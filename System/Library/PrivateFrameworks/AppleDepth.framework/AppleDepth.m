uint64_t getterDummy(objc_object *a1, objc_selector *a2)
{
  return 0;
}

void sub_215F179E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F17A8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F17B84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F18EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_215F194F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_215F1989C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t PixelBufferUtils::componentsPerPixelForPixelFormat(PixelBufferUtils *this, uint64_t a2)
{
  unint64_t v4 = 4;
  if ((int)this > 1380401728)
  {
    if ((int)this > 1717856626)
    {
      if ((int)this <= 1751411058)
      {
        if (this == 1717856627) {
          return 1;
        }
        int v5 = 1751410032;
      }
      else
      {
        if (this == 1751411059 || this == 1919365990) {
          return 1;
        }
        int v5 = 1932996149;
      }
      goto LABEL_31;
    }
    if ((int)this > 1380411456)
    {
      if (this == 1380411457) {
        return v4;
      }
      if (this == 1647392359) {
        return 1;
      }
      int v5 = 1717855600;
      goto LABEL_31;
    }
    if (this == 1380401729) {
      return v4;
    }
    int v6 = 1380410945;
LABEL_27:
    if (this == v6) {
      return v4;
    }
    goto LABEL_38;
  }
  if ((int)this > 875704437)
  {
    if ((int)this > 1111970368)
    {
      if (this == 1111970369) {
        return v4;
      }
      if (this == 1278226488) {
        return 1;
      }
      int v5 = 1278226536;
      goto LABEL_31;
    }
    if (this == 875704438) {
      goto LABEL_34;
    }
    int v6 = 1094862674;
    goto LABEL_27;
  }
  if ((int)this > 825437746)
  {
    if (this != 825437747)
    {
      if (this == 843264104) {
        return 2;
      }
      if (this != 875704422) {
        goto LABEL_38;
      }
LABEL_34:
      if (a2) {
        return 2;
      }
      else {
        return 1;
      }
    }
    return 1;
  }
  if (this == 32) {
    return v4;
  }
  int v5 = 825306677;
LABEL_31:
  if (this == v5) {
    return 1;
  }
LABEL_38:
  v8 = CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  v9 = [v8 objectForKeyedSubscript:@"BitsPerComponent"];
  if (v9)
  {
    unint64_t v10 = PixelBufferUtils::pixelSizeForPixelFormat(this, a2);
    [v9 floatValue];
    unint64_t v4 = (unint64_t)(float)((float)v10 / ceilf(v11 * 0.125));
  }
  else
  {

    PixelBufferUtils::pixelFormatAsString((unint64_t)this, (char *)__p);
    if (v14 >= 0) {
      v12 = __p;
    }
    else {
      v12 = (void **)__p[0];
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "componentsPerPixelForPixelFormat", 508, this, v12);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  return v4;
}

void sub_215F19C24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_215F19D90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t PixelBufferUtils::planeCountForPixelFormat(PixelBufferUtils *this)
{
  if ((int)this > 1380401728)
  {
    if ((int)this > 1717856626)
    {
      if ((int)this <= 1751411058)
      {
        if (this == 1717856627) {
          return 0;
        }
        int v2 = 1751410032;
      }
      else
      {
        if (this == 1751411059) {
          return 0;
        }
        if (this == 1919365990) {
          return 3;
        }
        int v2 = 1932996149;
      }
    }
    else if ((int)this <= 1380411456)
    {
      if (this == 1380401729) {
        return 0;
      }
      int v2 = 1380410945;
    }
    else
    {
      if (this == 1380411457 || this == 1647392359) {
        return 0;
      }
      int v2 = 1717855600;
    }
LABEL_29:
    if (this != v2) {
      goto LABEL_34;
    }
    return 0;
  }
  if ((int)this > 875704437)
  {
    if ((int)this <= 1111970368)
    {
      if (this == 875704438) {
        return 2;
      }
      int v2 = 1094862674;
    }
    else
    {
      if (this == 1111970369 || this == 1278226488) {
        return 0;
      }
      int v2 = 1278226536;
    }
    goto LABEL_29;
  }
  if ((int)this <= 825437746)
  {
    if (this == 32) {
      return 0;
    }
    int v2 = 825306677;
    goto LABEL_29;
  }
  if (this == 825437747 || this == 843264104) {
    return 0;
  }
  if (this == 875704422) {
    return 2;
  }
LABEL_34:
  int v5 = CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  if (!v5)
  {
    PixelBufferUtils::pixelFormatAsString((unint64_t)this, (char *)__p);
    if (v11 >= 0) {
      v9 = __p;
    }
    else {
      v9 = (void **)__p[0];
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "planeCountForPixelFormat", 554, this, v9);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  int v6 = v5;
  v7 = [v5 objectForKeyedSubscript:*MEMORY[0x263F042C8]];
  v8 = v7;
  if (v7) {
    uint64_t v3 = [v7 count];
  }
  else {
    uint64_t v3 = 0;
  }

  return v3;
}

void sub_215F1A064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_215F1A080(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id findNetworkSupportingFile(NSString *a1, NSString *a2, NSString *a3, NSString *a4)
{
  v7 = a1;
  v8 = a2;
  v9 = a3;
  unint64_t v10 = a4;
  char v11 = [(NSString *)v8 stringByDeletingLastPathComponent];
  v12 = [v11 stringByAppendingPathComponent:v7];

  v13 = [MEMORY[0x263F08850] defaultManager];
  char v14 = [v13 fileExistsAtPath:v12];

  if (v14) {
    goto LABEL_2;
  }
  int v16 = ![(NSString *)v8 isEqualToString:v9];
  if (!v10) {
    LOBYTE(v16) = 1;
  }
  if (v16)
  {
    id v15 = 0;
  }
  else
  {
    v17 = [(NSString *)v10 stringByDeletingLastPathComponent];
    uint64_t v18 = [v17 stringByAppendingPathComponent:v7];

    v19 = [MEMORY[0x263F08850] defaultManager];
    char v20 = [v19 fileExistsAtPath:v18];

    if (v20)
    {
      v12 = (void *)v18;
LABEL_2:
      id v15 = v12;
      v12 = v15;
      goto LABEL_10;
    }
    id v15 = 0;
    v12 = (void *)v18;
  }
LABEL_10:

  return v15;
}

void sub_215F1A204(_Unwind_Exception *a1)
{
  v7 = v5;

  _Unwind_Resume(a1);
}

void sub_215F1A580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NSString *findModel(NSString *a1, NSString *a2)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v3 = a1;
  unint64_t v4 = a2;
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    v31 = v3;
    __int16 v32 = 2112;
    v33 = v4;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "Searching for %@/%@*", buf, 0x16u);
  }
  int v5 = [MEMORY[0x263F08850] defaultManager];
  int v6 = [v5 contentsOfDirectoryAtPath:v3 error:0];

  if (v6)
  {
    v7 = (void *)MEMORY[0x263F08A98];
    v8 = [(NSString *)v4 stringByAppendingString:@"-"];
    v29 = [v7 predicateWithFormat:@"(SELF == %@) || (SELF BEGINSWITH %@)", v4, v8];

    v9 = [v6 filteredArrayUsingPredicate:v29];
    if (![v9 count])
    {
      v21 = 0;
LABEL_24:

      goto LABEL_25;
    }
    if ((unint64_t)[v9 count] >= 2)
    {
      unint64_t v10 = +[ADDeviceConfiguration getDeviceName];
      char v11 = [v10 stringByReplacingOccurrencesOfString:@"AP" withString:&stru_26C6879A8];

      v12 = [v11 stringByReplacingOccurrencesOfString:@"DEV" withString:&stru_26C6879A8];

      v13 = [MEMORY[0x263F08A98] predicateWithFormat:@"(SELF CONTAINS[c] %@)", v12];
      char v14 = [v9 filteredArrayUsingPredicate:v13];
      if ([v14 count])
      {
        id v15 = v14;

        v9 = v15;
      }
    }
    if ((unint64_t)[v9 count] >= 2
      && os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v31 = (NSString *)v9;
      _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "WARNING: found multiple networks matching query. First one will be loaded (might not be what you intended). Found paths: %@", buf, 0xCu);
    }
    int v16 = [v9 objectAtIndexedSubscript:0];
    v17 = [NSString stringWithFormat:@"%@/%@/%@", v3, v16, @"model.espresso.net"];
    uint64_t v18 = [MEMORY[0x263F08850] defaultManager];
    int v19 = [v18 fileExistsAtPath:v17];

    if (v19)
    {
      char v20 = v17;
    }
    else
    {
      v22 = [NSString stringWithFormat:@"%@/%@/%@", v3, v16, @"model.mil"];

      v23 = [MEMORY[0x263F08850] defaultManager];
      int v24 = [v23 fileExistsAtPath:v22];

      if (v24)
      {
        char v20 = v22;
      }
      else
      {
        v25 = [NSString stringWithFormat:@"%@/%@/%@", v3, v16, @"model.bundle"];

        v26 = [MEMORY[0x263F08850] defaultManager];
        int v27 = [v26 fileExistsAtPath:v25];

        if (!v27)
        {
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543362;
            v31 = v25;
            _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Folder exists but does not contain espresso network file (Looking for: %{public}@)", buf, 0xCu);
          }
          v21 = 0;
          goto LABEL_23;
        }
        char v20 = v25;
      }
    }
    v25 = v20;
    v21 = v20;
LABEL_23:

    goto LABEL_24;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138543362;
    v31 = v3;
    _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Failed getting content of directory: %{public}@", buf, 0xCu);
  }
  v21 = 0;
LABEL_25:

  return v21;
}

void sub_215F1AA88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

NSString *bundleE5mlIfNeeded(NSString *a1, NSString *a2, NSString *a3, unsigned int a4)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  v7 = a1;
  v8 = a2;
  v9 = a3;
  unint64_t v10 = [(NSString *)v7 pathExtension];
  int v11 = [v10 isEqualToString:@"bundle"];

  if (v11 || !v9)
  {
    char v14 = v7;
    goto LABEL_78;
  }
  if (ADDebugUtilsADVerboseLogsEnabled)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
    *(_WORD *)buf = 0;
    v12 = &_os_log_internal;
    os_log_type_t v13 = OS_LOG_TYPE_DEFAULT;
  }
  else
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_INFO)) {
      goto LABEL_10;
    }
    *(_WORD *)buf = 0;
    v12 = &_os_log_internal;
    os_log_type_t v13 = OS_LOG_TYPE_INFO;
  }
  _os_log_impl(&dword_215F16000, v12, v13, "model should be compiled for e5ml", buf, 2u);
LABEL_10:
  id v15 = [NSDictionary dictionaryWithContentsOfFile:v9];
  if (v15)
  {
    if (!a4 || ([MEMORY[0x263F28048] hasANE] & 1) != 0)
    {
      v57 = [(NSString *)v7 stringByDeletingLastPathComponent];
      int v16 = [MEMORY[0x263F08C38] UUID];
      v56 = [v16 UUIDString];

      v17 = NSString;
      uint64_t v18 = crc32ForFolder(v57);
      v51 = objc_msgSend(v17, "stringWithFormat:", @"crc32_%u_isANE_%d_espresso_%s", v18, a4, espresso_get_version_string());
      v55 = -[NSString stringByAppendingPathComponent:](v8, "stringByAppendingPathComponent:");
      v53 = [v55 stringByAppendingPathComponent:@"model.bundle"];
      v50 = [(NSString *)v8 stringByAppendingPathComponent:v56];
      v58 = [v50 stringByAppendingPathComponent:@"model.bundle"];
      v52 = [v50 stringByAppendingPathComponent:@"custom_options_net.plist"];
      [MEMORY[0x263F08850] defaultManager];
      v54 = id v67 = 0;
      LODWORD(v17) = [v54 createDirectoryAtPath:v8 withIntermediateDirectories:1 attributes:0 error:&v67];
      id v19 = v67;
      char v20 = v19;
      if (!v17
        || (id v66 = v19,
            v21 = [v54 createDirectoryAtPath:v55 withIntermediateDirectories:0 attributes:0 error:&v66], v22 = v66, v20, char v20 = v22, (v21 & 1) == 0)&& objc_msgSend(v22, "code") != 516)
      {
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          v38 = [v20 localizedDescription];
          *(_DWORD *)buf = 138412290;
          *(void *)&uint8_t buf[4] = v38;
          _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "failed to create folder structure needed for compilation. Error: %@", buf, 0xCu);
        }
        goto LABEL_24;
      }
      if ([v22 code] == 516)
      {
        if (ADDebugUtilsADVerboseLogsEnabled)
        {
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_44;
          }
          *(_WORD *)buf = 0;
          v23 = &_os_log_internal;
          os_log_type_t v24 = OS_LOG_TYPE_DEFAULT;
        }
        else
        {
          if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_INFO)) {
            goto LABEL_46;
          }
          *(_WORD *)buf = 0;
          v23 = &_os_log_internal;
          os_log_type_t v24 = OS_LOG_TYPE_INFO;
        }
        _os_log_impl(&dword_215F16000, v23, v24, "model already compiled or being compiled, no need to recompile", buf, 2u);
        if (ADDebugUtilsADVerboseLogsEnabled)
        {
LABEL_44:
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            *(void *)&uint8_t buf[4] = 0x404E000000000000;
            uint64_t v34 = &_os_log_internal;
            os_log_type_t v35 = OS_LOG_TYPE_DEFAULT;
LABEL_48:
            _os_log_impl(&dword_215F16000, v34, v35, "waiting for model folder to appear (timeout: %.0f seconds)", buf, 0xCu);
            goto LABEL_49;
          }
          goto LABEL_49;
        }
LABEL_46:
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134217984;
          *(void *)&uint8_t buf[4] = 0x404E000000000000;
          uint64_t v34 = &_os_log_internal;
          os_log_type_t v35 = OS_LOG_TYPE_INFO;
          goto LABEL_48;
        }
LABEL_49:
        if (waitForFolder(v53, 60.0))
        {
          if (ADDebugUtilsADVerboseLogsEnabled)
          {
            if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              v36 = &_os_log_internal;
              os_log_type_t v37 = OS_LOG_TYPE_DEFAULT;
LABEL_57:
              _os_log_impl(&dword_215F16000, v36, v37, "model folder found", buf, 2u);
            }
          }
          else if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            v36 = &_os_log_internal;
            os_log_type_t v37 = OS_LOG_TYPE_INFO;
            goto LABEL_57;
          }
          char v14 = v53;
          goto LABEL_76;
        }
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          *(void *)&uint8_t buf[4] = v8;
          _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "timed out waiting for model folder. Consider removing folder %@ and try again.", buf, 0xCu);
        }
LABEL_24:
        char v14 = 0;
LABEL_76:

        goto LABEL_77;
      }
      v59[0] = MEMORY[0x263EF8330];
      v59[1] = 3221225472;
      v60 = ___Z18bundleE5mlIfNeededP8NSStringS0_S0_b_block_invoke;
      v61 = &unk_26425B8B8;
      id v62 = v54;
      v63 = v8;
      id v64 = v51;
      id v65 = v55;
      [v62 createDirectoryAtPath:v50 withIntermediateDirectories:1 attributes:0 error:0];
      v25 = NSString;
      ADCommonUtils::runtimePlatformANEProductString(buf);
      if (v69 >= 0) {
        v26 = buf;
      }
      else {
        v26 = *(unsigned char **)buf;
      }
      v49 = [v25 stringWithUTF8String:v26];
      if (v69 < 0) {
        operator delete(*(void **)buf);
      }
      int v27 = [(NSDictionary *)v15 objectForKeyedSubscript:@"isProfiling"];
      if ([v27 BOOLValue]) {
        int v28 = [(NSString *)v49 isEqualToString:@"H14G"];
      }
      else {
        int v28 = 0;
      }

      if (![(NSString *)v49 hasSuffix:@".N301"]
        || (-[NSDictionary objectForKeyedSubscript:](v15, "objectForKeyedSubscript:", @"experimentalModelPlatformOverride"), v29 = objc_claimAutoreleasedReturnValue(), int v30 = [v29 BOOLValue], v29, !v30))
      {
LABEL_63:
        prepareAneFlags(v15, v49, v52, v28);
        v48 = (NSString *)objc_claimAutoreleasedReturnValue();
        if (compileE5mlBundle(v7, v58, a4, v49, v52, v48))
        {
          [v62 removeItemAtPath:v52 error:0];
          v40 = [v62 enumeratorAtPath:v58];
          while (1)
          {
            v41 = [v40 nextObject];
            v42 = v41;
            if (!v41)
            {
              [v62 moveItemAtPath:v58 toPath:v53 error:0];
              char v14 = v53;
              goto LABEL_74;
            }
            v43 = [v41 pathExtension];
            int v44 = [v43 isEqualToString:@"hwx"];

            if (v44)
            {
              v45 = [(NSString *)v58 stringByAppendingPathComponent:v42];
              char v46 = verifyMachoFlags(v45, v15);

              if ((v46 & 1) == 0) {
                break;
              }
            }
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "compiled model flags verification failed", buf, 2u);
          }

          char v14 = 0;
LABEL_74:
        }
        else
        {
          char v14 = 0;
        }

        v60((uint64_t)v59);
        goto LABEL_76;
      }
      if (ADDebugUtilsADVerboseLogsEnabled)
      {
        v31 = v49;
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(void *)&uint8_t buf[4] = v49;
          __int16 v32 = &_os_log_internal;
          os_log_type_t v33 = OS_LOG_TYPE_DEFAULT;
LABEL_61:
          _os_log_impl(&dword_215F16000, v32, v33, "platform is %@ but compiling to generic platform instead", buf, 0xCu);
        }
      }
      else
      {
        v31 = v49;
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412290;
          *(void *)&uint8_t buf[4] = v49;
          __int16 v32 = &_os_log_internal;
          os_log_type_t v33 = OS_LOG_TYPE_INFO;
          goto LABEL_61;
        }
      }
      uint64_t v39 = [(NSString *)v31 stringByReplacingOccurrencesOfString:@".N301" withString:&stru_26C6879A8];

      int v28 = 1;
      v49 = (NSString *)v39;
      goto LABEL_63;
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "no ANE found to compile for", buf, 2u);
    }
  }
  else if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)&uint8_t buf[4] = v9;
    _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "failed reading e5rt compilation arguments at %@", buf, 0xCu);
  }
  char v14 = 0;
LABEL_77:

LABEL_78:
  return v14;
}

void sub_215F1B5A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,char a25,uint64_t a26,void (*a27)(char *),uint64_t a28,id a29,id a30,id a31,id a32)
{
  a27(&a25);
  _Unwind_Resume(a1);
}

void sub_215F1BB54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_215F1BE74(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F1BF40(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_215F1C16C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1C52C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F1C8C8(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);
  _Unwind_Resume(a1);
}

void sub_215F1CBBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1CC4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1CD0C(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F1CE1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1CFEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F1D348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);

  _Unwind_Resume(a1);
}

void ADCommonUtils::runtimePlatformANEVersionString(unsigned char *a1@<X8>)
{
  if (![MEMORY[0x263F28048] hasANE])
  {
    a1[23] = 0;
    *a1 = 0;
    return;
  }
  id v10 = [MEMORY[0x263F28048] aneSubType];
  id v3 = [v10 uppercaseString];
  unint64_t v4 = (const char *)[v3 UTF8String];
  size_t v5 = strlen(v4);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v7 = v5 | 7;
    }
    uint64_t v8 = v7 + 1;
    v9 = operator new(v7 + 1);
    *((void *)a1 + 1) = v6;
    *((void *)a1 + 2) = v8 | 0x8000000000000000;
    *(void *)a1 = v9;
    a1 = v9;
  }
  else
  {
    a1[23] = v5;
    if (!v5) {
      goto LABEL_11;
    }
  }
  memmove(a1, v4, v6);
LABEL_11:
  a1[v6] = 0;
}

void sub_215F1D4DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F1D594(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1E030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);

  _Unwind_Resume(a1);
}

void sub_215F1E120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1E29C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1E360(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1ECC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_215F1F180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void ADCommonUtils::runtimePlatformANEProductString(unsigned char *a1@<X8>)
{
  if (![MEMORY[0x263F28048] hasANE])
  {
    a1[23] = 0;
    *a1 = 0;
    return;
  }
  id v3 = NSString;
  id v14 = [MEMORY[0x263F28048] aneSubType];
  unint64_t v4 = [MEMORY[0x263F28048] aneSubTypeVariant];
  size_t v5 = [MEMORY[0x263F28048] aneSubTypeProductVariant];
  size_t v6 = [v3 stringWithFormat:@"%@%@%@", v14, v4, v5];
  id v7 = [v6 uppercaseString];
  uint64_t v8 = (const char *)[v7 UTF8String];
  size_t v9 = strlen(v8);
  if (v9 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v10 = v9;
  if (v9 >= 0x17)
  {
    uint64_t v11 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v11 = v9 | 7;
    }
    uint64_t v12 = v11 + 1;
    os_log_type_t v13 = operator new(v11 + 1);
    *((void *)a1 + 1) = v10;
    *((void *)a1 + 2) = v12 | 0x8000000000000000;
    *(void *)a1 = v13;
    a1 = v13;
  }
  else
  {
    a1[23] = v9;
    if (!v9) {
      goto LABEL_11;
    }
  }
  memmove(a1, v8, v10);
LABEL_11:
  a1[v10] = 0;
}

void sub_215F1F3A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_215F1F530(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1F5BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1F778(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F1FA20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_215F200B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_215F201CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F202C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F20434(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F2081C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F20C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_215F20E18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F21058(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F211C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F2126C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F214CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F217E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F218A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F21BE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_215F2215C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F22284(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F22324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F22474(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F224E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F2260C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F226C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F22830(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F22D24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void embedDepthMapUsingFourierEncoding<half>(__CVBuffer *a1, void *a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  id v161 = a4;
  uint64_t v10 = [v161 data];
  uint64_t v11 = [v161 batchBytes];
  uint64_t v12 = [v161 channelBytes];
  size_t v169 = [v161 channelBytes];
  uint64_t v13 = [v161 rowBytes];
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  memset(&v187, 0, sizeof(v187));
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v187);
  uint64_t v14 = v11 * a6;
  uint64_t v15 = v12 * a5;
  int v16 = (char *)(v10 + v11 * a6 + v12 * a5);
  uint64_t v17 = *a2;
  pixelBuffer = a1;
  v171 = a2;
  if (a2[1] == *a2) {
    goto LABEL_19;
  }
  size_t rowBytes = v187.rowBytes;
  size_t v19 = v187.height * v187.rowBytes;
  vImagePixelCount height = v187.height;
  if (!v187.height || (vImagePixelCount width = v187.width) == 0)
  {
    unint64_t v44 = 0;
    do
    {
      bzero(v16, v19);
      ++v44;
      v16 += v169;
    }
    while (v44 < (uint64_t)(a2[1] - *a2) >> 2);
    goto LABEL_19;
  }
  data = (char *)v187.data;
  size_t v22 = v169;
  vImagePixelCount v166 = v187.height * v187.rowBytes;
  if (v187.width >= 4)
  {
    uint64_t v97 = 0;
    uint64_t v159 = v14 + v10 + v15;
    vImagePixelCount v173 = v187.width & 0xFFFFFFFFFFFFFFFELL;
    while (1)
    {
      size_t v98 = v159 + v22 * v97;
      uint64_t v163 = v97;
      float v177 = *(float *)(v17 + 4 * v97);
      bzero(v16, v19);
      uint64_t v100 = 0;
      v101 = data;
      v164 = v16;
      do
      {
        if (v98 + v13 * v100 - (unint64_t)&data[v100 * rowBytes] < 4)
        {
          vImagePixelCount v102 = 0;
          do
          {
LABEL_73:
            __asm { FCMP            H0, #0 }
            if (!_ZF)
            {
              __asm { FCVT            S0, H0 }
              *(float *)_D0.i32 = sinf(v177 * _S0);
              __asm { FCVT            H0, S0 }
              *(_WORD *)&v16[2 * v102] = _D0.i16[0];
            }
            ++v102;
          }
          while (width != v102);
          goto LABEL_61;
        }
        v103 = data;
        uint64_t v104 = 0;
        vImagePixelCount v105 = v173;
        do
        {
          _D0.i32[0] = *(_DWORD *)&v101[v104];
          uint32x4_t v185 = vmovl_u16((uint16x4_t)vmvn_s8((int8x8_t)vceqz_f16(_D0)));
          float32x2_t v106 = vmul_n_f32((float32x2_t)*(_OWORD *)&vcvtq_f32_f16(_D0), v177);
          float v179 = v106.f32[0];
          float v181 = sinf(v106.f32[1]);
          *(float *)_D0.i32 = sinf(v179);
          *(float *)&_D0.i32[1] = v181;
          if (v185.i8[0])
          {
            __asm { FCVT            H1, S0 }
            *(_WORD *)&v16[v104] = _H1;
          }
          if (v185.i8[4])
          {
            _S0 = v181;
            __asm { FCVT            H0, S0 }
            *(_WORD *)&v16[v104 + 2] = LOWORD(_S0);
          }
          v104 += 4;
          v105 -= 2;
        }
        while (v105);
        vImagePixelCount v102 = v173;
        data = v103;
        if (width != v173) {
          goto LABEL_73;
        }
LABEL_61:
        ++v100;
        v16 += v13;
        v101 += rowBytes;
      }
      while (v100 != height);
      uint64_t v97 = v163 + 1;
      size_t v22 = v169;
      a2 = v171;
      int v16 = &v164[v169];
      uint64_t v17 = *v171;
      size_t v19 = v166;
      if (v163 + 1 >= (unint64_t)((uint64_t)(v171[1] - *v171) >> 2)) {
        goto LABEL_19;
      }
    }
  }
  unint64_t v23 = 0;
  uint64_t v24 = v14 + v15 + v10 + 4;
  v25 = (char *)v187.data + 4;
  do
  {
    float v26 = *(float *)(v17 + 4 * v23);
    int v27 = v16;
    bzero(v16, v19);
    int v28 = v25;
    v29 = (_WORD *)v24;
    vImagePixelCount v30 = height;
    do
    {
      __asm { FCMP            H0, #0 }
      if (!_ZF)
      {
        __asm { FCVT            S0, H0 }
        _S0 = sinf(v26 * _S0);
        __asm { FCVT            H0, S0 }
        *(v29 - 2) = LOWORD(_S0);
      }
      if (width != 1)
      {
        __asm { FCMP            H0, #0 }
        if (!_ZF)
        {
          __asm { FCVT            S0, H0 }
          _S0 = sinf(v26 * _S0);
          __asm { FCVT            H0, S0 }
          *(v29 - 1) = LOWORD(_S0);
        }
        if (width != 2)
        {
          __asm { FCMP            H0, #0 }
          if (!_ZF)
          {
            __asm { FCVT            S0, H0 }
            _S0 = sinf(v26 * _S0);
            __asm { FCVT            H0, S0 }
            _WORD *v29 = LOWORD(_S0);
          }
        }
      }
      v29 = (_WORD *)((char *)v29 + v13);
      v28 += rowBytes;
      --v30;
    }
    while (v30);
    ++v23;
    a2 = v171;
    int v16 = &v27[v169];
    uint64_t v17 = *v171;
    v24 += v169;
    size_t v19 = v166;
  }
  while (v23 < (uint64_t)(v171[1] - *v171) >> 2);
LABEL_19:
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
  uint64_t v45 = [v161 channelBytes];
  uint64_t v46 = [v161 rowBytes];
  CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
  memset(&v187, 0, sizeof(v187));
  PixelBufferUtils::asVImageBuffer(pixelBuffer, *MEMORY[0x263F001A8], &v187);
  uint64_t v47 = *a2;
  if (a2[1] == *a2) {
    goto LABEL_37;
  }
  size_t v48 = v187.rowBytes;
  size_t v49 = v187.height * v187.rowBytes;
  vImagePixelCount v170 = v187.height * v187.rowBytes;
  vImagePixelCount v176 = v187.height;
  if (!v187.height || (vImagePixelCount v50 = v187.width) == 0)
  {
    unint64_t v69 = 0;
    do
    {
      bzero(v16, v170);
      ++v69;
      v16 += v45;
    }
    while (v69 < (uint64_t)(a2[1] - *a2) >> 2);
    goto LABEL_37;
  }
  uint64_t v162 = v45;
  v51 = (char *)v187.data;
  if (v187.width >= 4)
  {
    uint64_t v111 = 0;
    vImagePixelCount v174 = v187.width & 0xFFFFFFFFFFFFFFFELL;
    v165 = v16;
    uint64_t v112 = v45;
    while (1)
    {
      v113 = &v165[v112 * v111];
      uint64_t v160 = v111;
      float v178 = *(float *)(v47 + 4 * v111);
      bzero(v16, v49);
      uint64_t v115 = 0;
      v116 = v51;
      v168 = v16;
      v117 = v16;
      do
      {
        if ((unint64_t)(&v113[v46 * v115] - &v51[v115 * v48]) < 4)
        {
          vImagePixelCount v118 = 0;
          do
          {
LABEL_90:
            __asm { FCMP            H0, #0 }
            if (!_ZF)
            {
              __asm { FCVT            S0, H0 }
              *(float *)_D0.i32 = cosf(v178 * _S0);
              __asm { FCVT            H0, S0 }
              *(_WORD *)&v117[2 * v118] = _D0.i16[0];
            }
            ++v118;
          }
          while (v50 != v118);
          goto LABEL_78;
        }
        v119 = v113;
        v120 = v51;
        uint64_t v121 = 0;
        vImagePixelCount v122 = v174;
        do
        {
          _D0.i32[0] = *(_DWORD *)&v116[v121];
          uint32x4_t v186 = vmovl_u16((uint16x4_t)vmvn_s8((int8x8_t)vceqz_f16(_D0)));
          float32x2_t v123 = vmul_n_f32((float32x2_t)*(_OWORD *)&vcvtq_f32_f16(_D0), v178);
          float v180 = v123.f32[0];
          float v182 = cosf(v123.f32[1]);
          *(float *)_D0.i32 = cosf(v180);
          *(float *)&_D0.i32[1] = v182;
          if (v186.i8[0])
          {
            __asm { FCVT            H1, S0 }
            *(_WORD *)&v117[v121] = _H1;
          }
          if (v186.i8[4])
          {
            _S0 = v182;
            __asm { FCVT            H0, S0 }
            *(_WORD *)&v117[v121 + 2] = LOWORD(_S0);
          }
          v121 += 4;
          v122 -= 2;
        }
        while (v122);
        vImagePixelCount v118 = v174;
        v51 = v120;
        v113 = v119;
        if (v50 != v174) {
          goto LABEL_90;
        }
LABEL_78:
        ++v115;
        v117 += v46;
        v116 += v48;
      }
      while (v115 != v176);
      uint64_t v111 = v160 + 1;
      size_t v49 = v170;
      uint64_t v112 = v162;
      int v16 = &v168[v162];
      uint64_t v47 = *v171;
      if (v160 + 1 >= (unint64_t)((uint64_t)(v171[1] - *v171) >> 2)) {
        goto LABEL_37;
      }
    }
  }
  unint64_t v52 = 0;
  v53 = v16 + 4;
  v54 = (char *)v187.data + 4;
  do
  {
    float v55 = *(float *)(v47 + 4 * v52);
    v56 = v16;
    bzero(v16, v49);
    v57 = v54;
    v58 = v53;
    vImagePixelCount v59 = v176;
    do
    {
      __asm { FCMP            H0, #0 }
      if (!_ZF)
      {
        __asm { FCVT            S0, H0 }
        _S0 = cosf(v55 * _S0);
        __asm { FCVT            H0, S0 }
        *(v58 - 2) = LOWORD(_S0);
      }
      if (v50 != 1)
      {
        __asm { FCMP            H0, #0 }
        if (!_ZF)
        {
          __asm { FCVT            S0, H0 }
          _S0 = cosf(v55 * _S0);
          __asm { FCVT            H0, S0 }
          *(v58 - 1) = LOWORD(_S0);
        }
        if (v50 != 2)
        {
          __asm { FCMP            H0, #0 }
          if (!_ZF)
          {
            __asm { FCVT            S0, H0 }
            _S0 = cosf(v55 * _S0);
            __asm { FCVT            H0, S0 }
            _WORD *v58 = LOWORD(_S0);
          }
        }
      }
      v58 = (_WORD *)((char *)v58 + v46);
      v57 += v48;
      --v59;
    }
    while (v59);
    ++v52;
    int v16 = &v56[v162];
    size_t v49 = v170;
    uint64_t v47 = *v171;
    v53 = (_WORD *)((char *)v53 + v162);
  }
  while (v52 < (uint64_t)(v171[1] - *v171) >> 2);
LABEL_37:
  v167 = v16;
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
  uint64_t v184 = [v161 channelBytes];
  uint64_t v70 = [v161 rowBytes];
  CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
  memset(&v187, 0, sizeof(v187));
  PixelBufferUtils::asVImageBuffer(pixelBuffer, *MEMORY[0x263F001A8], &v187);
  uint64_t v71 = *a3;
  if (a3[1] == *a3) {
    goto LABEL_55;
  }
  size_t v72 = v187.rowBytes;
  vImagePixelCount v73 = v187.height;
  size_t v74 = v187.height * v187.rowBytes;
  size_t v75 = v187.height * v187.rowBytes;
  if (!v187.height || (vImagePixelCount v76 = v187.width) == 0)
  {
    unint64_t v95 = 0;
    v96 = v167;
    do
    {
      bzero(v96, v75);
      ++v95;
      v96 += v184;
    }
    while (v95 < (a3[1] - *a3) >> 2);
    goto LABEL_55;
  }
  v77 = (char *)v187.data;
  if (v187.width >= 4)
  {
    unint64_t v128 = 0;
    vImagePixelCount v129 = v187.width & 0xFFFFFFFFFFFFFFFCLL;
    v183 = (char *)v187.data + 4;
    v130 = v167;
    v131 = v167;
    uint64_t v132 = v184;
    while (1)
    {
      v133 = &v130[v132 * v128];
      float v134 = *(float *)(v71 + 4 * v128);
      bzero(v131, v74);
      uint64_t v137 = 0;
      v138 = v77;
      v139 = v183;
      v140 = v131;
      do
      {
        if ((unint64_t)(&v133[v70 * v137] - &v77[v137 * v72]) < 8)
        {
          unint64_t v141 = 0;
          do
          {
LABEL_111:
            __asm { FCMP            H0, #0 }
            if (!_ZF)
            {
              __asm { FCVT            S0, H0 }
              _S0 = v134 * _S0;
              __asm { FCVT            H0, S0 }
              *(_WORD *)&v140[2 * v141] = LOWORD(_S0);
            }
            ++v141;
          }
          while (v76 != v141);
          goto LABEL_95;
        }
        uint64_t v142 = 0;
        unint64_t v143 = v76 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          _Q1.i32[0] = *(_DWORD *)&v139[v142 - 4];
          _D0.i32[0] = *(_DWORD *)&v139[v142];
          uint32x4_t v144 = vmovl_u16((uint16x4_t)vmvn_s8((int8x8_t)vceqz_f16(*(float16x4_t *)_Q1.i8)));
          if (v144.i8[0])
          {
            __asm { FCVT            S3, H1 }
            _S3 = v134 * _S3;
            __asm { FCVT            H3, S3 }
            *(_WORD *)&v140[v142] = LOWORD(_S3);
          }
          if (v144.i8[4])
          {
            _H1 = _Q1.i16[1];
            __asm { FCVT            S1, H1 }
            _S1 = v134 * _S1;
            __asm { FCVT            H1, S1 }
            *(_WORD *)&v140[v142 + 2] = LOWORD(_S1);
          }
          _Q1 = vmovl_u16((uint16x4_t)vmvn_s8((int8x8_t)vceqz_f16(_D0)));
          if (_Q1.i8[0])
          {
            __asm { FCVT            S2, H0 }
            _S2 = v134 * _S2;
            __asm { FCVT            H2, S2 }
            *(_WORD *)&v140[v142 + 4] = LOWORD(_S2);
          }
          if (_Q1.i8[4])
          {
            _H0 = _D0.i16[1];
            __asm { FCVT            S0, H0 }
            _S0 = v134 * _S0;
            __asm { FCVT            H0, S0 }
            *(_WORD *)&v140[v142 + 6] = LOWORD(_S0);
          }
          v142 += 8;
          v143 -= 4;
        }
        while (v143);
        unint64_t v141 = v76 & 0xFFFFFFFFFFFFFFFCLL;
        if (v76 != v129) {
          goto LABEL_111;
        }
LABEL_95:
        ++v137;
        v140 += v70;
        v139 += v72;
        v138 += v72;
      }
      while (v137 != v73);
      ++v128;
      uint64_t v132 = v184;
      v131 += v184;
      uint64_t v71 = *a3;
      v130 = v167;
      size_t v74 = v73 * v72;
      if (v128 >= (a3[1] - *a3) >> 2) {
        goto LABEL_55;
      }
    }
  }
  unint64_t v78 = 0;
  v79 = v167;
  v80 = v167 + 4;
  v81 = (char *)v187.data + 4;
  do
  {
    float v82 = *(float *)(v71 + 4 * v78);
    bzero(v79, v74);
    v83 = v81;
    v84 = v80;
    vImagePixelCount v85 = v73;
    do
    {
      __asm { FCMP            H0, #0 }
      if (!_ZF)
      {
        __asm { FCVT            S0, H0 }
        _S0 = v82 * _S0;
        __asm { FCVT            H0, S0 }
        *(v84 - 2) = LOWORD(_S0);
      }
      if (v76 != 1)
      {
        __asm { FCMP            H0, #0 }
        if (!_ZF)
        {
          __asm { FCVT            S0, H0 }
          _S0 = v82 * _S0;
          __asm { FCVT            H0, S0 }
          *(v84 - 1) = LOWORD(_S0);
        }
        if (v76 != 2)
        {
          __asm { FCMP            H0, #0 }
          if (!_ZF)
          {
            __asm { FCVT            S0, H0 }
            _S0 = v82 * _S0;
            __asm { FCVT            H0, S0 }
            _WORD *v84 = LOWORD(_S0);
          }
        }
      }
      v84 = (_WORD *)((char *)v84 + v70);
      v83 += v72;
      --v85;
    }
    while (v85);
    ++v78;
    v79 += v184;
    uint64_t v71 = *a3;
    v80 = (_WORD *)((char *)v80 + v184);
    size_t v74 = v73 * v72;
  }
  while (v78 < (a3[1] - *a3) >> 2);
LABEL_55:
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
}

void sub_215F2376C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void embedDepthMapUsingFourierEncoding<float>(__CVBuffer *a1, void *a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  id v123 = a4;
  uint64_t v10 = [v123 data];
  uint64_t v11 = [v123 batchBytes];
  uint64_t v12 = [v123 channelBytes];
  size_t v131 = [v123 channelBytes];
  uint64_t v13 = [v123 rowBytes];
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  memset(&v149, 0, sizeof(v149));
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v149);
  uint64_t v14 = v11 * a6;
  uint64_t v15 = v12 * a5;
  int v16 = (char *)(v10 + v11 * a6 + v12 * a5);
  uint64_t v17 = *a2;
  pixelBuffer = a1;
  v133 = a2;
  if (a2[1] == *a2) {
    goto LABEL_19;
  }
  size_t rowBytes = v149.rowBytes;
  size_t v19 = v149.height * v149.rowBytes;
  vImagePixelCount height = v149.height;
  if (!v149.height || (vImagePixelCount width = v149.width) == 0)
  {
    unint64_t v33 = 0;
    do
    {
      bzero(v16, v19);
      ++v33;
      v16 += v131;
    }
    while (v33 < (uint64_t)(a2[1] - *a2) >> 2);
    goto LABEL_19;
  }
  data = (float *)v149.data;
  size_t v22 = v131;
  vImagePixelCount v128 = v149.height * v149.rowBytes;
  if (v149.width >= 4)
  {
    uint64_t v72 = 0;
    uint64_t v121 = v14 + v10 + v15;
    vImagePixelCount v135 = v149.width & 0xFFFFFFFFFFFFFFFELL;
    while (1)
    {
      size_t v73 = v121 + v22 * v72;
      uint64_t v125 = v72;
      float v139 = *(float *)(v17 + 4 * v72);
      bzero(v16, v19);
      uint64_t v75 = 0;
      vImagePixelCount v76 = data;
      v126 = v16;
      do
      {
        if (v73 + v13 * v75 - ((unint64_t)data + v75 * rowBytes) < 8)
        {
          vImagePixelCount v77 = 0;
          do
          {
LABEL_73:
            float v84 = v76[v77];
            if (v84 != 0.0) {
              *(float *)&v16[4 * v77] = sinf(v139 * v84);
            }
            ++v77;
          }
          while (width != v77);
          goto LABEL_61;
        }
        unint64_t v78 = data;
        uint64_t v79 = 0;
        vImagePixelCount v80 = v135;
        do
        {
          float32x2_t v81 = *(float32x2_t *)&v76[v79];
          *(int8x8_t *)&long long v74 = vmvn_s8((int8x8_t)vceqz_f32(v81));
          long long v147 = v74;
          float32x2_t v82 = vmul_n_f32(v81, v139);
          float v141 = v82.f32[0];
          float v143 = sinf(v82.f32[1]);
          float v83 = sinf(v141);
          *((void *)&v74 + 1) = *((void *)&v147 + 1);
          if (v147) {
            *(float *)&v16[v79 * 4] = v83;
          }
          if (BYTE4(v147)) {
            *(float *)&v16[v79 * 4 + 4] = v143;
          }
          v79 += 2;
          v80 -= 2;
        }
        while (v80);
        vImagePixelCount v77 = v135;
        data = v78;
        if (width != v135) {
          goto LABEL_73;
        }
LABEL_61:
        ++v75;
        v16 += v13;
        vImagePixelCount v76 = (float *)((char *)v76 + rowBytes);
      }
      while (v75 != height);
      uint64_t v72 = v125 + 1;
      size_t v22 = v131;
      a2 = v133;
      int v16 = &v126[v131];
      uint64_t v17 = *v133;
      size_t v19 = v128;
      if (v125 + 1 >= (unint64_t)((uint64_t)(v133[1] - *v133) >> 2)) {
        goto LABEL_19;
      }
    }
  }
  unint64_t v23 = 0;
  uint64_t v24 = v14 + v15 + v10 + 8;
  v25 = (float *)((char *)v149.data + 8);
  do
  {
    float v26 = *(float *)(v17 + 4 * v23);
    int v27 = v16;
    bzero(v16, v19);
    int v28 = v25;
    v29 = (float *)v24;
    vImagePixelCount v30 = height;
    do
    {
      float v31 = *(v28 - 2);
      if (v31 != 0.0) {
        *(v29 - 2) = sinf(v26 * v31);
      }
      if (width != 1)
      {
        float v32 = *(v28 - 1);
        if (v32 != 0.0) {
          *(v29 - 1) = sinf(v26 * v32);
        }
        if (width != 2 && *v28 != 0.0) {
          float *v29 = sinf(v26 * *v28);
        }
      }
      v29 = (float *)((char *)v29 + v13);
      int v28 = (float *)((char *)v28 + rowBytes);
      --v30;
    }
    while (v30);
    ++v23;
    a2 = v133;
    int v16 = &v27[v131];
    uint64_t v17 = *v133;
    v24 += v131;
    size_t v19 = v128;
  }
  while (v23 < (uint64_t)(v133[1] - *v133) >> 2);
LABEL_19:
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
  uint64_t v34 = [v123 channelBytes];
  uint64_t v35 = [v123 rowBytes];
  CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
  memset(&v149, 0, sizeof(v149));
  PixelBufferUtils::asVImageBuffer(pixelBuffer, *MEMORY[0x263F001A8], &v149);
  uint64_t v36 = *a2;
  if (a2[1] == *a2) {
    goto LABEL_37;
  }
  size_t v37 = v149.rowBytes;
  size_t v38 = v149.height * v149.rowBytes;
  vImagePixelCount v132 = v149.height * v149.rowBytes;
  vImagePixelCount v138 = v149.height;
  if (!v149.height || (vImagePixelCount v39 = v149.width) == 0)
  {
    unint64_t v51 = 0;
    do
    {
      bzero(v16, v132);
      ++v51;
      v16 += v34;
    }
    while (v51 < (uint64_t)(a2[1] - *a2) >> 2);
    goto LABEL_37;
  }
  uint64_t v124 = v34;
  v40 = (float *)v149.data;
  if (v149.width >= 4)
  {
    uint64_t v85 = 0;
    vImagePixelCount v136 = v149.width & 0xFFFFFFFFFFFFFFFELL;
    v127 = v16;
    uint64_t v86 = v34;
    while (1)
    {
      v87 = &v127[v86 * v85];
      uint64_t v122 = v85;
      float v140 = *(float *)(v36 + 4 * v85);
      bzero(v16, v38);
      uint64_t v89 = 0;
      v90 = v40;
      v130 = v16;
      v91 = v16;
      do
      {
        if ((unint64_t)(&v87[v35 * v89] - ((char *)v40 + v89 * v37)) < 8)
        {
          vImagePixelCount v92 = 0;
          do
          {
LABEL_90:
            float v100 = v90[v92];
            if (v100 != 0.0) {
              *(float *)&v91[4 * v92] = cosf(v140 * v100);
            }
            ++v92;
          }
          while (v39 != v92);
          goto LABEL_78;
        }
        v93 = v87;
        v94 = v40;
        uint64_t v95 = 0;
        vImagePixelCount v96 = v136;
        do
        {
          float32x2_t v97 = *(float32x2_t *)&v90[v95];
          *(int8x8_t *)&long long v88 = vmvn_s8((int8x8_t)vceqz_f32(v97));
          long long v148 = v88;
          float32x2_t v98 = vmul_n_f32(v97, v140);
          float v142 = v98.f32[0];
          float v144 = cosf(v98.f32[1]);
          float v99 = cosf(v142);
          *((void *)&v88 + 1) = *((void *)&v148 + 1);
          if (v148) {
            *(float *)&v91[v95 * 4] = v99;
          }
          if (BYTE4(v148)) {
            *(float *)&v91[v95 * 4 + 4] = v144;
          }
          v95 += 2;
          v96 -= 2;
        }
        while (v96);
        vImagePixelCount v92 = v136;
        v40 = v94;
        v87 = v93;
        if (v39 != v136) {
          goto LABEL_90;
        }
LABEL_78:
        ++v89;
        v91 += v35;
        v90 = (float *)((char *)v90 + v37);
      }
      while (v89 != v138);
      uint64_t v85 = v122 + 1;
      size_t v38 = v132;
      uint64_t v86 = v124;
      int v16 = &v130[v124];
      uint64_t v36 = *v133;
      if (v122 + 1 >= (unint64_t)((uint64_t)(v133[1] - *v133) >> 2)) {
        goto LABEL_37;
      }
    }
  }
  unint64_t v41 = 0;
  v42 = (float *)(v16 + 8);
  v43 = (float *)((char *)v149.data + 8);
  do
  {
    float v44 = *(float *)(v36 + 4 * v41);
    uint64_t v45 = v16;
    bzero(v16, v38);
    uint64_t v46 = v43;
    uint64_t v47 = v42;
    vImagePixelCount v48 = v138;
    do
    {
      float v49 = *(v46 - 2);
      if (v49 != 0.0) {
        *(v47 - 2) = cosf(v44 * v49);
      }
      if (v39 != 1)
      {
        float v50 = *(v46 - 1);
        if (v50 != 0.0) {
          *(v47 - 1) = cosf(v44 * v50);
        }
        if (v39 != 2 && *v46 != 0.0) {
          *uint64_t v47 = cosf(v44 * *v46);
        }
      }
      uint64_t v47 = (float *)((char *)v47 + v35);
      uint64_t v46 = (float *)((char *)v46 + v37);
      --v48;
    }
    while (v48);
    ++v41;
    int v16 = &v45[v124];
    size_t v38 = v132;
    uint64_t v36 = *v133;
    v42 = (float *)((char *)v42 + v124);
  }
  while (v41 < (uint64_t)(v133[1] - *v133) >> 2);
LABEL_37:
  vImagePixelCount v129 = v16;
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
  uint64_t v146 = [v123 channelBytes];
  uint64_t v52 = [v123 rowBytes];
  CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
  memset(&v149, 0, sizeof(v149));
  PixelBufferUtils::asVImageBuffer(pixelBuffer, *MEMORY[0x263F001A8], &v149);
  uint64_t v53 = *a3;
  if (a3[1] == *a3) {
    goto LABEL_55;
  }
  size_t v54 = v149.rowBytes;
  vImagePixelCount v55 = v149.height;
  size_t v56 = v149.height * v149.rowBytes;
  size_t v57 = v149.height * v149.rowBytes;
  if (!v149.height || (vImagePixelCount v58 = v149.width) == 0)
  {
    unint64_t v70 = 0;
    uint64_t v71 = v129;
    do
    {
      bzero(v71, v57);
      ++v70;
      v71 += v146;
    }
    while (v70 < (a3[1] - *a3) >> 2);
    goto LABEL_55;
  }
  vImagePixelCount v59 = (float *)v149.data;
  if (v149.width >= 4)
  {
    unint64_t v101 = 0;
    vImagePixelCount v102 = v149.width & 0xFFFFFFFFFFFFFFFCLL;
    v145 = (char *)v149.data + 8;
    v103 = v129;
    uint64_t v104 = v129;
    uint64_t v105 = v146;
    while (1)
    {
      float32x2_t v106 = &v103[v105 * v101];
      float v107 = *(float *)(v53 + 4 * v101);
      bzero(v104, v56);
      uint64_t v108 = 0;
      v109 = v59;
      v110 = v145;
      uint64_t v111 = v104;
      do
      {
        if ((unint64_t)(&v106[v52 * v108] - ((char *)v59 + v108 * v54)) < 0x10)
        {
          unint64_t v112 = 0;
          do
          {
LABEL_111:
            float v119 = v109[v112];
            if (v119 != 0.0) {
              *(float *)&v111[4 * v112] = v107 * v119;
            }
            ++v112;
          }
          while (v58 != v112);
          goto LABEL_95;
        }
        uint64_t v113 = 0;
        unint64_t v114 = v58 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          float32x2_t v116 = *(float32x2_t *)&v110[v113 - 8];
          float32x2_t v115 = *(float32x2_t *)&v110[v113];
          int8x8_t v117 = vmvn_s8((int8x8_t)vceqz_f32(v116));
          if (v117.i8[0]) {
            *(float *)&v111[v113] = v107 * v116.f32[0];
          }
          if (v117.i8[4]) {
            *(float *)&v111[v113 + 4] = vmuls_lane_f32(v107, v116, 1);
          }
          int8x8_t v118 = vmvn_s8((int8x8_t)vceqz_f32(v115));
          if (v118.i8[0]) {
            *(float *)&v111[v113 + 8] = v107 * v115.f32[0];
          }
          if (v118.i8[4]) {
            *(float *)&v111[v113 + 12] = vmuls_lane_f32(v107, v115, 1);
          }
          v113 += 16;
          v114 -= 4;
        }
        while (v114);
        unint64_t v112 = v58 & 0xFFFFFFFFFFFFFFFCLL;
        if (v58 != v102) {
          goto LABEL_111;
        }
LABEL_95:
        ++v108;
        v111 += v52;
        v110 += v54;
        v109 = (float *)((char *)v109 + v54);
      }
      while (v108 != v55);
      ++v101;
      uint64_t v105 = v146;
      v104 += v146;
      uint64_t v53 = *a3;
      v103 = v129;
      size_t v56 = v55 * v54;
      if (v101 >= (a3[1] - *a3) >> 2) {
        goto LABEL_55;
      }
    }
  }
  unint64_t v60 = 0;
  v61 = v129;
  id v62 = (float *)(v129 + 8);
  v63 = (float *)((char *)v149.data + 8);
  do
  {
    float v64 = *(float *)(v53 + 4 * v60);
    bzero(v61, v56);
    id v65 = v63;
    id v66 = v62;
    vImagePixelCount v67 = v55;
    do
    {
      float v68 = *(v65 - 2);
      if (v68 != 0.0) {
        *(v66 - 2) = v64 * v68;
      }
      if (v58 != 1)
      {
        float v69 = *(v65 - 1);
        if (v69 != 0.0) {
          *(v66 - 1) = v64 * v69;
        }
        if (v58 != 2 && *v65 != 0.0) {
          *id v66 = v64 * *v65;
        }
      }
      id v66 = (float *)((char *)v66 + v52);
      id v65 = (float *)((char *)v65 + v54);
      --v67;
    }
    while (v67);
    ++v60;
    v61 += v146;
    uint64_t v53 = *a3;
    id v62 = (float *)((char *)v62 + v146);
    size_t v56 = v55 * v54;
  }
  while (v60 < (a3[1] - *a3) >> 2);
LABEL_55:
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
}

void sub_215F240E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_215F24260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  if (v14) {
  _Unwind_Resume(a1);
  }
}

void sub_215F24360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_215F26430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  _Unwind_Resume(a1);
}

void sub_215F26600(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F26610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_215F267B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(void *result, char *__src, char *a3, size_t __sz)
{
  size_t v6 = __src;
  id v7 = result;
  uint64_t v8 = result[2];
  size_t v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 2)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz >> 62) {
      goto LABEL_22;
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= __sz) {
      uint64_t v10 = __sz;
    }
    BOOL v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL;
    unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v10;
    }
    if (v12 >> 62) {
LABEL_22:
    }
      std::vector<float>::__throw_length_error[abi:ne180100]();
    uint64_t v13 = 4 * v12;
    result = operator new(4 * v12);
    size_t v9 = (char *)result;
    void *v7 = result;
    v7[1] = result;
    v7[2] = (char *)result + v13;
    size_t v14 = a3 - v6;
    if (v14) {
      result = memcpy(result, v6, v14);
    }
    uint64_t v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  uint64_t v15 = (void **)(result + 1);
  int v16 = (unsigned char *)result[1];
  unint64_t v17 = (v16 - v9) >> 2;
  if (v17 >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_21;
    }
    size_t v19 = (void *)*result;
LABEL_20:
    result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  uint64_t v18 = &__src[4 * v17];
  if (v16 != v9)
  {
    result = memmove((void *)*result, __src, v16 - v9);
    size_t v9 = (char *)*v15;
  }
  size_t v14 = a3 - v18;
  if (v14)
  {
    size_t v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  void *v15 = &v9[v14];
  return result;
}

void std::vector<float>::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_215F26974(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

uint64_t INSTRUMENTS_END()
{
  return kdebug_trace();
}

uint64_t INSTRUMENTS_START()
{
  return kdebug_trace();
}

double *ImageUtils::IntegralImage<double>(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  result = *(double **)(a2 + 8);
  if (*(void *)(a2 + 32) < 8 * v3 * (unint64_t)v4)
  {
    if (result)
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  if (v4)
  {
    size_t v6 = *(double **)(a1 + 8);
    double v7 = 0.0;
    unsigned int v8 = v4;
    do
    {
      double v9 = *v6++;
      double v7 = v7 + v9;
      *result++ = v7;
      --v8;
    }
    while (v8);
    if (v3 >= 2)
    {
      uint64_t v10 = *(double **)(a2 + 8);
      for (int i = 1; i != v3; ++i)
      {
        double v12 = 0.0;
        unsigned int v13 = v4;
        do
        {
          double v14 = *v6++;
          double v12 = v12 + v14;
          double v15 = *v10++;
          *result++ = v12 + v15;
          --v13;
        }
        while (v13);
      }
    }
  }
  return result;
}

double *ImageUtils::IntegralImage<float>(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  result = *(double **)(a2 + 8);
  if (*(void *)(a2 + 32) < 8 * v3 * (unint64_t)v4)
  {
    if (result)
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  if (v4)
  {
    size_t v6 = *(float **)(a1 + 8);
    double v7 = 0.0;
    unsigned int v8 = v4;
    do
    {
      float v9 = *v6++;
      double v7 = v7 + v9;
      *result++ = v7;
      --v8;
    }
    while (v8);
    if (v3 >= 2)
    {
      uint64_t v10 = *(double **)(a2 + 8);
      for (int i = 1; i != v3; ++i)
      {
        double v12 = 0.0;
        unsigned int v13 = v4;
        do
        {
          float v14 = *v6++;
          double v12 = v12 + v14;
          double v15 = *v10++;
          *result++ = v15 + v12;
          --v13;
        }
        while (v13);
      }
    }
  }
  return result;
}

uint64_t ImageUtils::AdaptiveThreshold<double>(uint64_t a1, unsigned int a2, int a3, uint64_t a4, double a5)
{
  unsigned int v9 = *(_DWORD *)(a1 + 20);
  if (!a3)
  {
    if (v9 <= a2 || (unsigned int v14 = *(_DWORD *)(a1 + 16), v14 <= a2)) {
LABEL_231:
    }
      __assert_rtn("AdaptiveThreshold", "ImageUtils.cpp", 67, "im.Cols() > meanKernelSize && im.Rows() > meanKernelSize");
    unsigned int v15 = *(_DWORD *)(a1 + 16);
    unsigned int v16 = *(_DWORD *)(a1 + 20);
    unsigned int v17 = v15;
    if (*(void *)(a4 + 32) < v14 * (unint64_t)v9)
    {
      if (*(void *)(a4 + 8) && *(unsigned char *)(a4 + 24)) {
        MEMORY[0x2166C5D70]();
      }
      operator new[]();
    }
    *(_DWORD *)(a4 + 16) = v14;
    *(_DWORD *)(a4 + 20) = v9;
    if (8 * v15 * (unint64_t)v9) {
      operator new[]();
    }
    v152 = 0;
    if (v9)
    {
      v153 = 0;
      uint64_t v154 = *(void *)(a1 + 8);
      double v155 = 0.0;
      unsigned int v156 = v9;
      do
      {
        double v155 = v155 + *(double *)((char *)v153 + v154);
        *v153++ = v155;
        --v156;
      }
      while (v156);
      if (v17 >= 2)
      {
        v157 = (double *)((char *)v153 + v154);
        for (int i = 1; i != v17; ++i)
        {
          double v159 = 0.0;
          unsigned int v160 = v9;
          do
          {
            double v161 = *v157++;
            double v159 = v159 + v161;
            double v162 = *v152++;
            *v153++ = v159 + v162;
            --v160;
          }
          while (v160);
        }
      }
    }
    unsigned int v163 = a2 - 1;
    if (a2 - 1 >= v17 || v163 >= v9) {
      __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
    }
    unsigned int v164 = *(_DWORD *)(a1 + 20);
    uint64_t v384 = v164 - 1;
    if (v384 >= v9) {
      __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
    }
    int v165 = ~a2;
    uint64_t v382 = v164 + ~a2;
    if (v382 >= v9) {
      __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
    }
    int v166 = *(_DWORD *)(a1 + 16);
    int v167 = v166 - 1;
    if (v166 - 1 >= v17) {
      __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
    }
    int v168 = v166 + v165;
    if (v166 + v165 >= v17) {
      __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
    }
    unsigned int v380 = *(_DWORD *)(a1 + 16);
    LODWORD(v169) = 0;
    unsigned int v170 = a2 >> 1;
    unsigned int v171 = (a2 >> 1) + (a2 & 1) - 1;
    uint64_t v172 = v9 - (a2 >> 1);
    uint64_t v390 = v14 - (a2 >> 1);
    uint64_t v173 = 8 * v163;
    uint64_t v386 = a2 - 1;
    uint64_t v174 = v9 * v163;
    uint64_t v175 = *(uint64_t *)(v173 + 8 * v174);
    uint64_t v176 = 8 * v384;
    uint64_t v177 = 8 * v174;
    uint64_t v178 = 8 * v382;
    double v179 = *(double *)(v176 + 8 * v174) - *(double *)(v178 + 8 * v174);
    uint64_t v180 = 8 * v167 * v9;
    uint64_t v378 = v168 * v9;
    double v181 = *(double *)(v173 + v180) - *(double *)(v173 + 8 * v378);
    double v182 = *(double *)(v176 + v180)
         + *(double *)(v178 + 8 * v378)
         - *(double *)(v178 + v180)
         - *(double *)(v176 + 8 * v378);
    v183 = *(double **)(a1 + 8);
    uint64_t v184 = *(int8x16_t **)(a4 + 8);
    double v185 = (double)(a2 * a2);
    int v388 = ~v171;
    unsigned int v186 = (a2 >> 1) + (a2 & 1);
    if (v186 <= 1) {
      uint64_t v187 = 1;
    }
    else {
      uint64_t v187 = v186;
    }
    uint64_t v188 = v187 & 0xFFFFFFF0;
    uint64_t v189 = 8 * v188;
    float64x2_t v190 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a5, 0);
    float64x2_t v191 = (float64x2_t)vdupq_lane_s64(v175, 0);
    float64x2_t v192 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v179, 0);
    unsigned int v193 = v9 - v9 * v186;
    unsigned int v194 = v9 + v9 * v170;
    uint64_t v195 = v187 - v172;
    unsigned int v196 = v187 - v170 - (a2 & 1);
    uint64_t v197 = v177 + 8 * v196;
    uint64_t v198 = v177 + 8 * (v187 + v170);
    int v199 = 1;
    v200.i64[0] = 0x101010101010101;
    v200.i64[1] = 0x101010101010101;
    while (1)
    {
      unsigned int v201 = v199;
      unsigned int v202 = v193;
      unsigned int v203 = v194;
      if (v187 <= 0xF) {
        break;
      }
      v205 = (int8x16_t *)((char *)v184 + v188);
      v206 = (float64x2_t *)v183;
      uint64_t v207 = v187 & 0xFFFFFFF0;
      do
      {
        float64x2_t v209 = v206[6];
        float64x2_t v208 = v206[7];
        float64x2_t v211 = v206[4];
        float64x2_t v210 = v206[5];
        float64x2_t v213 = v206[2];
        float64x2_t v212 = v206[3];
        float64x2_t v214 = *v206;
        float64x2_t v215 = v206[1];
        v206 += 8;
        *v184++ = vandq_s8(vuzp1q_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v191, vmulq_n_f64(vaddq_f64(v214, v190), v185)), (int32x4_t)vcgeq_f64(v191, vmulq_n_f64(vaddq_f64(v215, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v191, vmulq_n_f64(vaddq_f64(v213, v190), v185)), (int32x4_t)vcgeq_f64(v191, vmulq_n_f64(vaddq_f64(v212, v190), v185))))), vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(
                                                                      v191,
                                                                      vmulq_n_f64(vaddq_f64(v211, v190), v185)),
                                                         (int32x4_t)vcgeq_f64(v191, vmulq_n_f64(vaddq_f64(v210, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v191, vmulq_n_f64(vaddq_f64(v209, v190), v185)), (int32x4_t)vcgeq_f64(v191, vmulq_n_f64(vaddq_f64(v208, v190), v185)))))), v200);
        v207 -= 16;
      }
      while (v207);
      v183 = (double *)((char *)v183 + v189);
      int v204 = v187 & 0xFFFFFFF0;
      v216 = v183;
      if (v188 != v187) {
        goto LABEL_115;
      }
LABEL_117:
      if (v187 >= v172)
      {
        v183 = v216;
        int v220 = v187;
        if (v187 < v164) {
          goto LABEL_125;
        }
      }
      else
      {
        uint64_t v219 = 0;
        v183 = v216;
        do
        {
          if (v187 + v170 + v219 >= v16) {
            __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
          }
          if (v196 + v219 >= v16) {
            __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
          }
          v205->i8[v219] = (v216[v219] + a5) * v185 > *(double *)(v198 + 8 * v219) - *(double *)(v197 + 8 * v219);
          ++v183;
          ++v219;
        }
        while (v195 + v219);
        v205 = (int8x16_t *)((char *)v205 + v219);
        int v220 = v187 + v219;
        if ((int)v187 + (int)v219 < v164)
        {
LABEL_125:
          uint64_t v221 = v164 + ~v220;
          if (v221 <= 0xE) {
            goto LABEL_129;
          }
          uint64_t v222 = v221 + 1;
          uint64_t v223 = (v221 + 1) & 0x1FFFFFFF0;
          v220 += v223;
          v224 = v205;
          v225 = (float64x2_t *)v183;
          uint64_t v226 = v223;
          do
          {
            float64x2_t v228 = v225[6];
            float64x2_t v227 = v225[7];
            float64x2_t v230 = v225[4];
            float64x2_t v229 = v225[5];
            float64x2_t v232 = v225[2];
            float64x2_t v231 = v225[3];
            float64x2_t v233 = *v225;
            float64x2_t v234 = v225[1];
            v225 += 8;
            *v224++ = vandq_s8(vuzp1q_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v192, vmulq_n_f64(vaddq_f64(v233, v190), v185)), (int32x4_t)vcgeq_f64(v192, vmulq_n_f64(vaddq_f64(v234, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v192, vmulq_n_f64(vaddq_f64(v232, v190), v185)), (int32x4_t)vcgeq_f64(v192, vmulq_n_f64(vaddq_f64(v231, v190), v185))))), vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(
                                                                          v192,
                                                                          vmulq_n_f64(vaddq_f64(v230, v190), v185)),
                                                             (int32x4_t)vcgeq_f64(v192, vmulq_n_f64(vaddq_f64(v229, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v192, vmulq_n_f64(vaddq_f64(v228, v190), v185)), (int32x4_t)vcgeq_f64(v192, vmulq_n_f64(vaddq_f64(v227, v190), v185)))))), v200);
            v226 -= 16;
          }
          while (v226);
          v205 = (int8x16_t *)((char *)v205 + v223);
          v183 += v223;
          uint64_t v184 = v205;
          if (v222 != v223)
          {
LABEL_129:
            int v235 = v164 - v220;
            uint64_t v184 = v205;
            do
            {
              double v236 = *v183++;
              v184->i8[0] = (v236 + a5) * v185 > v179;
              uint64_t v184 = (int8x16_t *)((char *)v184 + 1);
              --v235;
            }
            while (v235);
          }
          goto LABEL_109;
        }
      }
      uint64_t v184 = v205;
LABEL_109:
      LODWORD(v169) = v169 + 1;
      int v199 = v201 + 1;
      unsigned int v193 = v202 + v16;
      unsigned int v194 = v203 + v16;
      if (v169 > v171)
      {
        if (v169 < v390)
        {
          uint64_t v376 = v180;
          uint64_t v169 = v201;
          uint64_t v237 = 8 * v196;
          uint64_t v238 = 8 * (v187 + v170);
          v239.i64[0] = 0x101010101010101;
          v239.i64[1] = 0x101010101010101;
          uint64_t v240 = v386;
          while (1)
          {
            if (v170 + v169 >= v17) {
              __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
            }
            if ((int)v169 + v388 >= v17) {
              __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
            }
            uint64_t v241 = (v170 + v169) * v16;
            uint64_t v242 = (v169 + v388) * v16;
            double v243 = *(double *)(8 * v240 + 8 * v241) - *(double *)(8 * v240 + 8 * v242);
            if (v187 <= 0xF) {
              break;
            }
            v245 = (int8x16_t *)((char *)v184 + v188);
            float64x2_t v246 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v243, 0);
            v247 = (float64x2_t *)v183;
            uint64_t v248 = v187 & 0xFFFFFFF0;
            do
            {
              float64x2_t v250 = v247[6];
              float64x2_t v249 = v247[7];
              float64x2_t v252 = v247[4];
              float64x2_t v251 = v247[5];
              float64x2_t v254 = v247[2];
              float64x2_t v253 = v247[3];
              float64x2_t v255 = *v247;
              float64x2_t v256 = v247[1];
              v247 += 8;
              *v184++ = vandq_s8(vuzp1q_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v246, vmulq_n_f64(vaddq_f64(v255, v190), v185)), (int32x4_t)vcgeq_f64(v246, vmulq_n_f64(vaddq_f64(v256, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v246, vmulq_n_f64(vaddq_f64(v254, v190), v185)), (int32x4_t)vcgeq_f64(v246, vmulq_n_f64(vaddq_f64(v253, v190), v185))))), vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(
                                                                            v246,
                                                                            vmulq_n_f64(vaddq_f64(v252, v190), v185)),
                                                               (int32x4_t)vcgeq_f64(v246, vmulq_n_f64(vaddq_f64(v251, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v246, vmulq_n_f64(vaddq_f64(v250, v190), v185)), (int32x4_t)vcgeq_f64(v246, vmulq_n_f64(vaddq_f64(v249, v190), v185)))))), v239);
              v248 -= 16;
            }
            while (v248);
            v183 = (double *)((char *)v183 + v189);
            int v244 = v187 & 0xFFFFFFF0;
            v257 = v183;
            if (v188 != v187) {
              goto LABEL_143;
            }
LABEL_145:
            if (v187 >= v172)
            {
              v183 = v257;
              int v267 = v187;
              if (v187 < v164) {
                goto LABEL_153;
              }
            }
            else
            {
              uint64_t v260 = 0;
              uint64_t v261 = 8 * v203;
              uint64_t v262 = v238 + v261;
              uint64_t v263 = 8 * v202;
              uint64_t v264 = v238 + v263;
              uint64_t v265 = v237 + v261;
              uint64_t v266 = v237 + v263;
              v183 = v257;
              do
              {
                if (v187 + v170 + v260 >= v16) {
                  __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
                }
                if (v196 + v260 >= v16) {
                  __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
                }
                v245->i8[v260] = (v257[v260] + a5) * v185 > *(double *)(v262 + 8 * v260)
                                                          - *(double *)(v265 + 8 * v260)
                                                          - *(double *)(v264 + 8 * v260)
                                                          + *(double *)(v266 + 8 * v260);
                ++v183;
                ++v260;
              }
              while (v195 + v260);
              v245 = (int8x16_t *)((char *)v245 + v260);
              int v267 = v187 + v260;
              uint64_t v240 = v386;
              if ((int)v187 + (int)v260 < v164)
              {
LABEL_153:
                double v268 = *(double *)(8 * v384 + 8 * v241)
                     - *(double *)(8 * v382 + 8 * v241)
                     - *(double *)(8 * v384 + 8 * v242)
                     + *(double *)(8 * v382 + 8 * v242);
                uint64_t v269 = v164 + ~v267;
                if (v269 < 0xF) {
                  goto LABEL_157;
                }
                uint64_t v270 = v269 + 1;
                uint64_t v271 = (v269 + 1) & 0x1FFFFFFF0;
                v267 += v271;
                float64x2_t v272 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v268, 0);
                v273 = v245;
                v274 = (float64x2_t *)v183;
                uint64_t v275 = v271;
                do
                {
                  float64x2_t v277 = v274[6];
                  float64x2_t v276 = v274[7];
                  float64x2_t v279 = v274[4];
                  float64x2_t v278 = v274[5];
                  float64x2_t v281 = v274[2];
                  float64x2_t v280 = v274[3];
                  float64x2_t v282 = *v274;
                  float64x2_t v283 = v274[1];
                  v274 += 8;
                  *v273++ = vandq_s8(vuzp1q_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v272, vmulq_n_f64(vaddq_f64(v282, v190), v185)), (int32x4_t)vcgeq_f64(v272, vmulq_n_f64(vaddq_f64(v283, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v272, vmulq_n_f64(vaddq_f64(v281, v190), v185)), (int32x4_t)vcgeq_f64(v272, vmulq_n_f64(vaddq_f64(v280, v190), v185))))), vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(
                                                                                v272,
                                                                                vmulq_n_f64(vaddq_f64(v279, v190), v185)),
                                                                   (int32x4_t)vcgeq_f64(v272, vmulq_n_f64(vaddq_f64(v278, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v272, vmulq_n_f64(vaddq_f64(v277, v190), v185)), (int32x4_t)vcgeq_f64(v272, vmulq_n_f64(vaddq_f64(v276, v190), v185)))))), v239);
                  v275 -= 16;
                }
                while (v275);
                v245 = (int8x16_t *)((char *)v245 + v271);
                v183 += v271;
                uint64_t v184 = v245;
                uint64_t v240 = v386;
                if (v270 != v271)
                {
LABEL_157:
                  int v284 = v164 - v267;
                  uint64_t v184 = v245;
                  do
                  {
                    double v285 = *v183++;
                    v184->i8[0] = (v285 + a5) * v185 > v268;
                    uint64_t v184 = (int8x16_t *)((char *)v184 + 1);
                    --v284;
                  }
                  while (v284);
                }
                goto LABEL_135;
              }
            }
            uint64_t v184 = v245;
LABEL_135:
            ++v169;
            v202 += v16;
            v203 += v16;
            if (v169 == v390)
            {
              uint64_t v180 = v376;
              goto LABEL_189;
            }
          }
          int v244 = 0;
          v245 = v184;
LABEL_143:
          int v258 = v187 - v244;
          v257 = v183;
          do
          {
            double v259 = *v257++;
            v245->i8[0] = (v259 + a5) * v185 > v243;
            v245 = (int8x16_t *)((char *)v245 + 1);
            --v258;
          }
          while (v258);
          goto LABEL_145;
        }
LABEL_189:
        if (v169 >= v380) {
          return 0;
        }
        float64x2_t v330 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v181, 0);
        float64x2_t v331 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v182, 0);
        uint64_t v332 = 8 * v196;
        uint64_t v333 = 8 * v378 + v332;
        uint64_t v334 = v180 + v332;
        unsigned int v335 = v187 + v170;
        uint64_t v336 = 8 * v335;
        uint64_t v337 = v180;
        uint64_t v338 = 8 * v378 + v336;
        uint64_t v339 = v337 + v336;
        v340.i64[0] = 0x101010101010101;
        v340.i64[1] = 0x101010101010101;
        while (2)
        {
          if (v187 <= 0xF)
          {
            int v341 = 0;
            v342 = v184;
            goto LABEL_197;
          }
          v342 = (int8x16_t *)((char *)v184 + v188);
          v343 = (float64x2_t *)v183;
          uint64_t v344 = v187 & 0xFFFFFFF0;
          do
          {
            float64x2_t v346 = v343[6];
            float64x2_t v345 = v343[7];
            float64x2_t v348 = v343[4];
            float64x2_t v347 = v343[5];
            float64x2_t v350 = v343[2];
            float64x2_t v349 = v343[3];
            float64x2_t v351 = *v343;
            float64x2_t v352 = v343[1];
            v343 += 8;
            *v184++ = vandq_s8(vuzp1q_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v330, vmulq_n_f64(vaddq_f64(v351, v190), v185)), (int32x4_t)vcgeq_f64(v330, vmulq_n_f64(vaddq_f64(v352, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v330, vmulq_n_f64(vaddq_f64(v350, v190), v185)), (int32x4_t)vcgeq_f64(v330, vmulq_n_f64(vaddq_f64(v349, v190), v185))))), vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(
                                                                          v330,
                                                                          vmulq_n_f64(vaddq_f64(v348, v190), v185)),
                                                             (int32x4_t)vcgeq_f64(v330, vmulq_n_f64(vaddq_f64(v347, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v330, vmulq_n_f64(vaddq_f64(v346, v190), v185)), (int32x4_t)vcgeq_f64(v330, vmulq_n_f64(vaddq_f64(v345, v190), v185)))))), v340);
            v344 -= 16;
          }
          while (v344);
          v183 = (double *)((char *)v183 + v189);
          int v341 = v187 & 0xFFFFFFF0;
          v353 = v183;
          if (v188 != v187)
          {
LABEL_197:
            int v354 = v187 - v341;
            v353 = v183;
            do
            {
              double v355 = *v353++;
              v342->i8[0] = (v355 + a5) * v185 > v181;
              v342 = (int8x16_t *)((char *)v342 + 1);
              --v354;
            }
            while (v354);
          }
          if (v187 >= v172)
          {
            v183 = v353;
            int v357 = v187;
            if (v187 < v164) {
              goto LABEL_207;
            }
          }
          else
          {
            uint64_t v356 = 0;
            v183 = v353;
            do
            {
              if (v335 + v356 >= v16) {
                __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
              }
              if (v196 + v356 >= v16) {
                __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
              }
              v342->i8[v356] = (v353[v356] + a5) * v185 > *(double *)(v339 + 8 * v356)
                                                        - *(double *)(v334 + 8 * v356)
                                                        - *(double *)(v338 + 8 * v356)
                                                        + *(double *)(v333 + 8 * v356);
              ++v183;
              ++v356;
            }
            while (v195 + v356);
            v342 = (int8x16_t *)((char *)v342 + v356);
            int v357 = v187 + v356;
            if ((int)v187 + (int)v356 < v164)
            {
LABEL_207:
              uint64_t v358 = v164 + ~v357;
              if (v358 <= 0xE) {
                goto LABEL_211;
              }
              uint64_t v359 = v358 + 1;
              uint64_t v360 = (v358 + 1) & 0x1FFFFFFF0;
              v357 += v360;
              v361 = v342;
              v362 = (float64x2_t *)v183;
              uint64_t v363 = v360;
              do
              {
                float64x2_t v365 = v362[6];
                float64x2_t v364 = v362[7];
                float64x2_t v367 = v362[4];
                float64x2_t v366 = v362[5];
                float64x2_t v369 = v362[2];
                float64x2_t v368 = v362[3];
                float64x2_t v370 = *v362;
                float64x2_t v371 = v362[1];
                v362 += 8;
                *v361++ = vandq_s8(vuzp1q_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v331, vmulq_n_f64(vaddq_f64(v370, v190), v185)), (int32x4_t)vcgeq_f64(v331, vmulq_n_f64(vaddq_f64(v371, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v331, vmulq_n_f64(vaddq_f64(v369, v190), v185)), (int32x4_t)vcgeq_f64(v331, vmulq_n_f64(vaddq_f64(v368, v190), v185))))), vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(
                                                                              v331,
                                                                              vmulq_n_f64(vaddq_f64(v367, v190), v185)),
                                                                 (int32x4_t)vcgeq_f64(v331, vmulq_n_f64(vaddq_f64(v366, v190), v185))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v331, vmulq_n_f64(vaddq_f64(v365, v190), v185)), (int32x4_t)vcgeq_f64(v331, vmulq_n_f64(vaddq_f64(v364, v190), v185)))))), v340);
                v363 -= 16;
              }
              while (v363);
              v342 = (int8x16_t *)((char *)v342 + v360);
              v183 += v360;
              if (v359 != v360)
              {
LABEL_211:
                int v372 = v164 - v357;
                do
                {
                  double v373 = *v183++;
                  v342->i8[0] = (v373 + a5) * v185 > v182;
                  v342 = (int8x16_t *)((char *)v342 + 1);
                  --v372;
                }
                while (v372);
              }
            }
          }
          LODWORD(v169) = v169 + 1;
          uint64_t v184 = v342;
          if (v169 == v380) {
            return 0;
          }
          continue;
        }
      }
    }
    int v204 = 0;
    v205 = v184;
LABEL_115:
    int v217 = v187 - v204;
    v216 = v183;
    do
    {
      double v218 = *v216++;
      v205->i8[0] = (v218 + a5) * v185 > *(double *)&v175;
      v205 = (int8x16_t *)((char *)v205 + 1);
      --v217;
    }
    while (v217);
    goto LABEL_117;
  }
  if (v9 <= a2) {
    goto LABEL_231;
  }
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10 <= a2) {
    goto LABEL_231;
  }
  unsigned int v11 = *(_DWORD *)(a1 + 16);
  unsigned int v12 = *(_DWORD *)(a1 + 20);
  unsigned int v13 = v11;
  if (*(void *)(a4 + 32) < v10 * (unint64_t)v9)
  {
    if (*(void *)(a4 + 8))
    {
      if (*(unsigned char *)(a4 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 20) = v9;
  if (8 * v11 * (unint64_t)v9) {
    operator new[]();
  }
  uint64_t v18 = 0;
  if (v9)
  {
    size_t v19 = 0;
    uint64_t v20 = *(void *)(a1 + 8);
    double v21 = 0.0;
    unsigned int v22 = v9;
    do
    {
      double v21 = v21 + *(double *)((char *)v19 + v20);
      *v19++ = v21;
      --v22;
    }
    while (v22);
    if (v13 >= 2)
    {
      unint64_t v23 = (double *)((char *)v19 + v20);
      for (int j = 1; j != v13; ++j)
      {
        double v25 = 0.0;
        unsigned int v26 = v9;
        do
        {
          double v27 = *v23++;
          double v25 = v25 + v27;
          double v28 = *v18++;
          *v19++ = v25 + v28;
          --v26;
        }
        while (v26);
      }
    }
  }
  unsigned int v29 = a2 - 1;
  if (a2 - 1 >= v13 || v29 >= v9) {
    __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
  }
  unsigned int v30 = *(_DWORD *)(a1 + 20);
  uint64_t v383 = v30 - 1;
  if (v383 >= v9) {
    __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
  }
  int v31 = ~a2;
  uint64_t v381 = v30 + ~a2;
  if (v381 >= v9) {
    __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
  }
  int v32 = *(_DWORD *)(a1 + 16);
  int v33 = v32 - 1;
  if (v32 - 1 >= v13) {
    __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
  }
  int v34 = v32 + v31;
  if (v32 + v31 >= v13) {
    __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
  }
  unsigned int v379 = *(_DWORD *)(a1 + 16);
  LODWORD(v35) = 0;
  unsigned int v36 = a2 >> 1;
  unsigned int v37 = (a2 >> 1) + (a2 & 1) - 1;
  uint64_t v38 = v9 - (a2 >> 1);
  uint64_t v389 = v10 - (a2 >> 1);
  uint64_t v39 = 8 * v29;
  uint64_t v385 = a2 - 1;
  uint64_t v40 = v9 * v29;
  uint64_t v41 = *(uint64_t *)(v39 + 8 * v40);
  uint64_t v42 = 8 * v383;
  uint64_t v43 = 8 * v40;
  uint64_t v44 = 8 * v381;
  double v45 = *(double *)(v42 + 8 * v40) - *(double *)(v44 + 8 * v40);
  uint64_t v46 = 8 * v33 * v9;
  uint64_t v377 = v34 * v9;
  double v47 = *(double *)(v39 + v46) - *(double *)(v39 + 8 * v377);
  double v48 = *(double *)(v42 + v46) + *(double *)(v44 + 8 * v377) - *(double *)(v44 + v46) - *(double *)(v42 + 8 * v377);
  float v49 = *(double **)(a1 + 8);
  float v50 = *(int8x16_t **)(a4 + 8);
  double v51 = (double)(a2 * a2);
  int v387 = ~v37;
  unsigned int v52 = (a2 >> 1) + (a2 & 1);
  if (v52 <= 1) {
    uint64_t v53 = 1;
  }
  else {
    uint64_t v53 = v52;
  }
  uint64_t v54 = v53 & 0xFFFFFFF0;
  uint64_t v55 = 8 * v54;
  float64x2_t v56 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a5, 0);
  float64x2_t v57 = (float64x2_t)vdupq_lane_s64(v41, 0);
  float64x2_t v58 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v45, 0);
  unsigned int v59 = v9 - v9 * v52;
  unsigned int v60 = v9 + v9 * v36;
  uint64_t v61 = v53 - v38;
  unsigned int v62 = v53 - v36 - (a2 & 1);
  uint64_t v63 = v43 + 8 * v62;
  uint64_t v64 = v43 + 8 * (v53 + v36);
  int v65 = 1;
  v66.i64[0] = 0x101010101010101;
  v66.i64[1] = 0x101010101010101;
  do
  {
    unsigned int v67 = v65;
    unsigned int v68 = v59;
    unsigned int v69 = v60;
    if (v53 <= 0xF)
    {
      int v70 = 0;
      uint64_t v71 = v50;
LABEL_45:
      int v83 = v53 - v70;
      float32x2_t v82 = v49;
      do
      {
        double v84 = *v82++;
        v71->i8[0] = (v84 + a5) * v51 <= *(double *)&v41;
        uint64_t v71 = (int8x16_t *)((char *)v71 + 1);
        --v83;
      }
      while (v83);
      goto LABEL_47;
    }
    uint64_t v71 = (int8x16_t *)((char *)v50 + v54);
    uint64_t v72 = (float64x2_t *)v49;
    uint64_t v73 = v53 & 0xFFFFFFF0;
    do
    {
      float64x2_t v75 = v72[6];
      float64x2_t v74 = v72[7];
      float64x2_t v77 = v72[4];
      float64x2_t v76 = v72[5];
      float64x2_t v79 = v72[2];
      float64x2_t v78 = v72[3];
      float64x2_t v80 = *v72;
      float64x2_t v81 = v72[1];
      v72 += 8;
      *v50++ = vandq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v57, vmulq_n_f64(vaddq_f64(v80, v56), v51)), (int32x4_t)vcgeq_f64(v57, vmulq_n_f64(vaddq_f64(v81, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v57, vmulq_n_f64(vaddq_f64(v79, v56), v51)), (int32x4_t)vcgeq_f64(v57, vmulq_n_f64(vaddq_f64(v78, v56), v51)))), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v57, vmulq_n_f64(vaddq_f64(v77, v56), v51)), (int32x4_t)vcgeq_f64(v57, vmulq_n_f64(vaddq_f64(v76, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v57, vmulq_n_f64(vaddq_f64(v75, v56), v51)), (int32x4_t)vcgeq_f64(v57, vmulq_n_f64(vaddq_f64(v74, v56), v51))))), v66);
      v73 -= 16;
    }
    while (v73);
    float v49 = (double *)((char *)v49 + v55);
    int v70 = v53 & 0xFFFFFFF0;
    float32x2_t v82 = v49;
    if (v54 != v53) {
      goto LABEL_45;
    }
LABEL_47:
    if (v53 >= v38)
    {
      float v49 = v82;
      int v86 = v53;
      if (v53 >= v30) {
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v85 = 0;
      float v49 = v82;
      do
      {
        if (v53 + v36 + v85 >= v12) {
          __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
        }
        if (v62 + v85 >= v12) {
          __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
        }
        v71->i8[v85] = (v82[v85] + a5) * v51 <= *(double *)(v64 + 8 * v85) - *(double *)(v63 + 8 * v85);
        ++v49;
        ++v85;
      }
      while (v61 + v85);
      uint64_t v71 = (int8x16_t *)((char *)v71 + v85);
      int v86 = v53 + v85;
      if ((int)v53 + (int)v85 >= v30)
      {
LABEL_38:
        float v50 = v71;
        goto LABEL_39;
      }
    }
    uint64_t v87 = v30 + ~v86;
    if (v87 <= 0xE) {
      goto LABEL_59;
    }
    uint64_t v88 = v87 + 1;
    uint64_t v89 = (v87 + 1) & 0x1FFFFFFF0;
    v86 += v89;
    v90 = v71;
    v91 = (float64x2_t *)v49;
    uint64_t v92 = v89;
    do
    {
      float64x2_t v94 = v91[6];
      float64x2_t v93 = v91[7];
      float64x2_t v96 = v91[4];
      float64x2_t v95 = v91[5];
      float64x2_t v98 = v91[2];
      float64x2_t v97 = v91[3];
      float64x2_t v99 = *v91;
      float64x2_t v100 = v91[1];
      v91 += 8;
      *v90++ = vandq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v58, vmulq_n_f64(vaddq_f64(v99, v56), v51)), (int32x4_t)vcgeq_f64(v58, vmulq_n_f64(vaddq_f64(v100, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v58, vmulq_n_f64(vaddq_f64(v98, v56), v51)), (int32x4_t)vcgeq_f64(v58, vmulq_n_f64(vaddq_f64(v97, v56), v51)))), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v58, vmulq_n_f64(vaddq_f64(v96, v56), v51)), (int32x4_t)vcgeq_f64(v58, vmulq_n_f64(vaddq_f64(v95, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v58, vmulq_n_f64(vaddq_f64(v94, v56), v51)), (int32x4_t)vcgeq_f64(v58, vmulq_n_f64(vaddq_f64(v93, v56), v51))))), v66);
      v92 -= 16;
    }
    while (v92);
    uint64_t v71 = (int8x16_t *)((char *)v71 + v89);
    v49 += v89;
    float v50 = v71;
    if (v88 != v89)
    {
LABEL_59:
      int v101 = v30 - v86;
      float v50 = v71;
      do
      {
        double v102 = *v49++;
        v50->i8[0] = (v102 + a5) * v51 <= v45;
        float v50 = (int8x16_t *)((char *)v50 + 1);
        --v101;
      }
      while (v101);
    }
LABEL_39:
    LODWORD(v35) = v35 + 1;
    int v65 = v67 + 1;
    unsigned int v59 = v68 + v12;
    unsigned int v60 = v69 + v12;
  }
  while (v35 <= v37);
  if (v35 < v389)
  {
    uint64_t v375 = v46;
    uint64_t v35 = v67;
    uint64_t v103 = 8 * v62;
    uint64_t v104 = 8 * (v53 + v36);
    v105.i64[0] = 0x101010101010101;
    v105.i64[1] = 0x101010101010101;
    uint64_t v106 = v385;
    while (1)
    {
      if (v36 + v35 >= v13) {
        __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
      }
      if ((int)v35 + v387 >= v13) {
        __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
      }
      uint64_t v107 = (v36 + v35) * v12;
      uint64_t v108 = (v35 + v387) * v12;
      double v109 = *(double *)(8 * v106 + 8 * v107) - *(double *)(8 * v106 + 8 * v108);
      if (v53 <= 0xF) {
        break;
      }
      uint64_t v111 = (int8x16_t *)((char *)v50 + v54);
      float64x2_t v112 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v109, 0);
      uint64_t v113 = (float64x2_t *)v49;
      uint64_t v114 = v53 & 0xFFFFFFF0;
      do
      {
        float64x2_t v116 = v113[6];
        float64x2_t v115 = v113[7];
        float64x2_t v118 = v113[4];
        float64x2_t v117 = v113[5];
        float64x2_t v120 = v113[2];
        float64x2_t v119 = v113[3];
        float64x2_t v121 = *v113;
        float64x2_t v122 = v113[1];
        v113 += 8;
        *v50++ = vandq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v112, vmulq_n_f64(vaddq_f64(v121, v56), v51)), (int32x4_t)vcgeq_f64(v112, vmulq_n_f64(vaddq_f64(v122, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v112, vmulq_n_f64(vaddq_f64(v120, v56), v51)), (int32x4_t)vcgeq_f64(v112, vmulq_n_f64(vaddq_f64(v119, v56), v51)))), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v112, vmulq_n_f64(vaddq_f64(v118, v56), v51)), (int32x4_t)vcgeq_f64(v112, vmulq_n_f64(vaddq_f64(v117, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v112, vmulq_n_f64(vaddq_f64(v116, v56), v51)), (int32x4_t)vcgeq_f64(v112, vmulq_n_f64(vaddq_f64(v115, v56), v51))))), v105);
        v114 -= 16;
      }
      while (v114);
      float v49 = (double *)((char *)v49 + v55);
      int v110 = v53 & 0xFFFFFFF0;
      id v123 = v49;
      if (v54 != v53) {
        goto LABEL_73;
      }
LABEL_75:
      if (v53 >= v38)
      {
        float v49 = v123;
        int v133 = v53;
        if (v53 < v30) {
          goto LABEL_83;
        }
      }
      else
      {
        uint64_t v126 = 0;
        uint64_t v127 = 8 * v69;
        uint64_t v128 = v104 + v127;
        uint64_t v129 = 8 * v68;
        uint64_t v130 = v104 + v129;
        uint64_t v131 = v103 + v127;
        uint64_t v132 = v103 + v129;
        float v49 = v123;
        do
        {
          if (v53 + v36 + v126 >= v12) {
            __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
          }
          if (v62 + v126 >= v12) {
            __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
          }
          v111->i8[v126] = (v123[v126] + a5) * v51 <= *(double *)(v128 + 8 * v126)
                                                    - *(double *)(v131 + 8 * v126)
                                                    - *(double *)(v130 + 8 * v126)
                                                    + *(double *)(v132 + 8 * v126);
          ++v49;
          ++v126;
        }
        while (v61 + v126);
        uint64_t v111 = (int8x16_t *)((char *)v111 + v126);
        int v133 = v53 + v126;
        uint64_t v106 = v385;
        if ((int)v53 + (int)v126 < v30)
        {
LABEL_83:
          double v134 = *(double *)(8 * v383 + 8 * v107)
               - *(double *)(8 * v381 + 8 * v107)
               - *(double *)(8 * v383 + 8 * v108)
               + *(double *)(8 * v381 + 8 * v108);
          uint64_t v135 = v30 + ~v133;
          if (v135 < 0xF) {
            goto LABEL_87;
          }
          uint64_t v136 = v135 + 1;
          uint64_t v137 = (v135 + 1) & 0x1FFFFFFF0;
          v133 += v137;
          float64x2_t v138 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v134, 0);
          float v139 = v111;
          float v140 = (float64x2_t *)v49;
          uint64_t v141 = v137;
          do
          {
            float64x2_t v143 = v140[6];
            float64x2_t v142 = v140[7];
            float64x2_t v145 = v140[4];
            float64x2_t v144 = v140[5];
            float64x2_t v147 = v140[2];
            float64x2_t v146 = v140[3];
            float64x2_t v148 = *v140;
            float64x2_t v149 = v140[1];
            v140 += 8;
            *v139++ = vandq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v138, vmulq_n_f64(vaddq_f64(v148, v56), v51)), (int32x4_t)vcgeq_f64(v138, vmulq_n_f64(vaddq_f64(v149, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v138, vmulq_n_f64(vaddq_f64(v147, v56), v51)), (int32x4_t)vcgeq_f64(v138, vmulq_n_f64(vaddq_f64(v146, v56), v51)))), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v138, vmulq_n_f64(vaddq_f64(v145, v56), v51)), (int32x4_t)vcgeq_f64(v138, vmulq_n_f64(vaddq_f64(v144, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v138, vmulq_n_f64(vaddq_f64(v143, v56), v51)), (int32x4_t)vcgeq_f64(v138, vmulq_n_f64(vaddq_f64(v142, v56), v51))))), v105);
            v141 -= 16;
          }
          while (v141);
          uint64_t v111 = (int8x16_t *)((char *)v111 + v137);
          v49 += v137;
          float v50 = v111;
          uint64_t v106 = v385;
          if (v136 != v137)
          {
LABEL_87:
            int v150 = v30 - v133;
            float v50 = v111;
            do
            {
              double v151 = *v49++;
              v50->i8[0] = (v151 + a5) * v51 <= v134;
              float v50 = (int8x16_t *)((char *)v50 + 1);
              --v150;
            }
            while (v150);
          }
          goto LABEL_65;
        }
      }
      float v50 = v111;
LABEL_65:
      ++v35;
      v68 += v12;
      v69 += v12;
      if (v35 == v389)
      {
        uint64_t v46 = v375;
        goto LABEL_163;
      }
    }
    int v110 = 0;
    uint64_t v111 = v50;
LABEL_73:
    int v124 = v53 - v110;
    id v123 = v49;
    do
    {
      double v125 = *v123++;
      v111->i8[0] = (v125 + a5) * v51 <= v109;
      uint64_t v111 = (int8x16_t *)((char *)v111 + 1);
      --v124;
    }
    while (v124);
    goto LABEL_75;
  }
LABEL_163:
  if (v35 < v379)
  {
    float64x2_t v286 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v47, 0);
    float64x2_t v287 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v48, 0);
    uint64_t v288 = 8 * v62;
    uint64_t v289 = 8 * v377 + v288;
    uint64_t v290 = v46 + v288;
    unsigned int v291 = v53 + v36;
    uint64_t v292 = 8 * v291;
    uint64_t v293 = v46;
    uint64_t v294 = 8 * v377 + v292;
    uint64_t v295 = v293 + v292;
    v296.i64[0] = 0x101010101010101;
    v296.i64[1] = 0x101010101010101;
    while (v53 > 0xF)
    {
      v298 = (int8x16_t *)((char *)v50 + v54);
      v299 = (float64x2_t *)v49;
      uint64_t v300 = v53 & 0xFFFFFFF0;
      do
      {
        float64x2_t v302 = v299[6];
        float64x2_t v301 = v299[7];
        float64x2_t v304 = v299[4];
        float64x2_t v303 = v299[5];
        float64x2_t v306 = v299[2];
        float64x2_t v305 = v299[3];
        float64x2_t v307 = *v299;
        float64x2_t v308 = v299[1];
        v299 += 8;
        *v50++ = vandq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v286, vmulq_n_f64(vaddq_f64(v307, v56), v51)), (int32x4_t)vcgeq_f64(v286, vmulq_n_f64(vaddq_f64(v308, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v286, vmulq_n_f64(vaddq_f64(v306, v56), v51)), (int32x4_t)vcgeq_f64(v286, vmulq_n_f64(vaddq_f64(v305, v56), v51)))), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v286, vmulq_n_f64(vaddq_f64(v304, v56), v51)), (int32x4_t)vcgeq_f64(v286, vmulq_n_f64(vaddq_f64(v303, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v286, vmulq_n_f64(vaddq_f64(v302, v56), v51)), (int32x4_t)vcgeq_f64(v286, vmulq_n_f64(vaddq_f64(v301, v56), v51))))), v296);
        v300 -= 16;
      }
      while (v300);
      float v49 = (double *)((char *)v49 + v55);
      int v297 = v53 & 0xFFFFFFF0;
      v309 = v49;
      if (v54 != v53) {
        goto LABEL_171;
      }
LABEL_173:
      if (v53 < v38)
      {
        uint64_t v312 = 0;
        float v49 = v309;
        do
        {
          if (v291 + v312 >= v12) {
            __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
          }
          if (v62 + v312 >= v12) {
            __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
          }
          v298->i8[v312] = (v309[v312] + a5) * v51 <= *(double *)(v295 + 8 * v312)
                                                    - *(double *)(v290 + 8 * v312)
                                                    - *(double *)(v294 + 8 * v312)
                                                    + *(double *)(v289 + 8 * v312);
          ++v49;
          ++v312;
        }
        while (v61 + v312);
        v298 = (int8x16_t *)((char *)v298 + v312);
        int v313 = v53 + v312;
        if ((int)v53 + (int)v312 >= v30) {
          goto LABEL_165;
        }
LABEL_181:
        uint64_t v314 = v30 + ~v313;
        if (v314 <= 0xE) {
          goto LABEL_185;
        }
        uint64_t v315 = v314 + 1;
        uint64_t v316 = (v314 + 1) & 0x1FFFFFFF0;
        v313 += v316;
        v317 = v298;
        v318 = (float64x2_t *)v49;
        uint64_t v319 = v316;
        do
        {
          float64x2_t v321 = v318[6];
          float64x2_t v320 = v318[7];
          float64x2_t v323 = v318[4];
          float64x2_t v322 = v318[5];
          float64x2_t v325 = v318[2];
          float64x2_t v324 = v318[3];
          float64x2_t v326 = *v318;
          float64x2_t v327 = v318[1];
          v318 += 8;
          *v317++ = vandq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v287, vmulq_n_f64(vaddq_f64(v326, v56), v51)), (int32x4_t)vcgeq_f64(v287, vmulq_n_f64(vaddq_f64(v327, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v287, vmulq_n_f64(vaddq_f64(v325, v56), v51)), (int32x4_t)vcgeq_f64(v287, vmulq_n_f64(vaddq_f64(v324, v56), v51)))), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v287, vmulq_n_f64(vaddq_f64(v323, v56), v51)), (int32x4_t)vcgeq_f64(v287, vmulq_n_f64(vaddq_f64(v322, v56), v51))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v287, vmulq_n_f64(vaddq_f64(v321, v56), v51)), (int32x4_t)vcgeq_f64(v287, vmulq_n_f64(vaddq_f64(v320, v56), v51))))), v296);
          v319 -= 16;
        }
        while (v319);
        v298 = (int8x16_t *)((char *)v298 + v316);
        v49 += v316;
        if (v315 != v316)
        {
LABEL_185:
          int v328 = v30 - v313;
          do
          {
            double v329 = *v49++;
            v298->i8[0] = (v329 + a5) * v51 <= v48;
            v298 = (int8x16_t *)((char *)v298 + 1);
            --v328;
          }
          while (v328);
        }
        goto LABEL_165;
      }
      float v49 = v309;
      int v313 = v53;
      if (v53 < v30) {
        goto LABEL_181;
      }
LABEL_165:
      LODWORD(v35) = v35 + 1;
      float v50 = v298;
      if (v35 == v379) {
        return 0;
      }
    }
    int v297 = 0;
    v298 = v50;
LABEL_171:
    int v310 = v53 - v297;
    v309 = v49;
    do
    {
      double v311 = *v309++;
      v298->i8[0] = (v311 + a5) * v51 <= v47;
      v298 = (int8x16_t *)((char *)v298 + 1);
      --v310;
    }
    while (v310);
    goto LABEL_173;
  }
  return 0;
}

void sub_215F2888C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a21)
  {
    if (a23) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t Matrix<double>::~Matrix(uint64_t a1)
{
  *(void *)a1 = off_26C6875D0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

void Matrix<double>::~Matrix(uint64_t a1)
{
  *(void *)a1 = off_26C6875D0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  JUMPOUT(0x2166C5D90);
}

uint64_t ImageUtils::ErodeRect2x2(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  if (*(void *)(a2 + 32) < v4 * (unint64_t)v3)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  unsigned int v6 = *(_DWORD *)(a1 + 20);
  if (v6 < 3 || v5 <= 2) {
    __assert_rtn("ErodeRect2x2", "ImageUtils.cpp", 844, "im.Cols() > 2 && im.Rows() > 2");
  }
  unsigned int v8 = *(unsigned char **)(a1 + 8);
  unsigned int v9 = *(unsigned char **)(a2 + 8);
  memset(v9, 1, v6 * v5);
  if (!*v8) {
    unsigned char *v9 = 0;
  }
  unsigned int v10 = v9 + 1;
  uint64_t v11 = v6 - 2;
  unsigned int v12 = v8 + 1;
  unsigned int v13 = v6 - 1;
  unsigned int v14 = v6 - 1;
  do
  {
    if (!*v12++) {
      *(_WORD *)(v10 - 1) = 0;
    }
    ++v10;
    --v14;
  }
  while (v14);
  uint64_t v16 = v11 + 2;
  unsigned int v17 = &v8[v11 + 2];
  uint64_t v18 = -(uint64_t)*(unsigned int *)(a1 + 20);
  uint64_t v19 = (uint64_t)&v8[2 * v11 + 5];
  uint64_t v20 = (uint64_t)&v8[v11 + 3];
  LODWORD(result) = 1;
  do
  {
    unint64_t v23 = v10;
    uint64_t v24 = (unsigned __int8 *)v19;
    if (!*v17)
    {
      *unsigned int v10 = 0;
      v10[v18] = 0;
    }
    uint64_t v25 = 0;
    unsigned int v26 = &v10[-*(unsigned int *)(a1 + 20)];
    do
    {
      if (!*(unsigned char *)(v20 + v25))
      {
        *(_WORD *)&v23[v25] = 0;
        *(_WORD *)&v26[v25] = 0;
      }
      ++v25;
    }
    while (v13 != v25);
    unsigned int v10 = &v23[v25 + 1];
    v17 += v16;
    v19 += v16;
    v20 += v16;
    BOOL v22 = result == v5 - 2;
    uint64_t result = (result + 1);
  }
  while (!v22);
  int v27 = *v17;
  uint64_t v28 = *(unsigned int *)(a1 + 20);
  if (!v27)
  {
    *unsigned int v10 = 0;
    v10[-v28] = 0;
    LODWORD(v28) = *(_DWORD *)(a1 + 20);
  }
  uint64_t v29 = 0;
  unsigned int v30 = &v23[-v28];
  do
  {
    if (!*v24++)
    {
      *(_WORD *)&v23[v29 + 1 + v25] = 0;
      int v32 = &v30[v29 + v25];
      v32[1] = 0;
      v32[2] = 0;
    }
    ++v29;
  }
  while (v13 != v29);
  return result;
}

uint64_t ErodeOrDilateRect3x3<false>(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  if (*(void *)(a2 + 32) < v4 * (unint64_t)v3)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  unsigned int v6 = *(_DWORD *)(a1 + 20);
  uint64_t v7 = v6 - 3;
  if (v6 < 3 || v5 <= 2) {
    __assert_rtn("ErodeOrDilateRect3x3", "ImageUtils.cpp", 721, "im.Cols() > 2 && im.Rows() > 2");
  }
  unsigned int v9 = *(unsigned char **)(a1 + 8);
  unsigned int v10 = *(_WORD **)(a2 + 8);
  memset(v10, 1, v6 * v5);
  if (!*v9)
  {
    *unsigned int v10 = 0;
    *(_WORD *)((char *)v10 + *(unsigned int *)(a1 + 20)) = 0;
  }
  uint64_t v11 = (uint64_t)v10 + 1;
  uint64_t v12 = *(unsigned int *)(a1 + 20);
  unsigned int v13 = v9 + 1;
  unsigned int v14 = v6 - 2;
  unsigned int v15 = v6 - 2;
  do
  {
    uint64_t v16 = (_WORD *)v11;
    if (!*v13++)
    {
      *(_WORD *)(v11 - 1) = 0;
      *(unsigned char *)(v11 + 1) = 0;
      uint64_t v18 = v11 + v12;
      *(_WORD *)(v18 - 1) = 0;
      *(unsigned char *)(v18 + 1) = 0;
    }
    uint64_t v11 = (uint64_t)v16 + 1;
    --v15;
  }
  while (v15);
  uint64_t v19 = v7 + 2;
  uint64_t v20 = &v9[v7 + 2];
  uint64_t v21 = *(unsigned int *)(a1 + 20);
  if (!*v20)
  {
    *uint64_t v16 = 0;
    *(_WORD *)((char *)v16 + v21) = 0;
    LODWORD(v21) = *(_DWORD *)(a1 + 20);
  }
  BOOL v22 = v16 + 1;
  unint64_t v23 = v20 + 1;
  uint64_t v24 = v21;
  uint64_t v25 = -(uint64_t)v21;
  uint64_t v26 = v7 + 3;
  uint64_t v27 = (uint64_t)&v9[v7 + 4];
  LODWORD(result) = 1;
  do
  {
    uint64_t v33 = v11;
    if (!*v23)
    {
      unsigned char *v22 = 0;
      *(unsigned char *)(v11 + 2) = 0;
      *(_WORD *)&v22[v25] = 0;
      *(_WORD *)&v22[v24] = 0;
    }
    uint64_t v34 = 0;
    uint64_t v35 = *(unsigned int *)(a1 + 20);
    uint64_t v36 = v11 + v35;
    uint64_t v37 = v33 - v35;
    do
    {
      if (!*(unsigned char *)(v27 + v34))
      {
        uint64_t v38 = v33 + v34;
        *(unsigned char *)(v38 + 1) = 0;
        *(_WORD *)(v38 + 2) = 0;
        uint64_t v39 = v37 + v34;
        *(_WORD *)(v39 + 1) = 0;
        *(unsigned char *)(v39 + 3) = 0;
        uint64_t v40 = v36 + v34;
        *(_WORD *)(v40 + 1) = 0;
        *(unsigned char *)(v40 + 3) = 0;
      }
      ++v34;
    }
    while (v14 != v34);
    uint64_t v29 = (unsigned char *)(v33 + v34);
    uint64_t v11 = v33 + v34 + 2;
    if (!v20[v26])
    {
      v29[1] = 0;
      v29[2] = 0;
      *(_WORD *)(v11 + v25 - 1) = 0;
      *(_WORD *)(v11 + v24 - 1) = 0;
    }
    unsigned int v30 = v29 + 1;
    int v31 = &v20[v19];
    BOOL v22 = v29 + 3;
    unint64_t v23 = &v20[v19 + 2];
    v27 += v26;
    v20 += v26;
    BOOL v32 = result == v5 - 2;
    uint64_t result = (result + 1);
  }
  while (!v32);
  uint64_t v41 = *(unsigned int *)(a1 + 20);
  uint64_t v42 = v33 + v34 + 3;
  if (!*v23)
  {
    *((_WORD *)v30 + 1) = 0;
    *(_WORD *)&v22[-v41] = 0;
    LODWORD(v41) = *(_DWORD *)(a1 + 20);
  }
  uint64_t v43 = v31 + 3;
  uint64_t v44 = -(uint64_t)v41;
  do
  {
    uint64_t v45 = v42;
    if (!*v43)
    {
      *(_WORD *)uint64_t v42 = 0;
      *(unsigned char *)(v42 + 2) = 0;
      uint64_t v46 = v42 + v44;
      *(_WORD *)uint64_t v46 = 0;
      *(unsigned char *)(v46 + 2) = 0;
    }
    ++v43;
    uint64_t v42 = v45 + 1;
    --v14;
  }
  while (v14);
  if (!v23[v19])
  {
    *(_WORD *)uint64_t v42 = 0;
    *(unsigned char *)(v42 + v44) = 0;
    *(unsigned char *)(v45 + 2 + v44) = 0;
  }
  return result;
}

void ErodeOrDilateRect2x2<true>(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  if (*(void *)(a2 + 32) < v4 * (unint64_t)v3)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  unsigned int v5 = *(_DWORD *)(a1 + 20);
  uint64_t v7 = v5 - 2;
  if (v5 < 2 || v6 <= 1) {
    __assert_rtn("ErodeOrDilateRect2x2", "ImageUtils.cpp", 669, "im.Cols() > 1 && im.Rows() > 1");
  }
  unsigned int v9 = v5 - 1;
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v11 = *(char **)(a2 + 8);
  bzero(v11, v5 * v6);
  int v12 = 0;
  uint64_t v13 = *(unsigned int *)(a1 + 20);
  uint64_t v14 = v7 + 1;
  do
  {
    uint64_t v16 = 0;
    unsigned int v17 = v11;
    uint64_t v18 = &v11[*(unsigned int *)(a1 + 20)];
    do
    {
      if (*(unsigned char *)(v10 + v16))
      {
        *(_WORD *)&v11[v16] = 257;
        *(_WORD *)&v18[v16] = 257;
      }
      ++v16;
    }
    while (v9 != v16);
    uint64_t v19 = &v11[v16];
    if (*(unsigned char *)(v10 + v14))
    {
      v11[v16] = 1;
      v19[v13] = 1;
    }
    v10 += v7 + 2;
    uint64_t v11 = v19 + 1;
  }
  while (v12++ != v6 - 2);
  uint64_t v20 = 0;
  do
  {
    if (*(unsigned char *)(v10 + v20))
    {
      uint64_t v21 = &v17[v20 + v16];
      v21[1] = 1;
      v21[2] = 1;
    }
    ++v20;
  }
  while (v9 != v20);
  if (*(unsigned char *)(v10 + v14)) {
    v17[v16 + 1 + v20] = 1;
  }
}

uint64_t ErodeOrDilateRect3x3<true>(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  if (*(void *)(a2 + 32) < v4 * (unint64_t)v3)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  unsigned int v6 = *(_DWORD *)(a1 + 20);
  uint64_t v7 = v6 - 3;
  if (v6 < 3 || v5 <= 2) {
    __assert_rtn("ErodeOrDilateRect3x3", "ImageUtils.cpp", 721, "im.Cols() > 2 && im.Rows() > 2");
  }
  unsigned int v9 = *(unsigned char **)(a1 + 8);
  uint64_t v10 = *(_WORD **)(a2 + 8);
  bzero(v10, v6 * v5);
  if (*v9)
  {
    *uint64_t v10 = 257;
    *(_WORD *)((char *)v10 + *(unsigned int *)(a1 + 20)) = 257;
  }
  uint64_t v11 = (uint64_t)v10 + 1;
  uint64_t v12 = *(unsigned int *)(a1 + 20);
  uint64_t v13 = v9 + 1;
  unsigned int v14 = v6 - 2;
  unsigned int v15 = v6 - 2;
  do
  {
    uint64_t v16 = (_WORD *)v11;
    if (*v13++)
    {
      *(_WORD *)(v11 - 1) = 257;
      *(unsigned char *)(v11 + 1) = 1;
      uint64_t v18 = v11 + v12;
      *(_WORD *)(v18 - 1) = 257;
      *(unsigned char *)(v18 + 1) = 1;
    }
    uint64_t v11 = (uint64_t)v16 + 1;
    --v15;
  }
  while (v15);
  uint64_t v19 = v7 + 2;
  uint64_t v20 = &v9[v7 + 2];
  uint64_t v21 = *(unsigned int *)(a1 + 20);
  if (*v20)
  {
    *uint64_t v16 = 257;
    *(_WORD *)((char *)v16 + v21) = 257;
    LODWORD(v21) = *(_DWORD *)(a1 + 20);
  }
  BOOL v22 = v16 + 1;
  unint64_t v23 = v20 + 1;
  uint64_t v24 = v21;
  uint64_t v25 = -(uint64_t)v21;
  uint64_t v26 = v7 + 3;
  uint64_t v27 = (uint64_t)&v9[v7 + 4];
  uint64_t result = 1;
  int v29 = 1;
  do
  {
    uint64_t v33 = v11;
    if (*v23)
    {
      unsigned char *v22 = 1;
      *(unsigned char *)(v11 + 2) = 1;
      *(_WORD *)&v22[v25] = 257;
      *(_WORD *)&v22[v24] = 257;
    }
    uint64_t v34 = 0;
    uint64_t v35 = *(unsigned int *)(a1 + 20);
    uint64_t v36 = v11 + v35;
    uint64_t v37 = v33 - v35;
    do
    {
      if (*(unsigned char *)(v27 + v34))
      {
        uint64_t v38 = (unsigned char *)(v33 + v34);
        v38[1] = 1;
        v38[2] = 1;
        v38[3] = 1;
        uint64_t v39 = v37 + v34;
        *(_WORD *)(v39 + 1) = 257;
        *(unsigned char *)(v39 + 3) = 1;
        uint64_t v40 = v36 + v34;
        *(_WORD *)(v40 + 1) = 257;
        *(unsigned char *)(v40 + 3) = 1;
      }
      ++v34;
    }
    while (v14 != v34);
    uint64_t v41 = (unsigned char *)(v33 + v34);
    uint64_t v11 = v33 + v34 + 2;
    if (v20[v26])
    {
      v41[1] = 1;
      v41[2] = 1;
      *(_WORD *)(v11 + v25 - 1) = 257;
      *(_WORD *)(v11 + v24 - 1) = 257;
    }
    unsigned int v30 = v41 + 1;
    int v31 = &v20[v19];
    BOOL v22 = v41 + 3;
    unint64_t v23 = &v20[v19 + 2];
    v27 += v26;
    v20 += v26;
  }
  while (v29++ != v5 - 2);
  uint64_t v42 = *(unsigned int *)(a1 + 20);
  uint64_t v43 = v33 + v34 + 3;
  if (*v23)
  {
    *((_WORD *)v30 + 1) = 257;
    *(_WORD *)&v22[-v42] = 257;
    LODWORD(v42) = *(_DWORD *)(a1 + 20);
  }
  uint64_t v44 = v31 + 3;
  uint64_t v45 = -(uint64_t)v42;
  do
  {
    uint64_t v46 = v43;
    if (*v44)
    {
      *(_WORD *)uint64_t v43 = 257;
      *(unsigned char *)(v43 + 2) = 1;
      uint64_t v47 = v43 + v45;
      *(_WORD *)uint64_t v47 = 257;
      *(unsigned char *)(v47 + 2) = 1;
    }
    ++v44;
    uint64_t v43 = v46 + 1;
    --v14;
  }
  while (v14);
  if (v23[v19])
  {
    *(_WORD *)uint64_t v43 = 257;
    *(unsigned char *)(v43 + v45) = 1;
    *(unsigned char *)(v46 + 2 + v45) = 1;
  }
  return result;
}

uint64_t ImageUtils::CloseRect2x2(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  unsigned int v5 = &unk_26C6875B0;
  char v8 = 0;
  ErodeOrDilateRect2x2<true>(a1, (uint64_t)&v5);
  ImageUtils::ErodeRect2x2((uint64_t)&v5, a2);
  unsigned int v5 = &unk_26C6875B0;
  uint64_t result = v6;
  if (v6) {
    BOOL v4 = v8 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4) {
    return MEMORY[0x2166C5D70]();
  }
  return result;
}

void sub_215F29470(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Matrix<BOOL>::~Matrix((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t Matrix<BOOL>::~Matrix(uint64_t a1)
{
  *(void *)a1 = &unk_26C6875B0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

void Matrix<BOOL>::~Matrix(uint64_t a1)
{
  *(void *)a1 = &unk_26C6875B0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  JUMPOUT(0x2166C5D90);
}

uint64_t ImageUtils::CloseRect3x3(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  unsigned int v5 = &unk_26C6875B0;
  char v8 = 0;
  ErodeOrDilateRect3x3<true>(a1, (uint64_t)&v5);
  ErodeOrDilateRect3x3<false>((uint64_t)&v5, a2);
  unsigned int v5 = &unk_26C6875B0;
  uint64_t result = v6;
  if (v6) {
    BOOL v4 = v8 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4) {
    return MEMORY[0x2166C5D70]();
  }
  return result;
}

void sub_215F29624(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Matrix<BOOL>::~Matrix((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ImageUtils::Scale<double>(uint64_t a1, uint64_t a2, double a3)
{
  return Scale<double>(a1, a2, a3, a3);
}

uint64_t Scale<double>(uint64_t a1, uint64_t a2, double a3, double a4)
{
  int v7 = *(_DWORD *)(a1 + 16);
  unsigned int v8 = vcvtpd_u64_f64((double)v7 * a3);
  LODWORD(v4) = vcvtpd_u64_f64((double)*(int *)(a1 + 20) * a4);
  uint64_t v61 = off_26C6875D0;
  if (v7 * v4) {
    operator new[]();
  }
  uint64_t v62 = 0;
  int v63 = v7;
  int v64 = v4;
  char v65 = 0;
  unint64_t v66 = 8 * v7 * (unint64_t)v4;
  if (*(void *)(a2 + 32) < 8 * v8 * (unint64_t)v4)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v8;
  *(_DWORD *)(a2 + 20) = v4;
  if (a4 >= 1.0) {
    double v9 = 4.0;
  }
  else {
    double v9 = 4.0 / a4;
  }
  unsigned int v10 = vcvtpd_u64_f64(v9);
  if (a3 >= 1.0) {
    double v11 = 4.0;
  }
  else {
    double v11 = 4.0 / a3;
  }
  unsigned int v12 = vcvtpd_u64_f64(v11);
  if (v12 <= v10) {
    unsigned int v13 = v10;
  }
  else {
    unsigned int v13 = v12;
  }
  uint64_t v55 = off_26C6875D0;
  if (v13 != -4) {
    operator new[]();
  }
  int v57 = 1;
  int v58 = 0;
  char v59 = 0;
  uint64_t v60 = 0;
  uint64_t v55 = (uint64_t (**)())&unk_26C6874F0;
  float64x2_t v56 = 0;
  if (v4)
  {
    uint64_t v14 = 0;
    double v15 = fmin(a4, 1.0);
    do
    {
      uint64_t v54 = 0;
      CalculateWeightsForScale<double>((uint64_t)&v55, v10, (signed int *)&v54 + 1, (int *)&v54, v9, ((double)v14++ + 0.5) / a4 + -0.5, v15);
    }
    while (v14 != v4);
  }
  if (v8)
  {
    int v16 = 0;
    double v17 = fmin(a3, 1.0);
    uint64_t v18 = *(double **)(a2 + 8);
    uint64_t v19 = 8 * v4;
    double v20 = 0.0;
    do
    {
      uint64_t v54 = 0;
      CalculateWeightsForScale<double>((uint64_t)&v55, v12, (signed int *)&v54 + 1, (int *)&v54, v11, (v20 + 0.5) / a3 + -0.5, v17);
      if ((int)v54 >= v7) {
        int v21 = v7 - 1;
      }
      else {
        int v21 = v54;
      }
      if ((int)v54 >= v7) {
        int v22 = v54 - v7 + 1;
      }
      else {
        int v22 = 0;
      }
      if (v4)
      {
        unint64_t v23 = &v18[v4];
        uint64_t v24 = (double *)(v62 + 8 * (HIDWORD(v54) & ~(SHIDWORD(v54) >> 31)) * v4);
        unint64_t v25 = v62 + 8 * (v21 * v4);
        int v26 = (SHIDWORD(v54) >> 31) & -HIDWORD(v54);
        if (v26)
        {
          do
          {
            uint64_t v37 = v56;
            double v38 = *v24;
            double v39 = 0.0;
            int v40 = v26;
            do
            {
              double v41 = *v37++;
              double v39 = v39 + v41 * v38;
              --v40;
            }
            while (v40);
            uint64_t v42 = v24;
            if ((unint64_t)v24 < v25)
            {
              do
              {
                double v43 = *v37++;
                double v39 = v39 + v43 * *v42;
                uint64_t v42 = (double *)((char *)v42 + v19);
              }
              while ((unint64_t)v42 < v25);
              double v38 = *v42;
            }
            double v44 = v39 + *v37 * v38;
            if (v22)
            {
              uint64_t v45 = v37 + 1;
              int v46 = v22;
              do
              {
                double v47 = *v45++;
                double v44 = v44 + v47 * v38;
                --v46;
              }
              while (v46);
            }
            *v18++ = v44;
            ++v24;
            v25 += 8;
          }
          while (v18 < v23);
        }
        else if (v22)
        {
          do
          {
            uint64_t v27 = v56;
            double v28 = 0.0;
            for (int i = v24; (unint64_t)i < v25; int i = (double *)((char *)i + v19))
            {
              double v30 = *v27++;
              double v28 = v28 + v30 * *i;
            }
            double v32 = *v27;
            int v31 = v27 + 1;
            double v33 = *i;
            double v34 = v28 + v32 * *i;
            int v35 = v22;
            do
            {
              double v36 = *v31++;
              double v34 = v34 + v36 * v33;
              --v35;
            }
            while (v35);
            *v18++ = v34;
            ++v24;
            v25 += 8;
          }
          while (v18 < v23);
        }
        else
        {
          do
          {
            double v48 = v56;
            double v49 = 0.0;
            for (int j = v24; (unint64_t)j < v25; int j = (double *)((char *)j + v19))
            {
              double v51 = *v48++;
              double v49 = v49 + v51 * *j;
            }
            *v18++ = v49 + *v48 * *j;
            ++v24;
            v25 += 8;
          }
          while (v18 < v23);
        }
      }
      double v20 = v20 + 1.0;
      ++v16;
    }
    while (v16 != v8);
  }
  uint64_t v55 = off_26C6875D0;
  if (v56 && v59) {
    MEMORY[0x2166C5D70]();
  }
  uint64_t v61 = off_26C6875D0;
  uint64_t result = v62;
  if (v62 && v65) {
    return MEMORY[0x2166C5D70]();
  }
  return result;
}

void sub_215F29CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  Matrix<double>::~Matrix((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t CalculateWeightsForScale<double>(uint64_t result, int a2, signed int *a3, int *a4, double a5, double a6, double a7)
{
  int v7 = vcvtmd_s64_f64(a6 + a5 * -0.5);
  signed int v8 = v7;
  signed int v9 = v7 + a2;
  double v10 = (a6 - (double)v7) * a7;
  double v11 = fabs(v10);
  double v12 = v10 * v10;
  double v13 = v10 * v10 * v11;
  double v14 = 1.0;
  if (v11 <= 1.0)
  {
    double v15 = v12 * -2.5 + v13 * 1.5;
LABEL_5:
    double v16 = v15 + v14;
    if (v16 != 0.0) {
      goto LABEL_12;
    }
    goto LABEL_9;
  }
  double v14 = 2.0;
  if (v11 <= 2.0)
  {
    double v15 = v12 * 2.5 + v13 * -0.5 + v11 * -4.0;
    goto LABEL_5;
  }
  do
  {
LABEL_9:
    double v17 = (a6 - (double)++v8) * a7;
    double v18 = fabs(v17);
    double v19 = v17 * v17;
    double v20 = v17 * v17 * v18;
    if (v18 <= 1.0)
    {
      double v16 = v19 * -2.5 + v20 * 1.5 + 1.0;
    }
    else
    {
      double v16 = 0.0;
      if (v18 <= 2.0) {
        double v16 = v19 * 2.5 + v20 * -0.5 + v18 * -4.0 + 2.0;
      }
    }
  }
  while (v16 == 0.0);
LABEL_12:
  int v21 = *(double **)(result + 8);
  double *v21 = v16;
  int v22 = v21 + 1;
  if (v8 >= v9) {
    goto LABEL_18;
  }
  uint64_t v23 = (v9 + ~v8);
  if (v23 > 2)
  {
    int32x2_t v25 = vadd_s32(vdup_n_s32(v8), (int32x2_t)0x100000000);
    float64x2_t v26 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a6, 0);
    uint64_t v27 = v23 + 1;
    __asm { FMOV            V7.2D, #1.0 }
    uint64_t v33 = (v23 + 1) & 0x1FFFFFFFCLL;
    __asm { FMOV            V16.2D, #-2.5 }
    int v35 = (int8x16_t *)(v21 + 3);
    __asm
    {
      FMOV            V17.2D, #1.5
      FMOV            V18.2D, #2.0
      FMOV            V19.2D, #2.5
      FMOV            V20.2D, #-0.5
      FMOV            V21.2D, #-4.0
    }
    uint64_t v41 = v33;
    do
    {
      int32x2_t v42 = vadd_s32(v25, (int32x2_t)0x100000001);
      int32x2_t v43 = vadd_s32(v25, (int32x2_t)0x300000003);
      v44.i64[0] = v42.i32[0];
      v44.i64[1] = v42.i32[1];
      float64x2_t v45 = vcvtq_f64_s64(v44);
      v44.i64[0] = v43.i32[0];
      v44.i64[1] = v43.i32[1];
      float64x2_t v46 = vmulq_n_f64(vsubq_f64(v26, v45), a7);
      float64x2_t v47 = vmulq_n_f64(vsubq_f64(v26, vcvtq_f64_s64(v44)), a7);
      float64x2_t v48 = vabsq_f64(v46);
      float64x2_t v49 = vabsq_f64(v47);
      float64x2_t v50 = vmulq_f64(v46, v46);
      float64x2_t v51 = vmulq_f64(v47, v47);
      float64x2_t v52 = vmulq_f64(v50, v48);
      float64x2_t v53 = vmulq_f64(v51, v49);
      int8x16_t v54 = (int8x16_t)vcgeq_f64(_Q7, v48);
      int8x16_t v55 = (int8x16_t)vcgeq_f64(_Q7, v49);
      int8x16_t v56 = (int8x16_t)vcgeq_f64(_Q18, v48);
      int8x16_t v57 = (int8x16_t)vcgeq_f64(_Q18, v49);
      int8x16_t v58 = vbicq_s8(vbslq_s8(vbicq_s8(v56, v54), (int8x16_t)vaddq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(v50, _Q19), _Q20, v52), _Q21, v48), _Q18), (int8x16_t)vaddq_f64(vmlaq_f64(vmulq_f64(v50, _Q16), _Q17, v52), _Q7)), vbicq_s8(vmvnq_s8(v54), v56));
      int8x16_t v59 = vbicq_s8(vbslq_s8(vbicq_s8(v57, v55), (int8x16_t)vaddq_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(v51, _Q19), _Q20, v53), _Q21, v49), _Q18), (int8x16_t)vaddq_f64(vmlaq_f64(vmulq_f64(v51, _Q16), _Q17, v53), _Q7)), vbicq_s8(vmvnq_s8(v55), v57));
      v35[-1] = v58;
      *int v35 = v59;
      double v16 = v16 + *(double *)v58.i64 + *(double *)&v58.i64[1] + *(double *)v59.i64 + *(double *)&v59.i64[1];
      int32x2_t v25 = vadd_s32(v25, (int32x2_t)0x400000004);
      v35 += 2;
      v41 -= 4;
    }
    while (v41);
    v22 += v33;
    if (v27 == v33) {
      goto LABEL_18;
    }
    signed int v24 = v8 + v33;
  }
  else
  {
    signed int v24 = v8;
  }
  do
  {
    double v77 = (a6 - (double)++v24) * a7;
    double v78 = fabs(v77);
    double v79 = v77 * v77;
    double v80 = v77 * v77 * v78;
    if (v78 <= 1.0)
    {
      double v76 = v79 * -2.5 + v80 * 1.5 + 1.0;
    }
    else
    {
      double v76 = 0.0;
      if (v78 <= 2.0) {
        double v76 = v79 * 2.5 + v80 * -0.5 + v78 * -4.0 + 2.0;
      }
    }
    *v22++ = v76;
    double v16 = v16 + v76;
  }
  while (v9 != v24);
LABEL_18:
  int v60 = v7 + a2 + 1;
  uint64_t v61 = v22 - 1;
  do
  {
    double v62 = *v61--;
    --v60;
  }
  while (v62 == 0.0);
  uint64_t v63 = (v60 - v8 + 1);
  if (v60 - v8 != -1)
  {
    int v64 = *(float64x2_t **)(result + 8);
    unint64_t v65 = ~(unint64_t)v64;
    unint64_t v66 = (unint64_t)&v64->f64[v63];
    unsigned int v67 = &v64->f64[1];
    if (v66 <= (unint64_t)&v64->f64[1]) {
      unint64_t v66 = (unint64_t)&v64->f64[1];
    }
    unint64_t v68 = v66 + v65;
    unsigned int v69 = *(double **)(result + 8);
    if (v68 < 0x18) {
      goto LABEL_30;
    }
    uint64_t v70 = (v68 >> 3) + 1;
    float64x2_t v71 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v16, 0);
    if (&v64->f64[v60 - v8 + 1] > v67) {
      unsigned int v67 = &v64->f64[v60 - v8 + 1];
    }
    uint64_t v72 = ((((unint64_t)v67 + v65) >> 3) + 1) & 0x3FFFFFFFFFFFFFFCLL;
    uint64_t v73 = v64 + 1;
    do
    {
      float64x2_t v74 = vdivq_f64(*v73, v71);
      v73[-1] = vdivq_f64(v73[-1], v71);
      *uint64_t v73 = v74;
      v73 += 2;
      v72 -= 4;
    }
    while (v72);
    if (v70 != (v70 & 0x3FFFFFFFFFFFFFFCLL))
    {
      unsigned int v69 = &v64->f64[v70 & 0x3FFFFFFFFFFFFFFCLL];
LABEL_30:
      unint64_t v75 = (unint64_t)&v64->f64[v63];
      do
      {
        *unsigned int v69 = *v69 / v16;
        ++v69;
      }
      while ((unint64_t)v69 < v75);
    }
  }
  *a3 = v8;
  *a4 = v60;
  return result;
}

uint64_t MatrixNxPts<1u,double>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = off_26C6875D0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

void MatrixNxPts<1u,double>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = off_26C6875D0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  JUMPOUT(0x2166C5D90);
}

uint64_t ImageUtils::Scale<unsigned short>(uint64_t a1, uint64_t a2, double a3)
{
  int v6 = *(_DWORD *)(a1 + 16);
  uint64_t v7 = *(int *)(a1 + 20);
  unsigned int v8 = vcvtpd_u64_f64((double)v6 * a3);
  LODWORD(v3) = vcvtpd_u64_f64((double)(int)v7 * a3);
  float64x2_t v94 = off_26C6875D0;
  if (v6 * v3) {
    operator new[]();
  }
  uint64_t v95 = 0;
  int v96 = v6;
  int v97 = v3;
  char v98 = 0;
  unint64_t v99 = 8 * v6 * (unint64_t)v3;
  if (*(void *)(a2 + 32) < 8 * v8 * (unint64_t)v3)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  if (a3 >= 1.0) {
    double v9 = 4.0;
  }
  else {
    double v9 = 4.0 / a3;
  }
  unsigned int v10 = vcvtpd_u64_f64(v9);
  *(_DWORD *)(a2 + 16) = v8;
  *(_DWORD *)(a2 + 20) = v3;
  uint64_t v88 = off_26C6875D0;
  if (v10 != -4) {
    operator new[]();
  }
  double v11 = fmin(a3, 1.0);
  int v90 = 1;
  int v91 = 0;
  char v92 = 0;
  uint64_t v93 = 0;
  uint64_t v88 = (uint64_t (**)())&unk_26C6874F0;
  uint64_t v89 = 0;
  if (v3)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 2 * v7;
    unint64_t v14 = 8 * (v6 * v3);
    do
    {
      uint64_t v87 = 0;
      CalculateWeightsForScale<double>((uint64_t)&v88, -4, (signed int *)&v87 + 1, (int *)&v87, v9, ((double)v12 + 0.5) / a3 + -0.5, v11);
      if ((int)v87 >= (int)v7) {
        int v18 = v7 - 1;
      }
      else {
        int v18 = v87;
      }
      if ((int)v87 >= (int)v7) {
        int v19 = v87 - v7 + 1;
      }
      else {
        int v19 = 0;
      }
      double v20 = (double *)(v95 + 8 * v12);
      if ((unint64_t)v20 < v14)
      {
        uint64_t v21 = *(void *)(a1 + 8);
        int v22 = (_WORD *)(v21 + 2 * (HIDWORD(v87) & ~(SHIDWORD(v87) >> 31)));
        unint64_t v23 = v21 + 2 * v18;
        int v24 = (SHIDWORD(v87) >> 31) & -HIDWORD(v87);
        if (v24)
        {
          do
          {
            double v34 = v89;
            LOWORD(v15) = *v22;
            double v15 = (double)*(unint64_t *)&v15;
            double v35 = 0.0;
            int v36 = v24;
            do
            {
              double v37 = *v34++;
              double v35 = v35 + v37 * v15;
              --v36;
            }
            while (v36);
            double v38 = v22;
            if ((unint64_t)v22 < v23)
            {
              do
              {
                double v39 = *v34++;
                double v40 = v39;
                LODWORD(v39) = (unsigned __int16)*v38++;
                double v35 = v35 + v40 * (double)LODWORD(v39);
              }
              while ((unint64_t)v38 < v23);
              LOWORD(v40) = *v38;
              double v15 = (double)*(unint64_t *)&v40;
            }
            double v41 = v35 + *v34 * v15;
            if (v19)
            {
              int32x2_t v42 = v34 + 1;
              int v43 = v19;
              do
              {
                double v44 = *v42++;
                double v41 = v41 + v44 * v15;
                --v43;
              }
              while (v43);
            }
            double *v20 = v41;
            v20 += v3;
            int v22 = (_WORD *)((char *)v22 + v13);
            v23 += v13;
          }
          while ((unint64_t)v20 < v14);
        }
        else if (v19)
        {
          do
          {
            int32x2_t v25 = v89;
            double v26 = 0.0;
            for (i = v22; (unint64_t)i < v23; double v26 = v26 + v16 * (double)LODWORD(v28))
            {
              double v28 = *v25++;
              double v16 = v28;
              LODWORD(v28) = (unsigned __int16)*i++;
            }
            double v30 = *v25;
            int v29 = v25 + 1;
            LOWORD(v16) = *i;
            double v16 = (double)*(unint64_t *)&v16;
            double v31 = v26 + v30 * v16;
            int v32 = v19;
            do
            {
              double v33 = *v29++;
              double v31 = v31 + v33 * v16;
              --v32;
            }
            while (v32);
            double *v20 = v31;
            v20 += v3;
            int v22 = (_WORD *)((char *)v22 + v13);
            v23 += v13;
          }
          while ((unint64_t)v20 < v14);
        }
        else
        {
          do
          {
            float64x2_t v45 = v89;
            double v46 = 0.0;
            for (j = v22; (unint64_t)j < v23; double v46 = v46 + v49 * (double)LODWORD(v48))
            {
              double v48 = *v45++;
              double v49 = v48;
              LODWORD(v48) = (unsigned __int16)*j++;
              double v17 = (double)LODWORD(v48);
            }
            LOWORD(v17) = *j;
            double v17 = (double)*(unint64_t *)&v17;
            double *v20 = v46 + *v45 * v17;
            v20 += v3;
            int v22 = (_WORD *)((char *)v22 + v13);
            v23 += v13;
          }
          while ((unint64_t)v20 < v14);
        }
      }
      ++v12;
    }
    while (v12 != v3);
  }
  if (v8)
  {
    int v50 = 0;
    float64x2_t v51 = *(double **)(a2 + 8);
    uint64_t v52 = 8 * v3;
    double v53 = 0.0;
    do
    {
      uint64_t v87 = 0;
      CalculateWeightsForScale<double>((uint64_t)&v88, -4, (signed int *)&v87 + 1, (int *)&v87, v9, (v53 + 0.5) / a3 + -0.5, v11);
      if ((int)v87 >= v6) {
        int v54 = v6 - 1;
      }
      else {
        int v54 = v87;
      }
      if ((int)v87 >= v6) {
        int v55 = v87 - v6 + 1;
      }
      else {
        int v55 = 0;
      }
      if (v3)
      {
        int8x16_t v56 = &v51[v3];
        int8x16_t v57 = (double *)(v95 + 8 * (HIDWORD(v87) & ~(SHIDWORD(v87) >> 31)) * v3);
        unint64_t v58 = v95 + 8 * (v54 * v3);
        int v59 = (SHIDWORD(v87) >> 31) & -HIDWORD(v87);
        if (v59)
        {
          do
          {
            uint64_t v70 = v89;
            double v71 = *v57;
            double v72 = 0.0;
            int v73 = v59;
            do
            {
              double v74 = *v70++;
              double v72 = v72 + v74 * v71;
              --v73;
            }
            while (v73);
            unint64_t v75 = v57;
            if ((unint64_t)v57 < v58)
            {
              do
              {
                double v76 = *v70++;
                double v72 = v72 + v76 * *v75;
                unint64_t v75 = (double *)((char *)v75 + v52);
              }
              while ((unint64_t)v75 < v58);
              double v71 = *v75;
            }
            double v77 = v72 + *v70 * v71;
            if (v55)
            {
              double v78 = v70 + 1;
              int v79 = v55;
              do
              {
                double v80 = *v78++;
                double v77 = v77 + v80 * v71;
                --v79;
              }
              while (v79);
            }
            *v51++ = v77;
            ++v57;
            v58 += 8;
          }
          while (v51 < v56);
        }
        else if (v55)
        {
          do
          {
            int v60 = v89;
            double v61 = 0.0;
            for (k = v57; (unint64_t)k < v58; k = (double *)((char *)k + v52))
            {
              double v63 = *v60++;
              double v61 = v61 + v63 * *k;
            }
            double v65 = *v60;
            int v64 = v60 + 1;
            double v66 = *k;
            double v67 = v61 + v65 * *k;
            int v68 = v55;
            do
            {
              double v69 = *v64++;
              double v67 = v67 + v69 * v66;
              --v68;
            }
            while (v68);
            *v51++ = v67;
            ++v57;
            v58 += 8;
          }
          while (v51 < v56);
        }
        else
        {
          do
          {
            float64x2_t v81 = v89;
            double v82 = 0.0;
            for (m = v57; (unint64_t)m < v58; m = (double *)((char *)m + v52))
            {
              double v84 = *v81++;
              double v82 = v82 + v84 * *m;
            }
            *v51++ = v82 + *v81 * *m;
            ++v57;
            v58 += 8;
          }
          while (v51 < v56);
        }
      }
      double v53 = v53 + 1.0;
      ++v50;
    }
    while (v50 != v8);
  }
  uint64_t v88 = off_26C6875D0;
  if (v89 && v92) {
    MEMORY[0x2166C5D70]();
  }
  float64x2_t v94 = off_26C6875D0;
  uint64_t result = v95;
  if (v95 && v98) {
    return MEMORY[0x2166C5D70]();
  }
  return result;
}

void sub_215F2A80C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a20)
  {
    if (a22) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t ImageUtils::Scale<unsigned char>(uint64_t a1, uint64_t a2, double a3)
{
  int v5 = *(_DWORD *)(a1 + 16);
  int v6 = *(_DWORD *)(a1 + 20);
  unsigned int v7 = vcvtpd_u64_f64((double)v5 * a3);
  LODWORD(v3) = vcvtpd_u64_f64((double)v6 * a3);
  int8x16_t v56 = off_26C6875D0;
  if (v5 * v3) {
    operator new[]();
  }
  uint64_t v57 = 0;
  int v58 = v5;
  int v59 = v3;
  char v60 = 0;
  unint64_t v61 = 8 * v5 * (unint64_t)v3;
  if (*(void *)(a2 + 32) < 8 * v7 * (unint64_t)v3)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  if (a3 >= 1.0) {
    double v8 = 4.0;
  }
  else {
    double v8 = 4.0 / a3;
  }
  unsigned int v9 = vcvtpd_u64_f64(v8);
  *(_DWORD *)(a2 + 16) = v7;
  *(_DWORD *)(a2 + 20) = v3;
  int v50 = off_26C6875D0;
  if (v9 != -4) {
    operator new[]();
  }
  double v10 = fmin(a3, 1.0);
  int v52 = 1;
  int v53 = 0;
  char v54 = 0;
  uint64_t v55 = 0;
  int v50 = (uint64_t (**)())&unk_26C6874F0;
  float64x2_t v51 = 0;
  if (v3)
  {
    uint64_t v11 = 0;
    do
    {
      uint64_t v49 = 0;
      CalculateWeightsForScale<double>((uint64_t)&v50, -4, (signed int *)&v49 + 1, (int *)&v49, v8, ((double)v11 + 0.5) / a3 + -0.5, v10);
      if (v49 < 0) {
        HIDWORD(v49) = 0;
      }
      if ((int)v49 >= v6) {
        LODWORD(v49) = v6 - 1;
      }
      ++v11;
    }
    while (v11 != v3);
  }
  if (v7)
  {
    int v12 = 0;
    uint64_t v13 = *(double **)(a2 + 8);
    uint64_t v14 = 8 * v3;
    double v15 = 0.0;
    do
    {
      uint64_t v49 = 0;
      CalculateWeightsForScale<double>((uint64_t)&v50, -4, (signed int *)&v49 + 1, (int *)&v49, v8, (v15 + 0.5) / a3 + -0.5, v10);
      if ((int)v49 >= v5) {
        int v16 = v5 - 1;
      }
      else {
        int v16 = v49;
      }
      if ((int)v49 >= v5) {
        int v17 = v49 - v5 + 1;
      }
      else {
        int v17 = 0;
      }
      if (v3)
      {
        int v18 = &v13[v3];
        int v19 = (double *)(v57 + 8 * (HIDWORD(v49) & ~(SHIDWORD(v49) >> 31)) * v3);
        unint64_t v20 = v57 + 8 * (v16 * v3);
        int v21 = (SHIDWORD(v49) >> 31) & -HIDWORD(v49);
        if (v21)
        {
          do
          {
            int v32 = v51;
            double v33 = *v19;
            double v34 = 0.0;
            int v35 = v21;
            do
            {
              double v36 = *v32++;
              double v34 = v34 + v36 * v33;
              --v35;
            }
            while (v35);
            double v37 = v19;
            if ((unint64_t)v19 < v20)
            {
              do
              {
                double v38 = *v32++;
                double v34 = v34 + v38 * *v37;
                double v37 = (double *)((char *)v37 + v14);
              }
              while ((unint64_t)v37 < v20);
              double v33 = *v37;
            }
            double v39 = v34 + *v32 * v33;
            if (v17)
            {
              double v40 = v32 + 1;
              int v41 = v17;
              do
              {
                double v42 = *v40++;
                double v39 = v39 + v42 * v33;
                --v41;
              }
              while (v41);
            }
            *v13++ = v39;
            ++v19;
            v20 += 8;
          }
          while (v13 < v18);
        }
        else if (v17)
        {
          do
          {
            int v22 = v51;
            double v23 = 0.0;
            for (int i = v19; (unint64_t)i < v20; int i = (double *)((char *)i + v14))
            {
              double v25 = *v22++;
              double v23 = v23 + v25 * *i;
            }
            double v27 = *v22;
            double v26 = v22 + 1;
            double v28 = *i;
            double v29 = v23 + v27 * *i;
            int v30 = v17;
            do
            {
              double v31 = *v26++;
              double v29 = v29 + v31 * v28;
              --v30;
            }
            while (v30);
            *v13++ = v29;
            ++v19;
            v20 += 8;
          }
          while (v13 < v18);
        }
        else
        {
          do
          {
            int v43 = v51;
            double v44 = 0.0;
            for (int j = v19; (unint64_t)j < v20; int j = (double *)((char *)j + v14))
            {
              double v46 = *v43++;
              double v44 = v44 + v46 * *j;
            }
            *v13++ = v44 + *v43 * *j;
            ++v19;
            v20 += 8;
          }
          while (v13 < v18);
        }
      }
      double v15 = v15 + 1.0;
      ++v12;
    }
    while (v12 != v7);
  }
  int v50 = off_26C6875D0;
  if (v51 && v54) {
    MEMORY[0x2166C5D70]();
  }
  int8x16_t v56 = off_26C6875D0;
  uint64_t result = v57;
  if (v57 && v60) {
    return MEMORY[0x2166C5D70]();
  }
  return result;
}

void sub_215F2AEF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a20)
  {
    if (a22) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t ImageUtils::Scale<BOOL>(uint64_t a1, uint64_t a2, double a3)
{
  int v5 = *(_DWORD *)(a1 + 16);
  unsigned int v6 = vcvtpd_u64_f64((double)v5 * a3);
  LODWORD(v3) = vcvtpd_u64_f64((double)*(int *)(a1 + 20) * a3);
  int v59 = off_26C6875D0;
  if (v5 * v3) {
    operator new[]();
  }
  uint64_t v60 = 0;
  int v61 = v5;
  int v62 = v3;
  char v63 = 0;
  unint64_t v64 = 8 * v5 * (unint64_t)v3;
  if (*(void *)(a2 + 32) < 8 * v6 * (unint64_t)v3)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  int v7 = v5;
  if (a3 >= 1.0) {
    double v8 = 4.0;
  }
  else {
    double v8 = 4.0 / a3;
  }
  unsigned int v9 = vcvtpd_u64_f64(v8);
  *(_DWORD *)(a2 + 16) = v6;
  *(_DWORD *)(a2 + 20) = v3;
  int v53 = off_26C6875D0;
  if (v9 != -4) {
    operator new[]();
  }
  double v10 = fmin(a3, 1.0);
  int v55 = 1;
  int v56 = 0;
  char v57 = 0;
  uint64_t v58 = 0;
  int v53 = (uint64_t (**)())&unk_26C6874F0;
  char v54 = 0;
  if (v3)
  {
    uint64_t v11 = 0;
    int v12 = v7;
    do
    {
      uint64_t v52 = 0;
      CalculateWeightsForScale<double>((uint64_t)&v53, -4, (signed int *)&v52 + 1, (int *)&v52, v8, ((double)v11++ + 0.5) / a3 + -0.5, v10);
    }
    while (v11 != v3);
    if (v6)
    {
      int v13 = 0;
      int v14 = v7 - 1;
      double v15 = *(double **)(a2 + 8);
      uint64_t v16 = 8 * v3;
      double v17 = 0.0;
      do
      {
        uint64_t v52 = 0;
        CalculateWeightsForScale<double>((uint64_t)&v53, -4, (signed int *)&v52 + 1, (int *)&v52, v8, (v17 + 0.5) / a3 + -0.5, v10);
        if ((int)v52 >= v12) {
          int v18 = v14;
        }
        else {
          int v18 = v52;
        }
        if ((int)v52 >= v12) {
          int v19 = v52 - v12 + 1;
        }
        else {
          int v19 = 0;
        }
        unint64_t v20 = &v15[v3];
        int v21 = (double *)(v60 + 8 * (HIDWORD(v52) & ~(SHIDWORD(v52) >> 31)) * v3);
        unint64_t v22 = v60 + 8 * (v18 * v3);
        if (v52 < 0)
        {
          if (-HIDWORD(v52) != 1 && HIDWORD(v52) != 0) {
            int v37 = -HIDWORD(v52);
          }
          else {
            int v37 = 1;
          }
          do
          {
            double v38 = v54;
            double v39 = *v21;
            double v40 = 0.0;
            int v41 = v37;
            do
            {
              double v42 = *v38++;
              double v40 = v40 + v42 * v39;
              --v41;
            }
            while (v41);
            int v43 = v21;
            if ((unint64_t)v21 < v22)
            {
              do
              {
                double v44 = *v38++;
                double v40 = v40 + v44 * *v43;
                int v43 = (double *)((char *)v43 + v16);
              }
              while ((unint64_t)v43 < v22);
              double v39 = *v43;
            }
            double v45 = v40 + *v38 * v39;
            if (v19)
            {
              double v46 = v38 + 1;
              int v47 = v19;
              do
              {
                double v48 = *v46++;
                double v45 = v45 + v48 * v39;
                --v47;
              }
              while (v47);
            }
            *v15++ = v45;
            ++v21;
            v22 += 8;
          }
          while (v15 < v20);
        }
        else if (v19)
        {
          do
          {
            double v23 = v54;
            double v24 = 0.0;
            for (int i = v21; (unint64_t)i < v22; int i = (double *)((char *)i + v16))
            {
              double v26 = *v23++;
              double v24 = v24 + v26 * *i;
            }
            double v28 = *v23;
            double v27 = v23 + 1;
            double v29 = *i;
            double v30 = v24 + v28 * *i;
            int v31 = v19;
            do
            {
              double v32 = *v27++;
              double v30 = v30 + v32 * v29;
              --v31;
            }
            while (v31);
            *v15++ = v30;
            ++v21;
            v22 += 8;
          }
          while (v15 < v20);
        }
        else
        {
          do
          {
            double v33 = v54;
            double v34 = 0.0;
            for (int j = v21; (unint64_t)j < v22; int j = (double *)((char *)j + v16))
            {
              double v36 = *v33++;
              double v34 = v34 + v36 * *j;
            }
            *v15++ = v34 + *v33 * *j;
            ++v21;
            v22 += 8;
          }
          while (v15 < v20);
        }
        double v17 = v17 + 1.0;
        ++v13;
      }
      while (v13 != v6);
    }
  }
  else if (v6)
  {
    double v49 = 0.0;
    do
    {
      CalculateWeightsForScale<double>((uint64_t)&v53, -4, (signed int *)&v52 + 1, (int *)&v52, v8, (v49 + 0.5) / a3 + -0.5, v10);
      double v49 = v49 + 1.0;
      --v6;
    }
    while (v6);
  }
  int v53 = off_26C6875D0;
  if (v54 && v57) {
    MEMORY[0x2166C5D70]();
  }
  int v59 = off_26C6875D0;
  uint64_t result = v60;
  if (v60 && v63) {
    return MEMORY[0x2166C5D70]();
  }
  return result;
}

void sub_215F2BD54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a20)
  {
    if (a22) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t ImageUtils::Scale<double>(uint64_t a1, double a2, double a3, uint64_t a4, uint64_t a5)
{
  return Scale<double>(a1, a5, a2, a3);
}

double ImageUtils::Gradient<double>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(unsigned int *)(a1 + 20);
  unint64_t v6 = 8 * v5 * (unint64_t)v4;
  if (*(void *)(a2 + 32) < v6)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v5;
  *(_DWORD *)(a2 + 20) = v4;
  int v7 = *(double **)(a3 + 8);
  if (*(void *)(a3 + 32) < v6)
  {
    if (v7 && *(unsigned char *)(a3 + 24)) {
      MEMORY[0x2166C5D70]();
    }
    operator new[]();
  }
  *(_DWORD *)(a3 + 16) = v5;
  *(_DWORD *)(a3 + 20) = v4;
  double v8 = *(double **)(a1 + 8);
  unsigned int v9 = *(double **)(a2 + 8);
  double v10 = v8 + 1;
  double *v9 = v8[1] - *v8;
  uint64_t v11 = (float64x2_t *)(v9 + 1);
  double *v7 = v8[v4] - *v8;
  int v12 = v7 + 1;
  uint64_t v13 = (v4 - 1);
  if (v13 < 2)
  {
    uint64_t v16 = v9 + 1;
    goto LABEL_56;
  }
  uint64_t v14 = (v4 - 3);
  if (v14 > 0xE)
  {
    uint64_t v17 = 8 * v14 + 16;
    int v18 = (double *)((char *)v9 + v17);
    int v19 = (float64x2_t *)((char *)v7 + v17);
    unint64_t v20 = (unint64_t)&v8[v14 + 3];
    int v21 = &v8[v4];
    unint64_t v22 = v21 + 1;
    unint64_t v23 = (unint64_t)v21 + v17;
    BOOL v25 = (unint64_t)v11 < v20 && v8 < v18;
    BOOL v27 = (unint64_t)v11 < v23 && v22 < v18;
    BOOL v29 = (unint64_t)v12 < v20 && v8 < (double *)v19;
    BOOL v31 = (unint64_t)v12 < v23 && v22 < (double *)v19;
    BOOL v32 = v12 >= v18 || v11 >= v19;
    int v15 = 1;
    if (v32 && !v25 && !v27 && !v29 && !v31)
    {
      uint64_t v33 = v14 + 1;
      uint64_t v34 = (v14 + 1) & 0x1FFFFFFFELL;
      uint64_t v35 = 8 * v34;
      uint64_t v16 = &v11->f64[v34];
      int v15 = v33 | 1;
      __asm { FMOV            V0.2D, #0.5 }
      double v40 = (float64x2_t *)v12;
      int v41 = v8 + 1;
      uint64_t v42 = v34;
      do
      {
        *v11++ = vmulq_f64(vsubq_f64(*(float64x2_t *)(v41 + 1), *(float64x2_t *)(v41 - 1)), _Q0);
        float64x2_t v43 = *(float64x2_t *)&v41[v4];
        float64x2_t v44 = *(float64x2_t *)v41;
        v41 += 2;
        *v40++ = vsubq_f64(v43, v44);
        v42 -= 2;
      }
      while (v42);
      double v10 = (double *)((char *)v10 + v35);
      int v12 = (double *)((char *)v12 + v35);
      if (v33 == v34)
      {
        double v8 = v10 - 1;
        goto LABEL_56;
      }
      double v8 = (double *)((char *)v8 + v35);
      uint64_t v11 = (float64x2_t *)v16;
    }
  }
  else
  {
    int v15 = 1;
  }
  uint64_t v45 = 0;
  int v46 = ~v15 + v4;
  do
  {
    double v47 = v8[2];
    double v48 = *v8;
    double v8 = &v10[v45];
    v11->f64[v45] = (v47 - v48) * 0.5;
    v12[v45] = v10[v4 + v45] - v10[v45];
    ++v45;
    --v46;
  }
  while (v46);
  double v10 = (double *)((char *)v10 + v45 * 8);
  double v8 = v10 - 1;
  uint64_t v16 = &v11->f64[v45];
  int v12 = (double *)((char *)v12 + v45 * 8);
LABEL_56:
  *uint64_t v16 = *v10 - *v8;
  double v49 = v16 + 1;
  double *v12 = v10[v4] - *v10;
  int v50 = v12 + 1;
  unsigned int v51 = v5 - 1;
  uint64_t v52 = v10 + 1;
  if (v5 - 1 < 2) {
    goto LABEL_175;
  }
  if (v13 > 1)
  {
    uint64_t v53 = (v4 - 3);
    uint64_t v54 = 8 * v53 + 24;
    uint64_t v55 = v54 - 8 * v4;
    uint64_t v56 = (v53 + 1) & 0x1FFFFFFFELL;
    uint64_t v57 = v56;
    uint64_t v177 = 8 * v56 - 8;
    int v58 = 1;
    __asm { FMOV            V1.2D, #0.5 }
    while (1)
    {
      unint64_t v64 = v10 + 2;
      double *v49 = v10[2] - *v52;
      double *v50 = (v52[v4] - v52[-v4]) * 0.5;
      double v65 = (float64x2_t *)(v16 + 2);
      double v66 = (float64x2_t *)(v12 + 2);
      if (v53 < 0xD)
      {
        int v67 = 1;
        goto LABEL_115;
      }
      uint64_t v68 = v13;
      double v69 = (float64x2_t *)((char *)v16 + v54);
      uint64_t v70 = (float64x2_t *)((char *)v12 + v54);
      double v71 = (char *)v10 + 16 - 8 * v4;
      double v72 = (float64x2_t *)((char *)v10 + v55);
      int v73 = &v10[v4 + 2];
      double v74 = &v10[v53 + 3 + v4];
      unint64_t v75 = v10 + 1;
      double v76 = &v10[v53 + 4];
      BOOL v77 = v65 >= (float64x2_t *)((char *)v10 + v55) || v71 >= (char *)v69;
      BOOL v78 = !v77;
      BOOL v79 = v65 >= (float64x2_t *)v74 || v73 >= (double *)v69;
      BOOL v80 = !v79;
      BOOL v81 = v65 >= (float64x2_t *)v76 || v75 >= (double *)v69;
      BOOL v82 = !v81;
      BOOL v83 = v66 >= v72 || v71 >= (char *)v70;
      BOOL v84 = !v83;
      BOOL v85 = v66 >= (float64x2_t *)v74 || v73 >= (double *)v70;
      BOOL v86 = !v85;
      BOOL v87 = v66 >= (float64x2_t *)v76 || v75 >= (double *)v70;
      BOOL v88 = !v87;
      BOOL v89 = v66 >= v69 || v65 >= v70;
      int v67 = 1;
      if (!v89 || v78 || v80 || v82 || v84 || v86 || v88) {
        break;
      }
      uint64_t v16 = &v65->f64[v57];
      int v90 = v65;
      int v91 = v66;
      char v92 = v64;
      uint64_t v93 = (v53 + 1) & 0x1FFFFFFFELL;
      do
      {
        *v90++ = vmulq_f64(vsubq_f64(*(float64x2_t *)(v92 + 1), *(float64x2_t *)(v92 - 1)), _Q1);
        *v91++ = vmulq_f64(vsubq_f64(*(float64x2_t *)&v92[v4], *(float64x2_t *)&v92[-v4]), _Q1);
        v92 += 2;
        v93 -= 2;
      }
      while (v93);
      int v12 = &v66->f64[v57];
      double v10 = &v64[v57];
      uint64_t v13 = v68;
      if (v53 + 1 != v56)
      {
        int v67 = (v4 - 2) | 1;
        double v66 = (float64x2_t *)((char *)v66 + v57 * 8);
        double v65 = (float64x2_t *)((char *)v65 + v57 * 8);
        unint64_t v64 = (double *)((char *)v64 + v57 * 8);
        goto LABEL_115;
      }
      uint64_t v60 = (uint64_t)v66 + v177;
      uint64_t v61 = (uint64_t)v65 + v177;
      int v62 = (double *)((char *)v64 + v177);
LABEL_60:
      double *v12 = (v10[v4] - v10[-v4]) * 0.5;
      double v63 = *v62;
      uint64_t v52 = v62 + 2;
      *uint64_t v16 = *v10 - v63;
      ++v58;
      int v50 = (double *)(v60 + 16);
      double v49 = (double *)(v61 + 16);
      if (v58 == v51) {
        goto LABEL_175;
      }
    }
    uint64_t v13 = v68;
LABEL_115:
    uint64_t v94 = 0;
    int v95 = v13 - v67;
    do
    {
      v65->f64[v94] = (v64[v94 + 1] - v64[v94 - 1]) * 0.5;
      v66->f64[v94] = (v64[v4 + v94] - v64[v94 - v4]) * 0.5;
      ++v94;
      --v95;
    }
    while (v95);
    int v12 = &v66->f64[v94];
    uint64_t v60 = (uint64_t)v66 + v94 * 8 - 8;
    uint64_t v16 = &v65->f64[v94];
    uint64_t v61 = (uint64_t)v65 + v94 * 8 - 8;
    double v10 = &v64[v94];
    int v62 = v10 - 1;
    goto LABEL_60;
  }
  uint64_t v96 = v5 - 3;
  if (v96 > 0xA)
  {
    uint64_t v98 = 16 * v96 + 24;
    unint64_t v99 = (double *)((char *)v16 + v98);
    float64x2_t v100 = (double *)((char *)v12 + v98);
    int v101 = (double *)((char *)v10 + v98);
    unint64_t v102 = (unint64_t)&v10[-v4 + 1];
    uint64_t v103 = (double *)((char *)v10 + v98 - 8 * v4);
    uint64_t v104 = &v10[v4];
    int8x16_t v105 = v104 + 1;
    unint64_t v106 = (unint64_t)v104 + v98;
    BOOL v108 = v49 < v101 && v52 < v99;
    BOOL v110 = v49 < v103 && v102 < (unint64_t)v99;
    BOOL v112 = (unint64_t)v49 < v106 && v105 < v99;
    BOOL v114 = v50 < v101 && v52 < v100;
    BOOL v116 = v50 < v103 && v102 < (unint64_t)v100;
    BOOL v118 = (unint64_t)v50 < v106 && v105 < v100;
    BOOL v119 = v50 >= v99 || v49 >= v100;
    int v97 = 1;
    if (v119 && !v108 && !v110 && !v112 && !v114 && !v116 && !v118)
    {
      uint64_t v120 = v96 + 1;
      uint64_t v121 = (v96 + 1) & 0x1FFFFFFFELL;
      uint64_t v122 = 16 * v121;
      id v123 = &v49[2 * v121];
      int v97 = v120 | 1;
      v16 += 2 * v121;
      __asm { FMOV            V0.2D, #0.5 }
      uint64_t v126 = v10 + 1;
      uint64_t v127 = (float64x2_t *)(v12 + 1);
      uint64_t v128 = v121;
      do
      {
        uint64_t v129 = v126;
        float64x2x2_t v178 = vld2q_f64(v129);
        uint64_t v124 = -1 * v4;
        uint64_t v130 = (float64x2_t *)&v129[v124];
        v178.val[0] = vsubq_f64(v178.val[1], v178.val[0]);
        float64x2_t v131 = vmulq_f64(vsubq_f64(*(float64x2_t *)&v126[v4 + 2], v130[1]), _Q0);
        float64x2_t *v127 = vmulq_f64(vsubq_f64(*(float64x2_t *)&v126[v4], *v130), _Q0);
        v127[1] = v131;
        v127 += 2;
        float64x2x2_t v179 = vld2q_f64(v126);
        v126 += 4;
        v178.val[1] = vsubq_f64(v179.val[1], v179.val[0]);
        vst2q_f64(v49, v178);
        v49 += 4;
        v128 -= 2;
      }
      while (v128);
      uint64_t v52 = (double *)((char *)v52 + v122);
      int v50 = (double *)((char *)v50 + v122);
      double v10 = (double *)((char *)v10 + v122);
      if (v120 == v121)
      {
        double v49 = v123;
        goto LABEL_175;
      }
      int v12 = (double *)((char *)v12 + v122);
      double v49 = v123;
    }
  }
  else
  {
    int v97 = 1;
  }
  uint64_t v132 = 0;
  unsigned int v133 = ~v97 + v5;
  double v134 = v12;
  uint64_t v135 = v16;
  uint64_t v136 = v10;
  do
  {
    double *v49 = v10[v132 + 2] - *v52;
    double v137 = v52[v4];
    double v138 = v52[-v4];
    uint64_t v52 = v136 + 3;
    v136 += 2;
    double *v50 = (v137 - v138) * 0.5;
    double v49 = v135 + 3;
    v135 += 2;
    float v139 = &v16[v132];
    int v50 = v134 + 3;
    v134 += 2;
    v12[v132 + 2] = (v10[v4 + 2 + v132] - v10[v132 + 2 - v4]) * 0.5;
    double v141 = v10[v132 + 1];
    double v140 = v10[v132 + 2];
    v132 += 2;
    v139[2] = v140 - v141;
    --v133;
  }
  while (v133);
  int v50 = &v12[v132 + 1];
  double v49 = &v16[v132 + 1];
  double v10 = (double *)((char *)v10 + v132 * 8);
  uint64_t v52 = v10 + 1;
LABEL_175:
  double *v49 = v10[2] - *v52;
  float64x2_t v142 = (float64x2_t *)(v49 + 1);
  double *v50 = *v52 - v52[-v4];
  float64x2_t v143 = v50 + 1;
  float64x2_t v144 = v52 + 1;
  if (v13 < 2)
  {
    float64x2_t v147 = v49 + 1;
  }
  else
  {
    uint64_t v145 = (v4 - 3);
    if (v145 > 0xE)
    {
      uint64_t v148 = 8 * v145 + 16;
      float64x2_t v149 = (double *)((char *)v49 + v148);
      int v150 = (float64x2_t *)((char *)v50 + v148);
      unint64_t v151 = (unint64_t)&v52[-v4 + 1];
      v152 = (float64x2_t *)((char *)v52 + v148 - 8 * v4);
      unint64_t v153 = (unint64_t)&v52[v145 + 3];
      BOOL v155 = v142 < v152 && v151 < (unint64_t)v149;
      BOOL v157 = (unint64_t)v142 < v153 && v52 < v149;
      BOOL v159 = v143 < (double *)v152 && v151 < (unint64_t)v150;
      BOOL v161 = (unint64_t)v143 < v153 && v52 < (double *)v150;
      BOOL v162 = v143 >= v149 || v142 >= v150;
      int v146 = 1;
      if (v162 && !v155 && !v157 && !v159 && !v161)
      {
        uint64_t v163 = v145 + 1;
        uint64_t v164 = (v145 + 1) & 0x1FFFFFFFELL;
        uint64_t v165 = 8 * v164;
        float64x2_t v147 = &v142->f64[v164];
        int v146 = v163 | 1;
        __asm { FMOV            V0.2D, #0.5 }
        int v167 = (float64x2_t *)v143;
        int v168 = v52 + 1;
        uint64_t v169 = v164;
        do
        {
          *v142++ = vmulq_f64(vsubq_f64(*(float64x2_t *)(v168 + 1), *(float64x2_t *)(v168 - 1)), _Q0);
          float64x2_t v170 = *(float64x2_t *)&v168[-v4];
          float64x2_t v171 = *(float64x2_t *)v168;
          v168 += 2;
          *v167++ = vsubq_f64(v171, v170);
          v169 -= 2;
        }
        while (v169);
        float64x2_t v144 = (double *)((char *)v144 + v165);
        float64x2_t v143 = (double *)((char *)v143 + v165);
        if (v163 == v164)
        {
          uint64_t v52 = v144 - 1;
          goto LABEL_220;
        }
        uint64_t v52 = (double *)((char *)v52 + v165);
        float64x2_t v142 = (float64x2_t *)v147;
      }
    }
    else
    {
      int v146 = 1;
    }
    uint64_t v172 = 0;
    int v173 = ~v146 + v4;
    do
    {
      double v174 = v52[2];
      double v175 = *v52;
      uint64_t v52 = &v144[v172];
      v142->f64[v172] = (v174 - v175) * 0.5;
      v143[v172] = v144[v172] - v144[v172 - v4];
      ++v172;
      --v173;
    }
    while (v173);
    float64x2_t v144 = (double *)((char *)v144 + v172 * 8);
    uint64_t v52 = v144 - 1;
    float64x2_t v147 = &v142->f64[v172];
    float64x2_t v143 = (double *)((char *)v143 + v172 * 8);
  }
LABEL_220:
  *float64x2_t v147 = *v144 - *v52;
  double result = *v144 - v144[-v4];
  *float64x2_t v143 = result;
  return result;
}

int8x16_t *ImageUtils::Fliplr<double>(int8x16_t *result, uint64_t a2)
{
  int v2 = result;
  uint64_t v4 = result[1].u32[0];
  uint64_t v3 = result[1].u32[1];
  if (*(void *)(a2 + 32) < 8 * v4 * (unint64_t)v3)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v4;
  *(_DWORD *)(a2 + 20) = v3;
  if (v4) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    unint64_t v6 = *(int8x16_t **)(a2 + 8);
    if (v3 > 5)
    {
      uint64_t v9 = 8 * (v3 - 1);
      uint64_t v10 = v9 + 8;
      uint64_t v11 = 8 * v3;
      uint64_t v12 = 8 * v3 - 8;
      uint64_t v13 = v12 - v9;
      uint64_t v14 = 8 * (v3 & 0xFFFFFFFC);
      if ((v3 & 0xFFFFFFFC) == v3)
      {
        unsigned int v15 = 0;
        uint64_t v16 = 0;
        uint64_t v17 = v11 - 16;
        do
        {
          double result = (int8x16_t *)(8 * v15);
          uint64_t v18 = v2->i64[1];
          uint64_t v19 = v18 + 8 * (v3 * v16);
          unint64_t v20 = v19 + 8 * v3;
          unint64_t v21 = v19 + v13;
          if ((unint64_t)v6 >= v20 || v21 >= (unint64_t)v6->u64 + v10)
          {
            unint64_t v23 = v6 + 1;
            double result = (int8x16_t *)((char *)result + v18 + v17);
            uint64_t v24 = v3 & 0xFFFFFFFC;
            do
            {
              int8x16_t v25 = vextq_s8(result[-1], result[-1], 8uLL);
              v23[-1] = vextq_s8(*result, *result, 8uLL);
              int8x16_t *v23 = v25;
              v23 += 2;
              result -= 2;
              v24 -= 4;
            }
            while (v24);
            unint64_t v6 = (int8x16_t *)((char *)v6 + v14);
          }
          else
          {
            double v26 = (uint64_t *)((char *)result->i64 + v18 + v12);
            LODWORD(result) = v3;
            do
            {
              uint64_t v27 = *v26--;
              v6->i64[0] = v27;
              unint64_t v6 = (int8x16_t *)((char *)v6 + 8);
              double result = (int8x16_t *)(result - 1);
            }
            while (result);
          }
          ++v16;
          v15 += v3;
        }
        while (v16 != v4);
      }
      else
      {
        unsigned int v28 = 0;
        uint64_t v29 = 0;
        uint64_t v30 = v11 - 16;
        do
        {
          uint64_t v31 = v2->i64[1];
          uint64_t v32 = v31 + 8 * (v3 * v29);
          unint64_t v33 = v32 + 8 * v3;
          unint64_t v34 = v32 + v13;
          if ((unint64_t)v6 >= v33 || v34 >= (unint64_t)v6->u64 + v10)
          {
            double v36 = (int8x16_t *)((char *)v6 + v14);
            int v37 = v6 + 1;
            double v38 = (int8x16_t *)(v31 + v30 + 8 * v28);
            uint64_t v39 = v3 & 0xFFFFFFFC;
            do
            {
              int8x16_t v40 = vextq_s8(v38[-1], v38[-1], 8uLL);
              v37[-1] = vextq_s8(*v38, *v38, 8uLL);
              *int v37 = v40;
              v37 += 2;
              v38 -= 2;
              v39 -= 4;
            }
            while (v39);
            v33 -= v14;
            int v41 = v3 & 0xFFFFFFFC;
            unint64_t v6 = v36;
          }
          else
          {
            int v41 = 0;
          }
          LODWORD(result) = v3 - v41;
          uint64_t v42 = (uint64_t *)(v33 - 8);
          do
          {
            uint64_t v43 = *v42--;
            v6->i64[0] = v43;
            unint64_t v6 = (int8x16_t *)((char *)v6 + 8);
            double result = (int8x16_t *)(result - 1);
          }
          while (result);
          ++v29;
          v28 += v3;
        }
        while (v29 != v4);
      }
    }
    else
    {
      unsigned int v7 = 0;
      do
      {
        uint64_t v8 = result->i64[1] + 8 * v7 + 8 * v3;
        v6->i64[0] = *(void *)(v8 - 8);
        if (v3 == 1)
        {
          unint64_t v6 = (int8x16_t *)((char *)v6 + 8);
        }
        else
        {
          v6->i64[1] = *(void *)(v8 - 16);
          if (v3 == 2)
          {
            ++v6;
          }
          else
          {
            v6[1].i64[0] = *(void *)(v8 - 24);
            if (v3 == 3)
            {
              unint64_t v6 = (int8x16_t *)((char *)v6 + 24);
            }
            else
            {
              v6[1].i64[1] = *(void *)(v8 - 32);
              if (v3 == 4)
              {
                v6 += 2;
              }
              else
              {
                v6[2].i64[0] = *(void *)(v8 - 40);
                unint64_t v6 = (int8x16_t *)((char *)v6 + 40);
              }
            }
          }
        }
        v7 += v3;
        --v4;
      }
      while (v4);
    }
  }
  return result;
}

uint64_t ImageUtils::Flipud<double>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(result + 16);
  uint64_t v2 = *(unsigned int *)(result + 20);
  if (*(void *)(a2 + 32) < 8 * v3 * (unint64_t)v2)
  {
    if (*(void *)(a2 + 8))
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v2;
  if (v3) {
    BOOL v4 = v2 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    BOOL v5 = *(void **)(a2 + 8);
    if (v2 > 5)
    {
      uint64_t v8 = 8 * (v2 & 0xFFFFFFFC);
      if ((v2 & 0xFFFFFFFC) == v2)
      {
        uint64_t v9 = 0;
        unsigned int v10 = v2 * (v3 - 1);
        do
        {
          uint64_t v11 = *(void *)(result + 8);
          uint64_t v12 = (char *)(v11 + 8 * ((v3 + ~v9) * v2));
          if ((unint64_t)((char *)v5 - v12) >= 0x20)
          {
            unsigned int v15 = (long long *)(v11 + 8 * v10 + 16);
            uint64_t v16 = v5 + 2;
            uint64_t v17 = v2 & 0xFFFFFFFC;
            do
            {
              long long v18 = *v15;
              *(v16 - 1) = *(v15 - 1);
              *uint64_t v16 = v18;
              v15 += 2;
              v16 += 2;
              v17 -= 4;
            }
            while (v17);
            BOOL v5 = (void *)((char *)v5 + v8);
          }
          else
          {
            int v13 = v2;
            do
            {
              uint64_t v14 = *(void *)v12;
              v12 += 8;
              *v5++ = v14;
              --v13;
            }
            while (v13);
          }
          ++v9;
          v10 -= v2;
        }
        while (v9 != v3);
      }
      else
      {
        uint64_t v19 = 0;
        unsigned int v20 = v2 * (v3 - 1);
        do
        {
          uint64_t v21 = *(void *)(result + 8);
          unint64_t v22 = (char *)(v21 + 8 * ((v3 + ~v19) * v2));
          if ((unint64_t)((char *)v5 - v22) >= 0x20)
          {
            uint64_t v24 = &v5[(unint64_t)v8 / 8];
            int8x16_t v25 = (long long *)(v21 + 8 * v20 + 16);
            double v26 = v5 + 2;
            uint64_t v27 = v2 & 0xFFFFFFFC;
            do
            {
              long long v28 = *v25;
              *(v26 - 1) = *(v25 - 1);
              _OWORD *v26 = v28;
              v25 += 2;
              v26 += 2;
              v27 -= 4;
            }
            while (v27);
            v22 += v8;
            int v23 = v2 & 0xFFFFFFFC;
            BOOL v5 = v24;
          }
          else
          {
            int v23 = 0;
          }
          int v29 = v2 - v23;
          do
          {
            uint64_t v30 = *(void *)v22;
            v22 += 8;
            *v5++ = v30;
            --v29;
          }
          while (v29);
          ++v19;
          v20 -= v2;
        }
        while (v19 != v3);
      }
    }
    else
    {
      unsigned int v6 = v2 * (v3 - 1);
      do
      {
        unsigned int v7 = (void *)(*(void *)(result + 8) + 8 * v6);
        *BOOL v5 = *v7;
        if (v2 == 1)
        {
          ++v5;
        }
        else
        {
          v5[1] = v7[1];
          if (v2 == 2)
          {
            v5 += 2;
          }
          else
          {
            v5[2] = v7[2];
            if (v2 == 3)
            {
              v5 += 3;
            }
            else
            {
              v5[3] = v7[3];
              if (v2 == 4)
              {
                v5 += 4;
              }
              else
              {
                v5[4] = v7[4];
                v5 += 5;
              }
            }
          }
        }
        v6 -= v2;
        --v3;
      }
      while (v3);
    }
  }
  return result;
}

int8x16_t *ImageUtils::Rot90<double>(int8x16_t *result, int a2, uint64_t a3)
{
  uint64_t v3 = result;
  unsigned int v5 = result[1].u32[0];
  uint64_t v4 = result[1].u32[1];
  switch(a2)
  {
    case 0:
      unsigned int v6 = (const void *)result->i64[1];
      unsigned int v7 = *(void **)(a3 + 8);
      if (*(void *)(a3 + 32) < 8 * v5 * (unint64_t)v4)
      {
        if (v7)
        {
          if (*(unsigned char *)(a3 + 24)) {
            MEMORY[0x2166C5D70]();
          }
        }
        operator new[]();
      }
      *(_DWORD *)(a3 + 16) = v5;
      *(_DWORD *)(a3 + 20) = v4;
      return (int8x16_t *)memcpy(v7, v6, 8 * v5 * v4);
    case 1:
      if (*(void *)(a3 + 32) < 8 * v4 * (unint64_t)v5)
      {
        if (*(void *)(a3 + 8) && *(unsigned char *)(a3 + 24)) {
          MEMORY[0x2166C5D70]();
        }
        operator new[]();
      }
      *(_DWORD *)(a3 + 16) = v4;
      *(_DWORD *)(a3 + 20) = v5;
      if (v4 && v5)
      {
        uint64_t v8 = 0;
        uint64_t v9 = *(void **)(a3 + 8);
        uint64_t v10 = 8 * (v4 - 1);
        do
        {
          uint64_t v11 = (void *)(result->i64[1] + v10);
          unsigned int v12 = v5;
          do
          {
            *v9++ = *v11;
            v11 += v4;
            --v12;
          }
          while (v12);
          ++v8;
          v10 -= 8;
        }
        while (v8 != v4);
      }
      return result;
    case 2:
      double result = *(int8x16_t **)(a3 + 8);
      if (*(void *)(a3 + 32) < 8 * v5 * (unint64_t)v4)
      {
        if (result && *(unsigned char *)(a3 + 24)) {
          MEMORY[0x2166C5D70]();
        }
        operator new[]();
      }
      unsigned int v18 = v5 * v4;
      *(_DWORD *)(a3 + 16) = v5;
      *(_DWORD *)(a3 + 20) = v4;
      if (!(v5 * v4)) {
        return result;
      }
      unint64_t v19 = v3->u64[1];
      uint64_t v20 = v18 - 1;
      uint64_t v21 = (uint64_t *)(v19 + 8 * v20);
      if (v18 < 0xA
        || ((uint64_t v22 = 8 * v20 + 8, (unint64_t)result < v19 + v22)
          ? (BOOL v23 = v19 >= (unint64_t)result->u64 + v22)
          : (BOOL v23 = 1),
            !v23))
      {
        LODWORD(v24) = 0;
LABEL_51:
        int v29 = v18 - v24;
        do
        {
          uint64_t v30 = *v21--;
          result->i64[0] = v30;
          double result = (int8x16_t *)((char *)result + 8);
          --v29;
        }
        while (v29);
        return result;
      }
      uint64_t v24 = v18 & 0xFFFFFFFC;
      int8x16_t v25 = (int8x16_t *)(v19 + 8 * v20 - 8);
      double v26 = result + 1;
      uint64_t v27 = v24;
      do
      {
        int8x16_t v28 = vextq_s8(v25[-1], v25[-1], 8uLL);
        v26[-1] = vextq_s8(*v25, *v25, 8uLL);
        int8x16_t *v26 = v28;
        v25 -= 2;
        v26 += 2;
        v27 -= 4;
      }
      while (v27);
      if (v24 != v18)
      {
        double result = (int8x16_t *)((char *)result + 8 * v24);
        v21 -= v24;
        goto LABEL_51;
      }
      return result;
    case 3:
      if (*(void *)(a3 + 32) < 8 * v4 * (unint64_t)v5)
      {
        if (*(void *)(a3 + 8) && *(unsigned char *)(a3 + 24)) {
          MEMORY[0x2166C5D70]();
        }
        operator new[]();
      }
      *(_DWORD *)(a3 + 16) = v4;
      *(_DWORD *)(a3 + 20) = v5;
      if (v4 && v5)
      {
        uint64_t v13 = 0;
        uint64_t v14 = *(void **)(a3 + 8);
        uint64_t v15 = 8 * (v5 - 1) * v4;
        do
        {
          uint64_t v16 = (void *)(result->i64[1] + v15);
          unsigned int v17 = v5;
          do
          {
            *v14++ = *v16;
            v16 -= v4;
            --v17;
          }
          while (v17);
          ++v13;
          v15 += 8;
        }
        while (v13 != v4);
      }
      return result;
    default:
      return result;
  }
}

double ImageUtils::Rot90<BOOL>(uint64_t a1, int a2, uint64_t a3)
{
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(unsigned int *)(a1 + 20);
  switch(a2)
  {
    case 0:
      unsigned int v6 = *(const void **)(a1 + 8);
      unsigned int v7 = *(void **)(a3 + 8);
      if (*(void *)(a3 + 32) < v5 * (unint64_t)v4)
      {
        if (v7)
        {
          if (*(unsigned char *)(a3 + 24)) {
            MEMORY[0x2166C5D70]();
          }
        }
        operator new[]();
      }
      *(_DWORD *)(a3 + 16) = v5;
      *(_DWORD *)(a3 + 20) = v4;
      memcpy(v7, v6, v5 * v4);
      return *(double *)v17.i64;
    case 1:
      if (*(void *)(a3 + 32) < v5 * (unint64_t)v4)
      {
        if (*(void *)(a3 + 8) && *(unsigned char *)(a3 + 24)) {
          MEMORY[0x2166C5D70]();
        }
        operator new[]();
      }
      *(_DWORD *)(a3 + 16) = v4;
      *(_DWORD *)(a3 + 20) = v5;
      if (v4 && v5)
      {
        uint64_t v8 = 0;
        uint64_t v9 = *(unsigned char **)(a3 + 8);
        do
        {
          uint64_t v10 = (unsigned char *)(*(void *)(a1 + 8) + (v4 - 1) - v8);
          unsigned int v11 = v5;
          do
          {
            *v9++ = *v10;
            v10 += v4;
            --v11;
          }
          while (v11);
          ++v8;
        }
        while (v8 != v4);
      }
      return *(double *)v17.i64;
    case 2:
      unsigned int v12 = *(int8x16_t **)(a3 + 8);
      if (*(void *)(a3 + 32) < v5 * (unint64_t)v4)
      {
        if (v12 && *(unsigned char *)(a3 + 24)) {
          MEMORY[0x2166C5D70]();
        }
        operator new[]();
      }
      unsigned int v18 = v5 * v4;
      *(_DWORD *)(a3 + 16) = v5;
      *(_DWORD *)(a3 + 20) = v4;
      if (!(v5 * v4)) {
        return *(double *)v17.i64;
      }
      unint64_t v19 = *(void *)(a1 + 8);
      uint64_t v20 = v18 - 1;
      uint64_t v21 = (__int8 *)(v19 + v20);
      if (v18 < 8
        || ((unint64_t)v12 < v19 + v18 ? (BOOL v22 = v19 >= (unint64_t)v12->u64 + v18) : (BOOL v22 = 1), !v22))
      {
        LODWORD(v24) = 0;
        goto LABEL_49;
      }
      if (v18 >= 0x20)
      {
        uint64_t v23 = v18 & 0xFFFFFFE0;
        uint64_t v27 = (int8x16_t *)(v20 + v19 - 15);
        int8x16_t v28 = v12 + 1;
        uint64_t v29 = v23;
        do
        {
          int8x16_t v30 = vrev64q_s8(*v27);
          int8x16_t v17 = vextq_s8(v30, v30, 8uLL);
          int8x16_t v31 = vrev64q_s8(v27[-1]);
          v28[-1] = v17;
          *int8x16_t v28 = vextq_s8(v31, v31, 8uLL);
          v27 -= 2;
          v28 += 2;
          v29 -= 32;
        }
        while (v29);
        if (v23 == v18) {
          return *(double *)v17.i64;
        }
        if ((v18 & 0x18) == 0)
        {
          v21 -= v23;
          unsigned int v12 = (int8x16_t *)((char *)v12 + v23);
          LODWORD(v24) = v18 & 0xFFFFFFE0;
LABEL_49:
          int v25 = v18 - v24;
          do
          {
            __int8 v26 = *v21--;
            v12->i8[0] = v26;
            unsigned int v12 = (int8x16_t *)((char *)v12 + 1);
            --v25;
          }
          while (v25);
          return *(double *)v17.i64;
        }
      }
      else
      {
        uint64_t v23 = 0;
      }
      uint64_t v24 = v18 & 0xFFFFFFF8;
      uint64_t v32 = v23 - v24;
      unint64_t v33 = (int8x8_t *)(v20 - v23 + v19 - 7);
      unint64_t v34 = (uint64_t *)((char *)v12->i64 + v23);
      do
      {
        int8x8_t v35 = *v33--;
        *(int8x8_t *)v17.i8 = vrev64_s8(v35);
        *v34++ = v17.i64[0];
        v32 += 8;
      }
      while (v32);
      if (v24 != v18)
      {
        unsigned int v12 = (int8x16_t *)((char *)v12 + v24);
        v21 -= v18 & 0xFFFFFFF8;
        goto LABEL_49;
      }
      return *(double *)v17.i64;
    case 3:
      if (*(void *)(a3 + 32) < v5 * (unint64_t)v4)
      {
        if (*(void *)(a3 + 8) && *(unsigned char *)(a3 + 24)) {
          MEMORY[0x2166C5D70]();
        }
        operator new[]();
      }
      *(_DWORD *)(a3 + 16) = v4;
      *(_DWORD *)(a3 + 20) = v5;
      if (v4 && v5)
      {
        uint64_t v13 = 0;
        uint64_t v14 = *(unsigned char **)(a3 + 8);
        do
        {
          uint64_t v15 = (unsigned char *)(*(void *)(a1 + 8) + (v5 - 1) * v4 + v13);
          unsigned int v16 = v5;
          do
          {
            *v14++ = *v15;
            v15 -= v4;
            --v16;
          }
          while (v16);
          ++v13;
        }
        while (v13 != v4);
      }
      return *(double *)v17.i64;
    default:
      return *(double *)v17.i64;
  }
}

void ImageUtils::OtsuThreshold(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  unsigned int v3 = *(_DWORD *)(a1 + 20);
  uint64_t v4 = *(double **)(a1 + 8);
  double v5 = *v4;
  int v6 = v3 * v2;
  if (v3 * v2 >= 2)
  {
    unsigned int v7 = v4 + 1;
    int v8 = v6 - 1;
    double v9 = v5;
    while (1)
    {
      double v10 = *v7;
      if (*v7 < v9)
      {
        double v9 = *v7;
      }
      else if (v10 > v5)
      {
        goto LABEL_5;
      }
      double v10 = v5;
LABEL_5:
      ++v7;
      double v5 = v10;
      if (!--v8) {
        goto LABEL_10;
      }
    }
  }
  double v9 = *v4;
  double v10 = *v4;
LABEL_10:
  if (v9 != v10)
  {
    unsigned int v11 = (double *)malloc_type_calloc(0x100uLL, 8uLL, 0x100004000313F17uLL);
    unsigned int v12 = v11;
    if (v6)
    {
      uint64_t v13 = *(double **)(a1 + 8);
      do
      {
        double v14 = *v13++;
        uint64_t v15 = vcvtad_u64_f64((v14 - v9) / (v10 - v9) * 255.0);
        v11[v15] = 1.0 / ((double)v2 * (double)v3) + v11[v15];
        --v6;
      }
      while (v6);
    }
    unsigned int v16 = (double *)malloc_type_malloc(0x800uLL, 0x100004000313F17uLL);
    int8x16_t v17 = malloc_type_malloc(0x800uLL, 0x100004000313F17uLL);
    unsigned int v18 = v17;
    *unsigned int v16 = *v12;
    double v19 = *v12;
    void *v17 = *(void *)v12;
    if (v16 >= (double *)v17 + 256 || v17 >= (void *)v16 + 256)
    {
      uint64_t v20 = 0;
      double v22 = *v16;
      unsigned int v23 = 2;
      do
      {
        double v22 = v22 + v12[v20 + 1];
        v16[v20 + 1] = v22;
        double v19 = v19 + v12[v20 + 1] * (double)v23;
        *(double *)&v17[++v20] = v19;
        ++v23;
      }
      while ((v20 * 8) != 2040);
    }
    else
    {
      uint64_t v20 = 0;
      unsigned int v21 = 2;
      do
      {
        v16[v20 + 1] = v16[v20] + v12[v20 + 1];
        double v19 = *(double *)&v17[v20] + v12[v20 + 1] * (double)v21;
        *(double *)&v17[++v20] = v19;
        ++v21;
      }
      while ((v20 * 8) != 2040);
    }
    uint64_t v24 = (uint64_t)&v17[v20 - 1];
    uint64_t v25 = (uint64_t)&v16[v20 - 1];
    uint64_t v26 = (uint64_t)&v12[v20 - 1];
    int v27 = 0;
    double v28 = *(double *)(v25 - 2032);
    double v29 = -(*(double *)(v24 - 2032) - v19 * v28);
    double v30 = v29 * v29 / (v28 * (1.0 - v28));
    int v31 = 1;
    uint64_t v32 = -253;
    int v33 = 1;
    do
    {
      double v34 = *(double *)(v25 + 8 * v32);
      double v35 = -(*(double *)(v24 + 8 * v32) - v19 * v34);
      double v36 = v35 * v35 / (v34 * (1.0 - v34));
      if (v36 > v30)
      {
        int v27 = v32 + 254;
        int v33 = 1;
      }
      else
      {
        if (v36 == v30)
        {
          v27 += v31;
          ++v33;
        }
        double v36 = v30;
      }
      ++v31;
      ++v32;
      double v30 = v36;
    }
    while (v32 != 1);
    int v37 = (void *)(v26 - 2032);
    free(v16);
    free(v18);
    free(v37);
  }
}

uint64_t ImageUtils::ExtractPatch<double>(uint64_t result, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, uint64_t a6)
{
  unsigned int v6 = a2;
  uint64_t v7 = *(unsigned int *)(result + 20);
  uint64_t v8 = *(void *)(result + 8);
  unsigned int v9 = a3 - a2 + 1;
  unsigned int v10 = a5 - a4 + 1;
  if (*(void *)(a6 + 32) < 8 * v9 * (unint64_t)v10)
  {
    if (*(void *)(a6 + 8))
    {
      if (*(unsigned char *)(a6 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a6 + 16) = v9;
  *(_DWORD *)(a6 + 20) = v10;
  if (a3 >= a2 && a5 >= a4)
  {
    unsigned int v11 = *(void **)(a6 + 8);
    uint64_t v12 = v7 * a2;
    uint64_t v13 = v8 + 8 * v12;
    if (a5 + 1 <= a4 + 1) {
      unsigned int v14 = a4 + 1;
    }
    else {
      unsigned int v14 = a5 + 1;
    }
    uint64_t v15 = v14 + ~a4;
    if (v15 > 4)
    {
      if (v14 - 1 >= a4)
      {
        uint64_t v18 = v8 + 8 * (v12 + a4);
        uint64_t v19 = 8 * v7;
        uint64_t v20 = v15 + 1;
        uint64_t v21 = (v15 + 1) & 0x1FFFFFFFCLL;
        uint64_t v22 = 8 * v21;
        if (v20 == v21)
        {
          uint64_t v23 = 0;
          do
          {
            if ((unint64_t)v11 - v18 - v19 * v23 >= 0x20)
            {
              uint64_t v25 = v11 + 2;
              unsigned int v26 = a4;
              double result = v21;
              do
              {
                int v27 = (_OWORD *)(v13 + 8 * v26);
                long long v28 = v27[1];
                *(v25 - 1) = *v27;
                _OWORD *v25 = v28;
                v26 += 4;
                v25 += 2;
                result -= 4;
              }
              while (result);
              unsigned int v11 = (void *)((char *)v11 + v22);
            }
            else
            {
              unsigned int v24 = a4;
              do
                *v11++ = *(void *)(v13 + 8 * v24++);
              while (v14 != v24);
            }
            ++v6;
            v13 += 8 * v7;
            ++v23;
          }
          while (v6 <= a3);
        }
        else
        {
          uint64_t v29 = 0;
          do
          {
            if ((unint64_t)v11 - v18 - v19 * v29 >= 0x20)
            {
              int v31 = v11 + 2;
              unsigned int v32 = a4;
              double result = v21;
              do
              {
                int v33 = (_OWORD *)(v13 + 8 * v32);
                long long v34 = v33[1];
                *(v31 - 1) = *v33;
                _OWORD *v31 = v34;
                v32 += 4;
                v31 += 2;
                result -= 4;
              }
              while (result);
              unsigned int v11 = (void *)((char *)v11 + v22);
              unsigned int v30 = v21 + a4;
            }
            else
            {
              unsigned int v30 = a4;
            }
            do
              *v11++ = *(void *)(v13 + 8 * v30++);
            while (v30 <= a5);
            ++v6;
            v13 += 8 * v7;
            ++v29;
          }
          while (v6 <= a3);
        }
      }
      else
      {
        do
        {
          unsigned int v17 = a4;
          do
            *v11++ = *(void *)(v13 + 8 * v17++);
          while (v14 != v17);
          ++v6;
          v13 += 8 * v7;
        }
        while (v6 <= a3);
      }
    }
    else
    {
      do
      {
        unsigned int v16 = a4;
        do
          *v11++ = *(void *)(v13 + 8 * v16++);
        while (v14 != v16);
        ++v6;
        v13 += 8 * v7;
      }
      while (v6 <= a3);
    }
  }
  return result;
}

uint64_t ImageUtils::Conv2<double>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = *(_DWORD *)(a2 + 16);
  unsigned int v4 = *(_DWORD *)(a2 + 20);
  uint64_t v6 = v5 * v4;
  if (8 * v5 * (unint64_t)v4) {
    operator new[]();
  }
  uint64_t v7 = 0;
  if (v6)
  {
    unint64_t v8 = *(void *)(a2 + 8);
    uint64_t v9 = (v6 - 1);
    unsigned int v10 = (uint64_t *)(v8 + 8 * v9);
    if (v6 < 0xA || ((unint64_t v11 = 8 * v9 + 8, v8 + v11) ? (v12 = v8 >= v11) : (v12 = 1), !v12))
    {
      LODWORD(v13) = 0;
LABEL_15:
      int v18 = v6 - v13;
      do
      {
        uint64_t v19 = *v10--;
        *(void *)uint64_t v7 = v19;
        v7 += 8;
        --v18;
      }
      while (v18);
      goto LABEL_17;
    }
    uint64_t v13 = v6 & 0xFFFFFFFC;
    unsigned int v14 = (int8x16_t *)(v8 + 8 * v9 - 8);
    uint64_t v15 = 16;
    uint64_t v16 = v13;
    do
    {
      int8x16_t v17 = vextq_s8(v14[-1], v14[-1], 8uLL);
      *(int8x16_t *)(v15 - 16) = vextq_s8(*v14, *v14, 8uLL);
      *(int8x16_t *)uint64_t v15 = v17;
      v14 -= 2;
      v15 += 32;
      v16 -= 4;
    }
    while (v16);
    if (v13 != v6)
    {
      uint64_t v7 = 8 * (v6 & 0xFFFFFFFC);
      unsigned int v10 = (uint64_t *)((char *)v10 - v7);
      goto LABEL_15;
    }
  }
LABEL_17:
  if (a1 == a3)
  {
    float64x2_t v142 = "&im1 != res";
    int v143 = 196;
    float64x2_t v144 = "ImageUtils.hpp";
    uint64_t v145 = "Filter2";
    goto LABEL_167;
  }
  unsigned int v20 = *(_DWORD *)(a1 + 16);
  unsigned int v21 = *(_DWORD *)(a1 + 20);
  uint64_t v22 = *(double **)(a3 + 8);
  if (*(void *)(a3 + 32) < 8 * v20 * (unint64_t)v21)
  {
    if (v22)
    {
      if (*(unsigned char *)(a3 + 24)) {
        MEMORY[0x2166C5D70](*(void *)(a3 + 8), 0x1000C8000313F17);
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a3 + 16) = v20;
  *(_DWORD *)(a3 + 20) = v21;
  if ((v4 & 1) == 0)
  {
    float64x2_t v142 = "nCols2%2 == 1";
    int v143 = 541;
LABEL_166:
    float64x2_t v144 = "VdspSpecialization.hpp";
    uint64_t v145 = "vDSPImgfir";
LABEL_167:
    __assert_rtn(v145, v144, v143, v142);
  }
  if ((v5 & 1) == 0)
  {
    float64x2_t v142 = "nRows2%2 == 1";
    int v143 = 542;
    goto LABEL_166;
  }
  uint64_t v23 = *(void *)(a1 + 8);
  uint64_t v24 = *(unsigned int *)(a1 + 20);
  unsigned int v170 = *(_DWORD *)(a1 + 16);
  unsigned int v25 = v4 - 1;
  unsigned int v26 = (v4 - 1) >> 1;
  unsigned int v27 = (v5 - 1) >> 1;
  unsigned int v181 = v27;
  if (v5 - 1 >= 2)
  {
    int v104 = 0;
    size_t v105 = v24 - v26;
    uint64_t v106 = v26 + v24;
    if (v26 <= 1) {
      unsigned int v107 = 1;
    }
    else {
      unsigned int v107 = (v4 - 1) >> 1;
    }
    size_t v158 = 8 * (v107 - 1) + 8;
    uint64_t v161 = 8 * v107;
    size_t v153 = v24 - v26;
    uint64_t v155 = 8 * (v24 - (v25 | 1)) + 8;
    uint64_t v150 = 8 * (v26 - 1) + 8;
    if (v27 <= 1) {
      unsigned int v108 = 1;
    }
    else {
      unsigned int v108 = (v5 - 1) >> 1;
    }
    unsigned int v169 = v108;
    int v109 = v4 * v27;
    unsigned int v110 = v26 + v4 * v27;
    unsigned int v147 = v25 & 0xFFFFFFFE;
    unsigned int v146 = v24 - (v25 & 0xFFFFFFFE);
    unsigned int v164 = v107;
    uint64_t v166 = v26 + v24;
    while (1)
    {
      if (v25 >= 2)
      {
        if (v27 - v104 >= v5)
        {
          int v190 = v104;
          unsigned int v179 = v110;
          bzero(v22, v161);
          unsigned int v110 = v179;
          unsigned int v27 = (v5 - 1) >> 1;
          unsigned int v107 = v164;
          uint64_t v106 = v166;
          int v104 = v190;
          unsigned int v25 = v4 - 1;
          uint64_t v22 = (double *)((char *)v22 + v158);
        }
        else
        {
          int v111 = 0;
          unsigned int v112 = v110;
          unsigned int v113 = v26;
          do
          {
            double *v22 = 0.0;
            if (v26 - v111 < v4)
            {
              unsigned int v114 = 0;
              double v115 = 0.0;
              unsigned int v116 = v112;
              unsigned int v117 = v27 - v104;
              do
              {
                unsigned int v118 = v116;
                unsigned int v119 = v114;
                unint64_t v120 = v113;
                do
                {
                  double v115 = v115 + *(double *)(8 * v118) * *(double *)(v23 + 8 * v119);
                  double *v22 = v115;
                  ++v120;
                  ++v119;
                  ++v118;
                }
                while (v120 < v4);
                ++v117;
                v114 += v24;
                v116 += v4;
              }
              while (v117 < v5);
            }
            ++v111;
            ++v22;
            --v113;
            --v112;
          }
          while (v111 != v107);
        }
      }
      if (v26 >= v105) {
        goto LABEL_148;
      }
      if (v27 - v104 < v5) {
        break;
      }
      int v191 = v104;
      unsigned int v180 = v110;
      bzero(v22, v155);
      unsigned int v110 = v180;
      unsigned int v27 = (v5 - 1) >> 1;
      unsigned int v107 = v164;
      uint64_t v106 = v166;
      int v104 = v191;
      unsigned int v25 = v4 - 1;
      uint64_t v22 = (double *)((char *)v22 + v155);
      size_t v105 = v153;
      if (v153 < v24)
      {
LABEL_149:
        if (v27 - v104 >= v5)
        {
          int v189 = v104;
          unsigned int v178 = v110;
          bzero(v22, v150);
          unsigned int v110 = v178;
          unsigned int v27 = (v5 - 1) >> 1;
          unsigned int v107 = v164;
          uint64_t v106 = v166;
          int v104 = v189;
          unsigned int v25 = v4 - 1;
          uint64_t v22 = (double *)((char *)v22 + v150);
          unsigned int v26 = (v4 - 1) >> 1;
        }
        else
        {
          unsigned int v130 = v146;
          unsigned int v131 = v147;
          size_t v132 = v105;
          do
          {
            uint64_t v133 = v131;
            if (v131 <= 1uLL) {
              uint64_t v133 = 1;
            }
            double *v22 = 0.0;
            if (v132 != v106)
            {
              uint64_t v134 = -v133;
              double v135 = 0.0;
              int v136 = v109;
              unsigned int v137 = v130;
              unsigned int v138 = v27 - v104;
              do
              {
                unsigned int v139 = v136;
                unsigned int v140 = v137;
                uint64_t v141 = v134;
                do
                {
                  double v135 = v135 + *(double *)(8 * v139) * *(double *)(v23 + 8 * v140);
                  double *v22 = v135;
                  ++v140;
                  ++v139;
                  BOOL v12 = __CFADD__(v141++, 1);
                }
                while (!v12);
                ++v138;
                v137 += v24;
                v136 += v4;
              }
              while (v138 < v5);
            }
            ++v132;
            ++v22;
            --v131;
            ++v130;
          }
          while (v132 != v24);
        }
      }
LABEL_128:
      ++v104;
      v110 -= v4;
      v109 -= v4;
      if (v104 == v169) {
        goto LABEL_26;
      }
    }
    unsigned int v121 = 0;
    unsigned int v122 = v26;
    do
    {
      double *v22 = 0.0;
      double v123 = 0.0;
      int v124 = v109;
      unsigned int v125 = v121;
      unsigned int v126 = v27 - v104;
      do
      {
        unsigned int v127 = v124;
        unsigned int v128 = v125;
        uint64_t v129 = v4;
        do
        {
          double v123 = v123 + *(double *)(8 * v127) * *(double *)(v23 + 8 * v128);
          double *v22 = v123;
          ++v128;
          ++v127;
          --v129;
        }
        while (v129);
        ++v126;
        v125 += v24;
        v124 += v4;
      }
      while (v126 < v5);
      ++v122;
      ++v22;
      ++v121;
    }
    while (v122 != v105);
LABEL_148:
    if (v105 < v24) {
      goto LABEL_149;
    }
    goto LABEL_128;
  }
LABEL_26:
  unsigned int v28 = v170 - v27;
  if (v27 < v170 - v27)
  {
    unsigned int v29 = 0;
    uint64_t v30 = v24 - v26;
    if (v26 <= 1) {
      unsigned int v31 = 1;
    }
    else {
      unsigned int v31 = v26;
    }
    size_t v148 = 8 * (v31 - 1) + 8;
    uint64_t v151 = 8 * v31;
    uint64_t v159 = 8 * (v26 - 1) + 8;
    uint64_t v162 = 8 * (v24 - (v25 | 1)) + 8;
    unsigned int v156 = v25 & 0xFFFFFFFE;
    unsigned int v32 = v27;
    unsigned int v185 = v170 - v27;
    unsigned int v165 = v31;
    unsigned int v167 = v24 - v26;
    do
    {
      if (v25 >= 2)
      {
        if (!v5)
        {
          unsigned int v172 = v32;
          bzero(v22, v151);
          unsigned int v32 = v172;
          unsigned int v27 = v181;
          unsigned int v31 = v165;
          uint64_t v30 = v24 - v26;
          unsigned int v28 = v185;
          unsigned int v25 = v4 - 1;
          uint64_t v22 = (double *)((char *)v22 + v148);
          if (v26 < v167)
          {
LABEL_54:
            unsigned int v173 = v32;
            bzero(v22, v162);
            unsigned int v32 = v173;
            unsigned int v27 = (v5 - 1) >> 1;
            unsigned int v31 = v165;
            uint64_t v30 = v24 - v26;
            unsigned int v28 = v185;
            unsigned int v25 = v4 - 1;
            uint64_t v22 = (double *)((char *)v22 + v162);
          }
LABEL_55:
          if (v30 < v24)
          {
            if (v5)
            {
              unsigned int v51 = v32 - v27;
              goto LABEL_58;
            }
            unsigned int v171 = v32;
            bzero(v22, v159);
            unsigned int v32 = v171;
            unsigned int v27 = v181;
            unsigned int v31 = v165;
            uint64_t v30 = v24 - v26;
            unsigned int v28 = v185;
            unsigned int v25 = v4 - 1;
            uint64_t v22 = (double *)((char *)v22 + v159);
          }
          goto LABEL_32;
        }
        int v42 = 0;
        unsigned int v43 = v26;
        do
        {
          double *v22 = 0.0;
          if (v26 - v42 < v4)
          {
            int v44 = 0;
            double v45 = 0.0;
            unsigned int v46 = v43;
            unsigned int v47 = v29;
            do
            {
              unsigned int v48 = v46;
              unsigned int v49 = v47;
              unint64_t v50 = v43;
              do
              {
                double v45 = v45 + *(double *)(8 * v48) * *(double *)(v23 + 8 * v49);
                double *v22 = v45;
                ++v50;
                ++v49;
                ++v48;
              }
              while (v50 < v4);
              ++v44;
              v47 += v24;
              v46 += v4;
            }
            while (v44 != v5);
          }
          ++v42;
          ++v22;
          --v43;
        }
        while (v42 != v31);
      }
      if (v26 >= v30) {
        goto LABEL_55;
      }
      if (!v5) {
        goto LABEL_54;
      }
      if (v4)
      {
        unsigned int v33 = v29;
        unsigned int v34 = v26;
        do
        {
          unsigned int v35 = 0;
          int v36 = 0;
          double *v22 = 0.0;
          double v37 = 0.0;
          unsigned int v38 = v33;
          do
          {
            unsigned int v39 = v35;
            unsigned int v40 = v38;
            uint64_t v41 = v4;
            do
            {
              double v37 = v37 + *(double *)(8 * v39) * *(double *)(v23 + 8 * v40);
              double *v22 = v37;
              ++v40;
              ++v39;
              --v41;
            }
            while (v41);
            ++v36;
            v38 += v24;
            v35 += v4;
          }
          while (v36 != v5);
          ++v34;
          ++v22;
          ++v33;
        }
        while (v34 != v30);
        goto LABEL_55;
      }
      unsigned int v174 = v32;
      bzero(v22, v162);
      uint64_t v30 = v24 - v26;
      uint64_t v22 = (double *)((char *)v22 + v162);
      if (v167 < v24)
      {
        unsigned int v32 = v174;
        unsigned int v27 = (v5 - 1) >> 1;
        unsigned int v51 = v174 - v181;
        unsigned int v28 = v185;
        unsigned int v25 = v4 - 1;
        unsigned int v31 = v165;
LABEL_58:
        unsigned int v52 = -2 * v26 + v24 + v24 * v51;
        unsigned int v53 = v156;
        uint64_t v54 = v30;
        do
        {
          if (v53 <= 1uLL) {
            uint64_t v55 = 1;
          }
          else {
            uint64_t v55 = v53;
          }
          double *v22 = 0.0;
          if (v54 != v26 + v24)
          {
            unsigned int v56 = 0;
            int v57 = 0;
            uint64_t v58 = -v55;
            double v59 = 0.0;
            unsigned int v60 = v52;
            do
            {
              unsigned int v61 = v56;
              unsigned int v62 = v60;
              uint64_t v63 = v58;
              do
              {
                double v59 = v59 + *(double *)(8 * v61) * *(double *)(v23 + 8 * v62);
                double *v22 = v59;
                ++v62;
                ++v61;
                BOOL v12 = __CFADD__(v63++, 1);
              }
              while (!v12);
              ++v57;
              v60 += v24;
              v56 += v4;
            }
            while (v57 != v5);
          }
          ++v54;
          ++v22;
          --v53;
          ++v52;
        }
        while (v54 != v24);
        goto LABEL_32;
      }
      unsigned int v28 = v185;
      unsigned int v25 = v4 - 1;
      unsigned int v32 = v174;
      unsigned int v27 = (v5 - 1) >> 1;
      unsigned int v31 = v165;
LABEL_32:
      ++v32;
      v29 += v24;
    }
    while (v32 != v28);
  }
  if (v28 < v170)
  {
    unsigned int v64 = v27 + v170;
    unsigned int v65 = v24 - v26;
    uint64_t v66 = v26 + v24;
    unsigned int v67 = (v5 - 1) & 0xFFFFFFFE;
    if (v26 <= 1) {
      unsigned int v68 = 1;
    }
    else {
      unsigned int v68 = v26;
    }
    size_t v154 = 8 * (v68 - 1) + 8;
    uint64_t v157 = 8 * v68;
    uint64_t v160 = 8 * (v24 - (v25 | 1)) + 8;
    unsigned int v163 = v68;
    uint64_t v152 = 8 * (v26 - 1) + 8;
    unsigned int v69 = v24 * (v170 - v67);
    unsigned int v149 = v25 & 0xFFFFFFFE;
    unsigned int v70 = v24 + v69 - (v25 & 0xFFFFFFFE);
    unsigned int v168 = v64;
    while (1)
    {
      unsigned int v71 = v67;
      BOOL v12 = v67-- != 0;
      if (v67 != 0 && v12) {
        int v72 = v71;
      }
      else {
        int v72 = 1;
      }
      if (v25 >= 2)
      {
        if (v64 == v28)
        {
          unsigned int v183 = v67;
          unsigned int v187 = v28;
          unsigned int v176 = v70;
          bzero(v22, v157);
          unsigned int v70 = v176;
          unsigned int v67 = v183;
          unsigned int v68 = v163;
          uint64_t v66 = v26 + v24;
          unsigned int v64 = v168;
          unsigned int v28 = v187;
          unsigned int v25 = v4 - 1;
          uint64_t v22 = (double *)((char *)v22 + v154);
        }
        else
        {
          int v94 = 0;
          unsigned int v95 = v26;
          do
          {
            double *v22 = 0.0;
            if (v26 - v94 < v4)
            {
              int v96 = 0;
              double v97 = 0.0;
              unsigned int v98 = v95;
              unsigned int v99 = v69;
              do
              {
                unsigned int v100 = v98;
                unsigned int v101 = v99;
                unint64_t v102 = v95;
                do
                {
                  double v97 = v97 + *(double *)(8 * v100) * *(double *)(v23 + 8 * v101);
                  double *v22 = v97;
                  ++v102;
                  ++v101;
                  ++v100;
                }
                while (v102 < v4);
                ++v96;
                v99 += v24;
                v98 += v4;
              }
              while (v96 != v72);
            }
            ++v94;
            ++v22;
            --v95;
          }
          while (v94 != v68);
        }
      }
      if (v26 >= v65) {
        goto LABEL_95;
      }
      if (v64 != v28 && v4) {
        break;
      }
      unsigned int v184 = v67;
      unsigned int v188 = v28;
      unsigned int v177 = v70;
      bzero(v22, v160);
      unsigned int v70 = v177;
      unsigned int v67 = v184;
      unsigned int v68 = v163;
      uint64_t v66 = v26 + v24;
      unsigned int v64 = v168;
      unsigned int v28 = v188;
      unsigned int v25 = v4 - 1;
      uint64_t v22 = (double *)((char *)v22 + v160);
      if (v65 < v24)
      {
LABEL_96:
        if (v64 == v28)
        {
          unsigned int v182 = v67;
          unsigned int v186 = v28;
          unsigned int v175 = v70;
          bzero(v22, v152);
          unsigned int v70 = v175;
          unsigned int v67 = v182;
          unsigned int v68 = v163;
          uint64_t v66 = v26 + v24;
          unsigned int v64 = v168;
          unsigned int v28 = v186;
          unsigned int v25 = v4 - 1;
          uint64_t v22 = (double *)((char *)v22 + v152);
        }
        else
        {
          unsigned int v82 = v70;
          unsigned int v83 = v149;
          uint64_t v84 = v24 - v26;
          do
          {
            if (v83 <= 1uLL) {
              uint64_t v85 = 1;
            }
            else {
              uint64_t v85 = v83;
            }
            double *v22 = 0.0;
            if (v84 != v66)
            {
              unsigned int v86 = 0;
              int v87 = 0;
              uint64_t v88 = -v85;
              double v89 = 0.0;
              unsigned int v90 = v82;
              do
              {
                unsigned int v91 = v86;
                unsigned int v92 = v90;
                uint64_t v93 = v88;
                do
                {
                  double v89 = v89 + *(double *)(8 * v91) * *(double *)(v23 + 8 * v92);
                  double *v22 = v89;
                  ++v92;
                  ++v91;
                  BOOL v12 = __CFADD__(v93++, 1);
                }
                while (!v12);
                ++v87;
                v90 += v24;
                v86 += v4;
              }
              while (v87 != v72);
            }
            ++v84;
            ++v22;
            --v83;
            ++v82;
          }
          while (v84 != v24);
        }
      }
LABEL_79:
      ++v28;
      v69 += v24;
      v70 += v24;
      if (v28 == v170) {
        return 0;
      }
    }
    unsigned int v73 = v69;
    unsigned int v74 = v26;
    do
    {
      unsigned int v75 = 0;
      int v76 = 0;
      double *v22 = 0.0;
      double v77 = 0.0;
      unsigned int v78 = v73;
      do
      {
        unsigned int v79 = v75;
        unsigned int v80 = v78;
        uint64_t v81 = v4;
        do
        {
          double v77 = v77 + *(double *)(8 * v79) * *(double *)(v23 + 8 * v80);
          double *v22 = v77;
          ++v80;
          ++v79;
          --v81;
        }
        while (v81);
        ++v76;
        v78 += v24;
        v75 += v4;
      }
      while (v76 != v72);
      ++v74;
      ++v22;
      ++v73;
    }
    while (v74 != v65);
LABEL_95:
    if (v65 < v24) {
      goto LABEL_96;
    }
    goto LABEL_79;
  }
  return 0;
}

void sub_215F2E494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  Matrix<double>::~Matrix((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ImageUtils::Conv2<float>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = *(_DWORD *)(a2 + 16);
  unsigned int v4 = *(_DWORD *)(a2 + 20);
  uint64_t v6 = v5 * v4;
  if (4 * v5 * (unint64_t)v4) {
    operator new[]();
  }
  uint64_t v7 = 0;
  if (v6)
  {
    unint64_t v8 = *(void *)(a2 + 8);
    uint64_t v9 = (v6 - 1);
    unsigned int v10 = (int *)(v8 + 4 * v9);
    if (v6 < 0xC || ((unint64_t v11 = 4 * v9 + 4, v8 + v11) ? (v12 = v8 >= v11) : (v12 = 1), !v12))
    {
      LODWORD(v13) = 0;
LABEL_15:
      int v19 = v6 - v13;
      do
      {
        int v20 = *v10--;
        *(_DWORD *)uint64_t v7 = v20;
        v7 += 4;
        --v19;
      }
      while (v19);
      goto LABEL_17;
    }
    uint64_t v13 = v6 & 0xFFFFFFF8;
    unsigned int v14 = (int32x4_t *)(v8 + 4 * v9 - 12);
    uint64_t v15 = 16;
    uint64_t v16 = v13;
    do
    {
      int8x16_t v17 = (int8x16_t)vrev64q_s32(*v14);
      int8x16_t v18 = (int8x16_t)vrev64q_s32(v14[-1]);
      *(int8x16_t *)(v15 - 16) = vextq_s8(v17, v17, 8uLL);
      *(int8x16_t *)uint64_t v15 = vextq_s8(v18, v18, 8uLL);
      v14 -= 2;
      v15 += 32;
      v16 -= 8;
    }
    while (v16);
    if (v13 != v6)
    {
      uint64_t v7 = 4 * (v6 & 0xFFFFFFF8);
      unsigned int v10 = (int *)((char *)v10 - v7);
      goto LABEL_15;
    }
  }
LABEL_17:
  if (a1 == a3)
  {
    int v143 = "&im1 != res";
    int v144 = 196;
    uint64_t v145 = "ImageUtils.hpp";
    unsigned int v146 = "Filter2";
    goto LABEL_167;
  }
  unsigned int v21 = *(_DWORD *)(a1 + 16);
  unsigned int v22 = *(_DWORD *)(a1 + 20);
  uint64_t v23 = *(float **)(a3 + 8);
  if (*(void *)(a3 + 32) < 4 * v21 * (unint64_t)v22)
  {
    if (v23)
    {
      if (*(unsigned char *)(a3 + 24)) {
        MEMORY[0x2166C5D70](*(void *)(a3 + 8), 0x1000C8052888210);
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a3 + 16) = v21;
  *(_DWORD *)(a3 + 20) = v22;
  if ((v4 & 1) == 0)
  {
    int v143 = "nCols2%2 == 1";
    int v144 = 541;
LABEL_166:
    uint64_t v145 = "VdspSpecialization.hpp";
    unsigned int v146 = "vDSPImgfir";
LABEL_167:
    __assert_rtn(v146, v145, v144, v143);
  }
  if ((v5 & 1) == 0)
  {
    int v143 = "nRows2%2 == 1";
    int v144 = 542;
    goto LABEL_166;
  }
  uint64_t v24 = *(void *)(a1 + 8);
  uint64_t v25 = *(unsigned int *)(a1 + 20);
  unsigned int v171 = *(_DWORD *)(a1 + 16);
  unsigned int v26 = v4 - 1;
  unsigned int v27 = (v4 - 1) >> 1;
  unsigned int v28 = (v5 - 1) >> 1;
  unsigned int v182 = v28;
  if (v5 - 1 >= 2)
  {
    int v105 = 0;
    size_t v106 = v25 - v27;
    uint64_t v107 = v27 + v25;
    if (v27 <= 1) {
      unsigned int v108 = 1;
    }
    else {
      unsigned int v108 = (v4 - 1) >> 1;
    }
    size_t v159 = 4 * (v108 - 1) + 4;
    uint64_t v162 = 4 * v108;
    size_t v154 = v25 - v27;
    uint64_t v156 = 4 * (v25 - (v26 | 1)) + 4;
    uint64_t v151 = 4 * (v27 - 1) + 4;
    if (v28 <= 1) {
      unsigned int v109 = 1;
    }
    else {
      unsigned int v109 = (v5 - 1) >> 1;
    }
    unsigned int v170 = v109;
    int v110 = v4 * v28;
    unsigned int v111 = v27 + v4 * v28;
    unsigned int v148 = v26 & 0xFFFFFFFE;
    unsigned int v147 = v25 - (v26 & 0xFFFFFFFE);
    unsigned int v165 = v108;
    uint64_t v167 = v27 + v25;
    while (1)
    {
      if (v26 >= 2)
      {
        if (v28 - v105 >= v5)
        {
          int v191 = v105;
          unsigned int v180 = v111;
          bzero(v23, v162);
          unsigned int v111 = v180;
          unsigned int v28 = (v5 - 1) >> 1;
          unsigned int v108 = v165;
          uint64_t v107 = v167;
          int v105 = v191;
          unsigned int v26 = v4 - 1;
          uint64_t v23 = (float *)((char *)v23 + v159);
        }
        else
        {
          int v112 = 0;
          unsigned int v113 = v111;
          unsigned int v114 = v27;
          do
          {
            float *v23 = 0.0;
            if (v27 - v112 < v4)
            {
              unsigned int v115 = 0;
              float v116 = 0.0;
              unsigned int v117 = v113;
              unsigned int v118 = v28 - v105;
              do
              {
                unsigned int v119 = v117;
                unsigned int v120 = v115;
                unint64_t v121 = v114;
                do
                {
                  float v116 = v116 + (float)(*(float *)(4 * v119) * *(float *)(v24 + 4 * v120));
                  float *v23 = v116;
                  ++v121;
                  ++v120;
                  ++v119;
                }
                while (v121 < v4);
                ++v118;
                v115 += v25;
                v117 += v4;
              }
              while (v118 < v5);
            }
            ++v112;
            ++v23;
            --v114;
            --v113;
          }
          while (v112 != v108);
        }
      }
      if (v27 >= v106) {
        goto LABEL_148;
      }
      if (v28 - v105 < v5) {
        break;
      }
      int v192 = v105;
      unsigned int v181 = v111;
      bzero(v23, v156);
      unsigned int v111 = v181;
      unsigned int v28 = (v5 - 1) >> 1;
      unsigned int v108 = v165;
      uint64_t v107 = v167;
      int v105 = v192;
      unsigned int v26 = v4 - 1;
      uint64_t v23 = (float *)((char *)v23 + v156);
      size_t v106 = v154;
      if (v154 < v25)
      {
LABEL_149:
        if (v28 - v105 >= v5)
        {
          int v190 = v105;
          unsigned int v179 = v111;
          bzero(v23, v151);
          unsigned int v111 = v179;
          unsigned int v28 = (v5 - 1) >> 1;
          unsigned int v108 = v165;
          uint64_t v107 = v167;
          int v105 = v190;
          unsigned int v26 = v4 - 1;
          uint64_t v23 = (float *)((char *)v23 + v151);
          unsigned int v27 = (v4 - 1) >> 1;
        }
        else
        {
          unsigned int v131 = v147;
          unsigned int v132 = v148;
          size_t v133 = v106;
          do
          {
            uint64_t v134 = v132;
            if (v132 <= 1uLL) {
              uint64_t v134 = 1;
            }
            float *v23 = 0.0;
            if (v133 != v107)
            {
              uint64_t v135 = -v134;
              float v136 = 0.0;
              int v137 = v110;
              unsigned int v138 = v131;
              unsigned int v139 = v28 - v105;
              do
              {
                unsigned int v140 = v137;
                unsigned int v141 = v138;
                uint64_t v142 = v135;
                do
                {
                  float v136 = v136 + (float)(*(float *)(4 * v140) * *(float *)(v24 + 4 * v141));
                  float *v23 = v136;
                  ++v141;
                  ++v140;
                  BOOL v12 = __CFADD__(v142++, 1);
                }
                while (!v12);
                ++v139;
                v138 += v25;
                v137 += v4;
              }
              while (v139 < v5);
            }
            ++v133;
            ++v23;
            --v132;
            ++v131;
          }
          while (v133 != v25);
        }
      }
LABEL_128:
      ++v105;
      v111 -= v4;
      v110 -= v4;
      if (v105 == v170) {
        goto LABEL_26;
      }
    }
    unsigned int v122 = 0;
    unsigned int v123 = v27;
    do
    {
      float *v23 = 0.0;
      float v124 = 0.0;
      int v125 = v110;
      unsigned int v126 = v122;
      unsigned int v127 = v28 - v105;
      do
      {
        unsigned int v128 = v125;
        unsigned int v129 = v126;
        uint64_t v130 = v4;
        do
        {
          float v124 = v124 + (float)(*(float *)(4 * v128) * *(float *)(v24 + 4 * v129));
          float *v23 = v124;
          ++v129;
          ++v128;
          --v130;
        }
        while (v130);
        ++v127;
        v126 += v25;
        v125 += v4;
      }
      while (v127 < v5);
      ++v123;
      ++v23;
      ++v122;
    }
    while (v123 != v106);
LABEL_148:
    if (v106 < v25) {
      goto LABEL_149;
    }
    goto LABEL_128;
  }
LABEL_26:
  unsigned int v29 = v171 - v28;
  if (v28 < v171 - v28)
  {
    unsigned int v30 = 0;
    uint64_t v31 = v25 - v27;
    if (v27 <= 1) {
      unsigned int v32 = 1;
    }
    else {
      unsigned int v32 = v27;
    }
    size_t v149 = 4 * (v32 - 1) + 4;
    uint64_t v152 = 4 * v32;
    uint64_t v160 = 4 * (v27 - 1) + 4;
    uint64_t v163 = 4 * (v25 - (v26 | 1)) + 4;
    unsigned int v157 = v26 & 0xFFFFFFFE;
    unsigned int v33 = v28;
    unsigned int v186 = v171 - v28;
    unsigned int v166 = v32;
    unsigned int v168 = v25 - v27;
    do
    {
      if (v26 >= 2)
      {
        if (!v5)
        {
          unsigned int v173 = v33;
          bzero(v23, v152);
          unsigned int v33 = v173;
          unsigned int v28 = v182;
          unsigned int v32 = v166;
          uint64_t v31 = v25 - v27;
          unsigned int v29 = v186;
          unsigned int v26 = v4 - 1;
          uint64_t v23 = (float *)((char *)v23 + v149);
          if (v27 < v168)
          {
LABEL_54:
            unsigned int v174 = v33;
            bzero(v23, v163);
            unsigned int v33 = v174;
            unsigned int v28 = (v5 - 1) >> 1;
            unsigned int v32 = v166;
            uint64_t v31 = v25 - v27;
            unsigned int v29 = v186;
            unsigned int v26 = v4 - 1;
            uint64_t v23 = (float *)((char *)v23 + v163);
          }
LABEL_55:
          if (v31 < v25)
          {
            if (v5)
            {
              unsigned int v52 = v33 - v28;
              goto LABEL_58;
            }
            unsigned int v172 = v33;
            bzero(v23, v160);
            unsigned int v33 = v172;
            unsigned int v28 = v182;
            unsigned int v32 = v166;
            uint64_t v31 = v25 - v27;
            unsigned int v29 = v186;
            unsigned int v26 = v4 - 1;
            uint64_t v23 = (float *)((char *)v23 + v160);
          }
          goto LABEL_32;
        }
        int v43 = 0;
        unsigned int v44 = v27;
        do
        {
          float *v23 = 0.0;
          if (v27 - v43 < v4)
          {
            int v45 = 0;
            float v46 = 0.0;
            unsigned int v47 = v44;
            unsigned int v48 = v30;
            do
            {
              unsigned int v49 = v47;
              unsigned int v50 = v48;
              unint64_t v51 = v44;
              do
              {
                float v46 = v46 + (float)(*(float *)(4 * v49) * *(float *)(v24 + 4 * v50));
                float *v23 = v46;
                ++v51;
                ++v50;
                ++v49;
              }
              while (v51 < v4);
              ++v45;
              v48 += v25;
              v47 += v4;
            }
            while (v45 != v5);
          }
          ++v43;
          ++v23;
          --v44;
        }
        while (v43 != v32);
      }
      if (v27 >= v31) {
        goto LABEL_55;
      }
      if (!v5) {
        goto LABEL_54;
      }
      if (v4)
      {
        unsigned int v34 = v30;
        unsigned int v35 = v27;
        do
        {
          unsigned int v36 = 0;
          int v37 = 0;
          float *v23 = 0.0;
          float v38 = 0.0;
          unsigned int v39 = v34;
          do
          {
            unsigned int v40 = v36;
            unsigned int v41 = v39;
            uint64_t v42 = v4;
            do
            {
              float v38 = v38 + (float)(*(float *)(4 * v40) * *(float *)(v24 + 4 * v41));
              float *v23 = v38;
              ++v41;
              ++v40;
              --v42;
            }
            while (v42);
            ++v37;
            v39 += v25;
            v36 += v4;
          }
          while (v37 != v5);
          ++v35;
          ++v23;
          ++v34;
        }
        while (v35 != v31);
        goto LABEL_55;
      }
      unsigned int v175 = v33;
      bzero(v23, v163);
      uint64_t v31 = v25 - v27;
      uint64_t v23 = (float *)((char *)v23 + v163);
      if (v168 < v25)
      {
        unsigned int v33 = v175;
        unsigned int v28 = (v5 - 1) >> 1;
        unsigned int v52 = v175 - v182;
        unsigned int v29 = v186;
        unsigned int v26 = v4 - 1;
        unsigned int v32 = v166;
LABEL_58:
        unsigned int v53 = -2 * v27 + v25 + v25 * v52;
        unsigned int v54 = v157;
        uint64_t v55 = v31;
        do
        {
          if (v54 <= 1uLL) {
            uint64_t v56 = 1;
          }
          else {
            uint64_t v56 = v54;
          }
          float *v23 = 0.0;
          if (v55 != v27 + v25)
          {
            unsigned int v57 = 0;
            int v58 = 0;
            uint64_t v59 = -v56;
            float v60 = 0.0;
            unsigned int v61 = v53;
            do
            {
              unsigned int v62 = v57;
              unsigned int v63 = v61;
              uint64_t v64 = v59;
              do
              {
                float v60 = v60 + (float)(*(float *)(4 * v62) * *(float *)(v24 + 4 * v63));
                float *v23 = v60;
                ++v63;
                ++v62;
                BOOL v12 = __CFADD__(v64++, 1);
              }
              while (!v12);
              ++v58;
              v61 += v25;
              v57 += v4;
            }
            while (v58 != v5);
          }
          ++v55;
          ++v23;
          --v54;
          ++v53;
        }
        while (v55 != v25);
        goto LABEL_32;
      }
      unsigned int v29 = v186;
      unsigned int v26 = v4 - 1;
      unsigned int v33 = v175;
      unsigned int v28 = (v5 - 1) >> 1;
      unsigned int v32 = v166;
LABEL_32:
      ++v33;
      v30 += v25;
    }
    while (v33 != v29);
  }
  if (v29 < v171)
  {
    unsigned int v65 = v28 + v171;
    unsigned int v66 = v25 - v27;
    uint64_t v67 = v27 + v25;
    unsigned int v68 = (v5 - 1) & 0xFFFFFFFE;
    if (v27 <= 1) {
      unsigned int v69 = 1;
    }
    else {
      unsigned int v69 = v27;
    }
    size_t v155 = 4 * (v69 - 1) + 4;
    uint64_t v158 = 4 * v69;
    uint64_t v161 = 4 * (v25 - (v26 | 1)) + 4;
    unsigned int v164 = v69;
    uint64_t v153 = 4 * (v27 - 1) + 4;
    unsigned int v70 = v25 * (v171 - v68);
    unsigned int v150 = v26 & 0xFFFFFFFE;
    unsigned int v71 = v25 + v70 - (v26 & 0xFFFFFFFE);
    unsigned int v169 = v65;
    while (1)
    {
      unsigned int v72 = v68;
      BOOL v12 = v68-- != 0;
      if (v68 != 0 && v12) {
        int v73 = v72;
      }
      else {
        int v73 = 1;
      }
      if (v26 >= 2)
      {
        if (v65 == v29)
        {
          unsigned int v184 = v68;
          unsigned int v188 = v29;
          unsigned int v177 = v71;
          bzero(v23, v158);
          unsigned int v71 = v177;
          unsigned int v68 = v184;
          unsigned int v69 = v164;
          uint64_t v67 = v27 + v25;
          unsigned int v65 = v169;
          unsigned int v29 = v188;
          unsigned int v26 = v4 - 1;
          uint64_t v23 = (float *)((char *)v23 + v155);
        }
        else
        {
          int v95 = 0;
          unsigned int v96 = v27;
          do
          {
            float *v23 = 0.0;
            if (v27 - v95 < v4)
            {
              int v97 = 0;
              float v98 = 0.0;
              unsigned int v99 = v96;
              unsigned int v100 = v70;
              do
              {
                unsigned int v101 = v99;
                unsigned int v102 = v100;
                unint64_t v103 = v96;
                do
                {
                  float v98 = v98 + (float)(*(float *)(4 * v101) * *(float *)(v24 + 4 * v102));
                  float *v23 = v98;
                  ++v103;
                  ++v102;
                  ++v101;
                }
                while (v103 < v4);
                ++v97;
                v100 += v25;
                v99 += v4;
              }
              while (v97 != v73);
            }
            ++v95;
            ++v23;
            --v96;
          }
          while (v95 != v69);
        }
      }
      if (v27 >= v66) {
        goto LABEL_95;
      }
      if (v65 != v29 && v4) {
        break;
      }
      unsigned int v185 = v68;
      unsigned int v189 = v29;
      unsigned int v178 = v71;
      bzero(v23, v161);
      unsigned int v71 = v178;
      unsigned int v68 = v185;
      unsigned int v69 = v164;
      uint64_t v67 = v27 + v25;
      unsigned int v65 = v169;
      unsigned int v29 = v189;
      unsigned int v26 = v4 - 1;
      uint64_t v23 = (float *)((char *)v23 + v161);
      if (v66 < v25)
      {
LABEL_96:
        if (v65 == v29)
        {
          unsigned int v183 = v68;
          unsigned int v187 = v29;
          unsigned int v176 = v71;
          bzero(v23, v153);
          unsigned int v71 = v176;
          unsigned int v68 = v183;
          unsigned int v69 = v164;
          uint64_t v67 = v27 + v25;
          unsigned int v65 = v169;
          unsigned int v29 = v187;
          unsigned int v26 = v4 - 1;
          uint64_t v23 = (float *)((char *)v23 + v153);
        }
        else
        {
          unsigned int v83 = v71;
          unsigned int v84 = v150;
          uint64_t v85 = v25 - v27;
          do
          {
            if (v84 <= 1uLL) {
              uint64_t v86 = 1;
            }
            else {
              uint64_t v86 = v84;
            }
            float *v23 = 0.0;
            if (v85 != v67)
            {
              unsigned int v87 = 0;
              int v88 = 0;
              uint64_t v89 = -v86;
              float v90 = 0.0;
              unsigned int v91 = v83;
              do
              {
                unsigned int v92 = v87;
                unsigned int v93 = v91;
                uint64_t v94 = v89;
                do
                {
                  float v90 = v90 + (float)(*(float *)(4 * v92) * *(float *)(v24 + 4 * v93));
                  float *v23 = v90;
                  ++v93;
                  ++v92;
                  BOOL v12 = __CFADD__(v94++, 1);
                }
                while (!v12);
                ++v88;
                v91 += v25;
                v87 += v4;
              }
              while (v88 != v73);
            }
            ++v85;
            ++v23;
            --v84;
            ++v83;
          }
          while (v85 != v25);
        }
      }
LABEL_79:
      ++v29;
      v70 += v25;
      v71 += v25;
      if (v29 == v171) {
        return 0;
      }
    }
    unsigned int v74 = v70;
    unsigned int v75 = v27;
    do
    {
      unsigned int v76 = 0;
      int v77 = 0;
      float *v23 = 0.0;
      float v78 = 0.0;
      unsigned int v79 = v74;
      do
      {
        unsigned int v80 = v76;
        unsigned int v81 = v79;
        uint64_t v82 = v4;
        do
        {
          float v78 = v78 + (float)(*(float *)(4 * v80) * *(float *)(v24 + 4 * v81));
          float *v23 = v78;
          ++v81;
          ++v80;
          --v82;
        }
        while (v82);
        ++v77;
        v79 += v25;
        v76 += v4;
      }
      while (v77 != v73);
      ++v75;
      ++v23;
      ++v74;
    }
    while (v75 != v66);
LABEL_95:
    if (v66 < v25) {
      goto LABEL_96;
    }
    goto LABEL_79;
  }
  return 0;
}

void sub_215F2F060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  Matrix<float>::~Matrix((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t Matrix<float>::~Matrix(uint64_t a1)
{
  *(void *)a1 = &unk_26C6875F0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

void Matrix<float>::~Matrix(uint64_t a1)
{
  *(void *)a1 = &unk_26C6875F0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  JUMPOUT(0x2166C5D90);
}

uint64_t svd_os(uint64_t a1, double *a2, double *a3, double *a4, double *a5, int8x16_t a6, int8x16_t a7, float64x2_t a8, float64x2_t a9, float64x2_t a10, float64x2_t a11, __n128 a12, float64x2_t a13)
{
  v175[53] = *(double *)MEMORY[0x263EF8340];
  if ((unint64_t)(a1 - 10) < 0xFFFFFFFFFFFFFFF7) {
    return 4294967197;
  }
  uint64_t v16 = a1 - 1;
  if (a1 == 1)
  {
    a6.i64[0] = *(uint64_t *)a2;
    a7.i64[0] = 1.0;
    v17.f64[0] = NAN;
    v17.f64[1] = NAN;
    *(void *)a3 = vbslq_s8((int8x16_t)vnegq_f64(v17), a7, a6).u64[0];
    *a4 = fabs(*a2);
    *a5 = 1.0;
    if ((*(void *)a2 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL) {
      return 0;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t result = 0;
  uint64_t v162 = a1 - 2;
  uint64_t v163 = v16;
  uint64_t v18 = 8 * a1;
  uint64_t v19 = 8 * a1 + 8;
  int v20 = a2 + 3;
  unsigned int v169 = &a2[a1 + 3];
  unsigned int v21 = a2 + 1;
  v22.f64[0] = NAN;
  v22.f64[1] = NAN;
  int8x16_t v23 = (int8x16_t)vnegq_f64(v22);
  uint64_t v160 = &a2[a1];
  unsigned int v166 = v160;
  uint64_t v24 = v16;
  uint64_t v25 = (unint64_t *)a2;
  uint64_t v26 = a1;
  uint64_t v151 = &v175[v16];
  while (1)
  {
    unint64_t v27 = v16 - result;
    uint64_t v28 = a1 - result;
    if (a1 - result < 2) {
      goto LABEL_13;
    }
    a8.f64[0] = 0.0;
    uint64_t v29 = 1;
    do
    {
      *(void *)&a9.f64[0] = v25[v29];
      a8.f64[0] = a8.f64[0] + a9.f64[0] * a9.f64[0];
      ++v29;
    }
    while (v26 != v29);
    if (a8.f64[0] == 0.0)
    {
LABEL_13:
      *(void *)&a8.f64[0] = *v25;
      unint64_t *v25 = 0;
      goto LABEL_14;
    }
    a8.f64[0] = sqrt(a8.f64[0] + *(double *)v25 * *(double *)v25);
    a10.f64[0] = -*(double *)v25;
    a8 = (float64x2_t)vbslq_s8(v23, (int8x16_t)a8, (int8x16_t)a10);
    a9.f64[0] = 1.0 / (*(double *)v25 - a8.f64[0]);
    *(double *)uint64_t v25 = (a8.f64[0] - *(double *)v25) / a8.f64[0];
    if (v27 < 4)
    {
      uint64_t v43 = 1;
      goto LABEL_60;
    }
    unint64_t v59 = v27 & 0xFFFFFFFFFFFFFFFCLL;
    float v60 = (float64x2_t *)v20;
    unint64_t v61 = v24 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      a10 = vmulq_n_f64(v60[-1], a9.f64[0]);
      a11 = vmulq_n_f64(*v60, a9.f64[0]);
      v60[-1] = a10;
      *float v60 = a11;
      v60 += 2;
      v61 -= 4;
    }
    while (v61);
    if (v27 != v59)
    {
      uint64_t v43 = v59 | 1;
      do
      {
LABEL_60:
        a10.f64[0] = a9.f64[0] * *(double *)&v25[v43];
        v25[v43++] = *(void *)&a10.f64[0];
      }
      while (v26 != v43);
    }
LABEL_14:
    a4[result] = a8.f64[0];
    if ((*(void *)&a8.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
      return -(int)result;
    }
    unsigned int v30 = v21;
    uint64_t v31 = v28 - 1;
    unsigned int v32 = &v25[a1];
    if (v28 >= 2)
    {
      *(void *)&a8.f64[0] = *v25;
      if (*(double *)v25 != 0.0)
      {
        uint64_t v44 = 0;
        unint64_t v45 = v27 & 0xFFFFFFFFFFFFFFFCLL;
        unsigned int v47 = v166;
        float v46 = v169;
        while (v27 >= 4)
        {
          uint64_t v50 = 0;
          unint64_t v51 = v24 & 0xFFFFFFFFFFFFFFFCLL;
          double v49 = *(double *)&v32[v44 * a1];
          do
          {
            a13 = *(float64x2_t *)&v46[v50];
            a10 = vmulq_f64(*(float64x2_t *)&v20[v50 - 2], *(float64x2_t *)&v46[v50 - 2]);
            a12.n128_u64[0] = *(void *)&a10.f64[1];
            float64x2_t v52 = vmulq_f64(*(float64x2_t *)&v20[v50], a13);
            a13.f64[0] = v52.f64[1];
            double v49 = v49 + a10.f64[0] + a10.f64[1] + v52.f64[0] + v52.f64[1];
            v50 += 4;
            v51 -= 4;
          }
          while (v51);
          unint64_t v48 = v27 & 0xFFFFFFFFFFFFFFFCLL | 1;
          if (v27 != v45) {
            goto LABEL_42;
          }
LABEL_43:
          a11.f64[0] = v49 * *(double *)v25;
          *(double *)&v32[v44 * a1] = *(double *)&v32[v44 * a1] - a11.f64[0];
          a8.f64[0] = -a11.f64[0];
          if (v27 > 3
            && ((char *)a2 + v19 + v19 * result + v18 * v44 >= (char *)v160 + v18 * result
             || (char *)a2 + v19 * result + 8 >= (char *)&a2[2 * a1] + v18 * result + v18 * v44))
          {
            uint64_t v54 = 0;
            a9 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a8.f64[0], 0);
            unint64_t v55 = v24 & 0xFFFFFFFFFFFFFFFCLL;
            do
            {
              a10 = *(float64x2_t *)&v20[v54 - 2];
              a11 = *(float64x2_t *)&v20[v54];
              uint64_t v56 = (__n128 *)&v46[v54];
              a12 = (__n128)vmlaq_f64(*(float64x2_t *)&v46[v54 - 2], a10, a9);
              a13 = vmlaq_f64(*(float64x2_t *)&v46[v54], a11, a9);
              v56[-1] = a12;
              __n128 *v56 = (__n128)a13;
              v54 += 4;
              v55 -= 4;
            }
            while (v55);
            unint64_t v53 = v27 & 0xFFFFFFFFFFFFFFFCLL | 1;
            if (v27 == v45) {
              goto LABEL_36;
            }
          }
          else
          {
            unint64_t v53 = 1;
          }
          do
          {
            a10.f64[0] = v47[v53];
            a9.f64[0] = a10.f64[0] + a8.f64[0] * *(double *)&v25[v53];
            v47[v53++] = a9.f64[0];
          }
          while (v26 != v53);
LABEL_36:
          ++v44;
          float v46 = (double *)((char *)v46 + v18);
          unsigned int v47 = (double *)((char *)v47 + v18);
          if (v44 == v31) {
            goto LABEL_17;
          }
        }
        unint64_t v48 = 1;
        double v49 = *(double *)&v32[v44 * a1];
        do
        {
LABEL_42:
          double v49 = v49 + *(double *)&v25[v48] * v47[v48];
          ++v48;
        }
        while (v26 != v48);
        goto LABEL_43;
      }
    }
LABEL_17:
    if (result == v162) {
      break;
    }
    uint64_t v16 = v163;
    if (v28 < 3) {
      goto LABEL_22;
    }
    a8.f64[0] = 0.0;
    uint64_t v33 = 16 * a1;
    uint64_t v34 = 2;
    do
    {
      *(void *)&a9.f64[0] = *(unint64_t *)((char *)v25 + v33);
      a8.f64[0] = a8.f64[0] + a9.f64[0] * a9.f64[0];
      ++v34;
      v33 += v18;
    }
    while (v26 != v34);
    if (a8.f64[0] == 0.0)
    {
LABEL_22:
      *(void *)&a8.f64[0] = *v32;
      *unsigned int v32 = 0;
    }
    else
    {
      a8.f64[0] = sqrt(a8.f64[0] + *(double *)v32 * *(double *)v32);
      a10.f64[0] = -*(double *)v32;
      a8 = (float64x2_t)vbslq_s8(v23, (int8x16_t)a8, (int8x16_t)a10);
      a9.f64[0] = 1.0 / (*(double *)v32 - a8.f64[0]);
      *(double *)unsigned int v32 = (a8.f64[0] - *(double *)v32) / a8.f64[0];
      uint64_t v57 = 16 * a1;
      uint64_t v58 = 2;
      do
      {
        a10.f64[0] = a9.f64[0] * *(double *)((char *)v25 + v57);
        *(unint64_t *)((char *)v25 + v57) = *(void *)&a10.f64[0];
        ++v58;
        v57 += v18;
      }
      while (v26 != v58);
    }
    v175[result] = a8.f64[0];
    if ((*(void *)&a8.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
      return result;
    }
    unsigned int v35 = (char *)v25 + v19;
    if (v28 >= 3 && *(double *)v32 != 0.0)
    {
      uint64_t v36 = 0;
      int v37 = v30;
      do
      {
        uint64_t v38 = 16 * a1;
        uint64_t v39 = 2;
        double v40 = *(double *)&v35[8 * v36];
        do
        {
          double v40 = v40 + *(double *)((char *)v25 + v38) * *(double *)((char *)v37 + v38);
          ++v39;
          v38 += v18;
        }
        while (v26 != v39);
        a11.f64[0] = v40 * *(double *)v32;
        *(double *)&v35[8 * v36] = *(double *)&v35[8 * v36] - a11.f64[0];
        uint64_t v41 = 16 * a1;
        uint64_t v42 = 2;
        do
        {
          a10.f64[0] = *(double *)((char *)v37 + v41);
          a9.f64[0] = a10.f64[0] + -a11.f64[0] * *(double *)((char *)v25 + v41);
          *(double *)((char *)v37 + v41) = a9.f64[0];
          ++v42;
          v41 += v18;
        }
        while (v26 != v42);
        ++v36;
        ++v37;
      }
      while (v36 != v31);
    }
    ++result;
    --v26;
    --v24;
    int v20 = (double *)((char *)v20 + v19);
    unsigned int v169 = (double *)((char *)v169 + v19);
    unsigned int v166 = (double *)((char *)v166 + v19);
    unsigned int v21 = (double *)((char *)v30 + v19);
    uint64_t v25 = (unint64_t *)((char *)v25 + v19);
  }
  double v62 = *(double *)v32;
  a7.i64[0] = v32[1];
  uint64_t v63 = v163;
  *(void *)&v175[v162] = *v32;
  a4[v163] = *(double *)a7.i64;
  uint64_t v64 = v63 + v63 * a1;
  unsigned int v65 = a3;
  a3[v64] = 1.0;
  if (a1 < 2)
  {
    unsigned int v113 = a5;
    a5[v64] = 1.0;
    *a5 = 1.0;
    goto LABEL_132;
  }
  unint64_t v66 = 0;
  uint64_t v67 = v163 * a1;
  uint64_t v68 = -8 - v18;
  uint64_t v69 = a1 * a1;
  uint64_t v156 = v69 * 8 - 8;
  uint64_t v155 = -8 * a1;
  unsigned int v70 = &a3[v69];
  unsigned int v71 = v70 - 2;
  unsigned int v72 = &a2[v67 + 1];
  int v73 = v70 + 1;
  unsigned int v74 = &a2[v67 - 2];
  uint64_t v157 = v67 * 8 - 8;
  uint64_t v158 = -8 - v18;
  unsigned int v75 = &a3[v67 - 1];
  uint64_t v76 = a1 * v162;
  uint64_t v77 = 1;
  size_t v154 = &a2[v67];
  double v62 = 1.0;
  uint64_t v78 = a1 - 2;
  uint64_t v79 = v163;
  do
  {
    uint64_t v80 = v79;
    uint64_t v79 = v78;
    unsigned int v81 = v71;
    uint64_t v82 = v77;
    if (v80 < a1)
    {
      do
      {
        double *v81 = 0.0;
        unsigned int v81 = (double *)((char *)v81 + v18);
        --v82;
      }
      while (v82);
    }
    unint64_t v83 = v77 & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v84 = v66 + 1;
    uint64_t v85 = v79 + v79 * a1;
    *(double *)a7.i64 = a2[v85];
    if (a1 - v79 >= 2 && *(double *)a7.i64 != 0.0)
    {
      uint64_t v167 = v76;
      uint64_t v86 = 0;
      unint64_t v87 = v156 + v68 * v66;
      int v88 = (char *)a2 + v157 + v68 * v66;
      uint64_t v159 = v80;
      uint64_t v89 = &v65[v79 + v80 * a1];
      unint64_t v90 = v84 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v91 = v66 + 2;
      unsigned int v92 = v71;
      unsigned int v170 = v73;
      unsigned int v93 = (float64x2_t *)v73;
      while (1)
      {
        int v95 = v93;
        unsigned int v96 = (float64x2_t *)v72;
        unint64_t v97 = v77 & 0xFFFFFFFFFFFFFFFCLL;
        double v98 = v89[v86 * a1];
        if (v66 < 3) {
          break;
        }
        do
        {
          a9 = vmulq_f64(v96[-1], v95[-1]);
          a11.f64[0] = a9.f64[1];
          a10 = vmulq_f64(*v96, *v95);
          a12.n128_u64[0] = *(void *)&a10.f64[1];
          double v98 = v98 + a9.f64[0] + a9.f64[1] + a10.f64[0] + a10.f64[1];
          v96 += 2;
          v95 += 2;
          v97 -= 4;
        }
        while (v97);
        unint64_t v99 = v84 & 0xFFFFFFFFFFFFFFFCLL | 1;
        if (v84 != v90) {
          goto LABEL_76;
        }
LABEL_77:
        a10.f64[0] = v98 * a2[v85];
        v89[v86 * a1] = v89[v86 * a1] - a10.f64[0];
        double v100 = -a10.f64[0];
        if (v66 > 2
          && ((char *)a3 + v87 + v18 * v86 >= (char *)v154 + v155 * v66
           || v88 >= (char *)&a3[a1 * a1] + v155 * v66 + v18 * v86))
        {
          unint64_t v102 = 0;
          a8 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v100, 0);
          unint64_t v103 = v77 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            a9 = *(float64x2_t *)&v72[v102 / 8 - 2];
            a10 = *(float64x2_t *)&v72[v102 / 8];
            int v104 = (__n128 *)&v93[v102 / 0x10];
            a11 = vmlaq_f64(v93[v102 / 0x10 - 1], a9, a8);
            a12 = (__n128)vmlaq_f64(v93[v102 / 0x10], a10, a8);
            v104[-1] = (__n128)a11;
            *int v104 = a12;
            v102 += 32;
            v103 -= 4;
          }
          while (v103);
          unint64_t v101 = v84 & 0xFFFFFFFFFFFFFFFCLL | 1;
          if (v84 == v90) {
            goto LABEL_71;
          }
        }
        else
        {
          unint64_t v101 = 1;
        }
        do
        {
          a9.f64[0] = v92[v101];
          v92[v101] = a9.f64[0] + v100 * v74[v101];
          ++v101;
        }
        while (v91 != v101);
LABEL_71:
        unsigned int v93 = (float64x2_t *)((char *)v93 + v18);
        unsigned int v92 = (double *)((char *)v92 + v18);
        if (v86++ == a1 - v79 - 2)
        {
          *(double *)a7.i64 = a2[v85];
          int v73 = v170;
          unsigned int v65 = a3;
          uint64_t v63 = v163;
          uint64_t v68 = -8 - v18;
          uint64_t v80 = v159;
          uint64_t v76 = v167;
          goto LABEL_88;
        }
      }
      unint64_t v99 = 1;
      double v98 = v89[v86 * a1];
      do
      {
LABEL_76:
        double v98 = v98 + v74[v99] * v92[v99];
        ++v99;
      }
      while (v91 != v99);
      goto LABEL_77;
    }
LABEL_88:
    a8.f64[0] = 1.0 - *(double *)a7.i64;
    v65[v85] = 1.0 - *(double *)a7.i64;
    if (v80 < a1)
    {
      *(double *)a7.i64 = -*(double *)a7.i64;
      if (v66 < 3 || (unint64_t)((char *)a3 - (char *)a2) <= 0x1F) {
        goto LABEL_95;
      }
      uint64_t v105 = 0;
      unint64_t v106 = v84 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        a8 = vmulq_n_f64(*(float64x2_t *)&v72[v105 - 2], *(double *)a7.i64);
        a9 = vmulq_n_f64(*(float64x2_t *)&v72[v105], *(double *)a7.i64);
        uint64_t v107 = (__n128 *)&v75[v105];
        *uint64_t v107 = (__n128)a8;
        v107[1] = (__n128)a9;
        v105 += 4;
        v83 -= 4;
      }
      while (v83);
      if (v84 != v106)
      {
        v80 += v106;
LABEL_95:
        uint64_t v108 = a1 - v80;
        uint64_t v109 = v80 + v76;
        int v110 = &v65[v109];
        unsigned int v111 = &a2[v109];
        do
        {
          double v112 = *v111++;
          a8.f64[0] = v112 * *(double *)a7.i64;
          *v110++ = v112 * *(double *)a7.i64;
          --v108;
        }
        while (v108);
      }
    }
    uint64_t v78 = v79 - 1;
    ++v77;
    unsigned int v71 = (double *)((char *)v71 + v68);
    unsigned int v72 = (double *)((char *)v72 + v68);
    int v73 = (double *)((char *)v73 + v68);
    unsigned int v74 = (double *)((char *)v74 + v68);
    unsigned int v75 = (double *)((char *)v75 + v68);
    v76 -= a1;
    ++v66;
  }
  while (v84 != v63);
  unsigned int v113 = a5;
  a5[v163 + v163 * a1] = 1.0;
  uint64_t v114 = a1 - 2;
  if (a1 >= 3)
  {
    uint64_t v115 = 0;
    uint64_t v116 = 2 * a1;
    uint64_t v117 = 3 * a1;
    uint64_t v118 = 4 * a1;
    uint64_t v119 = 5 * a1;
    unsigned int v120 = (char *)a5 + a1 * (v18 + 48) - 16;
    unint64_t v121 = v18 ^ 0xFFFFFFFFFFFFFFF8;
    unsigned int v122 = (char *)a5 + a1 * (v18 + 40) - 16;
    unsigned int v123 = (char *)a5 + a1 * (v18 + 32) - 16;
    float v124 = (char *)a5 + a1 * (v18 + 24) - 16;
    int v125 = (char *)a5 + a1 * (v18 + 16) - 16;
    unsigned int v126 = (char *)a5 + a1 * (v18 + 8) - 16;
    unsigned int v127 = &a5[a1 * a1 - 2];
    unsigned int v128 = &a5[a1 * v63 - 2];
    uint64_t v129 = 16;
    uint64_t v130 = a1 - 2;
    unint64_t v152 = v121;
    do
    {
      uint64_t v131 = v63;
      uint64_t v63 = v130;
      if (v131 < a1)
      {
        unsigned int v168 = v122;
        unsigned int v171 = v120;
        uint64_t v132 = v130;
        unsigned int v164 = v123;
        uint64_t v133 = v115;
        uint64_t v161 = v124;
        uint64_t v134 = v119;
        bzero((char *)v113 + v157 + v68 * v115, 8 * v115 + 8);
        unint64_t v121 = v152;
        unsigned int v113 = a5;
        uint64_t v119 = v134;
        float v124 = v161;
        uint64_t v118 = 4 * a1;
        uint64_t v116 = 2 * a1;
        uint64_t v117 = 3 * a1;
        uint64_t v115 = v133;
        uint64_t v114 = a1 - 2;
        unsigned int v123 = v164;
        uint64_t v68 = v158;
        uint64_t v63 = v132;
        unsigned int v122 = v168;
        unsigned int v120 = v171;
        unsigned int v65 = a3;
      }
      uint64_t v135 = v131 - 2;
      float v136 = &a2[v63 * a1 - 2 + v131];
      double v62 = *v136;
      if (*v136 != 0.0)
      {
        unint64_t v137 = 0;
        uint64_t v138 = a1 - v63;
        do
        {
          double v139 = v128[v137 / 8];
          double v140 = v139 + v136[a1] * v127[v137 / 8];
          if (v138 != 2)
          {
            double v140 = v140 + v136[v116] * *(double *)&v126[v137];
            if (v138 != 3)
            {
              double v140 = v140 + v136[v117] * *(double *)&v125[v137];
              if (v138 != 4)
              {
                double v140 = v140 + v136[v118] * *(double *)&v124[v137];
                if (v138 != 5)
                {
                  double v140 = v140 + v136[v119] * *(double *)&v123[v137];
                  if (v138 != 6)
                  {
                    double v140 = v140 + v136[6 * a1] * *(double *)&v122[v137];
                    if (v138 != 7) {
                      double v140 = v140 + v136[7 * a1] * *(double *)&v120[v137];
                    }
                  }
                }
              }
            }
          }
          a8.f64[0] = *v136;
          a9.f64[0] = v140 * *v136;
          v128[v137 / 8] = v139 - a9.f64[0];
          a10.f64[0] = v127[v137 / 8];
          v127[v137 / 8] = a10.f64[0] - a9.f64[0] * v136[a1];
          if (v138 != 2)
          {
            double v141 = -(v140 * a8.f64[0]);
            a8.f64[0] = *(float64_t *)&v126[v137];
            *(double *)&v126[v137] = a8.f64[0] + v141 * v136[v116];
            if (v138 != 3)
            {
              a8.f64[0] = *(float64_t *)&v125[v137];
              *(double *)&v125[v137] = a8.f64[0] + v141 * v136[v117];
              if (v138 != 4)
              {
                a8.f64[0] = *(float64_t *)&v124[v137];
                *(double *)&v124[v137] = a8.f64[0] + v141 * v136[v118];
                if (v138 != 5)
                {
                  a8.f64[0] = *(float64_t *)&v123[v137];
                  *(double *)&v123[v137] = a8.f64[0] + v141 * v136[v119];
                  if (v138 != 6)
                  {
                    a8.f64[0] = *(float64_t *)&v122[v137];
                    *(double *)&v122[v137] = a8.f64[0] + v141 * v136[6 * a1];
                    if (v138 != 7)
                    {
                      a8.f64[0] = *(float64_t *)&v120[v137];
                      *(double *)&v120[v137] = a8.f64[0] + v141 * v136[7 * a1];
                    }
                  }
                }
              }
            }
          }
          v137 += 8;
        }
        while (v129 != v137);
        double v62 = *v136;
      }
      *(double *)a7.i64 = 1.0 - v62;
      v113[v63 * a1 + v63] = 1.0 - v62;
      if (v131 < a1)
      {
        *(double *)a7.i64 = -(v62 * a2[v131 * a1 + v135]);
        v113[v131 * a1 + v63] = *(double *)a7.i64;
        if (v131 + 1 != a1)
        {
          double v62 = -v62;
          uint64_t v142 = (v131 + 1) * a1;
          *(double *)a7.i64 = a2[v142 + v135] * v62;
          v113[v142 + v63] = *(double *)a7.i64;
          if (v131 + 2 != a1)
          {
            uint64_t v143 = (v131 + 2) * a1;
            *(double *)a7.i64 = a2[v143 + v135] * v62;
            v113[v143 + v63] = *(double *)a7.i64;
            if (v131 + 3 != a1)
            {
              uint64_t v144 = (v131 + 3) * a1;
              *(double *)a7.i64 = a2[v144 + v135] * v62;
              v113[v144 + v63] = *(double *)a7.i64;
              if (v131 + 4 != a1)
              {
                uint64_t v145 = (v131 + 4) * a1;
                *(double *)a7.i64 = a2[v145 + v135] * v62;
                v113[v145 + v63] = *(double *)a7.i64;
                if (v131 + 5 != a1)
                {
                  uint64_t v146 = (v131 + 5) * a1;
                  *(double *)a7.i64 = a2[v146 + v135] * v62;
                  v113[v146 + v63] = *(double *)a7.i64;
                  if (v131 + 6 != a1)
                  {
                    uint64_t v147 = (v131 + 6) * a1;
                    *(double *)a7.i64 = a2[v147 + v135];
                    double v62 = *(double *)a7.i64 * v62;
                    v113[v147 + v63] = v62;
                  }
                }
              }
            }
          }
        }
      }
      uint64_t v130 = v63 - 1;
      ++v115;
      v129 += 8;
      v120 += v121;
      v122 += v121;
      v123 += v121;
      v124 += v121;
      v125 += v121;
      v126 += v121;
      unsigned int v127 = (double *)((char *)v127 + v121);
      unsigned int v128 = (double *)((char *)v128 + v121);
    }
    while (v115 != v114);
  }
  double *v113 = 1.0;
  uint64_t v148 = 1;
  uint64_t v149 = a1;
  do
  {
    v113[v149] = 0.0;
    v113[v148++] = 0.0;
    v149 += a1;
  }
  while (a1 != v148);
LABEL_132:
  uint64_t v173 = a1;
  uint64_t v174 = 0;
  int v150 = dbdsqr_(&v173, &v173, (unint64_t *)&v173, a4, v175, v113, &v173, v65, v62, a7, (__n128)a8, a9, (int8x16_t)a10, a11.f64[0], a12.n128_f64[0], (int8x16_t)a13, &v173, v151, &v174);
  return (v150 | v174) != 0;
}

uint64_t dbdsqr_(uint64_t *a1, uint64_t *a2, unint64_t *a3, double *a4, double *a5, double *a6, uint64_t *a7, double *a8, double a9, int8x16_t a10, __n128 a11, float64x2_t a12, int8x16_t a13, double a14, double a15, int8x16_t a16, uint64_t *a17, double *a18, uint64_t *a19)
{
  uint64_t v24 = *a7;
  uint64_t v25 = *a17;
  double v323 = 0.0;
  uint64_t v324 = 0;
  double v321 = 0.0;
  uint64_t v322 = 0;
  double v319 = 0.0;
  double v320 = 0.0;
  *a19 = 0;
  uint64_t v26 = *a1;
  if (!*a1) {
    return 0;
  }
  unint64_t v27 = a7;
  v318 = a4 - 1;
  uint64_t v29 = v26 - 1;
  uint64_t v316 = v25;
  if (v26 == 1)
  {
    unsigned int v30 = a2;
    goto LABEL_21;
  }
  uint64_t v31 = a5;
  v325[0] = *a1;
  double v32 = fabs(*a4);
  BOOL v33 = *a4 == 0.0 || v26 < 2;
  if (!v33)
  {
    uint64_t v34 = v26 - 2;
    unsigned int v35 = a4 + 1;
    uint64_t v36 = a5;
    double v37 = v32;
    do
    {
      double v38 = *v35++;
      double v39 = fabs(v38);
      double v40 = *v36++;
      a12.f64[0] = v37 + fabs(v40);
      double v37 = v39 * (v37 / a12.f64[0]);
      if (v32 >= v37) {
        double v32 = v37;
      }
      BOOL v41 = v32 == 0.0 || v34-- == 0;
    }
    while (!v41);
  }
  double v42 = v32 / sqrt((double)v26) * 9.99200722e-15;
  uint64_t v43 = 6 * v26 * v26;
  *(double *)a10.i64 = (double)v43 * COERCE_DOUBLE(0x8000000000000);
  double v44 = v42 <= *(double *)a10.i64 ? (double)v43 * COERCE_DOUBLE(0x8000000000000) : v42;
  if (v26 <= 1) {
    return 0;
  }
  uint64_t v112 = 0;
  uint64_t v113 = 0;
  uint64_t v114 = v31 - 1;
  uint64_t v294 = a6;
  float64x2_t v279 = &a6[~v24];
  uint64_t v280 = v24;
  float64x2_t v281 = a8;
  uint64_t v293 = &a8[~v25];
  uint64_t v288 = &a18[3 * v29];
  uint64_t v289 = (double *)((char *)a18 + ((16 * v29) | 8) - 8);
  uint64_t v115 = a4 + 1;
  uint64_t v116 = &a18[3 * v26];
  float64x2_t v283 = v116 - 5;
  float64x2_t v282 = &a18[2 * v26 - 4];
  unsigned int v291 = a18 - 1;
  float64x2_t v286 = a18 - 2;
  uint64_t v287 = v26;
  uint64_t v117 = &a18[v26 - 1];
  uint64_t v118 = v116 - 3;
  uint64_t v119 = &a18[2 * v26 - 2];
  float64x2_t v277 = &a18[2 * v26 - 3];
  float64x2_t v278 = v116 - 4;
  uint64_t v120 = -1;
  v19.i64[0] = 1.0;
  v121.f64[0] = NAN;
  v121.f64[1] = NAN;
  float64x2_t v122 = vnegq_f64(v121);
  int8x16_t v292 = (int8x16_t)v122;
  *(void *)&long long v23 = 0;
  *(void *)&long long v22 = 0;
  *(void *)&long long v21 = 0;
  *(void *)&long long v20 = 0;
  double v123 = 0.0;
  uint64_t v124 = -1;
  int v297 = v117;
  uint64_t v295 = v119;
  int8x16_t v296 = v116 - 3;
  uint64_t v290 = 6 * v26 * v26;
LABEL_77:
  uint64_t v125 = v120;
  uint64_t v126 = v124;
  uint64_t v124 = v26;
LABEL_82:
  if (v112 <= v43)
  {
LABEL_83:
    uint64_t v130 = &v318[v124];
    uint64_t v131 = v124 - 1;
    uint64_t v132 = &v114[v124 - 1];
    while (1)
    {
      while (1)
      {
        a11.n128_f64[0] = fabs(*v130);
        uint64_t v133 = v124;
        while (1)
        {
          int64_t v134 = v133 - 1;
          v122.f64[0] = fabs(v31[v133 - 2]);
          if (v122.f64[0] <= v44) {
            break;
          }
          *(double *)a10.i64 = fabs(a4[v133 - 2]);
          if (a11.n128_f64[0] > *(double *)a10.i64) {
            *(double *)a10.i64 = a11.n128_f64[0];
          }
          if (*(double *)a10.i64 <= v122.f64[0]) {
            a11.n128_f64[0] = v122.f64[0];
          }
          else {
            a11.n128_f64[0] = *(double *)a10.i64;
          }
          --v133;
          if (v134 == 1)
          {
            int64_t v134 = 0;
            goto LABEL_94;
          }
        }
        v114[v134] = 0.0;
        if (v134 == v131) {
          goto LABEL_146;
        }
LABEL_94:
        uint64_t v120 = v134 + 1;
        if (v134 + 1 == v131)
        {
          uint64_t v309 = v125;
          uint64_t v313 = v113;
          uint64_t v284 = v112;
          dlasv2_(&v318[v131], &v114[v124 - 1], v130, &v320, &v319, &v321, (double *)&v322, &v323, (int8x16_t)v122, a10, (int8x16_t)a11, (int8x16_t)a12, a13, a14, a15, a16, (double *)&v324);
          v19.i64[0] = 1.0;
          uint64_t v112 = v284;
          unint64_t v27 = a7;
          v318[v131] = v319;
          *uint64_t v132 = 0.0;
          *(double *)&long long v21 = v321;
          v318[v124] = v320;
          uint64_t v140 = *a2;
          *(void *)&long long v20 = v322;
          if (*a2 >= 1)
          {
            double v141 = &v279[v131 + v280];
            if (*a7 == 1)
            {
              uint64_t v142 = (unint64_t *)&v279[v124 + v280];
              double v143 = *v141;
              do
              {
                a10.i64[0] = *v142;
                double v144 = *(double *)&v21 * *(double *)v142 + *(double *)&v20 * v143;
                double v143 = *(double *)&v20 * *(double *)v142 - v143 * *(double *)&v21;
                *((double *)v142 - 1) = v144;
                *(double *)v142++ = v143;
                --v140;
              }
              while (v140);
            }
            else
            {
              float64x2_t v122 = (float64x2_t)vdupq_lane_s64(v322, 0);
              uint64_t v145 = 8 * *a7;
              do
              {
                a10 = *(int8x16_t *)v141;
                a12.f64[1] = v141[1];
                a12.f64[0] = -*v141;
                int8x16_t v146 = (int8x16_t)vmulq_n_f64(a12, *(double *)&v21);
                a11 = (__n128)vmlaq_f64((float64x2_t)vextq_s8(v146, v146, 8uLL), *(float64x2_t *)v141, v122);
                *(__n128 *)double v141 = a11;
                double v141 = (double *)((char *)v141 + v145);
                --v140;
              }
              while (v140);
            }
          }
          unint64_t v147 = *a3;
          *(double *)&long long v23 = v323;
          *(void *)&long long v22 = v324;
          uint64_t v115 = a4 + 1;
          uint64_t v114 = v31 - 1;
          uint64_t v118 = v296;
          uint64_t v117 = v297;
          uint64_t v119 = v295;
          uint64_t v113 = v313;
          if ((uint64_t)*a3 >= 1)
          {
            if (v147 < 8
              || ((uint64_t v148 = (float64x2_t *)&v293[v131 * v316 + 1],
                   uint64_t v149 = (float64x2_t *)&v293[v124 * v316 + 1],
                   v148 < (float64x2_t *)((char *)&v281[v147] + v316 * (8 * v124 - 8)))
                ? (BOOL v150 = v149 >= (float64x2_t *)((char *)&v281[v147] + v316 * (8 * v124 - 16)))
                : (BOOL v150 = 1),
                  !v150))
            {
              unint64_t v151 = 0;
              goto LABEL_143;
            }
            unint64_t v151 = v147 & 0xFFFFFFFFFFFFFFFELL;
            float64x2_t v122 = (float64x2_t)vdupq_lane_s64(v324, 0);
            unint64_t v152 = v147 & 0xFFFFFFFFFFFFFFFELL;
            do
            {
              float64x2_t v153 = *v148;
              a11 = *(__n128 *)v149;
              a12 = vmlaq_f64(vmulq_n_f64(*v149, *(double *)&v23), *v148, v122);
              *v148++ = a12;
              a10 = (int8x16_t)vmlaq_f64(vmulq_n_f64(vnegq_f64(v153), *(double *)&v23), (float64x2_t)a11, v122);
              *v149++ = (float64x2_t)a10;
              v152 -= 2;
            }
            while (v152);
            if (v147 != v151)
            {
LABEL_143:
              unint64_t v154 = v147 - v151;
              uint64_t v155 = v151;
              uint64_t v156 = (unint64_t *)((char *)&v281[v155] + v316 * (8 * v124 - 8));
              uint64_t v157 = (double *)((char *)&v281[v155] + v316 * (8 * v124 - 16));
              do
              {
                double v158 = *v157;
                a10.i64[0] = *v156;
                double *v157 = *(double *)&v23 * *(double *)v156 + *(double *)&v22 * *v157;
                ++v157;
                *(double *)v156++ = *(double *)&v22 * *(double *)a10.i64 - v158 * *(double *)&v23;
                --v154;
              }
              while (v154);
            }
          }
          uint64_t v131 = v124 - 2;
          uint64_t v125 = v309;
LABEL_146:
          uint64_t v124 = v131;
          if (v131 < 2)
          {
            uint64_t v26 = *a1;
            a8 = v281;
            a6 = v294;
            unsigned int v30 = a2;
            uint64_t v25 = v316;
            if (*a1 < 1) {
              return 0;
            }
LABEL_21:
            unint64_t v45 = a6 + 2;
            uint64_t v46 = 1;
            unsigned int v47 = a6;
            while (2)
            {
              double v48 = v318[v46];
              if (v48 < 0.0)
              {
                v318[v46] = -v48;
                unint64_t v49 = *v30;
                if (*v30 >= 1)
                {
                  uint64_t v50 = *v27;
                  if (v49 >= 4 && v50 == 1)
                  {
                    unint64_t v53 = v49 & 0xFFFFFFFFFFFFFFFCLL;
                    uint64_t v54 = (float64x2_t *)v45;
                    unint64_t v55 = v49 & 0xFFFFFFFFFFFFFFFCLL;
                    do
                    {
                      float64x2_t v56 = vnegq_f64(*v54);
                      v54[-1] = vnegq_f64(v54[-1]);
                      float64x2_t *v54 = v56;
                      v54 += 2;
                      v55 -= 4;
                    }
                    while (v55);
                    if (v49 != v53)
                    {
                      uint64_t v52 = v53 | 1;
                      goto LABEL_34;
                    }
                  }
                  else
                  {
                    uint64_t v52 = 1;
LABEL_34:
                    uint64_t v57 = v49 - v52 + 1;
                    uint64_t v58 = 8 * v50;
                    unint64_t v59 = (double *)((char *)v47 + v58 * (v52 - 1));
                    do
                    {
                      *unint64_t v59 = -*v59;
                      unint64_t v59 = (double *)((char *)v59 + v58);
                      --v57;
                    }
                    while (v57);
                  }
                }
              }
              ++v45;
              ++v47;
              BOOL v41 = v46++ == v26;
              if (v41)
              {
                if (v26 < 2) {
                  return 0;
                }
                uint64_t v60 = 0;
                uint64_t v61 = v26 + 1;
                uint64_t v62 = 8 * v26 - 8;
                uint64_t v63 = v25 * v62;
                uint64_t v64 = -8 * v25;
                unsigned int v65 = &a6[v26 + 1];
                unint64_t v66 = &a6[v26];
                uint64_t v67 = (char *)a8 + v25 * v62 + 16;
                uint64_t v68 = &a8[-v25 - 1];
                uint64_t v69 = v26 * v25;
                uint64_t v70 = 1;
                uint64_t v71 = v26;
                while (2)
                {
                  double v72 = *a4;
                  uint64_t v73 = v61 - v70;
                  if (v61 - v70 >= 2)
                  {
                    uint64_t v75 = 1;
                    uint64_t v74 = 1;
                    do
                    {
                      double v76 = a4[v75];
                      if (v76 <= v72) {
                        uint64_t v74 = v75 + 1;
                      }
                      uint64_t v77 = v75 + 1;
                      if (v76 <= v72) {
                        double v72 = a4[v75];
                      }
                      ++v75;
                    }
                    while (v71 != v77);
                  }
                  else
                  {
                    uint64_t v74 = 1;
                  }
                  if (v74 != v73)
                  {
                    v318[v74] = v318[v73];
                    v318[v73] = v72;
                    unint64_t v78 = *v30;
                    if (*v30 >= 1)
                    {
                      uint64_t v79 = *v27;
                      uint64_t v80 = 1;
                      if (v78 >= 6 && v79 == 1)
                      {
                        unsigned int v81 = (char *)a6 + v62 - 8 * v60;
                        uint64_t v82 = &a6[v74 - 1];
                        if (v82 < (double *)&v81[8 * v78] && v81 < (char *)&v82[v78])
                        {
                          uint64_t v80 = 1;
                          unsigned int v30 = a2;
                          goto LABEL_59;
                        }
                        unint64_t v83 = v78 & 0xFFFFFFFFFFFFFFFCLL;
                        unint64_t v84 = &a6[v74 + 1];
                        uint64_t v85 = v65;
                        unint64_t v86 = v78 & 0xFFFFFFFFFFFFFFFCLL;
                        do
                        {
                          long long v87 = *((_OWORD *)v84 - 1);
                          long long v88 = *(_OWORD *)v84;
                          long long v89 = *(_OWORD *)v85;
                          *((_OWORD *)v84 - 1) = *((_OWORD *)v85 - 1);
                          *(_OWORD *)unint64_t v84 = v89;
                          *((_OWORD *)v85 - 1) = v87;
                          *(_OWORD *)uint64_t v85 = v88;
                          v85 += 4;
                          v84 += 4;
                          v86 -= 4;
                        }
                        while (v86);
                        unsigned int v30 = a2;
                        if (v78 != v83)
                        {
                          uint64_t v80 = v83 | 1;
                          goto LABEL_59;
                        }
                      }
                      else
                      {
LABEL_59:
                        uint64_t v90 = v78 - v80 + 1;
                        uint64_t v91 = 8 * v79;
                        uint64_t v92 = v91 * (v80 - 1) - 8;
                        unsigned int v93 = &a6[v74];
                        do
                        {
                          uint64_t v94 = *(void *)((char *)v93 + v92);
                          *(double *)((char *)v93 + v92) = *(double *)((char *)v66 + v92);
                          *(void *)((char *)v66 + v92) = v94;
                          v92 += v91;
                          --v90;
                        }
                        while (v90);
                      }
                    }
                    uint64_t v25 = v316;
                    unint64_t v95 = *a3;
                    if ((uint64_t)*a3 >= 1)
                    {
                      if (v95 > 7)
                      {
                        unint64_t v97 = (char *)a8 + v63 + v64 * v60;
                        uint64_t v98 = 8 * v74 - 8;
                        if ((char *)a8 + v316 * v98 < &v97[8 * v95] && v97 < (char *)&a8[v95] + v316 * v98)
                        {
                          uint64_t v96 = 1;
                          unsigned int v30 = a2;
                          uint64_t v25 = v316;
                          goto LABEL_73;
                        }
                        unint64_t v100 = v95 & 0xFFFFFFFFFFFFFFFCLL;
                        unint64_t v101 = (long long *)((char *)a8 + v316 * v98 + 16);
                        unint64_t v102 = (long long *)v67;
                        unint64_t v103 = v95 & 0xFFFFFFFFFFFFFFFCLL;
                        unsigned int v30 = a2;
                        uint64_t v25 = v316;
                        do
                        {
                          long long v104 = *(v101 - 1);
                          long long v105 = *v101;
                          long long v106 = *v102;
                          *(v101 - 1) = *(v102 - 1);
                          long long *v101 = v106;
                          *(v102 - 1) = v104;
                          *unint64_t v102 = v105;
                          v102 += 2;
                          v101 += 2;
                          v103 -= 4;
                        }
                        while (v103);
                        if (v95 != v100)
                        {
                          uint64_t v96 = v100 | 1;
                          goto LABEL_73;
                        }
                      }
                      else
                      {
                        uint64_t v96 = 1;
LABEL_73:
                        uint64_t v107 = v74 * v25;
                        uint64_t v108 = v95 - v96 + 1;
                        uint64_t v109 = &v68[v96 + v69];
                        int v110 = &v68[v96 + v107];
                        do
                        {
                          uint64_t v111 = *(void *)v110;
                          *v110++ = *v109;
                          *(void *)v109++ = v111;
                          --v108;
                        }
                        while (v108);
                      }
                    }
                  }
                  ++v70;
                  ++v60;
                  --v71;
                  --v65;
                  --v66;
                  v67 += v64;
                  v69 -= v25;
                  if (v70 == v26) {
                    return 0;
                  }
                  continue;
                }
              }
              continue;
            }
          }
          goto LABEL_83;
        }
        if (v134 >= v126 || v124 < v125) {
          break;
        }
        if (v113 == 1)
        {
          a10.i64[0] = *(uint64_t *)v130;
          *(double *)a13.i64 = fabs(*v130);
          goto LABEL_101;
        }
        v122.f64[0] = a4[v134];
        double v135 = fabs(v122.f64[0]);
LABEL_110:
        unint64_t v137 = &v31[v134];
        *(double *)a10.i64 = fabs(*v137);
        a13.i64[0] = 0x3D06800000000000;
        a12.f64[0] = v135 * 9.99200722e-15;
        if (*(double *)a10.i64 > a12.f64[0])
        {
          a10.i64[0] = *(uint64_t *)v130;
          a12.f64[0] = fabs(*v130);
          if (v131 <= v134)
          {
LABEL_148:
            uint64_t v314 = v113;
            int v159 = 0;
            goto LABEL_149;
          }
          uint64_t v138 = v124 - 2;
          a13.i64[0] = *(void *)&a12.f64[0];
          while (1)
          {
            a14 = fabs(v31[v138]);
            a15 = *(double *)a13.i64 * 9.99200722e-15;
            if (a14 <= *(double *)a13.i64 * 9.99200722e-15) {
              break;
            }
            *(double *)a13.i64 = *(double *)a13.i64 / (*(double *)a13.i64 + a14) * fabs(a4[v138]);
            if (a12.f64[0] >= *(double *)a13.i64) {
              a12.f64[0] = *(double *)a13.i64;
            }
            BOOL v33 = v138-- <= v134;
            if (v33) {
              goto LABEL_148;
            }
          }
          uint64_t v139 = v138 + 1;
          goto LABEL_123;
        }
LABEL_120:
        *unint64_t v137 = 0.0;
      }
      v122.f64[0] = a4[v134];
      double v135 = fabs(v122.f64[0]);
      a10.i64[0] = *(uint64_t *)v130;
      *(double *)a13.i64 = fabs(*v130);
      if (v135 < *(double *)a13.i64)
      {
        uint64_t v113 = 2;
        goto LABEL_110;
      }
LABEL_101:
      a12.f64[0] = *(double *)a13.i64 * 9.99200722e-15;
      if (fabs(*v132) <= *(double *)a13.i64 * 9.99200722e-15)
      {
        unint64_t v137 = &v114[v124 - 1];
        uint64_t v113 = 1;
        goto LABEL_120;
      }
      v122.f64[0] = a4[v134];
      a12.f64[0] = fabs(v122.f64[0]);
      if (v124 <= v120)
      {
        int v159 = 1;
        uint64_t v314 = 1;
LABEL_149:
        int64_t v160 = ~v134;
        uint64_t v161 = *a1;
        if (a12.f64[0] / a11.n128_f64[0] * ((double)*a1 * 9.99200722e-15) <= 1.11022302e-16) {
          goto LABEL_248;
        }
        if (v159)
        {
          double v162 = fabs(v122.f64[0]);
          double v163 = fabs(v318[v131]);
          double v164 = fabs(*(double *)a10.i64);
          if (v163 >= v164) {
            double v165 = v164;
          }
          else {
            double v165 = v163;
          }
          if (v163 > v164) {
            double v164 = v163;
          }
          double v166 = 0.0;
          if (v165 != 0.0)
          {
            double v167 = *v132;
            goto LABEL_242;
          }
LABEL_164:
          if (v162 > 0.0)
          {
LABEL_165:
            if (v166 / v162 * (v166 / v162) >= 1.11022302e-16) {
              goto LABEL_166;
            }
LABEL_248:
            uint64_t v169 = v112 + v124 + v160;
            if (v159)
            {
LABEL_249:
              double v217 = 1.0;
              uint64_t v218 = v124 - v120;
              if (v124 <= v120)
              {
                long long v301 = v23;
                long long v304 = v22;
                long long v307 = v21;
                long long v311 = v20;
                uint64_t v285 = v169;
                double v222 = 1.0;
                v224 = a18;
LABEL_309:
                double v265 = v217 * *(double *)a10.i64;
                double *v130 = v222 * v265;
                *uint64_t v132 = v123 * v265;
                uint64_t v266 = v218 + 1;
                v325[0] = v218 + 1;
                dlasr_("L", "F", v325, a2, v224, &v291[v161], &v294[v134], v27);
                v325[0] = v266;
                int v267 = (uint64_t *)a3;
                double v268 = &v293[v120 * v316 + 1];
                uint64_t v269 = "F";
                uint64_t v271 = v288;
                uint64_t v270 = v289;
                goto LABEL_312;
              }
              uint64_t v219 = 0;
              int v220 = &v114[v120];
              uint64_t v221 = &a4[v120];
              double v222 = 1.0;
              uint64_t v223 = v134 + 1;
              v224 = a18;
              while (2)
              {
                float64x2_t v227 = &v221[v219];
                double v228 = v217 * v221[v219 - 1];
                double v229 = v220[v219];
                double v230 = 0.0;
                if (v229 == 0.0)
                {
                  double v217 = 1.0;
                  double v229 = v228;
                }
                else if (v228 == 0.0)
                {
                  double v217 = 0.0;
                  double v230 = 1.0;
                }
                else
                {
                  double v231 = sqrt(v229 * v229 + v228 * v228);
                  double v217 = v228 / v231;
                  double v232 = v229 / v231;
                  BOOL v233 = fabs(v228) > fabs(v229);
                  double v229 = -v231;
                  if (v233 && v228 / v231 < 0.0)
                  {
                    double v217 = -v217;
                    double v230 = -v232;
                  }
                  else
                  {
                    double v229 = v231;
                    double v230 = v232;
                  }
                  if ((*(void *)&v229 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                    return 0xFFFFFFFFLL;
                  }
                }
                if (v223 > v120) {
                  v220[v219 - 1] = v123 * v229;
                }
                double v225 = v222 * v229;
                double v226 = v230 * v221[v219];
                if (v226 == 0.0)
                {
                  double v222 = 1.0;
                  double v123 = 0.0;
                  goto LABEL_253;
                }
                if (v225 == 0.0)
                {
                  double v222 = 0.0;
                  double v123 = 1.0;
                  double v225 = v230 * v221[v219];
LABEL_253:
                  *(v227 - 1) = v225;
                }
                else
                {
                  double v234 = sqrt(v226 * v226 + v225 * v225);
                  double v235 = v225 / v234;
                  double v236 = v226 / v234;
                  BOOL v237 = fabs(v225) > fabs(v226);
                  BOOL v238 = v225 / v234 < 0.0;
                  if (v237 && v238) {
                    double v234 = -v234;
                  }
                  *(v227 - 1) = v234;
                  double v239 = v234;
                  if (v237 && v238) {
                    double v222 = -v235;
                  }
                  else {
                    double v222 = v235;
                  }
                  if (v237 && v238) {
                    double v123 = -v236;
                  }
                  else {
                    double v123 = v236;
                  }
                  if ((*(void *)&v239 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
                    return 0xFFFFFFFFLL;
                  }
                }
                ++v223;
                a18[v219] = v217;
                v117[v219] = v230;
                v119[v219] = v222;
                v118[v219++] = v123;
                if (v124 == v223)
                {
                  long long v301 = v23;
                  long long v304 = v22;
                  long long v307 = v21;
                  long long v311 = v20;
                  uint64_t v285 = v169;
                  a10.i64[0] = *(uint64_t *)v130;
                  goto LABEL_309;
                }
                continue;
              }
            }
LABEL_278:
            double v240 = 1.0;
            if (v124 < v134 + 2)
            {
              long long v301 = v23;
              long long v304 = v22;
              long long v307 = v21;
              long long v311 = v20;
              uint64_t v285 = v169;
              double v241 = 1.0;
              goto LABEL_311;
            }
            uint64_t v242 = v124;
            double v243 = &v278[-v120];
            int v244 = &v277[-v120];
            v245 = &v286[-v120];
            float64x2_t v246 = &v291[-v120];
            double v241 = 1.0;
            v247 = a4 - 2;
            uint64_t v248 = v31 - 2;
            uint64_t v249 = v124;
            while (2)
            {
              float64x2_t v252 = &v247[v242];
              double v253 = v240 * v247[v242 + 1];
              double v254 = v248[v124];
              double v255 = 0.0;
              if (v254 == 0.0)
              {
                double v240 = 1.0;
                double v254 = v253;
              }
              else if (v253 == 0.0)
              {
                double v240 = 0.0;
                double v255 = 1.0;
              }
              else
              {
                double v256 = sqrt(v254 * v254 + v253 * v253);
                double v240 = v253 / v256;
                double v257 = v254 / v256;
                BOOL v258 = fabs(v253) > fabs(v254);
                double v254 = -v256;
                if (v258 && v253 / v256 < 0.0)
                {
                  double v240 = -v240;
                  double v255 = -v257;
                }
                else
                {
                  double v254 = v256;
                  double v255 = v257;
                }
                if ((*(void *)&v254 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                  return 0xFFFFFFFFLL;
                }
              }
              if (v249 < v124) {
                v248[v242 + 1] = v123 * v254;
              }
              double v250 = v241 * v254;
              double v251 = v255 * v247[v124];
              if (v251 == 0.0)
              {
                double v241 = 1.0;
                double v123 = 0.0;
                goto LABEL_284;
              }
              if (v250 == 0.0)
              {
                double v241 = 0.0;
                double v123 = 1.0;
                double v250 = v255 * v247[v124];
LABEL_284:
                v252[1] = v250;
              }
              else
              {
                double v259 = sqrt(v251 * v251 + v250 * v250);
                double v260 = v250 / v259;
                double v261 = v251 / v259;
                BOOL v262 = fabs(v250) > fabs(v251);
                BOOL v263 = v250 / v259 < 0.0;
                if (v262 && v263) {
                  double v259 = -v259;
                }
                v252[1] = v259;
                double v264 = v259;
                if (v262 && v263) {
                  double v241 = -v260;
                }
                else {
                  double v241 = v260;
                }
                if (v262 && v263) {
                  double v123 = -v261;
                }
                else {
                  double v123 = v261;
                }
                if ((*(void *)&v264 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
                  return 0xFFFFFFFFLL;
                }
              }
              v246[v124] = v240;
              v245[v124 + v287] = -v255;
              v244[v124] = v241;
              --v249;
              v243[v124] = -v123;
              --v248;
              --v243;
              --v244;
              --v245;
              --v246;
              --v247;
              if (v249 + 1 > v134 + 2) {
                continue;
              }
              break;
            }
            long long v301 = v23;
            long long v304 = v22;
            long long v307 = v21;
            long long v311 = v20;
            uint64_t v285 = v169;
            v122.f64[0] = a4[v134];
LABEL_311:
            unint64_t v272 = v134;
            double v273 = v240 * v122.f64[0];
            a4[v272] = v241 * v273;
            uint64_t v132 = &v31[v272];
            v31[v272] = v123 * v273;
            v325[0] = v124 - v120 + 1;
            dlasr_("L", "B", v325, a2, v289, v288, &v294[v272], v27);
            v325[0] = v124 - v120 + 1;
            uint64_t v271 = &v291[*a1];
            int v267 = (uint64_t *)a3;
            uint64_t v270 = a18;
            double v268 = &v293[v120 * v316 + 1];
            uint64_t v269 = "B";
LABEL_312:
            dlasr_("R", v269, v267, v325, v270, v271, v268, a17);
            uint64_t v114 = v31 - 1;
            unint64_t v27 = a7;
            uint64_t v26 = v124;
            uint64_t v43 = v290;
            uint64_t v112 = v285;
            uint64_t v117 = v297;
            uint64_t v115 = a4 + 1;
            uint64_t v119 = v295;
            uint64_t v118 = v296;
            v19.i64[0] = 1.0;
            uint64_t v113 = v314;
            long long v20 = v311;
            long long v22 = v304;
            long long v21 = v307;
            long long v23 = v301;
            if (fabs(*v132) <= v44)
            {
              *uint64_t v132 = 0.0;
              uint64_t v26 = v124;
            }
            goto LABEL_77;
          }
        }
        else
        {
          double v162 = fabs(*(double *)a10.i64);
          double v164 = fabs(v122.f64[0]);
          double v168 = fabs(v318[v134 + 2]);
          if (v164 >= v168) {
            double v165 = v168;
          }
          else {
            double v165 = v164;
          }
          if (v164 <= v168) {
            double v164 = v168;
          }
          double v166 = 0.0;
          if (v165 == 0.0) {
            goto LABEL_164;
          }
          double v167 = v31[v134];
LABEL_242:
          double v214 = fabs(v167);
          double v215 = v165 / v164 + *(double *)v19.i64;
          double v216 = (v164 - v165) / v164;
          if (v214 >= v164)
          {
            double v166 = v164
                 / v214
                 * (v165
                  * (2.0
                   / (sqrt(*(double *)v19.i64 + v164 / v214 * v215 * (v164 / v214 * v215))
                    + sqrt(*(double *)v19.i64 + v164 / v214 * v216 * (v164 / v214 * v216)))));
            if (v162 > 0.0) {
              goto LABEL_165;
            }
          }
          else
          {
            double v166 = v165
                 * (2.0
                  / (sqrt(v214 / v164 * (v214 / v164) + v215 * v215) + sqrt(v214 / v164 * (v214 / v164) + v216 * v216)));
            if (v162 > 0.0) {
              goto LABEL_165;
            }
          }
        }
LABEL_166:
        uint64_t v169 = v112 + v124 + v160;
        if (v166 == 0.0)
        {
          if (v159) {
            goto LABEL_249;
          }
          goto LABEL_278;
        }
        if (v159)
        {
          double v170 = (fabs(v122.f64[0]) - v166) * (*(double *)vbslq_s8(v292, v19, (int8x16_t)v122).i64 + v166 / v122.f64[0]);
          if (v124 <= v120)
          {
            unsigned int v176 = a18;
          }
          else
          {
            uint64_t v171 = 0;
            double v172 = v31[v134];
            uint64_t v173 = &v114[v134];
            uint64_t v174 = &v115[v134];
            uint64_t v175 = v134 + 1;
            unsigned int v176 = a18;
            do
            {
              if (v172 == 0.0)
              {
                *(void *)&long long v20 = 1.0;
                *(void *)&long long v21 = 0;
              }
              else if (v170 == 0.0)
              {
                *(void *)&long long v20 = 0;
                *(void *)&long long v21 = 1.0;
                double v170 = v172;
              }
              else
              {
                double v177 = sqrt(v172 * v172 + v170 * v170);
                BOOL v178 = fabs(v170) > fabs(v172);
                BOOL v179 = v170 / v177 < 0.0;
                if (v178 && v179) {
                  *(double *)&long long v21 = -(v172 / v177);
                }
                else {
                  *(double *)&long long v21 = v172 / v177;
                }
                if (v178 && v179) {
                  *(double *)&long long v20 = -(v170 / v177);
                }
                else {
                  *(double *)&long long v20 = v170 / v177;
                }
                if (v178 && v179) {
                  double v170 = -v177;
                }
                else {
                  double v170 = v177;
                }
                if ((*(void *)&v170 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                  return 0xFFFFFFFFLL;
                }
              }
              if (v175 > v120) {
                v173[v171] = v170;
              }
              double v180 = v174[v171 - 1];
              double v181 = v173[v171 + 1];
              double v182 = *(double *)&v21 * v181 + *(double *)&v20 * v180;
              v173[v171 + 1] = *(double *)&v20 * v181 - *(double *)&v21 * v180;
              double v183 = v174[v171];
              double v172 = *(double *)&v21 * v183;
              double v184 = *(double *)&v20 * v183;
              v174[v171] = v184;
              if (v172 == 0.0)
              {
                *(void *)&long long v22 = 1.0;
                *(void *)&long long v23 = 0;
              }
              else if (v182 == 0.0)
              {
                *(void *)&long long v22 = 0;
                *(void *)&long long v23 = 1.0;
                double v182 = v172;
              }
              else
              {
                double v185 = sqrt(v172 * v172 + v182 * v182);
                BOOL v186 = fabs(v182) > fabs(v172);
                BOOL v187 = v182 / v185 < 0.0;
                if (v186 && v187) {
                  *(double *)&long long v23 = -(v172 / v185);
                }
                else {
                  *(double *)&long long v23 = v172 / v185;
                }
                if (v186 && v187) {
                  *(double *)&long long v22 = -(v182 / v185);
                }
                else {
                  *(double *)&long long v22 = v182 / v185;
                }
                if (v186 && v187) {
                  double v182 = -v185;
                }
                else {
                  double v182 = v185;
                }
                if ((*(void *)&v182 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                  return 0xFFFFFFFFLL;
                }
              }
              v174[v171 - 1] = v182;
              double v188 = v173[v171 + 1];
              v174[v171] = *(double *)&v22 * v184 - *(double *)&v23 * v188;
              if (v175 < v131)
              {
                double v189 = v173[v171 + 2];
                double v172 = *(double *)&v23 * v189;
                v173[v171 + 2] = *(double *)&v22 * v189;
              }
              ++v175;
              double v170 = v184 * *(double *)&v23 + *(double *)&v22 * v188;
              *(void *)&a18[v171] = v20;
              *(void *)&v117[v171] = v21;
              *(void *)&v119[v171] = v22;
              *(void *)&v118[v171++] = v23;
            }
            while (v124 != v175);
          }
          long long v300 = v23;
          long long v303 = v22;
          long long v306 = v21;
          long long v310 = v20;
          *(void *)&double v321 = v21;
          uint64_t v322 = v20;
          *(void *)&double v323 = v23;
          uint64_t v324 = v22;
          uint64_t v213 = v169;
          *uint64_t v132 = v170;
          v325[0] = v124 - v134;
          dlasr_("L", "F", v325, a2, v176, &v291[v161], &v294[v134], v27);
          v325[0] = v124 - v120 + 1;
          dlasr_("R", "F", (uint64_t *)a3, v325, v289, v288, &v293[v120 * v316 + 1], a17);
          long long v23 = v300;
          long long v22 = v303;
          long long v21 = v306;
          long long v20 = v310;
          v19.i64[0] = 1.0;
          uint64_t v119 = v295;
          uint64_t v118 = v296;
          uint64_t v117 = v297;
          uint64_t v115 = a4 + 1;
          uint64_t v112 = v213;
          uint64_t v114 = v31 - 1;
          unint64_t v27 = a7;
          uint64_t v125 = v120;
          uint64_t v126 = v124;
          uint64_t v43 = v290;
          uint64_t v113 = v314;
          if (fabs(*v132) <= v44)
          {
            *uint64_t v132 = 0.0;
            uint64_t v125 = v120;
            uint64_t v126 = v124;
          }
        }
        else
        {
          double v190 = (fabs(*(double *)a10.i64) - v166)
               * (*(double *)vbslq_s8(v292, v19, a10).i64 + v166 / *(double *)a10.i64);
          uint64_t v191 = v134 + 2;
          if (v124 >= v134 + 2)
          {
            uint64_t v192 = v124;
            double v193 = *v132;
            unsigned int v194 = &v283[-v134];
            uint64_t v195 = &v282[-v134];
            unsigned int v196 = &a18[-v134 - 3];
            uint64_t v197 = &v286[-v134];
            uint64_t v198 = v318;
            uint64_t v199 = v124;
            do
            {
              if (v193 == 0.0)
              {
                *(void *)&long long v20 = 1.0;
                *(void *)&long long v21 = 0;
              }
              else if (v190 == 0.0)
              {
                *(void *)&long long v20 = 0;
                *(void *)&long long v21 = 1.0;
                double v190 = v193;
              }
              else
              {
                double v200 = sqrt(v193 * v193 + v190 * v190);
                BOOL v201 = fabs(v190) > fabs(v193);
                BOOL v202 = v190 / v200 < 0.0;
                if (v201 && v202) {
                  *(double *)&long long v21 = -(v193 / v200);
                }
                else {
                  *(double *)&long long v21 = v193 / v200;
                }
                if (v201 && v202) {
                  *(double *)&long long v20 = -(v190 / v200);
                }
                else {
                  *(double *)&long long v20 = v190 / v200;
                }
                if (v201 && v202) {
                  double v190 = -v200;
                }
                else {
                  double v190 = v200;
                }
                if ((*(void *)&v190 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                  return 0xFFFFFFFFLL;
                }
              }
              if (v199 < v124) {
                v114[v124] = v190;
              }
              double v203 = v198[v124];
              double v204 = v114[v192 - 1];
              double v205 = *(double *)&v21 * v204 + *(double *)&v20 * v203;
              v114[v192 - 1] = *(double *)&v20 * v204 - *(double *)&v21 * v203;
              double v206 = v198[v192 - 1];
              double v193 = *(double *)&v21 * v206;
              double v207 = *(double *)&v20 * v206;
              v198[v192 - 1] = v207;
              if (v193 == 0.0)
              {
                *(void *)&long long v22 = 1.0;
                *(void *)&long long v23 = 0;
              }
              else if (v205 == 0.0)
              {
                *(void *)&long long v22 = 0;
                *(void *)&long long v23 = 1.0;
                double v205 = v193;
              }
              else
              {
                double v208 = sqrt(v193 * v193 + v205 * v205);
                BOOL v209 = fabs(v205) > fabs(v193);
                BOOL v210 = v205 / v208 < 0.0;
                if (v209 && v210) {
                  *(double *)&long long v23 = -(v193 / v208);
                }
                else {
                  *(double *)&long long v23 = v193 / v208;
                }
                if (v209 && v210) {
                  *(double *)&long long v22 = -(v205 / v208);
                }
                else {
                  *(double *)&long long v22 = v205 / v208;
                }
                if (v209 && v210) {
                  double v205 = -v208;
                }
                else {
                  double v205 = v208;
                }
                if ((*(void *)&v205 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
                  return 0xFFFFFFFFLL;
                }
              }
              v198[v124] = v205;
              double v211 = v114[v192 - 1];
              v198[v192 - 1] = *(double *)&v22 * v207 - *(double *)&v23 * v211;
              if (v199 > v191)
              {
                double v212 = v114[v192 - 2];
                double v193 = *(double *)&v23 * v212;
                v114[v192 - 2] = *(double *)&v22 * v212;
              }
              --v199;
              *(void *)&v197[v124] = v20;
              v196[v124 + v287] = -*(double *)&v21;
              *(void *)&v195[v124] = v22;
              v194[v124] = -*(double *)&v23;
              --v114;
              --v194;
              --v195;
              double v190 = v207 * *(double *)&v23 + *(double *)&v22 * v211;
              --v196;
              --v197;
              --v198;
            }
            while (v199 + 1 > v191);
          }
          long long v299 = v23;
          long long v302 = v22;
          long long v305 = v21;
          long long v308 = v20;
          *(void *)&double v321 = v21;
          uint64_t v322 = v20;
          *(void *)&double v323 = v23;
          uint64_t v324 = v22;
          uint64_t v127 = v134;
          if (fabs(v190) <= v44) {
            double v128 = 0.0;
          }
          else {
            double v128 = v190;
          }
          v31[v127] = v128;
          v325[0] = v124 - v120 + 1;
          uint64_t v126 = v124;
          uint64_t v129 = v169;
          dlasr_("L", "B", v325, a2, v289, v288, &v294[v127], v27);
          v325[0] = v124 - v120 + 1;
          dlasr_("R", "B", (uint64_t *)a3, v325, a18, &v291[*a1], &v293[v120 * v316 + 1], a17);
          long long v23 = v299;
          long long v22 = v302;
          long long v21 = v305;
          long long v20 = v308;
          v19.i64[0] = 1.0;
          uint64_t v119 = v295;
          uint64_t v118 = v296;
          uint64_t v117 = v297;
          uint64_t v115 = a4 + 1;
          uint64_t v112 = v129;
          uint64_t v114 = v31 - 1;
          unint64_t v27 = a7;
          uint64_t v125 = v120;
          uint64_t v43 = v290;
          uint64_t v113 = v314;
        }
        goto LABEL_82;
      }
      int64_t v136 = v134;
      a13.i64[0] = *(void *)&a12.f64[0];
      while (1)
      {
        a14 = fabs(v31[v136]);
        a15 = *(double *)a13.i64 * 9.99200722e-15;
        if (a14 <= *(double *)a13.i64 * 9.99200722e-15) {
          break;
        }
        *(double *)a13.i64 = *(double *)a13.i64 / (*(double *)a13.i64 + a14) * fabs(v115[v136]);
        if (a12.f64[0] >= *(double *)a13.i64) {
          a12.f64[0] = *(double *)a13.i64;
        }
        if (v131 == ++v136)
        {
          int v159 = 1;
          uint64_t v314 = 1;
          goto LABEL_149;
        }
      }
      uint64_t v139 = v136 + 1;
      uint64_t v113 = 1;
LABEL_123:
      v114[v139] = 0.0;
    }
  }
  *a19 = 0;
  if (*a1 < 2) {
    return 0;
  }
  uint64_t v275 = 0;
  uint64_t v276 = *a1 - 1;
  uint64_t result = 0;
  do
  {
    if (*v31 != 0.0) {
      *a19 = ++v275;
    }
    ++v31;
    --v276;
  }
  while (v276);
  return result;
}

uint64_t dlasv2_(double *a1, double *a2, double *a3, double *a4, double *a5, double *a6, double *a7, double *a8, int8x16_t a9, int8x16_t a10, int8x16_t a11, int8x16_t a12, int8x16_t a13, double a14, double a15, int8x16_t a16, double *a17)
{
  int8x16_t v19 = a17;
  double v20 = *a1;
  double v21 = fabs(*a1);
  double v22 = fabs(*a3);
  uint64_t v23 = 1;
  if (v22 > v21) {
    double v24 = v22;
  }
  else {
    double v24 = v21;
  }
  if (v22 > v21) {
    double v25 = v21;
  }
  else {
    double v25 = v22;
  }
  if (v22 > v21) {
    a11.i64[0] = *(uint64_t *)a3;
  }
  else {
    a11.i64[0] = *(uint64_t *)a1;
  }
  if (v22 > v21) {
    uint64_t v23 = 3;
  }
  else {
    double v20 = *a3;
  }
  a13.i64[0] = *(uint64_t *)a2;
  if (*a2 == 0.0)
  {
    *a4 = v25;
    *a5 = v24;
    double v26 = 0.0;
    double v27 = 1.0;
    double v28 = 1.0;
    double v29 = 0.0;
  }
  else
  {
    double v30 = fabs(*(double *)a13.i64);
    if (v30 > v24)
    {
      if (v24 / v30 < 1.11022302e-16)
      {
        *a5 = v30;
        if (v25 <= 1.0) {
          double v31 = v25 * (v24 / v30);
        }
        else {
          double v31 = v24 / (v30 / v25);
        }
        *a4 = v31;
        double v47 = v20 / *(double *)a13.i64;
        double v48 = *(double *)a11.i64 / *(double *)a13.i64;
        BOOL v49 = v22 <= v21;
        if (v22 <= v21) {
          double v50 = v47;
        }
        else {
          double v50 = v48;
        }
        if (v49) {
          double v51 = v48;
        }
        else {
          double v51 = v47;
        }
        *a17 = 1.0;
        *a8 = v50;
        *a7 = v51;
        *a6 = 1.0;
        a9.i64[0] = 1.0;
        goto LABEL_53;
      }
      uint64_t v23 = 2;
    }
    *(double *)a16.i64 = v24 - v25;
    double v32 = (v24 - v25) / v24;
    v17.i64[0] = 1.0;
    if (v24 - v25 == v24) {
      double v32 = 1.0;
    }
    double v33 = *(double *)a13.i64 / *(double *)a11.i64;
    v18.i64[0] = 2.0;
    double v34 = 2.0 - v32;
    double v35 = sqrt(v34 * v34 + v33 * v33);
    double v36 = fabs(*(double *)a13.i64 / *(double *)a11.i64);
    double v37 = sqrt(v33 * v33 + v32 * v32);
    if (v32 != 0.0) {
      double v36 = v37;
    }
    double v38 = (v35 + v36) * 0.5;
    *a4 = v25 / v38;
    *a5 = v24 * v38;
    v39.f64[0] = NAN;
    v39.f64[1] = NAN;
    int8x16_t v40 = (int8x16_t)vnegq_f64(v39);
    double v41 = *(double *)a13.i64 / *(double *)vbslq_s8(v40, a16, a11).i64 + v33 / v34;
    double v42 = *(double *)vbslq_s8(v40, v18, a11).i64 * *(double *)vbslq_s8(v40, v17, a13).i64;
    if (v32 != 0.0) {
      double v42 = v41;
    }
    if (v33 * v33 != 0.0) {
      double v42 = (v33 / (v34 + v35) + v33 / (v32 + v36)) * (v38 + 1.0);
    }
    double v43 = sqrt(v42 * v42 + 4.0);
    double v28 = 2.0 / v43;
    double v29 = v42 / v43;
    double v27 = (v28 + v29 * v33) / v38;
    double v26 = v20 / *(double *)a11.i64 * v29 / v38;
  }
  BOOL v44 = v22 <= v21;
  if (v22 <= v21) {
    double v45 = v27;
  }
  else {
    double v45 = v29;
  }
  if (v44) {
    double v46 = v26;
  }
  else {
    double v46 = v28;
  }
  if (v44) {
    double v26 = v28;
  }
  *a17 = v45;
  *a8 = v46;
  if (v44) {
    *(double *)a9.i64 = v29;
  }
  else {
    *(double *)a9.i64 = v27;
  }
  *a7 = v26;
  *a6 = *(double *)a9.i64;
  if (v23 != 2)
  {
    if (v23 == 1)
    {
      a9.i64[0] = *(uint64_t *)a7;
      a2 = a1;
    }
    else
    {
      int8x16_t v19 = a8;
      a2 = a3;
    }
  }
LABEL_53:
  a10.i64[0] = 1.0;
  v52.f64[0] = NAN;
  v52.f64[1] = NAN;
  int8x16_t v53 = (int8x16_t)vnegq_f64(v52);
  int8x16_t v54 = vbslq_s8(v53, a10, a9);
  a12.i64[0] = *(uint64_t *)v19;
  int8x16_t v55 = vbslq_s8(v53, a10, a12);
  *(double *)v54.i64 = *(double *)v54.i64 * *(double *)v55.i64;
  v55.i64[0] = *(uint64_t *)a2;
  int8x16_t v56 = vbslq_s8(v53, a10, v55);
  *(double *)v54.i64 = *(double *)v54.i64 * *(double *)v56.i64;
  v56.i64[0] = *(uint64_t *)a5;
  int8x16_t v57 = vbslq_s8(v53, v56, v54);
  *a5 = *(double *)v57.i64;
  v57.i64[0] = *(uint64_t *)a1;
  int8x16_t v58 = vbslq_s8(v53, a10, v57);
  *(double *)v54.i64 = *(double *)v54.i64 * *(double *)v58.i64;
  v58.i64[0] = *(uint64_t *)a3;
  int8x16_t v59 = vbslq_s8(v53, a10, v58);
  *(double *)v54.i64 = *(double *)v54.i64 * *(double *)v59.i64;
  v59.i64[0] = *(uint64_t *)a4;
  *(void *)a4 = vbslq_s8(v53, v59, v54).u64[0];
  return 0;
}

uint64_t dlasr_(const char *a1, const char *a2, uint64_t *a3, uint64_t *a4, double *a5, double *a6, double *a7, uint64_t *a8)
{
  uint64_t v8 = *a3;
  if (!*a3) {
    return 0;
  }
  uint64_t v9 = *a4;
  if (!*a4) {
    return 0;
  }
  unsigned int v10 = a5 - 1;
  unint64_t v11 = a6 - 1;
  uint64_t v12 = *a8;
  int v13 = *(unsigned __int8 *)a2;
  if (*a1 != 76)
  {
    uint64_t v26 = v9 - 2;
    BOOL v28 = v9 < 2 || v8 < 1;
    if (v13 == 70)
    {
      if (v28) {
        return 0;
      }
      uint64_t v29 = 0;
      unint64_t v30 = 8 * v12;
      double v31 = &a7[-v12 - 1];
      uint64_t v32 = 2 * v12;
      uint64_t v33 = 1;
      uint64_t v34 = *a8;
      double v35 = a7;
      while (1)
      {
        uint64_t v36 = *(uint64_t *)&v10[v33];
        uint64_t v37 = *(uint64_t *)&v11[v33];
        if (*(double *)&v36 == 1.0 && *(double *)&v37 == 0.0) {
          goto LABEL_29;
        }
        double v38 = -*(double *)&v37;
        if ((unint64_t)v8 >= 2
          && ((char *)&a7[v30 / 8] + v30 * v29 < (char *)&a7[v8] + v30 * v29
            ? (BOOL v39 = (char *)a7 + v30 * v29 >= (char *)&a7[v8 + v12] + v30 * v29)
            : (BOOL v39 = 1),
              v39))
        {
          float64x2_t v40 = (float64x2_t)vdupq_lane_s64(v36, 0);
          float64x2_t v41 = (float64x2_t)vdupq_lane_s64(v37, 0);
          double v42 = (float64x2_t *)v35;
          unint64_t v43 = v8 & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            float64x2_t v44 = *(float64x2_t *)((char *)v42 + 8 * v12);
            float64x2_t v45 = *v42;
            *(float64x2_t *)((char *)v42 + 8 * v12) = vmlaq_f64(vmulq_n_f64(*v42, v38), v44, v40);
            *v42++ = vmlaq_f64(vmulq_n_f64(v45, *(double *)&v36), v44, v41);
            v43 -= 2;
          }
          while (v43);
          uint64_t v46 = v8 | 1;
          if (v8 == (v8 & 0xFFFFFFFFFFFFFFFELL)) {
            goto LABEL_29;
          }
        }
        else
        {
          uint64_t v46 = 1;
        }
        uint64_t v47 = v8 + 1 - v46;
        double v48 = &v31[v46 + v34];
        BOOL v49 = &v31[v46 + v32];
        do
        {
          double v50 = *v49;
          double *v49 = *v48 * v38 + *(double *)&v36 * *v49;
          ++v49;
          double *v48 = *(double *)&v36 * *v48 + *(double *)&v37 * v50;
          ++v48;
          --v47;
        }
        while (v47);
LABEL_29:
        ++v33;
        ++v29;
        double v35 = (double *)((char *)v35 + v30);
        v34 += v12;
        v32 += v12;
        if (v33 == v9) {
          return 0;
        }
      }
    }
    if (v28) {
      return 0;
    }
    uint64_t v63 = 0;
    uint64_t v64 = v12 * (8 * v9 - 8);
    uint64_t v65 = -8 * v12;
    uint64_t v66 = v64 + 8 * v8;
    uint64_t v67 = v12 * (8 * v9 - 16);
    uint64_t v68 = (char *)a7 + v67;
    uint64_t v69 = (float64x2_t *)((char *)a7 + v64);
    uint64_t v70 = (char *)a7 + v66;
    uint64_t v71 = (char *)&a7[v8] + v67;
    double v72 = v69;
    uint64_t v73 = (float64x2_t *)((char *)a7 + v67);
    while (1)
    {
      uint64_t v74 = *(uint64_t *)&v10[--v9];
      uint64_t v75 = *(uint64_t *)&v11[v9];
      if (*(double *)&v74 == 1.0 && *(double *)&v75 == 0.0) {
        goto LABEL_58;
      }
      double v76 = -*(double *)&v75;
      if ((unint64_t)v8 >= 2
        && ((char *)v69 + v65 * v63 < &v71[v65 * v63] ? (BOOL v77 = &v68[v65 * v63] >= &v70[v65 * v63]) : (BOOL v77 = 1), v77))
      {
        float64x2_t v78 = (float64x2_t)vdupq_lane_s64(v74, 0);
        float64x2_t v79 = (float64x2_t)vdupq_lane_s64(v75, 0);
        uint64_t v80 = v72;
        unsigned int v81 = v73;
        unint64_t v82 = v8 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          float64x2_t v83 = *v80;
          float64x2_t v84 = *v81;
          float64x2_t *v80 = vmlaq_f64(vmulq_n_f64(*v81, v76), *v80, v78);
          ++v80;
          *v81++ = vmlaq_f64(vmulq_n_f64(v84, *(double *)&v74), v83, v79);
          v82 -= 2;
        }
        while (v82);
        uint64_t v85 = v8 | 1;
        if (v8 == (v8 & 0xFFFFFFFFFFFFFFFELL)) {
          goto LABEL_58;
        }
      }
      else
      {
        uint64_t v85 = 1;
      }
      uint64_t v86 = 0;
      uint64_t v87 = v8 + 1 - v85;
      uint64_t v88 = 8 * v85;
      long long v89 = (char *)&v73->f64[v85];
      uint64_t v90 = (char *)v72 + v88;
      do
      {
        uint64_t v91 = &v90[8 * v86];
        double v92 = *((double *)v91 - 1);
        unsigned int v93 = &v89[8 * v86];
        *((double *)v91 - 1) = *((double *)v93 - 1) * v76 + *(double *)&v74 * v92;
        *((double *)v93 - 1) = *(double *)&v74 * *((double *)v93 - 1) + *(double *)&v75 * v92;
        ++v86;
      }
      while (v87 != v86);
LABEL_58:
      uint64_t v73 = (float64x2_t *)((char *)v73 - 8 * v12);
      double v72 = (float64x2_t *)((char *)v72 - 8 * v12);
      BOOL v55 = v63++ == v26;
      if (v55) {
        return 0;
      }
    }
  }
  uint64_t v14 = v8 - 2;
  BOOL v15 = v8 < 2 || v9 < 1;
  char v16 = v15;
  if (v13 == 70)
  {
    if ((v16 & 1) == 0)
    {
      if (v12 == 1)
      {
        uint64_t v17 = 0;
        int8x16_t v18 = a7 + 1;
        uint64_t v19 = 1;
        do
        {
          double v20 = v10[v19];
          double v21 = v11[v19];
          if (v20 != 1.0 || v21 != 0.0)
          {
            double v22 = a7[v17];
            uint64_t v23 = v9;
            double v24 = v18;
            do
            {
              double v25 = v22 * -v21 + v20 * *v24;
              *(v24 - 1) = v20 * v22 + v21 * *v24;
              *v24++ = v25;
              double v22 = v25;
              --v23;
            }
            while (v23);
          }
          ++v19;
          ++v17;
          ++v18;
        }
        while (v19 != v8);
      }
      else
      {
        uint64_t v94 = a7 + 1;
        uint64_t v95 = 8 * v12;
        uint64_t v96 = 1;
        do
        {
          double v97 = v10[v96];
          double v98 = v11[v96];
          if (v97 != 1.0 || v98 != 0.0)
          {
            unint64_t v99 = v94;
            uint64_t v100 = v9;
            do
            {
              double v101 = *(v99 - 1);
              double v102 = v101 * -v98 + v97 * *v99;
              *(v99 - 1) = v97 * v101 + v98 * *v99;
              *unint64_t v99 = v102;
              unint64_t v99 = (double *)((char *)v99 + v95);
              --v100;
            }
            while (v100);
          }
          ++v96;
          ++v94;
        }
        while (v96 != v8);
      }
    }
  }
  else if ((v16 & 1) == 0)
  {
    uint64_t v51 = v8;
    if (v12 == 1)
    {
      uint64_t v52 = 0;
      uint64_t v53 = v51 * 8 - 16;
      int8x16_t v54 = &a7[v8 - 1];
      do
      {
        double v56 = v10[--v8];
        double v57 = v11[v8];
        if (v56 != 1.0 || v57 != 0.0)
        {
          double v58 = *(double *)((char *)a7 + v53 - 8 * v52);
          uint64_t v59 = v9;
          uint64_t v60 = v54;
          do
          {
            double v61 = v58 * -v57 + v56 * *v60;
            *(v60 - 1) = v56 * v58 + v57 * *v60;
            *v60++ = v61;
            double v58 = v61;
            --v59;
          }
          while (v59);
        }
        --v54;
        BOOL v55 = v52++ == v14;
      }
      while (!v55);
    }
    else
    {
      unint64_t v103 = &a7[v51 - 1];
      uint64_t v104 = 8 * v12;
      do
      {
        uint64_t v105 = v8 - 1;
        double v106 = v10[v105];
        double v107 = v11[v105];
        if (v106 != 1.0 || v107 != 0.0)
        {
          uint64_t v108 = v103;
          uint64_t v109 = v9;
          do
          {
            double v110 = *(v108 - 1);
            double v111 = v110 * -v107 + v106 * *v108;
            *(v108 - 1) = v106 * v110 + v107 * *v108;
            *uint64_t v108 = v111;
            uint64_t v108 = (double *)((char *)v108 + v104);
            --v109;
          }
          while (v109);
        }
        --v103;
        BOOL v15 = v8-- <= 2;
      }
      while (!v15);
    }
  }
  return 0;
}

uint64_t bidiagonalSVD(uint64_t a1, double *a2, double *a3, double *a4, double *a5, double *a6, double a7, int8x16_t a8, __n128 a9, float64x2_t a10, int8x16_t a11, double a12, double a13, int8x16_t a14)
{
  uint64_t v16 = a1;
  uint64_t v17 = 0;
  int v14 = dbdsqr_(&v16, &v16, (unint64_t *)&v16, a2, a3, a5, &v16, a4, a7, a8, a9, a10, a11, a12, a13, a14, &v16, a6, &v17);
  return v14 | v17;
}

void CRandomGenerator::~CRandomGenerator(CRandomGenerator *this)
{
}

void CRandomGenerator::CRandomGenerator(CRandomGenerator *this, unsigned int a2)
{
  *(void *)this = &unk_26C687590;
  unsigned int v2 = 5489;
  uint64_t v3 = 1;
  for (uint64_t i = 3; i != 626; ++i)
  {
    int v5 = 1812433253 * (v2 ^ (v2 >> 30));
    unsigned int v2 = v5 + v3;
    *((_DWORD *)this + i) = i + v5 - 2;
    ++v3;
  }
  *((_DWORD *)this + 2) = a2;
  uint64_t v6 = 1;
  for (uint64_t j = 3; j != 626; ++j)
  {
    int v8 = 1812433253 * (a2 ^ (a2 >> 30));
    a2 = v8 + v6;
    *((_DWORD *)this + j) = j + v8 - 2;
    ++v6;
  }
  *((void *)this + 313) = 0;
}

{
  unsigned int v2;
  uint64_t v3;
  uint64_t i;
  int v5;
  uint64_t v6;
  uint64_t j;
  int v8;

  *(void *)this = &unk_26C687590;
  unsigned int v2 = 5489;
  uint64_t v3 = 1;
  for (uint64_t i = 3; i != 626; ++i)
  {
    int v5 = 1812433253 * (v2 ^ (v2 >> 30));
    unsigned int v2 = v5 + v3;
    *((_DWORD *)this + i) = i + v5 - 2;
    ++v3;
  }
  *((_DWORD *)this + 2) = a2;
  uint64_t v6 = 1;
  for (uint64_t j = 3; j != 626; ++j)
  {
    int v8 = 1812433253 * (a2 ^ (a2 >> 30));
    a2 = v8 + v6;
    *((_DWORD *)this + j) = j + v8 - 2;
    ++v6;
  }
  *((void *)this + 313) = 0;
}

uint64_t CRandomGenerator::Init(uint64_t this, unsigned int a2)
{
  *(_DWORD *)(this + 8) = a2;
  uint64_t v2 = 1;
  for (uint64_t i = 3; i != 626; ++i)
  {
    int v4 = 1812433253 * (a2 ^ (a2 >> 30));
    a2 = v4 + v2;
    *(_DWORD *)(this + 4 * i) = i + v4 - 2;
    ++v2;
  }
  *(void *)(this + 2504) = 0;
  return this;
}

float CRandomGenerator::UniformRand(CRandomGenerator *this)
{
  uint64_t v1 = *((void *)this + 313);
  unint64_t v2 = (v1 + 1) % 0x270uLL;
  uint64_t v3 = 4 * v1;
  LODWORD(v1) = *((_DWORD *)this + (v1 + 397) % 0x270uLL + 2) ^ ((*((_DWORD *)this + v2 + 2) & 0x7FFFFFFE | *((_DWORD *)this + v1 + 2) & 0x80000000) >> 1) ^ ((int)(*((_DWORD *)this + v2 + 2) << 31) >> 31) & 0x9908B0DF;
  *(_DWORD *)((char *)this + v3 + 8) = v1;
  *((void *)this + 313) = v2;
  int v4 = ((v1 ^ (v1 >> 11)) << 7) & 0x9D2C5680 ^ v1 ^ (v1 >> 11);
  return (float)((float)((v4 << 15) & 0xEFC60000 ^ v4 ^ (((v4 << 15) & 0xEFC60000 ^ v4) >> 18)) * 2.3283e-10) + 0.0;
}

float CRandomGenerator::NormalRand(CRandomGenerator *this, float a2)
{
  unint64_t v2 = (char *)this + 8;
  unint64_t v3 = *((void *)this + 313);
  int v4 = *((_DWORD *)this + v3 + 2);
  do
  {
    unint64_t v5 = (v3 + 1) % 0x270;
    uint64_t v6 = 4 * v5;
    unsigned int v7 = *(_DWORD *)&v2[4 * ((v3 + 397) % 0x270)] ^ ((*(_DWORD *)&v2[4 * v5] & 0x7FFFFFFE | v4 & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)&v2[4 * v5] << 31) >> 31) & 0x9908B0DF;
    *(_DWORD *)&v2[4 * v3] = v7;
    unsigned int v8 = ((v7 ^ (v7 >> 11)) << 7) & 0x9D2C5680 ^ v7 ^ (v7 >> 11);
    unint64_t v3 = v5 - 623;
    if (v5 < 0x26F) {
      unint64_t v3 = v5 + 1;
    }
    int v4 = *(_DWORD *)&v2[4 * v3];
    unsigned int v9 = (v8 << 15) & 0xEFC60000 ^ v8;
    if (v5 >= 0xE3) {
      uint64_t v10 = -227;
    }
    else {
      uint64_t v10 = 397;
    }
    float v11 = (float)(v9 ^ (v9 >> 18));
    unsigned int v12 = *(_DWORD *)&v2[4 * v10 + 4 * v5] ^ ((v4 & 0x7FFFFFFE | *(_DWORD *)&v2[4 * v5] & 0x80000000) >> 1) ^ (v4 << 31 >> 31) & 0x9908B0DF;
    unsigned int v13 = ((v12 ^ (v12 >> 11)) << 7) & 0x9D2C5680 ^ v12 ^ (v12 >> 11);
    float v14 = (float)((v13 << 15) & 0xEFC60000 ^ v13 ^ (((v13 << 15) & 0xEFC60000 ^ v13) >> 18));
    float v15 = (float)((float)(v11 * 2.3283e-10) * 2.0) + -1.0;
    float v16 = (float)((float)((float)(v14 * 2.3283e-10) * 2.0) + -1.0)
        * (float)((float)((float)(v14 * 2.3283e-10) * 2.0) + -1.0);
    float v17 = v16 + (float)(v15 * v15);
    *(_DWORD *)&v2[v6] = v12;
  }
  while (v17 > 1.0 || v17 == 0.0);
  *((void *)this + 313) = v3;
  return (float)((float)(v15 * sqrtf((float)(logf(v16 + (float)(v15 * v15)) * -2.0) / v17)) * a2) + 0.0;
}

void GeomUtils::DistortRadialLiteInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (*(_DWORD *)(a1 + 16) == 2)
  {
    if (*(_DWORD *)(a1 + 20)) {
      operator new[]();
    }
    if (a6)
    {
      uint64_t v6 = "xqSorted.GetNumOfPoints() > 1";
      int v7 = 1381;
      unsigned int v8 = "Interp1SortedWithExtrap";
    }
    else
    {
      uint64_t v6 = "xq.GetNumOfPoints() > 0";
      int v7 = 1285;
      unsigned int v8 = "Interp1WithExtrap";
    }
    __assert_rtn(v8, "Algo.hpp", v7, v6);
  }
  __assert_rtn("DistortRadialLiteInternal", "GeomUtils.cpp", 540, "pts.Rows() == 2");
}

void sub_215F331F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  if (a27 && a29) {
    MEMORY[0x2166C5D70]();
  }
  if (a32 && a34) {
    MEMORY[0x2166C5D70]();
  }
  if (a37 && a39) {
    MEMORY[0x2166C5D70]();
  }
  *(void *)(v39 - 224) = a13;
  if (*(void *)(v39 - 216) && *(unsigned char *)(v39 - 200)) {
    MEMORY[0x2166C5D70]();
  }
  *(void *)(v39 - 184) = a14;
  if (*(void *)(v39 - 176))
  {
    if (*(unsigned char *)(v39 - 160)) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(exception_object);
}

void GeomUtils::DistortRadialLite<double>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
}

{
  GeomUtils::DistortRadialLiteInternal(a1, a2, a3, 1, a4, a5);
}

void GeomUtils::ToHomg(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(unsigned int *)(a1 + 20);
  *(void *)a2 = off_26C6875D0;
  if (v2) {
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = 3;
  *(_DWORD *)(a2 + 20) = 0;
  *(unsigned char *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 24 * v2;
  *(void *)a2 = &unk_26C687550;
  *(void *)(a2 + 8) = 0;
}

void MatrixNxPts<3u,double>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = off_26C6875D0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  JUMPOUT(0x2166C5D90);
}

uint64_t MatrixNxPts<3u,double>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = off_26C6875D0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

double *GeomUtils::ToNonHomg@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(unsigned int *)(a1 + 20);
  *(void *)a2 = off_26C6875D0;
  uint64_t v4 = (2 * v3);
  if (v4) {
    operator new[]();
  }
  uint64_t result = 0;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v3;
  *(unsigned char *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 16 * v3;
  *(void *)a2 = &unk_26C687530;
  *(void *)(a2 + 8) = 0;
  if (v3)
  {
    uint64_t v6 = *(float64x2_t **)(a1 + 8);
    uint64_t v7 = v4;
    unint64_t v8 = 8 * v3;
    if (v3 < 0x14)
    {
      LODWORD(v9) = 0;
      goto LABEL_57;
    }
    LODWORD(v9) = 0;
    uint64_t v10 = (v3 - 1);
    unint64_t v11 = v10 * 8 + 8;
    unint64_t v12 = v10 * 8 + 8 + v8;
    unsigned int v13 = &v6->f64[v10 + 1];
    float v14 = (char *)v6 + v7 * 8;
    unint64_t v15 = (unint64_t)&v6->f64[v10 + 1 + v7];
    float v16 = (char *)v6 + v8;
    float v17 = (char *)v6 + v12;
    if (v13) {
      BOOL v18 = (unint64_t)v6 >= v11;
    }
    else {
      BOOL v18 = 1;
    }
    char v19 = !v18;
    if (v15) {
      BOOL v20 = (unint64_t)v14 >= v11;
    }
    else {
      BOOL v20 = 1;
    }
    char v21 = !v20;
    if (v17) {
      BOOL v22 = (unint64_t)v16 >= v11;
    }
    else {
      BOOL v22 = 1;
    }
    char v23 = !v22;
    BOOL v25 = v8 < (unint64_t)v13 && (unint64_t)v6 < v12;
    BOOL v27 = v8 < v15 && (unint64_t)v14 < v12;
    BOOL v29 = v8 < (unint64_t)v17 && (unint64_t)v16 < v12;
    BOOL v30 = v8 >= v11 || v12 == 0;
    if (!v30 || (v19 & 1) != 0 || (v21 & 1) != 0 || (v23 & 1) != 0 || v25 || v27 || v29) {
      goto LABEL_57;
    }
    uint64_t v9 = v3 & 0xFFFFFFFE;
    double v31 = (float64x2_t *)((char *)v6 + 8 * v9);
    uint64_t v32 = 0;
    uint64_t v33 = v9;
    do
    {
      float64x2_t v34 = *(float64x2_t *)((char *)v6 + 8 * v4);
      *uint64_t v32 = vdivq_f64(*v6, v34);
      *(float64x2_t *)((char *)v32++ + 8 * v3) = vdivq_f64(*(float64x2_t *)((char *)v6++ + 8 * v3), v34);
      v33 -= 2;
    }
    while (v33);
    if (v9 != v3)
    {
      uint64_t result = (double *)(8 * (v3 & 0xFFFFFFFE));
      uint64_t v6 = v31;
LABEL_57:
      int v35 = v3 - v9;
      do
      {
        double *result = v6->f64[0] / v6->f64[v4];
        result[v3] = v6->f64[v3] / v6->f64[v4];
        ++result;
        uint64_t v6 = (float64x2_t *)((char *)v6 + 8);
        --v35;
      }
      while (v35);
    }
  }
  return result;
}

{
  uint64_t v3;
  uint64_t v4;
  double *result;
  float64x2_t *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  float64_t *v13;
  char *v14;
  unint64_t v15;
  char *v16;
  char *v17;
  BOOL v18;
  char v19;
  BOOL v20;
  char v21;
  BOOL v22;
  char v23;
  BOOL v25;
  BOOL v27;
  BOOL v29;
  BOOL v30;
  float64x2_t *v31;
  float64x2_t *v32;
  uint64_t v33;
  float64x2_t v34;
  int v35;

  uint64_t v3 = *(unsigned int *)(a1 + 20);
  *(void *)a2 = off_26C6875D0;
  uint64_t v4 = (2 * v3);
  if (v4) {
    operator new[]();
  }
  uint64_t result = 0;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v3;
  *(unsigned char *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 16 * v3;
  *(void *)a2 = &unk_26C687530;
  *(void *)(a2 + 8) = 0;
  if (v3)
  {
    uint64_t v6 = *(float64x2_t **)(a1 + 8);
    uint64_t v7 = v4;
    unint64_t v8 = 8 * v3;
    if (v3 < 0x14)
    {
      LODWORD(v9) = 0;
      goto LABEL_57;
    }
    LODWORD(v9) = 0;
    uint64_t v10 = (v3 - 1);
    unint64_t v11 = v10 * 8 + 8;
    unint64_t v12 = v10 * 8 + 8 + v8;
    unsigned int v13 = &v6->f64[v10 + 1];
    float v14 = (char *)v6 + v7 * 8;
    unint64_t v15 = (unint64_t)&v6->f64[v10 + 1 + v7];
    float v16 = (char *)v6 + v8;
    float v17 = (char *)v6 + v12;
    if (v13) {
      BOOL v18 = (unint64_t)v6 >= v11;
    }
    else {
      BOOL v18 = 1;
    }
    char v19 = !v18;
    if (v15) {
      BOOL v20 = (unint64_t)v14 >= v11;
    }
    else {
      BOOL v20 = 1;
    }
    char v21 = !v20;
    if (v17) {
      BOOL v22 = (unint64_t)v16 >= v11;
    }
    else {
      BOOL v22 = 1;
    }
    char v23 = !v22;
    BOOL v25 = v8 < (unint64_t)v13 && (unint64_t)v6 < v12;
    BOOL v27 = v8 < v15 && (unint64_t)v14 < v12;
    BOOL v29 = v8 < (unint64_t)v17 && (unint64_t)v16 < v12;
    BOOL v30 = v8 >= v11 || v12 == 0;
    if (!v30 || (v19 & 1) != 0 || (v21 & 1) != 0 || (v23 & 1) != 0 || v25 || v27 || v29) {
      goto LABEL_57;
    }
    uint64_t v9 = v3 & 0xFFFFFFFE;
    double v31 = (float64x2_t *)((char *)v6 + 8 * v9);
    uint64_t v32 = 0;
    uint64_t v33 = v9;
    do
    {
      float64x2_t v34 = *(float64x2_t *)((char *)v6 + 8 * v4);
      *uint64_t v32 = vdivq_f64(*v6, v34);
      *(float64x2_t *)((char *)v32++ + 8 * v3) = vdivq_f64(*(float64x2_t *)((char *)v6++ + 8 * v3), v34);
      v33 -= 2;
    }
    while (v33);
    if (v9 != v3)
    {
      uint64_t result = (double *)(8 * (v3 & 0xFFFFFFFE));
      uint64_t v6 = v31;
LABEL_57:
      int v35 = v3 - v9;
      do
      {
        double *result = v6->f64[0] / v6->f64[v4];
        result[v3] = v6->f64[v3] / v6->f64[v4];
        ++result;
        uint64_t v6 = (float64x2_t *)((char *)v6 + 8);
        --v35;
      }
      while (v35);
    }
  }
  return result;
}

void MatrixNxPts<2u,double>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = off_26C6875D0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  JUMPOUT(0x2166C5D90);
}

uint64_t MatrixNxPts<2u,double>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = off_26C6875D0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

void GeomUtils::ComputeHomography(uint64_t a1, uint64_t a2)
{
  v85[9] = *(double *)MEMORY[0x263EF8340];
  uint64_t v3 = *(unsigned int *)(a1 + 20);
  uint64_t v4 = *(double **)(a2 + 8);
  uint64_t v5 = *(unsigned int *)(a2 + 20);
  uint64_t v6 = 8 * v5;
  int v72 = 1;
  int v73 = v5;
  char v74 = 0;
  uint64_t v75 = 8 * v5;
  uint64_t v70 = &unk_26C6874F0;
  uint64_t v71 = v4;
  uint64_t v7 = &v4[v5];
  unsigned int v66 = 1;
  unsigned int v67 = v5;
  char v68 = 0;
  uint64_t v69 = 8 * v5;
  uint64_t v64 = &unk_26C6874F0;
  uint64_t v65 = v7;
  if ((int)v5 < 1)
  {
    double v15 = (double)(int)v5;
    double v40 = 0.0 / (double)(int)v5;
    double v41 = v40;
    goto LABEL_24;
  }
  unint64_t v8 = (unint64_t)&v4[(int)v5];
  uint64_t v9 = v4 + 1;
  if (v8 <= (unint64_t)(v4 + 1)) {
    uint64_t v10 = v4 + 1;
  }
  else {
    uint64_t v10 = &v4[(int)v5];
  }
  unint64_t v11 = ~(unint64_t)v4;
  unint64_t v12 = (unint64_t)v10 + ~(unint64_t)v4;
  if (v12 > 7)
  {
    uint64_t v16 = (v12 >> 3) + 1;
    double v13 = 0.0;
    uint64_t v17 = v16 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      double v13 = v13 + *(v9 - 1) + *v9;
      v9 += 2;
      v17 -= 2;
    }
    while (v17);
    if (v16 == (v16 & 0x3FFFFFFFFFFFFFFELL))
    {
LABEL_13:
      double v15 = (double)(int)v5;
      char v19 = (double *)(v8 + v6);
      BOOL v20 = &v4[(unint64_t)v6 / 8 + 1];
      if (v19 <= v20) {
        char v19 = v20;
      }
      unint64_t v21 = (unint64_t)v19 + v11 - v6;
      if (v21 >= 8)
      {
        uint64_t v24 = (v21 >> 3) + 1;
        double v22 = 0.0;
        uint64_t v25 = v24 & 0x3FFFFFFFFFFFFFFELL;
        do
        {
          double v22 = v22 + *(v20 - 1) + *v20;
          v20 += 2;
          v25 -= 2;
        }
        while (v25);
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFELL)) {
          goto LABEL_23;
        }
        char v23 = &v7[v24 & 0x3FFFFFFFFFFFFFFELL];
      }
      else
      {
        double v22 = 0.0;
        char v23 = v7;
      }
      unint64_t v26 = (unint64_t)&v7[(int)v5];
      do
      {
        double v27 = *v23++;
        double v22 = v22 + v27;
      }
      while ((unint64_t)v23 < v26);
LABEL_23:
      double v41 = v13 / v15;
      double v40 = v22 / v15;
LABEL_24:
      *(void *)&v85[0] = off_26C6875D0;
      if (!v5)
      {
        char v62 = 0;
        uint64_t v63 = 8 * v5;
        uint64_t v60 = 0;
        uint64_t v61 = 1;
        uint64_t v77 = 0;
        LOBYTE(v79) = 0;
        *(void *)&double v80 = 8 * v5;
        double v76 = COERCE_DOUBLE(off_26C6875D0);
        double v78 = 0.0;
        uint64_t v59 = off_26C6875D0;
        *(void *)&v85[0] = off_26C6875D0;
        if (!(v67 * v66))
        {
          HIDWORD(v61) = v67;
          char v62 = 0;
          uint64_t v63 = 8 * v66 * (unint64_t)v67;
          uint64_t v59 = (uint64_t (**)())&unk_26C6874F0;
          uint64_t v60 = 0;
          LODWORD(v61) = 1;
          *(void *)&v85[0] = off_26C6875D0;
          if (!v67)
          {
            double v28 = 0.0 / v15;
            double v29 = 0.0 / (double)0;
            v85[0] = 1.0 / v28;
            v85[1] = 0.0;
            v85[2] = -v41 / v28;
            v85[3] = 0.0;
            v85[4] = 1.0 / v29;
            v85[5] = -v40 / v29;
            v85[6] = 0.0;
            v85[7] = 0.0;
            v85[8] = 1.0;
            double v76 = v28;
            uint64_t v77 = 0;
            double v78 = v41;
            uint64_t v79 = 0;
            double v80 = v29;
            double v81 = v40;
            uint64_t v82 = 0;
            uint64_t v83 = 0;
            uint64_t v84 = 0x3FF0000000000000;
            uint64_t v59 = off_26C6875D0;
            uint64_t v60 = v85;
            uint64_t v61 = 0x300000003;
            char v62 = 0;
            uint64_t v63 = 72;
            int8x16_t v54 = off_26C6875D0;
            BOOL v55 = (uint64_t (***)())&v76;
            uint64_t v56 = 0x300000003;
            char v57 = 0;
            uint64_t v58 = 72;
            uint64_t v30 = *(unsigned int *)(a2 + 20);
            double v42 = off_26C6875D0;
            if (v30) {
              operator new[]();
            }
            uint64_t v43 = 0;
            int v44 = 3;
            int v45 = 0;
            char v46 = 0;
            uint64_t v47 = 24 * v30;
            Matrix<double>::MultAxBToC((uint64_t)&v59, a2, (uint64_t)&v42);
            int v50 = 3;
            int v51 = v45;
            char v52 = v46;
            uint64_t v53 = v47;
            double v48 = &unk_26C687550;
            uint64_t v49 = v43;
            double v42 = off_26C6875D0;
            if (!(18 * v3))
            {
              uint64_t v31 = 0;
              uint64_t v43 = 0;
              int v44 = 2 * v3;
              int v45 = 9;
              char v46 = 0;
              uint64_t v47 = 72 * (2 * v3);
              if (v3)
              {
                uint64_t v32 = 0;
                uint64_t v33 = v49;
                uint64_t v34 = *(void *)(a1 + 8);
                uint64_t v35 = v49 + 8 * v3;
                do
                {
                  double v36 = *(double *)(v34 + 8 * v32);
                  double v37 = *(double *)(v34 + 8 * v3 + 8 * v32);
                  double v38 = *(double *)(v33 + 8 * v32);
                  double v39 = *(double *)(v35 + 8 * v32);
                  *(double *)uint64_t v31 = v36;
                  *(double *)(v31 + 8) = v37;
                  *(void *)(v31 + 16) = 0x3FF0000000000000;
                  *(void *)(v31 + 24) = 0;
                  *(void *)(v31 + 32) = 0;
                  *(void *)(v31 + 40) = 0;
                  *(double *)(v31 + 48) = -(v38 * v36);
                  *(double *)(v31 + 56) = -(v38 * v37);
                  *(double *)(v31 + 64) = -v38;
                  *(void *)(v31 + 80) = 0;
                  *(void *)(v31 + 88) = 0;
                  *(void *)(v31 + 72) = 0;
                  *(double *)(v31 + 96) = v36;
                  *(double *)(v31 + 104) = v37;
                  *(void *)(v31 + 112) = 0x3FF0000000000000;
                  *(double *)(v31 + 120) = -(v39 * v36);
                  *(double *)(v31 + 128) = -(v39 * v37);
                  *(double *)(v31 + 136) = -v39;
                  ++v32;
                  v31 += 144;
                }
                while (v3 != v32);
                if (v3 > 4) {
                  Matrix<double>::Transpose();
                }
              }
              __assert_rtn("Svd0LowestSingularVector", "Matrix.hpp", 2414, "false");
            }
            operator new[]();
          }
          operator new[]();
        }
        operator new[]();
      }
      operator new[]();
    }
    float v14 = &v4[v16 & 0x3FFFFFFFFFFFFFFELL];
  }
  else
  {
    double v13 = 0.0;
    float v14 = v4;
  }
  do
  {
    double v18 = *v14++;
    double v13 = v13 + v18;
  }
  while (v14 < &v4[(int)v5]);
  goto LABEL_13;
}

{
  uint64_t v2;
  uint64_t v3;
  void v4[2];
  int v5;
  int v6;
  char v7;
  uint64_t v8;
  void v9[2];
  int v10;
  int v11;
  char v12;
  uint64_t v13;

  uint64_t v2 = *(unsigned int *)(a2 + 20);
  v9[0] = off_26C6875D0;
  if (!v2)
  {
    uint64_t v10 = 3;
    unint64_t v11 = 0;
    unint64_t v12 = 0;
    double v13 = 24 * v2;
    v9[0] = &unk_26C687550;
    v9[1] = 0;
    uint64_t v3 = *(unsigned int *)(a1 + 20);
    v4[0] = off_26C6875D0;
    if (!v3)
    {
      uint64_t v5 = 3;
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      unint64_t v8 = 24 * v3;
      v4[0] = &unk_26C687550;
      v4[1] = 0;
      GeomUtils::ComputeHomography((uint64_t)v4, (uint64_t)v9);
    }
    operator new[]();
  }
  operator new[]();
}

void sub_215F3486C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t (**a29)(),uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t (**a44)(),uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t (**a49)(),uint64_t a50,uint64_t a51,char a52)
{
  if (a25 && a27) {
    MEMORY[0x2166C5D70]();
  }
  a29 = off_26C6875D0;
  if (a30 && a32) {
    MEMORY[0x2166C5D70]();
  }
  if (a35 && a37) {
    MEMORY[0x2166C5D70]();
  }
  if (a40 && a42) {
    MEMORY[0x2166C5D70]();
  }
  a44 = off_26C6875D0;
  if (a45 && a47) {
    MEMORY[0x2166C5D70]();
  }
  a49 = off_26C6875D0;
  if (a50)
  {
    if (a52) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(a1);
}

void Matrix<double>::MultAxBToC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  unsigned int v7 = *(_DWORD *)(a1 + 20);
  if (v6 == 1 && v7 == 1)
  {
    unsigned int v6 = *(_DWORD *)(a2 + 16);
    unsigned int v7 = *(_DWORD *)(a2 + 20);
    if (v7 * v6) {
      operator new[]();
    }
    size_t v12 = 8 * v6 * (unint64_t)v7;
    double v13 = *(void **)(a3 + 8);
    if (*(void *)(a3 + 32) < v12)
    {
      if (v13 && *(unsigned char *)(a3 + 24)) {
        MEMORY[0x2166C5D70]();
      }
      operator new[]();
    }
    goto LABEL_29;
  }
  int v10 = *(_DWORD *)(a2 + 16);
  int v9 = *(_DWORD *)(a2 + 20);
  if (v9 == 1 && v10 == 1)
  {
    if (v7 * v6) {
      operator new[]();
    }
    size_t v12 = 8 * v6 * (unint64_t)v7;
    double v13 = *(void **)(a3 + 8);
    if (*(void *)(a3 + 32) < v12)
    {
      if (v13 && *(unsigned char *)(a3 + 24)) {
        MEMORY[0x2166C5D70]();
      }
      operator new[]();
    }
LABEL_29:
    *(_DWORD *)(a3 + 16) = v6;
    *(_DWORD *)(a3 + 20) = v7;
    memcpy(v13, 0, v12);
    goto LABEL_30;
  }
  if (v7 != v10) {
    __assert_rtn("MultAxBToC", "Matrix.hpp", 1596, "m_cols == B.Rows() && \"Input dimensions not legal\"");
  }
  if (v6 != *(_DWORD *)(a3 + 16) || v9 != *(_DWORD *)(a3 + 20)) {
    __assert_rtn("MultAxBToC", "Matrix.hpp", 1597, "m_rows == C->Rows() && B.Cols() == C->Cols() && \"Output dimensions not legal\"");
  }
LABEL_30:
  uint64_t v14 = *(unsigned int *)(a1 + 16);
  if ((int)v14 >= 1)
  {
    uint64_t v15 = *(unsigned int *)(a3 + 20);
    if ((int)v15 >= 1)
    {
      uint64_t v16 = *(char **)(a3 + 8);
      unint64_t v17 = *(unsigned int *)(a1 + 20);
      if ((int)v17 <= 0)
      {
        bzero(v16, 8 * v14 * (unint64_t)v15);
      }
      else
      {
        double v18 = *(double **)(a1 + 8);
        char v19 = *(float64x2_t **)(a2 + 8);
        if (v17 > 3)
        {
          if (v15 == 1)
          {
            uint64_t v26 = v17 & 0x7FFFFFFC;
            unint64_t v27 = v17 - (v17 & 0xFFFFFFFC);
            if (v17 == (v17 & 0xFFFFFFFC))
            {
              uint64_t v28 = 0;
              double v29 = v19 + 1;
              uint64_t v30 = (float64x2_t *)(v18 + 2);
              do
              {
                double v31 = 0.0;
                uint64_t v32 = v30;
                uint64_t v33 = v29;
                unint64_t v34 = v17;
                do
                {
                  float64x2_t v35 = vmulq_f64(v32[-1], v33[-1]);
                  float64x2_t v36 = vmulq_f64(*v32, *v33);
                  double v31 = v31 + v35.f64[0] + v35.f64[1] + v36.f64[0] + v36.f64[1];
                  v33 += 2 * v15;
                  v32 += 2;
                  v34 -= 4;
                }
                while (v34);
                *(double *)&v16[8 * v28 * v15] = v31;
                ++v28;
                uint64_t v30 = (float64x2_t *)((char *)v30 + 8 * v17);
              }
              while (v28 != v14);
            }
            else
            {
              uint64_t v45 = 0;
              char v46 = (float64x2_t *)(v18 + 2);
              uint64_t v47 = 8 * v17;
              unint64_t v48 = v17 >> 2;
              f64 = v19[2 * (*(_DWORD *)(a1 + 20) >> 2)].f64;
              int v50 = &v18[4 * v48];
              do
              {
                double v51 = 0.0;
                char v52 = v46;
                uint64_t v53 = v19 + 1;
                uint64_t v54 = v26;
                do
                {
                  float64x2_t v55 = vmulq_f64(v52[-1], v53[-1]);
                  float64x2_t v56 = vmulq_f64(*v52, *v53);
                  double v51 = v51 + v55.f64[0] + v55.f64[1] + v56.f64[0] + v56.f64[1];
                  v53 += 2 * v15;
                  v52 += 2;
                  v54 -= 4;
                }
                while (v54);
                char v57 = v50;
                uint64_t v58 = f64;
                unint64_t v59 = v27;
                do
                {
                  double v60 = *v57++;
                  double v51 = v51 + v60 * *v58;
                  v58 += v15;
                  --v59;
                }
                while (v59);
                *(double *)&v16[8 * v45 * v15] = v51;
                ++v45;
                char v46 = (float64x2_t *)((char *)v46 + v47);
                int v50 = (double *)((char *)v50 + v47);
              }
              while (v45 != v14);
            }
          }
          else
          {
            for (uint64_t i = 0; i != v14; ++i)
            {
              uint64_t v38 = 0;
              double v39 = (double *)v19;
              do
              {
                double v40 = 0.0;
                double v41 = v18;
                double v42 = v39;
                unint64_t v43 = v17;
                do
                {
                  double v44 = *v41++;
                  double v40 = v40 + v44 * *v42;
                  v42 += v15;
                  --v43;
                }
                while (v43);
                *(double *)&v16[8 * i * v15 + 8 * v38++] = v40;
                ++v39;
              }
              while (v38 != v15);
              v18 += v17;
            }
          }
        }
        else
        {
          uint64_t v20 = 0;
          uint64_t v21 = 8 * v15;
          double v22 = &v19[v15];
          do
          {
            unint64_t v23 = 0;
            uint64_t v24 = &v18[v20 * v17];
            do
            {
              double v25 = *v24 * v19->f64[v23 / 8] + 0.0;
              if (v17 != 1)
              {
                double v25 = v25 + v24[1] * v19->f64[(unint64_t)v21 / 8 + v23 / 8];
                if (v17 != 2) {
                  double v25 = v25 + v24[2] * v22->f64[v23 / 8];
                }
              }
              *(double *)&v16[v23] = v25;
              v23 += 8;
            }
            while (v21 != v23);
            ++v20;
            v16 += v21;
          }
          while (v20 != v14);
        }
      }
    }
  }
}

void sub_215F35124(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Matrix<double>::~Matrix((uint64_t)va);
  _Unwind_Resume(a1);
}

void Matrix<double>::Transpose()
{
}

void sub_215F35498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_215F356BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a15)
  {
    if (a17) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(exception_object);
}

void GeomUtils::homography2d(void *a1@<X8>)
{
  uint64_t v10 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v6 = 0u;
  long long v7 = 0u;
  uint64_t v5 = 0;
  long long v3 = 0u;
  long long v4 = 0u;
  long long v1 = 0u;
  long long v2 = 0u;
  *a1 = off_26C6875D0;
  operator new[]();
}

void sub_215F359B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  if (a15 && a17) {
    MEMORY[0x2166C5D70]();
  }
  if (a20 && a22) {
    MEMORY[0x2166C5D70]();
  }
  if (a25 && a27) {
    MEMORY[0x2166C5D70]();
  }
  *(void *)uint64_t v27 = v28;
  if (*(void *)(v27 + 8))
  {
    if (*(unsigned char *)(v27 + 24))
    {
      MEMORY[0x2166C5D70]();
      *(void *)(v27 + 8) = 0;
      *(void *)(v27 + 32) = 0;
      *(unsigned char *)(v27 + 24) = 0;
    }
  }
  *(void *)(v27 + 16) = 0;
  _Unwind_Resume(exception_object);
}

void GeomUtils::ransacComputeHomography(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 20)) {
    operator new[]();
  }
  if (*(_DWORD *)(a2 + 20)) {
    operator new[]();
  }
  Algo::Normalize2DPts();
}

void sub_215F36E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
}

uint64_t GeomUtils::ransacFitPlane(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, unsigned int *a5, _DWORD *a6)
{
  uint64_t result = Algo::RansacPlane(a1, 3, 10, 50, 1u, a4, a5, a6);
  unsigned int v11 = *a5;
  if (*a5 > 2)
  {
    if (v11 == 3) {
      uint64_t v12 = 4;
    }
    else {
      uint64_t v12 = v11;
    }
    if (4 * v12) {
      operator new[]();
    }
    if (!v11) {
      goto LABEL_9;
    }
    int v13 = *(_DWORD *)(a1 + 16);
    if (v13)
    {
      uint64_t v14 = *(unsigned int *)(a1 + 20);
      if (v13 == 1)
      {
        uint64_t v20 = **(unsigned int **)(a4 + 8);
        if (v14 > v20) {
          MEMORY[0] = *(void *)(*(void *)(a1 + 8) + 8 * v20);
        }
      }
      else
      {
        if (v13 != 2)
        {
          uint64_t v15 = 0;
          do
          {
            uint64_t v16 = *(unsigned int *)(*(void *)(a4 + 8) + v15);
            if (v14 <= v16 || 4 * v12 == v15) {
              goto LABEL_26;
            }
            uint64_t v18 = 8 * v16;
            char v19 = (void *)((8 * v15) & 0x7FFFFFFE0);
            void *v19 = *(void *)(*(void *)(a1 + 8) + v18);
            v19[1] = *(void *)(*(void *)(a1 + 8) + v18 + 8 * v14);
            v19[2] = *(void *)(*(void *)(a1 + 8) + v18 + 8 * (2 * v14));
            v19[3] = 0x3FF0000000000000;
            v15 += 4;
          }
          while (4 * v11 != v15);
          if (v11 == 3)
          {
            if (v12 <= 3) {
              __assert_rtn("operator()", "Matrix.hpp", 120, "row < m_rows && col < m_cols");
            }
            MEMORY[0x60] = 0u;
            MEMORY[0x70] = 0u;
          }
LABEL_9:
          __assert_rtn("Svd0LowestSingularVector", "Matrix.hpp", 2414, "false");
        }
        uint64_t v21 = **(unsigned int **)(a4 + 8);
        if (v14 > v21)
        {
          double v22 = (void *)(*(void *)(a1 + 8) + 8 * v21);
          MEMORY[0] = *v22;
          MEMORY[8] = v22[v14];
        }
      }
    }
LABEL_26:
    __assert_rtn("operator()", "Matrix.hpp", 120, "row < m_rows && col < m_cols");
  }
  *a5 = 0;
  *a3 = 0x4197D78400000000;
  return result;
}

void sub_215F3716C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  Matrix<double>::~Matrix((uint64_t)va);
  _Unwind_Resume(a1);
}

void GeomUtils::estimateBestRotMat()
{
}

void sub_215F37264(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a11 && a13) {
    MEMORY[0x2166C5D70]();
  }
  if (a16 && a18) {
    MEMORY[0x2166C5D70]();
  }
  *(void *)(v19 - 72) = v18;
  if (*(void *)(v19 - 64))
  {
    if (*(unsigned char *)(v19 - 48)) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(exception_object);
}

void GeomUtils::estimatePlanePosition()
{
}

void sub_215F378A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  if (a25 && a27) {
    MEMORY[0x2166C5D70]();
  }
  if (a30 && a32) {
    MEMORY[0x2166C5D70]();
  }
  if (a35 && a37) {
    MEMORY[0x2166C5D70]();
  }
  *(void *)(v37 - 224) = off_26C6875D0;
  if (*(void *)(v37 - 216))
  {
    if (*(unsigned char *)(v37 - 200)) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t GeomUtils::CalcRotTrans(long long *a1, double *a2, double *a3, double a4, double a5, float64x2_t a6, float64x2_t a7, float64x2_t a8, float64x2_t a9, __n128 a10, float64x2_t a11, uint64_t a12, double *a13, float64x2_t *a14)
{
  long long v89 = 0u;
  float64x2_t v90 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v19 = a1[1];
  long long v92 = *a1;
  long long v93 = v19;
  int8x16_t v20 = (int8x16_t)a1[3];
  long long v94 = a1[2];
  v21.i64[1] = *((void *)&v94 + 1);
  int8x16_t v95 = v20;
  v20.i64[0] = *((void *)&v92 + 1);
  v21.i64[0] = v93;
  *(void *)&a7.f64[0] = v95.i64[1];
  *(void *)&a6.f64[0] = v95.i64[0];
  a8.f64[0] = *((float64_t *)&v93 + 1);
  a9.f64[0] = *((float64_t *)&v94 + 1);
  *((void *)&v92 + 1) = *((void *)&v93 + 1);
  *(void *)&long long v93 = v95.i64[0];
  v95.i64[0] = v21.i64[0];
  v95.i64[1] = *((void *)&v94 + 1);
  double v91 = 0.0;
  double v86 = 0.0;
  memset(v81, 0, sizeof(v81));
  uint64_t v96 = *((void *)a1 + 8);
  *((void *)&v93 + 1) = v20.i64[0];
  *((void *)&v94 + 1) = *(void *)&a7.f64[0];
  svd_os(3, (double *)&v92, (double *)&v87, v81, (double *)&v82, v20, v21, a6, a7, a8, a9, a10, a11);
  _Q0 = v90;
  _Q3.i64[0] = 0;
  double v24 = *(double *)&v87 * 0.0 + 0.0;
  *(double *)v25.i64 = vmlad_n_f64(*((double *)&v88 + 1) + v24, 0.0, v90.f64[0]);
  double v26 = vmlad_n_f64(0.0 - *(double *)&v87 + *((double *)&v88 + 1) * 0.0, 0.0, v90.f64[0]);
  double v27 = v90.f64[0] + v24 + *((double *)&v88 + 1) * 0.0;
  __asm
  {
    FMLA            D10, D3, V0.D[1]
    FMLA            D11, D3, V0.D[1]
  }
  double v80 = v90.f64[1];
  double v33 = v90.f64[1] + *((double *)&v87 + 1) * 0.0 + 0.0 + *(double *)&v89 * 0.0;
  double v34 = *(double *)&v88 * 0.0 + 0.0;
  double v35 = v91;
  double v36 = v34 + *((double *)&v89 + 1) * 0.0 + v91;
  *(double *)v14.i64 = *(double *)v25.i64 * *(double *)&v82 + 0.0 + v26 * *((double *)&v82 + 1) + v27 * *(double *)&v83;
  double v37 = _D10 * *((double *)&v83 + 1) + 0.0 + _D11 * *(double *)&v84 + v33 * *((double *)&v84 + 1);
  if ((*(void *)&v37 ^ v14.i64[0]) < 0
    || (double v38 = v34 + *((double *)&v89 + 1) + v91 * 0.0,
        double v39 = 0.0 - *(double *)&v88 + *((double *)&v89 + 1) * 0.0 + v91 * 0.0,
        ((COERCE_UNSIGNED_INT64(v38 * *(double *)&v85 + 0.0 + v39 * *((double *)&v85 + 1) + v36 * v86) ^ v14.i64[0]) & 0x8000000000000000) != 0))
  {
    double v55 = vmlad_n_f64(v24 - *((double *)&v88 + 1), 0.0, v90.f64[0]);
    double v56 = vmlad_n_f64(*(double *)&v87 + 0.0 + *((double *)&v88 + 1) * 0.0, 0.0, v90.f64[0]);
    __asm
    {
      FMLA            D26, D3, V0.D[1]
      FMLA            D25, D3, V0.D[1]
    }
    double v59 = v34 - *((double *)&v89 + 1) + v91 * 0.0;
    double v60 = *(double *)&v88 + 0.0 + *((double *)&v89 + 1) * 0.0 + v91 * 0.0;
    *(double *)v25.i64 = v55 * *(double *)&v82 + 0.0 + v56 * *((double *)&v82 + 1) + v27 * *(double *)&v83;
    double v61 = v55 * *((double *)&v83 + 1) + 0.0 + v56 * *(double *)&v84 + v27 * *((double *)&v84 + 1);
    double v62 = v55 * *(double *)&v85 + 0.0 + v56 * *((double *)&v85 + 1) + v27 * v86;
    double v63 = _D26 * *(double *)&v82 + 0.0 + _D25 * *((double *)&v82 + 1) + v33 * *(double *)&v83;
    double v64 = _D26 * *((double *)&v83 + 1) + 0.0 + _D25 * *(double *)&v84 + v33 * *((double *)&v84 + 1);
    double v65 = _D26 * *(double *)&v85 + 0.0 + _D25 * *((double *)&v85 + 1) + v33 * v86;
    double v66 = v59 * *(double *)&v82 + 0.0 + v60 * *((double *)&v82 + 1) + v36 * *(double *)&v83;
    double v67 = v59 * *((double *)&v83 + 1) + 0.0 + v60 * *(double *)&v84 + v36 * *((double *)&v84 + 1);
    double v68 = v59 * *(double *)&v85 + 0.0 + v60 * *((double *)&v85 + 1) + v36 * v86;
    _Q3.i64[0] = 1.0;
    v69.f64[0] = NAN;
    v69.f64[1] = NAN;
    double v70 = *(double *)vbslq_s8((int8x16_t)vnegq_f64(v69), _Q3, v25).i64;
    double v46 = *(double *)v25.i64 * v70;
    double v47 = v70 * v61;
    double v48 = v70 * v62;
    double v49 = v63 * v70;
    double v50 = v70 * v64;
    double v51 = v70 * v65;
    double v52 = v66 * v70;
    double v53 = v70 * v67;
    double v54 = v70 * v68;
  }
  else
  {
    double v40 = v38 * *(double *)&v85 + 0.0 + v39 * *((double *)&v85 + 1) + v36 * v86;
    double v41 = _D10 * *(double *)&v85 + 0.0 + _D11 * *((double *)&v85 + 1) + v33 * v86;
    double v42 = v38 * *(double *)&v82 + 0.0 + v39 * *((double *)&v82 + 1) + v36 * *(double *)&v83;
    double v43 = v38 * *((double *)&v83 + 1) + 0.0 + v39 * *(double *)&v84 + v36 * *((double *)&v84 + 1);
    _Q3.i64[0] = 1.0;
    v44.f64[0] = NAN;
    v44.f64[1] = NAN;
    double v45 = *(double *)vbslq_s8((int8x16_t)vnegq_f64(v44), _Q3, v14).i64;
    double v46 = *(double *)v14.i64 * v45;
    double v47 = v45 * (*(double *)v25.i64 * *((double *)&v83 + 1) + 0.0 + v26 * *(double *)&v84 + v27 * *((double *)&v84 + 1));
    double v48 = v45 * (*(double *)v25.i64 * *(double *)&v85 + 0.0 + v26 * *((double *)&v85 + 1) + v27 * v86);
    double v49 = (_D10 * *(double *)&v82 + 0.0 + _D11 * *((double *)&v82 + 1) + v33 * *(double *)&v83) * v45;
    double v50 = v45 * v37;
    double v51 = v45 * v41;
    double v52 = v42 * v45;
    double v53 = v45 * v43;
    double v54 = v45 * v40;
  }
  *a13 = v46;
  a13[1] = v47;
  a13[2] = v48;
  a13[3] = v49;
  a13[4] = v50;
  a13[5] = v51;
  a13[6] = v52;
  a13[7] = v53;
  a13[8] = v54;
  double v71 = *a3 - *a2;
  double v72 = a3[1] - a2[1];
  double v73 = a3[2] - a2[2];
  double v74 = sqrt(v71 * v71 + 0.0 + v72 * v72 + v73 * v73);
  _NF = v71 / v74 * _Q0.f64[0] + 0.0 + v72 / v74 * v80 + v73 / v74 * v35 < 0.0;
  int8x16_t v76 = (int8x16_t)vnegq_f64(_Q0);
  if (_NF) {
    double v35 = -v35;
  }
  int32x2_t v77 = vdup_n_s32(_NF);
  v78.i64[0] = v77.u32[0];
  v78.i64[1] = v77.u32[1];
  *a14 = vmulq_n_f64((float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v78, 0x3FuLL)), v76, (int8x16_t)_Q0), v74);
  a14[1].f64[0] = v74 * v35;
  return 0;
}

char *GeomUtils::homogDist2d(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5, double a6)
{
  uint64_t v102 = 3;
  char v103 = 0;
  unint64_t v104 = 0;
  uint64_t v100 = (uint64_t (**)())&unk_26C687550;
  double v101 = 0;
  size_t v99 = 0;
  uint64_t v96 = 0;
  uint64_t v97 = 0;
  int8x16_t v95 = off_26C6875D0;
  char v98 = 0;
  unsigned int v9 = *(_DWORD *)(a1 + 16);
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  float64x2_t v90 = off_26C6875D0;
  if (v10 * v9) {
    operator new[]();
  }
  __src = 0;
  unint64_t v92 = __PAIR64__(v10, v9);
  char v93 = 0;
  unint64_t v94 = 8 * v9 * (unint64_t)v10;
  Matrix<double>::MultAxBToC(a1, a2, (uint64_t)&v90);
  size_t v11 = 8 * v92 * (unint64_t)HIDWORD(v92);
  if (v99 < v11)
  {
    if (v96)
    {
      if (v98) {
        MEMORY[0x2166C5D70](v96, 0x1000C8000313F17);
      }
    }
    operator new[]();
  }
  uint64_t v97 = v92;
  memcpy(v96, __src, v11);
  float64x2_t v90 = off_26C6875D0;
  if (__src && v93) {
    MEMORY[0x2166C5D70]();
  }
  float64x2_t v90 = off_26C6875D0;
  if (HIDWORD(v97)) {
    operator new[]();
  }
  unint64_t v92 = 1;
  char v93 = 0;
  unint64_t v94 = 0;
  float64x2_t v90 = (uint64_t (**)())&unk_26C6874F0;
  __src = 0;
  uint64_t v12 = *(unsigned int *)(a3 + 20);
  uint64_t v13 = (2 * v12);
  if (v13) {
    operator new[]();
  }
  int8x16_t v14 = 0;
  if (v12)
  {
    uint64_t v15 = *(float64x2_t **)(a3 + 8);
    uint64_t v16 = v13;
    unint64_t v17 = 8 * v12;
    if (v12 >= 0x14)
    {
      LODWORD(v18) = 0;
      uint64_t v39 = (v12 - 1);
      unint64_t v40 = v39 * 8 + 8;
      unint64_t v41 = v39 * 8 + 8 + v17;
      double v42 = &v15->f64[v39 + 1];
      double v43 = (char *)v15 + v16 * 8;
      unint64_t v44 = (unint64_t)&v15->f64[v39 + 1 + v16];
      double v45 = (char *)v15 + v17;
      double v46 = (char *)v15 + v41;
      if (v42) {
        BOOL v47 = (unint64_t)v15 >= v40;
      }
      else {
        BOOL v47 = 1;
      }
      char v48 = !v47;
      if (v44) {
        BOOL v49 = (unint64_t)v43 >= v40;
      }
      else {
        BOOL v49 = 1;
      }
      char v50 = !v49;
      if (v46) {
        BOOL v51 = (unint64_t)v45 >= v40;
      }
      else {
        BOOL v51 = 1;
      }
      char v52 = !v51;
      BOOL v54 = v17 < (unint64_t)v42 && (unint64_t)v15 < v41;
      BOOL v56 = v17 < v44 && (unint64_t)v43 < v41;
      BOOL v58 = v17 < (unint64_t)v46 && (unint64_t)v45 < v41;
      BOOL v59 = v17 >= v40 || v41 == 0;
      if (v59 && (v48 & 1) == 0 && (v50 & 1) == 0 && (v52 & 1) == 0 && !v54 && !v56 && !v58)
      {
        uint64_t v18 = v12 & 0xFFFFFFFE;
        double v60 = (float64x2_t *)((char *)v15 + 8 * v18);
        double v61 = 0;
        uint64_t v62 = v18;
        do
        {
          float64x2_t v63 = *(float64x2_t *)((char *)v15 + 8 * v13);
          float64x2_t *v61 = vdivq_f64(*v15, v63);
          *(float64x2_t *)((char *)v61++ + 8 * v12) = vdivq_f64(*(float64x2_t *)((char *)v15++ + 8 * v12), v63);
          v62 -= 2;
        }
        while (v62);
        if (v18 == v12) {
LABEL_20:
        }
          operator new[]();
        int8x16_t v14 = (double *)(8 * (v12 & 0xFFFFFFFE));
        uint64_t v15 = v60;
      }
    }
    else
    {
      LODWORD(v18) = 0;
    }
    int v19 = v12 - v18;
    do
    {
      double *v14 = v15->f64[0] / v15->f64[v13];
      v14[v12] = v15->f64[v12] / v15->f64[v13];
      ++v14;
      uint64_t v15 = (float64x2_t *)((char *)v15 + 8);
      --v19;
    }
    while (v19);
    goto LABEL_20;
  }
  if (v104 < 24 * v12)
  {
    if (v101 && v103) {
      MEMORY[0x2166C5D70]();
    }
    operator new[]();
  }
  uint64_t v102 = 3;
  memcpy(v101, 0, 24 * v12);
  uint64_t v20 = HIDWORD(v97);
  uint64_t v21 = (2 * HIDWORD(v97));
  if (v21) {
    operator new[]();
  }
  double v22 = 0;
  if (HIDWORD(v97))
  {
    unint64_t v23 = v96;
    uint64_t v24 = v21;
    unint64_t v25 = 8 * HIDWORD(v97);
    if (HIDWORD(v97) >= 0x14)
    {
      LODWORD(v26) = 0;
      uint64_t v64 = (HIDWORD(v97) - 1);
      unint64_t v65 = v64 * 8 + 8;
      unint64_t v66 = v64 * 8 + 8 + v25;
      double v67 = (char *)&v96->f64[v64 + 1];
      double v68 = (char *)v96 + v24 * 8;
      float64x2_t v69 = (char *)&v96->f64[v64 + 1 + v24];
      double v70 = (char *)v96 + v25;
      double v71 = (char *)v96 + v66;
      if (v67) {
        BOOL v72 = (unint64_t)v96 >= v65;
      }
      else {
        BOOL v72 = 1;
      }
      char v73 = !v72;
      if (v69) {
        BOOL v74 = (unint64_t)v68 >= v65;
      }
      else {
        BOOL v74 = 1;
      }
      char v75 = !v74;
      if (v71) {
        BOOL v76 = (unint64_t)v70 >= v65;
      }
      else {
        BOOL v76 = 1;
      }
      char v77 = !v76;
      BOOL v79 = v25 < (unint64_t)v67 && (unint64_t)v96 < v66;
      BOOL v81 = v25 < (unint64_t)v69 && (unint64_t)v68 < v66;
      BOOL v83 = v25 < (unint64_t)v71 && (unint64_t)v70 < v66;
      BOOL v84 = v25 >= v65 || v66 == 0;
      if (v84 && (v73 & 1) == 0 && (v75 & 1) == 0 && (v77 & 1) == 0 && !v79 && !v81 && !v83)
      {
        uint64_t v26 = HIDWORD(v97) & 0xFFFFFFFE;
        long long v85 = (float64x2_t *)((char *)v96 + 8 * v26);
        double v86 = 0;
        uint64_t v87 = v26;
        do
        {
          float64x2_t v88 = *(float64x2_t *)((char *)v23 + 8 * v21);
          *double v86 = vdivq_f64(*v23, v88);
          *(float64x2_t *)((char *)v86++ + 8 * v20) = vdivq_f64(*(float64x2_t *)((char *)v23++ + 8 * v20), v88);
          v87 -= 2;
        }
        while (v87);
        if (v26 == v20) {
LABEL_33:
        }
          operator new[]();
        double v22 = (double *)(8 * (v20 & 0xFFFFFFFE));
        unint64_t v23 = v85;
      }
    }
    else
    {
      LODWORD(v26) = 0;
    }
    int v27 = v20 - v26;
    do
    {
      double *v22 = v23->f64[0] / v23->f64[v21];
      v22[v20] = v23->f64[v20] / v23->f64[v21];
      ++v22;
      unint64_t v23 = (float64x2_t *)((char *)v23 + 8);
      --v27;
    }
    while (v27);
    goto LABEL_33;
  }
  uint64_t v97 = 3;
  memcpy(v96, 0, 24 * v20);
  int v28 = HIDWORD(v97);
  if (HIDWORD(v97))
  {
    unint64_t v29 = 0;
    unsigned int v30 = 0;
    double v31 = "row < m_rows && col < m_cols";
    while (v102 && v29 < HIDWORD(v102) && v97)
    {
      int v32 = 120;
      if (v102 < 2 || v97 == 1 || v102 < 3 || v97 < 3) {
        goto LABEL_163;
      }
      if (v29 >= (HIDWORD(v92) * v92)) {
        goto LABEL_48;
      }
      double v33 = (double *)&v101[8 * v29];
      double v34 = &v96->f64[v29];
      double v35 = v33[HIDWORD(v102)] - v34[v28];
      double v36 = v35 * v35 + (*v33 - *v34) * (*v33 - *v34);
      double v37 = *(double *)&v101[8 * (2 * HIDWORD(v102)) + 8 * v29] - v96->f64[(2 * v28) + v29];
      *((double *)__src + v29) = v36 + v37 * v37;
      if (*((double *)__src + v29) < a6)
      {
        if (*(_DWORD *)(a4 + 20) * *(_DWORD *)(a4 + 16) <= v30)
        {
LABEL_48:
          int v32 = 132;
          double v31 = "index < m_rows * m_cols";
          goto LABEL_163;
        }
        *(_DWORD *)(*(void *)(a4 + 8) + 4 * v30++) = v29;
      }
      ++v29;
      int v28 = HIDWORD(v97);
      if (v29 >= HIDWORD(v97)) {
        goto LABEL_50;
      }
    }
    int v32 = 120;
LABEL_163:
    __assert_rtn("operator()", "Matrix.hpp", v32, v31);
  }
  unsigned int v30 = 0;
LABEL_50:
  *a5 = v30;
  float64x2_t v90 = off_26C6875D0;
  if (__src && v93) {
    MEMORY[0x2166C5D70]();
  }
  int8x16_t v95 = off_26C6875D0;
  if (v96 && v98) {
    MEMORY[0x2166C5D70]();
  }
  uint64_t v100 = off_26C6875D0;
  uint64_t result = v101;
  if (v101 && v103) {
    return (char *)MEMORY[0x2166C5D70]();
  }
  return result;
}

void sub_215F38A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  MatrixNxPts<3u,double>::~MatrixNxPts((uint64_t)&a16);
  MatrixNxPts<2u,double>::~MatrixNxPts((uint64_t)&a11);
  if (a22 && a24) {
    MEMORY[0x2166C5D70]();
  }
  a26 = a10;
  if (a27 && a29) {
    MEMORY[0x2166C5D70]();
  }
  *(void *)(v30 - 144) = v29;
  if (*(void *)(v30 - 136))
  {
    if (*(unsigned char *)(v30 - 120)) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(a1);
}

BOOL GeomUtils::check3of4SpotsOnSameLine(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 20) != 4 || *(_DWORD *)(a1 + 16) != 3) {
    __assert_rtn("check3of4SpotsOnSameLine", "GeomUtils.cpp", 1201, "x1.Cols()==4 && x1.Rows()==3");
  }
  if (*(_DWORD *)(a2 + 20) != 4 || *(_DWORD *)(a2 + 16) != 3) {
    __assert_rtn("check3of4SpotsOnSameLine", "GeomUtils.cpp", 1202, "x2.Cols()==4 && x2.Rows()==3");
  }
  long long v3 = *(double **)(a1 + 8);
  double v5 = *v3;
  double v4 = v3[1];
  double v6 = v3[4];
  double v7 = v3[5];
  double v9 = v3[8];
  double v8 = v3[9];
  double v10 = v3[2];
  double v11 = v3[6];
  double v12 = v3[10];
  double v13 = v7 * v12 - v11 * v8;
  double v14 = -(v11 * v9);
  double v15 = v6 * v8 - v7 * v9;
  if (fabs(*v3 * v13 - v4 * (v9 * v12 - v11 * v9) + v10 * v15) < 0.00000011920929) {
    return 1;
  }
  double v16 = v3[3];
  double v17 = v3[7];
  double v18 = v3[11];
  double v19 = v9 * v18 - v17 * v9;
  if (fabs(v19 * -v4 + v5 * (v7 * v18 - v17 * v8) + v16 * v15) < 0.00000011920929) {
    return 1;
  }
  double v20 = v12 * -v17 + v11 * v18;
  if (fabs(v5 * v20 - v10 * v19 + v16 * (v14 + v6 * v12)) < 0.00000011920929) {
    return 1;
  }
  if (fabs((v8 * v18 - v17 * v8) * -v10 + v4 * v20 + v16 * v13) < 0.00000011920929) {
    return 1;
  }
  uint64_t v21 = *(double **)(a2 + 8);
  double v22 = v21[1];
  double v23 = v21[5];
  double v24 = v21[8];
  double v25 = v21[9];
  double v26 = v21[4] * v25 - v23 * v24;
  if (fabs(*v21 * (v23 * v21[10] - v21[6] * v25) - v22 * (v24 * v21[10] - v21[6] * v24) + v21[2] * v26) < 0.00000011920929
    || fabs((v24 * v21[11] - v21[7] * v24) * -v22 + *v21 * (v23 * v21[11] - v21[7] * v25) + v21[3] * v26) < 0.00000011920929)
  {
    return 1;
  }
  double v29 = *(double *)Matrix<double>::operator()(a2, 0, 0);
  uint64_t v27 = 1;
  double v30 = *(double *)Matrix<double>::operator()(a2, 1u, 0);
  double v31 = *(double *)Matrix<double>::operator()(a2, 2u, 0);
  double v32 = *(double *)Matrix<double>::operator()(a2, 0, 2u);
  double v33 = *(double *)Matrix<double>::operator()(a2, 1u, 2u);
  double v34 = *(double *)Matrix<double>::operator()(a2, 2u, 2u);
  double v35 = *(double *)Matrix<double>::operator()(a2, 0, 3u);
  double v36 = *(double *)Matrix<double>::operator()(a2, 1u, 3u);
  double v37 = (double *)Matrix<double>::operator()(a2, 2u, 3u);
  if (fabs(v29 * (v33 * *v37 - v36 * v34) - v32 * (v31 * *v37 - v36 * v31) + v35 * (v30 * v34 - v33 * v31)) >= 0.00000011920929)
  {
    double v38 = *(double *)Matrix<double>::operator()(a2, 0, 1u);
    double v39 = *(double *)Matrix<double>::operator()(a2, 1u, 1u);
    double v40 = *(double *)Matrix<double>::operator()(a2, 2u, 1u);
    double v41 = *(double *)Matrix<double>::operator()(a2, 0, 2u);
    double v42 = *(double *)Matrix<double>::operator()(a2, 1u, 2u);
    double v43 = *(double *)Matrix<double>::operator()(a2, 2u, 2u);
    double v44 = *(double *)Matrix<double>::operator()(a2, 0, 3u);
    double v45 = *(double *)Matrix<double>::operator()(a2, 1u, 3u);
    double v46 = (double *)Matrix<double>::operator()(a2, 2u, 3u);
    return fabs(v38 * (v42 * *v46 - v45 * v43) - v41 * (v40 * *v46 - v45 * v40) + v44 * (v39 * v43 - v42 * v40)) < 0.00000011920929;
  }
  return v27;
}

uint64_t Matrix<double>::operator()(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (*(_DWORD *)(a1 + 16) <= a2 || (unsigned int v3 = *(_DWORD *)(a1 + 20), v3 <= a3)) {
    __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
  }
  return *(void *)(a1 + 8) + 8 * a3 + 8 * v3 * a2;
}

float32x2_t GeomUtils::ExtrinsicsToSimd4x3(float64x2_t *a1)
{
  float64x2_t v1 = *a1;
  v1.f64[1] = a1[1].f64[1];
  return vcvt_f32_f64(v1);
}

double GeomUtils::ExtrinsicsFromSimd4x3(float64x2_t *a1, float64x2_t *a2, int8x16_t a3, int8x16_t a4, __n128 a5, __n128 a6)
{
  a1->f64[0] = *(float *)a3.i32;
  a1->f64[1] = *(float *)a4.i32;
  float64x2_t v6 = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL)));
  float32x2_t v7 = (float32x2_t)vzip2_s32(*(int32x2_t *)a4.i8, (int32x2_t)a5.n128_u64[0]);
  a5.n128_u32[1] = a3.u32[1];
  a1[1] = vcvtq_f64_f32((float32x2_t)a5.n128_u64[0]);
  a1[2] = vcvtq_f64_f32(v7);
  a1[3] = v6;
  a1[4].f64[0] = a5.n128_f32[2];
  *a2 = vcvtq_f64_f32((float32x2_t)a6.n128_u64[0]);
  double result = a6.n128_f32[2];
  a2[1].f64[0] = a6.n128_f32[2];
  return result;
}

void SparseMatrix::SparseMatrix(SparseMatrix *this, int a2, int a3, const int *a4, int a5, int a6)
{
  *((_DWORD *)this + 10) = a2;
  *((_DWORD *)this + 11) = a6;
  *((_DWORD *)this + 8) = a5 + a3 * a6;
  *((_DWORD *)this + 9) = a3;
  operator new[]();
}

void SparseMatrix::allocateMem(SparseMatrix *this)
{
}

void SparseMatrix::SparseMatrix(SparseMatrix *a1, int a2, int a3, const int **a4, int a5)
{
  float32x2_t v7 = *a4;
  double v8 = a4[1];
  if (v7 == v8)
  {
    int v10 = 0;
    goto LABEL_5;
  }
  unint64_t v9 = (char *)v8 - (char *)v7 - 4;
  if (v9 >= 0x1C)
  {
    uint64_t v12 = (v9 >> 2) + 1;
    double v13 = (int32x4_t *)(v7 + 4);
    int32x4_t v14 = 0uLL;
    uint64_t v15 = v12 & 0x7FFFFFFFFFFFFFF8;
    int32x4_t v16 = 0uLL;
    do
    {
      int32x4_t v14 = vaddq_s32(v13[-1], v14);
      int32x4_t v16 = vaddq_s32(*v13, v16);
      v13 += 2;
      v15 -= 8;
    }
    while (v15);
    int v10 = vaddvq_s32(vaddq_s32(v16, v14));
    if (v12 == (v12 & 0x7FFFFFFFFFFFFFF8)) {
LABEL_5:
    }
      SparseMatrix::SparseMatrix(a1, a2, a3, v7, v10, a5);
    double v11 = &v7[v12 & 0x7FFFFFFFFFFFFFF8];
  }
  else
  {
    int v10 = 0;
    double v11 = v7;
  }
  do
  {
    int v17 = *v11++;
    v10 += v17;
  }
  while (v11 != v8);
  goto LABEL_5;
}

{
  const int *v7;
  const int *v8;
  unint64_t v9;
  int v10;
  const int *v11;
  uint64_t v12;
  int32x4_t *v13;
  int32x4_t v14;
  uint64_t v15;
  int32x4_t v16;
  int v17;

  float32x2_t v7 = *a4;
  double v8 = a4[1];
  if (v7 == v8)
  {
    int v10 = 0;
    goto LABEL_5;
  }
  unint64_t v9 = (char *)v8 - (char *)v7 - 4;
  if (v9 >= 0x1C)
  {
    uint64_t v12 = (v9 >> 2) + 1;
    double v13 = (int32x4_t *)(v7 + 4);
    int32x4_t v14 = 0uLL;
    uint64_t v15 = v12 & 0x7FFFFFFFFFFFFFF8;
    int32x4_t v16 = 0uLL;
    do
    {
      int32x4_t v14 = vaddq_s32(v13[-1], v14);
      int32x4_t v16 = vaddq_s32(*v13, v16);
      v13 += 2;
      v15 -= 8;
    }
    while (v15);
    int v10 = vaddvq_s32(vaddq_s32(v16, v14));
    if (v12 == (v12 & 0x7FFFFFFFFFFFFFF8)) {
LABEL_5:
    }
      SparseMatrix::SparseMatrix(a1, a2, a3, v7, v10, a5);
    double v11 = &v7[v12 & 0x7FFFFFFFFFFFFFF8];
  }
  else
  {
    int v10 = 0;
    double v11 = v7;
  }
  do
  {
    int v17 = *v11++;
    v10 += v17;
  }
  while (v11 != v8);
  goto LABEL_5;
}

void SparseMatrix::SparseMatrix(SparseMatrix *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
}

{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
}

double SparseMatrix::freeMem(SparseMatrix *this)
{
  uint64_t v2 = *(void *)this;
  if (v2) {
    MEMORY[0x2166C5D70](v2, 0x1000C8000313F17);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    MEMORY[0x2166C5D70](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4) {
    MEMORY[0x2166C5D70](v4, 0x1000C8052888210);
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    MEMORY[0x2166C5D70](v5, 0x1000C8052888210);
  }
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

void SparseMatrix::~SparseMatrix(SparseMatrix *this)
{
  uint64_t v2 = *(void *)this;
  if (v2) {
    MEMORY[0x2166C5D70](v2, 0x1000C8000313F17);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    MEMORY[0x2166C5D70](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4) {
    MEMORY[0x2166C5D70](v4, 0x1000C8052888210);
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    MEMORY[0x2166C5D70](v5, 0x1000C8052888210);
  }
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  uint64_t v2 = *(void *)this;
  if (v2) {
    MEMORY[0x2166C5D70](v2, 0x1000C8000313F17);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    MEMORY[0x2166C5D70](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4) {
    MEMORY[0x2166C5D70](v4, 0x1000C8052888210);
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    MEMORY[0x2166C5D70](v5, 0x1000C8052888210);
  }
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

void SparseMatrix::SparseMatrix(SparseMatrix *this, const SparseMatrix *a2)
{
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  operator new[]();
}

{
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  operator new[]();
}

double SparseMatrix::SparseMatrix(_OWORD *a1, _OWORD *a2)
{
  *a1 = *a2;
  long long v2 = a2[2];
  a1[1] = a2[1];
  a1[2] = v2;
  double result = 0.0;
  *a2 = 0u;
  a2[1] = 0u;
  return result;
}

{
  long long v2;
  double result;

  *a1 = *a2;
  long long v2 = a2[2];
  a1[1] = a2[1];
  a1[2] = v2;
  double result = 0.0;
  *a2 = 0u;
  a2[1] = 0u;
  return result;
}

uint64_t *SparseMatrix::operator=(uint64_t *a1, _OWORD *a2)
{
  uint64_t v4 = *a1;
  if (v4) {
    MEMORY[0x2166C5D70](v4, 0x1000C8000313F17);
  }
  uint64_t v5 = a1[1];
  if (v5) {
    MEMORY[0x2166C5D70](v5, 0x1000C8052888210);
  }
  uint64_t v6 = a1[2];
  if (v6) {
    MEMORY[0x2166C5D70](v6, 0x1000C8052888210);
  }
  uint64_t v7 = a1[3];
  if (v7) {
    MEMORY[0x2166C5D70](v7, 0x1000C8052888210);
  }
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *(_OWORD *)a1 = *a2;
  long long v8 = a2[2];
  *((_OWORD *)a1 + 1) = a2[1];
  *((_OWORD *)a1 + 2) = v8;
  *a2 = 0u;
  a2[1] = 0u;
  return a1;
}

uint64_t SparseMatrix::AddValue(uint64_t this, int a2, int a3, double a4)
{
  uint64_t v5 = *(void *)(this + 16);
  uint64_t v4 = *(void *)(this + 24);
  int v6 = *(_DWORD *)(v4 + 4 * a3) + *(_DWORD *)(v5 + 4 * a3);
  if (*(_DWORD *)(this + 36) - 1 == a3) {
    int v7 = *(_DWORD *)(this + 32);
  }
  else {
    int v7 = *(_DWORD *)(v5 + 4 * a3 + 4);
  }
  if (v6 >= v7) {
    __assert_rtn("AddValue", "SparseMatrix.cpp", 124, "(col != m_width-1 && index < m_colIndices[col+1]) || (col == m_width-1 && index < m_maxNNZ)");
  }
  uint64_t v8 = *(void *)(this + 8);
  *(double *)(*(void *)this + 8 * v6) = a4;
  *(_DWORD *)(v8 + 4 * v6) = a2;
  ++*(_DWORD *)(v4 + 4 * a3);
  return this;
}

uint64_t SparseMatrix::Expand(uint64_t this, int a2, unint64_t a3)
{
  unint64_t v3 = *(int *)(this + 44);
  if (v3 < a3) {
    __assert_rtn("Expand", "SparseMatrix.cpp", 134, "newNZPerCol <= (size_t)m_extraSpacePerCol");
  }
  *(_DWORD *)(this + 40) += a2;
  *(_DWORD *)(this + 44) = v3 - a3;
  return this;
}

uint64_t SparseMatrix::Squeeze(uint64_t this, int a2, int a3)
{
  int v3 = *(_DWORD *)(this + 36);
  int v4 = *(_DWORD *)(this + 44) + a3;
  *(_DWORD *)(this + 40) -= a2;
  *(_DWORD *)(this + 44) = v4;
  if (v3 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(this + 24);
    do
      *(_DWORD *)(v6 + 4 * v5++) -= a3;
    while (v5 < *(int *)(this + 36));
  }
  return this;
}

double SparseMatrix::operator()(uint64_t a1, int a2, int a3)
{
  if (*(_DWORD *)(a1 + 40) <= a2 || *(_DWORD *)(a1 + 36) <= a3) {
    __assert_rtn("operator()", "SparseMatrix.cpp", 154, "row<(int)GetMatrixHeight() && col<(int)GetMatrixWidth()");
  }
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 24) + 4 * a3);
  double result = 0.0;
  if ((int)v3 >= 1)
  {
    for (uint64_t i = *(int *)(*(void *)(a1 + 16) + 4 * a3); *(_DWORD *)(*(void *)(a1 + 8) + 4 * i) != a2; ++i)
    {
      if (!--v3) {
        return result;
      }
    }
    return *(double *)(*(void *)a1 + 8 * i);
  }
  return result;
}

uint64_t SparseMatrix::GetMatrixHeight(SparseMatrix *this)
{
  return *((int *)this + 10);
}

uint64_t SparseMatrix::GetMatrixWidth(SparseMatrix *this)
{
  return *((int *)this + 9);
}

uint64_t SparseMatrix::MultATagxB@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v2 = *(_DWORD *)(a1 + 36);
  *(void *)a2 = off_26C6875D0;
  if (v2) {
    operator new[]();
  }
  uint64_t result = 0;
  *(_DWORD *)(a2 + 16) = 1;
  *(_DWORD *)(a2 + 20) = 0;
  *(unsigned char *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)a2 = &unk_26C6874F0;
  *(void *)(a2 + 8) = 0;
  return result;
}

void SparseMatrix::operator*(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *((_DWORD *)a1 + 10);
  *(void *)a3 = off_26C6875D0;
  if (v6) {
    operator new[]();
  }
  *(_DWORD *)(a3 + 16) = 1;
  *(_DWORD *)(a3 + 20) = 0;
  *(unsigned char *)(a3 + 24) = 0;
  *(void *)(a3 + 32) = 0;
  *(void *)a3 = &unk_26C6874F0;
  *(void *)(a3 + 8) = 0;
  bzero(0, 0);
  uint64_t v7 = *((unsigned int *)a1 + 9);
  if ((int)v7 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a1[2];
    uint64_t v10 = a1[3];
    do
    {
      uint64_t v11 = *(int *)(v10 + 4 * v8);
      if ((int)v11 >= 1)
      {
        uint64_t v12 = *(int *)(v9 + 4 * v8);
        uint64_t v13 = v11 + v12;
        uint64_t v14 = *a1;
        uint64_t v15 = a1[1];
        do
        {
          uint64_t v16 = 8 * *(unsigned int *)(v15 + 4 * v12);
          *(double *)(*(void *)(a3 + 8) + v16) = *(double *)(*(void *)(a3 + 8) + v16)
                                                 + *(double *)(v14 + 8 * v12++)
                                                 * *(double *)(*(void *)(a2 + 8) + 8 * v8);
        }
        while (v12 < v13);
      }
      ++v8;
    }
    while (v8 != v7);
  }
}

void *SparseMatrix::ReverseStorageOfColumn(void *this, int a2)
{
  uint64_t v2 = *(int *)(this[3] + 4 * a2);
  if (v2)
  {
    uint64_t v3 = *(int *)(this[2] + 4 * a2);
    int v4 = (uint64_t *)(*this + 8 * v3);
    uint64_t v5 = (uint64_t *)(8 * v3 + 8 * v2 + *this - 8);
    do
    {
      if (v5 == v4) {
        break;
      }
      uint64_t v6 = *v4;
      *v4++ = *v5;
      BOOL v7 = v5 == v4;
      *v5-- = v6;
    }
    while (!v7);
    uint64_t v8 = this[1];
    uint64_t v9 = 4 * v3;
    uint64_t v10 = (int *)(v8 + 4 * v3);
    uint64_t v11 = (int *)(v9 + 4 * v2 + v8 - 4);
    do
    {
      if (v11 == v10) {
        break;
      }
      int v12 = *v10;
      *v10++ = *v11;
      BOOL v7 = v11 == v10;
      *v11-- = v12;
    }
    while (!v7);
  }
  return this;
}

double SparseMatrix::GetColumnAsDenseVector@<D0>(SparseMatrix *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v6 = *((_DWORD *)this + 10);
  *(void *)a3 = off_26C6875D0;
  if (v6) {
    operator new[]();
  }
  *(_DWORD *)(a3 + 16) = 1;
  *(_DWORD *)(a3 + 20) = 0;
  *(unsigned char *)(a3 + 24) = 0;
  *(void *)(a3 + 32) = 0;
  *(void *)a3 = &unk_26C6874F0;
  *(void *)(a3 + 8) = 0;
  bzero(0, 0);
  uint64_t v8 = *(int *)(*((void *)this + 3) + 4 * a2);
  if ((int)v8 >= 1)
  {
    uint64_t v9 = *((void *)this + 1);
    uint64_t v10 = *(int *)(*((void *)this + 2) + 4 * a2);
    uint64_t v11 = v8 + v10;
    uint64_t v12 = *(void *)this;
    do
    {
      double result = *(double *)(v12 + 8 * v10);
      *(double *)(*(void *)(a3 + 8) + 8 * *(unsigned int *)(v9 + 4 * v10++)) = result;
    }
    while (v10 < v11);
  }
  return result;
}

double SparseMatrix::CopyColumnToDenseVector(SparseMatrix *this, int a2, double *a3)
{
  bzero(a3, 8 * *((int *)this + 10));
  uint64_t v7 = *(int *)(*((void *)this + 3) + 4 * a2);
  if ((int)v7 >= 1)
  {
    uint64_t v8 = *((void *)this + 1);
    uint64_t v9 = *(int *)(*((void *)this + 2) + 4 * a2);
    uint64_t v10 = v7 + v9;
    uint64_t v11 = *(void *)this;
    do
    {
      double result = *(double *)(v11 + 8 * v9);
      a3[*(int *)(v8 + 4 * v9++)] = result;
    }
    while (v9 < v10);
  }
  return result;
}

uint64_t SparseMatrix::GetColumnAsSparseVector@<X0>(uint64_t this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v3 = *(_DWORD *)(this + 40);
  uint64_t v4 = 4 * a2;
  int v5 = *(_DWORD *)(*(void *)(this + 24) + v4);
  uint64_t v6 = *(int *)(*(void *)(this + 16) + v4);
  uint64_t v7 = *(void *)(this + 8) + 4 * v6;
  uint64_t v8 = *(void *)this + 8 * v6;
  *(_DWORD *)(a3 + 16) = v5;
  *(_DWORD *)(a3 + 20) = v5;
  *(_DWORD *)(a3 + 24) = v3;
  *(unsigned char *)(a3 + 28) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v7;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  return this;
}

void SparseVector::SparseVector(SparseVector *this, int a2, int a3, int *a4, double *a5, char a6)
{
  *((_DWORD *)this + 4) = a3;
  *((_DWORD *)this + 5) = a3;
  *((_DWORD *)this + 6) = a2;
  *((unsigned char *)this + 28) = a6;
  *((_DWORD *)this + 8) = 0;
  if (a6) {
    operator new[]();
  }
  *(void *)this = a5;
  *((void *)this + 1) = a4;
  *((void *)this + 6) = 0;
  *((void *)this + 5) = 0;
}

uint64_t SparseMatrix::SolveLTInPlace(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 36);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a2 + 8);
    uint64_t v5 = *(void *)result;
    uint64_t v6 = *(void *)(result + 16);
    uint64_t v7 = *(void *)(result + 24);
    uint64_t v8 = *(void *)result + 8;
    uint64_t v9 = (float64x2_t *)(v4 + 24);
    uint64_t v10 = *(void *)result + 24;
    do
    {
      uint64_t v11 = (double *)(v4 + 8 * v3);
      uint64_t v12 = *(int *)(v6 + 4 * v3);
      double v13 = *v11 / *(double *)(v5 + 8 * v12);
      *uint64_t v11 = v13;
      unint64_t v14 = (unint64_t)(v11 + 1);
      double result = *(unsigned int *)(v7 + 4 * v3);
      if ((int)result >= 2)
      {
        if (result > 6
          && ((unint64_t v15 = (unint64_t)&v11[result], v14 < v5 + 8 * v12 + 8 * result)
            ? (BOOL v16 = v8 + 8 * v12 >= v15)
            : (BOOL v16 = 1),
              v16))
        {
          unint64_t v17 = (result - 1) & 0xFFFFFFFFFFFFFFFCLL;
          float64x2_t v18 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v13, 0);
          double v19 = (float64x2_t *)(v10 + 8 * v12);
          double v20 = v9;
          unint64_t v21 = v17;
          do
          {
            float64x2_t v22 = vmlsq_f64(*v20, v18, *v19);
            v20[-1] = vmlsq_f64(v20[-1], v18, v19[-1]);
            float64x2_t *v20 = v22;
            v20 += 2;
            v19 += 2;
            v21 -= 4;
          }
          while (v21);
          if (result - 1 == v17) {
            goto LABEL_3;
          }
          uint64_t v23 = v17 | 1;
        }
        else
        {
          uint64_t v23 = 1;
        }
        result -= v23;
        double v24 = (double *)(v4 + 8 * (v23 + v3));
        double v25 = (double *)(v5 + 8 * v23 + 8 * v12);
        do
        {
          double v26 = *v25++;
          *double v24 = *v24 - v26 * v13;
          ++v24;
          --result;
        }
        while (result);
      }
LABEL_3:
      ++v3;
      uint64_t v9 = (float64x2_t *)((char *)v9 + 8);
    }
    while (v3 != v2);
  }
  return result;
}

void SparseMatrix::Zero(void **this)
{
}

void SparseVector::SparseVector(SparseVector *this, int a2, int a3)
{
  *((_DWORD *)this + 4) = a3;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = a2;
  *((unsigned char *)this + 28) = 1;
  *((_DWORD *)this + 8) = 0;
  operator new[]();
}

{
  *((_DWORD *)this + 4) = a3;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = a2;
  *((unsigned char *)this + 28) = 1;
  *((_DWORD *)this + 8) = 0;
  operator new[]();
}

void SparseVector::~SparseVector(SparseVector *this)
{
  if (*((unsigned char *)this + 28))
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      MEMORY[0x2166C5D70](v2, 0x1000C8052888210);
    }
    if (*(void *)this) {
      MEMORY[0x2166C5D70](*(void *)this, 0x1000C8000313F17);
    }
  }
  uint64_t v3 = *((void *)this + 6);
  if (v3) {
    MEMORY[0x2166C5D70](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 5);
  if (v4) {
    MEMORY[0x2166C5D70](v4, 0x1000C8000313F17);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (*((unsigned char *)this + 28))
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      MEMORY[0x2166C5D70](v2, 0x1000C8052888210);
    }
    if (*(void *)this) {
      MEMORY[0x2166C5D70](*(void *)this, 0x1000C8000313F17);
    }
  }
  uint64_t v3 = *((void *)this + 6);
  if (v3) {
    MEMORY[0x2166C5D70](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 5);
  if (v4) {
    MEMORY[0x2166C5D70](v4, 0x1000C8000313F17);
  }
}

__n128 SparseVector::SparseVector(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(unsigned char *)(a1 + 28) = *(unsigned char *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(unsigned char *)(a2 + 28) = 0;
  return result;
}

{
  __n128 result;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(unsigned char *)(a1 + 28) = *(unsigned char *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(unsigned char *)(a2 + 28) = 0;
  return result;
}

void SparseVector::SparseVector(SparseVector *this, const SparseVector *a2)
{
  uint64_t v2 = *(void *)((char *)a2 + 20);
  *((_DWORD *)this + 4) = v2;
  *(void *)((char *)this + 20) = v2;
  *((unsigned char *)this + 28) = 1;
  *((_DWORD *)this + 8) = 0;
  operator new[]();
}

{
  uint64_t v2;

  uint64_t v2 = *(void *)((char *)a2 + 20);
  *((_DWORD *)this + 4) = v2;
  *(void *)((char *)this + 20) = v2;
  *((unsigned char *)this + 28) = 1;
  *((_DWORD *)this + 8) = 0;
  operator new[]();
}

uint64_t SparseVector::operator=(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 28)) {
    __assert_rtn("operator=", "SparseMatrix.cpp", 500, "m_ownsData");
  }
  if (*(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16))
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4) {
      MEMORY[0x2166C5D70](v4, 0x1000C8052888210);
    }
    if (*(void *)a1) {
      MEMORY[0x2166C5D70](*(void *)a1, 0x1000C8000313F17);
    }
    uint64_t v5 = *(void *)(a1 + 48);
    if (v5) {
      MEMORY[0x2166C5D70](v5, 0x1000C8052888210);
    }
    uint64_t v6 = *(void *)(a1 + 40);
    if (v6) {
      MEMORY[0x2166C5D70](v6, 0x1000C8000313F17);
    }
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
    operator new[]();
  }
  memcpy(*(void **)(a1 + 8), *(const void **)(a2 + 8), 4 * *(int *)(a2 + 20));
  memcpy(*(void **)a1, *(const void **)a2, 8 * *(int *)(a2 + 20));
  *(void *)(a1 + 20) = *(void *)(a2 + 20);
  return a1;
}

uint64_t SparseVector::MultATagxB(uint64_t this, const SparseVector *a2)
{
  int v2 = 0;
  int v3 = 0;
  uint64_t v4 = *(int **)(this + 8);
  int v5 = *(_DWORD *)(this + 20);
  double v6 = 0.0;
  for (uint64_t i = (int *)*((void *)a2 + 1); ; ++i)
  {
    int v8 = *i;
    while (1)
    {
      int v9 = *v4;
      if (*v4 >= v8) {
        break;
      }
LABEL_7:
      if (++v2 >= v5) {
        return this;
      }
      ++v4;
    }
    while (v8 < v9)
    {
      if (++v3 >= v5) {
        return this;
      }
      int v10 = i[1];
      ++i;
      int v8 = v10;
      if (v9 < v10) {
        goto LABEL_7;
      }
    }
    double v6 = v6 + *(double *)(*(void *)this + 8 * v2) * *(double *)(*(void *)a2 + 8 * v3);
    if (++v2 >= v5) {
      break;
    }
    if (++v3 >= *((_DWORD *)a2 + 5)) {
      break;
    }
    ++v4;
  }
  return this;
}

uint64_t SparseVector::AddWithFactor(uint64_t this, const SparseVector *a2, double a3)
{
  if (!*(unsigned char *)(this + 28)) {
    __assert_rtn("AddWithFactor", "SparseMatrix.cpp", 594, "m_ownsData");
  }
  if (*(_DWORD *)(this + 24) != *((_DWORD *)a2 + 6)) {
    __assert_rtn("AddWithFactor", "SparseMatrix.cpp", 595, "this->m_size == rhs.m_size");
  }
  *(_DWORD *)(this + 32) = 0;
  uint64_t v3 = *((int *)a2 + 5);
  uint64_t v4 = *(double **)this;
  uint64_t v5 = *(void *)(this + 8);
  uint64_t v6 = *(int *)(this + 20);
  unint64_t v7 = *(void *)this + 8 * v6;
  int v8 = *(double **)a2;
  int v9 = (int *)*((void *)a2 + 1);
  unint64_t v10 = *(void *)a2 + 8 * v3;
  int v11 = 0;
  if ((int)v6 < 1 || (int)v3 < 1)
  {
    unint64_t v14 = *(int **)(this + 8);
    double v13 = *(double **)this;
    goto LABEL_27;
  }
  double v13 = *(double **)this;
  unint64_t v14 = *(int **)(this + 8);
  do
  {
    int v15 = *v14;
    int v16 = *v9;
    if (*v14 == *v9)
    {
      if (*(_DWORD *)(this + 24) <= v15 || v11 >= *(_DWORD *)(this + 16)) {
        goto LABEL_35;
      }
      double v17 = *v13++;
      double v18 = v17 + a3 * *v8;
      uint64_t v19 = *(void *)(this + 40);
      *(_DWORD *)(*(void *)(this + 48) + 4 * v11) = v15;
      uint64_t v20 = *(int *)(this + 32);
      *(double *)(v19 + 8 * v20) = v18;
      int v11 = v20 + 1;
      *(_DWORD *)(this + 32) = v11;
      ++v14;
LABEL_21:
      ++v8;
      ++v9;
      if ((unint64_t)v13 >= v7) {
        break;
      }
      continue;
    }
    if (v15 >= v16)
    {
      if (*(_DWORD *)(this + 24) <= v16 || v11 >= *(_DWORD *)(this + 16)) {
        goto LABEL_35;
      }
      double v24 = *v8 * a3;
      uint64_t v25 = *(void *)(this + 40);
      *(_DWORD *)(*(void *)(this + 48) + 4 * v11) = v16;
      uint64_t v26 = *(int *)(this + 32);
      *(double *)(v25 + 8 * v26) = v24;
      int v11 = v26 + 1;
      *(_DWORD *)(this + 32) = v11;
      goto LABEL_21;
    }
    if (*(_DWORD *)(this + 24) <= v15 || v11 >= *(_DWORD *)(this + 16)) {
      goto LABEL_35;
    }
    double v21 = *v13++;
    uint64_t v22 = *(void *)(this + 40);
    *(_DWORD *)(*(void *)(this + 48) + 4 * v11) = v15;
    uint64_t v23 = *(int *)(this + 32);
    *(double *)(v22 + 8 * v23) = v21;
    int v11 = v23 + 1;
    *(_DWORD *)(this + 32) = v11;
    ++v14;
    if ((unint64_t)v13 >= v7) {
      break;
    }
  }
  while ((unint64_t)v8 < v10);
LABEL_27:
  while ((unint64_t)v13 < v7)
  {
    if (*(_DWORD *)(this + 24) <= *v14 || v11 >= *(_DWORD *)(this + 16)) {
      goto LABEL_35;
    }
    double v27 = *v13++;
    uint64_t v28 = *(void *)(this + 40);
    *(_DWORD *)(*(void *)(this + 48) + 4 * v11) = *v14;
    uint64_t v29 = *(int *)(this + 32);
    *(double *)(v28 + 8 * v29) = v27;
    int v11 = v29 + 1;
    *(_DWORD *)(this + 32) = v11;
    ++v14;
  }
  if ((unint64_t)v8 < v10)
  {
    while (*(_DWORD *)(this + 24) > *v9 && v11 < *(_DWORD *)(this + 16))
    {
      double v30 = *v8++;
      uint64_t v32 = *(void *)(this + 40);
      uint64_t v31 = *(void *)(this + 48);
      *(_DWORD *)(v31 + 4 * v11) = *v9;
      uint64_t v33 = *(int *)(this + 32);
      *(double *)(v32 + 8 * v33) = v30 * a3;
      int v11 = v33 + 1;
      *(_DWORD *)(this + 32) = v11;
      ++v9;
      if ((unint64_t)v8 >= v10) {
        goto LABEL_34;
      }
    }
LABEL_35:
    __assert_rtn("AddValueToHelper", "SparseMatrix.hpp", 175, "pos<m_size && m_helperNNZ<m_maxNNZ");
  }
  uint64_t v32 = *(void *)(this + 40);
  uint64_t v31 = *(void *)(this + 48);
LABEL_34:
  *(void *)this = v32;
  *(void *)(this + 8) = v31;
  *(void *)(this + 40) = v4;
  *(void *)(this + 48) = v5;
  *(_DWORD *)(this + 20) = v11;
  return this;
}

void SparseVector::operator-(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = *(_DWORD *)(a1 + 24);
  *(void *)(a3 + 16) = (*(_DWORD *)(a2 + 20) + *(_DWORD *)(a1 + 20));
  *(_DWORD *)(a3 + 24) = v3;
  *(unsigned char *)(a3 + 28) = 1;
  *(_DWORD *)(a3 + 32) = 0;
  operator new[]();
}

void sub_215F3AE44(_Unwind_Exception *a1)
{
  MEMORY[0x2166C5D70](v1, 0x1000C8052888210);
  MEMORY[0x2166C5D70](v2, 0x1000C8000313F17);
  MEMORY[0x2166C5D70](v3, 0x1000C8052888210);
  MEMORY[0x2166C5D70](v4, 0x1000C8000313F17);
  _Unwind_Resume(a1);
}

double operator+=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 20);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = *(double **)a2;
    uint64_t v4 = *(_DWORD **)(a2 + 8);
    do
    {
      double v5 = *v3++;
      double v6 = v5;
      LODWORD(v5) = *v4++;
      uint64_t v7 = *(void *)(a1 + 8);
      uint64_t v8 = 8 * LODWORD(v5);
      double result = v6 + *(double *)(v7 + v8);
      *(double *)(v7 + v8) = result;
      --v2;
    }
    while (v2);
  }
  return result;
}

double SparseVector::GetAsDenseVector@<D0>(SparseVector *this@<X0>, uint64_t a2@<X8>)
{
  int v4 = *((_DWORD *)this + 6);
  *(void *)a2 = off_26C6875D0;
  if (v4) {
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = 1;
  *(_DWORD *)(a2 + 20) = 0;
  *(unsigned char *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)a2 = &unk_26C6874F0;
  *(void *)(a2 + 8) = 0;
  bzero(0, 0);
  uint64_t v6 = *((unsigned int *)this + 5);
  if ((int)v6 >= 1)
  {
    uint64_t v7 = *(double **)this;
    uint64_t v8 = (_DWORD *)*((void *)this + 1);
    do
    {
      double v9 = *v7++;
      double result = v9;
      LODWORD(v9) = *v8++;
      *(double *)(*(void *)(a2 + 8) + 8 * LODWORD(vbzero(this[3], 4 * *((int *)this + 9)) = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t Algo::asin(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(double **)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  double v5 = *(long double **)(a2 + 8);
  if (*(void *)(a2 + 32) < 8 * v3 * (unint64_t)v4)
  {
    if (v5)
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70](*(void *)(a2 + 8), 0x1000C8000313F17);
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  for (unint64_t i = *(void *)(a1 + 8) + 8 * (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
        (unint64_t)v2 < i;
        ++v5)
  {
    long double v7 = *v2++;
    *double v5 = asin(v7);
  }
  return 0;
}

uint64_t Algo::sin(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(long double **)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  double v5 = *(long double **)(a2 + 8);
  if (*(void *)(a2 + 32) < 8 * v3 * (unint64_t)v4)
  {
    if (v5)
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70](*(void *)(a2 + 8), 0x1000C8000313F17);
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  unint64_t v8 = v6 + 8 * v7;
  if ((unint64_t)v2 < v8)
  {
    unint64_t v9 = v6 + 8 * v7;
    if (v9 <= (unint64_t)(v2 + 1)) {
      unint64_t v9 = (unint64_t)(v2 + 1);
    }
    unint64_t v10 = v9 + ~(unint64_t)v2;
    if (v10 < 0x18 || (unint64_t)((char *)v5 - (char *)v2) < 0x10)
    {
      uint64_t v12 = v5;
      goto LABEL_18;
    }
    uint64_t v13 = (v10 >> 3) + 1;
    uint64_t v14 = v13 & 0x3FFFFFFFFFFFFFFELL;
    uint64_t v12 = &v5[v13 & 0x3FFFFFFFFFFFFFFELL];
    int v15 = v2;
    uint64_t v16 = v13 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      long long v17 = *(_OWORD *)v15;
      v15 += 2;
      long double v21 = sin(*((long double *)&v17 + 1));
      *(double *)&long long v18 = sin(*(long double *)&v17);
      *((long double *)&v18 + 1) = v21;
      *(_OWORD *)double v5 = v18;
      v5 += 2;
      v16 -= 2;
    }
    while (v16);
    if (v13 != v14)
    {
      v2 += v14;
      do
      {
LABEL_18:
        long double v19 = *v2++;
        *v12++ = sin(v19);
      }
      while ((unint64_t)v2 < v8);
    }
  }
  return 0;
}

uint64_t Algo::atan(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(double **)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  double v5 = *(long double **)(a2 + 8);
  if (*(void *)(a2 + 32) < 8 * v3 * (unint64_t)v4)
  {
    if (v5)
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70](*(void *)(a2 + 8), 0x1000C8000313F17);
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  for (unint64_t i = *(void *)(a1 + 8) + 8 * (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
        (unint64_t)v2 < i;
        ++v5)
  {
    long double v7 = *v2++;
    *double v5 = atan(v7);
  }
  return 0;
}

uint64_t Algo::atan2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(double **)(a2 + 8);
  unsigned int v4 = *(_DWORD *)(a2 + 16);
  unsigned int v5 = *(_DWORD *)(a2 + 20);
  uint64_t v6 = *(long double **)(a3 + 8);
  if (*(void *)(a3 + 32) < 8 * v4 * (unint64_t)v5)
  {
    if (v6)
    {
      if (*(unsigned char *)(a3 + 24)) {
        MEMORY[0x2166C5D70](*(void *)(a3 + 8), 0x1000C8000313F17);
      }
    }
    operator new[]();
  }
  unint64_t v7 = *(void *)(a3 + 32);
  *(_DWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 20) = v5;
  unint64_t v8 = *(double **)(a1 + 8);
  unsigned int v9 = *(_DWORD *)(a2 + 16);
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  if (v7 < 8 * v9 * (unint64_t)v10)
  {
    if (v6 && *(unsigned char *)(a3 + 24)) {
      MEMORY[0x2166C5D70](v6, 0x1000C8000313F17);
    }
    operator new[]();
  }
  *(_DWORD *)(a3 + 16) = v9;
  *(_DWORD *)(a3 + 20) = v10;
  for (unint64_t i = *(void *)(a2 + 8) + 8 * (*(_DWORD *)(a2 + 20) * *(_DWORD *)(a2 + 16));
        (unint64_t)v3 < i;
        ++v6)
  {
    double v12 = *v8++;
    long double v13 = v12;
    long double v14 = *v3++;
    *uint64_t v6 = atan2(v13, v14);
  }
  return 0;
}

uint64_t Algo::tan(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(double **)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  unsigned int v5 = *(long double **)(a2 + 8);
  if (*(void *)(a2 + 32) < 8 * v3 * (unint64_t)v4)
  {
    if (v5)
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70](*(void *)(a2 + 8), 0x1000C8000313F17);
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  for (unint64_t i = *(void *)(a1 + 8) + 8 * (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
        (unint64_t)v2 < i;
        ++v5)
  {
    long double v7 = *v2++;
    *unsigned int v5 = tan(v7);
  }
  return 0;
}

uint64_t Algo::acos(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(double **)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  unsigned int v5 = *(long double **)(a2 + 8);
  if (*(void *)(a2 + 32) < 8 * v3 * (unint64_t)v4)
  {
    if (v5)
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70](*(void *)(a2 + 8), 0x1000C8000313F17);
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  for (unint64_t i = *(void *)(a1 + 8) + 8 * (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
        (unint64_t)v2 < i;
        ++v5)
  {
    long double v7 = *v2++;
    *unsigned int v5 = acos(v7);
  }
  return 0;
}

uint64_t Algo::cos(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(long double **)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  unsigned int v5 = *(long double **)(a2 + 8);
  if (*(void *)(a2 + 32) < 8 * v3 * (unint64_t)v4)
  {
    if (v5)
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70](*(void *)(a2 + 8), 0x1000C8000313F17);
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 20) = v4;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (*(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
  unint64_t v8 = v6 + 8 * v7;
  if ((unint64_t)v2 < v8)
  {
    unint64_t v9 = v6 + 8 * v7;
    if (v9 <= (unint64_t)(v2 + 1)) {
      unint64_t v9 = (unint64_t)(v2 + 1);
    }
    unint64_t v10 = v9 + ~(unint64_t)v2;
    if (v10 < 0x18 || (unint64_t)((char *)v5 - (char *)v2) < 0x10)
    {
      double v12 = v5;
      goto LABEL_18;
    }
    uint64_t v13 = (v10 >> 3) + 1;
    uint64_t v14 = v13 & 0x3FFFFFFFFFFFFFFELL;
    double v12 = &v5[v13 & 0x3FFFFFFFFFFFFFFELL];
    int v15 = v2;
    uint64_t v16 = v13 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      long long v17 = *(_OWORD *)v15;
      v15 += 2;
      long double v21 = cos(*((long double *)&v17 + 1));
      *(double *)&long long v18 = cos(*(long double *)&v17);
      *((long double *)&v18 + 1) = v21;
      *(_OWORD *)unsigned int v5 = v18;
      v5 += 2;
      v16 -= 2;
    }
    while (v16);
    if (v13 != v14)
    {
      v2 += v14;
      do
      {
LABEL_18:
        long double v19 = *v2++;
        *v12++ = cos(v19);
      }
      while ((unint64_t)v2 < v8);
    }
  }
  return 0;
}

uint64_t Algo::cart2sph(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v8 = *(_DWORD *)(a1 + 16);
  unsigned int v9 = *(_DWORD *)(a1 + 20);
  uint64_t v64 = off_26C6875D0;
  if (v9 * v8) {
    operator new[]();
  }
  uint64_t v65 = 0;
  unint64_t v66 = __PAIR64__(v9, v8);
  char v67 = 0;
  unint64_t v68 = 8 * v8 * (unint64_t)v9;
  unsigned int v11 = *(_DWORD *)(a2 + 16);
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  BOOL v58 = off_26C6875D0;
  if (v10 * v11) {
    operator new[]();
  }
  uint64_t v59 = 0;
  unsigned int v60 = v11;
  unsigned int v61 = v10;
  char v62 = 0;
  unint64_t v63 = 8 * v11 * (unint64_t)v10;
  if (v10 != HIDWORD(v66) || v11 != v66) {
    __assert_rtn("doDimensionsMatchTo", "Matrix.hpp", 1043, "0");
  }
  uint64_t v70 = 0;
  char v72 = 0;
  unint64_t v73 = 8 * v11 * (unint64_t)v10;
  BOOL v74 = off_26C6875D0;
  uint64_t v75 = 0;
  unsigned int v76 = v11;
  unsigned int v77 = v10;
  char v78 = 0;
  unint64_t v79 = v73;
  float64x2_t v69 = off_26C6875D0;
  unint64_t v71 = 0;
  BOOL v58 = off_26C6875D0;
  uint64_t v64 = off_26C6875D0;
  unsigned int v13 = v11;
  unsigned int v14 = v10;
  if (a6)
  {
    BOOL v58 = off_26C6875D0;
    if (v77 * v76) {
      operator new[]();
    }
    uint64_t v59 = 0;
    unsigned int v60 = v76;
    unsigned int v61 = v77;
    char v62 = 0;
    unint64_t v63 = 8 * v76 * (unint64_t)v77;
    unsigned int v16 = *(_DWORD *)(a3 + 16);
    unsigned int v15 = *(_DWORD *)(a3 + 20);
    char v52 = off_26C6875D0;
    if (v15 * v16) {
      operator new[]();
    }
    uint64_t v53 = 0;
    unsigned int v54 = v16;
    unsigned int v55 = v15;
    char v56 = 0;
    unint64_t v57 = 8 * v16 * (unint64_t)v15;
    if (v15 != v61 || v16 != v60) {
      __assert_rtn("doDimensionsMatchTo", "Matrix.hpp", 1043, "0");
    }
    uint64_t v64 = off_26C6875D0;
    uint64_t v65 = 0;
    unint64_t v66 = __PAIR64__(v15, v16);
    char v67 = 0;
    unint64_t v68 = 8 * v16 * (unint64_t)v15;
    float64x2_t v69 = off_26C6875D0;
    uint64_t v70 = 0;
    unint64_t v71 = __PAIR64__(v15, v16);
    char v72 = 0;
    unint64_t v73 = v68;
    long long v18 = *(void **)(a6 + 8);
    if (*(void *)(a6 + 32) < v68)
    {
      if (v18)
      {
        if (*(unsigned char *)(a6 + 24)) {
          MEMORY[0x2166C5D70]();
        }
      }
      operator new[]();
    }
    *(_DWORD *)(a6 + 16) = v16;
    *(_DWORD *)(a6 + 20) = v15;
    memcpy(v18, 0, 8 * v16 * (unint64_t)v15);
    float64x2_t v69 = off_26C6875D0;
    if (v70 && v72)
    {
      MEMORY[0x2166C5D70]();
      uint64_t v70 = 0;
      unint64_t v73 = 0;
      char v72 = 0;
    }
    unint64_t v71 = 0;
    uint64_t v64 = off_26C6875D0;
    if (v65 && v67)
    {
      MEMORY[0x2166C5D70]();
      uint64_t v65 = 0;
      unint64_t v68 = 0;
      char v67 = 0;
    }
    unint64_t v66 = 0;
    char v52 = off_26C6875D0;
    if (v53 && v56) {
      MEMORY[0x2166C5D70]();
    }
    BOOL v58 = off_26C6875D0;
    if (v59 && v62) {
      MEMORY[0x2166C5D70]();
    }
    unsigned int v13 = v76;
    unsigned int v14 = v77;
  }
  uint64_t v19 = *(void *)(a3 + 8);
  unsigned int v20 = *(_DWORD *)(a3 + 16);
  unsigned int v21 = *(_DWORD *)(a3 + 20);
  BOOL v47 = off_26C6875D0;
  uint64_t v48 = v19;
  unint64_t v51 = 8 * v20 * (unint64_t)v21;
  unint64_t v49 = __PAIR64__(v21, v20);
  char v50 = 0;
  double v42 = off_26C6875D0;
  uint64_t v43 = v75;
  unint64_t v46 = 8 * v13 * (unint64_t)v14;
  unint64_t v44 = __PAIR64__(v14, v13);
  char v45 = 0;
  Algo::atan2((uint64_t)&v47, (uint64_t)&v42, a5);
  double v42 = off_26C6875D0;
  if (v43 && v45)
  {
    MEMORY[0x2166C5D70]();
    uint64_t v43 = 0;
    unint64_t v46 = 0;
    char v45 = 0;
  }
  unint64_t v44 = 0;
  BOOL v47 = off_26C6875D0;
  if (v48 && v50)
  {
    MEMORY[0x2166C5D70]();
    uint64_t v48 = 0;
    unint64_t v51 = 0;
    char v50 = 0;
  }
  unint64_t v49 = 0;
  uint64_t v22 = *(void *)(a2 + 8);
  unsigned int v23 = *(_DWORD *)(a2 + 16);
  unsigned int v24 = *(_DWORD *)(a2 + 20);
  double v37 = off_26C6875D0;
  uint64_t v38 = v22;
  unint64_t v41 = 8 * v23 * (unint64_t)v24;
  unint64_t v39 = __PAIR64__(v24, v23);
  char v40 = 0;
  uint64_t v25 = *(void *)(a1 + 8);
  unsigned int v26 = *(_DWORD *)(a1 + 16);
  unsigned int v27 = *(_DWORD *)(a1 + 20);
  uint64_t v32 = off_26C6875D0;
  uint64_t v33 = v25;
  unint64_t v36 = 8 * v26 * (unint64_t)v27;
  unint64_t v34 = __PAIR64__(v27, v26);
  char v35 = 0;
  Algo::atan2((uint64_t)&v37, (uint64_t)&v32, a4);
  uint64_t v32 = off_26C6875D0;
  if (v33 && v35)
  {
    MEMORY[0x2166C5D70]();
    uint64_t v33 = 0;
    unint64_t v36 = 0;
    char v35 = 0;
  }
  unint64_t v34 = 0;
  double v37 = off_26C6875D0;
  if (v38 && v40)
  {
    MEMORY[0x2166C5D70]();
    uint64_t v38 = 0;
    unint64_t v41 = 0;
    char v40 = 0;
  }
  unint64_t v39 = 0;
  BOOL v74 = off_26C6875D0;
  if (v75 && v78)
  {
    MEMORY[0x2166C5D70]();
    uint64_t v75 = 0;
    unint64_t v79 = 0;
    char v78 = 0;
  }
  return 0;
}

void sub_215F3C59C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  Matrix<double>::~Matrix(v37 - 168);
  Matrix<double>::~Matrix(v37 - 208);
  Matrix<double>::~Matrix((uint64_t)&a37);
  Matrix<double>::~Matrix(v37 - 248);
  Matrix<double>::~Matrix(v37 - 128);
  _Unwind_Resume(a1);
}

uint64_t Algo::LinearSpace@<X0>(Algo *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = off_26C6875D0;
  if (this) {
    operator new[]();
  }
  uint64_t result = 0;
  *(_DWORD *)(a2 + 16) = 1;
  *(_DWORD *)(a2 + 20) = 0;
  *(unsigned char *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)a2 = &unk_26C6874F0;
  *(void *)(a2 + 8) = 0;
  return result;
}

uint64_t Algo::LinearSpaceByStep@<X0>(Algo *this@<X0>, double a2@<D0>, double a3@<D1>, uint64_t a4@<X8>)
{
  unsigned int v4 = (int)(a3 - a2) / this;
  *(void *)a4 = off_26C6875D0;
  unsigned int v5 = v4 + 1;
  if (v4 != -1) {
    operator new[]();
  }
  uint64_t result = 0;
  *(_DWORD *)(a4 + 16) = 1;
  *(_DWORD *)(a4 + 20) = v5;
  *(unsigned char *)(a4 + 24) = v5 != 0;
  *(void *)(a4 + 32) = 0;
  *(void *)a4 = &unk_26C6874F0;
  *(void *)(a4 + 8) = 0;
  return result;
}

uint64_t Algo::Fspecial@<X0>(int a1@<W0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)a3 = off_26C6875D0;
  if (a2 * a2) {
    operator new[]();
  }
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 16) = a2;
  *(_DWORD *)(a3 + 20) = a2;
  *(unsigned char *)(a3 + 24) = 0;
  *(void *)(a3 + 32) = 8 * a2 * a2;
  if (a1) {
    return 0;
  }
  if (a2) {
    operator new[]();
  }
  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 20) = 0;
  unint64_t v4 = *(void *)(a3 + 8);
  uint64_t v5 = (*(_DWORD *)(a3 + 20) * *(_DWORD *)(a3 + 16));
  if (v5)
  {
    unint64_t v6 = v4 + 8 * v5;
    if (v6 <= v4 + 8) {
      unint64_t v6 = v4 + 8;
    }
    unint64_t v7 = v6 + ~v4;
    if (v7 >= 8)
    {
      uint64_t v9 = (v7 >> 3) + 1;
      uint64_t v10 = v9 & 0x3FFFFFFFFFFFFFFELL;
      unsigned int v11 = *(long double **)(a3 + 8);
      uint64_t v12 = v9 & 0x3FFFFFFFFFFFFFFELL;
      do
      {
        long long __x = *(_OWORD *)v11;
        long double v29 = exp(v11[1]);
        *(double *)&long long v13 = exp(*(long double *)&__x);
        *((long double *)&v13 + 1) = v29;
        *(_OWORD *)unsigned int v11 = v13;
        v11 += 2;
        v12 -= 2;
      }
      while (v12);
      if (v9 == v10)
      {
LABEL_17:
        unint64_t v4 = *(void *)(a3 + 8);
        if ((int)v5 >= 1)
        {
          double v15 = -2147483650.0;
          unsigned int v16 = *(double **)(a3 + 8);
          do
          {
            double v17 = *v16++;
            double v18 = v17;
            if (v17 > v15) {
              double v15 = v18;
            }
          }
          while ((unint64_t)v16 < v4 + 8 * (int)v5);
        }
        goto LABEL_22;
      }
      unsigned int v8 = (long double *)(v4 + 8 * v10);
    }
    else
    {
      unsigned int v8 = *(long double **)(a3 + 8);
    }
    unsigned int v14 = (double *)(v4 + 8 * v5);
    do
    {
      long double *v8 = exp(*v8);
      ++v8;
    }
    while (v8 < v14);
    goto LABEL_17;
  }
LABEL_22:
  if (!v5) {
    return 0;
  }
  unint64_t v19 = v4 + 8 * v5;
  unsigned int v20 = (double *)(v4 + 8);
  if (v19 > v4 + 8) {
    unsigned int v20 = (double *)(v4 + 8 * v5);
  }
  unint64_t v21 = (unint64_t)v20 + ~v4;
  if (v21 < 0x18) {
    goto LABEL_30;
  }
  uint64_t v22 = (v21 >> 3) + 1;
  float64x2_t v23 = (float64x2_t)vdupq_lane_s64(0, 0);
  unsigned int v24 = (float64x2_t *)(v4 + 16);
  uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    float64x2_t v26 = vdivq_f64(*v24, v23);
    v24[-1] = vdivq_f64(v24[-1], v23);
    *unsigned int v24 = v26;
    v24 += 2;
    v25 -= 4;
  }
  while (v25);
  if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
  {
    v4 += 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
    do
    {
LABEL_30:
      *(double *)unint64_t v4 = *(double *)v4 / 0.0;
      v4 += 8;
    }
    while (v4 < v19);
  }
  return 0;
}

void sub_215F3D844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  Matrix<double>::~Matrix((uint64_t)&a28);
  MatrixNxPts<1u,double>::~MatrixNxPts(v29 - 224);
  Matrix<double>::~Matrix(v29 - 184);
  Matrix<double>::~Matrix(v29 - 144);
  Matrix<double>::~Matrix(v28);
  _Unwind_Resume(a1);
}

void sub_215F3D8C0()
{
}

uint64_t Algo::StdFilter(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if ((int)a2 <= 0) {
    __assert_rtn("StdFilter", "Algo.cpp", 627, "windowSize > 0");
  }
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  unsigned int v5 = *(_DWORD *)(a1 + 20);
  if (*(void *)(a3 + 32) < 8 * v6 * (unint64_t)v5)
  {
    if (*(void *)(a3 + 8))
    {
      if (*(unsigned char *)(a3 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a3 + 16) = v6;
  *(_DWORD *)(a3 + 20) = v5;
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  unsigned int v8 = *(_DWORD *)(a1 + 20);
  if (v8 * v7) {
    operator new[]();
  }
  unsigned int v54 = *(_DWORD *)(a1 + 16);
  if (8 * v7 * (unint64_t)v8) {
    operator new[]();
  }
  uint64_t v9 = 0;
  if (v8)
  {
    uint64_t v10 = 0;
    uint64_t v11 = *(void *)(a1 + 8);
    double v12 = 0.0;
    unsigned int v13 = v8;
    do
    {
      double v12 = v12 + *(double *)((char *)v10 + v11);
      *v10++ = v12;
      --v13;
    }
    while (v13);
    if (v7 >= 2)
    {
      unsigned int v14 = (double *)((char *)v10 + v11);
      for (int i = 1; i != v7; ++i)
      {
        double v16 = 0.0;
        unsigned int v17 = v8;
        do
        {
          double v18 = *v14++;
          double v16 = v16 + v18;
          double v19 = *v9++;
          *v10++ = v16 + v19;
          --v17;
        }
        while (v17);
      }
    }
  }
  unsigned int v20 = 0;
  if (8 * v7 * (unint64_t)v8) {
    operator new[]();
  }
  if (v8)
  {
    double v21 = 0.0;
    uint64_t v22 = 0;
    unsigned int v23 = v8;
    do
    {
      double v24 = *v22++;
      double v21 = v21 + v24;
      *v20++ = v21;
      --v23;
    }
    while (v23);
    if (v7 >= 2)
    {
      int v25 = 1;
      float64x2_t v26 = 0;
      do
      {
        double v27 = 0.0;
        unsigned int v28 = v8;
        do
        {
          double v29 = *v22++;
          double v27 = v27 + v29;
          double v30 = *v26++;
          *v20++ = v27 + v30;
          --v28;
        }
        while (v28);
        ++v25;
      }
      while (v25 != v7);
    }
  }
  unsigned int v31 = a2 >> 1;
  uint64_t v32 = (a2 >> 1) + 1;
  int v33 = v6 - (a2 >> 1);
  if ((int)v32 < v33 && (int)v32 < (int)(v5 - v31))
  {
    double v34 = (double)(int)(a2 * a2);
    double v35 = sqrt(v34 / (v34 + -1.0));
    unsigned int v53 = a2 - v31;
    unint64_t v36 = (unint64_t)a2 >> 1;
    uint64_t v37 = 8 * v36 + 8;
    unsigned int v38 = v31 + v36;
    int v39 = v31 + v36 + 1;
    int v40 = v39 - a2;
    uint64_t v41 = 8 * (v39 - a2);
    int v42 = (2 * v31) | 1;
    unsigned int v43 = v42 - a2;
    uint64_t v44 = 8 * v38 + 8;
    unsigned int v45 = v31 + 1;
    do
    {
      if (v54 <= v45 + v31 || v7 <= v45 - v53 || v7 <= v45 + v31 || v7 <= v45 - v53) {
LABEL_45:
      }
        __assert_rtn("operator()", "Matrix.hpp", 120, "row < m_rows && col < m_cols");
      uint64_t v46 = 0;
      uint64_t v47 = 8 * v8 * v42;
      uint64_t v48 = v41 + v47;
      uint64_t v49 = v44 + v47;
      do
      {
        if (v8 <= v39 + (int)v46) {
          goto LABEL_45;
        }
        if (v8 <= v40 + (int)v46) {
          goto LABEL_45;
        }
        if (*(_DWORD *)(a3 + 16) <= v45) {
          goto LABEL_45;
        }
        unint64_t v50 = *(unsigned int *)(a3 + 20);
        if (v32 + v46 >= v50) {
          goto LABEL_45;
        }
        double v51 = *(double *)(v49 + 8 * v46)
            - *(double *)(v44 + 8 * v8 * v43 + 8 * v46)
            - *(double *)(v48 + 8 * v46)
            + *(double *)(v41 + 8 * v8 * v43 + 8 * v46);
        *(double *)(*(void *)(a3 + 8) + 8 * v45 * v50 + v37 + 8 * v46) = v35
                                                                                         * sqrt((*(double *)(v44 + 8 * v8 * v42 + 8 * v46)- *(double *)(v44 + 8 * v8 * v43 + 8 * v46)- *(double *)(v41 + 8 * v8 * v42 + 8 * v46)+ *(double *)(v41 + 8 * v8 * v43 + 8 * v46))/ v34- v51 * (v51 / v34) / v34);
        ++v46;
      }
      while ((int)(v5 - v31) > (int)v32 + (int)v46);
      ++v45;
      ++v43;
      ++v42;
    }
    while (v45 != v33);
  }
  return 0;
}

void sub_215F3E09C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  if (a14 && a16) {
    MEMORY[0x2166C5D70]();
  }
  if (a19 && a21) {
    MEMORY[0x2166C5D70]();
  }
  if (a24)
  {
    if (a26) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t Algo::NormXcorr2d(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = *(_DWORD *)(a2 + 16);
  unsigned int v6 = *(_DWORD *)(a2 + 20);
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  uint64_t v8 = *(unsigned int *)(a1 + 20);
  unint64_t v9 = *(void *)(a3 + 8);
  if (*(void *)(a3 + 32) < 8 * v5 * (unint64_t)v6)
  {
    if (v9)
    {
      if (*(unsigned char *)(a3 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  int v161 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a3 + 16) = v5;
  *(_DWORD *)(a3 + 20) = v6;
  if ((int)(v6 * v5) >= 1)
  {
    unint64_t v10 = v9 + 8 * v6 * v5;
    if (v10 <= v9 + 8) {
      unint64_t v10 = v9 + 8;
    }
    bzero((void *)v9, ((v10 + ~v9) & 0xFFFFFFFFFFFFFFF8) + 8);
  }
  unsigned int v11 = *(_DWORD *)(a2 + 16);
  unsigned int v12 = *(_DWORD *)(a2 + 20);
  if (v12 * v11) {
    operator new[]();
  }
  unsigned int v166 = *(_DWORD *)(a2 + 16);
  if (8 * v11 * (unint64_t)v12) {
    operator new[]();
  }
  unsigned int v13 = 0;
  unsigned int v164 = *(_DWORD *)(a2 + 16);
  unsigned int v165 = *(_DWORD *)(a2 + 20);
  if (v12)
  {
    unsigned int v14 = 0;
    uint64_t v15 = *(void *)(a2 + 8);
    double v16 = 0.0;
    int v17 = *(_DWORD *)(a2 + 20);
    do
    {
      double v16 = v16 + *(double *)((char *)v14 + v15);
      *v14++ = v16;
      --v17;
    }
    while (v17);
    if (v11 >= 2)
    {
      double v18 = (double *)((char *)v14 + v15);
      for (int i = 1; i != v11; ++i)
      {
        double v20 = 0.0;
        unsigned int v21 = v12;
        do
        {
          double v22 = *v18++;
          double v20 = v20 + v22;
          double v23 = *v13++;
          *v14++ = v20 + v23;
          --v21;
        }
        while (v21);
      }
    }
  }
  double v24 = 0;
  if (8 * v11 * (unint64_t)v12) {
    operator new[]();
  }
  unsigned int v163 = v12;
  if (v12)
  {
    double v25 = 0.0;
    float64x2_t v26 = 0;
    unsigned int v27 = v12;
    do
    {
      double v28 = *v26++;
      double v25 = v25 + v28;
      *v24++ = v25;
      --v27;
    }
    while (v27);
    if (v11 >= 2)
    {
      int v29 = 1;
      double v30 = 0;
      do
      {
        double v31 = 0.0;
        unsigned int v32 = v12;
        do
        {
          double v33 = *v26++;
          double v31 = v31 + v33;
          double v34 = *v30++;
          *v24++ = v31 + v34;
          --v32;
        }
        while (v32);
        ++v29;
      }
      while (v29 != v11);
    }
  }
  uint64_t v35 = *(void *)(a1 + 8);
  int v36 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
  int v37 = v36;
  if (v36 < 1)
  {
    double v41 = 0.0;
    goto LABEL_44;
  }
  unint64_t v38 = v35 + 8 * v36;
  int v39 = (double *)(v35 + 8);
  if (v38 <= v35 + 8) {
    unint64_t v38 = v35 + 8;
  }
  unint64_t v40 = v38 + ~v35;
  double v41 = 0.0;
  int v42 = *(double **)(a1 + 8);
  if (v40 < 8) {
    goto LABEL_40;
  }
  uint64_t v43 = (v40 >> 3) + 1;
  uint64_t v44 = v43 & 0x3FFFFFFFFFFFFFFELL;
  do
  {
    double v41 = v41 + *(v39 - 1) + *v39;
    v39 += 2;
    v44 -= 2;
  }
  while (v44);
  if (v43 != (v43 & 0x3FFFFFFFFFFFFFFELL))
  {
    int v42 = (double *)(v35 + 8 * (v43 & 0x3FFFFFFFFFFFFFFELL));
LABEL_40:
    unint64_t v45 = v35 + 8 * v36;
    do
    {
      double v46 = *v42++;
      double v41 = v41 + v46;
    }
    while ((unint64_t)v42 < v45);
  }
LABEL_44:
  if (v37) {
    operator new[]();
  }
  if (v8 * v7) {
    operator new[]();
  }
  if ((int)v7 >= 0) {
    int v47 = v7;
  }
  else {
    int v47 = v7 + 1;
  }
  if ((int)v7 >= 1 && (int)v8 >= 1)
  {
    unsigned int v48 = 0;
    uint64_t v49 = 0;
    double v50 = v41 / (double)0;
    double v51 = sqrt(0.0 / (double)0 - v50 * v50);
    uint64_t v52 = *(unsigned int *)(a1 + 16);
    do
    {
      if (v49 == v52) {
LABEL_138:
      }
        __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
      unsigned int v53 = (double *)(8 * v48);
      uint64_t v54 = *(unsigned int *)(a1 + 20);
      uint64_t v55 = 8 * (v54 * v49);
      uint64_t v56 = v8;
      do
      {
        if (!v54) {
          goto LABEL_138;
        }
        double *v53 = (*(double *)(*(void *)(a1 + 8) + v55) - v50) / v51;
        v55 += 8;
        ++v53;
        --v54;
        --v56;
      }
      while (v56);
      ++v49;
      v48 += v8;
    }
    while (v49 != (v7 & ~((int)v7 >> 31)));
  }
  int v57 = v47 >> 1;
  int v58 = v57 + 1;
  if (v57 + 1 < (int)(v5 - v57))
  {
    int v59 = (int)v8 >= 0 ? v8 : (int)v8 + 1;
    int v60 = v59 >> 1;
    int v61 = (v59 >> 1) + 1;
    uint64_t v159 = (v161 - (v59 >> 1));
    if (v61 < (int)v159)
    {
      double v62 = (double)0;
      int v63 = v7 - v57;
      unsigned int v64 = v11;
      int v149 = v61 - v57;
      int v148 = v57 + ~v60;
      unsigned int v65 = v57 + 2;
      uint64_t v66 = (v57 + 3);
      if (v57 + 2 >= v8) {
        unsigned int v67 = v8;
      }
      else {
        unsigned int v67 = v57 + 2;
      }
      uint64_t v68 = v66 & 0xFFFFFFFC;
      int v69 = v57;
      int v151 = v60;
      unint64_t v150 = (v60 + 1);
      do
      {
        unsigned int v70 = v58;
        unsigned int v71 = v58 + v57;
        unsigned int v72 = v58 - v63;
        BOOL v73 = v164 > v58 - v63;
        if (v64 <= v71 || v166 <= v72 || v164 <= v71) {
          goto LABEL_139;
        }
        uint64_t v157 = 8 * v163 * v72;
        uint64_t v158 = 8 * v163 * v71;
        int v162 = v70 - v57;
        int v156 = v69 + 4;
        uint64_t v155 = 8 * v165 * v71;
        uint64_t v74 = 8 * v165 * v72;
        if (v163 <= v165)
        {
          if (!v73) {
LABEL_139:
          }
            __assert_rtn("operator()", "Matrix.hpp", 120, "row < m_rows && col < m_cols");
          unint64_t v75 = v150;
          int v77 = v148;
          unsigned int v76 = v149;
          int v78 = v151;
          while (1)
          {
            if (v163 <= v57 + (int)v75) {
              goto LABEL_139;
            }
            int v79 = v75;
            if (v163 <= (int)v75 - v63) {
              goto LABEL_139;
            }
            uint64_t v80 = v76;
            uint64_t v81 = 8 * (v57 + v75);
            uint64_t v82 = 8 * (v75 - v63);
            double v83 = (*(double *)(v81 + v155) - *(double *)(v81 + v74) - *(double *)(v82 + v155) + *(double *)(v82 + v74))
                / v62;
            double v84 = sqrt((*(double *)(v81 + v158)- *(double *)(v81 + v157)- *(double *)(v82 + v158)+ *(double *)(v82 + v157))/ v62- v83 * v83);
            double v85 = 0.0;
            if (v84 > 0.0 && v162 < v156)
            {
              unsigned int v154 = v75 - v57;
              if ((int)v75 - v57 < v78 + 4) {
                break;
              }
            }
LABEL_99:
            int v63 = v7 - v57;
            if (*(_DWORD *)(a3 + 16) <= v70) {
              goto LABEL_139;
            }
            unint64_t v110 = *(unsigned int *)(a3 + 20);
            if (v75 >= v110) {
              goto LABEL_139;
            }
            *(double *)(*(void *)(a3 + 8) + 8 * v75++ + 8 * v110 * v70) = v85 / v62;
            unsigned int v76 = v80 + 1;
            --v77;
            int v78 = v79;
            if (v75 == v159) {
              goto LABEL_102;
            }
          }
          unsigned int v87 = 0;
          uint64_t v88 = 0;
          uint64_t v89 = 8 * v76;
          float64x2_t v90 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v83, 0);
          float64x2_t v91 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v84, 0);
          unsigned int v92 = v70 - v57;
          while (1)
          {
            if (v92 >= *(_DWORD *)(a2 + 16)) {
              goto LABEL_142;
            }
            unsigned int v93 = *(_DWORD *)(a2 + 20);
            if (v88 == v7) {
              goto LABEL_140;
            }
            int v94 = v93 <= v80 ? v80 : *(_DWORD *)(a2 + 20);
            if (v77 + v94 <= v67) {
              goto LABEL_142;
            }
            if (v8 <= v65) {
              goto LABEL_141;
            }
            uint64_t v95 = 8 * v87;
            uint64_t v96 = *(void *)(a2 + 8);
            if (v66 >= 4)
            {
              size_t v99 = (float64x2_t *)(v95 + 16);
              uint64_t v100 = (float64x2_t *)(v96 + v89 + 8 * v93 * v92 + 16);
              uint64_t v101 = v66 & 0xFFFFFFFC;
              do
              {
                float64x2_t v102 = vdivq_f64(vmulq_f64(vsubq_f64(v100[-1], v90), v99[-1]), v91);
                float64x2_t v103 = vdivq_f64(vmulq_f64(vsubq_f64(*v100, v90), *v99), v91);
                double v85 = v85 + v102.f64[0] + v102.f64[1] + v103.f64[0] + v103.f64[1];
                v100 += 2;
                v99 += 2;
                v101 -= 4;
              }
              while (v101);
              uint64_t v98 = v68 + v80;
              uint64_t v97 = v66 & 0xFFFFFFFC;
              if (v68 == v66) {
                goto LABEL_83;
              }
            }
            else
            {
              uint64_t v97 = 0;
              uint64_t v98 = v80;
            }
            unint64_t v104 = (double *)(v96 + 8 * v98 + 8 * v93 * v92);
            uint64_t v105 = v66 - v97;
            double v106 = (double *)(v95 + 8 * v97);
            do
            {
              double v107 = *v104++;
              double v108 = v107 - v83;
              double v109 = *v106++;
              double v85 = v85 + v108 * v109 / v84;
              --v105;
            }
            while (v105);
LABEL_83:
            ++v92;
            ++v88;
            v87 += v8;
            if (v88 == v66) {
              goto LABEL_99;
            }
          }
        }
        if (!v73) {
          goto LABEL_139;
        }
        unint64_t v111 = v150;
        int v113 = v148;
        unsigned int v112 = v149;
        int v114 = v151;
        do
        {
          uint64_t v115 = (v57 + v111);
          if (v163 <= v115) {
            goto LABEL_139;
          }
          int v116 = v111;
          if (v163 <= (int)v111 - v63 || v165 <= v115 || v165 <= (int)v111 - v63) {
            goto LABEL_139;
          }
          uint64_t v117 = v112;
          uint64_t v118 = 8 * v115;
          uint64_t v119 = 8 * (v111 - v63);
          double v120 = (*(double *)(v118 + v155) - *(double *)(v118 + v74) - *(double *)(v119 + v155) + *(double *)(v119 + v74))
               / v62;
          double v121 = sqrt((*(double *)(v118 + v158)- *(double *)(v118 + v157)- *(double *)(v119 + v158)+ *(double *)(v119 + v157))/ v62- v120 * v120);
          double v122 = 0.0;
          if (v121 > 0.0 && v162 < v156)
          {
            unsigned int v154 = v111 - v57;
            if ((int)v111 - v57 < v114 + 4)
            {
              unsigned int v124 = 0;
              uint64_t v125 = 0;
              uint64_t v153 = 8 * v112;
              float64x2_t v126 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v120, 0);
              uint64_t v152 = v68 + v112;
              float64x2_t v127 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v121, 0);
              unsigned int v128 = v70 - v57;
              do
              {
                if (v128 >= *(_DWORD *)(a2 + 16)) {
                  goto LABEL_142;
                }
                unsigned int v93 = *(_DWORD *)(a2 + 20);
                if (v125 == v7)
                {
LABEL_140:
                  if (v154 >= v93) {
LABEL_142:
                  }
                    int v147 = 126;
                  else {
LABEL_141:
                  }
                    int v147 = 120;
                  __assert_rtn("operator()", "Matrix.hpp", v147, "row < m_rows && col < m_cols");
                }
                if (v93 <= v117) {
                  int v129 = v117;
                }
                else {
                  int v129 = *(_DWORD *)(a2 + 20);
                }
                if (v113 + v129 <= v67) {
                  goto LABEL_142;
                }
                if (v8 <= v65) {
                  goto LABEL_141;
                }
                uint64_t v130 = 8 * v124;
                uint64_t v131 = *(void *)(a2 + 8);
                if (v66 >= 4)
                {
                  int64_t v134 = (float64x2_t *)(v130 + 16);
                  double v135 = (float64x2_t *)(v131 + v153 + 8 * v93 * v128 + 16);
                  uint64_t v136 = v66 & 0xFFFFFFFC;
                  do
                  {
                    float64x2_t v137 = vdivq_f64(vmulq_f64(vsubq_f64(v135[-1], v126), v134[-1]), v127);
                    float64x2_t v138 = vdivq_f64(vmulq_f64(vsubq_f64(*v135, v126), *v134), v127);
                    double v122 = v122 + v137.f64[0] + v137.f64[1] + v138.f64[0] + v138.f64[1];
                    v135 += 2;
                    v134 += 2;
                    v136 -= 4;
                  }
                  while (v136);
                  uint64_t v133 = v152;
                  uint64_t v132 = v66 & 0xFFFFFFFC;
                  if (v68 == v66) {
                    goto LABEL_117;
                  }
                }
                else
                {
                  uint64_t v132 = 0;
                  uint64_t v133 = v117;
                }
                uint64_t v139 = (double *)(v131 + 8 * v133 + 8 * v93 * v128);
                uint64_t v140 = v66 - v132;
                double v141 = (double *)(v130 + 8 * v132);
                do
                {
                  double v142 = *v139++;
                  double v143 = v142 - v120;
                  double v144 = *v141++;
                  double v122 = v122 + v143 * v144 / v121;
                  --v140;
                }
                while (v140);
LABEL_117:
                ++v128;
                ++v125;
                v124 += v8;
              }
              while (v125 != v66);
            }
          }
          int v63 = v7 - v57;
          if (*(_DWORD *)(a3 + 16) <= v70) {
            goto LABEL_139;
          }
          unint64_t v145 = *(unsigned int *)(a3 + 20);
          if (v111 >= v145) {
            goto LABEL_139;
          }
          *(double *)(*(void *)(a3 + 8) + 8 * v111++ + 8 * v145 * v70) = v122 / v62;
          unsigned int v112 = v117 + 1;
          --v113;
          int v114 = v116;
        }
        while (v111 != v159);
LABEL_102:
        int v58 = v70 + 1;
        int v69 = v70;
        unsigned int v64 = v166;
      }
      while (v70 + 1 != v5 - v57);
    }
  }
  return 0;
}

void sub_215F3EFE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  if (a36 && a38) {
    MEMORY[0x2166C5D70]();
  }
  *(void *)(v38 - 184) = a20;
  if (*(void *)(v38 - 176) && *(unsigned char *)(v38 - 160)) {
    MEMORY[0x2166C5D70]();
  }
  *(void *)(v38 - 144) = a21;
  if (*(void *)(v38 - 136))
  {
    if (*(unsigned char *)(v38 - 120)) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(exception_object);
}

void Algo::FundMatrix3x3(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 20)) {
    operator new[]();
  }
  if (*(_DWORD *)(a2 + 20)) {
    operator new[]();
  }
  Algo::Normalize2DPts();
}

void sub_215F4170C(_Unwind_Exception *a1)
{
}

void Algo::Normalize2DPts()
{
  v0 = off_26C6875D0;
  operator new[]();
}

void sub_215F41DD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  MatrixNxPts<3u,double>::~MatrixNxPts((uint64_t)va);
  MatrixNxPts<3u,double>::~MatrixNxPts((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t MatrixNxPts<9u,double>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = off_26C6875D0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

uint64_t MatrixMxN<3u,3u,double>::operator*(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  if (*(_DWORD *)(a3 + 16) == 3)
  {
    uint64_t v4 = *(unsigned int *)(a3 + 20);
    *(void *)uint64_t result = off_26C6875D0;
    if (v4) {
      operator new[]();
    }
    uint64_t result = 0;
    *(void *)(v3 + 8) = 0;
    *(_DWORD *)(v3 + 16) = 3;
    *(_DWORD *)(v3 + 20) = 0;
    *(unsigned char *)(v3 + 24) = 0;
    *(void *)(v3 + 32) = 24 * v4;
  }
  else
  {
    *(void *)(result + 32) = 0;
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)uint64_t result = off_26C6875D0;
    *(unsigned char *)(result + 24) = 0;
  }
  return result;
}

void MatrixNxPts<9u,double>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = off_26C6875D0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  JUMPOUT(0x2166C5D90);
}

uint64_t Algo::RandomSample(unsigned int a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a3 + 20);
  if (v3)
  {
    unsigned int v4 = 0;
    float v5 = (float)a1;
    uint64_t v6 = a2 + 8;
    unint64_t v7 = *(void *)(a2 + 2504);
    do
    {
      unint64_t v8 = (v7 + 1) % 0x270;
      uint64_t v9 = 4 * v7;
      unsigned int v10 = *(_DWORD *)(v6 + 4 * ((v7 + 397) % 0x270)) ^ ((*(_DWORD *)(v6 + 4 * v8) & 0x7FFFFFFE | *(_DWORD *)(v6 + 4 * v7) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(v6 + 4 * v8) << 31) >> 31) & 0x9908B0DF;
      *(_DWORD *)(v6 + v9) = v10;
      *(void *)(a2 + 2504) = v8;
      unsigned int v11 = ((v10 ^ (v10 >> 11)) << 7) & 0x9D2C5680 ^ v10 ^ (v10 >> 11);
      unsigned int v12 = (float)((float)((float)((float)((v11 << 15) & 0xEFC60000 ^ v11 ^ (((v11 << 15) & 0xEFC60000 ^ v11) >> 18))
                                                * 2.3283e-10)
                                        + 0.0)
                                * v5);
      if (v4)
      {
        uint64_t v13 = 0;
        uint64_t v14 = *(void *)(a3 + 8);
        uint64_t v15 = v4;
        while (*(_DWORD *)(v14 + 4 * v13) != v12)
        {
          if (v4 == ++v13) {
            goto LABEL_3;
          }
        }
      }
      else
      {
        LODWORD(v13) = 0;
      }
      if (v13 == v4)
      {
        uint64_t v14 = *(void *)(a3 + 8);
        uint64_t v15 = v4;
LABEL_3:
        *(_DWORD *)(v14 + 4 * v15) = v12;
        ++v4;
      }
      unint64_t v7 = v8;
    }
    while (v4 < v3);
  }
  return 0;
}

uint64_t Algo::FundDist(uint64_t (***a1)(), uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5, double a6)
{
  int v11 = *(_DWORD *)(a2 + 20);
  uint64_t v136 = off_26C6875D0;
  if (v11) {
    operator new[]();
  }
  unsigned int v138 = 1;
  unsigned int v139 = 0;
  char v140 = 0;
  uint64_t v141 = 0;
  uint64_t v136 = (uint64_t (**)())&unk_26C6874F0;
  uint64_t v137 = 0;
  MatrixMxN<3u,3u,double>::operator*((uint64_t)&v115, (uint64_t)a1, a2);
  unint64_t v131 = v116;
  unsigned int v133 = HIDWORD(v117);
  char v134 = (char)v118;
  uint64_t v135 = v119;
  unsigned int v12 = a1[1];
  uint64_t v13 = a1[2];
  unint64_t v14 = (unint64_t)a1[3];
  uint64_t v115 = *a1;
  unint64_t v116 = v14;
  uint64_t v15 = a1[4];
  double v16 = a1[5];
  double v121 = v13;
  double v122 = v16;
  int v17 = a1[7];
  uint64_t v117 = a1[6];
  uint64_t v118 = v12;
  uint64_t v130 = (uint64_t (**)())&unk_26C687550;
  int v132 = 3;
  uint64_t v119 = (uint64_t)v15;
  double v120 = v17;
  double v123 = a1[8];
  MatrixMxN<3u,3u,double>::operator*((uint64_t)&v142, (uint64_t)&v115, a3);
  double v22 = v143;
  int v23 = v145;
  int v126 = 3;
  unsigned int v127 = v145;
  char v128 = v146;
  uint64_t v129 = v147;
  unsigned int v124 = (uint64_t (**)())&unk_26C687550;
  uint64_t v125 = v143;
  uint64_t v24 = v132 * v133;
  if (v24)
  {
    unint64_t v25 = v131;
    unint64_t v26 = v131 + 8 * v24;
    if (v26 <= v131 + 8) {
      unint64_t v26 = v131 + 8;
    }
    unint64_t v27 = v26 + ~v131;
    double v28 = (double *)v131;
    if (v27 >= 0x18)
    {
      uint64_t v29 = (v27 >> 3) + 1;
      double v30 = (float64x2_t *)(v131 + 16);
      uint64_t v31 = v29 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        float64x2_t v32 = vmulq_f64(*v30, *v30);
        v30[-1] = vmulq_f64(v30[-1], v30[-1]);
        *double v30 = v32;
        v30 += 2;
        v31 -= 4;
      }
      while (v31);
      if (v29 == (v29 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_13;
      }
      double v28 = (double *)(v25 + 8 * (v29 & 0x3FFFFFFFFFFFFFFCLL));
    }
    unint64_t v33 = v25 + 8 * v24;
    do
    {
      *double v28 = *v28 * *v28;
      ++v28;
    }
    while ((unint64_t)v28 < v33);
LABEL_13:
    double v22 = v125;
  }
  if (!v23) {
    goto LABEL_24;
  }
  uint64_t v34 = (3 * v23);
  unint64_t v35 = (unint64_t)&v22->f64[v34];
  if (v35 <= (unint64_t)&v22->f64[1]) {
    unint64_t v35 = (unint64_t)&v22->f64[1];
  }
  unint64_t v36 = v35 + ~(unint64_t)v22;
  int v37 = (double *)v22;
  if (v36 < 0x18) {
    goto LABEL_22;
  }
  uint64_t v38 = (v36 >> 3) + 1;
  int v39 = v22 + 1;
  uint64_t v40 = v38 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    float64x2_t v41 = vmulq_f64(*v39, *v39);
    v39[-1] = vmulq_f64(v39[-1], v39[-1]);
    *int v39 = v41;
    v39 += 2;
    v40 -= 4;
  }
  while (v40);
  if (v38 != (v38 & 0x3FFFFFFFFFFFFFFCLL))
  {
    int v37 = &v22->f64[v38 & 0x3FFFFFFFFFFFFFFCLL];
LABEL_22:
    unint64_t v42 = (unint64_t)&v22->f64[v34];
    do
    {
      *int v37 = *v37 * *v37;
      ++v37;
    }
    while ((unint64_t)v37 < v42);
  }
LABEL_24:
  uint64_t v43 = v139;
  uint64_t v115 = off_26C6875D0;
  if (v138 * v139) {
    operator new[]();
  }
  uint64_t v44 = 8 * v139;
  char v146 = 0;
  uint64_t v147 = v44 * v138;
  double v142 = (uint64_t (**)())&unk_26C6874F0;
  double v143 = 0;
  int v144 = 1;
  int v145 = v139;
  unint64_t v45 = (double *)v131;
  unsigned int v46 = v133;
  uint64_t v47 = 8 * v133;
  LODWORD(v117) = 1;
  HIDWORD(v117) = v133;
  LOBYTE(v118) = 0;
  uint64_t v119 = v47;
  uint64_t v115 = (uint64_t (**)())&unk_26C6874F0;
  unint64_t v116 = v131;
  if (v133)
  {
    unint64_t v48 = v131 + v47;
    unint64_t v49 = v47 + v131;
    if (v47 + v131 <= v131 + 8) {
      unint64_t v49 = v131 + 8;
    }
    unint64_t v50 = v49 + ~v131;
    if (v50 >= 0x98)
    {
      unint64_t v53 = (v50 & 0xFFFFFFFFFFFFFFF8) + v131 + 8;
      if (v131 >= v53 + v47 || v48 >= v53)
      {
        uint64_t v55 = (v50 >> 3) + 1;
        uint64_t v56 = 8 * (v55 & 0x3FFFFFFFFFFFFFFCLL);
        double v51 = (double *)(v48 + v56);
        int v57 = (float64x2_t *)v131;
        uint64_t v58 = v55 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          double v18 = (char *)v57 + v47;
          float64x2_t v59 = vaddq_f64(v57[1], *(float64x2_t *)((char *)v57 + v47 + 16));
          float64x2_t *v57 = vaddq_f64(*v57, *(float64x2_t *)((char *)v57 + v47));
          v57[1] = v59;
          v57 += 2;
          v58 -= 4;
        }
        while (v58);
        if (v55 == (v55 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_42;
        }
        unint64_t v45 = (double *)((char *)v45 + v56);
      }
      else
      {
        double v51 = (double *)(v131 + v47);
      }
    }
    else
    {
      double v51 = (double *)(v131 + v47);
    }
    do
    {
      double v60 = *v51++;
      double *v45 = *v45 + v60;
      ++v45;
    }
    while ((unint64_t)v45 < v48);
LABEL_42:
    int v52 = (int)v117;
    goto LABEL_43;
  }
  int v52 = 1;
LABEL_43:
  int v61 = (double *)v125;
  uint64_t v62 = v127;
  if (v127 != v46 || v52 != 1) {
    __assert_rtn("doDimensionsMatchTo", "Matrix.hpp", 1043, "0");
  }
  if (v46)
  {
    unint64_t v63 = v116;
    unint64_t v64 = 8 * v127 + v116;
    if (v64 <= v116 + 8) {
      unint64_t v64 = v116 + 8;
    }
    unint64_t v65 = v64 + ~v116;
    if (v65 >= 0x88)
    {
      unint64_t v69 = (v65 & 0xFFFFFFFFFFFFFFF8) + 8;
      if (v116 >= (unint64_t)v125 + v69
        || (v70 = v116 + v69, uint64_t v66 = (double *)v116, (unint64_t)v125 >= v70))
      {
        uint64_t v71 = (v65 >> 3) + 1;
        uint64_t v72 = v71 & 0x3FFFFFFFFFFFFFFCLL;
        BOOL v73 = &v125->f64[v72];
        uint64_t v74 = (float64x2_t *)(v116 + 16);
        unint64_t v75 = v125 + 1;
        uint64_t v76 = v71 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          float64x2_t v77 = vaddq_f64(*v74, *v75);
          v74[-1] = vaddq_f64(v74[-1], v75[-1]);
          *uint64_t v74 = v77;
          v74 += 2;
          v75 += 2;
          v76 -= 4;
        }
        while (v76);
        if (v71 == (v71 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_59;
        }
        uint64_t v66 = (double *)(v63 + v72 * 8);
        int v61 = v73;
      }
    }
    else
    {
      uint64_t v66 = (double *)v116;
    }
    unint64_t v78 = v63 + 8 * v62;
    do
    {
      double v79 = *v61++;
      *uint64_t v66 = *v66 + v79;
      ++v66;
    }
    while ((unint64_t)v66 < v78);
LABEL_59:
    int v61 = (double *)v125;
    unsigned int v67 = v127;
    int v68 = (int)v117;
    goto LABEL_60;
  }
  unsigned int v67 = 0;
  int v68 = 1;
LABEL_60:
  uint64_t v80 = v67;
  uint64_t v81 = &v61[v80];
  if (v67 != v46 || v68 != 1) {
    __assert_rtn("doDimensionsMatchTo", "Matrix.hpp", 1043, "0");
  }
  if (v46)
  {
    unint64_t v82 = v116;
    unint64_t v83 = v80 * 8 + v116;
    if (v80 * 8 + v116 <= v116 + 8) {
      unint64_t v83 = v116 + 8;
    }
    unint64_t v84 = v83 + ~v116;
    if (v84 < 0x98)
    {
      double v85 = (double *)v116;
      goto LABEL_76;
    }
    double v86 = (float64x2_t *)&v61[v80];
    BOOL v87 = v116 >= (unint64_t)&v61[v80 + 1] + (v84 & 0xFFFFFFFFFFFFFFF8)
       || (unint64_t)v81 >= (v84 & 0xFFFFFFFFFFFFFFF8) + v116 + 8;
    double v85 = (double *)v116;
    if (!v87) {
      goto LABEL_76;
    }
    uint64_t v88 = (v84 >> 3) + 1;
    uint64_t v89 = 8 * (v88 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v81 = (double *)((char *)v81 + v89);
    float64x2_t v90 = (float64x2_t *)(v116 + 16);
    float64x2_t v91 = v86 + 1;
    uint64_t v92 = v88 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      float64x2_t v93 = vaddq_f64(*v90, *v91);
      v90[-1] = vaddq_f64(v90[-1], v91[-1]);
      float64x2_t *v90 = v93;
      v90 += 2;
      v91 += 2;
      v92 -= 4;
    }
    while (v92);
    if (v88 != (v88 & 0x3FFFFFFFFFFFFFFCLL))
    {
      double v85 = (double *)(v82 + v89);
LABEL_76:
      unint64_t v94 = v82 + 8 * v67;
      do
      {
        double v95 = *v81++;
        *double v85 = *v85 + v95;
        ++v85;
      }
      while ((unint64_t)v85 < v94);
    }
  }
  if (v46 != v43) {
    __assert_rtn("doDimensionsMatchTo", "Matrix.hpp", 1043, "0");
  }
  if (!v43)
  {
    *a5 = 0;
    goto LABEL_85;
  }
  uint64_t v96 = v143;
  uint64_t v97 = (double *)v116;
  unint64_t v98 = (unint64_t)v143 + v44;
  if (v98 <= (unint64_t)&v143->f64[1]) {
    unint64_t v98 = (unint64_t)&v143->f64[1];
  }
  unint64_t v99 = v98 + ~(unint64_t)v143;
  if (v99 < 0x78)
  {
    uint64_t v100 = (double *)v143;
    goto LABEL_112;
  }
  unint64_t v103 = (v99 & 0xFFFFFFFFFFFFFFF8) + 8;
  BOOL v104 = (unint64_t)v143 >= v116 + v103 || v116 >= (unint64_t)v143 + v103;
  uint64_t v100 = (double *)v143;
  if (!v104) {
    goto LABEL_112;
  }
  uint64_t v105 = (v99 >> 3) + 1;
  uint64_t v106 = v105 & 0x3FFFFFFFFFFFFFFCLL;
  double v107 = (double *)(v116 + v106 * 8);
  double v108 = v143 + 1;
  double v109 = (float64x2_t *)(v116 + 16);
  uint64_t v110 = v105 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    float64x2_t v111 = vdivq_f64(*v108, *v109);
    v108[-1] = vdivq_f64(v108[-1], v109[-1]);
    *double v108 = v111;
    v108 += 2;
    v109 += 2;
    v110 -= 4;
  }
  while (v110);
  if (v105 != (v105 & 0x3FFFFFFFFFFFFFFCLL))
  {
    uint64_t v100 = &v96->f64[v106];
    uint64_t v97 = v107;
    do
    {
LABEL_112:
      double v112 = *v97++;
      *uint64_t v100 = *v100 / v112;
      ++v100;
    }
    while (v100 < &v96->f64[v43]);
  }
  unsigned int v113 = 0;
  unint64_t v114 = 0;
  *a5 = 0;
  do
  {
    if (fabs(v143->f64[v114]) < a6)
    {
      *(_DWORD *)(*(void *)(a4 + 8) + 4 * v113) = v114;
      unsigned int v113 = *a5 + 1;
      *a5 = v113;
      LODWORD(v43) = v145;
    }
    ++v114;
  }
  while (v114 < v43);
LABEL_85:
  uint64_t v115 = off_26C6875D0;
  if (v116) {
    BOOL v101 = v118 == 0;
  }
  else {
    BOOL v101 = 1;
  }
  if (!v101) {
    MEMORY[0x2166C5D70](v116, 0x1000C8000313F17, v18, v19, v20, v21);
  }
  double v142 = off_26C6875D0;
  if (v143 && v146) {
    MEMORY[0x2166C5D70](v143, 0x1000C8000313F17, v18, v19, v20, v21);
  }
  unsigned int v124 = off_26C6875D0;
  if (v125 && v128) {
    MEMORY[0x2166C5D70](v125, 0x1000C8000313F17, v18, v19, v20, v21);
  }
  uint64_t v130 = off_26C6875D0;
  if (v131 && v134) {
    MEMORY[0x2166C5D70](v131, 0x1000C8000313F17, v18, v19, v20, v21);
  }
  uint64_t v136 = off_26C6875D0;
  if (v137 && v140) {
    MEMORY[0x2166C5D70](v137, 0x1000C8000313F17, v18, v19, v20, v21);
  }
  return 0;
}

void sub_215F42F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  MatrixNxPts<3u,double>::~MatrixNxPts((uint64_t)&a23);
  MatrixNxPts<3u,double>::~MatrixNxPts((uint64_t)&a28);
  MatrixNxPts<1u,double>::~MatrixNxPts(v28 - 176);
  _Unwind_Resume(a1);
}

void Algo::Ransac()
{
}

void sub_215F431F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  MatrixNxPts<1u,BOOL>::~MatrixNxPts((uint64_t)va);
  MatrixNxPts<1u,BOOL>::~MatrixNxPts((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t Algo::Ransac(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6, char a7, double a8, uint64_t a9, uint64_t a10, unsigned int *a11)
{
  unsigned int v15 = *(_DWORD *)(a1 + 20);
  double v60 = &unk_26C687590;
  unsigned int v16 = 5489;
  uint64_t v17 = 1;
  for (uint64_t i = 3; i != 626; ++i)
  {
    int v19 = 1812433253 * (v16 ^ (v16 >> 30));
    unsigned int v16 = v19 + v17;
    *((_DWORD *)&v60 + i) = i + v19 - 2;
    ++v17;
  }
  unsigned int v61 = a6;
  uint64_t v20 = 1;
  for (uint64_t j = 3; j != 626; ++j)
  {
    int v22 = 1812433253 * (a6 ^ (a6 >> 30));
    a6 = v22 + v20;
    *((_DWORD *)&v60 + j) = j + v22 - 2;
    ++v20;
  }
  unsigned int v23 = 0;
  char v33 = 0;
  uint64_t v62 = 0;
  *a11 = 0;
  uint64_t v59 = 0;
  char v58 = 0;
  BOOL v40 = a3 != 0;
  double v32 = (double)v15;
  uint64_t v37 = 24 * a3;
  double v24 = 1.0;
  do
  {
    if (v24 <= (double)v23) {
      break;
    }
    unsigned int v35 = v23;
    uint64_t v57 = 0;
    unsigned int v39 = 1;
    memset(v56, 0, sizeof(v56));
    do
    {
      double v51 = off_26C687610;
      if (a3) {
        operator new[]();
      }
      uint64_t v53 = 1;
      BOOL v54 = v40;
      uint64_t v55 = 0;
      double v51 = (uint64_t (**)())&unk_26C687510;
      __src = 0;
      if ((a7 & 1) == 0)
      {
        int v47 = 3;
        int v48 = 0;
        BOOL v49 = v40;
        uint64_t v50 = v37;
        v46[0] = &unk_26C687550;
        v46[1] = 0;
        int v42 = 3;
        int v43 = 0;
        BOOL v44 = v40;
        uint64_t v45 = v37;
        v41[0] = &unk_26C687550;
        v41[1] = 0;
        Algo::FundMatrix3x3((uint64_t)v46, (uint64_t)v41);
      }
      double v51 = off_26C687610;
      ++v39;
    }
    while (v39 <= a4);
    int v25 = *(_DWORD *)(a1 + 20);
    double v51 = off_26C687610;
    if (v25) {
      operator new[]();
    }
    uint64_t v53 = 1;
    BOOL v54 = 0;
    uint64_t v55 = 0;
    double v51 = (uint64_t (**)())&unk_26C687510;
    __src = 0;
    LODWORD(v46[0]) = 0;
    Algo::FundDist((uint64_t (***)())v56, a1, a2, (uint64_t)&v51, (unsigned int *)v46, a8);
    unsigned int v26 = v46[0];
    if (LODWORD(v46[0]) > *a11)
    {
      int v27 = HIDWORD(v53);
      size_t v28 = 4 * v53 * (unint64_t)HIDWORD(v53);
      uint64_t v29 = *(void **)(a10 + 8);
      if (*(void *)(a10 + 32) < v28)
      {
        if (v29)
        {
          if (*(unsigned char *)(a10 + 24)) {
            MEMORY[0x2166C5D70]();
          }
        }
        operator new[]();
      }
      *(_DWORD *)(a10 + 16) = v53;
      *(_DWORD *)(a10 + 20) = v27;
      memcpy(v29, __src, v28);
      *a11 = v26;
      long double v30 = pow((double)v26 / v32, (double)0);
      char v33 = 1;
      double v24 = -6.90775528 / log(fmin(fmax(1.0 - v30, 2.22044605e-16), 1.0));
    }
    double v51 = off_26C687610;
    if (__src && v54) {
      MEMORY[0x2166C5D70]();
    }
    unsigned int v23 = v35 + 1;
  }
  while (v35 + 1 <= a5);
  return (v33 & 1u) - 1;
}

void sub_215F43C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

void sub_215F43CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  if (a25 && a27) {
    MEMORY[0x2166C5D70]();
  }
  if (a30 && a32) {
    MEMORY[0x2166C5D70]();
  }
  if (a35)
  {
    if (a37) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(a1);
}

uint64_t MatrixNxPts<1u,BOOL>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = &unk_26C6875B0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

uint64_t MatrixNxPts<1u,unsigned int>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = off_26C687610;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

void MatrixNxPts<1u,unsigned int>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = off_26C687610;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  JUMPOUT(0x2166C5D90);
}

void Matrix<unsigned int>::~Matrix(uint64_t a1)
{
  *(void *)a1 = off_26C687610;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  JUMPOUT(0x2166C5D90);
}

uint64_t Matrix<unsigned int>::~Matrix(uint64_t a1)
{
  *(void *)a1 = off_26C687610;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

void MatrixNxPts<1u,BOOL>::~MatrixNxPts(uint64_t a1)
{
  *(void *)a1 = &unk_26C6875B0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x2166C5D70]();
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 16) = 0;
  JUMPOUT(0x2166C5D90);
}

uint64_t Algo::RansacHomography(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, _DWORD *a8, _DWORD *a9)
{
  *a8 = 0;
  uint64_t v17 = &unk_26C687590;
  unsigned int v9 = 5489;
  uint64_t v10 = 1;
  for (uint64_t i = 3; i != 626; ++i)
  {
    int v12 = 1812433253 * (v9 ^ (v9 >> 30));
    unsigned int v9 = v12 + v10;
    *((_DWORD *)&v17 + i) = i + v12 - 2;
    ++v10;
  }
  unsigned int v18 = a6;
  uint64_t v13 = 1;
  for (uint64_t j = 3; j != 626; ++j)
  {
    int v15 = 1812433253 * (a6 ^ (a6 >> 30));
    a6 = v15 + v13;
    *((_DWORD *)&v17 + j) = j + v15 - 2;
    ++v13;
  }
  uint64_t v19 = 0;
  if ((double)0 < 1.0) {
    operator new[]();
  }
  if (a9) {
    *a9 = -1;
  }
  return 0xFFFFFFFFLL;
}

void sub_215F44DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  MatrixNxPts<1u,unsigned int>::~MatrixNxPts(v59 - 192);
  if (a57)
  {
    if (a59) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(a1);
}

uint64_t Algo::RansacPlane(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, _DWORD *a7, _DWORD *a8)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  *a7 = 0;
  unsigned int v16 = &unk_26C687590;
  unsigned int v8 = 5489;
  uint64_t v9 = 1;
  for (uint64_t i = 3; i != 626; ++i)
  {
    int v11 = 1812433253 * (v8 ^ (v8 >> 30));
    unsigned int v8 = v11 + v9;
    *((_DWORD *)&v16 + i) = i + v11 - 2;
    ++v9;
  }
  unsigned int v17 = a5;
  uint64_t v12 = 1;
  for (uint64_t j = 3; j != 626; ++j)
  {
    int v14 = 1812433253 * (a5 ^ (a5 >> 30));
    a5 = v14 + v12;
    *((_DWORD *)&v16 + j) = j + v14 - 2;
    ++v12;
  }
  uint64_t v18 = 0;
  if ((double)0 < 1.0) {
    operator new[]();
  }
  if (a8) {
    *a8 = -1;
  }
  return 0xFFFFFFFFLL;
}

void sub_215F46314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,unint64_t a23,unint64_t a24,unint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a62 && a64) {
    MEMORY[0x2166C5D70]();
  }
  STACK[0xC38] = a23;
  if (STACK[0xC40] && LOBYTE(STACK[0xC50]))
  {
    MEMORY[0x2166C5D70]();
    STACK[0xC40] = 0;
    STACK[0xC58] = 0;
    LOBYTE(STACK[0xC50]) = 0;
  }
  STACK[0xC48] = 0;
  STACK[0xC10] = a24;
  if (STACK[0xC18] && LOBYTE(STACK[0xC28]))
  {
    MEMORY[0x2166C5D70]();
    STACK[0xC18] = 0;
    STACK[0xC30] = 0;
    LOBYTE(STACK[0xC28]) = 0;
  }
  STACK[0xC20] = 0;
  STACK[0xBE8] = a25;
  if (STACK[0xBF0] && LOBYTE(STACK[0xC00])) {
    MEMORY[0x2166C5D70]();
  }
  if (a67 && a69) {
    MEMORY[0x2166C5D70]();
  }
  if (a72)
  {
    if (LOBYTE(STACK[0x208])) {
      MEMORY[0x2166C5D70]();
    }
  }
  _Unwind_Resume(a1);
}

double Algo::Mean(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4 == 1)
  {
    if (*(void *)(a2 + 32) <= 7uLL)
    {
      if (*(void *)(a2 + 8) && *(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
      operator new[]();
    }
    *(void *)(a2 + 16) = 0x100000001;
    int v15 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16);
    int v16 = v15;
    if (v15 < 1)
    {
      double v21 = 0.0;
    }
    else
    {
      uint64_t v17 = *(void *)(a1 + 8);
      unint64_t v18 = v17 + 8 * v15;
      uint64_t v19 = (double *)(v17 + 8);
      if (v18 <= v17 + 8) {
        unint64_t v18 = v17 + 8;
      }
      unint64_t v20 = v18 + ~v17;
      if (v20 >= 8)
      {
        uint64_t v34 = (v20 >> 3) + 1;
        double v21 = 0.0;
        uint64_t v35 = v34 & 0x3FFFFFFFFFFFFFFELL;
        do
        {
          double v21 = v21 + *(v19 - 1) + *v19;
          v19 += 2;
          v35 -= 2;
        }
        while (v35);
        if (v34 == (v34 & 0x3FFFFFFFFFFFFFFELL)) {
          goto LABEL_47;
        }
        int v22 = (double *)(v17 + 8 * (v34 & 0x3FFFFFFFFFFFFFFELL));
      }
      else
      {
        double v21 = 0.0;
        int v22 = *(double **)(a1 + 8);
      }
      unint64_t v36 = v17 + 8 * v15;
      do
      {
        double v37 = *v22++;
        double v21 = v21 + v37;
      }
      while ((unint64_t)v22 < v36);
    }
LABEL_47:
    double result = v21 / (double)v16;
    **(double **)(a2 + 8) = result;
    return result;
  }
  if (!v4) {
    __assert_rtn("Mean", "Algo.cpp", 1452, "rows > 0");
  }
  uint64_t v5 = *(unsigned int *)(a1 + 20);
  uint64_t v6 = *(void **)(a2 + 8);
  if (*(void *)(a2 + 32) < (unint64_t)(8 * v5))
  {
    if (v6)
    {
      if (*(unsigned char *)(a2 + 24)) {
        MEMORY[0x2166C5D70]();
      }
    }
    operator new[]();
  }
  *(_DWORD *)(a2 + 16) = 1;
  *(_DWORD *)(a2 + 20) = v5;
  bzero(v6, 8 * v5);
  if (v5)
  {
    int v8 = 0;
    int v9 = *(_DWORD *)(a1 + 16);
    do
    {
      if (v8 == v9) {
LABEL_50:
      }
        __assert_rtn("operator()", "Matrix.hpp", 126, "row < m_rows && col < m_cols");
      unint64_t v10 = 0;
      uint64_t v11 = *(unsigned int *)(a1 + 20);
      do
      {
        if (v11 == v10) {
          goto LABEL_50;
        }
        int v12 = *(_DWORD *)(a2 + 16);
        if (!v12 || (unint64_t v13 = *(unsigned int *)(a2 + 20), v10 >= v13)) {
          __assert_rtn("operator()", "Matrix.hpp", 120, "row < m_rows && col < m_cols");
        }
        uint64_t v14 = *(void *)(a2 + 8);
        double result = *(double *)(*(void *)(a1 + 8) + 8 * (v11 * v8) + 8 * v10)
               + *(double *)(v14 + 8 * v10);
        *(double *)(v14 + 8 * v10++) = result;
      }
      while (v5 != v10);
      ++v8;
    }
    while (v8 != v4);
  }
  else
  {
    int v12 = *(_DWORD *)(a2 + 16);
    LODWORD(v13) = *(_DWORD *)(a2 + 20);
  }
  int v23 = v13 * v12;
  if ((int)v13 * v12 >= 1)
  {
    double result = (double)v4;
    double v24 = *(float64x2_t **)(a2 + 8);
    unint64_t v25 = (unint64_t)&v24->f64[v23];
    if (v25 <= (unint64_t)&v24->f64[1]) {
      unint64_t v25 = (unint64_t)&v24->f64[1];
    }
    unint64_t v26 = v25 + ~(unint64_t)v24;
    int v27 = *(double **)(a2 + 8);
    if (v26 < 0x18) {
      goto LABEL_37;
    }
    uint64_t v28 = (v26 >> 3) + 1;
    float64x2_t v29 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&result, 0);
    long double v30 = v24 + 1;
    uint64_t v31 = v28 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      float64x2_t v32 = vdivq_f64(*v30, v29);
      v30[-1] = vdivq_f64(v30[-1], v29);
      *long double v30 = v32;
      v30 += 2;
      v31 -= 4;
    }
    while (v31);
    if (v28 != (v28 & 0x3FFFFFFFFFFFFFFCLL))
    {
      int v27 = &v24->f64[v28 & 0x3FFFFFFFFFFFFFFCLL];
LABEL_37:
      unint64_t v33 = (unint64_t)&v24->f64[v23];
      do
      {
        *int v27 = *v27 / result;
        ++v27;
      }
      while ((unint64_t)v27 < v33);
    }
  }
  return result;
}

uint64_t Algo::Gcd(uint64_t this, uint64_t a2)
{
  if (a2)
  {
    do
    {
      uint64_t v2 = a2;
      a2 = this % a2;
      LODWORD(this) = v2;
    }
    while (a2);
    return v2;
  }
  return this;
}

uint64_t Algo::Lcm(Algo *this, unsigned int a2)
{
  unsigned int v2 = this;
  if (a2)
  {
    unsigned int v3 = a2;
    unsigned int v4 = this;
    do
    {
      unsigned int v2 = v3;
      unsigned int v3 = v4 % v3;
      unsigned int v4 = v2;
    }
    while (v3);
  }
  return this / v2 * a2;
}

void sub_215F46C4C(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F470C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F47200(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
}

void InstrumentsTraceGuard::~InstrumentsTraceGuard(InstrumentsTraceGuard *this)
{
}

void sub_215F47328(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F47C90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (v31 < 0) {
    operator delete(v30);
  }
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)&a16);

  _Unwind_Resume(a1);
}

void filterDepthAndUncertainty<float,float,false>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  id v73 = a5;
  id v19 = a6;
  unint64_t v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  float v22 = v21;

  int v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  float v25 = v24;

  unint64_t v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  float v28 = v27;

  float64x2_t v29 = [v19 pipelineParameters];
  char v30 = [v29 outputHighConfidencePixelsOnly];

  if (v73)
  {
    uint64_t v31 = 0;
    unsigned int v32 = 0;
    while (1)
    {
      int v33 = [v73 length];
      BOOL v34 = v31 >= v33;
      if (v31 >= v33) {
        break;
      }
      if (*(float *)([v73 confidences] + 4 * v31) > 0.0)
      {
        uint64_t v35 = [v19 pipelineParameters];
        unsigned int v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          BOOL v34 = 0;
          break;
        }
      }
      ++v31;
    }
  }
  else
  {
    BOOL v34 = 1;
  }
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4) {
    CVPixelBufferLockBaseAddress(a4, 0);
  }
  memset(&v77, 0, sizeof(v77));
  double v37 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v77);
  memset(&v76, 0, sizeof(v76));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v76);
  memset(&v75, 0, sizeof(v75));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v75);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v74);
    data = (float *)v74.data;
    size_t rowBytes = v74.rowBytes;
    if (a10 <= 0.0) {
      goto LABEL_80;
    }
  }
  else
  {
    data = 0;
    size_t rowBytes = 0;
    if (a10 <= 0.0) {
      goto LABEL_80;
    }
  }
  if (v22 <= 10.0) {
    char v40 = v30;
  }
  else {
    char v40 = 0;
  }
  if (a9 > 0.0)
  {
    size_t v41 = v76.rowBytes;
    size_t v42 = v77.rowBytes;
    unint64_t v43 = 4 * (unint64_t)a7;
    BOOL v44 = (char *)v77.data + v77.rowBytes * (unint64_t)a8 + v43;
    uint64_t v45 = (char *)v76.data + v76.rowBytes * (unint64_t)a8 + v43;
    unsigned int v46 = (float *)v75.data;
    size_t v47 = v75.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if (v40)
        {
          unint64_t v48 = 0;
          do
          {
            unint64_t v49 = 0;
            do
            {
              uint64_t v50 = v49;
              v46[v50] = NAN;
              data[v50] = 10.0;
              ++v49;
            }
            while (a9 > (double)v49);
            ++v48;
            data = (float *)((char *)data + rowBytes);
            unsigned int v46 = (float *)((char *)v46 + v47);
          }
          while (a10 > (double)v48);
        }
        else
        {
          unint64_t v68 = 0;
          do
          {
            unint64_t v69 = 0;
            do
            {
              uint64_t v70 = v69;
              v46[v70] = *(float *)&v44[4 * v69];
              data[v70] = 10.0;
              ++v69;
            }
            while (a9 > (double)v69);
            ++v68;
            data = (float *)((char *)data + rowBytes);
            unsigned int v46 = (float *)((char *)v46 + v47);
            v44 += v42;
          }
          while (a10 > (double)v68);
        }
      }
      else
      {
        unint64_t v53 = 0;
        if (v30)
        {
          do
          {
            unint64_t v54 = 0;
            do
            {
              float v55 = *(float *)&v44[4 * v54];
              float v56 = *(float *)&v45[4 * v54];
              if (v55 < v28 || v55 > v25) {
                float v56 = 10.0;
              }
              if (v56 >= v22) {
                float v55 = NAN;
              }
              v46[v54] = v55;
              data[v54++] = v56;
            }
            while (a9 > (double)v54);
            ++v53;
            data = (float *)((char *)data + rowBytes);
            unsigned int v46 = (float *)((char *)v46 + v47);
            v45 += v41;
            v44 += v42;
          }
          while (a10 > (double)v53);
        }
        else
        {
          do
          {
            unint64_t v58 = 0;
            do
            {
              float v59 = *(float *)&v44[4 * v58];
              float v60 = *(float *)&v45[4 * v58];
              if (v59 < v28 || v59 > v25) {
                float v60 = 10.0;
              }
              v46[v58] = v59;
              data[v58++] = v60;
            }
            while (a9 > (double)v58);
            ++v53;
            data = (float *)((char *)data + rowBytes);
            unsigned int v46 = (float *)((char *)v46 + v47);
            v45 += v41;
            v44 += v42;
          }
          while (a10 > (double)v53);
        }
      }
    }
    else if (v34)
    {
      if (v40)
      {
        unint64_t v51 = 0;
        do
        {
          unint64_t v52 = 0;
          do
            v46[v52++] = NAN;
          while (a9 > (double)v52);
          ++v51;
          unsigned int v46 = (float *)((char *)v46 + v47);
        }
        while (a10 > (double)v51);
      }
      else
      {
        unint64_t v71 = 0;
        do
        {
          unint64_t v72 = 0;
          do
          {
            v46[v72] = *(float *)&v44[4 * v72];
            ++v72;
          }
          while (a9 > (double)v72);
          ++v71;
          unsigned int v46 = (float *)((char *)v46 + v47);
          v44 += v42;
        }
        while (a10 > (double)v71);
      }
    }
    else
    {
      unint64_t v62 = 0;
      if (v30)
      {
        do
        {
          unint64_t v63 = 0;
          do
          {
            float v64 = *(float *)&v44[4 * v63];
            float v65 = *(float *)&v45[4 * v63];
            if (v64 < v28 || v64 > v25) {
              float v65 = 10.0;
            }
            if (v65 >= v22) {
              float v64 = NAN;
            }
            v46[v63++] = v64;
          }
          while (a9 > (double)v63);
          ++v62;
          unsigned int v46 = (float *)((char *)v46 + v47);
          v45 += v41;
          v44 += v42;
        }
        while (a10 > (double)v62);
      }
      else
      {
        do
        {
          unint64_t v67 = 0;
          do
          {
            v46[v67] = *(float *)&v44[4 * v67];
            ++v67;
          }
          while (a9 > (double)v67);
          ++v62;
          unsigned int v46 = (float *)((char *)v46 + v47);
          v44 += v42;
        }
        while (a10 > (double)v62);
      }
    }
  }
LABEL_80:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4) {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}

void sub_215F48278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void filterDepthAndUncertainty<float,half,false>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  id v80 = a5;
  id v19 = a6;
  unint64_t v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  float v22 = v21;

  int v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  float v25 = v24;

  unint64_t v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  float v28 = v27;

  float64x2_t v29 = [v19 pipelineParameters];
  unsigned __int8 v30 = [v29 outputHighConfidencePixelsOnly];

  if (v80)
  {
    uint64_t v31 = 0;
    unsigned int v32 = 0;
    while (1)
    {
      int v33 = [v80 length];
      BOOL v34 = v31 >= v33;
      if (v31 >= v33) {
        break;
      }
      if (*(float *)([v80 confidences] + 4 * v31) > 0.0)
      {
        uint64_t v35 = [v19 pipelineParameters];
        unsigned int v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          BOOL v34 = 0;
          break;
        }
      }
      ++v31;
    }
  }
  else
  {
    BOOL v34 = 1;
  }
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4) {
    CVPixelBufferLockBaseAddress(a4, 0);
  }
  memset(&v84, 0, sizeof(v84));
  double v37 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v84);
  memset(&v83, 0, sizeof(v83));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v83);
  memset(&v82, 0, sizeof(v82));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v82);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v81);
    data = (char *)v81.data;
    size_t rowBytes = v81.rowBytes;
    if (a10 <= 0.0) {
      goto LABEL_71;
    }
  }
  else
  {
    data = 0;
    size_t rowBytes = 0;
    if (a10 <= 0.0) {
      goto LABEL_71;
    }
  }
  if (v22 <= 10.0) {
    unsigned __int8 v40 = v30;
  }
  else {
    unsigned __int8 v40 = 0;
  }
  if (a9 > 0.0)
  {
    size_t v41 = v83.rowBytes;
    size_t v42 = v84.rowBytes;
    unint64_t v43 = 4 * (unint64_t)a7;
    BOOL v44 = (char *)v84.data + v84.rowBytes * (unint64_t)a8 + v43;
    uint64_t v45 = (char *)v83.data + v83.rowBytes * (unint64_t)a8 + v43;
    unsigned int v46 = (char *)v82.data;
    size_t v47 = v82.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if (v40)
        {
          unint64_t v48 = 0;
          do
          {
            unint64_t v49 = 0;
            do
            {
              uint64_t v50 = 2 * v49;
              *(_WORD *)&v46[v50] = 32256;
              *(_WORD *)&data[v50] = COERCE_UNSIGNED_INT(10.0);
              ++v49;
            }
            while (a9 > (double)v49);
            ++v48;
            data += rowBytes;
            v46 += v47;
          }
          while (a10 > (double)v48);
        }
        else
        {
          unint64_t v73 = 0;
          do
          {
            unint64_t v74 = 0;
            do
            {
              _S1 = *(_DWORD *)&v44[4 * v74];
              __asm { FCVT            H1, S1 }
              uint64_t v76 = 2 * v74;
              *(_WORD *)&v46[v76] = _S1;
              *(_WORD *)&data[v76] = COERCE_UNSIGNED_INT(10.0);
              ++v74;
            }
            while (a9 > (double)v74);
            ++v73;
            data += rowBytes;
            v46 += v47;
            v44 += v42;
          }
          while (a10 > (double)v73);
        }
      }
      else
      {
        unint64_t v53 = 0;
        do
        {
          unint64_t v54 = 0;
          do
          {
            _S2 = *(float *)&v44[4 * v54];
            _S3 = *(float *)&v45[4 * v54];
            if (_S2 < v28 || _S2 > v25) {
              _S3 = 10.0;
            }
            __asm { FCVT            H2, S2 }
            if ((v30 & (_S3 >= v22)) != 0) {
              _H2 = COERCE_SHORT_FLOAT(32256);
            }
            uint64_t v63 = 2 * v54;
            *(short float *)&v46[v63] = _H2;
            __asm { FCVT            H2, S3 }
            *(_WORD *)&data[v63] = _H2;
            ++v54;
          }
          while (a9 > (double)v54);
          ++v53;
          data += rowBytes;
          v46 += v47;
          v45 += v41;
          v44 += v42;
        }
        while (a10 > (double)v53);
      }
    }
    else if (v34)
    {
      if (v40)
      {
        unint64_t v51 = 0;
        do
        {
          unint64_t v52 = 0;
          do
            *(_WORD *)&v46[2 * v52++] = 32256;
          while (a9 > (double)v52);
          ++v51;
          v46 += v47;
        }
        while (a10 > (double)v51);
      }
      else
      {
        unint64_t v77 = 0;
        do
        {
          unint64_t v78 = 0;
          do
          {
            _S0 = *(_DWORD *)&v44[4 * v78];
            __asm { FCVT            H0, S0 }
            *(_WORD *)&v46[2 * v78++] = _S0;
          }
          while (a9 > (double)v78);
          ++v77;
          v46 += v47;
          v44 += v42;
        }
        while (a10 > (double)v77);
      }
    }
    else
    {
      unint64_t v65 = 0;
      if (v30)
      {
        do
        {
          unint64_t v66 = 0;
          do
          {
            _S2 = *(float *)&v44[4 * v66];
            float v68 = *(float *)&v45[4 * v66];
            if (_S2 < v28 || _S2 > v25) {
              float v68 = 10.0;
            }
            __asm { FCVT            H2, S2 }
            if (v68 >= v22) {
              _H2 = COERCE_SHORT_FLOAT(32256);
            }
            *(short float *)&v46[2 * v66++] = _H2;
          }
          while (a9 > (double)v66);
          ++v65;
          v46 += v47;
          v45 += v41;
          v44 += v42;
        }
        while (a10 > (double)v65);
      }
      else
      {
        do
        {
          unint64_t v71 = 0;
          do
          {
            _S0 = *(_DWORD *)&v44[4 * v71];
            __asm { FCVT            H0, S0 }
            *(_WORD *)&v46[2 * v71++] = _S0;
          }
          while (a9 > (double)v71);
          ++v65;
          v46 += v47;
          v44 += v42;
        }
        while (a10 > (double)v65);
      }
    }
  }
LABEL_71:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4) {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}

void sub_215F487F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void filterDepthAndUncertainty<float,float,true>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  id v78 = a5;
  id v19 = a6;
  unint64_t v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  float v22 = v21;

  int v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  float v25 = v24;

  unint64_t v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  float v28 = v27;

  float64x2_t v29 = [v19 pipelineParameters];
  int v30 = [v29 outputHighConfidencePixelsOnly];

  if (v78)
  {
    uint64_t v31 = 0;
    unsigned int v32 = 0;
    while (1)
    {
      int v33 = [v78 length];
      BOOL v34 = v31 >= v33;
      if (v31 >= v33) {
        break;
      }
      if (*(float *)([v78 confidences] + 4 * v31) > 0.0)
      {
        uint64_t v35 = [v19 pipelineParameters];
        unsigned int v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          BOOL v34 = 0;
          break;
        }
      }
      ++v31;
    }
  }
  else
  {
    BOOL v34 = 1;
  }
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4) {
    CVPixelBufferLockBaseAddress(a4, 0);
  }
  memset(&v82, 0, sizeof(v82));
  double v37 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v82);
  memset(&v81, 0, sizeof(v81));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v81);
  memset(&v80, 0, sizeof(v80));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v80);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v79);
    data = (char *)v79.data;
    size_t rowBytes = v79.rowBytes;
    if (a10 <= 0.0) {
      goto LABEL_81;
    }
  }
  else
  {
    data = 0;
    size_t rowBytes = 0;
    if (a10 <= 0.0) {
      goto LABEL_81;
    }
  }
  if (v22 <= 10.0) {
    char v40 = v30;
  }
  else {
    char v40 = 0;
  }
  if (a9 > 0.0)
  {
    size_t v41 = v81.rowBytes;
    size_t v42 = v82.rowBytes;
    unint64_t v43 = 4 * (unint64_t)a7;
    BOOL v44 = (char *)v82.data + v82.rowBytes * (unint64_t)a8 + v43;
    uint64_t v45 = (char *)v81.data + v81.rowBytes * (unint64_t)a8 + v43;
    unsigned int v46 = (float *)v80.data;
    size_t v47 = v80.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if (v40)
        {
          unint64_t v48 = 0;
          do
          {
            unint64_t v49 = 0;
            do
            {
              uint64_t v50 = v49;
              v46[v50] = NAN;
              *(_DWORD *)&data[v50 * 4] = 1092616192;
              ++v49;
            }
            while (a9 > (double)v49);
            ++v48;
            data += rowBytes;
            unsigned int v46 = (float *)((char *)v46 + v47);
          }
          while (a10 > (double)v48);
        }
        else
        {
          unint64_t v67 = 0;
          do
          {
            unint64_t v68 = 0;
            do
            {
              float v69 = *(float *)&v44[4 * v68];
              float v70 = 1.0 / v69;
              BOOL v71 = v69 == 0.0;
              float v72 = NAN;
              if (!v71) {
                float v72 = v70;
              }
              v46[v68] = v72;
              *(_DWORD *)&data[4 * v68++] = 1092616192;
            }
            while (a9 > (double)v68);
            ++v67;
            data += rowBytes;
            unsigned int v46 = (float *)((char *)v46 + v47);
            v44 += v42;
          }
          while (a10 > (double)v67);
        }
      }
      else
      {
        unint64_t v53 = 0;
        do
        {
          unint64_t v54 = 0;
          do
          {
            float v55 = *(float *)&v44[4 * v54];
            float v56 = *(float *)&v45[4 * v54];
            if (v55 < v28 || v55 > v25) {
              float v56 = 10.0;
            }
            if (v56 >= v22) {
              int v58 = v30;
            }
            else {
              int v58 = 0;
            }
            if (v55 == 0.0) {
              int v58 = 1;
            }
            float v59 = 1.0 / v55;
            if (v58) {
              float v59 = NAN;
            }
            v46[v54] = v59;
            *(float *)&data[4 * v54++] = v56;
          }
          while (a9 > (double)v54);
          ++v53;
          data += rowBytes;
          unsigned int v46 = (float *)((char *)v46 + v47);
          v45 += v41;
          v44 += v42;
        }
        while (a10 > (double)v53);
      }
    }
    else if (v34)
    {
      if (v40)
      {
        unint64_t v51 = 0;
        do
        {
          unint64_t v52 = 0;
          do
            v46[v52++] = NAN;
          while (a9 > (double)v52);
          ++v51;
          unsigned int v46 = (float *)((char *)v46 + v47);
        }
        while (a10 > (double)v51);
      }
      else
      {
        unint64_t v73 = 0;
        do
        {
          unint64_t v74 = 0;
          do
          {
            float v75 = *(float *)&v44[4 * v74];
            float v76 = 1.0 / v75;
            BOOL v71 = v75 == 0.0;
            float v77 = NAN;
            if (!v71) {
              float v77 = v76;
            }
            v46[v74++] = v77;
          }
          while (a9 > (double)v74);
          ++v73;
          unsigned int v46 = (float *)((char *)v46 + v47);
          v44 += v42;
        }
        while (a10 > (double)v73);
      }
    }
    else
    {
      unint64_t v60 = 0;
      do
      {
        unint64_t v61 = 0;
        do
        {
          float v62 = *(float *)&v44[4 * v61];
          float v63 = *(float *)&v45[4 * v61];
          if (v62 < v28 || v62 > v25) {
            float v63 = 10.0;
          }
          if (v63 >= v22) {
            int v65 = v30;
          }
          else {
            int v65 = 0;
          }
          if (v62 == 0.0) {
            int v65 = 1;
          }
          float v66 = 1.0 / v62;
          if (v65) {
            float v66 = NAN;
          }
          v46[v61++] = v66;
        }
        while (a9 > (double)v61);
        ++v60;
        unsigned int v46 = (float *)((char *)v46 + v47);
        v45 += v41;
        v44 += v42;
      }
      while (a10 > (double)v60);
    }
  }
LABEL_81:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4) {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}

void sub_215F48D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void filterDepthAndUncertainty<float,half,true>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  id v88 = a5;
  id v19 = a6;
  unint64_t v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  float v22 = v21;

  int v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  float v25 = v24;

  unint64_t v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  float v28 = v27;

  float64x2_t v29 = [v19 pipelineParameters];
  int v30 = [v29 outputHighConfidencePixelsOnly];

  if (v88)
  {
    uint64_t v31 = 0;
    unsigned int v32 = 0;
    while (1)
    {
      int v33 = [v88 length];
      BOOL v34 = v31 >= v33;
      if (v31 >= v33) {
        break;
      }
      if (*(float *)([v88 confidences] + 4 * v31) > 0.0)
      {
        uint64_t v35 = [v19 pipelineParameters];
        unsigned int v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          BOOL v34 = 0;
          break;
        }
      }
      ++v31;
    }
  }
  else
  {
    BOOL v34 = 1;
  }
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4) {
    CVPixelBufferLockBaseAddress(a4, 0);
  }
  memset(&v92, 0, sizeof(v92));
  double v37 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v92);
  memset(&v91, 0, sizeof(v91));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v91);
  memset(&v90, 0, sizeof(v90));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v90);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v89);
    data = (char *)v89.data;
    size_t rowBytes = v89.rowBytes;
    if (a10 <= 0.0) {
      goto LABEL_83;
    }
  }
  else
  {
    data = 0;
    size_t rowBytes = 0;
    if (a10 <= 0.0) {
      goto LABEL_83;
    }
  }
  if (v22 <= 10.0) {
    char v40 = v30;
  }
  else {
    char v40 = 0;
  }
  if (a9 > 0.0)
  {
    size_t v41 = v91.rowBytes;
    size_t v42 = v92.rowBytes;
    unint64_t v43 = 4 * (unint64_t)a7;
    BOOL v44 = (char *)v92.data + v92.rowBytes * (unint64_t)a8 + v43;
    uint64_t v45 = (char *)v91.data + v91.rowBytes * (unint64_t)a8 + v43;
    unsigned int v46 = (char *)v90.data;
    size_t v47 = v90.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if (v40)
        {
          unint64_t v48 = 0;
          do
          {
            unint64_t v49 = 0;
            do
            {
              uint64_t v50 = 2 * v49;
              *(_WORD *)&v46[v50] = 32256;
              *(_WORD *)&data[v50] = COERCE_UNSIGNED_INT(10.0);
              ++v49;
            }
            while (a9 > (double)v49);
            ++v48;
            data += rowBytes;
            v46 += v47;
          }
          while (a10 > (double)v48);
        }
        else
        {
          unint64_t v75 = 0;
          do
          {
            unint64_t v76 = 0;
            do
            {
              float v77 = *(float *)&v44[4 * v76];
              _S4 = 1.0 / v77;
              __asm { FCVT            H4, S4 }
              if (v77 == 0.0) {
                short float v80 = COERCE_SHORT_FLOAT(32256);
              }
              else {
                short float v80 = _H4;
              }
              uint64_t v81 = 2 * v76;
              *(short float *)&v46[v81] = v80;
              *(_WORD *)&data[v81] = COERCE_UNSIGNED_INT(10.0);
              ++v76;
            }
            while (a9 > (double)v76);
            ++v75;
            data += rowBytes;
            v46 += v47;
            v44 += v42;
          }
          while (a10 > (double)v75);
        }
      }
      else
      {
        unint64_t v53 = 0;
        do
        {
          unint64_t v54 = 0;
          do
          {
            float v55 = *(float *)&v44[4 * v54];
            _S4 = *(float *)&v45[4 * v54];
            if (v55 < v28 || v55 > v25) {
              _S4 = 10.0;
            }
            if (_S4 >= v22) {
              int v58 = v30;
            }
            else {
              int v58 = 0;
            }
            if (v55 == 0.0) {
              int v58 = 1;
            }
            _S3 = 1.0 / v55;
            __asm { FCVT            H3, S3 }
            if (v58) {
              _H3 = COERCE_SHORT_FLOAT(32256);
            }
            uint64_t v65 = 2 * v54;
            *(short float *)&v46[v65] = _H3;
            __asm { FCVT            H3, S4 }
            *(_WORD *)&data[v65] = _H3;
            ++v54;
          }
          while (a9 > (double)v54);
          ++v53;
          data += rowBytes;
          v46 += v47;
          v45 += v41;
          v44 += v42;
        }
        while (a10 > (double)v53);
      }
    }
    else if (v34)
    {
      if (v40)
      {
        unint64_t v51 = 0;
        do
        {
          unint64_t v52 = 0;
          do
            *(_WORD *)&v46[2 * v52++] = 32256;
          while (a9 > (double)v52);
          ++v51;
          v46 += v47;
        }
        while (a10 > (double)v51);
      }
      else
      {
        unint64_t v82 = 0;
        do
        {
          unint64_t v83 = 0;
          do
          {
            float v84 = *(float *)&v44[4 * v83];
            _S3 = 1.0 / v84;
            __asm { FCVT            H3, S3 }
            if (v84 == 0.0) {
              short float v87 = COERCE_SHORT_FLOAT(32256);
            }
            else {
              short float v87 = _H3;
            }
            *(short float *)&v46[2 * v83++] = v87;
          }
          while (a9 > (double)v83);
          ++v82;
          v46 += v47;
          v44 += v42;
        }
        while (a10 > (double)v82);
      }
    }
    else
    {
      unint64_t v67 = 0;
      do
      {
        unint64_t v68 = 0;
        do
        {
          float v69 = *(float *)&v44[4 * v68];
          float v70 = *(float *)&v45[4 * v68];
          if (v69 < v28 || v69 > v25) {
            float v70 = 10.0;
          }
          if (v70 >= v22) {
            int v72 = v30;
          }
          else {
            int v72 = 0;
          }
          if (v69 == 0.0) {
            int v72 = 1;
          }
          _S3 = 1.0 / v69;
          __asm { FCVT            H3, S3 }
          if (v72) {
            _H3 = COERCE_SHORT_FLOAT(32256);
          }
          *(short float *)&v46[2 * v68++] = _H3;
        }
        while (a9 > (double)v68);
        ++v67;
        v46 += v47;
        v45 += v41;
        v44 += v42;
      }
      while (a10 > (double)v67);
    }
  }
LABEL_83:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4) {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}

void sub_215F49300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void filterDepthAndUncertainty<half,float,false>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  id v86 = a5;
  id v19 = a6;
  unint64_t v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  _S12 = v21;

  int v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  _S13 = v24;

  unint64_t v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  _S14 = v27;

  float64x2_t v29 = [v19 pipelineParameters];
  unsigned __int8 v30 = [v29 outputHighConfidencePixelsOnly];

  if (v86)
  {
    uint64_t v31 = 0;
    unsigned int v32 = 0;
    while (1)
    {
      int v33 = [v86 length];
      BOOL v34 = v31 >= v33;
      if (v31 >= v33) {
        break;
      }
      if (*(float *)([v86 confidences] + 4 * v31) > 0.0)
      {
        uint64_t v35 = [v19 pipelineParameters];
        unsigned int v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          BOOL v34 = 0;
          break;
        }
      }
      ++v31;
    }
  }
  else
  {
    BOOL v34 = 1;
  }
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4) {
    CVPixelBufferLockBaseAddress(a4, 0);
  }
  memset(&v90, 0, sizeof(v90));
  double v37 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v90);
  memset(&v89, 0, sizeof(v89));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v89);
  memset(&v88, 0, sizeof(v88));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v88);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v87);
    data = (char *)v87.data;
    size_t rowBytes = v87.rowBytes;
    if (a10 <= 0.0) {
      goto LABEL_71;
    }
  }
  else
  {
    data = 0;
    size_t rowBytes = 0;
    if (a10 <= 0.0) {
      goto LABEL_71;
    }
  }
  __asm { FCVT            H0, S12 }
  if (_H0 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(10.0))) {
    unsigned __int8 v45 = v30;
  }
  else {
    unsigned __int8 v45 = 0;
  }
  if (a9 > 0.0)
  {
    __asm
    {
      FCVT            H1, S13
      FCVT            H2, S14
    }
    size_t v48 = v89.rowBytes;
    size_t v49 = v90.rowBytes;
    unint64_t v50 = 2 * (unint64_t)a7;
    unint64_t v51 = (char *)v90.data + v90.rowBytes * (unint64_t)a8 + v50;
    unint64_t v52 = (char *)v89.data + v89.rowBytes * (unint64_t)a8 + v50;
    unint64_t v53 = (char *)v88.data;
    size_t v54 = v88.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if (v45)
        {
          unint64_t v55 = 0;
          do
          {
            unint64_t v56 = 0;
            do
            {
              uint64_t v57 = 4 * v56;
              *(_DWORD *)&v53[v57] = 2143289344;
              *(_DWORD *)&data[v57] = 1092616192;
              ++v56;
            }
            while (a9 > (double)v56);
            ++v55;
            data += rowBytes;
            v53 += v54;
          }
          while (a10 > (double)v55);
        }
        else
        {
          unint64_t v77 = 0;
          do
          {
            unint64_t v78 = 0;
            do
            {
              _H0 = *(_WORD *)&v51[2 * v78];
              __asm { FCVT            S0, H0 }
              uint64_t v81 = 4 * v78;
              *(_DWORD *)&v53[v81] = _S0;
              *(_DWORD *)&data[v81] = 1092616192;
              ++v78;
            }
            while (a9 > (double)v78);
            ++v77;
            data += rowBytes;
            v53 += v54;
            v51 += v49;
          }
          while (a10 > (double)v77);
        }
      }
      else
      {
        unint64_t v60 = 0;
        do
        {
          unint64_t v61 = 0;
          do
          {
            _H4 = *(short float *)&v51[2 * v61];
            _H5 = *(short float *)&v52[2 * v61];
            if (_H4 < _H2 || _H4 > _H1) {
              LOWORD(_H5) = COERCE_UNSIGNED_INT(10.0);
            }
            __asm { FCVT            S4, H4 }
            if ((v30 & (_H5 >= _H0)) != 0) {
              _S4 = NAN;
            }
            uint64_t v66 = 4 * v61;
            *(float *)&v53[v66] = _S4;
            __asm { FCVT            S4, H5 }
            *(_DWORD *)&data[v66] = _S4;
            ++v61;
          }
          while (a9 > (double)v61);
          ++v60;
          data += rowBytes;
          v53 += v54;
          v52 += v48;
          v51 += v49;
        }
        while (a10 > (double)v60);
      }
    }
    else if (v34)
    {
      if (v45)
      {
        unint64_t v58 = 0;
        do
        {
          unint64_t v59 = 0;
          do
            *(_DWORD *)&v53[4 * v59++] = 2143289344;
          while (a9 > (double)v59);
          ++v58;
          v53 += v54;
        }
        while (a10 > (double)v58);
      }
      else
      {
        unint64_t v82 = 0;
        do
        {
          unint64_t v83 = 0;
          do
          {
            _H0 = *(_WORD *)&v51[2 * v83];
            __asm { FCVT            S0, H0 }
            *(_DWORD *)&v53[4 * v83++] = _S0;
          }
          while (a9 > (double)v83);
          ++v82;
          v53 += v54;
          v51 += v49;
        }
        while (a10 > (double)v82);
      }
    }
    else
    {
      unint64_t v68 = 0;
      if (v30)
      {
        do
        {
          unint64_t v69 = 0;
          do
          {
            _H4 = *(short float *)&v51[2 * v69];
            short float v71 = *(short float *)&v52[2 * v69];
            if (_H4 < _H2 || _H4 > _H1) {
              LOWORD(v71) = COERCE_UNSIGNED_INT(10.0);
            }
            __asm { FCVT            S4, H4 }
            if (v71 >= _H0) {
              _S4 = NAN;
            }
            *(float *)&v53[4 * v69++] = _S4;
          }
          while (a9 > (double)v69);
          ++v68;
          v53 += v54;
          v52 += v48;
          v51 += v49;
        }
        while (a10 > (double)v68);
      }
      else
      {
        do
        {
          unint64_t v74 = 0;
          do
          {
            _H0 = *(_WORD *)&v51[2 * v74];
            __asm { FCVT            S0, H0 }
            *(_DWORD *)&v53[4 * v74++] = _S0;
          }
          while (a9 > (double)v74);
          ++v68;
          v53 += v54;
          v51 += v49;
        }
        while (a10 > (double)v68);
      }
    }
  }
LABEL_71:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4) {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}

void sub_215F49888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void filterDepthAndUncertainty<half,half,false>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  id v80 = a5;
  id v19 = a6;
  unint64_t v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  _S12 = v21;

  int v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  _S13 = v24;

  unint64_t v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  _S14 = v27;

  float64x2_t v29 = [v19 pipelineParameters];
  char v30 = [v29 outputHighConfidencePixelsOnly];

  if (v80)
  {
    uint64_t v31 = 0;
    unsigned int v32 = 0;
    while (1)
    {
      int v33 = [v80 length];
      BOOL v34 = v31 >= v33;
      if (v31 >= v33) {
        break;
      }
      if (*(float *)([v80 confidences] + 4 * v31) > 0.0)
      {
        uint64_t v35 = [v19 pipelineParameters];
        unsigned int v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          BOOL v34 = 0;
          break;
        }
      }
      ++v31;
    }
  }
  else
  {
    BOOL v34 = 1;
  }
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4) {
    CVPixelBufferLockBaseAddress(a4, 0);
  }
  memset(&v84, 0, sizeof(v84));
  double v37 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v84);
  memset(&v83, 0, sizeof(v83));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v83);
  memset(&v82, 0, sizeof(v82));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v82);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v81);
    data = (short float *)v81.data;
    size_t rowBytes = v81.rowBytes;
    if (a10 <= 0.0) {
      goto LABEL_80;
    }
  }
  else
  {
    data = 0;
    size_t rowBytes = 0;
    if (a10 <= 0.0) {
      goto LABEL_80;
    }
  }
  __asm { FCVT            H2, S12 }
  if (_H2 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(10.0))) {
    char v45 = v30;
  }
  else {
    char v45 = 0;
  }
  if (a9 > 0.0)
  {
    __asm
    {
      FCVT            H0, S13
      FCVT            H1, S14
    }
    size_t v48 = v83.rowBytes;
    size_t v49 = v84.rowBytes;
    unint64_t v50 = 2 * (unint64_t)a7;
    unint64_t v51 = (char *)v84.data + v84.rowBytes * (unint64_t)a8 + v50;
    unint64_t v52 = (char *)v83.data + v83.rowBytes * (unint64_t)a8 + v50;
    unint64_t v53 = (short float *)v82.data;
    size_t v54 = v82.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if (v45)
        {
          unint64_t v55 = 0;
          do
          {
            unint64_t v56 = 0;
            do
            {
              uint64_t v57 = v56;
              LOWORD(v53[v57]) = 32256;
              LOWORD(data[v57]) = COERCE_UNSIGNED_INT(10.0);
              ++v56;
            }
            while (a9 > (double)v56);
            ++v55;
            data = (short float *)((char *)data + rowBytes);
            unint64_t v53 = (short float *)((char *)v53 + v54);
          }
          while (a10 > (double)v55);
        }
        else
        {
          unint64_t v71 = 0;
          do
          {
            unint64_t v72 = 0;
            do
            {
              uint64_t v73 = v72;
              v53[v73] = *(short float *)&v51[2 * v72];
              LOWORD(data[v73]) = COERCE_UNSIGNED_INT(10.0);
              ++v72;
            }
            while (a9 > (double)v72);
            ++v71;
            data = (short float *)((char *)data + rowBytes);
            unint64_t v53 = (short float *)((char *)v53 + v54);
            v51 += v49;
          }
          while (a10 > (double)v71);
        }
      }
      else
      {
        unint64_t v60 = 0;
        if (v30)
        {
          do
          {
            unint64_t v61 = 0;
            do
            {
              short float v62 = *(short float *)&v51[2 * v61];
              short float v63 = *(short float *)&v52[2 * v61];
              if (v62 < _H1 || v62 > _H0) {
                LOWORD(v63) = COERCE_UNSIGNED_INT(10.0);
              }
              if (v63 >= _H2) {
                short float v62 = COERCE_SHORT_FLOAT(32256);
              }
              v53[v61] = v62;
              data[v61++] = v63;
            }
            while (a9 > (double)v61);
            ++v60;
            data = (short float *)((char *)data + rowBytes);
            unint64_t v53 = (short float *)((char *)v53 + v54);
            v52 += v48;
            v51 += v49;
          }
          while (a10 > (double)v60);
        }
        else
        {
          do
          {
            unint64_t v74 = 0;
            do
            {
              short float v75 = *(short float *)&v51[2 * v74];
              short float v76 = *(short float *)&v52[2 * v74];
              if (v75 < _H1 || v75 > _H0) {
                LOWORD(v76) = COERCE_UNSIGNED_INT(10.0);
              }
              v53[v74] = v75;
              data[v74++] = v76;
            }
            while (a9 > (double)v74);
            ++v60;
            data = (short float *)((char *)data + rowBytes);
            unint64_t v53 = (short float *)((char *)v53 + v54);
            v52 += v48;
            v51 += v49;
          }
          while (a10 > (double)v60);
        }
      }
    }
    else if (v34)
    {
      if (v45)
      {
        unint64_t v58 = 0;
        do
        {
          unint64_t v59 = 0;
          do
            LOWORD(v53[v59++]) = 32256;
          while (a9 > (double)v59);
          ++v58;
          unint64_t v53 = (short float *)((char *)v53 + v54);
        }
        while (a10 > (double)v58);
      }
      else
      {
        unint64_t v78 = 0;
        do
        {
          unint64_t v79 = 0;
          do
          {
            v53[v79] = *(short float *)&v51[2 * v79];
            ++v79;
          }
          while (a9 > (double)v79);
          ++v78;
          unint64_t v53 = (short float *)((char *)v53 + v54);
          v51 += v49;
        }
        while (a10 > (double)v78);
      }
    }
    else
    {
      unint64_t v65 = 0;
      if (v30)
      {
        do
        {
          unint64_t v66 = 0;
          do
          {
            short float v67 = *(short float *)&v51[2 * v66];
            short float v68 = *(short float *)&v52[2 * v66];
            if (v67 < _H1 || v67 > _H0) {
              LOWORD(v68) = COERCE_UNSIGNED_INT(10.0);
            }
            if (v68 >= _H2) {
              short float v67 = COERCE_SHORT_FLOAT(32256);
            }
            v53[v66++] = v67;
          }
          while (a9 > (double)v66);
          ++v65;
          unint64_t v53 = (short float *)((char *)v53 + v54);
          v52 += v48;
          v51 += v49;
        }
        while (a10 > (double)v65);
      }
      else
      {
        do
        {
          unint64_t v70 = 0;
          do
          {
            v53[v70] = *(short float *)&v51[2 * v70];
            ++v70;
          }
          while (a9 > (double)v70);
          ++v65;
          unint64_t v53 = (short float *)((char *)v53 + v54);
          v51 += v49;
        }
        while (a10 > (double)v65);
      }
    }
  }
LABEL_80:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4) {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}

void sub_215F49E5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void filterDepthAndUncertainty<half,float,true>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  id v93 = a5;
  id v19 = a6;
  unint64_t v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  _S12 = v21;

  int v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  _S13 = v24;

  unint64_t v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  _S14 = v27;

  float64x2_t v29 = [v19 pipelineParameters];
  int v30 = [v29 outputHighConfidencePixelsOnly];

  if (v93)
  {
    uint64_t v31 = 0;
    unsigned int v32 = 0;
    while (1)
    {
      int v33 = [v93 length];
      BOOL v34 = v31 >= v33;
      if (v31 >= v33) {
        break;
      }
      if (*(float *)([v93 confidences] + 4 * v31) > 0.0)
      {
        uint64_t v35 = [v19 pipelineParameters];
        unsigned int v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          BOOL v34 = 0;
          break;
        }
      }
      ++v31;
    }
  }
  else
  {
    BOOL v34 = 1;
  }
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4) {
    CVPixelBufferLockBaseAddress(a4, 0);
  }
  memset(&v97, 0, sizeof(v97));
  double v37 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v97);
  memset(&v96, 0, sizeof(v96));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v96);
  memset(&v95, 0, sizeof(v95));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v95);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v94);
    data = (char *)v94.data;
    size_t rowBytes = v94.rowBytes;
    if (a10 <= 0.0) {
      goto LABEL_83;
    }
  }
  else
  {
    data = 0;
    size_t rowBytes = 0;
    if (a10 <= 0.0) {
      goto LABEL_83;
    }
  }
  __asm { FCVT            H0, S12 }
  if (_H0 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(10.0))) {
    char v45 = v30;
  }
  else {
    char v45 = 0;
  }
  if (a9 > 0.0)
  {
    __asm
    {
      FCVT            H1, S13
      FCVT            H2, S14
    }
    size_t v48 = v96.rowBytes;
    size_t v49 = v97.rowBytes;
    unint64_t v50 = 2 * (unint64_t)a7;
    unint64_t v51 = (char *)v97.data + v97.rowBytes * (unint64_t)a8 + v50;
    unint64_t v52 = (char *)v96.data + v96.rowBytes * (unint64_t)a8 + v50;
    unint64_t v53 = (char *)v95.data;
    size_t v54 = v95.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if (v45)
        {
          unint64_t v55 = 0;
          do
          {
            unint64_t v56 = 0;
            do
            {
              uint64_t v57 = 4 * v56;
              *(_DWORD *)&v53[v57] = 2143289344;
              *(_DWORD *)&data[v57] = 1092616192;
              ++v56;
            }
            while (a9 > (double)v56);
            ++v55;
            data += rowBytes;
            v53 += v54;
          }
          while (a10 > (double)v55);
        }
        else
        {
          unint64_t v80 = 0;
          do
          {
            unint64_t v81 = 0;
            do
            {
              _H2 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / *(short float *)&v51[2 * v81];
              __asm
              {
                FCVT            S2, H2
                FCMP            H1, #0
              }
              float v85 = NAN;
              if (!_ZF) {
                float v85 = _S2;
              }
              uint64_t v86 = 4 * v81;
              *(float *)&v53[v86] = v85;
              *(_DWORD *)&data[v86] = 1092616192;
              ++v81;
            }
            while (a9 > (double)v81);
            ++v80;
            data += rowBytes;
            v53 += v54;
            v51 += v49;
          }
          while (a10 > (double)v80);
        }
      }
      else
      {
        unint64_t v60 = 0;
        do
        {
          unint64_t v61 = 0;
          do
          {
            short float v62 = *(short float *)&v51[2 * v61];
            _H6 = *(short float *)&v52[2 * v61];
            if (v62 < _H2 || v62 > _H1) {
              LOWORD(_H6) = COERCE_UNSIGNED_INT(10.0);
            }
            if (_H6 >= _H0) {
              int v65 = v30;
            }
            else {
              int v65 = 0;
            }
            __asm { FCMP            H5, #0 }
            if (_ZF) {
              int v65 = 1;
            }
            _H5 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / _H5;
            __asm { FCVT            S5, H5 }
            if (v65) {
              _S5 = NAN;
            }
            uint64_t v69 = 4 * v61;
            *(float *)&v53[v69] = _S5;
            __asm { FCVT            S5, H6 }
            *(_DWORD *)&data[v69] = _S5;
            ++v61;
          }
          while (a9 > (double)v61);
          ++v60;
          data += rowBytes;
          v53 += v54;
          v52 += v48;
          v51 += v49;
        }
        while (a10 > (double)v60);
      }
    }
    else if (v34)
    {
      if (v45)
      {
        unint64_t v58 = 0;
        do
        {
          unint64_t v59 = 0;
          do
            *(_DWORD *)&v53[4 * v59++] = 2143289344;
          while (a9 > (double)v59);
          ++v58;
          v53 += v54;
        }
        while (a10 > (double)v58);
      }
      else
      {
        unint64_t v87 = 0;
        do
        {
          unint64_t v88 = 0;
          do
          {
            _H2 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / *(short float *)&v51[2 * v88];
            __asm
            {
              FCVT            S2, H2
              FCMP            H1, #0
            }
            float v92 = NAN;
            if (!_ZF) {
              float v92 = _S2;
            }
            *(float *)&v53[4 * v88++] = v92;
          }
          while (a9 > (double)v88);
          ++v87;
          v53 += v54;
          v51 += v49;
        }
        while (a10 > (double)v87);
      }
    }
    else
    {
      unint64_t v71 = 0;
      do
      {
        unint64_t v72 = 0;
        do
        {
          short float v73 = *(short float *)&v51[2 * v72];
          short float v74 = *(short float *)&v52[2 * v72];
          if (v73 < _H2 || v73 > _H1) {
            LOWORD(v74) = COERCE_UNSIGNED_INT(10.0);
          }
          if (v74 >= _H0) {
            int v76 = v30;
          }
          else {
            int v76 = 0;
          }
          __asm { FCMP            H5, #0 }
          if (_ZF) {
            int v76 = 1;
          }
          _H5 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / _H5;
          __asm { FCVT            S5, H5 }
          if (v76) {
            _S5 = NAN;
          }
          *(float *)&v53[4 * v72++] = _S5;
        }
        while (a9 > (double)v72);
        ++v71;
        v53 += v54;
        v52 += v48;
        v51 += v49;
      }
      while (a10 > (double)v71);
    }
  }
LABEL_83:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4) {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}

void sub_215F4A3FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void filterDepthAndUncertainty<half,half,true>(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3, __CVBuffer *a4, void *a5, void *a6, double a7, double a8, double a9, double a10)
{
  id v84 = a5;
  id v19 = a6;
  unint64_t v20 = [v19 pipelineParameters];
  [v20 uncertaintyThreshold];
  _S12 = v21;

  int v23 = [v19 pipelineParameters];
  [v23 maxDepthThresholdForInvalidUncertainty];
  _S13 = v24;

  unint64_t v26 = [v19 pipelineParameters];
  [v26 minDepthThresholdForInvalidUncertainty];
  _S14 = v27;

  float64x2_t v29 = [v19 pipelineParameters];
  int v30 = [v29 outputHighConfidencePixelsOnly];

  if (v84)
  {
    uint64_t v31 = 0;
    unsigned int v32 = 0;
    while (1)
    {
      int v33 = [v84 length];
      BOOL v34 = v31 >= v33;
      if (v31 >= v33) {
        break;
      }
      if (*(float *)([v84 confidences] + 4 * v31) > 0.0)
      {
        uint64_t v35 = [v19 pipelineParameters];
        unsigned int v36 = [v35 minRequiredJasperPoints];
        ++v32;

        if (v32 >= v36)
        {
          BOOL v34 = 0;
          break;
        }
      }
      ++v31;
    }
  }
  else
  {
    BOOL v34 = 1;
  }
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  if (a4) {
    CVPixelBufferLockBaseAddress(a4, 0);
  }
  memset(&v88, 0, sizeof(v88));
  double v37 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v88);
  memset(&v87, 0, sizeof(v87));
  PixelBufferUtils::asVImageBuffer(a2, *v37, &v87);
  memset(&v86, 0, sizeof(v86));
  PixelBufferUtils::asVImageBuffer(a3, *v37, &v86);
  if (a4)
  {
    PixelBufferUtils::asVImageBuffer(a4, *v37, &v85);
    data = (char *)v85.data;
    size_t rowBytes = v85.rowBytes;
    if (a10 <= 0.0) {
      goto LABEL_85;
    }
  }
  else
  {
    data = 0;
    size_t rowBytes = 0;
    if (a10 <= 0.0) {
      goto LABEL_85;
    }
  }
  __asm { FCVT            H0, S12 }
  if (_H0 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(10.0))) {
    char v45 = v30;
  }
  else {
    char v45 = 0;
  }
  if (a9 > 0.0)
  {
    __asm
    {
      FCVT            H1, S13
      FCVT            H2, S14
    }
    size_t v48 = v87.rowBytes;
    size_t v49 = v88.rowBytes;
    unint64_t v50 = 2 * (unint64_t)a7;
    unint64_t v51 = (char *)v88.data + v88.rowBytes * (unint64_t)a8 + v50;
    unint64_t v52 = (char *)v87.data + v87.rowBytes * (unint64_t)a8 + v50;
    unint64_t v53 = (short float *)v86.data;
    size_t v54 = v86.rowBytes;
    if (a4)
    {
      if (v34)
      {
        if (v45)
        {
          unint64_t v55 = 0;
          do
          {
            unint64_t v56 = 0;
            do
            {
              uint64_t v57 = v56;
              LOWORD(v53[v57]) = 32256;
              *(_WORD *)&data[v57 * 2] = COERCE_UNSIGNED_INT(10.0);
              ++v56;
            }
            while (a9 > (double)v56);
            ++v55;
            data += rowBytes;
            unint64_t v53 = (short float *)((char *)v53 + v54);
          }
          while (a10 > (double)v55);
        }
        else
        {
          unint64_t v76 = 0;
          do
          {
            unint64_t v77 = 0;
            do
            {
              __asm { FCMP            H3, #0 }
              if (_ZF) {
                short float v79 = COERCE_SHORT_FLOAT(32256);
              }
              else {
                short float v79 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / *(short float *)&v51[2 * v77];
              }
              v53[v77] = v79;
              *(_WORD *)&data[2 * v77++] = COERCE_UNSIGNED_INT(10.0);
            }
            while (a9 > (double)v77);
            ++v76;
            data += rowBytes;
            unint64_t v53 = (short float *)((char *)v53 + v54);
            v51 += v49;
          }
          while (a10 > (double)v76);
        }
      }
      else
      {
        unint64_t v60 = 0;
        do
        {
          unint64_t v61 = 0;
          do
          {
            short float v62 = *(short float *)&v51[2 * v61];
            short float v63 = *(short float *)&v52[2 * v61];
            if (v62 < _H2 || v62 > _H1) {
              LOWORD(v63) = COERCE_UNSIGNED_INT(10.0);
            }
            if (v63 >= _H0) {
              int v65 = v30;
            }
            else {
              int v65 = 0;
            }
            __asm { FCMP            H6, #0 }
            if (_ZF) {
              int v65 = 1;
            }
            short float v67 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / _H6;
            if (v65) {
              short float v67 = COERCE_SHORT_FLOAT(32256);
            }
            v53[v61] = v67;
            *(short float *)&data[2 * v61++] = v63;
          }
          while (a9 > (double)v61);
          ++v60;
          data += rowBytes;
          unint64_t v53 = (short float *)((char *)v53 + v54);
          v52 += v48;
          v51 += v49;
        }
        while (a10 > (double)v60);
      }
    }
    else if (v34)
    {
      if (v45)
      {
        unint64_t v58 = 0;
        do
        {
          unint64_t v59 = 0;
          do
            LOWORD(v53[v59++]) = 32256;
          while (a9 > (double)v59);
          ++v58;
          unint64_t v53 = (short float *)((char *)v53 + v54);
        }
        while (a10 > (double)v58);
      }
      else
      {
        unint64_t v80 = 0;
        do
        {
          unint64_t v81 = 0;
          do
          {
            __asm { FCMP            H2, #0 }
            if (_ZF) {
              short float v83 = COERCE_SHORT_FLOAT(32256);
            }
            else {
              short float v83 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / *(short float *)&v51[2 * v81];
            }
            v53[v81++] = v83;
          }
          while (a9 > (double)v81);
          ++v80;
          unint64_t v53 = (short float *)((char *)v53 + v54);
          v51 += v49;
        }
        while (a10 > (double)v80);
      }
    }
    else
    {
      unint64_t v68 = 0;
      do
      {
        unint64_t v69 = 0;
        do
        {
          short float v70 = *(short float *)&v51[2 * v69];
          short float v71 = *(short float *)&v52[2 * v69];
          if (v70 < _H2 || v70 > _H1) {
            LOWORD(v71) = COERCE_UNSIGNED_INT(10.0);
          }
          if (v71 >= _H0) {
            int v73 = v30;
          }
          else {
            int v73 = 0;
          }
          __asm { FCMP            H6, #0 }
          if (_ZF) {
            int v73 = 1;
          }
          short float v75 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / _H6;
          if (v73) {
            short float v75 = COERCE_SHORT_FLOAT(32256);
          }
          v53[v69++] = v75;
        }
        while (a9 > (double)v69);
        ++v68;
        unint64_t v53 = (short float *)((char *)v53 + v54);
        v52 += v48;
        v51 += v49;
      }
      while (a10 > (double)v68);
    }
  }
LABEL_85:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  if (a4) {
    CVPixelBufferUnlockBaseAddress(a4, 0);
  }
}

void sub_215F4A990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F4AB80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F4AD4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F4B0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);

  _Unwind_Resume(a1);
}

uint64_t getMaxOneShotEventsCount(void)
{
  return 15;
}

uint64_t getDateDiff(NSDate *a1, NSDate *a2, uint64_t a3)
{
  uint64_t v5 = a1;
  uint64_t v6 = a2;
  id v7 = objc_alloc(MEMORY[0x263EFF8F0]);
  int v8 = (void *)[v7 initWithCalendarIdentifier:*MEMORY[0x263EFF3F8]];
  int v9 = [v8 components:a3 fromDate:v5 toDate:v6 options:0];
  uint64_t v10 = [v9 day];

  return v10;
}

void sub_215F4B1B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t fireOneShotLargeRotationEventIfDetected(void *a1, unsigned int a2, void *a3, void *a4, float a5, float a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  id v11 = a1;
  id v12 = a3;
  id v13 = a4;
  uint64_t v14 = v13;
  if (fabsf(a5) <= a6 || v13 == 0) {
    goto LABEL_21;
  }
  if ((a2 & 0x80000000) != 0)
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "fireOneShotLargeRotationEventIfDetected: fail to understand history when tried to fire one shot large tolerance", buf, 2u);
    }
    goto LABEL_21;
  }
  uint64_t v16 = a2;
  uint64_t v17 = [v13 objectAtIndexedSubscript:a2];
  if (!v17)
  {
    id v19 = 0;
LABEL_20:

LABEL_21:
    uint64_t v22 = 0;
    goto LABEL_22;
  }
  unint64_t v18 = [MEMORY[0x263EFF910] distantPast];

  if (v17 != v18 && os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    uint64_t v29 = (uint64_t)v11;
    __int16 v30 = 2112;
    double v31 = *(double *)&v17;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "fireOneShotLargeRotationEventIfDetected: this event of large tolerance for %@ is not the first and it wa last sean at %@", buf, 0x16u);
  }
  id v19 = [MEMORY[0x263EFF910] now];
  if (getDateDiff(v17, v19, 16) < 60) {
    goto LABEL_20;
  }
  [v14 setObject:v19 atIndexedSubscript:v16];
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    uint64_t v29 = (uint64_t)v17;
    __int16 v30 = 2112;
    double v31 = *(double *)&v19;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "fireOneShotLargeRotationEventIfDetected: time since last large rotation event is >= then 2 monthes, last event time %@, current event time %@", buf, 0x16u);
  }

  uint64_t v25 = MEMORY[0x263EF8330];
  id v20 = v11;
  unint64_t v26 = v20;
  *(float *)&uint64_t v27 = a6;
  if (AnalyticsSendEventLazy())
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = objc_msgSend(v20, "UTF8String", v25, 3221225472, ___Z39fireOneShotLargeRotationEventIfDetectedPK8NSStringff12OneShotIndexPS_P14NSMutableArray_block_invoke, &unk_26425B868, v20, v27);
      *(_DWORD *)buf = 136315650;
      uint64_t v29 = v21;
      __int16 v30 = 2048;
      double v31 = a5;
      __int16 v32 = 2048;
      double v33 = a6;
      _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "fireOneShotLargeRotationEventIfDetected: rotation diff %s compare to factory %f > %f fired", buf, 0x20u);
    }

    goto LABEL_21;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    uint64_t v24 = objc_msgSend(v20, "UTF8String", v25, 3221225472, ___Z39fireOneShotLargeRotationEventIfDetectedPK8NSStringff12OneShotIndexPS_P14NSMutableArray_block_invoke, &unk_26425B868, v20, v27);
    *(_DWORD *)buf = 136315394;
    uint64_t v29 = v24;
    __int16 v30 = 2048;
    double v31 = a6;
    _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "fireOneShotLargeRotationEventIfDetected: rotation diff %s > %f compare to factory event failed to be seant", buf, 0x16u);
  }

  uint64_t v22 = 0xFFFFFFFFLL;
LABEL_22:

  return v22;
}

void sub_215F4B580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

id ___Z39fireOneShotLargeRotationEventIfDetectedPK8NSStringff12OneShotIndexPS_P14NSMutableArray_block_invoke(uint64_t a1, double a2)
{
  v9[3] = *MEMORY[0x263EF8340];
  unsigned int v2 = (_DWORD *)(a1 + 40);
  LODWORD(a2) = *(_DWORD *)(a1 + 40);
  v9[0] = *(void *)(a1 + 32);
  v8[0] = @"Axis";
  v8[1] = @"ToleranceThreshold";
  unsigned int v3 = [NSNumber numberWithFloat:a2];
  v9[1] = v3;
  v8[2] = @"ToleranceThreshold_v2";
  LODWORD(v4) = *v2;
  uint64_t v5 = [NSNumber numberWithFloat:v4];
  v9[2] = v5;
  uint64_t v6 = [NSDictionary dictionaryWithObjects:v9 forKeys:v8 count:3];

  return v6;
}

void sub_215F4B6DC(_Unwind_Exception *a1)
{
  unsigned int v3 = v2;

  _Unwind_Resume(a1);
}

void analyzeOneShotExtremeRotation(float a1, float a2, float a3, NSString *a4, NSMutableArray *a5)
{
  id v11 = a4;
  int v9 = a5;
  uint64_t v10 = (void *)MEMORY[0x2166C6180]();
  fireOneShotLargeRotationEventIfDetected(@"X", 0, v11, v9, a1, 6.0);
  fireOneShotLargeRotationEventIfDetected(@"X", 1u, v11, v9, a1, 12.0);
  fireOneShotLargeRotationEventIfDetected(@"X", 2u, v11, v9, a1, 18.0);
  fireOneShotLargeRotationEventIfDetected(@"X", 3u, v11, v9, a1, 36.0);
  fireOneShotLargeRotationEventIfDetected(@"X", 4u, v11, v9, a1, 60.0);
  fireOneShotLargeRotationEventIfDetected(@"Y", 5u, v11, v9, a2, 6.0);
  fireOneShotLargeRotationEventIfDetected(@"Y", 6u, v11, v9, a2, 12.0);
  fireOneShotLargeRotationEventIfDetected(@"Y", 7u, v11, v9, a2, 18.0);
  fireOneShotLargeRotationEventIfDetected(@"Y", 8u, v11, v9, a2, 36.0);
  fireOneShotLargeRotationEventIfDetected(@"Y", 9u, v11, v9, a2, 60.0);
  fireOneShotLargeRotationEventIfDetected(@"Z", 0xAu, v11, v9, a3, 6.0);
  fireOneShotLargeRotationEventIfDetected(@"Z", 0xBu, v11, v9, a3, 12.0);
  fireOneShotLargeRotationEventIfDetected(@"Z", 0xCu, v11, v9, a3, 18.0);
  fireOneShotLargeRotationEventIfDetected(@"Z", 0xDu, v11, v9, a3, 36.0);
  fireOneShotLargeRotationEventIfDetected(@"Z", 0xEu, v11, v9, a3, 60.0);
}

void sub_215F4B978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F4BC4C(_Unwind_Exception *a1)
{
  _ZNSt3__18functionIFNS_6vectorI7CGPointNS_9allocatorIS2_EEEERKNS1_IDv3_fNS3_IS6_EEEEEED1Ev((void *)(v4 - 88));

  _Unwind_Resume(a1);
}

void *_ZNSt3__18functionIFNS_6vectorI7CGPointNS_9allocatorIS2_EEEERKNS1_IDv3_fNS3_IS6_EEEEEED1Ev(void *a1)
{
  unsigned int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t _ZNSt3__110__function6__funcIZ53__ADWorldToImageProjection_initWithPose_calibration__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEEclESD_@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, char **a3@<X8>)
{
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  size_t v7 = v5 - v6;
  uint64_t v8 = (v5 - v6) >> 4;
  if (v5 == v6)
  {
    int v9 = 0;
  }
  else
  {
    if ((v7 & 0x8000000000000000) != 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    int v9 = (char *)operator new(v5 - v6);
    *a3 = v9;
    a3[2] = &v9[16 * v8];
    bzero(v9, v7);
    a3[1] = &v9[v7];
  }
  return [v4 project:v8 points:v6 outUndistortedPixels:v9];
}

void sub_215F4BD98(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

void _ZNSt3__110__function6__funcIZ53__ADWorldToImageProjection_initWithPose_calibration__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEE18destroy_deallocateEv(id *a1)
{
  operator delete(a1);
}

void _ZNSt3__110__function6__funcIZ53__ADWorldToImageProjection_initWithPose_calibration__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEE7destroyEv(uint64_t a1)
{
}

id _ZNKSt3__110__function6__funcIZ53__ADWorldToImageProjection_initWithPose_calibration__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEE7__cloneEPNS0_6__baseISE_EE(uint64_t a1, void *a2)
{
  unsigned int v3 = *(void **)(a1 + 8);
  *a2 = &unk_26C6876F8;
  id result = v3;
  a2[1] = result;
  return result;
}

void *_ZNKSt3__110__function6__funcIZ53__ADWorldToImageProjection_initWithPose_calibration__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEE7__cloneEv(uint64_t a1)
{
  unsigned int v2 = operator new(0x10uLL);
  unsigned int v3 = *(void **)(a1 + 8);
  void *v2 = &unk_26C6876F8;
  v2[1] = v3;
  return v2;
}

void _ZNSt3__110__function6__funcIZ53__ADWorldToImageProjection_initWithPose_calibration__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEED0Ev(uint64_t a1)
{
  JUMPOUT(0x2166C5D90);
}

uint64_t _ZNSt3__110__function6__funcIZ53__ADWorldToImageProjection_initWithPose_calibration__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEED1Ev(uint64_t a1)
{
  return a1;
}

void sub_215F4C528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void sub_215F4C7D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F4CD68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_215F4CF78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F4D280(_Unwind_Exception *a1)
{
  MEMORY[0x2166C5D90](v3, 0x1020C403903361BLL);

  _Unwind_Resume(a1);
}

void sub_215F4D79C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F4D7F4()
{
}

void sub_215F4DC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void (*a28)(char *))
{
  operator delete(v28);
  a28(&a26);

  _Unwind_Resume(a1);
}

void sub_215F4DFB0(_Unwind_Exception *a1)
{
  if (v2) {
    operator delete(v2);
  }

  _Unwind_Resume(a1);
}

void sub_215F4E9C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59,uint64_t a60,void *a61,uint64_t a62,int a63)
{
  if (v70) {
    (*(void (**)(uint64_t))(*(void *)v70 + 8))(v70);
  }

  if (a52 < 0) {
    operator delete(__p);
  }
  if (a59 < 0) {
    operator delete(a54);
  }
  if (a66 < 0) {
    operator delete(a61);
  }
  ((void (*)(char *))a69)(&a67);

  _Unwind_Resume(a1);
}

void *std::tuple<BOOL,float,float,std::vector<float>,std::vector<float>,std::vector<ADDisparityToDepthFitWorldPoint>>::~tuple(void *a1)
{
  unsigned int v2 = (void *)a1[8];
  if (v2)
  {
    a1[9] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[5];
  if (v3)
  {
    a1[6] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[2];
  if (v4)
  {
    a1[3] = v4;
    operator delete(v4);
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZ92__ADDispartiyToDepthFitEstimator_estimateWithDisparity_calibration_pose_disparityTimestamp__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEEclESD_(uint64_t a1@<X0>, uint64_t *a2@<X1>, char **a3@<X8>)
{
  uint64_t v7 = *a2;
  uint64_t v6 = a2[1];
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  int64_t v8 = v6 - v7;
  if (v6 == v7)
  {
    int v9 = 0;
    uint64_t v10 = 0;
    id v11 = 0;
  }
  else
  {
    if (v8 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    int v9 = (char *)operator new(v6 - v7);
    *a3 = v9;
    a3[2] = &v9[16 * (v8 >> 4)];
    bzero(v9, v8);
    a3[1] = &v9[v8];
    uint64_t v10 = (char *)operator new(v8);
    bzero(v10, v8);
    id v11 = &v10[v8];
  }
  id v12 = objc_alloc(MEMORY[0x263F26C40]);
  LODWORD(v13) = 1.0;
  uint64_t v14 = objc_msgSend(v12, "initWithIntrinsics:cameraToPlatformTransform:pixelSize:referenceDimensions:distortionModel:", 0, 0.0, 0.0, 0.0, *(double *)&_PromotedConst, unk_215FC5570, 0.0, unk_215FC5590, v13, 0x3FF0000000000000, 0x3FF0000000000000);
  objc_msgSend(v14, "transform:points:toCamera:outPoints:", (a2[1] - *a2) >> 4);
  [*(id *)(a1 + 8) project:(v11 - v10) >> 4 points:v10 outUndistortedPixels:v9];

  if (v10)
  {
    operator delete(v10);
  }
}

void sub_215F4EE3C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  operator delete(v2);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZ92__ADDispartiyToDepthFitEstimator_estimateWithDisparity_calibration_pose_disparityTimestamp__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEE18destroy_deallocateEv(id *a1)
{
  operator delete(a1);
}

void _ZNSt3__110__function6__funcIZ92__ADDispartiyToDepthFitEstimator_estimateWithDisparity_calibration_pose_disparityTimestamp__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEE7destroyEv(uint64_t a1)
{
}

id _ZNKSt3__110__function6__funcIZ92__ADDispartiyToDepthFitEstimator_estimateWithDisparity_calibration_pose_disparityTimestamp__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEE7__cloneEPNS0_6__baseISE_EE(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  *a2 = &unk_26C687740;
  id result = v3;
  a2[1] = result;
  return result;
}

void *_ZNKSt3__110__function6__funcIZ92__ADDispartiyToDepthFitEstimator_estimateWithDisparity_calibration_pose_disparityTimestamp__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEE7__cloneEv(uint64_t a1)
{
  unsigned int v2 = operator new(0x10uLL);
  uint64_t v3 = *(void **)(a1 + 8);
  void *v2 = &unk_26C687740;
  v2[1] = v3;
  return v2;
}

void _ZNSt3__110__function6__funcIZ92__ADDispartiyToDepthFitEstimator_estimateWithDisparity_calibration_pose_disparityTimestamp__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEED0Ev(uint64_t a1)
{
  JUMPOUT(0x2166C5D90);
}

uint64_t _ZNSt3__110__function6__funcIZ92__ADDispartiyToDepthFitEstimator_estimateWithDisparity_calibration_pose_disparityTimestamp__E3__0NS_9allocatorIS2_EEFNS_6vectorI7CGPointNS3_IS6_EEEERKNS5_IDv3_fNS3_IS9_EEEEEED1Ev(uint64_t a1)
{
  return a1;
}

void sub_215F4F1EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_215F4F650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F4F700(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ADDebugUtils::setVerboseLogsEnabled(ADDebugUtils *this)
{
  int v1 = (int)this;
  uint64_t v3 = *MEMORY[0x263EF8340];
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    v2[0] = 67109120;
    v2[1] = v1;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "setting verboseLogs: %d", (uint8_t *)v2, 8u);
  }
  ADDebugUtilsADVerboseLogsEnabled = v1;
}

uint64_t ADDebugUtils::isVerboseLogsEnabled(ADDebugUtils *this)
{
  return ADDebugUtilsADVerboseLogsEnabled;
}

uint64_t debugQuickLookObjectFromCGImage(CGImage *a1)
{
  Class v2 = NSClassFromString(&cfstr_Uiimage.isa);
  SEL v3 = NSSelectorFromString(&cfstr_Imagewithcgima.isa);
  uint64_t v4 = (uint64_t (*)(Class, SEL, CGImage *))[(objc_class *)v2 methodForSelector:v3];
  return v4(v2, v3, a1);
}

void sub_215F4F8F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F4FBB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F4FC78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADDensifiedLiDARFocusAssistExecutor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F50A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,char a31)
{
  objc_sync_exit(v32);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)&a31);

  _Unwind_Resume(a1);
}

void sub_215F50C0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F50DB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F50F74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  objc_sync_exit(v2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F5111C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F51340(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F513A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F517BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);

  _Unwind_Resume(a1);
}

void sub_215F51D34(_Unwind_Exception *a1, void *a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);

  _Unwind_Resume(a1);
}

void sub_215F524D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F52698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F52A38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F52BF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F52CC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F52E34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F5308C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F531CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F5336C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F53568(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F536E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F53764(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F537C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F54EA8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_215F54FC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F56270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  _Unwind_Resume(a1);
}

void sub_215F56C00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{
  _Unwind_Resume(a1);
}

void sub_215F56EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F56FDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F57120(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADJasperColorInFieldCalibrationExecutor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F57594(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F576D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F57810(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F57A30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F57FE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F58094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F58150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_215F582B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F58384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F58584(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F587C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t crc32ForFolder(NSString *a1)
{
  v27[1] = *MEMORY[0x263EF8340];
  double v13 = a1;
  uint64_t v14 = [MEMORY[0x263F08850] defaultManager];
  int v1 = [NSURL fileURLWithPath:v13];
  uint64_t v2 = *MEMORY[0x263EFF6A8];
  v27[0] = *MEMORY[0x263EFF6A8];
  SEL v3 = [MEMORY[0x263EFF8C0] arrayWithObjects:v27 count:1];
  int v15 = [v14 enumeratorAtURL:v1 includingPropertiesForKeys:v3 options:4 errorHandler:0];

  uint64_t v22 = 0;
  int v23 = &v22;
  uint64_t v24 = 0x2020000000;
  int v25 = 0;
  int v25 = crc32(0, 0, 0);
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v4 = v15;
  uint64_t v5 = [v4 countByEnumeratingWithState:&v18 objects:v26 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v19;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v19 != v6) {
          objc_enumerationMutation(v4);
        }
        int64_t v8 = *(void **)(*((void *)&v18 + 1) + 8 * v7);
        id v17 = 0;
        [v8 getResourceValue:&v17 forKey:v2 error:0];
        id v9 = v17;
        if (([v9 BOOLValue] & 1) == 0)
        {
          uint64_t v10 = [MEMORY[0x263EFF8F8] dataWithContentsOfURL:v8];
          v16[0] = MEMORY[0x263EF8330];
          v16[1] = 3221225472;
          v16[2] = ___Z14crc32ForFolderP8NSString_block_invoke;
          v16[3] = &unk_26425B890;
          v16[4] = &v22;
          [v10 enumerateByteRangesUsingBlock:v16];
        }
        ++v7;
      }
      while (v5 != v7);
      uint64_t v5 = [v4 countByEnumeratingWithState:&v18 objects:v26 count:16];
    }
    while (v5);
  }

  uint64_t v11 = *((unsigned int *)v23 + 6);
  _Block_object_dispose(&v22, 8);

  return v11;
}

void sub_215F58B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

uint64_t waitForFolder(NSString *a1, double a2)
{
  SEL v3 = a1;
  id v4 = [MEMORY[0x263F08850] defaultManager];
  uint64_t v5 = [MEMORY[0x263EFF910] date];
  while (1)
  {
    uint64_t v6 = [v4 fileExistsAtPath:v3];
    if (v6) {
      break;
    }
    uint64_t v7 = [MEMORY[0x263EFF910] date];
    [v7 timeIntervalSinceDate:v5];
    double v9 = v8;

    if (v9 >= a2) {
      break;
    }
    [MEMORY[0x263F08B88] sleepForTimeInterval:1.0];
  }

  return v6;
}

void sub_215F58C8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___Z18bundleE5mlIfNeededP8NSStringS0_S0_b_block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v2 = objc_msgSend(*(id *)(a1 + 32), "contentsOfDirectoryAtPath:error:", *(void *)(a1 + 40), 0, 0);
  uint64_t v3 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v11;
    do
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        if (*(void *)v11 != v4) {
          objc_enumerationMutation(v2);
        }
        uint64_t v6 = *(void **)(*((void *)&v10 + 1) + 8 * i);
        if (([v6 isEqualToString:*(void *)(a1 + 48)] & 1) == 0)
        {
          uint64_t v7 = *(void **)(a1 + 32);
          double v8 = [*(id *)(a1 + 40) stringByAppendingPathComponent:v6];
          [v7 removeItemAtPath:v8 error:0];
        }
      }
      uint64_t v3 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v3);
  }

  return rmdir((const char *)[*(id *)(a1 + 56) fileSystemRepresentation]);
}

void sub_215F58E14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id prepareAneFlags(NSDictionary *a1, NSString *a2, NSString *a3, int a4)
{
  v35[1] = *MEMORY[0x263EF8340];
  uint64_t v27 = a1;
  int v25 = a2;
  unint64_t v26 = a3;
  float v28 = [MEMORY[0x263EFF9A0] dictionary];
  [v28 setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"KernelRewind"];
  uint64_t v7 = [(NSDictionary *)v27 objectForKeyedSubscript:@"spatialSplitMode"];
  uint64_t v8 = [v7 length];

  if (v8)
  {
    double v9 = [(NSDictionary *)v27 objectForKeyedSubscript:@"spatialSplitMode"];
    [v28 setObject:v9 forKeyedSubscript:@"SpatialSplitMode"];
  }
  [v28 setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"ScanWeightsForCompression"];
  long long v10 = [(NSDictionary *)v27 objectForKeyedSubscript:@"useReductionPerformance"];
  int v11 = [v10 BOOLValue];

  if (v11) {
    [v28 setObject:@"ReductionPerf" forKeyedSubscript:@"Optimize"];
  }
  if (a4)
  {
    [v28 setObject:&unk_26C698310 forKeyedSubscript:@"NeFrequency"];
    [v28 setObject:&unk_26C698328 forKeyedSubscript:@"PstateDCSLevel"];
    [v28 setObject:&unk_26C698340 forKeyedSubscript:@"PstateSOCLevel"];
    [v28 setObject:MEMORY[0x263EFFA88] forKeyedSubscript:@"EnableContextSwitchEvents"];
  }
  long long v12 = [(NSString *)v25 lowercaseString];
  uint64_t v34 = v12;
  v35[0] = v28;
  long long v13 = [NSDictionary dictionaryWithObjects:v35 forKeys:&v34 count:1];
  [v13 writeToFile:v26 atomically:1];

  uint64_t v14 = [MEMORY[0x263EFF980] array];
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id v15 = v28;
  uint64_t v16 = [v15 countByEnumeratingWithState:&v29 objects:v33 count:16];
  if (v16)
  {
    uint64_t v17 = *(void *)v30;
    do
    {
      for (uint64_t i = 0; i != v16; ++i)
      {
        if (*(void *)v30 != v17) {
          objc_enumerationMutation(v15);
        }
        uint64_t v19 = *(void *)(*((void *)&v29 + 1) + 8 * i);
        long long v20 = NSString;
        long long v21 = [v15 objectForKeyedSubscript:v19];
        uint64_t v22 = [v20 stringWithFormat:@"%@=%@", v19, v21];
        [v14 addObject:v22];
      }
      uint64_t v16 = [v15 countByEnumeratingWithState:&v29 objects:v33 count:16];
    }
    while (v16);
  }

  int v23 = [v14 componentsJoinedByString:@","];

  return v23;
}

void sub_215F59194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t compileE5mlBundle(NSString *a1, NSString *a2, int a3, NSString *a4, NSString *a5, NSString *a6)
{
  v38[9] = *MEMORY[0x263EF8340];
  int v11 = a1;
  long long v12 = a2;
  long long v13 = a4;
  uint64_t v14 = a5;
  id v15 = a6;
  id v16 = objc_alloc_init(MEMORY[0x263F08B50]);
  uint64_t v17 = [NSURL fileURLWithPath:@"/usr/local/bin/espressoc"];
  [v16 setExecutableURL:v17];

  if (a3)
  {
    long long v18 = [(NSString *)v11 pathExtension];
    int v19 = [v18 isEqualToString:@"net"];

    if (v19)
    {
      v38[0] = @"--e5-require-ane-resident=strict";
      v38[1] = @"--ane-options-plist";
      v38[2] = v14;
      v38[3] = @"-i";
      v38[4] = v11;
      v38[5] = @"-p";
      v38[6] = v13;
      v38[7] = @"-o";
      v38[8] = v12;
      long long v20 = [MEMORY[0x263EFF8C0] arrayWithObjects:v38 count:9];
      [v16 setArguments:v20];
    }
    else
    {
      v37[0] = @"--mil-entry-points";
      v37[1] = @"*";
      v37[2] = @"--e5-compute-units";
      v37[3] = @"ane";
      v37[4] = @"--e5-require-ane-resident=strict";
      v37[5] = @"--ane-options";
      v37[6] = v15;
      v37[7] = @"-i";
      v37[8] = v11;
      v37[9] = @"-p";
      v37[10] = v13;
      v37[11] = @"-o";
      v37[12] = v12;
      long long v20 = [MEMORY[0x263EFF8C0] arrayWithObjects:v37 count:13];
      [v16 setArguments:v20];
    }
  }
  else
  {
    v36[0] = @"--mil-entry-points";
    v36[1] = @"*";
    v36[2] = @"-i";
    v36[3] = v11;
    v36[4] = @"-p";
    v36[5] = @"universal";
    v36[6] = @"-o";
    v36[7] = v12;
    long long v20 = [MEMORY[0x263EFF8C0] arrayWithObjects:v36 count:8];
    [v16 setArguments:v20];
  }

  if (ADDebugUtilsADVerboseLogsEnabled)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
    long long v21 = [v16 executableURL];
    uint64_t v22 = [v21 path];
    int v23 = [v16 arguments];
    int v32 = 138412546;
    double v33 = v22;
    __int16 v34 = 2112;
    uint64_t v35 = v23;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "running %@ with arguments: %@", (uint8_t *)&v32, 0x16u);
  }
  else
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_13;
    }
    long long v29 = [v16 executableURL];
    long long v30 = [v29 path];
    long long v31 = [v16 arguments];
    int v32 = 138412546;
    double v33 = v30;
    __int16 v34 = 2112;
    uint64_t v35 = v31;
    _os_log_debug_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEBUG, "running %@ with arguments: %@", (uint8_t *)&v32, 0x16u);
  }
  if (ADDebugUtilsADVerboseLogsEnabled)
  {
LABEL_10:
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      int v32 = 138412290;
      double v33 = v15;
      _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "ANE options: %@", (uint8_t *)&v32, 0xCu);
    }
    goto LABEL_15;
  }
LABEL_13:
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEBUG))
  {
    int v32 = 138412290;
    double v33 = v15;
    _os_log_debug_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEBUG, "ANE options: %@", (uint8_t *)&v32, 0xCu);
  }
LABEL_15:
  if ([v16 launchAndReturnError:0]
    && ([v16 waitUntilExit], !objc_msgSend(v16, "terminationStatus")))
  {
    uint64_t v24 = 1;
  }
  else
  {
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      unint64_t v26 = [v16 executableURL];
      uint64_t v27 = [v26 path];
      float v28 = [v16 arguments];
      int v32 = 138543618;
      double v33 = v27;
      __int16 v34 = 2114;
      uint64_t v35 = v28;
      _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "failed to run %{public}@ with arguments: %{public}@", (uint8_t *)&v32, 0x16u);
    }
    uint64_t v24 = 0;
  }

  return v24;
}

void sub_215F59764(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t verifyMachoFlags(NSString *a1, NSDictionary *a2)
{
  v43[2] = *MEMORY[0x263EF8340];
  uint64_t v3 = a1;
  uint64_t v4 = a2;
  id v5 = objc_alloc_init(MEMORY[0x263F08B50]);
  uint64_t v6 = [NSURL fileURLWithPath:@"/usr/local/bin/zin_ane_dump"];
  [v5 setExecutableURL:v6];

  v43[0] = @"-i";
  v43[1] = v3;
  uint64_t v7 = [MEMORY[0x263EFF8C0] arrayWithObjects:v43 count:2];
  [v5 setArguments:v7];

  uint64_t v8 = [MEMORY[0x263F08A80] pipe];
  [v5 setStandardOutput:v8];
  if ([v5 launchAndReturnError:0])
  {
    [v5 waitUntilExit];
    if (![v5 terminationStatus])
    {
      id v11 = [NSString alloc];
      long long v12 = [v8 fileHandleForReading];
      long long v13 = [v12 readDataToEndOfFileAndReturnError:0];
      uint64_t v14 = (void *)[v11 initWithData:v13 encoding:4];

      uint64_t v15 = [v14 rangeOfString:@"\\n\\s*--fspatial-split=" options:1024];
      if (v15 == 0x7FFFFFFFFFFFFFFFLL)
      {
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "unable to find ANE compilation flag SpatialSplitMode", buf, 2u);
        }
        uint64_t v9 = 0;
        goto LABEL_27;
      }
      uint64_t v17 = [v14 substringFromIndex:v15 + v16];
      long long v18 = objc_msgSend(v17, "substringToIndex:", objc_msgSend(v17, "rangeOfString:", @"\n"));

      uint64_t v38 = [v18 stringByReplacingOccurrencesOfString:@"-" withString:&stru_26C6879A8];

      int v19 = [(NSDictionary *)v4 objectForKeyedSubscript:@"spatialSplitMode"];
      long long v20 = [v19 lowercaseString];

      if (([(__CFString *)v20 isEqualToString:v38] & 1) == 0
        && (v20 || ([v38 isEqualToString:@"disabled"] & 1) == 0))
      {
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543618;
          char v40 = v20;
          __int16 v41 = 2114;
          size_t v42 = v38;
          _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "mismatch in ANE compilation flag SpatialSplitMode between {%{public}@} and {%{public}@}", buf, 0x16u);
        }
        uint64_t v9 = 0;
        goto LABEL_26;
      }
      uint64_t v21 = [v14 rangeOfString:@"\\n\\s*--optimize=" options:1024];
      if (v21 == 0x7FFFFFFFFFFFFFFFLL)
      {
        int v23 = &stru_26C6879A8;
      }
      else
      {
        uint64_t v27 = [v14 substringFromIndex:v21 + v22];
        uint64_t v28 = objc_msgSend(v27, "substringToIndex:", objc_msgSend(v27, "rangeOfString:", @"\n"));

        int v23 = (__CFString *)v28;
      }
      long long v29 = [(NSDictionary *)v4 objectForKeyedSubscript:@"useReductionPerformance"];
      int v30 = [v29 BOOLValue];
      int v31 = [(__CFString *)v23 isEqualToString:@"reduction-perf"];

      int v32 = v30 ^ v31;
      if (v32)
      {
        double v33 = [(NSDictionary *)v4 objectForKeyedSubscript:@"useReductionPerformance"];
        int v34 = [v33 BOOLValue];

        BOOL v35 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        if (v34)
        {
          if (v35)
          {
            *(_DWORD *)buf = 138543362;
            char v40 = v23;
            unsigned int v36 = &_os_log_internal;
            uint64_t v37 = "mismatch in ANE compilation flag Optimize. Expected {reduction-perf} and got {%{public}@}";
LABEL_29:
            _os_log_error_impl(&dword_215F16000, v36, OS_LOG_TYPE_ERROR, v37, buf, 0xCu);
          }
        }
        else if (v35)
        {
          *(_DWORD *)buf = 138543362;
          char v40 = v23;
          unsigned int v36 = &_os_log_internal;
          uint64_t v37 = "mismatch in ANE compilation flag Optimize. Expected {} and got {%{public}@}";
          goto LABEL_29;
        }
      }

      uint64_t v9 = v32 ^ 1u;
LABEL_26:

LABEL_27:
      goto LABEL_6;
    }
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    uint64_t v24 = [v5 executableURL];
    int v25 = [v24 path];
    unint64_t v26 = [v5 arguments];
    *(_DWORD *)buf = 138543618;
    char v40 = v25;
    __int16 v41 = 2114;
    size_t v42 = v26;
    _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "failed to run %{public}@ with arguments: %{public}@", buf, 0x16u);
  }
  uint64_t v9 = 0;
LABEL_6:

  return v9;
}

void sub_215F59D5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uLong ___Z14crc32ForFolderP8NSString_block_invoke(uint64_t a1, const Bytef *a2, int a3, uInt len)
{
  uLong result = crc32(*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), a2, len);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t AdaptiveCorrection_create(unsigned int a1, void *a2)
{
  memset(v3, 0, sizeof(v3));
  return AdaptiveCorrection_createWithConfig(a1, v3, a2);
}

uint64_t AdaptiveCorrection_createWithConfig(unsigned int a1, long long *a2, void *a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = 4294954516;
  if ((int)a1 >= 1 && a2 && a3)
  {
    uint64_t v3 = (char *)malloc_type_calloc(1uLL, 0x20E0uLL, 0x1080040D8A15840uLL);
    if (!v3) {
      goto LABEL_14;
    }
    uint64_t v8 = malloc_type_malloc(16 * a1, 0x100004000313F17uLL);
    *((void *)v3 + 1045) = v8;
    if (!v8) {
      goto LABEL_14;
    }
    uint64_t v9 = malloc_type_malloc(16 * a1, 0x100004000313F17uLL);
    *((void *)v3 + 1046) = v9;
    if (!v9) {
      goto LABEL_14;
    }
    long long v10 = malloc_type_malloc(16 * a1, 0x100004000313F17uLL);
    *((void *)v3 + 1047) = v10;
    if (!v10) {
      goto LABEL_14;
    }
    id v11 = malloc_type_malloc(16 * a1, 0x100004000313F17uLL);
    *((void *)v3 + 1048) = v11;
    if (!v11) {
      goto LABEL_14;
    }
    long long v12 = malloc_type_malloc(16 * a1, 0x100004000313F17uLL);
    *((void *)v3 + 1049) = v12;
    if (v12
      && (long long v13 = malloc_type_malloc(16 * a1, 0x100004000313F17uLL), (*((void *)v3 + 1050) = v13) != 0)
      && (uint64_t v14 = malloc_type_malloc(8 * a1, 0x100004000313F17uLL), (*((void *)v3 + 1051) = v14) != 0))
    {
      uint64_t v4 = 0;
      *(_DWORD *)uint64_t v3 = a1;
      long long v15 = *a2;
      long long v16 = a2[1];
      long long v17 = a2[2];
      *(_OWORD *)(v3 + 56) = a2[3];
      *(_OWORD *)(v3 + 40) = v17;
      *(_OWORD *)(v3 + 24) = v16;
      *(_OWORD *)(v3 + 8) = v15;
      long long v18 = a2[4];
      long long v19 = a2[5];
      long long v20 = a2[6];
      *(_OWORD *)(v3 + 120) = a2[7];
      *(_OWORD *)(v3 + 104) = v20;
      *(_OWORD *)(v3 + 88) = v19;
      *(_OWORD *)(v3 + 72) = v18;
      *a3 = v3;
      uint64_t v3 = 0;
    }
    else
    {
LABEL_14:
      uint64_t v4 = 4294954510;
    }
  }
  AdaptiveCorrection_destroy((void **)v3);
  return v4;
}

void AdaptiveCorrection_destroy(void **a1)
{
  if (a1)
  {
    free(a1[1045]);
    free(a1[1046]);
    free(a1[1047]);
    free(a1[1048]);
    free(a1[1049]);
    free(a1[1050]);
    free(a1[1051]);
    free(a1);
  }
}

__n128 AdaptiveCorrection_setConfiguration(uint64_t a1, long long *a2)
{
  if (a1)
  {
    if (a2)
    {
      long long v2 = *a2;
      long long v3 = a2[1];
      long long v4 = a2[2];
      *(_OWORD *)(a1 + 56) = a2[3];
      *(_OWORD *)(a1 + 40) = v4;
      *(_OWORD *)(a1 + 24) = v3;
      *(_OWORD *)(a1 + 8) = v2;
      __n128 result = (__n128)a2[4];
      long long v6 = a2[5];
      long long v7 = a2[6];
      *(_OWORD *)(a1 + 120) = a2[7];
      *(_OWORD *)(a1 + 104) = v7;
      *(_OWORD *)(a1 + 88) = v6;
      *(__n128 *)(a1 + 72) = result;
    }
  }
  return result;
}

void AdaptiveCorrection_getStatus(uint64_t a1@<X0>, void *a2@<X8>)
{
  bzero(a2, 0x1E48uLL);
  if (a1)
  {
    memcpy(a2, (const void *)(a1 + 136), 0x1E48uLL);
  }
}

uint64_t AdaptiveCorrection_fullTemporalCorrectionWithDistortion(uint64_t a1, uint64_t a2, uint64_t a3, signed int a4, float64x2_t *a5, float64x2_t *a6, float64x2_t *a7, double a8, double a9, double a10, double a11, int32x4_t a12, int32x4_t a13, double a14, int32x4_t a15)
{
  uint64_t result = 4294954516;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4 >= 1)
        {
          if (a7)
          {
            if (a6)
            {
              if (a5)
              {
                if (*(_DWORD *)a1 >= a4)
                {
                  double v167 = a5->f64[1];
                  double v168 = a5->f64[0];
                  double v20 = a5[2].f64[0];
                  double v125 = a5[1].f64[1];
                  double v126 = a5[1].f64[0];
                  double v21 = a5[3].f64[0];
                  double v22 = a5[3].f64[1];
                  double v123 = a5[4].f64[0];
                  double v124 = a5[2].f64[1];
                  double v122 = a5[4].f64[1];
                  double v166 = a5[5].f64[0];
                  double v121 = a5[5].f64[1];
                  double v165 = a5[6].f64[0];
                  double v119 = a5[7].f64[0];
                  double v120 = a5[6].f64[1];
                  double v163 = a5[8].f64[0];
                  double v164 = a5[7].f64[1];
                  double v161 = a5[9].f64[0];
                  double v162 = a5[8].f64[1];
                  double v159 = a6->f64[0];
                  double v160 = a5[9].f64[1];
                  double v157 = a6[1].f64[0];
                  double v158 = a6->f64[1];
                  double v155 = a6[2].f64[0];
                  double v156 = a6[1].f64[1];
                  double v153 = a6[3].f64[0];
                  double v154 = a6[2].f64[1];
                  double v151 = a6[4].f64[0];
                  double v152 = a6[3].f64[1];
                  double v150 = a6[4].f64[1];
                  double v149 = a6[5].f64[0];
                  double v148 = a6[6].f64[0];
                  double v147 = a6[6].f64[1];
                  double v146 = a6[7].f64[0];
                  double v145 = a6[7].f64[1];
                  double v144 = a6[8].f64[0];
                  double v143 = a6[8].f64[1];
                  double v142 = a6[9].f64[0];
                  double v127 = a6[9].f64[1];
                  double v128 = a6[5].f64[1];
                  double v23 = a7->f64[0];
                  double v141 = a7->f64[1];
                  double v24 = a7[1].f64[0];
                  double v140 = a7[1].f64[1];
                  double v25 = a7[2].f64[0];
                  double v26 = a7[2].f64[1];
                  double v27 = a7[3].f64[0];
                  double v139 = a7[3].f64[1];
                  double v138 = a7[4].f64[0];
                  double v136 = a7[5].f64[0];
                  double v137 = a7[4].f64[1];
                  double v134 = a7[6].f64[0];
                  double v135 = a7[5].f64[1];
                  double v132 = a7[7].f64[0];
                  double v133 = a7[6].f64[1];
                  double v130 = a7[8].f64[0];
                  double v131 = a7[7].f64[1];
                  double v129 = a7[8].f64[1];
                  uint64_t result = AdaptiveCorrection_fullCorrectionWithDistortion(a1, a2, a3, a4, a5->f64, a6->f64, a7->f64, v129, v131, a10, a11, a12, a13, a14, a15);
                  if (!result)
                  {
                    double v28 = v22;
                    double v29 = v21;
                    double v30 = a7->f64[0] - v23;
                    double v31 = a7[1].f64[0] - v24;
                    double v32 = a7[2].f64[0] - v25;
                    double v33 = a7->f64[1] - v141;
                    double v34 = a7[1].f64[1] - v140;
                    double v35 = a7[2].f64[1] - v26;
                    double v36 = a7[3].f64[0] - v27;
                    double v37 = a7[3].f64[1] - v139;
                    double v38 = a7[4].f64[0] - v138;
                    double v81 = a7[4].f64[1] - v137;
                    double v82 = a7[5].f64[0] - v136;
                    double v83 = a7[5].f64[1] - v135;
                    double v84 = a7[6].f64[0] - v134;
                    double v85 = a7[6].f64[1] - v133;
                    double v86 = a7[7].f64[0] - v132;
                    double v87 = a7[7].f64[1] - v131;
                    double v88 = a7[8].f64[0] - v130;
                    double v89 = a7[8].f64[1] - v129;
                    double v90 = a5->f64[1] - v167;
                    double v39 = a5[1].f64[0] - v126;
                    double v40 = a5[1].f64[1] - v125;
                    double v41 = a5->f64[0] - v168;
                    double v42 = a5[2].f64[0] - v20;
                    double v91 = a5[6].f64[0] - v165;
                    double v43 = a5[2].f64[1] - v124;
                    double v92 = a5[6].f64[1] - v120;
                    double v118 = v29;
                    double v44 = a5[3].f64[0] - v29;
                    double v93 = a5[7].f64[0] - v119;
                    double v45 = a5[3].f64[1] - v28;
                    double v94 = a5[7].f64[1] - v164;
                    double v46 = a5[4].f64[0] - v123;
                    double v95 = a5[8].f64[0] - v163;
                    double v47 = a5[4].f64[1] - v122;
                    double v96 = a5[8].f64[1] - v162;
                    double v48 = a5[5].f64[0] - v166;
                    double v97 = a5[9].f64[0] - v161;
                    double v49 = a5[5].f64[1] - v121;
                    double v99 = a5[9].f64[1] - v160;
                    double v100 = a6->f64[1] - v158;
                    double v101 = a6[1].f64[0] - v157;
                    double v102 = a6[1].f64[1] - v156;
                    double v98 = a6->f64[0] - v159;
                    double v103 = a6[2].f64[0] - v155;
                    double v107 = a6[6].f64[0] - v148;
                    double v104 = a6[2].f64[1] - v154;
                    double v109 = a6[6].f64[1] - v147;
                    double v105 = a6[3].f64[0] - v153;
                    double v113 = a6[7].f64[0] - v146;
                    double v106 = a6[3].f64[1] - v152;
                    double v114 = a6[7].f64[1] - v145;
                    double v108 = a6[4].f64[0] - v151;
                    double v115 = a6[8].f64[0] - v144;
                    double v110 = a6[4].f64[1] - v150;
                    double v116 = a6[8].f64[1] - v143;
                    double v111 = a6[5].f64[0] - v149;
                    double v117 = a6[9].f64[0] - v142;
                    double v50 = v128;
                    double v112 = a6[5].f64[1] - v128;
                    double v51 = v127;
                    double v52 = a6[9].f64[1] - v127;
                    if (*(unsigned char *)(a1 + 7888))
                    {
                      float v53 = *(float *)(a1 + 128);
                      float v54 = 1.0 - v53;
                      double v55 = v53;
                      double v56 = v54;
                      *(double *)(a1 + 7896) = *(double *)(a1 + 7896) * v55 + v30 * v56;
                      *(double *)(a1 + 7904) = v33 * v56 + *(double *)(a1 + 7904) * v55;
                      *(double *)(a1 + 7912) = v31 * v56 + *(double *)(a1 + 7912) * v55;
                      *(double *)(a1 + 7920) = v34 * v56 + *(double *)(a1 + 7920) * v55;
                      *(double *)(a1 + 7928) = v32 * v56 + *(double *)(a1 + 7928) * v55;
                      *(double *)(a1 + 7936) = v35 * v56 + *(double *)(a1 + 7936) * v55;
                      *(double *)(a1 + 7944) = v36 * v56 + *(double *)(a1 + 7944) * v55;
                      *(double *)(a1 + 7952) = v37 * v56 + *(double *)(a1 + 7952) * v55;
                      *(double *)(a1 + 7960) = v38 * v56 + *(double *)(a1 + 7960) * v55;
                      *(double *)(a1 + 7968) = v81 * v56 + *(double *)(a1 + 7968) * v55;
                      *(double *)(a1 + 7976) = v82 * v56 + *(double *)(a1 + 7976) * v55;
                      *(double *)(a1 + 7984) = v83 * v56 + *(double *)(a1 + 7984) * v55;
                      *(double *)(a1 + 7992) = v84 * v56 + *(double *)(a1 + 7992) * v55;
                      *(double *)(a1 + 8000) = v85 * v56 + *(double *)(a1 + 8000) * v55;
                      *(double *)(a1 + 8008) = v86 * v56 + *(double *)(a1 + 8008) * v55;
                      *(double *)(a1 + 8016) = v87 * v56 + *(double *)(a1 + 8016) * v55;
                      *(double *)(a1 + 8024) = v88 * v56 + *(double *)(a1 + 8024) * v55;
                      *(double *)(a1 + 8032) = v89 * v56 + *(double *)(a1 + 8032) * v55;
                      *(double *)(a1 + 8040) = v41 * v56 + *(double *)(a1 + 8040) * v55;
                      *(double *)(a1 + 8048) = v90 * v56 + *(double *)(a1 + 8048) * v55;
                      *(double *)(a1 + 8056) = v39 * v56 + *(double *)(a1 + 8056) * v55;
                      *(double *)(a1 + 8064) = v40 * v56 + *(double *)(a1 + 8064) * v55;
                      *(double *)(a1 + 8072) = v42 * v56 + *(double *)(a1 + 8072) * v55;
                      *(double *)(a1 + 8080) = v43 * v56 + *(double *)(a1 + 8080) * v55;
                      *(double *)(a1 + 8088) = v44 * v56 + *(double *)(a1 + 8088) * v55;
                      *(double *)(a1 + 8096) = v45 * v56 + *(double *)(a1 + 8096) * v55;
                      *(double *)(a1 + 8104) = v46 * v56 + *(double *)(a1 + 8104) * v55;
                      *(double *)(a1 + 8112) = v47 * v56 + *(double *)(a1 + 8112) * v55;
                      *(double *)(a1 + 8120) = v48 * v56 + *(double *)(a1 + 8120) * v55;
                      *(double *)(a1 + 8128) = v49 * v56 + *(double *)(a1 + 8128) * v55;
                      *(double *)(a1 + 8136) = v91 * v56 + *(double *)(a1 + 8136) * v55;
                      *(double *)(a1 + 8144) = v92 * v56 + *(double *)(a1 + 8144) * v55;
                      *(double *)(a1 + 8152) = v93 * v56 + *(double *)(a1 + 8152) * v55;
                      *(double *)(a1 + 8160) = v94 * v56 + *(double *)(a1 + 8160) * v55;
                      *(double *)(a1 + 8168) = v95 * v56 + *(double *)(a1 + 8168) * v55;
                      *(double *)(a1 + 8176) = v96 * v56 + *(double *)(a1 + 8176) * v55;
                      *(double *)(a1 + 8184) = v97 * v56 + *(double *)(a1 + 8184) * v55;
                      *(double *)(a1 + 0x2000) = v99 * v56 + *(double *)(a1 + 0x2000) * v55;
                      *(double *)(a1 + 8200) = v98 * v56 + *(double *)(a1 + 8200) * v55;
                      double v57 = v101 * v56 + *(double *)(a1 + 8216) * v55;
                      double v58 = *(double *)(a1 + 8224);
                      *(double *)(a1 + 8208) = v100 * v56 + *(double *)(a1 + 8208) * v55;
                      double v59 = *(double *)(a1 + 8240);
                      double v60 = v103 * v56 + *(double *)(a1 + 8232) * v55;
                      double v61 = *(double *)(a1 + 8248);
                      *(double *)(a1 + 8216) = v57;
                      double v62 = v107 * v56 + *(double *)(a1 + 8296) * v55;
                      double v63 = *(double *)(a1 + 8256);
                      double v64 = *(double *)(a1 + 8264);
                      *(double *)(a1 + 8224) = v102 * v56 + v58 * v55;
                      double v65 = v109 * v56 + *(double *)(a1 + 8304) * v55;
                      double v66 = *(double *)(a1 + 8272);
                      double v67 = *(double *)(a1 + 8280);
                      *(double *)(a1 + 8232) = v60;
                      double v68 = *(double *)(a1 + 8288);
                      double v69 = *(double *)(a1 + 8312);
                      double v70 = *(double *)(a1 + 8320);
                      *(double *)(a1 + 8240) = v104 * v56 + v59 * v55;
                      double v71 = *(double *)(a1 + 8328);
                      double v72 = v69 * v55;
                      double v73 = v70 * v55;
                      *(double *)(a1 + 8248) = v105 * v56 + v61 * v55;
                      double v74 = v71 * v55;
                      double v75 = v66 * v55;
                      double v76 = *(double *)(a1 + 8336) * v55;
                      *(double *)(a1 + 8256) = v106 * v56 + v63 * v55;
                      double v77 = v67 * v55;
                      double v78 = *(double *)(a1 + 8344) * v55;
                      double v79 = v68 * v55;
                      *(double *)(a1 + 8264) = v108 * v56 + v64 * v55;
                      double v80 = *(double *)(a1 + 8352) * v55;
                      double v51 = v127;
                      *(double *)(a1 + 8272) = v110 * v56 + v75;
                      *(double *)(a1 + 8280) = v111 * v56 + v77;
                      *(double *)(a1 + 8288) = v112 * v56 + v79;
                      *(double *)(a1 + 8296) = v62;
                      *(double *)(a1 + 8304) = v65;
                      *(double *)(a1 + 8312) = v113 * v56 + v72;
                      *(double *)(a1 + 8320) = v114 * v56 + v73;
                      *(double *)(a1 + 8328) = v115 * v56 + v74;
                      *(double *)(a1 + 8336) = v116 * v56 + v76;
                      *(double *)(a1 + 8344) = v117 * v56 + v78;
                      double v50 = v128;
                      *(double *)(a1 + 8352) = v52 * v56 + v80;
                    }
                    else
                    {
                      *(double *)(a1 + 7896) = v30;
                      *(double *)(a1 + 7904) = v33;
                      *(double *)(a1 + 7912) = v31;
                      *(double *)(a1 + 7920) = v34;
                      *(double *)(a1 + 7928) = v32;
                      *(double *)(a1 + 7936) = v35;
                      *(double *)(a1 + 7944) = v36;
                      *(double *)(a1 + 7952) = v37;
                      *(double *)(a1 + 7960) = v38;
                      *(double *)(a1 + 7968) = v81;
                      *(double *)(a1 + 7976) = v82;
                      *(double *)(a1 + 7984) = v83;
                      *(double *)(a1 + 7992) = v84;
                      *(double *)(a1 + 8000) = v85;
                      *(double *)(a1 + 8008) = v86;
                      *(double *)(a1 + 8016) = v87;
                      *(double *)(a1 + 8024) = v88;
                      *(double *)(a1 + 8032) = v89;
                      *(double *)(a1 + 8040) = v41;
                      *(double *)(a1 + 8048) = v90;
                      *(double *)(a1 + 8056) = v39;
                      *(double *)(a1 + 8064) = v40;
                      *(double *)(a1 + 8072) = v42;
                      *(double *)(a1 + 8080) = v43;
                      *(double *)(a1 + 8088) = v44;
                      *(double *)(a1 + 8096) = v45;
                      *(double *)(a1 + 8104) = v46;
                      *(double *)(a1 + 8112) = v47;
                      *(double *)(a1 + 8120) = v48;
                      *(double *)(a1 + 8128) = v49;
                      *(double *)(a1 + 8136) = v91;
                      *(double *)(a1 + 8144) = v92;
                      *(double *)(a1 + 8152) = v93;
                      *(double *)(a1 + 8160) = v94;
                      *(double *)(a1 + 8168) = v95;
                      *(double *)(a1 + 8176) = v96;
                      *(double *)(a1 + 8184) = v97;
                      *(double *)(a1 + 0x2000) = v99;
                      *(double *)(a1 + 8200) = v98;
                      *(double *)(a1 + 8208) = v100;
                      *(double *)(a1 + 8216) = v101;
                      *(double *)(a1 + 8224) = v102;
                      *(double *)(a1 + 8232) = v103;
                      *(double *)(a1 + 8240) = v104;
                      *(double *)(a1 + 8248) = v105;
                      *(double *)(a1 + 8256) = v106;
                      *(double *)(a1 + 8264) = v108;
                      *(double *)(a1 + 8272) = v110;
                      *(double *)(a1 + 8280) = v111;
                      *(double *)(a1 + 8288) = v112;
                      *(double *)(a1 + 8296) = v107;
                      *(double *)(a1 + 8304) = v109;
                      *(double *)(a1 + 8312) = v113;
                      *(double *)(a1 + 8320) = v114;
                      *(double *)(a1 + 8328) = v115;
                      *(double *)(a1 + 8336) = v116;
                      *(double *)(a1 + 8344) = v117;
                      *(double *)(a1 + 8352) = v52;
                      *(unsigned char *)(a1 + 7888) = 1;
                    }
                    a7->f64[0] = v23;
                    a7->f64[1] = v141;
                    a7[1].f64[0] = v24;
                    a7[1].f64[1] = v140;
                    a7[2].f64[0] = v25;
                    a7[2].f64[1] = v26;
                    a7[3].f64[0] = v27;
                    a7[3].f64[1] = v139;
                    a7[4].f64[0] = v138;
                    a7[4].f64[1] = v137;
                    a7[5].f64[0] = v136;
                    a7[5].f64[1] = v135;
                    a7[6].f64[0] = v134;
                    a7[6].f64[1] = v133;
                    a7[7].f64[0] = v132;
                    a7[7].f64[1] = v131;
                    a7[8].f64[0] = v130;
                    a7[8].f64[1] = v129;
                    a5->f64[0] = v168;
                    a5->f64[1] = v167;
                    a5[1].f64[0] = v126;
                    a5[1].f64[1] = v125;
                    a5[2].f64[0] = v20;
                    a5[2].f64[1] = v124;
                    a5[3].f64[0] = v118;
                    a5[3].f64[1] = v28;
                    a5[4].f64[0] = v123;
                    a5[4].f64[1] = v122;
                    a5[5].f64[0] = v166;
                    a5[5].f64[1] = v121;
                    a5[6].f64[0] = v165;
                    a5[6].f64[1] = v120;
                    a5[7].f64[0] = v119;
                    a5[7].f64[1] = v164;
                    a5[8].f64[0] = v163;
                    a5[8].f64[1] = v162;
                    a5[9].f64[0] = v161;
                    a5[9].f64[1] = v160;
                    a6->f64[0] = v159;
                    a6->f64[1] = v158;
                    a6[1].f64[0] = v157;
                    a6[1].f64[1] = v156;
                    a6[2].f64[0] = v155;
                    a6[2].f64[1] = v154;
                    a6[3].f64[0] = v153;
                    a6[3].f64[1] = v152;
                    a6[4].f64[0] = v151;
                    a6[4].f64[1] = v150;
                    a6[5].f64[0] = v149;
                    a6[5].f64[1] = v50;
                    a6[6].f64[0] = v148;
                    a6[6].f64[1] = v147;
                    a6[7].f64[0] = v146;
                    a6[7].f64[1] = v145;
                    a6[8].f64[0] = v144;
                    a6[8].f64[1] = v143;
                    a6[9].f64[0] = v142;
                    a6[9].f64[1] = v51;
                    AdaptiveCorrection_applyTemporalCorrectionState(a1, a5, a6, a7);
                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t AdaptiveCorrection_fullCorrectionWithDistortion(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, double *a5, double *a6, double *a7, double a8, double a9, double a10, double a11, int32x4_t a12, int32x4_t a13, double a14, int32x4_t a15)
{
  uint64_t result = 4294954516;
  if (!a1) {
    return result;
  }
  if (!a2) {
    return result;
  }
  if (!a3) {
    return result;
  }
  if ((int)a4 < 1) {
    return result;
  }
  if (!a7) {
    return result;
  }
  if (!a6) {
    return result;
  }
  if (!a5) {
    return result;
  }
  if (*(_DWORD *)a1 < (signed int)a4) {
    return result;
  }
  int8x16_t v228 = 0u;
  long long v229 = 0u;
  int8x16_t v226 = 0u;
  int8x16_t v227 = 0u;
  float32x2_t v224 = 0;
  float32x2_t v225 = 0;
  simd_float2x2 v223 = (simd_float2x2)0;
  float64x2_t v23 = *(float64x2_t *)(a7 + 6);
  *(float32x2_t *)a12.i8 = vcvt_f32_f64(v23);
  float64x2_t v221 = *(float64x2_t *)(a7 + 8);
  float64x2_t v24 = *(float64x2_t *)(a7 + 10);
  *(float32x2_t *)a15.i8 = vcvt_f32_f64(v24);
  float64x2_t v219 = *(float64x2_t *)(a7 + 12);
  float64x2_t v25 = *(float64x2_t *)(a7 + 14);
  *(float32x2_t *)a13.i8 = vcvt_f32_f64(v25);
  float32x2_t v216 = *(float32x2_t *)a12.i8;
  float64x2_t v217 = *(float64x2_t *)(a7 + 16);
  float32x2_t v214 = *(float32x2_t *)a13.i8;
  float32x2_t v215 = *(float32x2_t *)a15.i8;
  int32x4_t v26 = vzip1q_s32(a12, a13);
  int32x4_t v27 = vzip2q_s32((int32x4_t)vcvt_hight_f32_f64(*(int32x2_t *)&v23.f64[0], v221), (int32x4_t)vcvt_hight_f32_f64(*(int32x2_t *)&v25.f64[0], v217));
  int32x4_t v28 = vzip2q_s32((int32x4_t)vcvt_hight_f32_f64(*(int32x2_t *)&v24.f64[0], v219), (int32x4_t)0);
  v267.columns[0] = (simd_float3)vzip1q_s32(v26, a15);
  v267.columns[2] = (simd_float3)vzip1q_s32(v27, v28);
  v267.columns[1] = (simd_float3)vzip2q_s32(v26, vdupq_lane_s32(*(int32x2_t *)a15.i8, 1));
  uint64_t result = AdaptiveCorrection_computeVerticalBaselineTransform((uint64_t)&v226, &v224, (int32x4_t *)&v223, v267, (float32x4_t)vzip2q_s32(v27, v28));
  if (result) {
    return result;
  }
  float32x2_t v29 = v224;
  float32x2_t v30 = v225;
  float v31 = a7[2];
  float v32 = a7[4];
  int32x2_t v33 = (int32x2_t)vmla_n_f32(vmul_n_f32(v224, v31), v225, v32);
  float v34 = a7[3];
  float v35 = a7[5];
  int32x2_t v36 = (int32x2_t)vmla_n_f32(vmul_n_f32((float32x2_t)v223.columns[0], v34), (float32x2_t)v223.columns[1], v35);
  long long v250 = *(_OWORD *)a7;
  float64x2_t v251 = vcvtq_f64_f32((float32x2_t)vzip1_s32(v33, v36));
  float64x2_t v252 = vcvtq_f64_f32((float32x2_t)vzip2_s32(v33, v36));
  *(double *)&long long v253 = *(float *)v226.i32;
  *((double *)&v253 + 1) = *(float *)v227.i32;
  *(float64x2_t *)&v254[8] = vcvtq_f64_f32((float32x2_t)__PAIR64__(v226.u32[1], v229));
  *(float64x2_t *)&v254[24] = vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v227.i8, *(int32x2_t *)v228.i8));
  *(float64x2_t *)&v254[40] = vcvtq_f64_f32((float32x2_t)vext_s8(*(int8x8_t *)&v229, (int8x8_t)*(_OWORD *)&vextq_s8(v226, v226, 8uLL), 4uLL));
  *(float64x2_t *)&v254[56] = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v227, v227, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v228, v228, 8uLL)));
  *(double *)double v254 = *(float *)v228.i32;
  *(double *)&v254[72] = *((float *)&v229 + 2);
  long long v37 = *((_OWORD *)a5 + 9);
  long long v248 = *((_OWORD *)a5 + 8);
  long long v249 = v37;
  long long v38 = *((_OWORD *)a5 + 7);
  long long v246 = *((_OWORD *)a5 + 6);
  long long v247 = v38;
  long long v39 = *((_OWORD *)a5 + 5);
  long long v244 = *((_OWORD *)a5 + 4);
  long long v245 = v39;
  long long v40 = *((_OWORD *)a5 + 3);
  long long v242 = *((_OWORD *)a5 + 2);
  long long v243 = v40;
  float64x2_t v41 = *(float64x2_t *)(a5 + 2);
  long long v240 = *(_OWORD *)a5;
  float64x2_t v241 = v41;
  *(float *)v41.f64 = a5[2];
  float v42 = a5[3];
  float64x2_t v43 = vcvtq_f64_f32(vmla_n_f32(vmul_n_f32(v224, *(float *)v41.f64), v225, v42));
  float64x2_t v241 = v43;
  long long v44 = *((_OWORD *)a6 + 6);
  long long v45 = *((_OWORD *)a6 + 8);
  long long v46 = *((_OWORD *)a6 + 9);
  long long v237 = *((_OWORD *)a6 + 7);
  long long v238 = v45;
  long long v239 = v46;
  long long v47 = *((_OWORD *)a6 + 2);
  long long v48 = *((_OWORD *)a6 + 4);
  long long v49 = *((_OWORD *)a6 + 5);
  long long v233 = *((_OWORD *)a6 + 3);
  long long v234 = v48;
  long long v235 = v49;
  long long v236 = v44;
  float64x2_t v50 = *(float64x2_t *)(a6 + 2);
  long long v230 = *(_OWORD *)a6;
  float64x2_t v231 = v50;
  *(float *)&long long v44 = a6[2];
  *(float *)v50.f64 = a6[3];
  float64x2_t v51 = vcvtq_f64_f32(vmla_n_f32(vmul_n_f32((float32x2_t)v223.columns[0], *(float *)&v44), (float32x2_t)v223.columns[1], *(float *)v50.f64));
  float64x2_t v231 = v51;
  long long v232 = v47;
  unint64_t v52 = *(void *)(a1 + 8360);
  if (!v52) {
    return 4294954516;
  }
  uint64_t v53 = 0;
  float32x2_t v54 = vcvt_f32_f64(v221);
  float32x2_t v55 = vcvt_f32_f64(v219);
  float32x2_t v56 = vcvt_f32_f64(v217);
  double v57 = *(const double **)(a1 + 8360);
  do
  {
    float v58 = *(double *)(a2 + v53);
    float v59 = *(double *)(a2 + v53 + 8);
    *(float64x2_t *)(v52 + v53) = vcvtq_f64_f32(vmla_n_f32(vmul_n_f32(v29, v58), v30, v59));
    v53 += 16;
  }
  while (16 * a4 != v53);
  double v60 = *(const double **)(a1 + 8368);
  if (!v60) {
    return 4294954516;
  }
  unint64_t v61 = 0;
  uint64_t v218 = *(const double **)(a1 + 8368);
  simd_float2x2 v62 = v223;
  uint64_t v63 = 16 * a4;
  do
  {
    float v64 = *(double *)(a3 + v61);
    float v65 = *(double *)(a3 + v61 + 8);
    *(float64x2_t *)&v60[v61 / 8] = vcvtq_f64_f32(vmla_n_f32(vmul_n_f32((float32x2_t)v62.columns[0], v64), (float32x2_t)v62.columns[1], v65));
    v61 += 16;
  }
  while (v63 != v61);
  int64x2_t v220 = (int64x2_t)v43;
  if (*(_DWORD *)a1 < (signed int)a4) {
    return 4294954516;
  }
  unint64_t v222 = v52;
  float64x2_t v213 = v51;
  bzero((void *)(a1 + 136), 0x1E48uLL);
  unint64_t v66 = *(void *)(a1 + 8376);
  if (!v66) {
    return 4294954516;
  }
  double v67 = *(double *)&v240;
  double v68 = *(double *)&v242 + *((double *)&v240 + 1) * *(double *)&v240 * *(double *)&v246;
  double v69 = *((double *)&v242 + 1) + *((double *)&v240 + 1) * *(double *)&v240 * *((double *)&v246 + 1);
  double v70 = *(double *)&v243 + *((double *)&v240 + 1) * *(double *)&v240 * *(double *)&v247;
  double v71 = *((double *)&v243 + 1) + *((double *)&v240 + 1) * *(double *)&v240 * *((double *)&v247 + 1);
  double v72 = *(double *)&v244 + *((double *)&v240 + 1) * *(double *)&v240 * *(double *)&v248;
  double v73 = *((double *)&v244 + 1) + *((double *)&v240 + 1) * *(double *)&v240 * *((double *)&v248 + 1);
  double v74 = *(double *)&v245 + *((double *)&v240 + 1) * *(double *)&v240 * *(double *)&v249;
  double v75 = *((double *)&v245 + 1) + *((double *)&v240 + 1) * *(double *)&v240 * *((double *)&v249 + 1);
  float64x2_t v76 = (float64x2_t)v220;
  if (a4 >= 2 && (v66 >= v222 + v63 || v222 >= v66 + v63))
  {
    float64x2_t v102 = (float64x2_t)vdupq_lane_s64(v220.i64[0], 0);
    float64x2_t v103 = (float64x2_t)vdupq_laneq_s64(v220, 1);
    float64x2_t v104 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v68, 0);
    float64x2_t v105 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v70, 0);
    float64x2_t v106 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v71, 0);
    float64x2_t v107 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v72, 0);
    float64x2_t v108 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v73, 0);
    float64x2_t v109 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v74, 0);
    float64x2_t v110 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
    uint64_t v77 = a4 & 0xFFFFFFFE;
    __asm { FMOV            V26.2D, #1.0 }
    double v116 = *(double **)(a1 + 8376);
    uint64_t v117 = v77;
    float64x2_t v118 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v75, 0);
    do
    {
      float64x2x2_t v270 = vld2q_f64(v57);
      v57 += 4;
      float64x2_t v119 = vsubq_f64(v270.val[0], v102);
      v270.val[0] = vsubq_f64(v270.val[1], v103);
      v270.val[1] = vmulq_n_f64(vsqrtq_f64(vmlaq_f64(vmulq_f64(v270.val[0], v270.val[0]), v119, v119)), v67);
      v270.val[1] = vmulq_f64(v270.val[1], v270.val[1]);
      float64x2_t v120 = vmulq_f64(v270.val[1], v270.val[1]);
      float64x2_t v121 = vmulq_f64(v270.val[1], v120);
      float64x2_t v122 = vmulq_f64(v120, v120);
      v270.val[1] = vaddq_f64(vdivq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vaddq_f64(v104, vmulq_n_f64(v270.val[1], v69)), v120, v105), v121, v106), v122, v107), vmulq_f64(v120, v121), v108), vmulq_f64(v121, v121), v109), vmulq_f64(v122, v121), v118), v110), _Q26);
      v270.val[1] = (float64x2_t)vbslq_s8((int8x16_t)vcgtzq_f64(v270.val[1]), (int8x16_t)vdivq_f64(_Q26, v270.val[1]), (int8x16_t)_Q26);
      v270.val[0] = vmulq_f64(v270.val[0], v270.val[1]);
      v270.val[1] = vaddq_f64(vmulq_f64(v119, v270.val[1]), v102);
      float64x2_t v123 = vaddq_f64(v270.val[0], v103);
      vst2q_f64(v116, *(float64x2x2_t *)((char *)&v270 + 16));
      v116 += 4;
      v117 -= 2;
    }
    while (v117);
    float64x2_t v76 = (float64x2_t)v220;
    if (v77 == a4) {
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v77 = 0;
  }
  uint64_t v78 = a4 - v77;
  uint64_t v79 = 16 * v77;
  double v80 = (float64x2_t *)(v66 + 16 * v77);
  double v81 = (float64x2_t *)(v222 + v79);
  do
  {
    float64x2_t v82 = *v81++;
    float64x2_t v83 = vsubq_f64(v82, v76);
    double v84 = sqrt(vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(v83, v83).f64[1]), v83.f64[0], v83.f64[0]));
    double v85 = v67 * v84 * (v67 * v84);
    double v86 = v85 * (v85 * v85);
    double v87 = (v68
         + v69 * v85
         + v70 * (v85 * v85)
         + v71 * v86
         + v72 * (v85 * v85 * (v85 * v85))
         + v73 * (v85 * v85 * v86)
         + v74 * (v86 * v86)
         + v75 * (v85 * v85 * (v85 * v85) * v86))
        / 100.0
        + 1.0;
    if (v87 <= 0.0) {
      double v88 = 1.0;
    }
    else {
      double v88 = 1.0 / v87;
    }
    *v80++ = vaddq_f64(vmulq_n_f64(v83, v88), v76);
    --v78;
  }
  while (v78);
LABEL_27:
  unint64_t v89 = *(void *)(a1 + 8384);
  if (!v89) {
    return 4294954516;
  }
  double v90 = *(double *)&v230;
  double v91 = *(double *)&v232 + *((double *)&v230 + 1) * *(double *)&v230 * *(double *)&v236;
  double v92 = *((double *)&v232 + 1) + *((double *)&v230 + 1) * *(double *)&v230 * *((double *)&v236 + 1);
  double v93 = *(double *)&v233 + *((double *)&v230 + 1) * *(double *)&v230 * *(double *)&v237;
  double v94 = *((double *)&v233 + 1) + *((double *)&v230 + 1) * *(double *)&v230 * *((double *)&v237 + 1);
  double v95 = *(double *)&v234 + *((double *)&v230 + 1) * *(double *)&v230 * *(double *)&v238;
  double v96 = *((double *)&v234 + 1) + *((double *)&v230 + 1) * *(double *)&v230 * *((double *)&v238 + 1);
  double v97 = *(double *)&v235 + *((double *)&v230 + 1) * *(double *)&v230 * *(double *)&v239;
  double v98 = *((double *)&v235 + 1) + *((double *)&v230 + 1) * *(double *)&v230 * *((double *)&v239 + 1);
  if (a4 >= 2)
  {
    if (v89 >= (unint64_t)&v60[(unint64_t)v63 / 8] || (unint64_t)v60 >= v89 + v63)
    {
      float64x2_t v124 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v213.f64[0], 0);
      float64x2_t v125 = (float64x2_t)vdupq_laneq_s64((int64x2_t)v213, 1);
      float64x2_t v126 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v91, 0);
      float64x2_t v127 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v93, 0);
      float64x2_t v128 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v94, 0);
      float64x2_t v129 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v95, 0);
      float64x2_t v130 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v96, 0);
      float64x2_t v131 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v97, 0);
      float64x2_t v132 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
      uint64_t v99 = a4 & 0xFFFFFFFE;
      __asm { FMOV            V26.2D, #1.0 }
      double v134 = *(double **)(a1 + 8384);
      uint64_t v135 = v99;
      float64x2_t v136 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v98, 0);
      do
      {
        float64x2x2_t v271 = vld2q_f64(v60);
        v60 += 4;
        float64x2_t v137 = vsubq_f64(v271.val[0], v124);
        v271.val[0] = vsubq_f64(v271.val[1], v125);
        v271.val[1] = vmulq_n_f64(vsqrtq_f64(vmlaq_f64(vmulq_f64(v271.val[0], v271.val[0]), v137, v137)), v90);
        v271.val[1] = vmulq_f64(v271.val[1], v271.val[1]);
        float64x2_t v138 = vmulq_f64(v271.val[1], v271.val[1]);
        float64x2_t v139 = vmulq_f64(v271.val[1], v138);
        float64x2_t v140 = vmulq_f64(v138, v138);
        v271.val[1] = vaddq_f64(vdivq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vaddq_f64(v126, vmulq_n_f64(v271.val[1], v92)), v138, v127), v139, v128), v140, v129), vmulq_f64(v138, v139), v130), vmulq_f64(v139, v139), v131), vmulq_f64(v140, v139), v136), v132), _Q26);
        v271.val[1] = (float64x2_t)vbslq_s8((int8x16_t)vcgtzq_f64(v271.val[1]), (int8x16_t)vdivq_f64(_Q26, v271.val[1]), (int8x16_t)_Q26);
        v271.val[0] = vmulq_f64(v271.val[0], v271.val[1]);
        v271.val[1] = vaddq_f64(vmulq_f64(v137, v271.val[1]), v124);
        float64x2_t v141 = vaddq_f64(v271.val[0], v125);
        vst2q_f64(v134, *(float64x2x2_t *)((char *)&v271 + 16));
        v134 += 4;
        v135 -= 2;
      }
      while (v135);
      double v100 = (unsigned char *)(a1 + 5348);
      double v101 = v218;
      if (v99 == a4) {
        goto LABEL_45;
      }
    }
    else
    {
      uint64_t v99 = 0;
      double v100 = (unsigned char *)(a1 + 5348);
      double v101 = v60;
    }
  }
  else
  {
    uint64_t v99 = 0;
    double v100 = (unsigned char *)(a1 + 5348);
    double v101 = v60;
  }
  uint64_t v142 = a4 - v99;
  uint64_t v143 = 2 * v99;
  double v144 = (float64x2_t *)(v89 + 16 * v99);
  double v145 = (float64x2_t *)&v101[v143];
  do
  {
    float64x2_t v146 = *v145++;
    float64x2_t v147 = vsubq_f64(v146, v213);
    double v148 = sqrt(vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(v147, v147).f64[1]), v147.f64[0], v147.f64[0]));
    double v149 = v90 * v148 * (v90 * v148);
    double v150 = v149 * (v149 * v149);
    double v151 = (v91
          + v92 * v149
          + v93 * (v149 * v149)
          + v94 * v150
          + v95 * (v149 * v149 * (v149 * v149))
          + v96 * (v149 * v149 * v150)
          + v97 * (v150 * v150)
          + v98 * (v149 * v149 * (v149 * v149) * v150))
         / 100.0
         + 1.0;
    if (v151 <= 0.0) {
      double v152 = 1.0;
    }
    else {
      double v152 = 1.0 / v151;
    }
    *v144++ = vaddq_f64(vmulq_n_f64(v147, v152), v213);
    --v142;
  }
  while (v142);
LABEL_45:
  AdaptiveCorrection_fullCorrection();
  *(_OWORD *)&v254[32] = v264;
  *(_OWORD *)&v254[48] = v265;
  *(_OWORD *)&v254[64] = v266;
  float64x2_t v252 = v260;
  long long v253 = v261;
  *(_OWORD *)double v254 = v262;
  *(_OWORD *)&v254[16] = v263;
  long long v250 = v258;
  float64x2_t v251 = v259;
  FundamentalEpipolarError_ABSVec(*(const double **)(a1 + 8376), *(const double **)(a1 + 8384), a4, (double *)&v250, *(float64x2_t **)(a1 + 8408));
  unint64_t v153 = 0;
  signed int v154 = 0;
  uint64_t v155 = *(void *)(a1 + 8408);
  double v156 = v101 + 1;
  double v157 = (void *)(v222 + 8);
  do
  {
    if (*(double *)(v155 + 8 * v153) < *(double *)(a1 + 16))
    {
      uint64_t v158 = *(void *)(a1 + 8392);
      uint64_t v159 = 16 * v154;
      *(void *)(v158 + v159) = *(v157 - 1);
      uint64_t v160 = (16 * v154) | 8;
      *(void *)(v158 + v160) = *v157;
      uint64_t v161 = *(void *)(a1 + 8400);
      *(void *)(v161 + v159) = *(v156 - 1);
      *(void *)(v161 + v160) = *v156;
      ++v154;
      if (v153 <= 0x7FF) {
        *(unsigned char *)(a1 + 5840 + v153) = 1;
      }
    }
    ++v153;
    v156 += 2;
    v157 += 2;
  }
  while (a4 != v153);
  *(_DWORD *)(a1 + 5344) = v154;
  if (v154 >= *(_DWORD *)(a1 + 80))
  {
    long long v162 = v247;
    *(_OWORD *)(a1 + 5120) = v246;
    *(_OWORD *)(a1 + 5136) = v162;
    long long v163 = v249;
    *(_OWORD *)(a1 + 5152) = v248;
    *(_OWORD *)(a1 + 5168) = v163;
    long long v164 = v243;
    *(_OWORD *)(a1 + 5056) = v242;
    *(_OWORD *)(a1 + 5072) = v164;
    long long v165 = v245;
    *(_OWORD *)(a1 + 5088) = v244;
    *(_OWORD *)(a1 + 5104) = v165;
    float64x2_t v166 = v241;
    *(_OWORD *)(a1 + 5024) = v240;
    *(float64x2_t *)(a1 + 5040) = v166;
    long long v167 = v237;
    *(_OWORD *)(a1 + 5280) = v236;
    *(_OWORD *)(a1 + 5296) = v167;
    long long v168 = v239;
    *(_OWORD *)(a1 + 5312) = v238;
    *(_OWORD *)(a1 + 5328) = v168;
    long long v169 = v233;
    *(_OWORD *)(a1 + 5216) = v232;
    *(_OWORD *)(a1 + 5232) = v169;
    long long v170 = v235;
    *(_OWORD *)(a1 + 5248) = v234;
    *(_OWORD *)(a1 + 5264) = v170;
    float64x2_t v171 = v231;
    *(_OWORD *)(a1 + 5184) = v230;
    *double v100 = 1;
    *(float64x2_t *)(a1 + 5200) = v171;
    uint64_t v256 = 0;
    uint64_t v255 = 0;
    uint64_t v257 = 0;
    AdjustCalibrationDistorted(*(void *)(a1 + 8392), *(void *)(a1 + 8400), v154, (double *)&v240, (double *)&v230, (double *)&v250, (double *)(a1 + 8), (uint64_t)&v255);
    uint64_t v172 = v257;
    *(void *)(a1 + 5352) = v256;
    *(void *)(a1 + 5368) = v172;
    long long v173 = *(_OWORD *)v254;
    *(_OWORD *)(a1 + 5456) = *(_OWORD *)&v254[16];
    long long v174 = *(_OWORD *)&v254[48];
    *(_OWORD *)(a1 + 5472) = *(_OWORD *)&v254[32];
    *(_OWORD *)(a1 + 5488) = v174;
    *(_OWORD *)(a1 + 5504) = *(_OWORD *)&v254[64];
    long long v175 = v250;
    *(float64x2_t *)(a1 + 5392) = v251;
    long long v176 = v253;
    *(float64x2_t *)(a1 + 5408) = v252;
    *(_OWORD *)(a1 + 5424) = v176;
    *(_OWORD *)(a1 + 5440) = v173;
    *(_OWORD *)(a1 + 5376) = v175;
    long long v177 = v247;
    *(_OWORD *)(a1 + 5616) = v246;
    *(_OWORD *)(a1 + 5632) = v177;
    long long v178 = v249;
    *(_OWORD *)(a1 + 5648) = v248;
    *(_OWORD *)(a1 + 5664) = v178;
    long long v179 = v243;
    *(_OWORD *)(a1 + 5552) = v242;
    *(_OWORD *)(a1 + 5568) = v179;
    long long v180 = v245;
    *(_OWORD *)(a1 + 5584) = v244;
    *(_OWORD *)(a1 + 5600) = v180;
    float64x2_t v181 = v241;
    *(_OWORD *)(a1 + 5520) = v240;
    *(float64x2_t *)(a1 + 5536) = v181;
    long long v182 = v237;
    *(_OWORD *)(a1 + 5776) = v236;
    *(_OWORD *)(a1 + 5792) = v182;
    long long v183 = v239;
    *(_OWORD *)(a1 + 5808) = v238;
    *(_OWORD *)(a1 + 5824) = v183;
    long long v184 = v233;
    *(_OWORD *)(a1 + 5712) = v232;
    *(_OWORD *)(a1 + 5728) = v184;
    long long v185 = v235;
    *(_OWORD *)(a1 + 5744) = v234;
    *(_OWORD *)(a1 + 5760) = v185;
    float64x2_t v186 = v231;
    *(_OWORD *)(a1 + 5680) = v230;
    *(_DWORD *)(a1 + 5360) = v255;
    v100[16] = BYTE4(v255);
    *(float64x2_t *)(a1 + 5696) = v186;
  }
  v268.columns[0] = (simd_float2)v224;
  v268.columns[1] = (simd_float2)v225;
  simd_float2x2 v187 = __invert_f2(v268);
  simd_float2x2 v188 = __invert_f2(v223);
  float v189 = v251.f64[0];
  float v190 = v252.f64[0];
  int32x2_t v191 = (int32x2_t)vmla_n_f32(vmul_n_f32((float32x2_t)v187.columns[0], v189), (float32x2_t)v187.columns[1], v190);
  float v192 = v251.f64[1];
  float v193 = v252.f64[1];
  int32x2_t v194 = (int32x2_t)vmla_n_f32(vmul_n_f32((float32x2_t)v188.columns[0], v192), (float32x2_t)v188.columns[1], v193);
  *(_OWORD *)a7 = v250;
  *((float64x2_t *)a7 + 1) = vcvtq_f64_f32((float32x2_t)vzip1_s32(v191, v194));
  *((float64x2_t *)a7 + 2) = vcvtq_f64_f32((float32x2_t)vzip2_s32(v191, v194));
  *((float64x2_t *)a7 + 3) = vcvtq_f64_f32(v216);
  *((float64x2_t *)a7 + 4) = vcvtq_f64_f32(v54);
  *((float64x2_t *)a7 + 5) = vcvtq_f64_f32(v215);
  *((float64x2_t *)a7 + 6) = vcvtq_f64_f32(v55);
  *((float64x2_t *)a7 + 7) = vcvtq_f64_f32(v214);
  *((float64x2_t *)a7 + 8) = vcvtq_f64_f32(v56);
  v269.columns[0] = (simd_float2)v224;
  v269.columns[1] = (simd_float2)v225;
  simd_float2x2 v195 = __invert_f2(v269);
  long long v196 = v246;
  long long v197 = v248;
  long long v198 = v249;
  *((_OWORD *)a5 + 7) = v247;
  *((_OWORD *)a5 + 8) = v197;
  *((_OWORD *)a5 + 9) = v198;
  long long v199 = v242;
  long long v200 = v244;
  long long v201 = v245;
  *((_OWORD *)a5 + 3) = v243;
  *((_OWORD *)a5 + 4) = v200;
  *((_OWORD *)a5 + 5) = v201;
  *((_OWORD *)a5 + 6) = v196;
  float64x2_t v202 = v241;
  *(_OWORD *)a5 = v240;
  *((float64x2_t *)a5 + 1) = v202;
  *(float *)&long long v196 = v241.f64[0];
  float32x2_t v203 = vmul_n_f32((float32x2_t)v195.columns[0], *(float *)&v196);
  *(float *)&long long v196 = v241.f64[1];
  *((float64x2_t *)a5 + 1) = vcvtq_f64_f32(vmla_n_f32(v203, (float32x2_t)v195.columns[1], *(float *)&v196));
  *((_OWORD *)a5 + 2) = v199;
  simd_float2x2 v204 = __invert_f2(v223);
  uint64_t result = 0;
  long long v205 = v236;
  long long v206 = v238;
  long long v207 = v239;
  *((_OWORD *)a6 + 7) = v237;
  *((_OWORD *)a6 + 8) = v206;
  *((_OWORD *)a6 + 9) = v207;
  long long v208 = v232;
  long long v209 = v234;
  long long v210 = v235;
  *((_OWORD *)a6 + 3) = v233;
  *((_OWORD *)a6 + 4) = v209;
  *((_OWORD *)a6 + 5) = v210;
  *((_OWORD *)a6 + 6) = v205;
  float64x2_t v211 = v231;
  *(_OWORD *)a6 = v230;
  *((float64x2_t *)a6 + 1) = v211;
  *(float *)&long long v205 = v231.f64[0];
  float32x2_t v212 = vmul_n_f32((float32x2_t)v204.columns[0], *(float *)&v205);
  *(float *)&long long v205 = v231.f64[1];
  *((float64x2_t *)a6 + 1) = vcvtq_f64_f32(vmla_n_f32(v212, (float32x2_t)v204.columns[1], *(float *)&v205));
  *((_OWORD *)a6 + 2) = v208;
  return result;
}

uint64_t AdaptiveCorrection_applyTemporalCorrectionState(uint64_t a1, float64x2_t *a2, float64x2_t *a3, float64x2_t *a4)
{
  if (!a1) {
    return 4294954516;
  }
  uint64_t result = 4294954516;
  if (a4 && a3 && a2)
  {
    uint64_t v6 = a1 + 7888;
    if (*(unsigned char *)(a1 + 7888))
    {
      uint64_t result = 0;
      long long v7 = (float64x2_t *)(a1 + 8200);
      float64x2_t v8 = vaddq_f64(a4[1], *(float64x2_t *)(v6 + 24));
      float64x2_t v9 = vaddq_f64(a4[2], *(float64x2_t *)(v6 + 40));
      float64x2_t v10 = vaddq_f64(a4[3], *(float64x2_t *)(v6 + 56));
      float64x2_t v11 = vaddq_f64(a4[4], *(float64x2_t *)(v6 + 72));
      float64x2_t v12 = vaddq_f64(a4[5], *(float64x2_t *)(v6 + 88));
      float64x2_t v13 = vaddq_f64(a4[6], *(float64x2_t *)(v6 + 104));
      float64x2_t v14 = vaddq_f64(a4[7], *(float64x2_t *)(v6 + 120));
      float64x2_t v15 = vaddq_f64(a4[8], *(float64x2_t *)(v6 + 136));
      *a4 = vaddq_f64(*a4, *(float64x2_t *)(v6 + 8));
      a4[1] = v8;
      a4[2] = v9;
      a4[3] = v10;
      a4[4] = v11;
      a4[5] = v12;
      a4[6] = v13;
      a4[7] = v14;
      a4[8] = v15;
      float64x2_t v16 = vaddq_f64(a2[1], *(float64x2_t *)(v6 + 168));
      float64x2_t v17 = vaddq_f64(a2[2], *(float64x2_t *)(v6 + 184));
      float64x2_t v18 = vaddq_f64(a2[3], *(float64x2_t *)(v6 + 200));
      float64x2_t v19 = vaddq_f64(a2[4], *(float64x2_t *)(v6 + 216));
      float64x2_t v20 = vaddq_f64(a2[5], *(float64x2_t *)(v6 + 232));
      float64x2_t v21 = vaddq_f64(a2[6], *(float64x2_t *)(v6 + 248));
      float64x2_t v22 = vaddq_f64(a2[7], *(float64x2_t *)(v6 + 264));
      float64x2_t v23 = vaddq_f64(a2[8], *(float64x2_t *)(v6 + 280));
      float64x2_t v24 = vaddq_f64(a2[9], *(float64x2_t *)(v6 + 296));
      *a2 = vaddq_f64(*a2, *(float64x2_t *)(v6 + 152));
      a2[1] = v16;
      a2[2] = v17;
      a2[3] = v18;
      a2[4] = v19;
      a2[5] = v20;
      a2[6] = v21;
      a2[7] = v22;
      a2[8] = v23;
      a2[9] = v24;
      float64x2_t v25 = vaddq_f64(a3[1], v7[1]);
      float64x2_t v26 = vaddq_f64(a3[2], v7[2]);
      float64x2_t v27 = vaddq_f64(a3[3], v7[3]);
      float64x2_t v28 = vaddq_f64(a3[4], v7[4]);
      float64x2_t v29 = vaddq_f64(a3[5], v7[5]);
      float64x2_t v30 = vaddq_f64(a3[6], v7[6]);
      float64x2_t v31 = vaddq_f64(a3[7], v7[7]);
      float64x2_t v32 = vaddq_f64(a3[8], v7[8]);
      float64x2_t v33 = vaddq_f64(a3[9], v7[9]);
      *a3 = vaddq_f64(*a3, *v7);
      a3[1] = v25;
      a3[2] = v26;
      a3[3] = v27;
      a3[4] = v28;
      a3[5] = v29;
      a3[6] = v30;
      a3[7] = v31;
      a3[8] = v32;
      a3[9] = v33;
    }
  }
  return result;
}

uint64_t AdaptiveCorrection_computeVerticalBaselineTransform(uint64_t a1, void *a2, int32x4_t *a3, simd_float3x3 a4, float32x4_t a5)
{
  uint64_t result = 4294954516;
  if (!a1 || !a2 || !a3) {
    return result;
  }
  simd_float3x3 v49 = a4;
  a4.columns[0].i32[3] = 0;
  a4.columns[1].i32[3] = 0;
  a4.columns[2].i32[3] = 0;
  simd_float3x3 v51 = __invert_f3(a4);
  float32x4_t v9 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v51.columns[0], a5.f32[0]), (float32x4_t)v51.columns[1], *(float32x2_t *)a5.f32, 1), (float32x4_t)v51.columns[2], a5, 2);
  float v10 = sqrtf(vaddv_f32((float32x2_t)*(_OWORD *)&vmulq_f32(v9, v9)));
  if (v10 <= 0.0) {
    return 4294954516;
  }
  unint64_t v11 = vnegq_f32(v9).u64[0];
  float v12 = fabsf(*((float *)&v11 + 1));
  float v13 = fabsf(*(float *)&v11);
  if (v12 >= v13 && *((float *)&v11 + 1) >= 0.0)
  {
    *(float *)&uint64_t v14 = *((float *)&v11 + 1) / v10;
    float v15 = (float)-*(float *)&v11 / v10;
LABEL_11:
    float v16 = -v15;
    LODWORD(v17) = v14;
    goto LABEL_12;
  }
  if (v12 >= v13 && *((float *)&v11 + 1) < 0.0)
  {
    *(float *)&uint64_t v14 = (float)-*((float *)&v11 + 1) / v10;
    float v15 = *(float *)&v11 / v10;
    goto LABEL_11;
  }
  if (v13 <= v12 || *(float *)&v11 < 0.0)
  {
    uint64_t result = 4294954516;
    if (v13 <= v12 || *(float *)&v11 >= 0.0) {
      return result;
    }
    *(float *)&uint64_t v14 = *((float *)&v11 + 1) / v10;
    float v15 = (float)-*(float *)&v11 / v10;
  }
  else
  {
    *(float *)&uint64_t v14 = (float)-*((float *)&v11 + 1) / v10;
    float v15 = *(float *)&v11 / v10;
  }
  float v17 = -*(float *)&v14;
  float v16 = v15;
LABEL_12:
  *((float *)&v14 + 1) = v16;
  unint64_t v18 = __PAIR64__(LODWORD(v17), LODWORD(v15));
  uint64_t v48 = v14;
  float v46 = v15;
  unint64_t v47 = __PAIR64__(LODWORD(v17), LODWORD(v15));
  simd_float2x2 v20 = __invert_f2(*(simd_float2x2 *)&v14);
  _Q3 = vmlaq_f32(vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v49.columns[0], v20.columns[0].f32[0]), (float32x4_t)v49.columns[1], (float32x2_t)v20.columns[0], 1), (float32x4_t)0, (float32x4_t)v49.columns[2]), (float32x4_t)0, a5);
  _S2 = _Q3.i32[1];
  __asm { FMLA            S4, S2, V3.S[1] }
  *(float *)v28.i32 = sqrtf(_S4);
  if (*(float *)v28.i32 <= 0.0) {
    return 4294954516;
  }
  uint64_t result = 0;
  float32x4_t v29 = vmlaq_f32(vmulq_f32((float32x4_t)v49.columns[0], (float32x4_t)0), (float32x4_t)0, (float32x4_t)v49.columns[1]);
  float32x4_t v30 = vaddq_f32((float32x4_t)v49.columns[2], v29);
  float32x4_t v31 = vaddq_f32(a5, vmlaq_f32(v29, (float32x4_t)0, (float32x4_t)v49.columns[2]));
  float32x4_t v32 = vmlaq_f32(v30, (float32x4_t)0, a5);
  float32x4_t v33 = vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v49.columns[0], v20.columns[1].f32[0]), (float32x4_t)v49.columns[1], (float32x2_t)v20.columns[1], 1), (float32x4_t)0, (float32x4_t)v49.columns[2]);
  *(float32x2_t *)v19.i8 = vdiv_f32(*(float32x2_t *)_Q3.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v28.i8, 0));
  unsigned int v34 = v46 > 0.0;
  if (fabsf(*(float *)&v19.i32[1]) <= fabsf(*(float *)v19.i32)) {
    unsigned int v34 = 0;
  }
  int8x8_t v35 = (int8x8_t)vrev64_s32(*(int32x2_t *)v19.i8);
  v36.i32[0] = v35.i32[0];
  *(float *)&v36.i32[1] = -*(float *)v19.i32;
  *(float *)v35.i32 = -*(float *)&v19.i32[1];
  *(int8x8_t *)v28.i8 = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v34), 0x1FuLL)), v36, v35);
  int32x4_t v37 = vzip1q_s32(v19, v28);
  int32x4_t v38 = v19;
  v38.i32[1] = 0;
  v19.i64[1] = v28.i64[0];
  float32x4_t v39 = (float32x4_t)vzip1q_s32(v38, v28);
  float32x4_t v40 = (float32x4_t)vuzp2q_s32(v19, vzip2q_s32(v19, (int32x4_t)0));
  float32x4_t v41 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v39, _Q3.f32[0]), v40, *(float32x2_t *)_Q3.f32, 1), (float32x4_t)xmmword_215FC45E0, _Q3, 2);
  *(_DWORD *)(a1 + 8) = v41.i32[2];
  float32x4_t v42 = vmlaq_f32(v33, (float32x4_t)0, a5);
  float32x4_t v43 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v39, v42.f32[0]), v40, *(float32x2_t *)v42.f32, 1), (float32x4_t)xmmword_215FC45E0, v42, 2);
  float32x4_t v44 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v39, v32.f32[0]), v40, *(float32x2_t *)v32.f32, 1), (float32x4_t)xmmword_215FC45E0, v32, 2);
  *(_DWORD *)(a1 + 24) = v43.i32[2];
  *(_DWORD *)(a1 + 40) = v44.i32[2];
  float32x4_t v45 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v39, v31.f32[0]), v40, *(float32x2_t *)v31.f32, 1), (float32x4_t)xmmword_215FC45E0, v31, 2);
  *(_DWORD *)(a1 + 56) = v45.i32[2];
  *(void *)a1 = v41.i64[0];
  *(_DWORD *)(a1 + 12) = 0;
  *(void *)(a1 + 16) = v43.i64[0];
  *(_DWORD *)(a1 + 28) = 0;
  *(void *)(a1 + 32) = v44.i64[0];
  *(_DWORD *)(a1 + 44) = 0;
  *(void *)(a1 + 48) = v45.i64[0];
  *(_DWORD *)(a1 + 60) = 0;
  *a2 = v48;
  a2[1] = v47;
  *a3 = v37;
  return result;
}

void AdaptiveCorrection_fullCorrection()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  long long v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  signed int v8 = v7;
  float v10 = v9;
  unint64_t v11 = (const double *)v0;
  uint64_t v13 = v12;
  uint64_t v169 = *MEMORY[0x263EF8340];
  bzero(__src, 0x1E48uLL);
  long long v14 = v6[5];
  long long v16 = v6[6];
  long long v15 = v6[7];
  *(_OWORD *)(v13 + 96) = v16;
  *(_OWORD *)(v13 + 112) = v15;
  long long v17 = v6[7];
  *(_OWORD *)(v13 + 128) = v6[8];
  long long v18 = v6[1];
  long long v20 = v6[2];
  long long v19 = v6[3];
  *(_OWORD *)(v13 + 32) = v20;
  *(_OWORD *)(v13 + 48) = v19;
  long long v21 = v6[3];
  long long v23 = v6[4];
  long long v22 = v6[5];
  *(_OWORD *)(v13 + 64) = v23;
  *(_OWORD *)(v13 + 80) = v22;
  long long v24 = v6[1];
  long long v25 = *v6;
  *(_OWORD *)uint64_t v13 = *v6;
  *(_OWORD *)(v13 + 16) = v24;
  *(_OWORD *)&__src[88] = v14;
  *(_OWORD *)&__src[104] = v16;
  *(_OWORD *)&__src[120] = v17;
  *(_OWORD *)&__src[136] = v6[8];
  *(_OWORD *)&__src[24] = v18;
  *(_OWORD *)&__src[40] = v20;
  *(_OWORD *)&__src[56] = v21;
  *(_OWORD *)&__src[72] = v23;
  *(_OWORD *)&__src[8] = v25;
  *(_DWORD *)__src = v8;
  if (*(_DWORD *)(v4 + 72) <= v8)
  {
    float64x2_t v124 = v10;
    float64x2_t v125 = v11;
    __src[4] = 1;
    size_t v26 = 16 * v8;
    float64x2_t v27 = (double *)malloc_type_malloc(v26, 0x100004000313F17uLL);
    int32x4_t v28 = (double *)malloc_type_malloc(v26, 0x100004000313F17uLL);
    double v29 = *(double *)v4;
    size_t v30 = 8 * v8;
    float32x4_t v31 = (float64x2_t *)malloc_type_malloc(v30, 0x100004000313F17uLL);
    float64x2_t v123 = v2;
    if (v31)
    {
      FundamentalEpipolarError_ABSVec(v125, v124, v8, (double *)v13, v31);
      if (v8 < 1)
      {
        int v33 = 0;
        size_t v30 = 8 * v8;
        size_t v26 = 16 * v8;
      }
      else
      {
        unint64_t v32 = 0;
        int v33 = 0;
        unsigned int v34 = (double *)(v124 + 1);
        int8x8_t v35 = (double *)(v125 + 1);
        size_t v30 = 8 * v8;
        size_t v26 = 16 * v8;
        do
        {
          if (v31->f64[v32] < v29)
          {
            if (v32 <= 0x7FF) {
              __src[v32 + 472] = 1;
            }
            uint64_t v36 = 2 * v33;
            v27[v36] = *(v35 - 1);
            uint64_t v37 = (16 * v33) | 8;
            *(double *)((char *)v27 + v37) = *v35;
            v28[v36] = *(v34 - 1);
            *(double *)((char *)v28 + v37) = *v34;
            ++v33;
          }
          ++v32;
          v34 += 2;
          v35 += 2;
        }
        while (v8 != v32);
      }
    }
    else
    {
      int v33 = 0;
    }
    free(v31);
    *(_DWORD *)&__src[152] = v33;
    if (v33 < *(_DWORD *)(v4 + 72))
    {
      double v85 = 0;
      double v86 = 0;
LABEL_41:
      long long v2 = v123;
      goto LABEL_42;
    }
    __src[156] = 1;
    if (!*(unsigned char *)(v4 + 104))
    {
      double v44 = *(double *)(v13 + 16);
      double v43 = *(double *)(v13 + 24);
      double v45 = *(double *)v13;
      double v46 = *(double *)(v13 + 8);
LABEL_29:
      uint64_t v138 = 0;
      uint64_t v139 = 0;
      uint64_t v140 = 0;
      long long v69 = *(_OWORD *)(v13 + 112);
      long long v133 = *(_OWORD *)(v13 + 96);
      long long v134 = v69;
      long long v135 = *(_OWORD *)(v13 + 128);
      long long v70 = *(_OWORD *)(v13 + 48);
      long long v129 = *(_OWORD *)(v13 + 32);
      long long v130 = v70;
      long long v71 = *(_OWORD *)(v13 + 80);
      long long v131 = *(_OWORD *)(v13 + 64);
      long long v132 = v71;
      double v165 = v44;
      double v166 = v43;
      double v167 = v45;
      double v168 = v46;
      *(void *)&long long v71 = *(void *)(v4 + 32);
      *(void *)&long long v70 = *(void *)(v4 + 40);
      double v161 = v44 - *(double *)&v71;
      double v162 = v43 - *(double *)&v70;
      double v72 = *(double *)(v4 + 16);
      double v73 = *(double *)(v4 + 24);
      double v163 = v45 - v72;
      double v164 = v46 - v73;
      double v157 = v44 + *(double *)&v71;
      double v158 = v43 + *(double *)&v70;
      double v159 = v45 + v72;
      double v160 = v46 + v73;
      int v151 = 0;
      long long v153 = 0u;
      double v148 = v27;
      double v149 = v28;
      int v150 = v33;
      uint64_t v152 = v13;
      long long v143 = xmmword_215FC47C0;
      int v146 = unk_215FC47DC;
      uint64_t v147 = 0x3FB999999999999ALL;
      long long v141 = xmmword_215FC47A0;
      long long v142 = unk_215FC47B0;
      uint64_t v144 = 0;
      int v145 = 50;
      fmincon_spg((void (*)(void, void, void, void))CalcObjValGradForImagePoints, (void (*)(void, void, void))CalcObjValForImagePoints, (uint64_t)&v148, (uint64_t)&v165, 4, &v161, &v157, (double *)&v141, &v155, (uint64_t)&v138);
      BYTE4(v138) = 1;
      long long v74 = v155;
      *(_OWORD *)uint64_t v13 = v156;
      *(_OWORD *)(v13 + 16) = v74;
      long long v75 = v134;
      *(_OWORD *)(v13 + 96) = v133;
      *(_OWORD *)(v13 + 112) = v75;
      *(_OWORD *)(v13 + 128) = v135;
      long long v76 = v130;
      *(_OWORD *)(v13 + 32) = v129;
      *(_OWORD *)(v13 + 48) = v76;
      long long v77 = v132;
      *(_OWORD *)(v13 + 64) = v131;
      *(_OWORD *)(v13 + 80) = v77;
      *(void *)&__src[304] = v139;
      *(_DWORD *)&__src[312] = v138;
      __src[316] = 1;
      *(void *)&__src[320] = v140;
      long long v78 = *(_OWORD *)v13;
      long long v79 = *(_OWORD *)(v13 + 16);
      long long v80 = *(_OWORD *)(v13 + 48);
      *(_OWORD *)&__src[360] = *(_OWORD *)(v13 + 32);
      *(_OWORD *)&__src[376] = v80;
      *(_OWORD *)&__src[328] = v78;
      *(_OWORD *)&__src[344] = v79;
      long long v81 = *(_OWORD *)(v13 + 64);
      long long v82 = *(_OWORD *)(v13 + 80);
      long long v83 = *(_OWORD *)(v13 + 128);
      *(_OWORD *)&__src[440] = *(_OWORD *)(v13 + 112);
      *(_OWORD *)&__src[456] = v83;
      long long v84 = *(_OWORD *)(v13 + 96);
      *(_OWORD *)&__src[408] = v82;
      *(_OWORD *)&__src[424] = v84;
      *(_OWORD *)&__src[392] = v81;
      double v85 = (double *)malloc_type_malloc(v26, 0x100004000313F17uLL);
      double v86 = (double *)malloc_type_malloc(v26, 0x100004000313F17uLL);
      double v87 = *(double *)(v4 + 8);
      double v88 = (float64x2_t *)malloc_type_malloc(v30, 0x100004000313F17uLL);
      if (v88)
      {
        signed int v89 = v8;
        FundamentalEpipolarError_ABSVec(v125, v124, v8, (double *)v13, v88);
        if (v8 < 1)
        {
          signed int v91 = 0;
        }
        else
        {
          unint64_t v90 = 0;
          signed int v91 = 0;
          double v92 = (double *)(v124 + 1);
          double v93 = (double *)(v125 + 1);
          do
          {
            if (v88->f64[v90] < v87)
            {
              if (v90 <= 0x7FF) {
                __src[v90 + 2840] = 1;
              }
              uint64_t v94 = 2 * v91;
              v85[v94] = *(v93 - 1);
              uint64_t v95 = (16 * v91) | 8;
              *(double *)((char *)v85 + v95) = *v93;
              v86[v94] = *(v92 - 1);
              *(double *)((char *)v86 + v95) = *v92;
              ++v91;
            }
            ++v90;
            v92 += 2;
            v93 += 2;
          }
          while (v89 != v90);
        }
      }
      else
      {
        signed int v91 = 0;
      }
      free(v88);
      *(_DWORD *)&__src[2520] = v91;
      if (v91 >= *(_DWORD *)(v4 + 72))
      {
        __src[2524] = 1;
        AdjustYOpticalCenterForValidDistanceRange((uint64_t)v85, (uint64_t)v86, v91, v13, (double *)v4, (uint64_t)&v129);
        long long v96 = v136;
        long long v97 = v137;
        *(_OWORD *)(v13 + 96) = v135;
        *(_OWORD *)(v13 + 112) = v96;
        *(_OWORD *)(v13 + 128) = v97;
        long long v98 = v132;
        *(_OWORD *)(v13 + 32) = v131;
        *(_OWORD *)(v13 + 48) = v98;
        long long v99 = v134;
        *(_OWORD *)(v13 + 64) = v133;
        *(_OWORD *)(v13 + 80) = v99;
        long long v100 = v130;
        *(_OWORD *)uint64_t v13 = v129;
        *(_OWORD *)(v13 + 16) = v100;
        long long v101 = *(_OWORD *)(v13 + 64);
        *(_OWORD *)&__src[2608] = *(_OWORD *)(v13 + 80);
        long long v102 = *(_OWORD *)(v13 + 112);
        *(_OWORD *)&__src[2624] = *(_OWORD *)(v13 + 96);
        *(_OWORD *)&__src[2640] = v102;
        *(_OWORD *)&__src[2656] = *(_OWORD *)(v13 + 128);
        *(_OWORD *)&__src[2544] = *(_OWORD *)(v13 + 16);
        long long v103 = *(_OWORD *)(v13 + 48);
        *(_OWORD *)&__src[2560] = *(_OWORD *)(v13 + 32);
        *(_OWORD *)&__src[2576] = v103;
        *(_OWORD *)&__src[2592] = v101;
        *(_OWORD *)&__src[2528] = *(_OWORD *)v13;
        uint64_t v126 = 0;
        uint64_t v127 = 0;
        uint64_t v128 = 0;
        long long v104 = *(_OWORD *)(v13 + 112);
        long long v133 = *(_OWORD *)(v13 + 96);
        long long v134 = v104;
        long long v135 = *(_OWORD *)(v13 + 128);
        long long v105 = *(_OWORD *)(v13 + 48);
        long long v129 = *(_OWORD *)(v13 + 32);
        long long v130 = v105;
        long long v106 = *(_OWORD *)(v13 + 80);
        long long v131 = *(_OWORD *)(v13 + 64);
        long long v132 = v106;
        *(void *)&long long v105 = *(void *)(v13 + 24);
        double v165 = *(double *)(v13 + 16);
        double v166 = *(double *)&v105;
        double v107 = *(double *)(v13 + 8);
        double v167 = *(double *)v13;
        double v168 = v107;
        double v108 = *(double *)(v4 + 32);
        double v109 = *(double *)(v4 + 40);
        double v161 = v165 - v108;
        double v162 = *(double *)&v105 - v109;
        double v110 = *(double *)(v4 + 16);
        double v111 = *(double *)(v4 + 24);
        double v163 = v167 - v110;
        double v164 = v107 - v111;
        double v157 = v165 + v108;
        double v158 = *(double *)&v105 + v109;
        double v159 = v167 + v110;
        double v160 = v107 + v111;
        int v151 = 0;
        long long v153 = 0u;
        double v148 = v85;
        double v149 = v86;
        int v150 = v91;
        uint64_t v152 = v13;
        long long v143 = xmmword_215FC47C0;
        int v146 = unk_215FC47DC;
        uint64_t v147 = 0x3FB999999999999ALL;
        long long v141 = xmmword_215FC47A0;
        long long v142 = unk_215FC47B0;
        uint64_t v144 = 0;
        int v145 = 50;
        fmincon_spg((void (*)(void, void, void, void))CalcObjValGradForImagePoints, (void (*)(void, void, void))CalcObjValForImagePoints, (uint64_t)&v148, (uint64_t)&v165, 4, &v161, &v157, (double *)&v141, &v155, (uint64_t)&v126);
        long long v112 = v155;
        *(_OWORD *)uint64_t v13 = v156;
        *(_OWORD *)(v13 + 16) = v112;
        long long v113 = v134;
        *(_OWORD *)(v13 + 96) = v133;
        *(_OWORD *)(v13 + 112) = v113;
        *(_OWORD *)(v13 + 128) = v135;
        long long v114 = v130;
        *(_OWORD *)(v13 + 32) = v129;
        *(_OWORD *)(v13 + 48) = v114;
        long long v115 = v132;
        *(_OWORD *)(v13 + 64) = v131;
        *(_OWORD *)(v13 + 80) = v115;
        *(void *)&__src[2672] = v127;
        *(_DWORD *)&__src[2680] = v126;
        __src[2684] = 1;
        *(void *)&__src[2688] = v128;
        long long v116 = *(_OWORD *)v13;
        long long v117 = *(_OWORD *)(v13 + 16);
        long long v118 = *(_OWORD *)(v13 + 48);
        *(_OWORD *)&__src[2728] = *(_OWORD *)(v13 + 32);
        *(_OWORD *)&__src[2744] = v118;
        *(_OWORD *)&__src[2696] = v116;
        *(_OWORD *)&__src[2712] = v117;
        long long v119 = *(_OWORD *)(v13 + 64);
        long long v120 = *(_OWORD *)(v13 + 80);
        long long v121 = *(_OWORD *)(v13 + 128);
        *(_OWORD *)&__src[2808] = *(_OWORD *)(v13 + 112);
        *(_OWORD *)&__src[2824] = v121;
        long long v122 = *(_OWORD *)(v13 + 96);
        *(_OWORD *)&__src[2776] = v120;
        *(_OWORD *)&__src[2792] = v122;
        *(_OWORD *)&__src[2760] = v119;
      }
      goto LABEL_41;
    }
    if (v33 < 1)
    {
      double v42 = 0.0;
      double v41 = 0.0;
      double v40 = 0.0;
      double v39 = 0.0;
    }
    else
    {
      if (v33 == 1)
      {
        uint64_t v38 = 0;
        double v39 = 0.0;
        double v40 = 0.0;
        double v41 = 0.0;
        double v42 = 0.0;
      }
      else
      {
        uint64_t v38 = v33 & 0xFFFFFFFE;
        unint64_t v47 = v28 + 2;
        uint64_t v48 = v27 + 2;
        double v39 = 0.0;
        uint64_t v49 = v38;
        double v40 = 0.0;
        double v41 = 0.0;
        double v42 = 0.0;
        do
        {
          double v50 = *(v48 - 2);
          double v51 = *v48;
          v48 += 4;
          double v52 = v51;
          double v53 = *(v47 - 2);
          double v54 = *v47;
          v47 += 4;
          double v39 = v39 + v50 + v52;
          double v40 = v40 + v53 + v54;
          double v41 = v41 + v53 * v53 + v54 * v54;
          double v42 = v42 + v50 * v53 + v52 * v54;
          v49 -= 2;
        }
        while (v49);
        if (v38 == v33) {
          goto LABEL_24;
        }
      }
      uint64_t v55 = v33 - v38;
      uint64_t v56 = 2 * v38;
      double v57 = &v28[2 * v38];
      float v58 = &v27[v56];
      do
      {
        double v59 = *v58;
        v58 += 2;
        double v60 = v59;
        double v61 = *v57;
        v57 += 2;
        double v42 = v42 + v60 * v61;
        double v39 = v39 + v60;
        double v40 = v40 + v61;
        double v41 = v41 + v61 * v61;
        --v55;
      }
      while (v55);
    }
LABEL_24:
    double v45 = *(double *)v13;
    double v44 = *(double *)(v13 + 16);
    double v43 = *(double *)(v13 + 24);
    double v62 = v41 * (double)v33 - v40 * v40;
    if (v62 <= 0.0 || (double v63 = ((double)v33 * v42 - v39 * v40) / v62, v63 <= 0.0))
    {
      double v46 = *(double *)(v13 + 8);
    }
    else
    {
      double v64 = *(double *)(v13 + 128);
      double v46 = v45 / v63;
      if (v64 > 0.0) {
        double v43 = v43
      }
            - (v43
             - *(double *)(v13 + 8) * (*(double *)(v13 + 64) / v64))
            + (v44 - (v41 * v39 - v42 * v40) / v62) / v63;
    }
    *(double *)(v13 + 8) = v46;
    *(double *)(v13 + 24) = v43;
    __src[157] = 1;
    long long v65 = *(_OWORD *)(v13 + 112);
    *(_OWORD *)&__src[256] = *(_OWORD *)(v13 + 96);
    *(_OWORD *)&__src[272] = v65;
    *(_OWORD *)&__src[288] = *(_OWORD *)(v13 + 128);
    long long v66 = *(_OWORD *)(v13 + 48);
    *(_OWORD *)&__src[192] = *(_OWORD *)(v13 + 32);
    *(_OWORD *)&__src[208] = v66;
    long long v67 = *(_OWORD *)(v13 + 64);
    *(_OWORD *)&__src[240] = *(_OWORD *)(v13 + 80);
    *(_OWORD *)&__src[224] = v67;
    long long v68 = *(_OWORD *)v13;
    *(_OWORD *)&__src[176] = *(_OWORD *)(v13 + 16);
    *(_OWORD *)&__src[160] = v68;
    goto LABEL_29;
  }
  float64x2_t v27 = 0;
  int32x4_t v28 = 0;
  double v85 = 0;
  double v86 = 0;
LABEL_42:
  free(v27);
  free(v28);
  free(v85);
  free(v86);
  if (v2) {
    memcpy(v2, __src, 0x1E48uLL);
  }
}

double AdaptiveCorrection_rotateCalModel(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, __n128 a6, float32x2_t a7, float32x2_t a8, float32x2_t a9, float32x2_t a10)
{
  if (a1 && a2)
  {
    *(_OWORD *)a2 = *(_OWORD *)a1;
    long long v10 = *(_OWORD *)(a1 + 16);
    long long v11 = *(_OWORD *)(a1 + 32);
    long long v12 = *(_OWORD *)(a1 + 64);
    *(_OWORD *)(a2 + 48) = *(_OWORD *)(a1 + 48);
    *(_OWORD *)(a2 + 64) = v12;
    *(_OWORD *)(a2 + 16) = v10;
    *(_OWORD *)(a2 + 32) = v11;
    long long v13 = *(_OWORD *)(a1 + 80);
    long long v14 = *(_OWORD *)(a1 + 96);
    long long v15 = *(_OWORD *)(a1 + 128);
    *(_OWORD *)(a2 + 112) = *(_OWORD *)(a1 + 112);
    *(_OWORD *)(a2 + 128) = v15;
    *(_OWORD *)(a2 + 80) = v13;
    *(_OWORD *)(a2 + 96) = v14;
    *(float *)&long long v13 = *(double *)(a1 + 16);
    float v16 = *(double *)(a1 + 32);
    int32x2_t v17 = (int32x2_t)vmla_n_f32(vmul_n_f32(a7, *(float *)&v13), a8, v16);
    float v18 = *(double *)(a1 + 24);
    *(float *)&long long v13 = *(double *)(a1 + 40);
    int32x2_t v19 = (int32x2_t)vmla_n_f32(vmul_n_f32(a9, v18), a10, *(float *)&v13);
    *(float64x2_t *)(a2 + 16) = vcvtq_f64_f32((float32x2_t)vzip1_s32(v17, v19));
    *(float64x2_t *)(a2 + 32) = vcvtq_f64_f32((float32x2_t)vzip2_s32(v17, v19));
    *(double *)(a2 + 48) = *(float *)a3.i32;
    *(double *)(a2 + 56) = *(float *)a4.i32;
    *(double *)(a2 + 64) = *(float *)a5.i32;
    *(float64x2_t *)(a2 + 72) = vcvtq_f64_f32((float32x2_t)__PAIR64__(a3.u32[1], a6.n128_u32[0]));
    *(float64x2_t *)(a2 + 88) = vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)a4.i8, *(int32x2_t *)a5.i8));
    *(float64x2_t *)(a2 + 104) = vcvtq_f64_f32((float32x2_t)vext_s8((int8x8_t)a6.n128_u64[0], (int8x8_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), 4uLL));
    *(float64x2_t *)(a2 + 120) = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL)));
    *(double *)a3.i64 = a6.n128_f32[2];
    *(double *)(a2 + 136) = a6.n128_f32[2];
  }
  return *(double *)a3.i64;
}

float64x2_t AdaptiveCorrection_rotateDistortionModel(uint64_t a1, _OWORD *a2, float64x2_t result, float32x2_t a4)
{
  if (a1)
  {
    if (a2)
    {
      long long v4 = *(_OWORD *)(a1 + 16);
      *a2 = *(_OWORD *)a1;
      a2[1] = v4;
      long long v5 = *(_OWORD *)(a1 + 32);
      long long v6 = *(_OWORD *)(a1 + 48);
      long long v7 = *(_OWORD *)(a1 + 80);
      a2[4] = *(_OWORD *)(a1 + 64);
      a2[5] = v7;
      a2[2] = v5;
      a2[3] = v6;
      long long v8 = *(_OWORD *)(a1 + 96);
      long long v9 = *(_OWORD *)(a1 + 112);
      long long v10 = *(_OWORD *)(a1 + 144);
      a2[8] = *(_OWORD *)(a1 + 128);
      a2[9] = v10;
      a2[6] = v8;
      a2[7] = v9;
      *(float *)&long long v8 = *(double *)(a1 + 16);
      *(float *)&long long v9 = *(double *)(a1 + 24);
      uint64_t result = vcvtq_f64_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)&result.f64[0], *(float *)&v8), a4, *(float *)&v9));
      a2[1] = result;
    }
  }
  return result;
}

uint64_t AdaptiveCorrection_transformPointsWithMatrix(uint64_t a1, int a2, float64x2_t *a3, float32x2_t a4, float32x2_t a5)
{
  uint64_t v5 = 4294954516;
  if (!a1 || !a3) {
    return v5;
  }
  if (a2 >= 1)
  {
    uint64_t v5 = a2;
    long long v6 = (double *)(a1 + 8);
    do
    {
      float v7 = *(v6 - 1);
      float v8 = *v6;
      *a3++ = vcvtq_f64_f32(vmla_n_f32(vmul_n_f32(a4, v7), a5, v8));
      v6 += 2;
      --v5;
    }
    while (v5);
    return v5;
  }
  return 0;
}

double AdaptiveCorrection_approximateCorrection@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  long long v5 = *(_OWORD *)(a4 + 112);
  *(_OWORD *)(a5 + 96) = *(_OWORD *)(a4 + 96);
  *(_OWORD *)(a5 + 112) = v5;
  *(_OWORD *)(a5 + 128) = *(_OWORD *)(a4 + 128);
  long long v6 = *(_OWORD *)(a4 + 48);
  *(_OWORD *)(a5 + 32) = *(_OWORD *)(a4 + 32);
  *(_OWORD *)(a5 + 48) = v6;
  long long v7 = *(_OWORD *)(a4 + 80);
  *(_OWORD *)(a5 + 64) = *(_OWORD *)(a4 + 64);
  *(_OWORD *)(a5 + 80) = v7;
  long long v8 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)a5 = *(_OWORD *)a4;
  *(_OWORD *)(a5 + 16) = v8;
  if (a3 < 1)
  {
    double v13 = 0.0;
    double v12 = 0.0;
    double v11 = 0.0;
    double result = 0.0;
    goto LABEL_10;
  }
  if (a3 == 1)
  {
    uint64_t v9 = 0;
    double result = 0.0;
    double v11 = 0.0;
    double v12 = 0.0;
    double v13 = 0.0;
LABEL_8:
    uint64_t v22 = a3 - v9;
    uint64_t v23 = 16 * v9;
    long long v24 = (double *)(a2 + 16 * v9);
    long long v25 = (double *)(a1 + v23);
    do
    {
      double v26 = *v25;
      v25 += 2;
      double v27 = v26;
      double v28 = *v24;
      v24 += 2;
      double v13 = v13 + v27 * v28;
      double result = result + v27;
      double v11 = v11 + v28;
      double v12 = v12 + v28 * v28;
      --v22;
    }
    while (v22);
    goto LABEL_10;
  }
  uint64_t v9 = a3 & 0xFFFFFFFE;
  long long v14 = (double *)(a2 + 16);
  long long v15 = (double *)(a1 + 16);
  double result = 0.0;
  uint64_t v16 = v9;
  double v11 = 0.0;
  double v12 = 0.0;
  double v13 = 0.0;
  do
  {
    double v17 = *(v15 - 2);
    double v18 = *v15;
    v15 += 4;
    double v19 = v18;
    double v20 = *(v14 - 2);
    double v21 = *v14;
    v14 += 4;
    double result = result + v17 + v19;
    double v11 = v11 + v20 + v21;
    double v12 = v12 + v20 * v20 + v21 * v21;
    double v13 = v13 + v17 * v20 + v19 * v21;
    v16 -= 2;
  }
  while (v16);
  if (v9 != a3) {
    goto LABEL_8;
  }
LABEL_10:
  double v29 = v12 * (double)a3 - v11 * v11;
  if (v29 > 0.0)
  {
    double v30 = ((double)a3 * v13 - result * v11) / v29;
    if (v30 > 0.0)
    {
      double v31 = *(double *)(a4 + 8);
      double v33 = *(double *)(a4 + 16);
      double v32 = *(double *)(a4 + 24);
      double v34 = *(double *)(a4 + 64);
      double v35 = *(double *)(a4 + 128);
      *(double *)(a5 + 8) = *(double *)a4 / v30;
      if (v35 > 0.0)
      {
        double result = v32 - (v32 - v31 * (v34 / v35)) + (v33 - (v12 * result - v13 * v11) / v29) / v30;
        *(double *)(a5 + 24) = result;
      }
    }
  }
  return result;
}

uint64_t AdaptiveCorrection_applyDistortionModelSimplified(const double *a1, unsigned int a2, float64x2_t *a3, double *a4)
{
  uint64_t v4 = 4294954516;
  if (a1 && (int)a2 >= 1 && a3 && a4)
  {
    double v5 = a3->f64[0];
    float64_t v6 = a3->f64[1] * a3->f64[0];
    double v7 = a3[2].f64[0] + v6 * a3[6].f64[0];
    double v8 = a3[2].f64[1] + v6 * a3[6].f64[1];
    double v9 = a3[3].f64[0] + v6 * a3[7].f64[0];
    double v10 = a3[3].f64[1] + v6 * a3[7].f64[1];
    double v11 = a3[4].f64[0] + v6 * a3[8].f64[0];
    double v12 = a3[4].f64[1] + v6 * a3[8].f64[1];
    double v13 = a3[5].f64[0] + v6 * a3[9].f64[0];
    double v14 = a3[5].f64[1] + v6 * a3[9].f64[1];
    float64x2_t v15 = a3[1];
    if (a2 >= 2 && (&a1[2 * a2] <= a4 || &a4[2 * a2] <= a1))
    {
      float64x2_t v28 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v15.f64[0], 0);
      float64x2_t v29 = (float64x2_t)vdupq_laneq_s64((int64x2_t)v15, 1);
      float64x2_t v30 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v7, 0);
      float64x2_t v31 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v9, 0);
      float64x2_t v32 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v10, 0);
      float64x2_t v33 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v11, 0);
      float64x2_t v34 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v12, 0);
      uint64_t v16 = a2 & 0xFFFFFFFE;
      float64x2_t v35 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v13, 0);
      float64x2_t v36 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
      __asm { FMOV            V27.2D, #1.0 }
      double v42 = a1;
      double v43 = a4;
      uint64_t v44 = v16;
      float64x2_t v45 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v14, 0);
      do
      {
        float64x2x2_t v51 = vld2q_f64(v42);
        v42 += 4;
        float64x2_t v46 = vsubq_f64(v51.val[0], v28);
        v51.val[0] = vsubq_f64(v51.val[1], v29);
        v51.val[1] = vmulq_n_f64(vsqrtq_f64(vmlaq_f64(vmulq_f64(v51.val[0], v51.val[0]), v46, v46)), v5);
        v51.val[1] = vmulq_f64(v51.val[1], v51.val[1]);
        float64x2_t v47 = vmulq_f64(v51.val[1], v51.val[1]);
        float64x2_t v48 = vmulq_f64(v51.val[1], v47);
        float64x2_t v49 = vmulq_f64(v47, v47);
        v51.val[1] = vaddq_f64(vdivq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vaddq_f64(v30, vmulq_n_f64(v51.val[1], v8)), v47, v31), v48, v32), v49, v33), vmulq_f64(v47, v48), v34), vmulq_f64(v48, v48), v35), vmulq_f64(v49, v48), v45), v36), _Q27);
        v51.val[1] = (float64x2_t)vbslq_s8((int8x16_t)vcgtzq_f64(v51.val[1]), (int8x16_t)vdivq_f64(_Q27, v51.val[1]), (int8x16_t)_Q27);
        v51.val[0] = vmulq_f64(v51.val[0], v51.val[1]);
        v51.val[1] = vaddq_f64(v28, vmulq_f64(v46, v51.val[1]));
        float64x2_t v50 = vaddq_f64(v29, v51.val[0]);
        vst2q_f64(v43, *(float64x2x2_t *)((char *)&v51 + 16));
        v43 += 4;
        v44 -= 2;
      }
      while (v44);
      if (v16 == a2) {
        return 0;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
    uint64_t v4 = a2 - v16;
    uint64_t v17 = 2 * v16;
    double v18 = (float64x2_t *)&a4[2 * v16];
    double v19 = (float64x2_t *)&a1[v17];
    do
    {
      float64x2_t v20 = *v19++;
      float64x2_t v21 = vsubq_f64(v20, v15);
      double v22 = sqrt(vmlad_n_f64(COERCE_DOUBLE(*(void *)&vmulq_f64(v21, v21).f64[1]), v21.f64[0], v21.f64[0]));
      double v23 = v5 * v22 * (v5 * v22);
      double v24 = v23 * (v23 * v23);
      double v25 = (v7
           + v8 * v23
           + v9 * (v23 * v23)
           + v10 * v24
           + v11 * (v23 * v23 * (v23 * v23))
           + v12 * (v23 * v23 * v24)
           + v13 * (v24 * v24)
           + v14 * (v23 * v23 * (v23 * v23) * v24))
          / 100.0
          + 1.0;
      if (v25 <= 0.0) {
        double v26 = 1.0;
      }
      else {
        double v26 = 1.0 / v25;
      }
      *v18++ = vaddq_f64(v15, vmulq_n_f64(v21, v26));
      --v4;
    }
    while (v4);
  }
  return v4;
}

const double *AdaptiveCorrection_applyDistortionModel(const double *result, unsigned int a2, double *a3, double *a4, double a5, double a6, double a7)
{
  if ((int)a2 >= 1)
  {
    uint64_t v7 = *(uint64_t *)a3;
    double v8 = a3[1];
    uint64_t v9 = *((uint64_t *)a3 + 2);
    uint64_t v10 = *((uint64_t *)a3 + 3);
    uint64_t v11 = *((uint64_t *)a3 + 4);
    uint64_t v12 = *((uint64_t *)a3 + 5);
    uint64_t v13 = *((uint64_t *)a3 + 6);
    uint64_t v14 = *((uint64_t *)a3 + 7);
    if (a2 == 1 || (&result[2 * a2] > a4 ? (BOOL v15 = &a4[2 * a2] > result) : (BOOL v15 = 0), v15))
    {
      uint64_t v23 = 0;
    }
    else
    {
      float64x2_t v16 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a5, 0);
      float64x2_t v17 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a6, 0);
      float64x2_t v18 = (float64x2_t)vdupq_lane_s64(v7, 0);
      float64x2_t v19 = (float64x2_t)vdupq_lane_s64(v9, 0);
      float64x2_t v20 = (float64x2_t)vdupq_lane_s64(v10, 0);
      float64x2_t v21 = (float64x2_t)vdupq_lane_s64(v11, 0);
      float64x2_t v22 = (float64x2_t)vdupq_lane_s64(v12, 0);
      uint64_t v23 = a2 & 0xFFFFFFFE;
      float64x2_t v24 = (float64x2_t)vdupq_lane_s64(v13, 0);
      float64x2_t v25 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
      __asm { FMOV            V28.2D, #1.0 }
      float64x2_t v31 = result;
      float64x2_t v32 = a4;
      uint64_t v33 = v23;
      float64x2_t v34 = (float64x2_t)vdupq_lane_s64(v14, 0);
      do
      {
        float64x2x2_t v51 = vld2q_f64(v31);
        v31 += 4;
        float64x2_t v35 = vsubq_f64(v51.val[0], v16);
        v51.val[0] = vsubq_f64(v51.val[1], v17);
        v51.val[1] = vmulq_n_f64(vsqrtq_f64(vmlaq_f64(vmulq_f64(v51.val[0], v51.val[0]), v35, v35)), a7);
        v51.val[1] = vmulq_f64(v51.val[1], v51.val[1]);
        float64x2_t v36 = vmulq_f64(v51.val[1], v51.val[1]);
        float64x2_t v37 = vmulq_f64(v51.val[1], v36);
        float64x2_t v38 = vmulq_f64(v36, v36);
        v51.val[1] = vaddq_f64(vdivq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vaddq_f64(v18, vmulq_n_f64(v51.val[1], v8)), v36, v19), v37, v20), v38, v21), vmulq_f64(v36, v37), v22), vmulq_f64(v37, v37), v24), vmulq_f64(v38, v37), v34), v25), _Q28);
        v51.val[1] = (float64x2_t)vbslq_s8((int8x16_t)vcgtzq_f64(v51.val[1]), (int8x16_t)vdivq_f64(_Q28, v51.val[1]), (int8x16_t)_Q28);
        v50.val[0] = vaddq_f64(vmulq_f64(v35, v51.val[1]), v16);
        v50.val[1] = vaddq_f64(vmulq_f64(v51.val[0], v51.val[1]), v17);
        vst2q_f64(v32, v50);
        v32 += 4;
        v33 -= 2;
      }
      while (v33);
      if (v23 == a2) {
        return result;
      }
    }
    uint64_t v39 = a2 - v23;
    uint64_t v40 = (16 * v23) | 8;
    double v41 = (double *)((char *)a4 + v40);
    double v42 = (double *)((char *)result + v40);
    do
    {
      double v43 = *(v42 - 1) - a5;
      double v44 = *v42 - a6;
      double v45 = sqrt(v44 * v44 + v43 * v43);
      double v46 = v45 * a7 * (v45 * a7);
      double v47 = v46 * (v46 * v46);
      double v48 = (*(double *)&v7
           + v8 * v46
           + *(double *)&v9 * (v46 * v46)
           + *(double *)&v10 * v47
           + *(double *)&v11 * (v46 * v46 * (v46 * v46))
           + *(double *)&v12 * (v46 * v46 * v47)
           + *(double *)&v13 * (v47 * v47)
           + *(double *)&v14 * (v46 * v46 * (v46 * v46) * v47))
          / 100.0
          + 1.0;
      if (v48 <= 0.0) {
        double v49 = 1.0;
      }
      else {
        double v49 = 1.0 / v48;
      }
      *(v41 - 1) = v43 * v49 + a5;
      double *v41 = v44 * v49 + a6;
      v41 += 2;
      v42 += 2;
      --v39;
    }
    while (v39);
  }
  return result;
}

uint64_t AdaptiveCorrection_computeStereoRectificationHomographies(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5, double a6, float32x4_t a7)
{
  uint64_t v9 = 4294954516;
  if (a1 && a2 && a3 && a4)
  {
    float v10 = *(double *)a1;
    if (v10 <= 0.0) {
      return 4294954516;
    }
    v11.i32[0] = 0;
    v11.i64[1] = 0;
    float v12 = *(double *)(a1 + 72);
    float v13 = *(double *)(a1 + 104);
    float v14 = *(double *)(a1 + 136);
    int32x2_t v15 = (int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 48));
    a7.f32[0] = *(double *)(a1 + 64);
    float64x2_t v16 = *(float64x2_t *)(a1 + 80);
    float32_t v17 = *(double *)(a1 + 96);
    float64x2_t v18 = *(float64x2_t *)(a1 + 112);
    *(float32x2_t *)&v18.f64[0] = vcvt_f32_f64(v18);
    int32x2_t v19 = vzip1_s32(v15, *(int32x2_t *)&v18.f64[0]);
    *(int32x2_t *)v20.f32 = vzip1_s32(v19, (int32x2_t)vcvt_f32_f64(v16));
    *(int32x2_t *)&v20.u32[2] = vdup_lane_s32(v19, 1);
    float32_t v21 = *(double *)(a1 + 128);
    a7.f32[1] = v17;
    a7.f32[2] = v21;
    float32x4_t v22 = (float32x4_t)vuzp2q_s32((int32x4_t)vcvt_hight_f32_f64(v15, v16), (int32x4_t)v18);
    float32x4_t v23 = vmlaq_f32(vmlaq_f32(vnegq_f32(v20), (float32x4_t)0, v22), (float32x4_t)0, a7);
    float32x4_t v24 = vmulq_f32(v20, (float32x4_t)0);
    __asm { FMOV            V17.4S, #-1.0 }
    float32x4_t v30 = vmlaq_f32(vmlaq_f32(v24, _Q17, v22), (float32x4_t)0, a7);
    float32x4_t v31 = vaddq_f32(a7, vmlaq_f32(v24, (float32x4_t)0, v22));
    float32x4_t v32 = vmlaq_n_f32(vmulq_n_f32((float32x4_t)xmmword_215FC45F0, v12), (float32x4_t)xmmword_215FC4600, v13);
    float32x4_t v33 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_215FC45F0, v23.f32[0]), (float32x4_t)xmmword_215FC4600, *(float32x2_t *)v23.f32, 1), (float32x4_t)xmmword_215FC45E0, v23, 2);
    float32x4_t v34 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_215FC45F0, v30.f32[0]), (float32x4_t)xmmword_215FC4600, *(float32x2_t *)v30.f32, 1), (float32x4_t)xmmword_215FC45E0, v30, 2);
    float32x4_t v35 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_215FC45F0, v31.f32[0]), (float32x4_t)xmmword_215FC4600, *(float32x2_t *)v31.f32, 1), (float32x4_t)xmmword_215FC45E0, v31, 2);
    float32x4_t v36 = vmlaq_n_f32(v32, (float32x4_t)xmmword_215FC45E0, v14);
    float32x4_t v37 = (float32x4_t)vtrn2q_s32((int32x4_t)v33, (int32x4_t)v34);
    v37.i32[2] = v35.i32[1];
    float32x4_t v38 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v33, (int32x4_t)v35), (int32x4_t)v34), v36.f32[0]), v37, *(float32x2_t *)v36.f32, 1), (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)v33, (int32x4_t)v35), vdupq_laneq_s32((int32x4_t)v34, 2)), v36, 2);
    float32x4_t v39 = vnegq_f32(v38);
    int32x4_t v40 = (int32x4_t)vmulq_f32(v38, v38);
    v40.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v40, 2), vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.i8, 1))).u32[0];
    *(float32x2_t *)v23.f32 = vrsqrte_f32((float32x2_t)v40.u32[0]);
    *(float32x2_t *)v23.f32 = vmul_f32(*(float32x2_t *)v23.f32, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v23.f32)));
    float32x4_t v41 = vmulq_n_f32(v39, vmul_f32(*(float32x2_t *)v23.f32, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(*(float32x2_t *)v23.f32, *(float32x2_t *)v23.f32))).f32[0]);
    float32x4_t v42 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), (int8x16_t)v41, 0xCuLL);
    float32x4_t v43 = vmlaq_f32(vmulq_f32(v42, (float32x4_t)xmmword_215FC4610), (float32x4_t)xmmword_215FC4620, v41);
    float32x4_t v44 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v43, (int32x4_t)v43), (int8x16_t)v43, 0xCuLL);
    int32x4_t v45 = (int32x4_t)vmulq_f32(v43, v43);
    v45.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v45.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v45, 2), *(float32x2_t *)v45.i8)).u32[0];
    *(float32x2_t *)v30.f32 = vrsqrte_f32((float32x2_t)v45.u32[0]);
    *(float32x2_t *)v30.f32 = vmul_f32(*(float32x2_t *)v30.f32, vrsqrts_f32((float32x2_t)v45.u32[0], vmul_f32(*(float32x2_t *)v30.f32, *(float32x2_t *)v30.f32)));
    float32x4_t v46 = vmulq_n_f32(v44, vmul_f32(*(float32x2_t *)v30.f32, vrsqrts_f32((float32x2_t)v45.u32[0], vmul_f32(*(float32x2_t *)v30.f32, *(float32x2_t *)v30.f32))).f32[0]);
    float32x4_t v47 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v46, (int32x4_t)v46), (int8x16_t)v46, 0xCuLL), vnegq_f32(v41)), v46, v42);
    float32x4_t v48 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v47, (int32x4_t)v47), (int8x16_t)v47, 0xCuLL);
    int32x4_t v49 = (int32x4_t)vmulq_f32(v47, v47);
    v49.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v49.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v49, 2), *(float32x2_t *)v49.i8)).u32[0];
    *(float32x2_t *)v30.f32 = vrsqrte_f32((float32x2_t)v49.u32[0]);
    *(float32x2_t *)v30.f32 = vmul_f32(*(float32x2_t *)v30.f32, vrsqrts_f32((float32x2_t)v49.u32[0], vmul_f32(*(float32x2_t *)v30.f32, *(float32x2_t *)v30.f32)));
    float32x4_t v50 = vmulq_n_f32(v48, vmul_f32(*(float32x2_t *)v30.f32, vrsqrts_f32((float32x2_t)v49.u32[0], vmul_f32(*(float32x2_t *)v30.f32, *(float32x2_t *)v30.f32))).f32[0]);
    v7.i32[0] = 1.0;
    v30.i64[0] = 0x8000000080000000;
    v30.i64[1] = 0x8000000080000000;
    float32x4_t v51 = vmulq_n_f32(v41, *(float *)vbslq_s8((int8x16_t)v30, v7, (int8x16_t)v41).i32);
    v41.i32[0] = v46.i32[1];
    int8x16_t v52 = vbslq_s8((int8x16_t)v30, v7, (int8x16_t)v41);
    int32x4_t v53 = (int32x4_t)vmulq_n_f32(v46, *(float *)v52.i32);
    v52.i32[0] = v50.i32[2];
    float32x4_t v54 = vmulq_n_f32(v50, *(float *)vbslq_s8((int8x16_t)v30, v7, v52).i32);
    int32x4_t v55 = vzip1q_s32((int32x4_t)v51, (int32x4_t)v54);
    int32x4_t v56 = vzip1q_s32(v55, v53);
    float32x4_t v57 = (float32x4_t)vzip2q_s32(v55, vzip1q_s32(v53, (int32x4_t)0));
    int32x4_t v58 = vzip1q_s32(vzip2q_s32((int32x4_t)v51, (int32x4_t)v54), vdupq_laneq_s32(v53, 2));
    int32x4_t v59 = vzip1q_s32(v56, v58);
    int32x4_t v60 = vzip2q_s32(v56, v58);
    int32x4_t v61 = vzip1q_s32((int32x4_t)v57, (int32x4_t)0);
    float32x4_t v62 = (float32x4_t)vtrn2q_s32(v56, v53);
    v62.i32[2] = v58.i32[1];
    float32x4_t v63 = vmulq_f32((float32x4_t)vzip1q_s32(v59, v61), (float32x4_t)0);
    float32x4_t v64 = vaddq_f32((float32x4_t)vzip1q_s32(v60, vdupq_lane_s32(*(int32x2_t *)v54.f32, 1)), vmlaq_f32(v63, (float32x4_t)0, v62));
    if (v64.f32[2] <= 0.0)
    {
      return 4294954516;
    }
    else
    {
      uint64_t v9 = 0;
      int32x4_t v65 = (int32x4_t)xmmword_215FC4620;
      double v66 = *(double *)(a1 + 8);
      *(float *)v8.i32 = *(double *)(a1 + 16);
      double v67 = *(double *)(a1 + 24);
      *(float *)&unsigned int v68 = *(double *)(a1 + 32);
      *(float *)&unsigned int v69 = *(double *)a1;
      v11.f32[1] = *(float *)&v69;
      float32x4_t v70 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 2);
      int32x2_t v71 = (int32x2_t)vdivq_f32(v64, v70).u64[0];
      v70.f32[0] = -*(float *)v71.i32;
      v65.i32[2] = v71.i32[0];
      __asm { FMOV            V31.4S, #1.0 }
      *(float *)&double v67 = v67;
      int32x4_t v73 = vzip2q_s32(vdupq_lane_s32(*(int32x2_t *)v70.f32, 0), _Q31);
      int32x4_t v74 = vzip2q_s32(vdupq_lane_s32(*(int32x2_t *)&v67, 0), _Q31);
      int32x4_t v75 = vzip2q_s32(v65, _Q31);
      v76.i64[1] = _Q31.i64[1];
      v76.i64[0] = __PAIR64__(v68, v8.u32[0]);
      float32x4_t v77 = (float32x4_t)vzip2q_s32(v59, v61);
      _Q31.i64[0] = *(void *)(a1 + 40);
      float v78 = 1.0 / v10;
      float v79 = (float)-*(float *)v8.i32 / v10;
      float v80 = (float)-*(float *)&v68 / v10;
      *(float *)v8.i32 = -*(float *)&v71.i32[1];
      float32x4_t v81 = vmlaq_f32(vmlaq_f32(vmulq_n_f32(v51, v78), (float32x4_t)0, v77), (float32x4_t)0, v54);
      float32x4_t v82 = vmlaq_f32(vmlaq_n_f32(v63, v77, v78), (float32x4_t)0, v54);
      float32x4_t v83 = vaddq_f32(v54, vmlaq_n_f32(vmulq_n_f32(v51, v79), v77, v80));
      float32x4_t v84 = (float32x4_t)vzip1q_s32(v73, v8);
      float32x4_t v85 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_215FC4620, v81.f32[0]), (float32x4_t)xmmword_215FC4630, *(float32x2_t *)v81.f32, 1), v84, v81, 2);
      float32x4_t v86 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_215FC4620, v82.f32[0]), (float32x4_t)xmmword_215FC4630, *(float32x2_t *)v82.f32, 1), v84, v82, 2);
      float32x4_t v87 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_215FC4620, v83.f32[0]), (float32x4_t)xmmword_215FC4630, *(float32x2_t *)v83.f32, 1), v84, v83, 2);
      float32x4_t v88 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v69, v85.f32[0]), v11, *(float32x2_t *)v85.f32, 1), v76, v85, 2);
      float32x4_t v89 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v69, v86.f32[0]), v11, *(float32x2_t *)v86.f32, 1), v76, v86, 2);
      float32x4_t v90 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v69, v87.f32[0]), v11, *(float32x2_t *)v87.f32, 1), v76, v87, 2);
      *(_DWORD *)(a2 + 8) = v88.i32[2];
      *(_DWORD *)(a2 + 24) = v89.i32[2];
      *(_DWORD *)(a2 + 40) = v90.i32[2];
      float32x4_t v91 = (float32x4_t)vzip1q_s32((int32x4_t)v51, v53);
      v91.i32[2] = v54.i32[0];
      float32x4_t v92 = (float32x4_t)vzip2q_s32((int32x4_t)v51, v53);
      v92.i32[2] = v54.i32[2];
      *(float *)&unsigned int v93 = v66;
      LODWORD(v94) = 0;
      HIDWORD(v94) = v93;
      int32x4_t v95 = vdupq_lane_s32(v71, 1);
      *(float *)v65.i32 = *(double *)_Q31.i64;
      float32x4_t v96 = (float32x4_t)vzip1q_s32(v74, v65);
      float32x4_t v97 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, v85.f32[0]), v34, *(float32x2_t *)v85.f32, 1), v35, v85, 2);
      float32x4_t v98 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, v86.f32[0]), v34, *(float32x2_t *)v86.f32, 1), v35, v86, 2);
      float32x4_t v99 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, v87.f32[0]), v34, *(float32x2_t *)v87.f32, 1), v35, v87, 2);
      float32x4_t v100 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v93, v97.f32[0]), (float32x4_t)v94, *(float32x2_t *)v97.f32, 1), v96, v97, 2);
      float32x4_t v101 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v93, v98.f32[0]), (float32x4_t)v94, *(float32x2_t *)v98.f32, 1), v96, v98, 2);
      float32x4_t v102 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v93, v99.f32[0]), (float32x4_t)v94, *(float32x2_t *)v99.f32, 1), v96, v99, 2);
      float32x4_t v103 = (float32x4_t)vzip1q_s32(v75, v95);
      float32x4_t v104 = vmlaq_f32(vmlaq_f32(vmulq_n_f32((float32x4_t)0x3F800000uLL, v78), (float32x4_t)0, (float32x4_t)xmmword_215FC4630), (float32x4_t)0, v103);
      float32x4_t v105 = vmlaq_f32(vmlaq_n_f32(vmulq_f32((float32x4_t)0x3F800000uLL, (float32x4_t)0), (float32x4_t)xmmword_215FC4630, v78), (float32x4_t)0, v103);
      float32x4_t v106 = vaddq_f32(v103, vmlaq_n_f32(vmulq_n_f32((float32x4_t)0x3F800000uLL, v79), (float32x4_t)xmmword_215FC4630, v80));
      float32x4_t v107 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v91, v104.f32[0]), v57, *(float32x2_t *)v104.f32, 1), v92, v104, 2);
      float32x4_t v108 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v91, v105.f32[0]), v57, *(float32x2_t *)v105.f32, 1), v92, v105, 2);
      *(void *)a2 = v88.i64[0];
      *(_DWORD *)(a2 + 12) = 0;
      *(void *)(a2 + 16) = v89.i64[0];
      *(_DWORD *)(a2 + 28) = 0;
      *(void *)(a2 + 32) = v90.i64[0];
      *(_DWORD *)(a2 + 44) = 0;
      *(_DWORD *)(a3 + 8) = v100.i32[2];
      *(void *)a3 = v100.i64[0];
      *(_DWORD *)(a3 + 12) = 0;
      *(_DWORD *)(a3 + 24) = v101.i32[2];
      float32x4_t v109 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v91, v106.f32[0]), v57, *(float32x2_t *)v106.f32, 1), v92, v106, 2);
      float32x4_t v110 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v69, v107.f32[0]), v11, *(float32x2_t *)v107.f32, 1), v76, v107, 2);
      float32x4_t v111 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v69, v108.f32[0]), v11, *(float32x2_t *)v108.f32, 1), v76, v108, 2);
      *(void *)(a3 + 16) = v101.i64[0];
      *(_DWORD *)(a3 + 28) = 0;
      *(_DWORD *)(a3 + 40) = v102.i32[2];
      *(void *)(a3 + 32) = v102.i64[0];
      *(_DWORD *)(a3 + 44) = 0;
      *(void *)a4 = v110.i64[0];
      *(_DWORD *)(a4 + 8) = v110.i32[2];
      *(_DWORD *)(a4 + 12) = 0;
      *(void *)(a4 + 16) = v111.i64[0];
      *(_DWORD *)(a4 + 24) = v111.i32[2];
      float32x4_t v112 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v69, v109.f32[0]), v11, *(float32x2_t *)v109.f32, 1), v76, v109, 2);
      *(_DWORD *)(a4 + 28) = 0;
      *(void *)(a4 + 32) = v112.i64[0];
      *(_DWORD *)(a4 + 40) = v112.i32[2];
      *(_DWORD *)(a4 + 44) = 0;
    }
  }
  return v9;
}

double FundamentalEpipolarErrorForCalModel(double *a1, uint64_t a2, uint64_t a3, int a4)
{
  double v5 = 0.0;
  FundamentalEpipolarError_MeanVal(a2, a3, a4, a1, &v5);
  return v5;
}

void sub_215F5D694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F5D704(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F5D7CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F5DAEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F5DBE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F5DCFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F5DDC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float DisparityToDepth::RansacLine2DModel::intercept(DisparityToDepth::RansacLine2DModel *this)
{
  return *((float *)this + 3);
}

float DisparityToDepth::RansacLine2DModel::slope(DisparityToDepth::RansacLine2DModel *this)
{
  return *((float *)this + 2);
}

uint64_t DisparityToDepth::RansacLine2DModel::minNumOfParametersForFit(DisparityToDepth::RansacLine2DModel *this)
{
  return 2;
}

void DisparityToDepth::RansacLine2DModel::estimateX(uint64_t a1@<X0>, float **a2@<X1>, float **a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  uint64_t v5 = (char *)v3 - (char *)*a2;
  if (v3 != *a2)
  {
    if (v5 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    int32x4_t v8 = (float *)operator new((char *)v3 - (char *)*a2);
    uint64_t v9 = &v8[v5 >> 2];
    *a3 = v8;
    a3[1] = v8;
    a3[2] = v9;
    float v10 = v8;
    double v26 = v3;
    while (1)
    {
      float v12 = (float)(*v4 - *(float *)(a1 + 12)) / *(float *)(a1 + 8);
      if (v10 >= v9) {
        break;
      }
      *float v10 = v12;
      float32x4_t v11 = v10 + 1;
LABEL_5:
      a3[1] = v11;
      ++v4;
      float v10 = v11;
      if (v4 == v3) {
        return;
      }
    }
    uint64_t v13 = v10 - v8;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    if (((char *)v9 - (char *)v8) >> 1 > v14) {
      unint64_t v14 = ((char *)v9 - (char *)v8) >> 1;
    }
    if ((unint64_t)((char *)v9 - (char *)v8) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15)
    {
      if (v15 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float64x2_t v16 = operator new(4 * v15);
    }
    else
    {
      float64x2_t v16 = 0;
    }
    float32_t v17 = (float *)&v16[4 * v13];
    float *v17 = v12;
    float32x4_t v11 = v17 + 1;
    if (v10 == v8) {
      goto LABEL_21;
    }
    unint64_t v18 = (char *)(v10 - 1) - (char *)v8;
    if (v18 < 0xBC)
    {
      int32x2_t v19 = v10;
      goto LABEL_20;
    }
    if (&v16[(char *)v10 - (char *)v8 - 4 - (v18 & 0xFFFFFFFFFFFFFFFCLL)] > &v16[(char *)v10 - (char *)v8 - 4])
    {
      int32x2_t v19 = v10;
    }
    else
    {
      if ((float *)((char *)v10 - (v18 & 0xFFFFFFFFFFFFFFFCLL) - 4) <= v10 - 1)
      {
        if ((unint64_t)((char *)v8 - v16) < 0x20)
        {
          int32x2_t v19 = v10;
          goto LABEL_20;
        }
        uint64_t v21 = (v18 >> 2) + 1;
        int32x2_t v19 = &v10[-(v21 & 0x7FFFFFFFFFFFFFF8)];
        float32x4_t v22 = &v16[4 * v13 - 16];
        float32x4_t v23 = v10 - 4;
        uint64_t v24 = v21 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v25 = *(_OWORD *)v23;
          *(v22 - 1) = *((_OWORD *)v23 - 1);
          _OWORD *v22 = v25;
          v22 -= 2;
          v23 -= 8;
          v24 -= 8;
        }
        while (v24);
        v17 -= v21 & 0x7FFFFFFFFFFFFFF8;
        if (v21 != (v21 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_20;
        }
LABEL_21:
        uint64_t v9 = (float *)&v16[4 * v15];
        *a3 = v17;
        a3[1] = v11;
        a3[2] = v9;
        if (v8) {
          operator delete(v8);
        }
        int32x4_t v8 = v17;
        uint64_t v3 = v26;
        goto LABEL_5;
      }
      int32x2_t v19 = v10;
    }
    do
    {
LABEL_20:
      int v20 = *((_DWORD *)v19-- - 1);
      *((_DWORD *)v17-- - 1) = v20;
    }
    while (v19 != v8);
    goto LABEL_21;
  }
}

void sub_215F5E214(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void DisparityToDepth::RansacLine2DModel::estimateY(uint64_t a1@<X0>, float **a2@<X1>, float **a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  uint64_t v5 = (char *)v3 - (char *)*a2;
  if (v3 != *a2)
  {
    if (v5 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    int32x4_t v8 = (float *)operator new((char *)v3 - (char *)*a2);
    uint64_t v9 = &v8[v5 >> 2];
    *a3 = v8;
    a3[1] = v8;
    a3[2] = v9;
    float v10 = v8;
    double v26 = v3;
    while (1)
    {
      float v12 = *(float *)(a1 + 12) + (float)(*(float *)(a1 + 8) * *v4);
      if (v10 >= v9) {
        break;
      }
      *float v10 = v12;
      float32x4_t v11 = v10 + 1;
LABEL_5:
      a3[1] = v11;
      ++v4;
      float v10 = v11;
      if (v4 == v3) {
        return;
      }
    }
    uint64_t v13 = v10 - v8;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    if (((char *)v9 - (char *)v8) >> 1 > v14) {
      unint64_t v14 = ((char *)v9 - (char *)v8) >> 1;
    }
    if ((unint64_t)((char *)v9 - (char *)v8) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15)
    {
      if (v15 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float64x2_t v16 = operator new(4 * v15);
    }
    else
    {
      float64x2_t v16 = 0;
    }
    float32_t v17 = (float *)&v16[4 * v13];
    float *v17 = v12;
    float32x4_t v11 = v17 + 1;
    if (v10 == v8) {
      goto LABEL_21;
    }
    unint64_t v18 = (char *)(v10 - 1) - (char *)v8;
    if (v18 < 0xBC)
    {
      int32x2_t v19 = v10;
      goto LABEL_20;
    }
    if (&v16[(char *)v10 - (char *)v8 - 4 - (v18 & 0xFFFFFFFFFFFFFFFCLL)] > &v16[(char *)v10 - (char *)v8 - 4])
    {
      int32x2_t v19 = v10;
    }
    else
    {
      if ((float *)((char *)v10 - (v18 & 0xFFFFFFFFFFFFFFFCLL) - 4) <= v10 - 1)
      {
        if ((unint64_t)((char *)v8 - v16) < 0x20)
        {
          int32x2_t v19 = v10;
          goto LABEL_20;
        }
        uint64_t v21 = (v18 >> 2) + 1;
        int32x2_t v19 = &v10[-(v21 & 0x7FFFFFFFFFFFFFF8)];
        float32x4_t v22 = &v16[4 * v13 - 16];
        float32x4_t v23 = v10 - 4;
        uint64_t v24 = v21 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v25 = *(_OWORD *)v23;
          *(v22 - 1) = *((_OWORD *)v23 - 1);
          _OWORD *v22 = v25;
          v22 -= 2;
          v23 -= 8;
          v24 -= 8;
        }
        while (v24);
        v17 -= v21 & 0x7FFFFFFFFFFFFFF8;
        if (v21 != (v21 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_20;
        }
LABEL_21:
        uint64_t v9 = (float *)&v16[4 * v15];
        *a3 = v17;
        a3[1] = v11;
        a3[2] = v9;
        if (v8) {
          operator delete(v8);
        }
        int32x4_t v8 = v17;
        uint64_t v3 = v26;
        goto LABEL_5;
      }
      int32x2_t v19 = v10;
    }
    do
    {
LABEL_20:
      int v20 = *((_DWORD *)v19-- - 1);
      *((_DWORD *)v17-- - 1) = v20;
    }
    while (v19 != v8);
    goto LABEL_21;
  }
}

void sub_215F5E460(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float DisparityToDepth::RansacLine2DModel::fit(uint64_t a1, float **a2, float **a3)
{
  uint64_t v3 = (float32x4_t *)*a2;
  uint64_t v4 = a2[1];
  if (*a2 == v4 || (uint64_t v5 = (float32x4_t *)*a3, v6 = a3[1], *a3 == v6))
  {
    *(_DWORD *)(a1 + 8) = 0;
    float result = 0.0;
    *(_DWORD *)(a1 + 12) = 0;
    return result;
  }
  unint64_t v7 = (char *)v4 - (char *)v3 - 4;
  uint64_t v8 = (v7 >> 2) + 1;
  double v9 = 0.0;
  float v10 = *a2;
  if (v7 <= 0x1B) {
    goto LABEL_8;
  }
  float32x4_t v11 = v3 + 1;
  uint64_t v12 = v8 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    float32x4_t v13 = v11[-1];
    float64x2_t v14 = vcvt_hight_f64_f32(v13);
    float64x2_t v15 = vcvtq_f64_f32(*(float32x2_t *)v13.f32);
    float64x2_t v16 = vcvt_hight_f64_f32(*v11);
    float64x2_t v17 = vcvtq_f64_f32(*(float32x2_t *)v11->f32);
    double v9 = v9 + v15.f64[0] + v15.f64[1] + v14.f64[0] + v14.f64[1] + v17.f64[0] + v17.f64[1] + v16.f64[0] + v16.f64[1];
    v11 += 2;
    v12 -= 8;
  }
  while (v12);
  if (v8 != (v8 & 0x7FFFFFFFFFFFFFF8))
  {
    float v10 = &v3->f32[v8 & 0x7FFFFFFFFFFFFFF8];
    do
    {
LABEL_8:
      float v18 = *v10++;
      double v9 = v9 + v18;
    }
    while (v10 != v4);
  }
  unint64_t v19 = (char *)v6 - (char *)v5 - 4;
  uint64_t v20 = (v19 >> 2) + 1;
  double v21 = 0.0;
  float32x4_t v22 = *a3;
  if (v19 < 0x1C) {
    goto LABEL_14;
  }
  float32x4_t v23 = v5 + 1;
  uint64_t v24 = v20 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    float32x4_t v25 = v23[-1];
    float64x2_t v26 = vcvt_hight_f64_f32(v25);
    float64x2_t v27 = vcvtq_f64_f32(*(float32x2_t *)v25.f32);
    float64x2_t v28 = vcvt_hight_f64_f32(*v23);
    float64x2_t v29 = vcvtq_f64_f32(*(float32x2_t *)v23->f32);
    double v21 = v21 + v27.f64[0] + v27.f64[1] + v26.f64[0] + v26.f64[1] + v29.f64[0] + v29.f64[1] + v28.f64[0] + v28.f64[1];
    v23 += 2;
    v24 -= 8;
  }
  while (v24);
  if (v20 != (v20 & 0x7FFFFFFFFFFFFFF8))
  {
    float32x4_t v22 = &v5->f32[v20 & 0x7FFFFFFFFFFFFFF8];
    do
    {
LABEL_14:
      float v30 = *v22++;
      double v21 = v21 + v30;
    }
    while (v22 != v6);
  }
  unint64_t v31 = ((char *)v4 - (char *)v3) >> 2;
  double v32 = 0.0;
  float32x4_t v33 = (float *)v3;
  if (v7 < 0x1C) {
    goto LABEL_20;
  }
  float32x4_t v34 = v3 + 1;
  uint64_t v35 = v8 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    float32x4_t v36 = v34[-1];
    float64x2_t v37 = vcvt_hight_f64_f32(v36);
    float64x2_t v38 = vcvtq_f64_f32(*(float32x2_t *)v36.f32);
    float64x2_t v39 = vcvt_hight_f64_f32(*v34);
    float64x2_t v40 = vcvtq_f64_f32(*(float32x2_t *)v34->f32);
    double v32 = v32 + v38.f64[0] + v38.f64[1] + v37.f64[0] + v37.f64[1] + v40.f64[0] + v40.f64[1] + v39.f64[0] + v39.f64[1];
    v34 += 2;
    v35 -= 8;
  }
  while (v35);
  if (v8 != (v8 & 0x7FFFFFFFFFFFFFF8))
  {
    float32x4_t v33 = &v3->f32[v8 & 0x7FFFFFFFFFFFFFF8];
    do
    {
LABEL_20:
      float v41 = *v33++;
      double v32 = v32 + v41;
    }
    while (v33 != v4);
  }
  double v42 = (double)v31;
  double v43 = 0.0;
  float32x4_t v44 = (float *)v3;
  if (v7 >= 0x1C)
  {
    int32x4_t v45 = v3 + 1;
    uint64_t v46 = v8 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      float32x4_t v47 = v45[-1];
      float64x2_t v48 = vcvt_hight_f64_f32(v47);
      float64x2_t v49 = vcvtq_f64_f32(*(float32x2_t *)v47.f32);
      float64x2_t v50 = vcvt_hight_f64_f32(*v45);
      float64x2_t v51 = vcvtq_f64_f32(*(float32x2_t *)v45->f32);
      double v52 = v43 + v49.f64[0] + v49.f64[1] + v48.f64[0] + v48.f64[1] + v51.f64[0] + v51.f64[1] + v50.f64[0];
      double v43 = v52 + v50.f64[1];
      v45 += 2;
      v46 -= 8;
    }
    while (v46);
    if (v8 == (v8 & 0x7FFFFFFFFFFFFFF8)) {
      goto LABEL_27;
    }
    float32x4_t v44 = &v3->f32[v8 & 0x7FFFFFFFFFFFFFF8];
  }
  do
  {
    float v53 = *v44++;
    double v52 = v53;
    double v43 = v43 + v53;
  }
  while (v44 != v4);
LABEL_27:
  *(float *)&double v52 = v32 / v42;
  *(float *)&double v43 = v43 / v42;
  if (v31 <= 1) {
    unint64_t v54 = 1;
  }
  else {
    unint64_t v54 = ((char *)v4 - (char *)v3) >> 2;
  }
  float v55 = 0.0;
  if (v54 < 0xC)
  {
    unint64_t v56 = 0;
    int v57 = 0;
LABEL_38:
    unsigned int v65 = v57 + 1;
    do
    {
      float v55 = v55 + (float)((float)(v3->f32[v56] - *(float *)&v52) * (float)(v3->f32[v56] - *(float *)&v43));
      unint64_t v56 = v65++;
    }
    while (v31 > v56);
    goto LABEL_40;
  }
  int v57 = 0;
  unint64_t v56 = 0;
  if (!v54) {
    goto LABEL_38;
  }
  if ((v54 - 1) >> 32) {
    goto LABEL_38;
  }
  float32x4_t v59 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v52, 0);
  unint64_t v56 = v54 & 0xFFFFFFFFFFFFFFF8;
  float32x4_t v60 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v43, 0);
  int32x4_t v61 = v3 + 1;
  unint64_t v62 = v54 & 0xFFFFFFFFFFFFFFF8;
  do
  {
    float32x4_t v63 = vmulq_f32(vsubq_f32(v61[-1], v59), vsubq_f32(v61[-1], v60));
    float32x4_t v64 = vmulq_f32(vsubq_f32(*v61, v59), vsubq_f32(*v61, v60));
    float v55 = (float)((float)((float)((float)((float)((float)((float)(v55 + v63.f32[0]) + v63.f32[1]) + v63.f32[2])
                                        + v63.f32[3])
                                + v64.f32[0])
                        + v64.f32[1])
                + v64.f32[2])
        + v64.f32[3];
    v61 += 2;
    v62 -= 8;
  }
  while (v62);
  int v57 = v54 & 0xFFFFFFF8;
  if (v54 != v56) {
    goto LABEL_38;
  }
LABEL_40:
  double v66 = (double)(unint64_t)(((char *)v6 - (char *)v5) >> 2);
  double v67 = 0.0;
  unsigned int v68 = (float *)v3;
  if (v7 < 0x1C) {
    goto LABEL_45;
  }
  unsigned int v69 = v3 + 1;
  uint64_t v70 = v8 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    float32x4_t v71 = v69[-1];
    float64x2_t v72 = vcvt_hight_f64_f32(v71);
    float64x2_t v73 = vcvtq_f64_f32(*(float32x2_t *)v71.f32);
    float64x2_t v74 = vcvt_hight_f64_f32(*v69);
    float64x2_t v75 = vcvtq_f64_f32(*(float32x2_t *)v69->f32);
    double v67 = v67 + v73.f64[0] + v73.f64[1] + v72.f64[0] + v72.f64[1] + v75.f64[0] + v75.f64[1] + v74.f64[0] + v74.f64[1];
    v69 += 2;
    v70 -= 8;
  }
  while (v70);
  if (v8 != (v8 & 0x7FFFFFFFFFFFFFF8))
  {
    unsigned int v68 = &v3->f32[v8 & 0x7FFFFFFFFFFFFFF8];
    do
    {
LABEL_45:
      float v76 = *v68++;
      double v67 = v67 + v76;
    }
    while (v68 != v4);
  }
  double v77 = v9 / v42;
  float v78 = (float)(v31 - 1);
  double v79 = 0.0;
  float v80 = (float *)v5;
  double v81 = v21 / v66;
  if (v19 < 0x1C) {
    goto LABEL_51;
  }
  float32x4_t v82 = v5 + 1;
  uint64_t v83 = v20 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    float32x4_t v84 = v82[-1];
    float64x2_t v85 = vcvt_hight_f64_f32(v84);
    float64x2_t v86 = vcvtq_f64_f32(*(float32x2_t *)v84.f32);
    float64x2_t v87 = vcvt_hight_f64_f32(*v82);
    float64x2_t v88 = vcvtq_f64_f32(*(float32x2_t *)v82->f32);
    double v79 = v79 + v86.f64[0] + v86.f64[1] + v85.f64[0] + v85.f64[1] + v88.f64[0] + v88.f64[1] + v87.f64[0] + v87.f64[1];
    v82 += 2;
    v83 -= 8;
  }
  while (v83);
  if (v20 != (v20 & 0x7FFFFFFFFFFFFFF8))
  {
    float v80 = &v5->f32[v20 & 0x7FFFFFFFFFFFFFF8];
    do
    {
LABEL_51:
      float v89 = *v80++;
      double v79 = v79 + v89;
    }
    while (v80 != v6);
  }
  float v90 = v77;
  float v91 = v81;
  *(float *)&double v67 = v67 / v42;
  *(float *)&double v66 = v79 / v66;
  float v92 = 0.0;
  float v93 = v55 / v78;
  if (v54 < 8)
  {
    unint64_t v94 = 0;
    int v95 = 0;
LABEL_59:
    unsigned int v103 = v95 + 1;
    do
    {
      float v92 = v92 + (float)((float)(v3->f32[v94] - *(float *)&v67) * (float)(v5->f32[v94] - *(float *)&v66));
      unint64_t v94 = v103++;
    }
    while (v31 > v94);
    goto LABEL_61;
  }
  int v95 = 0;
  unint64_t v94 = 0;
  if (!v54) {
    goto LABEL_59;
  }
  if ((v54 - 1) >> 32) {
    goto LABEL_59;
  }
  unint64_t v94 = v54 & 0xFFFFFFFFFFFFFFF8;
  float32x4_t v96 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v67, 0);
  float32x4_t v97 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v66, 0);
  float32x4_t v98 = v5 + 1;
  float32x4_t v99 = v3 + 1;
  unint64_t v100 = v54 & 0xFFFFFFFFFFFFFFF8;
  do
  {
    float32x4_t v101 = vmulq_f32(vsubq_f32(v99[-1], v96), vsubq_f32(v98[-1], v97));
    float32x4_t v102 = vmulq_f32(vsubq_f32(*v99, v96), vsubq_f32(*v98, v97));
    float v92 = (float)((float)((float)((float)((float)((float)((float)(v92 + v101.f32[0]) + v101.f32[1]) + v101.f32[2])
                                        + v101.f32[3])
                                + v102.f32[0])
                        + v102.f32[1])
                + v102.f32[2])
        + v102.f32[3];
    v98 += 2;
    v99 += 2;
    v100 -= 8;
  }
  while (v100);
  int v95 = v54 & 0xFFFFFFF8;
  if (v54 != v94) {
    goto LABEL_59;
  }
LABEL_61:
  float v104 = (float)(v92 / v78) / v93;
  if (v93 == 0.0) {
    float v104 = 0.0;
  }
  *(float *)(a1 + 8) = v104;
  float result = v91 - (float)(v104 * v90);
  *(float *)(a1 + 12) = result;
  return result;
}

void DisparityToDepth::RansacLine2DModel::~RansacLine2DModel(DisparityToDepth::RansacLine2DModel *this)
{
}

float DisparityToDepth::RansacLineModel::intercept(DisparityToDepth::RansacLineModel *this)
{
  return *((float *)this + 2);
}

float DisparityToDepth::RansacLineModel::slope(DisparityToDepth::RansacLineModel *this)
{
  return 1.0;
}

uint64_t DisparityToDepth::RansacLineModel::minNumOfParametersForFit(DisparityToDepth::RansacLineModel *this)
{
  return 1;
}

void DisparityToDepth::RansacLineModel::estimateX(uint64_t a1@<X0>, float **a2@<X1>, float **a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  uint64_t v5 = (char *)v3 - (char *)*a2;
  if (v3 != *a2)
  {
    if (v5 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = (float *)operator new((char *)v3 - (char *)*a2);
    double v9 = &v8[v5 >> 2];
    *a3 = v8;
    a3[1] = v8;
    a3[2] = v9;
    float v10 = v8;
    uint64_t v26 = a1;
    while (1)
    {
      float v12 = *v4 - *(float *)(a1 + 8);
      if (v10 >= v9) {
        break;
      }
      *float v10 = v12;
      float32x4_t v11 = v10 + 1;
LABEL_5:
      a3[1] = v11;
      ++v4;
      float v10 = v11;
      if (v4 == v3) {
        return;
      }
    }
    uint64_t v13 = v10 - v8;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    if (((char *)v9 - (char *)v8) >> 1 > v14) {
      unint64_t v14 = ((char *)v9 - (char *)v8) >> 1;
    }
    if ((unint64_t)((char *)v9 - (char *)v8) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15)
    {
      if (v15 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float64x2_t v16 = operator new(4 * v15);
    }
    else
    {
      float64x2_t v16 = 0;
    }
    float64x2_t v17 = (float *)&v16[4 * v13];
    float *v17 = v12;
    float32x4_t v11 = v17 + 1;
    if (v10 == v8) {
      goto LABEL_21;
    }
    unint64_t v18 = (char *)(v10 - 1) - (char *)v8;
    if (v18 < 0xBC)
    {
      unint64_t v19 = v10;
      goto LABEL_20;
    }
    if (&v16[(char *)v10 - (char *)v8 - 4 - (v18 & 0xFFFFFFFFFFFFFFFCLL)] > &v16[(char *)v10 - (char *)v8 - 4])
    {
      unint64_t v19 = v10;
    }
    else
    {
      if ((float *)((char *)v10 - (v18 & 0xFFFFFFFFFFFFFFFCLL) - 4) <= v10 - 1)
      {
        if ((unint64_t)((char *)v8 - v16) < 0x20)
        {
          unint64_t v19 = v10;
          goto LABEL_20;
        }
        uint64_t v21 = (v18 >> 2) + 1;
        unint64_t v19 = &v10[-(v21 & 0x7FFFFFFFFFFFFFF8)];
        float32x4_t v22 = &v16[4 * v13 - 16];
        float32x4_t v23 = v10 - 4;
        uint64_t v24 = v21 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v25 = *(_OWORD *)v23;
          *(v22 - 1) = *((_OWORD *)v23 - 1);
          _OWORD *v22 = v25;
          v22 -= 2;
          v23 -= 8;
          v24 -= 8;
        }
        while (v24);
        v17 -= v21 & 0x7FFFFFFFFFFFFFF8;
        if (v21 != (v21 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_20;
        }
LABEL_21:
        double v9 = (float *)&v16[4 * v15];
        *a3 = v17;
        a3[1] = v11;
        a3[2] = v9;
        if (v8) {
          operator delete(v8);
        }
        uint64_t v8 = v17;
        a1 = v26;
        goto LABEL_5;
      }
      unint64_t v19 = v10;
    }
    do
    {
LABEL_20:
      int v20 = *((_DWORD *)v19-- - 1);
      *((_DWORD *)v17-- - 1) = v20;
    }
    while (v19 != v8);
    goto LABEL_21;
  }
}

void sub_215F5ECBC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void DisparityToDepth::RansacLineModel::estimateY(uint64_t a1@<X0>, float **a2@<X1>, float **a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  uint64_t v5 = (char *)v3 - (char *)*a2;
  if (v3 != *a2)
  {
    if (v5 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = (float *)operator new((char *)v3 - (char *)*a2);
    double v9 = &v8[v5 >> 2];
    *a3 = v8;
    a3[1] = v8;
    a3[2] = v9;
    float v10 = v8;
    uint64_t v26 = a1;
    while (1)
    {
      float v12 = *v4 + *(float *)(a1 + 8);
      if (v10 >= v9) {
        break;
      }
      *float v10 = v12;
      float32x4_t v11 = v10 + 1;
LABEL_5:
      a3[1] = v11;
      ++v4;
      float v10 = v11;
      if (v4 == v3) {
        return;
      }
    }
    uint64_t v13 = v10 - v8;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    if (((char *)v9 - (char *)v8) >> 1 > v14) {
      unint64_t v14 = ((char *)v9 - (char *)v8) >> 1;
    }
    if ((unint64_t)((char *)v9 - (char *)v8) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15)
    {
      if (v15 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float64x2_t v16 = operator new(4 * v15);
    }
    else
    {
      float64x2_t v16 = 0;
    }
    float64x2_t v17 = (float *)&v16[4 * v13];
    float *v17 = v12;
    float32x4_t v11 = v17 + 1;
    if (v10 == v8) {
      goto LABEL_21;
    }
    unint64_t v18 = (char *)(v10 - 1) - (char *)v8;
    if (v18 < 0xBC)
    {
      unint64_t v19 = v10;
      goto LABEL_20;
    }
    if (&v16[(char *)v10 - (char *)v8 - 4 - (v18 & 0xFFFFFFFFFFFFFFFCLL)] > &v16[(char *)v10 - (char *)v8 - 4])
    {
      unint64_t v19 = v10;
    }
    else
    {
      if ((float *)((char *)v10 - (v18 & 0xFFFFFFFFFFFFFFFCLL) - 4) <= v10 - 1)
      {
        if ((unint64_t)((char *)v8 - v16) < 0x20)
        {
          unint64_t v19 = v10;
          goto LABEL_20;
        }
        uint64_t v21 = (v18 >> 2) + 1;
        unint64_t v19 = &v10[-(v21 & 0x7FFFFFFFFFFFFFF8)];
        float32x4_t v22 = &v16[4 * v13 - 16];
        float32x4_t v23 = v10 - 4;
        uint64_t v24 = v21 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v25 = *(_OWORD *)v23;
          *(v22 - 1) = *((_OWORD *)v23 - 1);
          _OWORD *v22 = v25;
          v22 -= 2;
          v23 -= 8;
          v24 -= 8;
        }
        while (v24);
        v17 -= v21 & 0x7FFFFFFFFFFFFFF8;
        if (v21 != (v21 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_20;
        }
LABEL_21:
        double v9 = (float *)&v16[4 * v15];
        *a3 = v17;
        a3[1] = v11;
        a3[2] = v9;
        if (v8) {
          operator delete(v8);
        }
        uint64_t v8 = v17;
        a1 = v26;
        goto LABEL_5;
      }
      unint64_t v19 = v10;
    }
    do
    {
LABEL_20:
      int v20 = *((_DWORD *)v19-- - 1);
      *((_DWORD *)v17-- - 1) = v20;
    }
    while (v19 != v8);
    goto LABEL_21;
  }
}

void sub_215F5EF08(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float DisparityToDepth::RansacLineModel::fit(uint64_t a1, float **a2, float **a3)
{
  uint64_t v3 = *a3;
  uint64_t v4 = a3[1];
  float v5 = 0.0;
  float v6 = 0.0;
  if (*a3 != v4)
  {
    uint64_t v7 = (char *)v4 - (char *)v3;
    unint64_t v8 = (char *)v4 - (char *)v3 - 4;
    if (v8 >= 0x1C)
    {
      uint64_t v10 = (v8 >> 2) + 1;
      float32x4_t v11 = (float32x4_t *)(v3 + 4);
      double v9 = 0.0;
      uint64_t v12 = v10 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v13 = v11[-1];
        float64x2_t v14 = vcvt_hight_f64_f32(v13);
        float64x2_t v15 = vcvtq_f64_f32(*(float32x2_t *)v13.f32);
        float64x2_t v16 = vcvt_hight_f64_f32(*v11);
        float64x2_t v17 = vcvtq_f64_f32(*(float32x2_t *)v11->f32);
        double v9 = v9 + v15.f64[0] + v15.f64[1] + v14.f64[0] + v14.f64[1] + v17.f64[0] + v17.f64[1] + v16.f64[0] + v16.f64[1];
        v11 += 2;
        v12 -= 8;
      }
      while (v12);
      if (v10 == (v10 & 0x7FFFFFFFFFFFFFF8)) {
        goto LABEL_9;
      }
      v3 += v10 & 0x7FFFFFFFFFFFFFF8;
    }
    else
    {
      double v9 = 0.0;
    }
    do
    {
      float v18 = *v3++;
      double v9 = v9 + v18;
    }
    while (v3 != v4);
LABEL_9:
    float v6 = v9 / (double)(unint64_t)(v7 >> 2);
  }
  unint64_t v19 = *a2;
  int v20 = a2[1];
  if (*a2 != v20)
  {
    uint64_t v21 = (char *)v20 - (char *)v19;
    unint64_t v22 = (char *)v20 - (char *)v19 - 4;
    if (v22 >= 0x1C)
    {
      uint64_t v24 = (v22 >> 2) + 1;
      long long v25 = (float32x4_t *)(v19 + 4);
      double v23 = 0.0;
      uint64_t v26 = v24 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v27 = v25[-1];
        float64x2_t v28 = vcvt_hight_f64_f32(v27);
        float64x2_t v29 = vcvtq_f64_f32(*(float32x2_t *)v27.f32);
        float64x2_t v30 = vcvt_hight_f64_f32(*v25);
        float64x2_t v31 = vcvtq_f64_f32(*(float32x2_t *)v25->f32);
        double v23 = v23
            + v29.f64[0]
            + v29.f64[1]
            + v28.f64[0]
            + v28.f64[1]
            + v31.f64[0]
            + v31.f64[1]
            + v30.f64[0]
            + v30.f64[1];
        v25 += 2;
        v26 -= 8;
      }
      while (v26);
      if (v24 == (v24 & 0x7FFFFFFFFFFFFFF8)) {
        goto LABEL_18;
      }
      v19 += v24 & 0x7FFFFFFFFFFFFFF8;
    }
    else
    {
      double v23 = 0.0;
    }
    do
    {
      float v32 = *v19++;
      double v23 = v23 + v32;
    }
    while (v19 != v20);
LABEL_18:
    float v5 = v23 / (double)(unint64_t)(v21 >> 2);
  }
  float result = v6 - v5;
  *(float *)(a1 + 8) = result;
  return result;
}

void DisparityToDepth::RansacLineModel::~RansacLineModel(DisparityToDepth::RansacLineModel *this)
{
}

void DisparityToDepth::DisparityToDepthFitEstimator::DisparityToDepthFitEstimator(uint64_t a1, uint64_t a2, double a3, double a4, double a5, float a6, uint64_t a7, uint64_t a8)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a8;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(float *)(a1 + 56) = a6;
  if (*(unsigned char *)(a2 + 12)) {
    operator new();
  }
  operator new();
}

void sub_215F5F248(_Unwind_Exception *a1)
{
  DisparityToDepth::WorldPointsContainer::~WorldPointsContainer(v1);
  _Unwind_Resume(a1);
}

void DisparityToDepth::WorldPointsContainer::~WorldPointsContainer(DisparityToDepth::WorldPointsContainer *this)
{
  long long v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v3;
    operator delete(v3);
  }
}

uint64_t DisparityToDepth::WorldPointsContainer::WorldPointsContainer(uint64_t this, uint64_t a2, float a3)
{
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = a2;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 32) = 0;
  *(float *)(this + 56) = a3;
  return this;
}

{
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = a2;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 32) = 0;
  *(float *)(this + 56) = a3;
  return this;
}

void DisparityToDepth::WorldPointsContainer::push(DisparityToDepth::WorldPointsContainer *this, ADDisparityToDepthFitWorldPoint *a2, unint64_t a3)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  double v43 = 0;
  float32x4_t v44 = 0;
  int32x4_t v45 = 0;
  if (a3)
  {
    unint64_t v4 = a3;
    if (a3 >> 59) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    float v6 = (char *)operator new(32 * a3);
    double v43 = v6;
    float32x4_t v44 = v6;
    int32x4_t v45 = &v6[32 * v4];
    uint64_t v7 = *(void **)this;
    *((void *)this + 1) = *(void *)this;
    if (v4 > (uint64_t)(*((void *)this + 2) - (void)v7) >> 5)
    {
      unint64_t v8 = (char *)operator new(32 * v4);
      *(void *)this = v8;
      *((void *)this + 1) = v8;
      *((void *)this + 2) = &v8[32 * v4];
      if (v7) {
        operator delete(v7);
      }
    }
    float v41 = a2;
    double v42 = &v6[32 * v4];
    uint64_t v9 = 0;
    unsigned int v10 = 0;
    float32x4_t v11 = v6;
    unint64_t v40 = v4;
    do
    {
      float32x4_t v13 = &a2[4 * v9];
      float64x2_t v15 = (_OWORD *)*((void *)this + 1);
      unint64_t v14 = *((void *)this + 2);
      if ((unint64_t)v15 >= v14)
      {
        float v18 = *(_OWORD **)this;
        uint64_t v19 = ((uint64_t)v15 - *(void *)this) >> 5;
        unint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 59) {
          goto LABEL_56;
        }
        uint64_t v21 = v14 - (void)v18;
        if (v21 >> 4 > v20) {
          unint64_t v20 = v21 >> 4;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v22 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v22 = v20;
        }
        if (v22)
        {
          if (v22 >> 59) {
            goto LABEL_57;
          }
          double v23 = (char *)operator new(32 * v22);
        }
        else
        {
          double v23 = 0;
        }
        long long v24 = *(_OWORD *)&v13[2].var0;
        long long v25 = &v23[32 * v19];
        *(_OWORD *)long long v25 = *(_OWORD *)&v13->var0;
        *((_OWORD *)v25 + 1) = v24;
        uint64_t v26 = v25;
        if (v15 == v18)
        {
          a2 = v41;
        }
        else
        {
          a2 = v41;
          do
          {
            long long v27 = *(v15 - 1);
            *((_OWORD *)v26 - 2) = *(v15 - 2);
            *((_OWORD *)v26 - 1) = v27;
            v26 -= 32;
            v15 -= 2;
          }
          while (v15 != v18);
          float64x2_t v15 = *(_OWORD **)this;
        }
        float64x2_t v17 = v25 + 32;
        *(void *)this = v26;
        *((void *)this + 1) = v25 + 32;
        *((void *)this + 2) = &v23[32 * v22];
        if (v15) {
          operator delete(v15);
        }
        unint64_t v4 = v40;
      }
      else
      {
        long long v16 = *(_OWORD *)&v13[2].var0;
        _OWORD *v15 = *(_OWORD *)&v13->var0;
        v15[1] = v16;
        float64x2_t v17 = v15 + 2;
      }
      *((void *)this + 1) = v17;
      if (a2[4 * v9 + 2].var0 >= *((float *)this + 14))
      {
        if (v6 < v42)
        {
          long long v12 = *(_OWORD *)&v13[2].var0;
          *(_OWORD *)float v6 = *(_OWORD *)&v13->var0;
          *((_OWORD *)v6 + 1) = v12;
          v6 += 32;
        }
        else
        {
          uint64_t v28 = (v6 - v11) >> 5;
          unint64_t v29 = v28 + 1;
          if ((unint64_t)(v28 + 1) >> 59) {
LABEL_56:
          }
            std::vector<float>::__throw_length_error[abi:ne180100]();
          if ((v42 - v11) >> 4 > v29) {
            unint64_t v29 = (v42 - v11) >> 4;
          }
          if ((unint64_t)(v42 - v11) >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v30 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v29;
          }
          if (v30)
          {
            if (v30 >> 59) {
LABEL_57:
            }
              std::__throw_bad_array_new_length[abi:ne180100]();
            float64x2_t v31 = (char *)operator new(32 * v30);
            unint64_t v4 = v40;
          }
          else
          {
            float64x2_t v31 = 0;
          }
          long long v32 = *(_OWORD *)&v13[2].var0;
          float32x4_t v33 = &v31[32 * v28];
          *(_OWORD *)float32x4_t v33 = *(_OWORD *)&v13->var0;
          *((_OWORD *)v33 + 1) = v32;
          if (v6 == v11)
          {
            float32x4_t v36 = v6;
            float32x4_t v11 = &v31[32 * v28];
            a2 = v41;
          }
          else
          {
            float32x4_t v34 = &v31[32 * v28];
            a2 = v41;
            do
            {
              long long v35 = *((_OWORD *)v6 - 1);
              *((_OWORD *)v34 - 2) = *((_OWORD *)v6 - 2);
              *((_OWORD *)v34 - 1) = v35;
              v34 -= 32;
              v6 -= 32;
            }
            while (v6 != v11);
            float32x4_t v36 = v11;
            float32x4_t v11 = v34;
          }
          double v42 = &v31[32 * v30];
          float v6 = v33 + 32;
          if (v36) {
            operator delete(v36);
          }
        }
      }
      uint64_t v9 = ++v10;
    }
    while (v10 < v4);
    float32x4_t v44 = v6;
    float64x2_t v37 = v42;
  }
  else
  {
    float32x4_t v11 = 0;
    float64x2_t v37 = 0;
    *((void *)this + 1) = *(void *)this;
  }
  int32x4_t v45 = v37;
  double v43 = v11;
  DisparityToDepth::WorldPointsLRU::push((void *)this + 3, (uint64_t *)&v43);
  if (ADDebugUtilsADVerboseLogsEnabled && os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v38 = (uint64_t)(*((void *)this + 1) - *(void *)this) >> 5;
    uint64_t v39 = (uint64_t)(*((void *)this + 5) - *((void *)this + 4)) >> 5;
    *(_DWORD *)buf = 134218240;
    uint64_t v47 = v38;
    __int16 v48 = 2048;
    uint64_t v49 = v39;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "DisparityToDepth [Verbose] WorldPointsContainer amount of pushed points %lu amount of retained points %lu", buf, 0x16u);
  }
  if (v11)
  {
    float32x4_t v44 = v11;
    operator delete(v11);
  }
}

void sub_215F5F670(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void DisparityToDepth::WorldPointsLRU::push(void *a1, uint64_t *a2)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  int64x2_t v4 = 0uLL;
  *(_OWORD *)float32x4_t v44 = 0u;
  *(_OWORD *)__p = 0u;
  int v46 = 1065353216;
  unint64_t v5 = *a1;
  if (*a1)
  {
    if (v5 >> 59) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    float v6 = (char *)operator new(32 * v5);
    unint64_t v5 = (unint64_t)&v6[32 * v5];
    int64x2_t v4 = vdupq_n_s64((unint64_t)v6);
  }
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  if (*a2 != v8)
  {
    while (1)
    {
      uint64_t v9 = (_OWORD *)v4.i64[1];
      unsigned int v10 = (_OWORD *)v4.i64[0];
      uint64_t v11 = (v4.i64[1] - v4.i64[0]) >> 5;
      if (v11 == *a1) {
        goto LABEL_29;
      }
      int64x2_t v41 = v4;
      if (std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)v44, *(_DWORD *)(v7 + 20), *(_DWORD *)(v7 + 20)))break; {
      int64x2_t v4 = v41;
      }
LABEL_7:
      v7 += 32;
      if (v7 == v8) {
        goto LABEL_29;
      }
    }
    if ((unint64_t)v9 >= v5)
    {
      unint64_t v14 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 59) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      if ((uint64_t)(v5 - (void)v10) >> 4 > v14) {
        unint64_t v14 = (uint64_t)(v5 - (void)v10) >> 4;
      }
      if (v5 - (unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v15 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v14;
      }
      if (v15)
      {
        if (v15 >> 59) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        long long v16 = (char *)operator new(32 * v15);
      }
      else
      {
        long long v16 = 0;
      }
      long long v17 = *(_OWORD *)(v7 + 16);
      float v18 = &v16[32 * v11];
      *(_OWORD *)float v18 = *(_OWORD *)v7;
      *((_OWORD *)v18 + 1) = v17;
      uint64_t v19 = v18;
      if (v9 != v10)
      {
        do
        {
          long long v20 = *(v9 - 1);
          *((_OWORD *)v19 - 2) = *(v9 - 2);
          *((_OWORD *)v19 - 1) = v20;
          v19 -= 32;
          v9 -= 2;
        }
        while (v9 != v10);
        uint64_t v9 = v10;
      }
      unint64_t v5 = (unint64_t)&v16[32 * v15];
      float32x4_t v13 = v18 + 32;
      v4.i64[0] = (uint64_t)v19;
      if (!v9) {
        goto LABEL_28;
      }
      v41.i64[0] = (uint64_t)v19;
      operator delete(v9);
    }
    else
    {
      long long v12 = *(_OWORD *)(v7 + 16);
      _OWORD *v9 = *(_OWORD *)v7;
      v9[1] = v12;
      float32x4_t v13 = v9 + 2;
    }
    v4.i64[0] = v41.i64[0];
LABEL_28:
    v4.i64[1] = (uint64_t)v13;
    goto LABEL_7;
  }
LABEL_29:
  uint64_t v22 = a1[1];
  uint64_t v23 = a1[2];
  uint64_t v21 = (void **)(a1 + 1);
  if (v22 != v23)
  {
    while (1)
    {
      long long v24 = (_OWORD *)v4.i64[1];
      long long v25 = (_OWORD *)v4.i64[0];
      uint64_t v26 = (v4.i64[1] - v4.i64[0]) >> 5;
      if (v26 == *a1) {
        goto LABEL_54;
      }
      int64x2_t v42 = v4;
      if (std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)v44, *(_DWORD *)(v22 + 20), *(_DWORD *)(v22 + 20)))break; {
      int64x2_t v4 = v42;
      }
LABEL_32:
      v22 += 32;
      if (v22 == v23) {
        goto LABEL_54;
      }
    }
    if ((unint64_t)v24 >= v5)
    {
      unint64_t v29 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 59) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      if ((uint64_t)(v5 - (void)v25) >> 4 > v29) {
        unint64_t v29 = (uint64_t)(v5 - (void)v25) >> 4;
      }
      if (v5 - (unint64_t)v25 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v30 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v30 = v29;
      }
      if (v30)
      {
        if (v30 >> 59) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        float64x2_t v31 = (char *)operator new(32 * v30);
      }
      else
      {
        float64x2_t v31 = 0;
      }
      long long v32 = *(_OWORD *)(v22 + 16);
      float32x4_t v33 = &v31[32 * v26];
      *(_OWORD *)float32x4_t v33 = *(_OWORD *)v22;
      *((_OWORD *)v33 + 1) = v32;
      float32x4_t v34 = v33;
      if (v24 != v25)
      {
        do
        {
          long long v35 = *(v24 - 1);
          *((_OWORD *)v34 - 2) = *(v24 - 2);
          *((_OWORD *)v34 - 1) = v35;
          v34 -= 32;
          v24 -= 2;
        }
        while (v24 != v25);
        long long v24 = v25;
      }
      unint64_t v5 = (unint64_t)&v31[32 * v30];
      uint64_t v28 = v33 + 32;
      v4.i64[0] = (uint64_t)v34;
      if (!v24) {
        goto LABEL_53;
      }
      v42.i64[0] = (uint64_t)v34;
      operator delete(v24);
    }
    else
    {
      long long v27 = *(_OWORD *)(v22 + 16);
      *long long v24 = *(_OWORD *)v22;
      v24[1] = v27;
      uint64_t v28 = v24 + 2;
    }
    v4.i64[0] = v42.i64[0];
LABEL_53:
    v4.i64[1] = (uint64_t)v28;
    goto LABEL_32;
  }
LABEL_54:
  int64x2_t v43 = v4;
  if (ADDebugUtilsADVerboseLogsEnabled && os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v36 = (uint64_t)(a1[2] - a1[1]) >> 5;
    *(_DWORD *)buf = 134218240;
    uint64_t v48 = v36;
    __int16 v49 = 2048;
    uint64_t v50 = (v43.i64[1] - v43.i64[0]) >> 5;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "DisparityToDepth [Verbose] WorldPointsLRU amount of points before push %lu new amount of points %lu", buf, 0x16u);
  }
  float64x2_t v37 = *v21;
  if (*v21)
  {
    a1[2] = v37;
    operator delete(v37);
    void *v21 = 0;
    a1[2] = 0;
    a1[3] = 0;
  }
  *(int64x2_t *)(a1 + 1) = v43;
  a1[3] = v5;
  uint64_t v38 = __p[0];
  if (__p[0])
  {
    do
    {
      uint64_t v39 = (void *)*v38;
      operator delete(v38);
      uint64_t v38 = v39;
    }
    while (v39);
  }
  unint64_t v40 = v44[0];
  v44[0] = 0;
  if (v40) {
    operator delete(v40);
  }
}

void sub_215F5FA60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::unordered_set<int>::~unordered_set[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(float *a1, int a2, int a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unsigned int v10 = *v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return 0;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_23;
            }
            unsigned int v10 = (uint64_t *)*v10;
            if (!v10) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return 0;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unsigned int v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_23:
  unint64_t v14 = operator new(0x18uLL);
  void *v14 = 0;
  v14[1] = v6;
  *((_DWORD *)v14 + 4) = a3;
  float v15 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v16 = a1[8];
  if (!v7 || (float)(v16 * (float)v7) < v15)
  {
    BOOL v17 = 1;
    if (v7 >= 3) {
      BOOL v17 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v7);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t prime = v19;
    }
    else {
      size_t prime = v18;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_60;
      }
      unint64_t v32 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (prime <= v32) {
        size_t prime = v32;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
LABEL_60:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v6) {
            unint64_t v3 = v6 % v7;
          }
          else {
            unint64_t v3 = v6;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v6;
        }
        goto LABEL_73;
      }
      if (!prime)
      {
        int64x2_t v41 = *(void **)a1;
        *(void *)a1 = 0;
        if (v41) {
          operator delete(v41);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_60;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v21 = operator new(8 * prime);
    uint64_t v22 = *(void **)a1;
    *(void *)a1 = v21;
    if (v22) {
      operator delete(v22);
    }
    uint64_t v23 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v23++) = 0;
    while (prime != v23);
    long long v25 = (uint64_t *)(a1 + 4);
    long long v24 = (void *)*((void *)a1 + 2);
    if (!v24)
    {
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    size_t v26 = v24[1];
    size_t v27 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v28 = v26 & v27;
      *(void *)(*(void *)a1 + 8 * v28) = v25;
      for (uint64_t i = (void *)*v24; *v24; uint64_t i = (void *)*v24)
      {
        size_t v30 = i[1] & v27;
        if (v30 == v28)
        {
          long long v24 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v30))
        {
          *long long v24 = *i;
          uint64_t v31 = 8 * v30;
          *uint64_t i = **(void **)(*(void *)a1 + v31);
          **(void **)(*(void *)a1 + v31) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v30) = v24;
          long long v24 = i;
          size_t v28 = v30;
        }
      }
      goto LABEL_59;
    }
    if (v26 >= prime) {
      v26 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v26) = v25;
    long long v35 = (void *)*v24;
    if (!*v24) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v37 = v35[1];
      if (v37 >= prime) {
        v37 %= prime;
      }
      if (v37 != v26)
      {
        if (!*(void *)(*(void *)a1 + 8 * v37))
        {
          *(void *)(*(void *)a1 + 8 * v37) = v24;
          goto LABEL_64;
        }
        *long long v24 = *v35;
        uint64_t v36 = 8 * v37;
        *long long v35 = **(void **)(*(void *)a1 + v36);
        **(void **)(*(void *)a1 + v36) = v35;
        long long v35 = v24;
      }
      size_t v37 = v26;
LABEL_64:
      long long v24 = v35;
      long long v35 = (void *)*v35;
      size_t v26 = v37;
      if (!v35) {
        goto LABEL_59;
      }
    }
  }
LABEL_73:
  uint64_t v38 = *(void **)a1;
  uint64_t v39 = *(void **)(*(void *)a1 + 8 * v3);
  if (v39)
  {
    void *v14 = *v39;
LABEL_81:
    *uint64_t v39 = v14;
    goto LABEL_82;
  }
  void *v14 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v14;
  v38[v3] = a1 + 4;
  if (*v14)
  {
    unint64_t v40 = *(void *)(*v14 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v40 >= v7) {
        v40 %= v7;
      }
    }
    else
    {
      v40 &= v7 - 1;
    }
    uint64_t v39 = (void *)(*(void *)a1 + 8 * v40);
    goto LABEL_81;
  }
LABEL_82:
  ++*((void *)a1 + 3);
  return 1;
}

void sub_215F5FF00(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_set<int>::~unordered_set[abi:ne180100](uint64_t a1)
{
  long long v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      operator delete(v2);
      long long v2 = v3;
    }
    while (v3);
  }
  int64x2_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void DisparityToDepth::DisparityToDepthFitEstimator::estimate(DisparityToDepth::WorldPointsContainer *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, double a5@<X4>, unint64_t a6@<X5>, unint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v169 = *MEMORY[0x263EF8340];
  long long v156 = 0;
  double v157 = 0;
  double v158 = 0;
  long long v153 = 0;
  signed int v154 = 0;
  long long v155 = 0;
  DisparityToDepth::WorldPointsContainer::vector(a1, (char **)&v151);
  if (!a6 || !a7)
  {
    _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4ELm5EEEEJbffNS_6vectorIfNS_9allocatorIfEEEES6_NS3_I31ADDisparityToDepthFitWorldPointNS4_IS7_EEEEEEC2B8ne180100IJLm0ELm1ELm2ELm3ELm4ELm5EEJbffS6_S6_S9_EJEJEJbiiRS6_SC_RKS9_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSG_IJDpT2_EEEDpOT3_(a9, 0, 0, 0, (uint64_t)&v156, (uint64_t)&v153, (uint64_t)&v151);
    goto LABEL_162;
  }
  uint64_t v148 = a3;
  unint64_t v18 = v151;
  BOOL v17 = v152;
  uint64_t v19 = v152 - (unsigned char *)v151;
  uint64_t v143 = a9;
  uint64_t v144 = a1;
  unint64_t v145 = a4;
  unint64_t v146 = *(void *)&a5;
  unint64_t v141 = a6;
  unint64_t v142 = a7;
  if (v152 == v151)
  {
    long long v20 = 0;
    uint64_t v23 = 0;
  }
  else
  {
    if (v19 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    long long v20 = (char *)operator new((unint64_t)v19 >> 1);
    uint64_t v21 = &v20[16 * (v19 >> 5)];
    uint64_t v22 = v20;
    do
    {
      if (v22 < v21)
      {
        *(_OWORD *)uint64_t v22 = *v18;
        uint64_t v23 = v22 + 16;
      }
      else
      {
        uint64_t v24 = (v22 - v20) >> 4;
        unint64_t v25 = v24 + 1;
        if ((unint64_t)(v24 + 1) >> 60) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        if ((v21 - v20) >> 3 > v25) {
          unint64_t v25 = (v21 - v20) >> 3;
        }
        if ((unint64_t)(v21 - v20) >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v26 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v26 = v25;
        }
        if (v26)
        {
          if (v26 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          size_t v27 = (char *)operator new(16 * v26);
        }
        else
        {
          size_t v27 = 0;
        }
        size_t v28 = &v27[16 * v24];
        uint64_t v21 = &v27[16 * v26];
        *(_OWORD *)size_t v28 = *v18;
        uint64_t v23 = v28 + 16;
        if (v22 == v20) {
          goto LABEL_22;
        }
        do
        {
          long long v29 = *((_OWORD *)v22 - 1);
          v22 -= 16;
          *((_OWORD *)v28 - 1) = v29;
          v28 -= 16;
        }
        while (v22 != v20);
        if (v20) {
LABEL_22:
        }
          operator delete(v20);
        long long v20 = v28;
      }
      v18 += 2;
      uint64_t v22 = v23;
    }
    while (v18 != v17);
  }
  (*(void (**)(void **__return_ptr, uint64_t, char *, int64_t))(*(void *)a8 + 16))(&__p, a8, v20, (v23 - v20) >> 4);
  int64_t v31 = v145;
  int64_t v30 = *(void *)&a5;
  if (ADDebugUtilsADVerboseLogsEnabled && os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134219008;
    uint64_t v160 = v148;
    __int16 v161 = 2048;
    double v162 = *(double *)&v145;
    __int16 v163 = 2048;
    double v164 = a5;
    __int16 v165 = 2048;
    unint64_t v166 = v141;
    __int16 v167 = 2048;
    unint64_t v168 = a7;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "DisparityToDepth [Verbose] estiamte with disparityCount: %lu disparityWidth: %lu disparityHeight: %lu rgbWidth: %lu rgbHeight: %lu", buf, 0x34u);
  }
  uint8x8_t v33 = (float *)__p;
  unint64_t v32 = v150;
  unint64_t v34 = (char *)v150 - (unsigned char *)__p;
  unint64_t v35 = ((char *)v150 - (unsigned char *)__p) >> 4;
  uint64_t v36 = (float *)v156;
  if (v35 > (v158 - (unsigned char *)v156) >> 2)
  {
    if ((v34 & 0x8000000000000000) != 0) {
      goto LABEL_173;
    }
    size_t v37 = v157;
    uint64_t v38 = (char *)operator new(v34 >> 2);
    uint64_t v39 = (char *)v37 - (char *)v36;
    unint64_t v40 = (float *)&v38[((char *)v37 - (char *)v36) & 0xFFFFFFFFFFFFFFFCLL];
    int64x2_t v41 = (char *)v40;
    if (v37 == v36) {
      goto LABEL_39;
    }
    if ((unint64_t)(v39 - 4) >= 0x2C)
    {
      int64x2_t v41 = &v38[((char *)v37 - (char *)v36) & 0xFFFFFFFFFFFFFFFCLL];
      if ((unint64_t)((char *)v37 - &v38[v39 & 0xFFFFFFFFFFFFFFFCLL]) >= 0x20)
      {
        uint64_t v42 = v39 >> 2;
        unint64_t v43 = ((unint64_t)(v39 - 4) >> 2) + 1;
        float32x4_t v44 = &v38[4 * v42 - 16];
        int32x4_t v45 = v37 - 4;
        uint64_t v46 = v43 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v47 = *(_OWORD *)v45;
          *((_OWORD *)v44 - 1) = *((_OWORD *)v45 - 1);
          *(_OWORD *)float32x4_t v44 = v47;
          v44 -= 32;
          v45 -= 8;
          v46 -= 8;
        }
        while (v46);
        int64x2_t v41 = (char *)&v40[-(v43 & 0x7FFFFFFFFFFFFFF8)];
        v37 -= v43 & 0x7FFFFFFFFFFFFFF8;
        if (v43 == (v43 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_39:
          long long v156 = v41;
          double v157 = v40;
          double v158 = &v38[4 * v35];
          if (v36)
          {
            operator delete(v36);
            uint8x8_t v33 = (float *)__p;
            unint64_t v32 = v150;
            unint64_t v34 = (char *)v150 - (unsigned char *)__p;
            unint64_t v35 = ((char *)v150 - (unsigned char *)__p) >> 4;
          }
          goto LABEL_41;
        }
      }
    }
    else
    {
      int64x2_t v41 = &v38[((char *)v37 - (char *)v36) & 0xFFFFFFFFFFFFFFFCLL];
    }
    do
    {
      int v48 = *((_DWORD *)v37-- - 1);
      *((_DWORD *)v41 - 1) = v48;
      v41 -= 4;
    }
    while (v37 != v36);
    goto LABEL_39;
  }
LABEL_41:
  __int16 v49 = (char *)v153;
  if (v35 <= (v155 - (unsigned char *)v153) >> 2) {
    goto LABEL_53;
  }
  if ((v34 & 0x8000000000000000) != 0) {
LABEL_173:
  }
    std::vector<float>::__throw_length_error[abi:ne180100]();
  uint64_t v50 = v154;
  uint64_t v51 = (char *)operator new(v34 >> 2);
  uint64_t v52 = v50 - v49;
  float v53 = &v51[(v50 - v49) & 0xFFFFFFFFFFFFFFFCLL];
  unint64_t v54 = v53;
  if (v50 == v49) {
    goto LABEL_51;
  }
  if ((unint64_t)(v52 - 4) < 0x2C)
  {
    unint64_t v54 = &v51[(v50 - v49) & 0xFFFFFFFFFFFFFFFCLL];
    do
    {
LABEL_50:
      int v61 = *((_DWORD *)v50 - 1);
      v50 -= 4;
      *((_DWORD *)v54 - 1) = v61;
      v54 -= 4;
    }
    while (v50 != v49);
    goto LABEL_51;
  }
  unint64_t v54 = &v51[(v50 - v49) & 0xFFFFFFFFFFFFFFFCLL];
  if (v50 - v51 - (v52 & 0xFFFFFFFFFFFFFFFCLL) < 0x20) {
    goto LABEL_50;
  }
  uint64_t v55 = v52 >> 2;
  unint64_t v56 = ((unint64_t)(v52 - 4) >> 2) + 1;
  int v57 = &v51[4 * v55 - 16];
  int32x4_t v58 = v50 - 16;
  uint64_t v59 = v56 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    long long v60 = *(_OWORD *)v58;
    *((_OWORD *)v57 - 1) = *((_OWORD *)v58 - 1);
    *(_OWORD *)int v57 = v60;
    v57 -= 32;
    v58 -= 32;
    v59 -= 8;
  }
  while (v59);
  unint64_t v54 = &v53[-4 * (v56 & 0x7FFFFFFFFFFFFFF8)];
  v50 -= 4 * (v56 & 0x7FFFFFFFFFFFFFF8);
  if (v56 != (v56 & 0x7FFFFFFFFFFFFFF8)) {
    goto LABEL_50;
  }
LABEL_51:
  long long v153 = v54;
  signed int v154 = v53;
  long long v155 = &v51[4 * v35];
  if (v49)
  {
    operator delete(v49);
    uint8x8_t v33 = (float *)__p;
    unint64_t v32 = v150;
  }
LABEL_53:
  unint64_t v62 = v144;
  if (v33 != v32)
  {
    float32x4_t v63 = &_os_log_internal;
    do
    {
      float v65 = *v33;
      float v66 = v33[1];
      int64_t v67 = llroundf((float)(*v33 / (float)v141) * (float)v145);
      float v68 = v33[2];
      if (v67 >= v31
        || v67 < 0
        || (int64_t v69 = llroundf((float)(v66 / (float)v142) * (float)v146), v69 < 0)
        || (float v70 = v68 / 1000.0, (float)(v68 / 1000.0) > *((float *)v62 + 653))
        || v69 >= v30
        || v70 < *((float *)v62 + 652))
      {
        if (ADDebugUtilsADVerboseLogsEnabled && os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218496;
          *(double *)&uint64_t v160 = v65;
          __int16 v161 = 2048;
          double v162 = v66;
          __int16 v163 = 2048;
          double v164 = v68;
          _os_log_impl(&dword_215F16000, v63, OS_LOG_TYPE_DEFAULT, "DisparityToDepth [Verbose] Skipping (pixelX, pixelY, depth)=(%f, %f, %f)", buf, 0x20u);
        }
        goto LABEL_57;
      }
      _H13 = *(_WORD *)(a2 + 2 * (v67 + v69 * v31));
      float64x2_t v72 = v157;
      float v73 = 1.0 / v70;
      if (v157 < (float *)v158)
      {
        float *v157 = v73;
        float64x2_t v74 = v72 + 1;
        goto LABEL_91;
      }
      float64x2_t v75 = (float *)v156;
      int64_t v76 = (char *)v157 - (unsigned char *)v156;
      uint64_t v77 = ((char *)v157 - (unsigned char *)v156) >> 2;
      unint64_t v78 = v77 + 1;
      if ((unint64_t)(v77 + 1) >> 62) {
        goto LABEL_171;
      }
      uint64_t v79 = v158 - (unsigned char *)v156;
      if ((v158 - (unsigned char *)v156) >> 1 > v78) {
        unint64_t v78 = v79 >> 1;
      }
      if ((unint64_t)v79 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v80 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v80 = v78;
      }
      if (v80)
      {
        if (v80 >> 62) {
          goto LABEL_172;
        }
        double v81 = (char *)operator new(4 * v80);
      }
      else
      {
        double v81 = 0;
      }
      float32x4_t v82 = (float *)&v81[4 * v77];
      *float32x4_t v82 = v73;
      float64x2_t v74 = v82 + 1;
      if (v72 == v75)
      {
        int64_t v31 = v145;
        int64_t v30 = v146;
      }
      else
      {
        unint64_t v83 = (char *)(v72 - 1) - (char *)v75;
        if (v83 >= 0x2C)
        {
          unint64_t v84 = (char *)v72 - &v81[v76];
          int64_t v31 = v145;
          int64_t v30 = v146;
          if (v84 >= 0x20)
          {
            uint64_t v85 = (v83 >> 2) + 1;
            float64x2_t v86 = &v81[4 * v77 - 16];
            float64x2_t v87 = v72 - 4;
            uint64_t v88 = v85 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v89 = *(_OWORD *)v87;
              *((_OWORD *)v86 - 1) = *((_OWORD *)v87 - 1);
              *(_OWORD *)float64x2_t v86 = v89;
              v86 -= 32;
              v87 -= 8;
              v88 -= 8;
            }
            while (v88);
            v82 -= v85 & 0x7FFFFFFFFFFFFFF8;
            v72 -= v85 & 0x7FFFFFFFFFFFFFF8;
            if (v85 == (v85 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_88;
            }
          }
        }
        else
        {
          int64_t v31 = v145;
          int64_t v30 = v146;
        }
        do
        {
          int v90 = *((_DWORD *)v72-- - 1);
          *((_DWORD *)v82-- - 1) = v90;
        }
        while (v72 != v75);
      }
LABEL_88:
      long long v156 = v82;
      double v157 = v74;
      double v158 = &v81[4 * v80];
      if (v75) {
        operator delete(v75);
      }
      unint64_t v62 = v144;
      float32x4_t v63 = &_os_log_internal;
LABEL_91:
      __asm { FCVT            S13, H13 }
      double v157 = v74;
      float32x4_t v96 = v154;
      if (v154 >= v155)
      {
        float32x4_t v97 = (char *)v153;
        int64_t v98 = v154 - (unsigned char *)v153;
        uint64_t v99 = (v154 - (unsigned char *)v153) >> 2;
        unint64_t v100 = v99 + 1;
        if ((unint64_t)(v99 + 1) >> 62) {
LABEL_171:
        }
          std::vector<float>::__throw_length_error[abi:ne180100]();
        uint64_t v101 = v155 - (unsigned char *)v153;
        if ((v155 - (unsigned char *)v153) >> 1 > v100) {
          unint64_t v100 = v101 >> 1;
        }
        if ((unint64_t)v101 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v102 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v102 = v100;
        }
        if (v102)
        {
          if (v102 >> 62) {
LABEL_172:
          }
            std::__throw_bad_array_new_length[abi:ne180100]();
          unsigned int v103 = (char *)operator new(4 * v102);
        }
        else
        {
          unsigned int v103 = 0;
        }
        float v104 = &v103[4 * v99];
        *(_DWORD *)float v104 = _S13;
        float32x4_t v64 = v104 + 4;
        if (v96 == v97)
        {
          int64_t v31 = v145;
          int64_t v30 = v146;
        }
        else
        {
          unint64_t v105 = v96 - 4 - v97;
          if (v105 < 0x2C)
          {
            int64_t v31 = v145;
            int64_t v30 = v146;
            goto LABEL_110;
          }
          unint64_t v106 = v96 - &v103[v98];
          int64_t v31 = v145;
          int64_t v30 = v146;
          if (v106 < 0x20) {
            goto LABEL_183;
          }
          uint64_t v107 = (v105 >> 2) + 1;
          float32x4_t v108 = &v103[4 * v99 - 16];
          float32x4_t v109 = v96 - 16;
          uint64_t v110 = v107 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v111 = *(_OWORD *)v109;
            *((_OWORD *)v108 - 1) = *((_OWORD *)v109 - 1);
            *(_OWORD *)float32x4_t v108 = v111;
            v108 -= 32;
            v109 -= 32;
            v110 -= 8;
          }
          while (v110);
          v104 -= 4 * (v107 & 0x7FFFFFFFFFFFFFF8);
          v96 -= 4 * (v107 & 0x7FFFFFFFFFFFFFF8);
          if (v107 != (v107 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_183:
            do
            {
LABEL_110:
              int v112 = *((_DWORD *)v96 - 1);
              v96 -= 4;
              *((_DWORD *)v104 - 1) = v112;
              v104 -= 4;
            }
            while (v96 != v97);
          }
        }
        long long v153 = v104;
        signed int v154 = v64;
        long long v155 = &v103[4 * v102];
        if (v97) {
          operator delete(v97);
        }
        unint64_t v62 = v144;
        float32x4_t v63 = &_os_log_internal;
        goto LABEL_56;
      }
      *(_DWORD *)signed int v154 = _S13;
      float32x4_t v64 = v96 + 4;
LABEL_56:
      signed int v154 = v64;
LABEL_57:
      v33 += 4;
    }
    while (v33 != v32);
  }
  if (DisparityToDepth::Ransac<float,float>::fit((int *)v62 + 18, (const void **)&v156, (const void **)&v153))
  {
    if (ADDebugUtilsADVerboseLogsEnabled && os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v160 = ((char *)v157 - (unsigned char *)v156) >> 2;
      _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "DisparityToDepth [Verbose] Ransac with input length: %lu succeeded", buf, 0xCu);
    }
    float v113 = (*(float (**)(void))(**((void **)v62 + 8) + 48))(*((void *)v62 + 8));
    if (*((unsigned char *)v62 + 2616))
    {
      if (*((unsigned char *)v62 + 2632)) {
        double v114 = *((double *)v62 + 328);
      }
      else {
        double v114 = v113;
      }
      double v127 = (float)(v113 * (float)(1.0 - *((float *)v62 + 655))) + *((float *)v62 + 655) * v114;
      *((double *)v62 + 328) = v127;
      *((unsigned char *)v62 + 2632) = 1;
      float v113 = v127;
    }
    else
    {
      if (!*((unsigned char *)v62 + 2632)) {
        *((unsigned char *)v62 + 2632) = 1;
      }
      *((double *)v62 + 328) = v113;
    }
    float v128 = -(*(float (**)(void))(**((void **)v62 + 8) + 56))(*((void *)v62 + 8));
    if (*((unsigned char *)v62 + 2640))
    {
      if (*((unsigned char *)v62 + 2656)) {
        double v129 = *((double *)v62 + 331);
      }
      else {
        double v129 = v128;
      }
      double v130 = (float)((float)(1.0 - *((float *)v62 + 661)) * v128) + *((float *)v62 + 661) * v129;
      *((double *)v62 + 331) = v130;
      *((unsigned char *)v62 + 2656) = 1;
      float v128 = v130;
    }
    else
    {
      if (!*((unsigned char *)v62 + 2656)) {
        *((unsigned char *)v62 + 2656) = 1;
      }
      *((double *)v62 + 331) = v128;
    }
    *(unsigned char *)uint64_t v143 = 1;
    *(void *)(v143 + 16) = 0;
    *(float *)(v143 + 4) = v113;
    *(float *)(v143 + 8) = v128;
    *(void *)(v143 + 24) = 0;
    *(void *)(v143 + 32) = 0;
    long long v131 = v156;
    int64_t v132 = (char *)v157 - (unsigned char *)v156;
    if (v157 != v156)
    {
      if (v132 < 0) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      long long v133 = (char *)operator new((char *)v157 - (unsigned char *)v156);
      *(void *)(v143 + 16) = v133;
      *(void *)(v143 + 24) = v133;
      long long v134 = &v133[4 * (v132 >> 2)];
      *(void *)(v143 + 32) = v134;
      memcpy(v133, v131, v132);
      *(void *)(v143 + 24) = v134;
    }
    *(void *)(v143 + 40) = 0;
    *(void *)(v143 + 48) = 0;
    *(void *)(v143 + 56) = 0;
    long long v135 = v153;
    int64_t v136 = v154 - (unsigned char *)v153;
    if (v154 != v153)
    {
      if (v136 < 0) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      long long v137 = (char *)operator new(v154 - (unsigned char *)v153);
      *(void *)(v143 + 40) = v137;
      *(void *)(v143 + 48) = v137;
      uint64_t v138 = &v137[4 * (v136 >> 2)];
      *(void *)(v143 + 56) = v138;
      memcpy(v137, v135, v136);
      *(void *)(v143 + 48) = v138;
    }
    *(void *)(v143 + 64) = 0;
    *(void *)(v143 + 72) = 0;
    *(void *)(v143 + 80) = 0;
    float64x2_t v125 = v151;
    int64_t v126 = v152 - (unsigned char *)v151;
    if (v152 == v151) {
      goto LABEL_158;
    }
    if (v126 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    goto LABEL_157;
  }
  if (ADDebugUtilsADVerboseLogsEnabled && os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v160 = ((char *)v157 - (unsigned char *)v156) >> 2;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "DisparityToDepth [Verbose] Ransac input length: %lu failed", buf, 0xCu);
  }
  if (*((unsigned char *)v62 + 2656) && *((unsigned char *)v62 + 2632))
  {
    double v115 = *((double *)v62 + 331);
    double v116 = *((double *)v62 + 328);
    *(unsigned char *)uint64_t v143 = 1;
    *(float *)&double v116 = v116;
    *(float *)&double v115 = v115;
    *(void *)(v143 + 16) = 0;
    *(_DWORD *)(v143 + 4) = LODWORD(v116);
    *(_DWORD *)(v143 + 8) = LODWORD(v115);
    *(void *)(v143 + 24) = 0;
    *(void *)(v143 + 32) = 0;
    long long v117 = v156;
    int64_t v118 = (char *)v157 - (unsigned char *)v156;
    if (v157 != v156)
    {
      if (v118 < 0) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      long long v119 = (char *)operator new((char *)v157 - (unsigned char *)v156);
      *(void *)(v143 + 16) = v119;
      *(void *)(v143 + 24) = v119;
      long long v120 = &v119[4 * (v118 >> 2)];
      *(void *)(v143 + 32) = v120;
      memcpy(v119, v117, v118);
      *(void *)(v143 + 24) = v120;
    }
    *(void *)(v143 + 40) = 0;
    *(void *)(v143 + 48) = 0;
    *(void *)(v143 + 56) = 0;
    long long v121 = v153;
    int64_t v122 = v154 - (unsigned char *)v153;
    if (v154 != v153)
    {
      if (v122 < 0) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      float64x2_t v123 = (char *)operator new(v154 - (unsigned char *)v153);
      *(void *)(v143 + 40) = v123;
      *(void *)(v143 + 48) = v123;
      float64x2_t v124 = &v123[4 * (v122 >> 2)];
      *(void *)(v143 + 56) = v124;
      memcpy(v123, v121, v122);
      *(void *)(v143 + 48) = v124;
    }
    *(void *)(v143 + 64) = 0;
    *(void *)(v143 + 72) = 0;
    *(void *)(v143 + 80) = 0;
    float64x2_t v125 = v151;
    int64_t v126 = v152 - (unsigned char *)v151;
    if (v152 == v151) {
      goto LABEL_158;
    }
    if (v126 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
LABEL_157:
    uint64_t v139 = (char *)operator new(v152 - (unsigned char *)v151);
    *(void *)(v143 + 64) = v139;
    *(void *)(v143 + 72) = v139;
    uint64_t v140 = &v139[32 * (v126 >> 5)];
    *(void *)(v143 + 80) = v140;
    memcpy(v139, v125, v126);
    *(void *)(v143 + 72) = v140;
    goto LABEL_158;
  }
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4ELm5EEEEJbffNS_6vectorIfNS_9allocatorIfEEEES6_NS3_I31ADDisparityToDepthFitWorldPointNS4_IS7_EEEEEEC2B8ne180100IJLm0ELm1ELm2ELm3ELm4ELm5EEJbffS6_S6_S9_EJEJEJbiiRS6_SC_RKS9_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSG_IJDpT2_EEEDpOT3_(v143, 0, 0, 0, (uint64_t)&v156, (uint64_t)&v153, (uint64_t)&v151);
LABEL_158:
  if (__p)
  {
    int v150 = (float *)__p;
    operator delete(__p);
  }
  if (v20) {
    operator delete(v20);
  }
LABEL_162:
  if (v151) {
    operator delete(v151);
  }
  if (v153)
  {
    signed int v154 = (char *)v153;
    operator delete(v153);
  }
  if (v156)
  {
    double v157 = (float *)v156;
    operator delete(v156);
  }
}

void sub_215F60C20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29)
{
  unint64_t v34 = *v32;
  if (*v32)
  {
    a12[9] = v34;
    operator delete(v34);
    unint64_t v35 = *v30;
    if (!*v30)
    {
LABEL_3:
      uint64_t v36 = *v29;
      if (!*v29) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else
  {
    unint64_t v35 = *v30;
    if (!*v30) {
      goto LABEL_3;
    }
  }
  a12[6] = v35;
  operator delete(v35);
  uint64_t v36 = *v29;
  if (!*v29)
  {
LABEL_4:
    size_t v37 = __p;
    if (!__p) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
LABEL_12:
  a12[3] = v36;
  operator delete(v36);
  size_t v37 = __p;
  if (!__p)
  {
LABEL_5:
    if (!v31) {
      goto LABEL_6;
    }
    goto LABEL_14;
  }
LABEL_13:
  operator delete(v37);
  if (!v31)
  {
LABEL_6:
    uint64_t v38 = a22;
    if (!a22) {
      goto LABEL_7;
    }
    goto LABEL_15;
  }
LABEL_14:
  operator delete(v31);
  uint64_t v38 = a22;
  if (!a22)
  {
LABEL_7:
    uint64_t v39 = a25;
    if (!a25) {
      goto LABEL_8;
    }
    goto LABEL_16;
  }
LABEL_15:
  operator delete(v38);
  uint64_t v39 = a25;
  if (!a25)
  {
LABEL_8:
    unint64_t v40 = a28;
    if (!a28) {
      goto LABEL_9;
    }
    goto LABEL_17;
  }
LABEL_16:
  operator delete(v39);
  unint64_t v40 = a28;
  if (!a28) {
LABEL_9:
  }
    _Unwind_Resume(exception_object);
LABEL_17:
  operator delete(v40);
  _Unwind_Resume(exception_object);
}

void DisparityToDepth::WorldPointsContainer::vector(DisparityToDepth::WorldPointsContainer *this@<X0>, char **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  *(_OWORD *)unint64_t v43 = 0u;
  *(_OWORD *)__p = 0u;
  int v45 = 1065353216;
  uint64_t v4 = *(void *)this;
  uint64_t v3 = *((void *)this + 1);
  unint64_t v6 = (unsigned char *)*((void *)this + 4);
  unint64_t v5 = (unsigned char *)*((void *)this + 5);
  size_t v7 = v5 - v6;
  uint64_t v8 = (v5 - v6) >> 5;
  unint64_t v9 = v8 + ((v3 - *(void *)this) >> 5);
  if (!v9)
  {
    unint64_t v11 = 0;
    unsigned int v10 = 0;
    if (v4 != v3) {
      goto LABEL_4;
    }
LABEL_35:
    if (v5 == v6) {
      goto LABEL_29;
    }
LABEL_36:
    if ((v7 & 0x8000000000000000) != 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    size_t v27 = (char *)operator new(v7);
    size_t v28 = &v27[32 * v8];
    memcpy(v27, v6, v7);
    if (v8)
    {
      long long v29 = a2[2];
      int64_t v30 = *a2;
      int64_t v31 = v27;
      do
      {
        if (std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)v43, *((_DWORD *)v31 + 5), *((_DWORD *)v31 + 5)))
        {
          if (v10 < v29)
          {
            long long v32 = *((_OWORD *)v31 + 1);
            *(_OWORD *)unsigned int v10 = *(_OWORD *)v31;
            *((_OWORD *)v10 + 1) = v32;
            v10 += 32;
          }
          else
          {
            uint64_t v33 = (v10 - v30) >> 5;
            unint64_t v34 = v33 + 1;
            if ((unint64_t)(v33 + 1) >> 59) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            if ((v29 - v30) >> 4 > v34) {
              unint64_t v34 = (v29 - v30) >> 4;
            }
            if ((unint64_t)(v29 - v30) >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v35 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v35 = v34;
            }
            if (v35)
            {
              if (v35 >> 59) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              uint64_t v36 = (char *)operator new(32 * v35);
            }
            else
            {
              uint64_t v36 = 0;
            }
            long long v37 = *((_OWORD *)v31 + 1);
            uint64_t v38 = &v36[32 * v33];
            *(_OWORD *)uint64_t v38 = *(_OWORD *)v31;
            *((_OWORD *)v38 + 1) = v37;
            if (v10 == v30)
            {
              int64x2_t v41 = &v36[32 * v33];
            }
            else
            {
              uint64_t v39 = &v36[32 * v33];
              do
              {
                long long v40 = *((_OWORD *)v10 - 1);
                int64x2_t v41 = v39 - 32;
                *((_OWORD *)v39 - 2) = *((_OWORD *)v10 - 2);
                *((_OWORD *)v39 - 1) = v40;
                v10 -= 32;
                v39 -= 32;
              }
              while (v10 != v30);
            }
            long long v29 = &v36[32 * v35];
            unsigned int v10 = v38 + 32;
            *a2 = v41;
            a2[1] = v38 + 32;
            a2[2] = v29;
            if (v30) {
              operator delete(v30);
            }
            int64_t v30 = v41;
          }
          a2[1] = v10;
        }
        v31 += 32;
      }
      while (v31 != v28);
    }
    operator delete(v27);
    uint64_t v24 = __p[0];
    if (__p[0]) {
      goto LABEL_30;
    }
    goto LABEL_31;
  }
  if (v9 >> 59) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  unsigned int v10 = (char *)operator new(32 * v9);
  unint64_t v11 = &v10[32 * v9];
  *a2 = v10;
  a2[1] = v10;
  a2[2] = v11;
  if (v4 == v3) {
    goto LABEL_35;
  }
LABEL_4:
  uint64_t v12 = v10;
  do
  {
    if (std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)v43, *(_DWORD *)(v4 + 20), *(_DWORD *)(v4 + 20)))
    {
      if (v12 < v11)
      {
        long long v13 = *(_OWORD *)(v4 + 16);
        *(_OWORD *)uint64_t v12 = *(_OWORD *)v4;
        *((_OWORD *)v12 + 1) = v13;
        v12 += 32;
      }
      else
      {
        uint64_t v14 = (v12 - v10) >> 5;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 59) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        if ((v11 - v10) >> 4 > v15) {
          unint64_t v15 = (v11 - v10) >> 4;
        }
        if ((unint64_t)(v11 - v10) >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v16 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v15;
        }
        if (v16)
        {
          if (v16 >> 59) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          BOOL v17 = (char *)operator new(32 * v16);
        }
        else
        {
          BOOL v17 = 0;
        }
        long long v18 = *(_OWORD *)(v4 + 16);
        uint64_t v19 = &v17[32 * v14];
        *(_OWORD *)uint64_t v19 = *(_OWORD *)v4;
        *((_OWORD *)v19 + 1) = v18;
        if (v12 == v10)
        {
          uint64_t v22 = &v17[32 * v14];
        }
        else
        {
          long long v20 = &v17[32 * v14];
          do
          {
            long long v21 = *((_OWORD *)v12 - 1);
            uint64_t v22 = v20 - 32;
            *((_OWORD *)v20 - 2) = *((_OWORD *)v12 - 2);
            *((_OWORD *)v20 - 1) = v21;
            v12 -= 32;
            v20 -= 32;
          }
          while (v12 != v10);
        }
        unint64_t v11 = &v17[32 * v16];
        uint64_t v12 = v19 + 32;
        *a2 = v22;
        a2[1] = v19 + 32;
        a2[2] = v11;
        if (v10) {
          operator delete(v10);
        }
        unsigned int v10 = v22;
      }
      a2[1] = v12;
    }
    v4 += 32;
  }
  while (v4 != v3);
  unint64_t v6 = (unsigned char *)*((void *)this + 4);
  uint64_t v23 = (unsigned char *)*((void *)this + 5);
  size_t v7 = v23 - v6;
  uint64_t v8 = (v23 - v6) >> 5;
  unsigned int v10 = v12;
  if (v23 != v6) {
    goto LABEL_36;
  }
LABEL_29:
  uint64_t v24 = __p[0];
  if (__p[0])
  {
    do
    {
LABEL_30:
      unint64_t v25 = (void *)*v24;
      operator delete(v24);
      uint64_t v24 = v25;
    }
    while (v25);
  }
LABEL_31:
  unint64_t v26 = v43[0];
  v43[0] = 0;
  if (v26) {
    operator delete(v26);
  }
}

void sub_215F610D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::unordered_set<int>::~unordered_set[abi:ne180100]((uint64_t)va);
  unint64_t v5 = *(void **)v3;
  if (*(void *)v3)
  {
    *(void *)(v3 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2ELm3ELm4ELm5EEEEJbffNS_6vectorIfNS_9allocatorIfEEEES6_NS3_I31ADDisparityToDepthFitWorldPointNS4_IS7_EEEEEEC2B8ne180100IJLm0ELm1ELm2ELm3ELm4ELm5EEJbffS6_S6_S9_EJEJEJbiiRS6_SC_RKS9_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSG_IJDpT2_EEEDpOT3_(uint64_t a1, char a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(unsigned char *)a1 = a2;
  *(void *)(a1 + 16) = 0;
  *(float *)(a1 + 4) = (float)a3;
  *(float *)(a1 + 8) = (float)a4;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  unint64_t v11 = *(const void **)a5;
  uint64_t v10 = *(void *)(a5 + 8);
  int64_t v12 = v10 - *(void *)a5;
  if (v10 != *(void *)a5)
  {
    if (v12 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    long long v13 = (char *)operator new(v10 - *(void *)a5);
    *(void *)(a1 + 16) = v13;
    *(void *)(a1 + 24) = v13;
    uint64_t v14 = &v13[4 * (v12 >> 2)];
    *(void *)(a1 + 32) = v14;
    memcpy(v13, v11, v12);
    *(void *)(a1 + 24) = v14;
  }
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  unint64_t v15 = *(const void **)a6;
  int64_t v16 = *(void *)(a6 + 8) - *(void *)a6;
  if (v16)
  {
    if (v16 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    BOOL v17 = (char *)operator new(v16);
    *(void *)(a1 + 40) = v17;
    *(void *)(a1 + 48) = v17;
    long long v18 = &v17[4 * (v16 >> 2)];
    *(void *)(a1 + 56) = v18;
    memcpy(v17, v15, v16);
    *(void *)(a1 + 48) = v18;
  }
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  uint64_t v19 = *(const void **)a7;
  int64_t v20 = *(void *)(a7 + 8) - *(void *)a7;
  if (v20)
  {
    if (v20 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    long long v21 = (char *)operator new(v20);
    *(void *)(a1 + 64) = v21;
    *(void *)(a1 + 72) = v21;
    uint64_t v22 = &v21[32 * (v20 >> 5)];
    *(void *)(a1 + 80) = v22;
    memcpy(v21, v19, v20);
    *(void *)(a1 + 72) = v22;
  }
  return a1;
}

void sub_215F61254(_Unwind_Exception *exception_object)
{
  unint64_t v6 = *v2;
  if (*v2)
  {
    v1[9] = v6;
    operator delete(v6);
    size_t v7 = *v3;
    if (!*v3)
    {
LABEL_3:
      uint64_t v8 = *v4;
      if (!*v4) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else
  {
    size_t v7 = *v3;
    if (!*v3) {
      goto LABEL_3;
    }
  }
  v1[6] = v7;
  operator delete(v7);
  uint64_t v8 = *v4;
  if (!*v4) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_4:
  v1[3] = v8;
  operator delete(v8);
  goto LABEL_5;
}

void sub_215F612B4()
{
  if (!*v0) {
    JUMPOUT(0x215F61278);
  }
  JUMPOUT(0x215F61270);
}

uint64_t DisparityToDepth::Ransac<float,float>::fit(int *a1, const void **a2, const void **a3)
{
  long long v234 = 0;
  long long v235 = 0;
  uint64_t v236 = 0;
  float64x2_t v231 = 0;
  long long v232 = 0;
  uint64_t v233 = 0;
  uint64_t v3 = a2[1];
  if (*a2 == v3)
  {
    uint64_t v19 = 0;
    goto LABEL_262;
  }
  unint64_t v5 = a3[1];
  if (*a3 == v5
    || (unint64_t v6 = (v3 - (unsigned char *)*a2) >> 2, v6 != (v5 - (unsigned char *)*a3) >> 2)
    || v6 < (*(unsigned int (**)(void))(**(void **)a1 + 40))(*(void *)a1)
    || (v8 = *a3, size_t v7 = a3[1],
                  (*(unsigned int (**)(void))(**(void **)a1 + 40))() > (unint64_t)((v7 - v8) >> 2)))
  {
LABEL_259:
    uint64_t v19 = 0;
    goto LABEL_260;
  }
  uint64_t v10 = a1;
  if (*((float *)a1 + 3) == 0.0)
  {
    if (*((unsigned char *)a1 + 2528)) {
      unint64_t v11 = a3;
    }
    else {
      unint64_t v11 = a2;
    }
    int64_t v12 = *v11;
    long long v13 = a2 + 1;
    if (*((unsigned char *)a1 + 2528)) {
      long long v13 = a3 + 1;
    }
    uint64_t v14 = *v13;
    int64_t v15 = (unsigned char *)*v13 - v12;
    unint64_t v16 = v15 >> 2;
    if (*v13 == v12)
    {
      long long v18 = 0;
      BOOL v17 = 0;
    }
    else
    {
      if (v15 < 0) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      BOOL v17 = (float32x4_t *)operator new((unsigned char *)*v13 - v12);
      long long v18 = &v17->f32[v16];
      memcpy(v17, v12, v15);
    }
    int64_t v20 = &v17->f32[v16 >> 1];
    if (v20 != v18) {
      std::__nth_element[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<float *>>(v17->f32, &v17->f32[v16 >> 1], v18);
    }
    if (v14 == v12) {
      goto LABEL_30;
    }
    v9.i32[0] = *(__int32 *)v20;
    if (v16 <= 1) {
      unint64_t v21 = 1;
    }
    else {
      unint64_t v21 = v16;
    }
    if (v21 > 7)
    {
      unint64_t v22 = v21 & 0xFFFFFFFFFFFFFFF8;
      float32x4_t v23 = (float32x4_t)vdupq_lane_s32(v9, 0);
      uint64_t v24 = v17 + 1;
      unint64_t v25 = v21 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v26 = vabdq_f32(*v24, v23);
        v24[-1] = vabdq_f32(v24[-1], v23);
        *uint64_t v24 = v26;
        v24 += 2;
        v25 -= 8;
      }
      while (v25);
      if (v21 == v22) {
        goto LABEL_30;
      }
    }
    else
    {
      unint64_t v22 = 0;
    }
    unint64_t v27 = v21 - v22;
    size_t v28 = &v17->f32[v22];
    do
    {
      *size_t v28 = vabds_f32(*v28, *(float *)v9.i32);
      ++v28;
      --v27;
    }
    while (v27);
LABEL_30:
    if (v20 != v18) {
      std::__nth_element[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<float *>>(v17->f32, &v17->f32[v16 >> 1], v18);
    }
    __int32 v29 = *(_DWORD *)v20;
    operator delete(v17);
    uint64_t v10 = a1;
    a1[3] = v29;
  }
  if (v10[2] < 1) {
    goto LABEL_259;
  }
  float32x2_t v215 = a3;
  int v30 = 0;
  int v203 = 0;
  int64_t v31 = v10 + 6;
  float v32 = 0.0;
  do
  {
    unsigned int v33 = (*(uint64_t (**)(void))(**(void **)v10 + 40))();
    int v204 = v30;
    if (v33)
    {
      uint64_t v34 = v33;
      unint64_t v35 = (char *)operator new(8 * v33);
      uint64_t v36 = &v35[8 * v34];
    }
    else
    {
      unint64_t v35 = 0;
      uint64_t v36 = 0;
    }
    unsigned int v37 = 0;
    uint64_t v38 = a1;
    unint64_t v39 = (unint64_t)((unsigned char *)a2[1] - (unsigned char *)*a2) >> 2;
    uint64_t v40 = __clz(v39);
    uint64_t v41 = 31;
    if (((v39 << v40) & 0x7FFFFFFF) != 0) {
      uint64_t v41 = 32;
    }
    unint64_t v42 = v41 - v40;
    unint64_t v43 = v42 >> 5;
    if ((v42 & 0x1F) != 0) {
      ++v43;
    }
    unint64_t v205 = v43;
    unint64_t v207 = v42;
    float32x4_t v44 = v35;
    int v45 = v35;
    while (v37 < (*(unsigned int (**)(void))(**(void **)v38 + 40))())
    {
      if (v39 == 1)
      {
        signed int v50 = 0;
        if (v45 < v36) {
          goto LABEL_44;
        }
      }
      else if (v39)
      {
        unsigned int v51 = 0xFFFFFFFF >> -(v207 / v205);
        if (v205 > v207) {
          unsigned int v51 = 0;
        }
        unint64_t v52 = *((void *)v38 + 315);
        do
        {
          uint64_t v53 = v52;
          unint64_t v54 = v52 + 397;
          unint64_t v52 = (v52 + 1) % 0x270;
          unsigned int v55 = v31[v54 % 0x270] ^ ((v31[v52] & 0x7FFFFFFE | v31[v53] & 0x80000000) >> 1) ^ (v31[v52] << 31 >> 31) & 0x9908B0DF;
          v31[v53] = v55;
          unsigned int v56 = ((v55 ^ (v55 >> 11)) << 7) & 0x9D2C5680 ^ v55 ^ (v55 >> 11);
          signed int v50 = ((v56 << 15) & 0xEFC60000 ^ v56 ^ (((v56 << 15) & 0xEFC60000 ^ v56) >> 18)) & v51;
        }
        while (v50 >= v39);
        *((void *)v38 + 315) = v52;
        if (v45 < v36)
        {
LABEL_44:
          *(void *)int v45 = v50;
          uint64_t v46 = v45 + 8;
          goto LABEL_45;
        }
      }
      else
      {
        uint64_t v47 = *((void *)v38 + 315);
        unint64_t v48 = (v47 + 1) % 0x270uLL;
        uint64_t v49 = v47;
        LODWORD(v47) = v31[(v47 + 397) % 0x270uLL] ^ ((v31[v48] & 0x7FFFFFFE | v31[v47] & 0x80000000) >> 1) ^ (v31[v48] << 31 >> 31) & 0x9908B0DF;
        v31[v49] = v47;
        *((void *)v38 + 315) = v48;
        LODWORD(v47) = ((v47 ^ (v47 >> 11)) << 7) & 0x9D2C5680 ^ v47 ^ (v47 >> 11);
        signed int v50 = (v47 << 15) & 0xEFC60000 ^ v47 ^ (((v47 << 15) & 0xEFC60000 ^ v47) >> 18);
        if (v45 < v36) {
          goto LABEL_44;
        }
      }
      unsigned int v211 = v37;
      int v57 = v45;
      uint64_t v58 = v45 - v44;
      uint64_t v59 = v58 >> 3;
      unint64_t v60 = (v58 >> 3) + 1;
      if (v60 >> 61) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      if ((v36 - v44) >> 2 > v60) {
        unint64_t v60 = (v36 - v44) >> 2;
      }
      if ((unint64_t)(v36 - v44) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v61 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v61 = v60;
      }
      if (v61)
      {
        if (v61 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        unint64_t v62 = v61;
        float32x4_t v63 = (char *)operator new(8 * v61);
        unint64_t v61 = v62;
      }
      else
      {
        float32x4_t v63 = 0;
      }
      unint64_t v35 = &v63[8 * v59];
      *(void *)unint64_t v35 = v50;
      uint64_t v46 = v35 + 8;
      if (v57 == v44)
      {
        uint64_t v38 = a1;
        unsigned int v37 = v211;
        goto LABEL_78;
      }
      unint64_t v64 = v57 - 8 - v44;
      if (v64 < 0x168)
      {
        float v65 = v57;
LABEL_76:
        uint64_t v38 = a1;
        unsigned int v37 = v211;
        do
        {
LABEL_77:
          uint64_t v66 = *((void *)v65 - 1);
          v65 -= 8;
          *((void *)v35 - 1) = v66;
          v35 -= 8;
        }
        while (v65 != v44);
        goto LABEL_78;
      }
      if (&v63[v58 - 8 - (v64 & 0xFFFFFFFFFFFFFFF8)] > &v63[v58 - 8]
        || &v57[-(v64 & 0xFFFFFFFFFFFFFFF8) - 8] > v57 - 8
        || (unint64_t)(v57 - &v63[v58]) < 0x20)
      {
        float v65 = v57;
        goto LABEL_76;
      }
      uint64_t v67 = (v64 >> 3) + 1;
      float v65 = &v57[-8 * (v67 & 0x3FFFFFFFFFFFFFFCLL)];
      float v68 = &v63[8 * v59 - 16];
      int64_t v69 = v57 - 16;
      uint64_t v70 = v67 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v71 = *(_OWORD *)v69;
        *((_OWORD *)v68 - 1) = *((_OWORD *)v69 - 1);
        *(_OWORD *)float v68 = v71;
        v68 -= 32;
        v69 -= 32;
        v70 -= 4;
      }
      while (v70);
      v35 -= 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v38 = a1;
      unsigned int v37 = v211;
      if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_77;
      }
LABEL_78:
      uint64_t v36 = &v63[8 * v61];
      if (v44) {
        operator delete(v44);
      }
      float32x4_t v44 = v35;
LABEL_45:
      ++v37;
      int v45 = v46;
    }
    int8x16_t v228 = 0;
    long long v229 = 0;
    long long v230 = 0;
    float32x2_t v225 = 0;
    int8x16_t v226 = 0;
    int8x16_t v227 = 0;
    uint64_t v72 = v45 - v44;
    if (v45 != v44)
    {
      if (v72 < 0) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      size_t v73 = (unint64_t)v72 >> 1;
      float64x2_t v74 = (char *)operator new((unint64_t)v72 >> 1);
      uint64_t v75 = v72 >> 3;
      int8x16_t v228 = v74;
      long long v229 = v74;
      long long v230 = &v74[4 * v75];
      int64_t v76 = (char *)operator new(v73);
      float32x2_t v225 = v76;
      int8x16_t v226 = v76;
      int8x16_t v227 = &v76[4 * v75];
      long long v209 = v45;
      while (1)
      {
        uint64_t v78 = *(void *)v44;
        uint64_t v79 = *a2;
        unint64_t v80 = v229;
        if (v229 >= v230)
        {
          float32x4_t v82 = (char *)v228;
          unint64_t v83 = (char *)(v229 - (unsigned char *)v228);
          uint64_t v84 = (v229 - (unsigned char *)v228) >> 2;
          unint64_t v85 = v84 + 1;
          if ((unint64_t)(v84 + 1) >> 62) {
            goto LABEL_265;
          }
          uint64_t v86 = v230 - (unsigned char *)v228;
          if ((v230 - (unsigned char *)v228) >> 1 > v85) {
            unint64_t v85 = v86 >> 1;
          }
          unint64_t v87 = (unint64_t)v86 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v85;
          if (v87)
          {
            float32x2_t v212 = (char *)(v229 - (unsigned char *)v228);
            if (v87 >> 62) {
              goto LABEL_267;
            }
            uint64_t v88 = *a2;
            long long v89 = v76;
            unint64_t v90 = v87;
            float v91 = (char *)operator new(4 * v87);
            unint64_t v87 = v90;
            int64_t v76 = v89;
            uint64_t v79 = v88;
            unint64_t v83 = v212;
          }
          else
          {
            float v91 = 0;
          }
          float v92 = &v91[4 * v84];
          *(_DWORD *)float v92 = v79[v78];
          double v81 = v92 + 4;
          if (v80 != v82)
          {
            unint64_t v93 = v80 - 4 - v82;
            if (v93 < 0x2C) {
              goto LABEL_279;
            }
            if ((unint64_t)(v80 - &v83[(void)v91]) < 0x20) {
              goto LABEL_279;
            }
            uint64_t v94 = (v93 >> 2) + 1;
            int v95 = &v91[4 * v84 - 16];
            float32x4_t v96 = v80 - 16;
            uint64_t v97 = v94 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v98 = *(_OWORD *)v96;
              *((_OWORD *)v95 - 1) = *((_OWORD *)v96 - 1);
              *(_OWORD *)int v95 = v98;
              v95 -= 32;
              v96 -= 32;
              v97 -= 8;
            }
            while (v97);
            v92 -= 4 * (v94 & 0x7FFFFFFFFFFFFFF8);
            v80 -= 4 * (v94 & 0x7FFFFFFFFFFFFFF8);
            if (v94 != (v94 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_279:
              do
              {
                int v99 = *((_DWORD *)v80 - 1);
                v80 -= 4;
                *((_DWORD *)v92 - 1) = v99;
                v92 -= 4;
              }
              while (v80 != v82);
            }
          }
          int8x16_t v228 = v92;
          long long v229 = v81;
          long long v230 = &v91[4 * v87];
          if (v82)
          {
            operator delete(v82);
            int64_t v76 = v226;
          }
          int v45 = v209;
        }
        else
        {
          *(_DWORD *)long long v229 = v79[v78];
          double v81 = v80 + 4;
        }
        long long v229 = v81;
        uint64_t v100 = *(void *)v44;
        uint64_t v101 = *v215;
        if (v76 >= v227) {
          break;
        }
        *(_DWORD *)int64_t v76 = v101[v100];
        uint64_t v77 = v76 + 4;
LABEL_89:
        int8x16_t v226 = v77;
        v44 += 8;
        int64_t v76 = v77;
        if (v44 == v45) {
          goto LABEL_138;
        }
      }
      unint64_t v102 = (char *)v225;
      int64_t v103 = v76 - (unsigned char *)v225;
      uint64_t v104 = (v76 - (unsigned char *)v225) >> 2;
      unint64_t v105 = v104 + 1;
      if ((unint64_t)(v104 + 1) >> 62) {
LABEL_265:
      }
        std::vector<float>::__throw_length_error[abi:ne180100]();
      uint64_t v106 = v227 - (unsigned char *)v225;
      if ((v227 - (unsigned char *)v225) >> 1 > v105) {
        unint64_t v105 = v106 >> 1;
      }
      if ((unint64_t)v106 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v107 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v107 = v105;
      }
      if (v107)
      {
        if (v107 >> 62) {
LABEL_267:
        }
          std::__throw_bad_array_new_length[abi:ne180100]();
        float32x4_t v108 = v76;
        unint64_t v109 = v107;
        uint64_t v110 = operator new(4 * v107);
        unint64_t v107 = v109;
        int64_t v76 = v108;
      }
      else
      {
        uint64_t v110 = 0;
      }
      long long v111 = &v110[4 * v104];
      *(_DWORD *)long long v111 = v101[v100];
      uint64_t v77 = v111 + 4;
      if (v76 == v102)
      {
        int v45 = v209;
        goto LABEL_129;
      }
      unint64_t v112 = v76 - 4 - v102;
      if (v112 < 0xBC
        || &v110[v103 - 4 - (v112 & 0xFFFFFFFFFFFFFFFCLL)] > &v110[v103 - 4]
        || &v76[-(v112 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v76 - 4
        || (unint64_t)(v76 - v110 - v103) < 0x20)
      {
        float v113 = v76;
        int v45 = v209;
      }
      else
      {
        uint64_t v115 = (v112 >> 2) + 1;
        float v113 = &v76[-4 * (v115 & 0x7FFFFFFFFFFFFFF8)];
        double v116 = &v110[4 * v104 - 16];
        long long v117 = (long long *)(v76 - 16);
        uint64_t v118 = v115 & 0x7FFFFFFFFFFFFFF8;
        int v45 = v209;
        do
        {
          long long v119 = *v117;
          *(v116 - 1) = *(v117 - 1);
          _OWORD *v116 = v119;
          v116 -= 2;
          v117 -= 2;
          v118 -= 8;
        }
        while (v118);
        v111 -= 4 * (v115 & 0x7FFFFFFFFFFFFFF8);
        if (v115 == (v115 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_129:
          float32x2_t v225 = v111;
          int8x16_t v226 = v77;
          int8x16_t v227 = &v110[4 * v107];
          if (v102) {
            operator delete(v102);
          }
          goto LABEL_89;
        }
      }
      do
      {
        int v114 = *((_DWORD *)v113 - 1);
        v113 -= 4;
        *((_DWORD *)v111 - 1) = v114;
        v111 -= 4;
      }
      while (v113 != v102);
      goto LABEL_129;
    }
LABEL_138:
    (*(void (**)(void, void **, void **))(**(void **)a1 + 16))(*(void *)a1, &v228, &v225);
    if (*((unsigned char *)a1 + 2528))
    {
      (*(void (**)(void **__return_ptr))(**(void **)a1 + 32))(&__p);
    }
    else
    {
      (*(void (**)(void **__return_ptr))(**(void **)a1 + 24))(&__p);
    }
    long long v120 = (float *)v219;
    if (__p)
    {
      simd_float2x2 v223 = (char *)__p;
      operator delete(__p);
    }
    int64_t v122 = *a2;
    long long v121 = a2[1];
    uint64_t v123 = v121 - (unsigned char *)*a2;
    unint64_t v124 = v123 >> 2;
    long long v208 = v120;
    if (v121 != *a2)
    {
      if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFFDLL) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      float64x2_t v125 = (char *)operator new(2 * v123);
      unint64_t v126 = 0;
      double v127 = &v125[8 * v124];
      float v128 = v125;
      double v129 = v121;
      while (1)
      {
        if (v120[v126] <= *((float *)a1 + 3))
        {
          if (v128 >= v127)
          {
            double v130 = v125;
            uint64_t v131 = v128 - v125;
            uint64_t v132 = v131 >> 3;
            unint64_t v133 = (v131 >> 3) + 1;
            float64x2_t v213 = v130;
            if (v133 >> 61) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v134 = v127 - v130;
            unint64_t v135 = (v127 - v130) >> 2;
            if (v135 > v133) {
              unint64_t v133 = v135;
            }
            if (v134 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v136 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v136 = v133;
            }
            if (v136)
            {
              if (v136 >> 61) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              long long v137 = v129;
              uint64_t v138 = v128;
              uint64_t v139 = operator new(8 * v136);
              float v128 = v138;
              double v129 = v137;
            }
            else
            {
              uint64_t v139 = 0;
            }
            uint64_t v140 = (unint64_t *)&v139[8 * v132];
            unint64_t *v140 = v126;
            unint64_t v141 = (char *)(v140 + 1);
            unint64_t v142 = v213;
            if (v128 != v213)
            {
              unint64_t v143 = v128 - 8 - v213;
              if (v143 < 0x168
                || &v139[v131 - 8 - (v143 & 0xFFFFFFFFFFFFFFF8)] > &v139[v131 - 8]
                || &v128[-(v143 & 0xFFFFFFFFFFFFFFF8) - 8] > v128 - 8
                || (unint64_t)(v128 - &v139[v131]) < 0x20)
              {
                uint64_t v144 = v128;
                long long v120 = v208;
                unint64_t v142 = v213;
              }
              else
              {
                uint64_t v146 = (v143 >> 3) + 1;
                uint64_t v144 = &v128[-8 * (v146 & 0x3FFFFFFFFFFFFFFCLL)];
                uint64_t v147 = &v139[8 * v132 - 16];
                uint64_t v148 = v128 - 16;
                uint64_t v149 = v146 & 0x3FFFFFFFFFFFFFFCLL;
                unint64_t v142 = v213;
                do
                {
                  long long v150 = *(_OWORD *)v148;
                  *(v147 - 1) = *((_OWORD *)v148 - 1);
                  *uint64_t v147 = v150;
                  v147 -= 2;
                  v148 -= 32;
                  v149 -= 4;
                }
                while (v149);
                v140 -= v146 & 0x3FFFFFFFFFFFFFFCLL;
                long long v120 = v208;
                if (v146 == (v146 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_164:
                  double v127 = &v139[8 * v136];
                  if (v142) {
                    goto LABEL_165;
                  }
                  goto LABEL_166;
                }
              }
              do
              {
                unint64_t v145 = *((void *)v144 - 1);
                v144 -= 8;
                *--uint64_t v140 = v145;
              }
              while (v144 != v142);
              goto LABEL_164;
            }
            long long v120 = v208;
            double v127 = &v139[8 * v136];
            if (v213)
            {
LABEL_165:
              operator delete(v142);
              int64_t v122 = *a2;
              double v129 = a2[1];
            }
LABEL_166:
            float64x2_t v125 = (char *)v140;
            float v128 = v141;
            goto LABEL_147;
          }
          *(void *)float v128 = v126;
          v128 += 8;
        }
LABEL_147:
        ++v126;
        unint64_t v124 = (v129 - v122) >> 2;
        if (v126 >= v124) {
          goto LABEL_177;
        }
      }
    }
    float64x2_t v125 = 0;
    float v128 = 0;
LABEL_177:
    unint64_t v151 = v128 - v125;
    uint64_t v152 = (v128 - v125) >> 3;
    if ((float)((float)(unint64_t)v152 / (float)v124) <= *((float *)a1 + 4))
    {
      uint64_t v10 = a1;
      int v199 = v204;
      if (!v125) {
        goto LABEL_235;
      }
LABEL_234:
      operator delete(v125);
      goto LABEL_235;
    }
    __p = 0;
    simd_float2x2 v223 = 0;
    float32x2_t v224 = 0;
    float64x2_t v219 = 0;
    int64x2_t v220 = 0;
    float64x2_t v221 = 0;
    if (v128 != v125)
    {
      long long v210 = v128;
      float32x2_t v214 = v125;
      if ((v151 & 0x8000000000000000) != 0) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      size_t v153 = v151 >> 1;
      __p = operator new(v151 >> 1);
      simd_float2x2 v223 = (char *)__p;
      float32x2_t v224 = (char *)__p + 4 * v152;
      signed int v154 = (char *)operator new(v153);
      float64x2_t v219 = v154;
      int64x2_t v220 = v154;
      float64x2_t v221 = &v154[4 * v152];
      long long v155 = v125;
      long long v156 = v210;
      while (1)
      {
        uint64_t v158 = *(void *)v155;
        double v159 = *a2;
        uint64_t v160 = v223;
        if (v223 >= v224)
        {
          double v162 = (char *)__p;
          uint64_t v163 = v223 - (unsigned char *)__p;
          int64_t v164 = (v223 - (unsigned char *)__p) >> 2;
          unint64_t v165 = v164 + 1;
          if ((unint64_t)(v164 + 1) >> 62) {
            goto LABEL_268;
          }
          uint64_t v166 = v224 - (unsigned char *)__p;
          if ((v224 - (unsigned char *)__p) >> 1 > v165) {
            unint64_t v165 = v166 >> 1;
          }
          unint64_t v167 = (unint64_t)v166 >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v165;
          if (v167)
          {
            uint64_t v206 = v223 - (unsigned char *)__p;
            if (v167 >> 62) {
              goto LABEL_270;
            }
            unint64_t v168 = v154;
            uint64_t v169 = v155;
            unint64_t v170 = v167;
            float64x2_t v171 = operator new(4 * v167);
            long long v156 = v210;
            unint64_t v167 = v170;
            long long v155 = v169;
            signed int v154 = v168;
            uint64_t v163 = v206;
          }
          else
          {
            float64x2_t v171 = 0;
          }
          uint64_t v172 = &v171[4 * v164];
          *(_DWORD *)uint64_t v172 = v159[v158];
          __int16 v161 = v172 + 4;
          if (v160 != v162)
          {
            unint64_t v173 = v160 - 4 - v162;
            if (v173 < 0x2C) {
              goto LABEL_280;
            }
            if ((unint64_t)(v160 - &v171[v163]) < 0x20) {
              goto LABEL_280;
            }
            uint64_t v174 = (v173 >> 2) + 1;
            long long v175 = &v171[4 * v164 - 16];
            long long v176 = v160 - 16;
            uint64_t v177 = v174 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v178 = *(_OWORD *)v176;
              *(v175 - 1) = *((_OWORD *)v176 - 1);
              *long long v175 = v178;
              v175 -= 2;
              v176 -= 32;
              v177 -= 8;
            }
            while (v177);
            v172 -= 4 * (v174 & 0x7FFFFFFFFFFFFFF8);
            v160 -= 4 * (v174 & 0x7FFFFFFFFFFFFFF8);
            if (v174 != (v174 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_280:
              do
              {
                int v179 = *((_DWORD *)v160 - 1);
                v160 -= 4;
                *((_DWORD *)v172 - 1) = v179;
                v172 -= 4;
              }
              while (v160 != v162);
            }
          }
          __p = v172;
          simd_float2x2 v223 = v161;
          float32x2_t v224 = &v171[4 * v167];
          if (v162)
          {
            operator delete(v162);
            long long v156 = v210;
            signed int v154 = v220;
          }
        }
        else
        {
          *(_DWORD *)simd_float2x2 v223 = v159[v158];
          __int16 v161 = v160 + 4;
        }
        simd_float2x2 v223 = v161;
        uint64_t v180 = *(void *)v155;
        float64x2_t v181 = *v215;
        if (v154 >= v221) {
          break;
        }
        *(_DWORD *)signed int v154 = v181[v180];
        double v157 = v154 + 4;
        float64x2_t v125 = v214;
LABEL_182:
        int64x2_t v220 = v157;
        v155 += 8;
        signed int v154 = v157;
        if (v155 == v156) {
          goto LABEL_243;
        }
      }
      long long v182 = (char *)v219;
      int64_t v183 = v154 - (unsigned char *)v219;
      uint64_t v184 = (v154 - (unsigned char *)v219) >> 2;
      unint64_t v185 = v184 + 1;
      if ((unint64_t)(v184 + 1) >> 62) {
LABEL_268:
      }
        std::vector<float>::__throw_length_error[abi:ne180100]();
      uint64_t v186 = v221 - (unsigned char *)v219;
      if ((v221 - (unsigned char *)v219) >> 1 > v185) {
        unint64_t v185 = v186 >> 1;
      }
      if ((unint64_t)v186 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v187 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v187 = v185;
      }
      if (v187)
      {
        if (v187 >> 62) {
LABEL_270:
        }
          std::__throw_bad_array_new_length[abi:ne180100]();
        simd_float2x2 v188 = v154;
        float v189 = operator new(4 * v187);
        long long v156 = v210;
        signed int v154 = v188;
      }
      else
      {
        float v189 = 0;
      }
      float v190 = &v189[4 * v184];
      *(_DWORD *)float v190 = v181[v180];
      double v157 = v190 + 4;
      if (v154 == v182)
      {
        float64x2_t v125 = v214;
        goto LABEL_221;
      }
      unint64_t v191 = v154 - 4 - v182;
      float64x2_t v125 = v214;
      if (v191 >= 0xBC)
      {
        if (&v189[v183 - 4 - (v191 & 0xFFFFFFFFFFFFFFFCLL)] > &v189[v183 - 4])
        {
          float v192 = v154;
        }
        else if (&v154[-(v191 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v154 - 4)
        {
          float v192 = v154;
        }
        else if ((unint64_t)(v154 - v189 - v183) >= 0x20)
        {
          uint64_t v194 = (v191 >> 2) + 1;
          float v192 = &v154[-4 * (v194 & 0x7FFFFFFFFFFFFFF8)];
          simd_float2x2 v195 = &v189[4 * v184 - 16];
          long long v196 = v154 - 16;
          uint64_t v197 = v194 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v198 = *(_OWORD *)v196;
            *(v195 - 1) = *((_OWORD *)v196 - 1);
            *simd_float2x2 v195 = v198;
            v195 -= 2;
            v196 -= 32;
            v197 -= 8;
          }
          while (v197);
          v190 -= 4 * (v194 & 0x7FFFFFFFFFFFFFF8);
          if (v194 == (v194 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_221:
            float64x2_t v219 = v190;
            int64x2_t v220 = v157;
            float64x2_t v221 = &v189[4 * v187];
            if (v182)
            {
              operator delete(v182);
              long long v156 = v210;
            }
            goto LABEL_182;
          }
        }
        else
        {
          float v192 = v154;
        }
      }
      else
      {
        float v192 = v154;
      }
      do
      {
        int v193 = *((_DWORD *)v192 - 1);
        v192 -= 4;
        *((_DWORD *)v190 - 1) = v193;
        v190 -= 4;
      }
      while (v192 != v182);
      goto LABEL_221;
    }
LABEL_243:
    (*(void (**)(void, void **, void **))(**(void **)a1 + 16))(*(void *)a1, &__p, &v219);
    uint64_t v10 = a1;
    if (*((unsigned char *)a1 + 2528))
    {
      (*(void (**)(void **__return_ptr))(**(void **)a1 + 24))(v218);
      int v199 = v204;
      long long v120 = v208;
    }
    else
    {
      (*(void (**)(void **__return_ptr))(**(void **)a1 + 32))(v218);
      int v199 = v204;
      long long v120 = v208;
    }
    float v201 = v200;
    if (v218[0])
    {
      v218[1] = v218[0];
      operator delete(v218[0]);
    }
    if (!v203 || v201 > v32)
    {
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(&v234, (char *)__p, v223, (v223 - (unsigned char *)__p) >> 2);
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(&v231, (char *)v219, v220, (v220 - (unsigned char *)v219) >> 2);
      float v32 = v201;
    }
    if (v219)
    {
      int64x2_t v220 = (char *)v219;
      operator delete(v219);
    }
    if (__p)
    {
      simd_float2x2 v223 = (char *)__p;
      operator delete(__p);
    }
    int v203 = 1;
    if (v125) {
      goto LABEL_234;
    }
LABEL_235:
    if (v120) {
      operator delete(v120);
    }
    if (v225)
    {
      int8x16_t v226 = (char *)v225;
      operator delete(v225);
    }
    if (v228)
    {
      long long v229 = (char *)v228;
      operator delete(v228);
    }
    if (v35) {
      operator delete(v35);
    }
    int v30 = v199 + 1;
  }
  while (v30 < v10[2]);
  if (!v203) {
    goto LABEL_259;
  }
  (*(void (**)(void, void **, void **))(**(void **)v10 + 16))(*(void *)v10, &v234, &v231);
  uint64_t v19 = 1;
LABEL_260:
  if (v231)
  {
    long long v232 = v231;
    operator delete(v231);
  }
LABEL_262:
  if (v234)
  {
    long long v235 = v234;
    operator delete(v234);
  }
  return v19;
}

void sub_215F624E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30)
{
  float v32 = *(void **)(v30 - 152);
  if (v32)
  {
    *(void *)(v30 - 144) = v32;
    operator delete(v32);
    unsigned int v33 = *(void **)(v30 - 128);
    if (!v33) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    unsigned int v33 = *(void **)(v30 - 128);
    if (!v33) {
      goto LABEL_3;
    }
  }
  *(void *)(v30 - 120) = v33;
  operator delete(v33);
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::absoluteError(float **a1, void *a2, void *a3)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  uint64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    if (v5 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = a2;
    int32x2_t v9 = (float *)operator new(v3 - v4);
    uint64_t v10 = v9;
    uint64_t v11 = 0;
    int64_t v12 = &v9[v5 >> 2];
    *a1 = v9;
    a1[1] = v9;
    a1[2] = v12;
    if ((unint64_t)(v5 >> 2) <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = v5 >> 2;
    }
    uint64_t v14 = v9;
    uint64_t v30 = v8;
    int64_t v31 = a3;
    while (1)
    {
      float v16 = vabds_f32(*(float *)(*v8 + 4 * v11), *(float *)(*a3 + 4 * v11));
      if (v14 >= v12) {
        break;
      }
      float *v14 = v16;
      int64_t v15 = v14 + 1;
LABEL_8:
      a1[1] = v15;
      ++v11;
      uint64_t v14 = v15;
      if (v11 == v13) {
        return;
      }
    }
    uint64_t v17 = v14 - v10;
    unint64_t v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    if (((char *)v12 - (char *)v10) >> 1 > v18) {
      unint64_t v18 = ((char *)v12 - (char *)v10) >> 1;
    }
    if ((unint64_t)((char *)v12 - (char *)v10) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v18;
    }
    if (v19)
    {
      if (v19 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int64_t v20 = operator new(4 * v19);
    }
    else
    {
      int64_t v20 = 0;
    }
    unint64_t v21 = (float *)&v20[4 * v17];
    float *v21 = v16;
    int64_t v15 = v21 + 1;
    if (v14 == v10) {
      goto LABEL_24;
    }
    unint64_t v22 = (char *)(v14 - 1) - (char *)v10;
    if (v22 < 0xBC)
    {
      float32x4_t v23 = v14;
      goto LABEL_23;
    }
    if (&v20[(char *)v14 - (char *)v10 - 4 - (v22 & 0xFFFFFFFFFFFFFFFCLL)] > &v20[(char *)v14 - (char *)v10 - 4])
    {
      float32x4_t v23 = v14;
    }
    else
    {
      if ((float *)((char *)v14 - (v22 & 0xFFFFFFFFFFFFFFFCLL) - 4) <= v14 - 1)
      {
        if ((unint64_t)((char *)v10 - v20) < 0x20)
        {
          float32x4_t v23 = v14;
          goto LABEL_23;
        }
        uint64_t v25 = (v22 >> 2) + 1;
        float32x4_t v23 = &v14[-(v25 & 0x7FFFFFFFFFFFFFF8)];
        float32x4_t v26 = &v20[4 * v17 - 16];
        unint64_t v27 = v14 - 4;
        uint64_t v28 = v25 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v29 = *(_OWORD *)v27;
          *(v26 - 1) = *((_OWORD *)v27 - 1);
          _OWORD *v26 = v29;
          v26 -= 2;
          v27 -= 8;
          v28 -= 8;
        }
        while (v28);
        v21 -= v25 & 0x7FFFFFFFFFFFFFF8;
        if (v25 != (v25 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_23;
        }
LABEL_24:
        int64_t v12 = (float *)&v20[4 * v19];
        *a1 = v21;
        a1[1] = v15;
        a1[2] = v12;
        if (v10) {
          operator delete(v10);
        }
        uint64_t v10 = v21;
        uint64_t v8 = v30;
        a3 = v31;
        goto LABEL_8;
      }
      float32x4_t v23 = v14;
    }
    do
    {
LABEL_23:
      int v24 = *((_DWORD *)v23-- - 1);
      *((_DWORD *)v21-- - 1) = v24;
    }
    while (v23 != v10);
    goto LABEL_24;
  }
}

void sub_215F628F0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float anonymous namespace'::calculateRSquaredScore(float **a1, void *a2)
{
  long long v2 = a1;
  uint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  float v5 = 0.0;
  int64_t v6 = (char *)v3 - (char *)*a1;
  unint64_t v7 = v6 >> 2;
  if (!v6)
  {
    uint64_t v10 = 0;
    float v45 = 0.0;
    goto LABEL_47;
  }
  float v65 = v4;
  uint64_t v66 = v3;
  if (v6 < 0) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  int32x2_t v9 = (float32x4_t *)operator new(v6);
  uint64_t v10 = v9;
  uint64_t v11 = 0;
  if (v7 <= 1) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = v7;
  }
  uint64_t v13 = (float *)v9;
  uint64_t v14 = &v9->f32[v7];
  uint64_t v67 = v2;
  do
  {
    double v16 = (float)((*v2)[v11] - *(float *)(*a2 + 4 * v11));
    double v17 = v16 * v16;
    if (v13 < v14)
    {
      float v15 = v17;
      *v13++ = v15;
      goto LABEL_8;
    }
    uint64_t v18 = ((char *)v13 - (char *)v10) >> 2;
    unint64_t v19 = v18 + 1;
    if ((unint64_t)(v18 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    if (((char *)v14 - (char *)v10) >> 1 > v19) {
      unint64_t v19 = ((char *)v14 - (char *)v10) >> 1;
    }
    if ((unint64_t)((char *)v14 - (char *)v10) >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v19;
    }
    if (v20)
    {
      if (v20 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v21 = operator new(4 * v20);
    }
    else
    {
      unint64_t v21 = 0;
    }
    unint64_t v22 = (float *)&v21[4 * v18];
    float v23 = v17;
    float *v22 = v23;
    int v24 = v22 + 1;
    if (v13 != (float *)v10)
    {
      unint64_t v25 = (char *)(v13 - 1) - (char *)v10;
      if (v25 >= 0xBC)
      {
        if (&v21[(char *)v13 - (char *)v10 - 4 - (v25 & 0xFFFFFFFFFFFFFFFCLL)] > &v21[(char *)v13 - (char *)v10 - 4])
        {
          float32x4_t v26 = v13;
        }
        else if ((float *)((char *)v13 - (v25 & 0xFFFFFFFFFFFFFFFCLL) - 4) > v13 - 1)
        {
          float32x4_t v26 = v13;
        }
        else if ((unint64_t)((char *)v10 - v21) >= 0x20)
        {
          uint64_t v28 = (v25 >> 2) + 1;
          float32x4_t v26 = &v13[-(v28 & 0x7FFFFFFFFFFFFFF8)];
          long long v29 = &v21[4 * v18 - 16];
          uint64_t v30 = v13 - 4;
          uint64_t v31 = v28 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v32 = *(_OWORD *)v30;
            *(v29 - 1) = *((_OWORD *)v30 - 1);
            _OWORD *v29 = v32;
            v29 -= 2;
            v30 -= 8;
            v31 -= 8;
          }
          while (v31);
          v22 -= v28 & 0x7FFFFFFFFFFFFFF8;
          if (v28 == (v28 & 0x7FFFFFFFFFFFFFF8)) {
            goto LABEL_24;
          }
        }
        else
        {
          float32x4_t v26 = v13;
        }
      }
      else
      {
        float32x4_t v26 = v13;
      }
      do
      {
        int v27 = *((_DWORD *)v26-- - 1);
        *((_DWORD *)v22-- - 1) = v27;
      }
      while (v26 != (float *)v10);
    }
LABEL_24:
    uint64_t v14 = (float *)&v21[4 * v20];
    if (v10) {
      operator delete(v10);
    }
    uint64_t v10 = (float32x4_t *)v22;
    uint64_t v13 = v24;
    long long v2 = v67;
LABEL_8:
    ++v11;
  }
  while (v11 != v12);
  if (v10 == (float32x4_t *)v13)
  {
    float v45 = 0.0;
    uint64_t v4 = v65;
    uint64_t v3 = v66;
  }
  else
  {
    unint64_t v33 = (char *)v13 - (char *)v10 - 4;
    double v34 = 0.0;
    unint64_t v35 = (float *)v10;
    uint64_t v4 = v65;
    uint64_t v3 = v66;
    if (v33 < 0x1C)
    {
      do
      {
LABEL_43:
        float v44 = *v35++;
        double v34 = v34 + v44;
      }
      while (v35 != v13);
    }
    else
    {
      uint64_t v36 = (v33 >> 2) + 1;
      unsigned int v37 = v10 + 1;
      uint64_t v38 = v36 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v39 = v37[-1];
        float64x2_t v40 = vcvt_hight_f64_f32(v39);
        float64x2_t v41 = vcvtq_f64_f32(*(float32x2_t *)v39.f32);
        float64x2_t v42 = vcvt_hight_f64_f32(*v37);
        float64x2_t v43 = vcvtq_f64_f32(*(float32x2_t *)v37->f32);
        double v34 = v34
            + v41.f64[0]
            + v41.f64[1]
            + v40.f64[0]
            + v40.f64[1]
            + v43.f64[0]
            + v43.f64[1]
            + v42.f64[0]
            + v42.f64[1];
        v37 += 2;
        v38 -= 8;
      }
      while (v38);
      if (v36 != (v36 & 0x7FFFFFFFFFFFFFF8))
      {
        unint64_t v35 = &v10->f32[v36 & 0x7FFFFFFFFFFFFFF8];
        goto LABEL_43;
      }
    }
    float v45 = v34;
  }
LABEL_47:
  uint64_t v46 = *v2;
  uint64_t v47 = v2[1];
  if (*v2 != v47)
  {
    unint64_t v48 = (char *)v47 - (char *)v46 - 4;
    double v49 = 0.0;
    signed int v50 = *v2;
    if (v48 < 0x1C)
    {
      do
      {
LABEL_53:
        float v59 = *v50++;
        double v49 = v49 + v59;
      }
      while (v50 != v47);
    }
    else
    {
      uint64_t v51 = (v48 >> 2) + 1;
      unint64_t v52 = (float32x4_t *)(v46 + 4);
      uint64_t v53 = v51 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v54 = v52[-1];
        float64x2_t v55 = vcvt_hight_f64_f32(v54);
        float64x2_t v56 = vcvtq_f64_f32(*(float32x2_t *)v54.f32);
        float64x2_t v57 = vcvt_hight_f64_f32(*v52);
        float64x2_t v58 = vcvtq_f64_f32(*(float32x2_t *)v52->f32);
        double v49 = v49
            + v56.f64[0]
            + v56.f64[1]
            + v55.f64[0]
            + v55.f64[1]
            + v58.f64[0]
            + v58.f64[1]
            + v57.f64[0]
            + v57.f64[1];
        v52 += 2;
        v53 -= 8;
      }
      while (v53);
      if (v51 != (v51 & 0x7FFFFFFFFFFFFFF8))
      {
        signed int v50 = &v46[v51 & 0x7FFFFFFFFFFFFFF8];
        goto LABEL_53;
      }
    }
    float v5 = v49 / (double)(unint64_t)(v47 - v46);
  }
  if (v3 == v4)
  {
    float v63 = 0.0;
  }
  else
  {
    if (v7 <= 1) {
      uint64_t v60 = 1;
    }
    else {
      uint64_t v60 = v7;
    }
    float v61 = 0.0;
    do
    {
      float v62 = *v46++;
      float v61 = (float)(v62 - v5) * (float)(v62 - v5) + v61;
      --v60;
    }
    while (v60);
    float v63 = 0.0;
    if (v61 != 0.0) {
      float v63 = 1.0 - (float)(v45 / v61);
    }
  }
  if (v10) {
    operator delete(v10);
  }
  return v63;
}

void sub_215F62D3C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

float *std::__nth_element[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<float *>>(float *result, float *a2, float *a3)
{
  if (a3 != a2)
  {
    while (1)
    {
      unint64_t v3 = a3 - result;
      if (v3 < 2) {
        return result;
      }
      if (v3 == 3)
      {
        float v40 = *result;
        float v41 = result[1];
        float v42 = *(a3 - 1);
        if (v41 >= *result)
        {
          if (v42 < v41)
          {
            result[1] = v42;
            *(a3 - 1) = v41;
            float v52 = *result;
            float v51 = result[1];
            if (v51 < *result)
            {
              char *result = v51;
              result[1] = v52;
            }
          }
        }
        else if (v42 >= v41)
        {
          char *result = v41;
          result[1] = v40;
          float v53 = *(a3 - 1);
          if (v53 < v40)
          {
            result[1] = v53;
            *(a3 - 1) = v40;
          }
        }
        else
        {
          char *result = v42;
          *(a3 - 1) = v40;
        }
        return result;
      }
      if (v3 == 2)
      {
        float v38 = *(a3 - 1);
        float v39 = *result;
        if (v38 < *result)
        {
          char *result = v38;
          *(a3 - 1) = v39;
        }
        return result;
      }
      if ((char *)a3 - (char *)result <= 31)
      {
        while (result != a3 - 1)
        {
          float64x2_t v43 = result++;
          if (v43 != a3 && result != a3)
          {
            float v44 = *v43;
            float v45 = *v43;
            uint64_t v46 = result;
            uint64_t v47 = v43;
            unint64_t v48 = result;
            do
            {
              float v49 = *v48++;
              float v50 = v49;
              if (v49 < v45)
              {
                float v45 = v50;
                uint64_t v47 = v46;
              }
              uint64_t v46 = v48;
            }
            while (v48 != a3);
            if (v47 != v43)
            {
              float *v43 = *v47;
              *uint64_t v47 = v44;
            }
          }
        }
        return result;
      }
      uint64_t v4 = &result[v3 >> 1];
      float v5 = a3 - 1;
      float v6 = *(a3 - 1);
      float v7 = *v4;
      float v8 = *result;
      if (*v4 < *result) {
        break;
      }
      if (v6 < v7)
      {
        *uint64_t v4 = v6;
        *float v5 = v7;
        float v9 = *result;
        if (*v4 < *result)
        {
          char *result = *v4;
          *uint64_t v4 = v9;
LABEL_14:
          int v10 = 2;
          goto LABEL_17;
        }
        goto LABEL_15;
      }
      int v10 = 0;
LABEL_17:
      float v11 = *result;
      if (*result < *v4)
      {
LABEL_22:
        double v16 = result + 1;
        if (result + 1 >= v5)
        {
          unint64_t v19 = result + 1;
        }
        else
        {
          double v17 = result + 1;
          while (1)
          {
            float v18 = *v4;
            do
            {
              unint64_t v19 = v17;
              float v20 = *v17++;
              float v21 = v20;
            }
            while (v20 < v18);
            do
            {
              float v22 = *--v5;
              float v23 = v22;
            }
            while (v22 >= v18);
            if (v19 >= v5) {
              break;
            }
            float *v19 = v23;
            *float v5 = v21;
            ++v10;
            if (v4 == v19) {
              uint64_t v4 = v5;
            }
          }
        }
        if (v19 != v4)
        {
          float v24 = *v19;
          if (*v4 < *v19)
          {
            float *v19 = *v4;
            *uint64_t v4 = v24;
            ++v10;
          }
        }
        if (v19 == a2) {
          return result;
        }
        if (!v10)
        {
          if (v19 <= a2)
          {
            uint64_t v30 = v19 + 1;
            while (v30 != a3)
            {
              float v32 = *(v30 - 1);
              float v31 = *v30++;
              if (v31 < v32) {
                goto LABEL_37;
              }
            }
          }
          else
          {
            while (v16 != v19)
            {
              float v27 = *(v16 - 1);
              float v26 = *v16++;
              if (v26 < v27) {
                goto LABEL_37;
              }
            }
          }
          return result;
        }
LABEL_37:
        if (v19 <= a2)
        {
          unint64_t v25 = v19 + 1;
        }
        else
        {
          a3 = v19;
          unint64_t v25 = result;
        }
      }
      else
      {
        uint64_t v12 = a3 - 2;
        while (v12 != result)
        {
          uint64_t v13 = v12;
          float v14 = *v12--;
          float v15 = v14;
          if (v14 < *v4)
          {
            char *result = v15;
            float *v13 = v11;
            ++v10;
            float v5 = v13;
            goto LABEL_22;
          }
        }
        uint64_t v28 = result + 1;
        if (v11 >= *v5)
        {
          if (v28 == v5) {
            return result;
          }
          while (1)
          {
            float v29 = *v28;
            if (v11 < *v28) {
              break;
            }
            if (++v28 == v5) {
              return result;
            }
          }
          *v28++ = *v5;
          *float v5 = v29;
        }
        if (v28 == v5) {
          return result;
        }
        while (1)
        {
          float v33 = *result;
          do
          {
            unint64_t v25 = v28;
            float v34 = *v28++;
            float v35 = v34;
          }
          while (v33 >= v34);
          do
          {
            float v36 = *--v5;
            float v37 = v36;
          }
          while (v33 < v36);
          if (v25 >= v5) {
            break;
          }
          float *v25 = v37;
          *float v5 = v35;
        }
        if (v25 > a2) {
          return result;
        }
      }
      float result = v25;
      if (a3 == a2) {
        return result;
      }
    }
    if (v6 >= v7)
    {
      char *result = v7;
      *uint64_t v4 = v8;
      if (*v5 < v8)
      {
        *uint64_t v4 = *v5;
        *float v5 = v8;
        goto LABEL_14;
      }
    }
    else
    {
      char *result = v6;
      *float v5 = v8;
    }
LABEL_15:
    int v10 = 1;
    goto LABEL_17;
  }
  return result;
}

void DisparityToDepth::DisparityToDepthFitEstimator::~DisparityToDepthFitEstimator(DisparityToDepth::DisparityToDepthFitEstimator *this)
{
  uint64_t v2 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v4;
    operator delete(v4);
  }
}

{
  uint64_t v2;
  void *v3;
  void *v4;

  uint64_t v2 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v4;
    operator delete(v4);
  }
}

void *DisparityToDepth::RansacLine2DModel::RansacLine2DModel(void *this)
{
  *this = &unk_26C687680;
  this[1] = 0;
  return this;
}

{
  *this = &unk_26C687680;
  this[1] = 0;
  return this;
}

uint64_t DisparityToDepth::RansacLineModel::RansacLineModel(uint64_t this)
{
  *(void *)this = &unk_26C687630;
  *(_DWORD *)(this + 8) = 0;
  return this;
}

{
  *(void *)this = &unk_26C687630;
  *(_DWORD *)(this + 8) = 0;
  return this;
}

void DisparityToDepth::VioProjectionFactory::create()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void sub_215F6343C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*a13 + 40))();
  }
  MEMORY[0x2166C5D90](v13, 0x10A1C40AA26649ELL);
  _Unwind_Resume(a1);
}

void _ZZN16DisparityToDepth20VioProjectionFactory6createERK13simd_float3x3RKDv3_fNSt3__18functionIFNS7_6vectorI7CGPointNS7_9allocatorISA_EEEERKNS9_IS4_NSB_IS4_EEEEEEEEN17VioProjectionImpl7projectEPS5_m(float32x4_t *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, float32x4_t **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if (a3)
  {
    if (a3 >> 60) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = a3;
    float v9 = (float32x4_t *)operator new(16 * a3);
    *a4 = v9;
    a4[2] = &v9[v8];
    bzero(v9, 16 * a3);
    uint64_t v10 = 0;
    a4[1] = &v9[v8];
    float32x4_t v11 = a1[1];
    float32x4_t v12 = a1[2];
    float32x4_t v13 = a1[3];
    float32x4_t v14 = a1[4];
    float32x4_t v15 = (float32x4_t)vdupq_n_s32(0x447A0000u);
    do
    {
      v9[v10] = vmulq_f32(vaddq_f32(v14, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v11, COERCE_FLOAT(*(_OWORD *)(a2 + 16 * v10))), v12, *(float32x2_t *)(a2 + 16 * v10), 1), v13, *(float32x4_t *)(a2 + 16 * v10), 2)), v15);
      ++v10;
    }
    while (a3 != v10);
  }
  uint64_t v16 = a1[6].i64[1];
  if (!v16) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(void **__return_ptr))(*(void *)v16 + 48))(__p);
  if (a3)
  {
    uint64_t v17 = 0;
    do
    {
      *(float32x2_t *)v18.f32 = vcvt_f32_f64(*((float64x2_t *)__p[0] + v17));
      v18.i64[1] = vextq_s8((int8x16_t)(*a4)[v17], (int8x16_t)(*a4)[v17], 8uLL).u64[0];
      (*a4)[v17++] = v18;
    }
    while (a3 != v17);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_215F6361C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x2166C5D90);
}

void _ZZN16DisparityToDepth20VioProjectionFactory6createERK13simd_float3x3RKDv3_fNSt3__18functionIFNS7_6vectorI7CGPointNS7_9allocatorISA_EEEERKNS9_IS4_NSB_IS4_EEEEEEEEN17VioProjectionImplD0Ev(void *a1)
{
  *a1 = &unk_26C6877B0;
  uint64_t v1 = a1 + 10;
  uint64_t v2 = (void *)a1[13];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  JUMPOUT(0x2166C5D90);
}

void *_ZZN16DisparityToDepth20VioProjectionFactory6createERK13simd_float3x3RKDv3_fNSt3__18functionIFNS7_6vectorI7CGPointNS7_9allocatorISA_EEEERKNS9_IS4_NSB_IS4_EEEEEEEEN17VioProjectionImplD1Ev(void *a1)
{
  *a1 = &unk_26C6877B0;
  uint64_t v2 = a1 + 10;
  unint64_t v3 = (void *)a1[13];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  return a1;
}

void *DisparityToDepth::WorldPointsLRU::WorldPointsLRU(void *this, uint64_t a2)
{
  *this = a2;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

{
  *this = a2;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

void *DisparityToDepth::WorldPointsLRU::vector@<X0>(void *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v4 = (unsigned char *)this[1];
  unint64_t v3 = (unsigned char *)this[2];
  int64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    if (v5 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    float v6 = (char *)operator new(v3 - v4);
    *a2 = v6;
    float v7 = &v6[32 * (v5 >> 5)];
    a2[2] = v7;
    this = memcpy(v6, v4, v5);
    a2[1] = v7;
  }
  return this;
}

uint64_t DisparityToDepth::WorldPointsLRU::size(DisparityToDepth::WorldPointsLRU *this)
{
  return (uint64_t)(*((void *)this + 2) - *((void *)this + 1)) >> 5;
}

void sub_215F63A7C(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F63BB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F63DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F63EB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F642D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_215F64BB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Unwind_Resume(a1);
}

void sub_215F64F2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);

  _Unwind_Resume(a1);
}

void sub_215F6511C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F65200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_215F65588(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F65610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADLKTOpticalFlow;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F65838(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F65CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_215F65DD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F65EC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F66000(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F66134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F662D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F66404(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F664E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

double ADCommonUtils::calcRotationAngle(ADCommonUtils *this, simd_float3x3 *a2)
{
  float v3 = *((float *)this + 6);
  float v4 = *((float *)this + 10);
  float v7 = atan2f(v3, v4);
  float v6 = atan2f(-*((float *)this + 2), sqrtf((float)(v4 * v4) + (float)(v3 * v3)));
  atan2f(*((float *)this + 1), *(float *)this);
  return COERCE_DOUBLE(__PAIR64__(LODWORD(v6), LODWORD(v7)));
}

void ADCommonUtils::calcRotationAngle(ADCommonUtils *this@<X0>, _OWORD *a2@<X8>)
{
  long double v5 = *((double *)this + 6);
  long double v6 = *((double *)this + 10);
  long double v11 = atan2(v5, v6);
  long long __x = *(_OWORD *)this;
  long double v10 = atan2(-*((double *)this + 2), sqrt(v6 * v6 + v5 * v5));
  *(double *)&long long v7 = atan2(*((long double *)&__x + 1), *(long double *)&__x);
  *(long double *)&long long v8 = v11;
  *((long double *)&v8 + 1) = v10;
  *a2 = v8;
  a2[1] = v7;
}

__n128 ADCommonUtils::extrinsicsFromRotationTranslation(uint64_t a1)
{
  return *(__n128 *)a1;
}

__n128 ADCommonUtils::rotationFromExtrinsics(ADCommonUtils *this, const simd_float4x3 *a2)
{
  return *(__n128 *)this;
}

__n128 ADCommonUtils::translationFromExtrinsics(__n128 *this, const simd_float4x3 *a2)
{
  return this[3];
}

__n128 ADCommonUtils::matrixFromArrayColumnFirst(ADCommonUtils *this, NSArray *a2)
{
  uint64_t v2 = this;
  float v27 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:0];
  [v27 floatValue];
  unsigned int v28 = v3;
  float v26 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:1];
  [v26 floatValue];
  unsigned int v20 = v4;
  unint64_t v25 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:2];
  [v25 floatValue];
  unsigned int v19 = v5;
  float v24 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:3];
  [v24 floatValue];
  unsigned int v18 = v6;
  float v23 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:4];
  [v23 floatValue];
  float v22 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:5];
  [v22 floatValue];
  float v21 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:6];
  [v21 floatValue];
  long long v7 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:7];
  [v7 floatValue];
  long long v8 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:8];
  [v8 floatValue];
  float v9 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:9];
  [v9 floatValue];
  long double v10 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:10];
  [v10 floatValue];
  long double v11 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:11];
  [v11 floatValue];
  float32x4_t v12 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:12];
  [v12 floatValue];
  float32x4_t v13 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:13];
  [v13 floatValue];
  float32x4_t v14 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:14];
  [v14 floatValue];
  float32x4_t v15 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:15];
  [v15 floatValue];
  *(void *)&long long v16 = __PAIR64__(v20, v28);
  *((void *)&v16 + 1) = __PAIR64__(v18, v19);
  long long v29 = v16;

  return (__n128)v29;
}

void sub_215F66B68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,void *a33,void *a34)
{
  *(void *)(v44 - 112) = a1;

  _Unwind_Resume(*(_Unwind_Exception **)(v44 - 112));
}

void sub_215F66BFC(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BA8);
}

void sub_215F66C04(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BACLL);
}

void sub_215F66C0C(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BB0);
}

void sub_215F66C14(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BB4);
}

void sub_215F66C1C(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BB8);
}

void sub_215F66C24(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BC0);
}

void sub_215F66C2C(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BC8);
}

void sub_215F66C34(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BD0);
}

void sub_215F66C3C(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BD8);
}

void sub_215F66C44(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BE0);
}

void sub_215F66C4C(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66BE8);
}

__n128 ADCommonUtils::matrixFromArrayRowFirst(ADCommonUtils *this, NSArray *a2)
{
  uint64_t v2 = this;
  float v27 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:0];
  [v27 floatValue];
  unsigned int v28 = v3;
  float v26 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:4];
  [v26 floatValue];
  unsigned int v20 = v4;
  unint64_t v25 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:8];
  [v25 floatValue];
  unsigned int v19 = v5;
  float v24 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:12];
  [v24 floatValue];
  unsigned int v18 = v6;
  float v23 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:1];
  [v23 floatValue];
  float v22 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:5];
  [v22 floatValue];
  float v21 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:9];
  [v21 floatValue];
  long long v7 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:13];
  [v7 floatValue];
  long long v8 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:2];
  [v8 floatValue];
  float v9 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:6];
  [v9 floatValue];
  long double v10 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:10];
  [v10 floatValue];
  long double v11 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:14];
  [v11 floatValue];
  float32x4_t v12 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:3];
  [v12 floatValue];
  float32x4_t v13 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:7];
  [v13 floatValue];
  float32x4_t v14 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:11];
  [v14 floatValue];
  float32x4_t v15 = [(ADCommonUtils *)v2 objectAtIndexedSubscript:15];
  [v15 floatValue];
  *(void *)&long long v16 = __PAIR64__(v20, v28);
  *((void *)&v16 + 1) = __PAIR64__(v18, v19);
  long long v29 = v16;

  return (__n128)v29;
}

void sub_215F66F3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,void *a33,void *a34)
{
  *(void *)(v44 - 112) = a1;

  _Unwind_Resume(*(_Unwind_Exception **)(v44 - 112));
}

void sub_215F66FD0(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66F7CLL);
}

void sub_215F66FD8(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66F80);
}

void sub_215F66FE0(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66F84);
}

void sub_215F66FE8(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66F88);
}

void sub_215F66FF0(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66F8CLL);
}

void sub_215F66FF8(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66F94);
}

void sub_215F67000(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66F9CLL);
}

void sub_215F67008(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66FA4);
}

void sub_215F67010(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66FACLL);
}

void sub_215F67018(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66FB4);
}

void sub_215F67020(uint64_t a1)
{
  *(void *)(v1 - 112) = a1;
  JUMPOUT(0x215F66FBCLL);
}

double ADCommonUtils::extrinsicsFromFile(ADCommonUtils *this, const char *a2)
{
  *(void *)&double result = ADCommonUtils::extrinsics4x4FromFile(this, a2).n128_u64[0];
  return result;
}

__n128 ADCommonUtils::extrinsics4x4FromFile(ADCommonUtils *this, const char *a2)
{
  uint64_t v2 = [NSString stringWithUTF8String:this];
  unsigned int v3 = [v2 lowercaseString];
  int v4 = [v3 hasSuffix:@".json"];

  if (v4)
  {
    id v20 = 0;
    id v5 = [MEMORY[0x263EFF8F8] dataWithContentsOfFile:v2 options:1 error:&v20];
    id v6 = v20;
    if (v6)
    {
      long long v7 = v6;
      long long v8 = [v6 description];
      NSLog(&cfstr_FailedLoadingE.isa, v8);
LABEL_8:

      long long v18 = 0u;
      goto LABEL_9;
    }
    id v19 = 0;
    long long v8 = [MEMORY[0x263F08900] JSONObjectWithData:v5 options:4 error:&v19];
    id v12 = v19;
    long long v7 = v12;
    if (v12)
    {
      float32x4_t v13 = [v12 description];
      NSLog(&cfstr_FailedLoadingE.isa, v13);

      goto LABEL_8;
    }
    for (unint64_t i = 0; i < [v8 count]; ++i)
    {
      long long v16 = [v8 objectAtIndexedSubscript:i];
      [v16 floatValue];
      *((_DWORD *)v21 + i) = v17;
    }
  }
  else
  {
    id v5 = [MEMORY[0x263EFF8F8] dataWithContentsOfFile:v2];
    float v9 = (_OWORD *)[v5 bytes];
    long long v10 = v9[1];
    v21[0] = *v9;
    v21[1] = v10;
    long long v11 = v9[3];
    v21[2] = v9[2];
    v21[3] = v11;
  }

  long long v18 = v21[0];
LABEL_9:

  return (__n128)v18;
}

void sub_215F6721C(_Unwind_Exception *a1)
{
  id v6 = v5;

  _Unwind_Resume(a1);
}

uint64_t ADCommonUtils::extrinsicsToFile(ADCommonUtils *this, const char *a2, simd_float4x4 a3)
{
  a3.columns[0].i32[3] = 0;
  a3.columns[1].i32[3] = 0;
  a3.columns[2].i32[3] = 0;
  a3.columns[3].i32[3] = 1.0;
  return ADCommonUtils::extrinsicsToFile(this, a2, a3);
}

{
  void *v3;
  void *v4;
  int v5;
  void *v6;
  void *v7;
  double v8;
  void *v9;
  double v10;
  void *v11;
  double v12;
  void *v13;
  void *v14;
  double v15;
  void *v16;
  double v17;
  void *v18;
  double v19;
  void *v20;
  void *v21;
  double v22;
  void *v23;
  double v24;
  void *v25;
  double v26;
  void *v27;
  void *v28;
  double v29;
  void *v30;
  double v31;
  void *v32;
  double v33;
  void *v34;
  void *v35;
  id v36;
  id v37;
  void *v38;
  uint64_t v39;
  simd_float4 v41;
  simd_float4 v42;
  simd_float4 v43;
  simd_float4 v44;
  id v45;
  id v46;
  simd_float4x4 v47;

  float64x2_t v43 = a3.columns[1];
  uint64_t v44 = a3.columns[0];
  uint64_t v47 = a3;
  float v41 = a3.columns[3];
  float v42 = a3.columns[2];
  unsigned int v3 = [NSString stringWithUTF8String:this];
  int v4 = [v3 lowercaseString];
  id v5 = [v4 hasSuffix:@".json"];

  if (v5)
  {
    id v6 = objc_opt_new();
    long long v7 = [NSNumber numberWithFloat:*(double *)v44.i64];
    [v6 setObject:v7 atIndexedSubscript:0];

    LODWORD(v8) = v44.i32[1];
    float v9 = [NSNumber numberWithFloat:v8];
    [v6 setObject:v9 atIndexedSubscript:1];

    LODWORD(v10) = v44.i32[2];
    long long v11 = [NSNumber numberWithFloat:v10];
    [v6 setObject:v11 atIndexedSubscript:2];

    LODWORD(v12) = v44.i32[3];
    float32x4_t v13 = [NSNumber numberWithFloat:v12];
    [v6 setObject:v13 atIndexedSubscript:3];

    float32x4_t v14 = [NSNumber numberWithFloat:*(double *)v43.i64];
    [v6 setObject:v14 atIndexedSubscript:4];

    LODWORD(v15) = v43.i32[1];
    long long v16 = [NSNumber numberWithFloat:v15];
    [v6 setObject:v16 atIndexedSubscript:5];

    LODWORD(v17) = v43.i32[2];
    long long v18 = [NSNumber numberWithFloat:v17];
    [v6 setObject:v18 atIndexedSubscript:6];

    LODWORD(v19) = v43.i32[3];
    id v20 = [NSNumber numberWithFloat:v19];
    [v6 setObject:v20 atIndexedSubscript:7];

    float v21 = [NSNumber numberWithFloat:*(double *)v42.i64];
    [v6 setObject:v21 atIndexedSubscript:8];

    LODWORD(v22) = v42.i32[1];
    float v23 = [NSNumber numberWithFloat:v22];
    [v6 setObject:v23 atIndexedSubscript:9];

    LODWORD(v24) = v42.i32[2];
    unint64_t v25 = [NSNumber numberWithFloat:v24];
    [v6 setObject:v25 atIndexedSubscript:10];

    LODWORD(v26) = v42.i32[3];
    float v27 = [NSNumber numberWithFloat:v26];
    [v6 setObject:v27 atIndexedSubscript:11];

    unsigned int v28 = [NSNumber numberWithFloat:*(double *)v41.i64];
    [v6 setObject:v28 atIndexedSubscript:12];

    LODWORD(v29) = v41.i32[1];
    uint64_t v30 = [NSNumber numberWithFloat:v29];
    [v6 setObject:v30 atIndexedSubscript:13];

    LODWORD(v31) = v41.i32[2];
    float v32 = [NSNumber numberWithFloat:v31];
    [v6 setObject:v32 atIndexedSubscript:14];

    LODWORD(v33) = v41.i32[3];
    float v34 = [NSNumber numberWithFloat:v33];
    [v6 setObject:v34 atIndexedSubscript:15];

    uint64_t v46 = 0;
    float v35 = [MEMORY[0x263F08900] dataWithJSONObject:v6 options:1 error:&v46];
    float v36 = v46;
    float v37 = v36;
    if (v36)
    {
      float v38 = [v36 description];
      NSLog(&cfstr_FailedWritingE.isa, v38);
    }
    float v39 = [v35 writeToFile:v3 atomically:1];
  }
  else
  {
    id v6 = [MEMORY[0x263EFF8F8] dataWithBytes:&v47 length:64];
    float v45 = 0;
    float v39 = [v6 writeToFile:v3 options:1 error:&v45];
    float v37 = v45;
  }

  return v39;
}

void sub_215F676E8(_Unwind_Exception *a1)
{
  id v6 = v4;

  _Unwind_Resume(a1);
}

double ADCommonUtils::rotateSize(uint64_t a1, double a2, double a3)
{
  if ((a1 | 2) != 3) {
    return a2;
  }
  return a3;
}

uint64_t ADCommonUtils::reverseRotation(uint64_t a1)
{
  uint64_t v1 = 3;
  if (a1 != 1) {
    uint64_t v1 = a1;
  }
  if (a1 == 3) {
    return 1;
  }
  else {
    return v1;
  }
}

double ADCommonUtils::matrixForImageRotation(uint64_t a1)
{
  float v1 = 0.0;
  if ((unint64_t)(a1 - 1) <= 2) {
    float v1 = flt_215FC4794[a1 - 1];
  }
  __float2 v2 = __sincosf_stret(v1);
  *(float *)&double v3 = v2.__cosval;
  *((float *)&v3 + 1) = -v2.__sinval;
  return v3;
}

double ADCommonUtils::inverseTransform(ADCommonUtils *this, simd_float4x4 a2)
{
  *(void *)&double result = vzip1q_s32(vzip1q_s32((int32x4_t)a2.columns[0], (int32x4_t)a2.columns[2]), (int32x4_t)a2.columns[1]).u64[0];
  return result;
}

double ADCommonUtils::inverseTransform(ADCommonUtils *this, simd_float4x3 a2)
{
  *(void *)&double result = vzip1q_s32((int32x4_t)a2.columns[0], (int32x4_t)a2.columns[1]).u64[0];
  return result;
}

double ADCommonUtils::computeTransform(ADCommonUtils *this, simd_float4x3 a2, simd_float4x3 a3)
{
  float32x4_t v3 = (float32x4_t)vtrn2q_s32((int32x4_t)a2.columns[0], (int32x4_t)a2.columns[1]);
  v3.i32[2] = a2.columns[2].i32[1];
  *(void *)&double result = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a2.columns[0], (int32x4_t)a2.columns[2]), (int32x4_t)a2.columns[1]), a3.columns[0].f32[0]), v3, *(float32x2_t *)a3.columns[0].f32, 1), (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a2.columns[0], (int32x4_t)a2.columns[2]), vdupq_laneq_s32((int32x4_t)a2.columns[1], 2)), (float32x4_t)a3.columns[0], 2).u64[0];
  return result;
}

float ADCommonUtils::calculatePoseDistance(ADCommonUtils *this, simd_float4x4 a2, simd_float4x4 a3)
{
  int32x4_t v3 = vzip1q_s32((int32x4_t)a2.columns[0], (int32x4_t)a2.columns[2]);
  int32x4_t v4 = vzip2q_s32((int32x4_t)a2.columns[0], (int32x4_t)a2.columns[2]);
  float32x4_t v5 = (float32x4_t)vzip1q_s32(v3, (int32x4_t)a2.columns[1]);
  a2.columns[0] = (simd_float4)vtrn2q_s32((int32x4_t)a2.columns[0], (int32x4_t)a2.columns[1]);
  a2.columns[0].i32[2] = a2.columns[2].i32[1];
  float32x4_t v6 = (float32x4_t)vzip1q_s32(v4, vdupq_laneq_s32((int32x4_t)a2.columns[1], 2));
  float32x4_t v7 = (float32x4_t)vtrn2q_s32((int32x4_t)a3.columns[0], (int32x4_t)a3.columns[1]);
  v7.i32[2] = a3.columns[2].i32[1];
  float32x4_t v8 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)a3.columns[0], (int32x4_t)a3.columns[2]), (int32x4_t)a3.columns[1]);
  float32x4_t v9 = (float32x4_t)vzip1q_s32(vzip2q_s32((int32x4_t)a3.columns[0], (int32x4_t)a3.columns[2]), vdupq_laneq_s32((int32x4_t)a3.columns[1], 2));
  float32x4_t v10 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v5, (int32x4_t)v6), vdupq_laneq_s32(v3, 2));
  a2.columns[1] = (simd_float4)vtrn2q_s32((int32x4_t)v5, (int32x4_t)a2.columns[1]);
  a2.columns[1].i32[2] = v6.i32[1];
  a2.columns[2] = (simd_float4)vzip1q_s32(vzip2q_s32((int32x4_t)v5, (int32x4_t)v6), vdupq_lane_s32(*(int32x2_t *)a2.columns[2].f32, 1));
  float v11 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v10, a3.columns[0].f32[0]), (float32x4_t)a2.columns[1], a3.columns[1].f32[0]), (float32x4_t)a2.columns[2], a3.columns[2].f32[0]).f32[0];
  float32x4_t v12 = vmlaq_lane_f32(vmlaq_lane_f32(vmulq_lane_f32(v10, *(float32x2_t *)a3.columns[0].f32, 1), (float32x4_t)a2.columns[1], *(float32x2_t *)a3.columns[1].f32, 1), (float32x4_t)a2.columns[2], *(float32x2_t *)a3.columns[2].f32, 1);
  a3.columns[0] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v10, (float32x4_t)a3.columns[0], 2), (float32x4_t)a2.columns[1], (float32x4_t)a3.columns[1], 2), (float32x4_t)a2.columns[2], (float32x4_t)a3.columns[2], 2);
  float32x4_t v13 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5, a2.columns[3].f32[0]), (float32x4_t)a2.columns[0], *(float32x2_t *)a2.columns[3].f32, 1), v6, (float32x4_t)a2.columns[3], 2);
  double v14 = 3.0 - v11 - v12.f32[1] - a3.columns[0].f32[2];
  *(float *)&double v14 = (v14 + v14) / 3.0;
  float32x4_t v15 = vmulq_f32(vsubq_f32(v13, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v8, a3.columns[3].f32[0]), v7, *(float32x2_t *)a3.columns[3].f32, 1), v9, (float32x4_t)a3.columns[3], 2)), (float32x4_t)vdupq_n_s32(0x3A83126Fu));
  float32x4_t v16 = vmulq_f32(v15, v15);
  return vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0]+ *(float *)&v14;
}

void ADCommonUtils::extrinsicsToString(simd_float4x3 a1@<0:Q0, 16:Q1, 32:Q2, 48:Q3>, void *a2@<X8>)
{
  id v10 = [NSString stringWithFormat:@"R:[%.4f, %.4f, %.4f],[%.4f, %.4f, %.4f],[%.4f, %.4f, %.4f]. T:[%.4f, %.4f, %.4f]\n", a1.columns[0].f32[0], a1.columns[0].f32[1], a1.columns[0].f32[2], a1.columns[1].f32[0], a1.columns[1].f32[1], a1.columns[1].f32[2], a1.columns[2].f32[0], a1.columns[2].f32[1], a1.columns[2].f32[2], a1.columns[3].f32[0], a1.columns[3].f32[1], a1.columns[3].f32[2]];
  int32x4_t v4 = (const char *)[v10 UTF8String];
  size_t v5 = strlen(v4);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v7 = v5 | 7;
    }
    uint64_t v8 = v7 + 1;
    float32x4_t v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
    goto LABEL_8;
  }
  *((unsigned char *)a2 + 23) = v5;
  if (v5) {
LABEL_8:
  }
    memmove(a2, v4, v6);
  *((unsigned char *)a2 + v6) = 0;
}

void sub_215F67B40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

void ADCommonUtils::extrinsicsToString(simd_float4x4 a1@<0:Q0, 16:Q1, 32:Q2, 48:Q3>, void *a2@<X8>)
{
  id v10 = [NSString stringWithFormat:@"R:[%.4f, %.4f, %.4f, %.4f],[%.4f, %.4f, %.4f, %.4f],[%.4f, %.4f, %.4f, %.4f]. T:[%.4f, %.4f, %.4f, %.4f]\n", a1.columns[0].f32[0], a1.columns[0].f32[1], a1.columns[0].f32[2], a1.columns[0].f32[3], a1.columns[1].f32[0], a1.columns[1].f32[1], a1.columns[1].f32[2], a1.columns[1].f32[3], a1.columns[2].f32[0], a1.columns[2].f32[1], a1.columns[2].f32[2], a1.columns[2].f32[3], a1.columns[3].f32[0], a1.columns[3].f32[1], a1.columns[3].f32[2], a1.columns[3].f32[3]];
  int32x4_t v4 = (const char *)[v10 UTF8String];
  size_t v5 = strlen(v4);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v7 = v5 | 7;
    }
    uint64_t v8 = v7 + 1;
    float32x4_t v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
    goto LABEL_8;
  }
  *((unsigned char *)a2 + 23) = v5;
  if (v5) {
LABEL_8:
  }
    memmove(a2, v4, v6);
  *((unsigned char *)a2 + v6) = 0;
}

void sub_215F67CDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ADCommonUtils::intrinsicsToString(simd_float3x3 a1@<0:Q0, 16:Q1, 32:Q2>, void *a2@<X8>)
{
  objc_msgSend(NSString, "stringWithFormat:", @"eflx:%.3f efly:%.3f ppx:%.3f ppy:%.3f\n", a1.columns[0].f32[0], a1.columns[1].f32[1], a1.columns[2].f32[0], a1.columns[2].f32[1]);
  id v10 = objc_claimAutoreleasedReturnValue();
  int32x4_t v4 = (const char *)[v10 UTF8String];
  size_t v5 = strlen(v4);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v7 = v5 | 7;
    }
    uint64_t v8 = v7 + 1;
    float32x4_t v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
    goto LABEL_8;
  }
  *((unsigned char *)a2 + 23) = v5;
  if (v5) {
LABEL_8:
  }
    memmove(a2, v4, v6);
  *((unsigned char *)a2 + v6) = 0;
}

void sub_215F67DF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14)
{
  _Unwind_Resume(a1);
}

uint64_t ADCommonUtils::hashArray(ADCommonUtils *this, NSArray *a2)
{
  __float2 v2 = this;
  uint64_t v3 = [(ADCommonUtils *)v2 hash];
  for (uint64_t i = 1; i - 1 < (unint64_t)[(ADCommonUtils *)v2 count]; ++i)
  {
    size_t v5 = -[ADCommonUtils objectAtIndexedSubscript:](v2, "objectAtIndexedSubscript:");
    v3 ^= [v5 hash] * i;
  }
  return v3;
}

void sub_215F67E80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CGFloat ADCommonUtils::computeMaximalRoi(ADCommonUtils *this, CGSize a2, CGSize a3)
{
  double width = a2.height / (a3.height / a3.width);
  if (a2.width < width) {
    double width = a2.width;
  }
  return (a2.width - width) * 0.5;
}

Float64 ADCommonUtils::machTimeToSeconds(ADCommonUtils *this)
{
  memset(&v3, 0, sizeof(v3));
  CMClockMakeHostTimeFromSystemUnits(&v3, (uint64_t)this);
  CMTime v2 = v3;
  return CMTimeGetSeconds(&v2);
}

uint64_t ADCommonUtils::runtimePlatformHasANE(ADCommonUtils *this)
{
  return [MEMORY[0x263F28048] hasANE];
}

uint64_t ADCommonUtils::runtimePlatformANEVersionNumber(ADCommonUtils *this)
{
  ADCommonUtils::runtimePlatformANEVersionString(v4);
  if (v5 < 0)
  {
    CMTime v2 = (void *)v4[0];
    if (v4[1]) {
      uint64_t v1 = atoi((const char *)(v4[0] + 1));
    }
    else {
      uint64_t v1 = 0xFFFFFFFFLL;
    }
    operator delete(v2);
  }
  else if (v5)
  {
    return atoi((const char *)v4 + 1);
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void ADCommonUtils::espressoEngineAsString(uint64_t a1@<X0>, char *a2@<X8>)
{
  CMTime v2 = a2;
  switch(a1)
  {
    case 0:
      a2[23] = 3;
      *(_DWORD *)a2 = 5591107;
      return;
    case 1:
      a2[23] = 5;
      strcpy(a2, "METAL");
      return;
    case 2:
      a2[23] = 3;
      *(_DWORD *)a2 = 5460045;
      return;
    case 3:
      a2[23] = 16;
      strcpy(a2, "ANERuntimeDirect");
      return;
    case 4:
      a2[23] = 10;
      strcpy(a2, "ANERuntime");
      return;
    default:
      id v10 = [NSNumber numberWithUnsignedInteger:a1];
      id v3 = [v10 stringValue];
      int32x4_t v4 = (const char *)[v3 UTF8String];
      size_t v5 = strlen(v4);
      if (v5 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      size_t v6 = v5;
      if (v5 >= 0x17)
      {
        uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v5 | 7) != 0x17) {
          uint64_t v7 = v5 | 7;
        }
        uint64_t v8 = v7 + 1;
        float32x4_t v9 = (char *)operator new(v7 + 1);
        *((void *)v2 + 1) = v6;
        *((void *)v2 + 2) = v8 | 0x8000000000000000;
        *(void *)CMTime v2 = v9;
        CMTime v2 = v9;
      }
      else
      {
        v2[23] = v5;
        if (!v5) {
          goto LABEL_16;
        }
      }
      memmove(v2, v4, v6);
LABEL_16:
      v2[v6] = 0;

      return;
  }
}

void sub_215F68164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ADCommonUtils::runtimePlatformANEEnforceModelChecksDisabled(ADCommonUtils *this)
{
  return [MEMORY[0x263F28048] precompiledModelChecksDisabled];
}

__n128 AdjustCalibrationFocalLengthAndOpticalCenterX_Gradient@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X3>, double *a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  long long v9 = *(_OWORD *)(a4 + 112);
  a7[6] = *(_OWORD *)(a4 + 96);
  a7[7] = v9;
  a7[8] = *(_OWORD *)(a4 + 128);
  long long v10 = *(_OWORD *)(a4 + 16);
  long long v11 = *(_OWORD *)(a4 + 48);
  a7[2] = *(_OWORD *)(a4 + 32);
  a7[3] = v11;
  long long v12 = *(_OWORD *)(a4 + 80);
  a7[4] = *(_OWORD *)(a4 + 64);
  a7[5] = v12;
  *a7 = *(_OWORD *)a4;
  a7[1] = v10;
  *(void *)&long long v12 = *(void *)(a4 + 24);
  v29[0] = *(double *)(a4 + 16);
  *(void *)&v29[1] = v12;
  double v13 = *(double *)(a4 + 8);
  double v30 = *(double *)a4;
  double v31 = v13;
  double v14 = a5[4];
  double v15 = a5[5];
  v28[0] = v29[0] - v14;
  v28[1] = *(double *)&v12 - v15;
  double v16 = a5[2];
  double v17 = a5[3];
  v28[2] = v30 - v16;
  v28[3] = v13 - v17;
  v27[0] = v29[0] + v14;
  v27[1] = *(double *)&v12 + v15;
  v27[2] = v30 + v16;
  void v27[3] = v13 + v17;
  long long v25 = 0u;
  v24[0] = a1;
  v24[1] = a2;
  v24[2] = a3;
  v24[3] = a4;
  v19[2] = xmmword_215FC47C0;
  int v22 = unk_215FC47DC;
  uint64_t v23 = 0x3FB999999999999ALL;
  v19[0] = xmmword_215FC47A0;
  v19[1] = unk_215FC47B0;
  uint64_t v20 = 0;
  int v21 = 50;
  fmincon_spg((void (*)(void, void, void, void))CalcObjValGradForImagePoints, (void (*)(void, void, void))CalcObjValForImagePoints, (uint64_t)v24, (uint64_t)v29, 4, v28, v27, (double *)v19, v26, a6);
  *(unsigned char *)(a6 + 4) = 1;
  __n128 result = (__n128)v26[0];
  *a7 = v26[1];
  a7[1] = result;
  return result;
}

double CalcObjValForImagePoints(long long *a1, uint64_t a2, double *a3)
{
  id v3 = *(long long **)(a2 + 24);
  long long v4 = v3[7];
  long long v16 = v3[6];
  long long v17 = v4;
  long long v18 = v3[8];
  long long v5 = v3[3];
  long long v12 = v3[2];
  long long v13 = v5;
  long long v6 = v3[5];
  long long v14 = v3[4];
  long long v15 = v6;
  long long v7 = v3[1];
  long long v10 = *v3;
  long long v11 = v7;
  long long v8 = *a1;
  long long v10 = a1[1];
  long long v11 = v8;
  return FundamentalEpipolarError_MeanVal(*(void *)a2, *(void *)(a2 + 8), *(_DWORD *)(a2 + 16), (double *)&v10, a3);
}

double CalcObjValGradForImagePoints(long long *a1, uint64_t a2, double *a3, double *a4)
{
  long long v4 = *(long long **)(a2 + 24);
  long long v5 = v4[7];
  long long v17 = v4[6];
  long long v18 = v5;
  long long v19 = v4[8];
  long long v6 = v4[3];
  long long v13 = v4[2];
  long long v14 = v6;
  long long v7 = v4[5];
  long long v15 = v4[4];
  long long v16 = v7;
  long long v8 = v4[1];
  long long v11 = *v4;
  long long v12 = v8;
  long long v9 = *a1;
  long long v11 = a1[1];
  long long v12 = v9;
  return FundamentalEpipolarError_MeanValPlusGradient(*(void *)a2, *(void *)(a2 + 8), *(_DWORD *)(a2 + 16), &v11, a3, a4);
}

double AdjustCalibrationDistorted(uint64_t a1, uint64_t a2, unsigned int a3, double *a4, double *a5, double *a6, double *a7, uint64_t a8)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  double v12 = a6[1];
  double v13 = a6[2];
  double v14 = a6[3];
  v41[0] = *a6;
  v41[1] = v13;
  void v41[2] = v12;
  v41[3] = v14;
  double v15 = a4[2];
  double v42 = a4[1];
  double v43 = v15;
  double v16 = a5[1];
  double v17 = a5[2];
  double v44 = a4[3];
  double v45 = v16;
  double v18 = a5[3];
  double v46 = v17;
  double v47 = v18;
  double v19 = a7[2];
  double v20 = a7[3];
  double v21 = a7[4];
  double v22 = a7[5];
  v40[0] = v41[0] - v19;
  v40[1] = v13 - v21;
  v40[2] = v12 - v20;
  v40[3] = v14 - v22;
  v40[4] = v42 - v19;
  v40[5] = v15 - v21;
  v40[6] = v44 - v21;
  v40[7] = v16 - v20;
  v40[8] = v17 - v22;
  v40[9] = v18 - v22;
  v39[0] = v41[0] + v19;
  v39[1] = v13 + v21;
  v39[2] = v12 + v20;
  v39[3] = v14 + v22;
  v39[4] = v19 + v42;
  v39[5] = v21 + v15;
  v39[6] = v21 + v44;
  v39[7] = v20 + v16;
  v39[8] = v22 + v17;
  v39[9] = v22 + v18;
  v31[0] = a1;
  v31[1] = a2;
  v31[3] = a6;
  v31[2] = a3;
  v31[4] = a4;
  v31[5] = a5;
  _OWORD v26[2] = xmmword_215FC47C0;
  int v29 = unk_215FC47DC;
  uint64_t v30 = 0x3FB999999999999ALL;
  v26[0] = xmmword_215FC47A0;
  v26[1] = unk_215FC47B0;
  uint64_t v27 = 0;
  int v28 = 100;
  fmincon_spg((void (*)(void, void, void, void))CalcObjValGradForDistortedImagePoints, (void (*)(void, void, void))CalcObjValForDistortedImagePoints, (uint64_t)v31, (uint64_t)v41, 10, v40, v39, (double *)v26, &v32, a8);
  *(unsigned char *)(a8 + 4) = 1;
  uint64_t v23 = v34;
  *(void *)a6 = v32;
  *(int8x16_t *)(a6 + 1) = vextq_s8(v33, v33, 8uLL);
  *((void *)a6 + 3) = v23;
  *(_OWORD *)(a4 + 1) = v35;
  uint64_t v24 = v38;
  *((void *)a4 + 3) = v36;
  double result = *(double *)&v37;
  *(_OWORD *)(a5 + 1) = v37;
  *((void *)a5 + 3) = v24;
  return result;
}

double CalcObjValForDistortedImagePoints(uint64_t a1, uint64_t a2, double *a3, double a4, double a5, double a6, double a7, __n128 a8, double a9, double a10, __n128 a11)
{
  long long v11 = *(_OWORD **)(a2 + 24);
  double v12 = *(_OWORD **)(a2 + 32);
  double v13 = *(__n128 **)(a2 + 40);
  *(_OWORD *)float v49 = *v11;
  long long v14 = v11[1];
  long long v15 = v11[2];
  long long v16 = v11[4];
  long long v51 = v11[3];
  long long v52 = v16;
  *(_OWORD *)&v49[16] = v14;
  long long v50 = v15;
  long long v17 = v11[5];
  long long v18 = v11[6];
  long long v19 = v11[8];
  long long v55 = v11[7];
  long long v56 = v19;
  long long v53 = v17;
  long long v54 = v18;
  *(void *)&long long v17 = *(void *)a1;
  *(int8x16_t *)&v49[8] = vextq_s8(*(int8x16_t *)(a1 + 8), *(int8x16_t *)(a1 + 8), 8uLL);
  *(void *)&long long v18 = *(void *)(a1 + 24);
  *(void *)float v49 = v17;
  *(void *)&v49[24] = v18;
  long long v20 = v12[7];
  long long v45 = v12[6];
  long long v46 = v20;
  long long v21 = v12[9];
  long long v47 = v12[8];
  long long v48 = v21;
  long long v22 = v12[3];
  long long v41 = v12[2];
  long long v42 = v22;
  long long v23 = v12[5];
  long long v43 = v12[4];
  long long v44 = v23;
  long long v24 = v12[1];
  *(_OWORD *)float v40 = *v12;
  *(_OWORD *)&v40[16] = v24;
  *(_OWORD *)&v40[8] = *(_OWORD *)(a1 + 32);
  *(void *)&v40[24] = *(void *)(a1 + 48);
  __n128 v25 = v13[7];
  __n128 v36 = v13[6];
  __n128 v37 = v25;
  __n128 v26 = v13[9];
  __n128 v38 = v13[8];
  __n128 v39 = v26;
  __n128 v27 = v13[3];
  __n128 v32 = v13[2];
  __n128 v33 = v27;
  __n128 v28 = v13[5];
  __n128 v34 = v13[4];
  __n128 v35 = v28;
  __n128 v29 = v13[1];
  *(__n128 *)double v31 = *v13;
  *(__n128 *)&v31[16] = v29;
  *(_OWORD *)&v31[8] = *(_OWORD *)(a1 + 56);
  return FundamentalDistortionError_MeanVal(*(const double **)a2, *(const double **)(a2 + 8), *(_DWORD *)(a2 + 16), (double *)v40, (double *)v31, (uint64_t)v49, a3, *(double *)(a1 + 72), v29, *(double *)&v55, *(double *)&v19, a8, a9, a10, a11);
}

double *CalcObjValGradForDistortedImagePoints(uint64_t a1, uint64_t a2, double *a3, double *a4)
{
  long long v4 = *(_OWORD **)(a2 + 24);
  long long v5 = *(_OWORD **)(a2 + 32);
  long long v6 = *(_OWORD **)(a2 + 40);
  *(_OWORD *)long long v42 = *v4;
  long long v7 = v4[1];
  long long v8 = v4[2];
  long long v9 = v4[4];
  long long v44 = v4[3];
  long long v45 = v9;
  *(_OWORD *)&v42[16] = v7;
  long long v43 = v8;
  long long v10 = v4[5];
  long long v11 = v4[6];
  long long v12 = v4[8];
  long long v48 = v4[7];
  long long v49 = v12;
  long long v46 = v10;
  long long v47 = v11;
  *(void *)&long long v10 = *(void *)a1;
  *(int8x16_t *)&v42[8] = vextq_s8(*(int8x16_t *)(a1 + 8), *(int8x16_t *)(a1 + 8), 8uLL);
  *(void *)&long long v11 = *(void *)(a1 + 24);
  *(void *)long long v42 = v10;
  *(void *)&v42[24] = v11;
  long long v13 = v5[7];
  long long v38 = v5[6];
  long long v39 = v13;
  long long v14 = v5[9];
  long long v40 = v5[8];
  long long v41 = v14;
  long long v15 = v5[3];
  long long v34 = v5[2];
  long long v35 = v15;
  long long v16 = v5[5];
  long long v36 = v5[4];
  long long v37 = v16;
  long long v17 = v5[1];
  *(_OWORD *)__n128 v33 = *v5;
  *(_OWORD *)&v33[16] = v17;
  *(_OWORD *)&v33[8] = *(_OWORD *)(a1 + 32);
  *(void *)&v33[24] = *(void *)(a1 + 48);
  long long v18 = v6[7];
  long long v29 = v6[6];
  long long v30 = v18;
  long long v19 = v6[9];
  long long v31 = v6[8];
  long long v32 = v19;
  long long v20 = v6[3];
  long long v25 = v6[2];
  long long v26 = v20;
  long long v21 = v6[5];
  long long v27 = v6[4];
  long long v28 = v21;
  long long v22 = v6[1];
  *(_OWORD *)long long v24 = *v6;
  *(_OWORD *)&v24[16] = v22;
  *(_OWORD *)&v24[8] = *(_OWORD *)(a1 + 56);
  *(void *)&v24[24] = *(void *)(a1 + 72);
  return FundamentalDistortionError_MeanValPlusGradient(*(void *)a2, *(void *)(a2 + 8), *(_DWORD *)(a2 + 16), (double *)v33, (uint64_t)v24, (long long *)v42, a3, a4);
}

void dumpRawImageFile(uint64_t a1, const void *a2, size_t a3)
{
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
    if (!a2) {
      goto LABEL_12;
    }
  }
  else
  {
    std::string __p = *(std::string *)a1;
    if (!a2)
    {
LABEL_12:
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
      goto LABEL_13;
    }
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  long long v6 = fopen((const char *)p_p, "wb");
  if (v6)
  {
    fwrite(a2, 4uLL, a3, v6);
    fclose(v6);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_13;
  }
  if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
    goto LABEL_12;
  }
  *(_WORD *)buf = 0;
  _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Error dumping files. did you forget to set entitlements?", buf, 2u);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_13:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
}

{
  std::string *p_p;
  FILE *v6;
  std::string __p;
  uint8_t buf[16];

  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
    if (!a2) {
      goto LABEL_12;
    }
  }
  else
  {
    std::string __p = *(std::string *)a1;
    if (!a2)
    {
LABEL_12:
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
      goto LABEL_13;
    }
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  long long v6 = fopen((const char *)p_p, "wb");
  if (v6)
  {
    fwrite(a2, 1uLL, a3, v6);
    fclose(v6);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_13;
  }
  if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
    goto LABEL_12;
  }
  *(_WORD *)buf = 0;
  _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Error dumping files. did you forget to set entitlements?", buf, 2u);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_13:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
}

{
  std::string *p_p;
  FILE *v6;
  std::string __p;
  uint8_t buf[16];

  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
    if (!a2) {
      goto LABEL_12;
    }
  }
  else
  {
    std::string __p = *(std::string *)a1;
    if (!a2)
    {
LABEL_12:
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
      goto LABEL_13;
    }
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  long long v6 = fopen((const char *)p_p, "wb");
  if (v6)
  {
    fwrite(a2, 2uLL, a3, v6);
    fclose(v6);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_13;
  }
  if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
    goto LABEL_12;
  }
  *(_WORD *)buf = 0;
  _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "Error dumping files. did you forget to set entitlements?", buf, 2u);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_13:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_215F688DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  long long v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    long long v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    long long v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void sub_215F68AA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_215F68BD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void dumpTexture(const char *a1, void *a2)
{
  id v3 = a2;
  long long v4 = v3;
  if (v3)
  {
    unint64_t v5 = +[ADMetalUtils bytesPerPixelForTextureFormat:](ADMetalUtils, "bytesPerPixelForTextureFormat:", [v3 pixelFormat]);
    uint64_t v6 = [v4 width];
    uint64_t v7 = [v4 height];
    unint64_t v8 = v6 * v5;
    size_t v9 = v6 * v5 * v7;
    long long v10 = malloc_type_malloc(v9, 0xE7EBB413uLL);
    memset(v12, 0, 24);
    v12[3] = v6;
    v12[4] = v7;
    v12[5] = 1;
    [v4 getBytes:v10 bytesPerRow:v8 fromRegion:v12 mipmapLevel:0];
    if (a1[23] < 0) {
      a1 = *(const char **)a1;
    }
    long long v11 = fopen(a1, "wb");
    fwrite(v10, 1uLL, v9, v11);
    fclose(v11);
    free(v10);
  }
}

void sub_215F68CFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 AdjustYOpticalCenterForValidDistanceRange@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X3>, double *a5@<X4>, uint64_t a6@<X8>)
{
  double v7 = *(double *)(a4 + 40);
  int v8 = (int)a5[6];
  if (v8 < 0)
  {
    double v43 = *(double *)(a4 + 40);
  }
  else
  {
    double v9 = a5[10];
    double v10 = a5[11];
    int v11 = -v8;
    double v12 = a5[12];
    if ((int)a3 < 1)
    {
      double v113 = v12 * 0.0 + v9 * 0.0 + v10 * 0.0;
      int v114 = (2 * v8) | 1;
      double v115 = 1.79769313e308;
      double v116 = *(double *)(a4 + 40);
      double v117 = 1.79769313e308;
      do
      {
        double v43 = v7 + (double)v11;
        if (v113 < v115)
        {
          double v117 = -(v7 - v43);
          if (v7 - v43 >= 0.0) {
            double v117 = v7 - v43;
          }
          double v115 = v12 * 0.0 + v9 * 0.0 + v10 * 0.0;
        }
        else if (v113 == v115)
        {
          double v118 = v7 - v43;
          if (v7 - v43 < 0.0) {
            double v118 = -(v7 - v43);
          }
          if (v118 >= v117) {
            double v43 = v116;
          }
          else {
            double v117 = v118;
          }
        }
        else
        {
          double v43 = v116;
        }
        ++v11;
        double v116 = v43;
        --v114;
      }
      while (v114);
    }
    else
    {
      double v14 = *(double *)a4;
      double v13 = *(double *)(a4 + 8);
      double v15 = *(double *)(a4 + 16);
      double v16 = *(double *)(a4 + 32);
      double v18 = *(double *)(a4 + 80);
      double v17 = *(double *)(a4 + 88);
      double v19 = *(double *)(a4 + 112);
      double v20 = *(double *)(a4 + 120);
      double v21 = *(double *)(a4 + 136);
      double v23 = a5[7];
      double v22 = a5[8];
      uint64_t v24 = a3 & 7;
      if (!v24) {
        uint64_t v24 = 8;
      }
      uint64_t v25 = a3 - v24;
      double v26 = -v19;
      double v27 = -v20;
      double v28 = v16 * v20 + v19 * v15 + v14 * *(double *)(a4 + 128);
      double v29 = -(v14 * v13) * *(double *)(a4 + 96) - v13 * (v16 * v17 + v18 * v15);
      double v30 = -(v13 * *(double *)(a4 + 104));
      double v31 = 1.79769313e308;
      double v32 = v14 * v21 / 1.79769313e308 + v28;
      double v33 = v14 * v21 / v22 + v28;
      double v34 = v14 * v21 / v23 + v28;
      float64x2_t v139 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32, 0);
      float64x2_t v140 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(-v19), 0);
      long long v35 = (const double *)(a2 + 72);
      long long v36 = (const double *)(a1 + 64);
      int64x2_t v37 = vdupq_lane_s64(*(uint64_t *)&v34, 0);
      uint64_t v38 = a2 + 8;
      uint64_t v39 = a1 + 8;
      double v40 = *(double *)(a4 + 40);
      double v133 = 1.79769313e308;
      double v128 = a5[10];
      double v126 = a5[12];
      double v127 = a5[11];
      double v124 = a5[7];
      double v125 = a5[8];
      double v123 = -v19;
      double v122 = v28;
      double v131 = v30;
      double v132 = v29;
      double v120 = v33;
      double v121 = v32;
      double v119 = v34;
      float64x2_t v141 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v33, 0);
      double v146 = -v20;
      do
      {
        double v134 = v40;
        double v43 = v7 + (double)v11;
        *(double *)&long long v6 = v13 * v17 - v43 * v20;
        double v44 = v29 + v43 * v28;
        double v45 = v14 * (v30 + v43 * v21);
        double v46 = v45 / 1.79769313e308 + v44;
        double v47 = v45 / v22 + v44;
        double v48 = v45 / v23 + v44;
        double v137 = v46;
        double v138 = v13 * v18 - v43 * v19;
        double v135 = v48;
        double v136 = v47;
        if (a3 > 8)
        {
          double v129 = v31;
          double v130 = v7 + (double)v11;
          float64x2_t v144 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v46, 0);
          float64x2_t v145 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v13 * v18 - v43 * v19), 0);
          long long v147 = v6;
          int32x4_t v57 = 0uLL;
          float64x2_t v58 = v36;
          float v59 = v35;
          float64x2_t v142 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v48, 0);
          float64x2_t v143 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v47, 0);
          uint64_t v60 = v25;
          int32x4_t v61 = 0uLL;
          int32x4_t v62 = 0uLL;
          int32x4_t v63 = 0uLL;
          int32x4_t v64 = 0uLL;
          int32x4_t v65 = 0uLL;
          do
          {
            int32x4_t v148 = v57;
            uint64_t v66 = v58 - 8;
            float64x2x2_t v152 = vld2q_f64(v66);
            uint64_t v67 = v58 - 4;
            float64x2x2_t v149 = vld2q_f64(v67);
            float v68 = v58;
            float64x2x2_t v150 = vld2q_f64(v68);
            v68 += 4;
            float64x2x2_t v151 = vld2q_f64(v68);
            int64_t v69 = v59 - 8;
            unsigned long long v70 = (unsigned __int128)vld2q_f64(v69);
            long long v71 = v59 - 4;
            uint64_t v72 = v59;
            unsigned long long v73 = (unsigned __int128)vld2q_f64(v71);
            unsigned long long v74 = (unsigned __int128)vld2q_f64(v72);
            v72 += 4;
            float64x2_t v75 = vmlaq_f64(vmulq_n_f64(v152.val[1], *(double *)&v147), v152.val[0], v145);
            float64x2_t v76 = vmlaq_f64(vmulq_n_f64(v149.val[1], *(double *)&v147), v149.val[0], v145);
            float64x2_t v77 = vmlaq_f64(vmulq_n_f64(v151.val[1], *(double *)&v147), v151.val[0], v145);
            float64x2_t v78 = vmlaq_f64(vmulq_n_f64(v150.val[1], *(double *)&v147), v150.val[0], v145);
            float64x2_t v79 = (float64x2_t)v37;
            float64x2_t v80 = vmlaq_f64(vmulq_n_f64(v152.val[1], v146), v152.val[0], v140);
            float64x2_t v81 = vmlaq_f64(vmulq_n_f64(v149.val[1], v146), v149.val[0], v140);
            v149.val[0] = vmlaq_f64(vmulq_n_f64(v151.val[1], v146), v151.val[0], v140);
            v152.val[1] = vmlaq_f64(vmulq_n_f64(v150.val[1], v146), v150.val[0], v140);
            v149.val[1] = vdivq_f64(vaddq_f64(v144, v75), vaddq_f64(v139, v80));
            v151.val[1] = vdivq_f64(vaddq_f64(v144, v78), vaddq_f64(v139, v152.val[1]));
            v151.val[0] = vdivq_f64(vaddq_f64(v144, v76), vaddq_f64(v139, v81));
            v150.val[0] = vdivq_f64(vaddq_f64(v143, v75), vaddq_f64(v141, v80));
            v152.val[0] = vdivq_f64(vaddq_f64(v143, v76), vaddq_f64(v141, v81));
            v150.val[1] = vdivq_f64(vaddq_f64(v143, v78), vaddq_f64(v141, v152.val[1]));
            float64x2_t v82 = vaddq_f64(v79, v80);
            int64x2_t v37 = (int64x2_t)v79;
            float64x2_t v83 = vdivq_f64(vaddq_f64(v142, v75), v82);
            float64x2_t v84 = vdivq_f64(vaddq_f64(v142, v76), vaddq_f64(v79, v81));
            float64x2_t v85 = vdivq_f64(vaddq_f64(v144, v77), vaddq_f64(v139, v149.val[0]));
            float64x2_t v86 = vdivq_f64(vaddq_f64(v142, v78), vaddq_f64(v79, v152.val[1]));
            v152.val[1] = vdivq_f64(vaddq_f64(v143, v77), vaddq_f64(v141, v149.val[0]));
            int32x4_t v87 = (int32x4_t)vcgtq_f64(v151.val[0], (float64x2_t)v73);
            int32x4_t v88 = (int32x4_t)vcgtq_f64(v149.val[1], (float64x2_t)v70);
            int32x4_t v89 = (int32x4_t)vcgtq_f64(v151.val[1], (float64x2_t)v74);
            float64x2_t v90 = vdivq_f64(vaddq_f64(v142, v77), vaddq_f64(v79, v149.val[0]));
            v149.val[0] = (float64x2_t)vcgtq_f64(v150.val[1], (float64x2_t)v74);
            int32x4_t v91 = (int32x4_t)vcgtq_f64(v86, (float64x2_t)v74);
            unsigned long long v92 = (unsigned __int128)vld2q_f64(v72);
            v149.val[1] = (float64x2_t)vuzp1q_s32((int32x4_t)vcgtq_f64(v150.val[0], v149.val[1]), (int32x4_t)vcgtq_f64(v152.val[0], v151.val[0]));
            v151.val[0] = (float64x2_t)vuzp1q_s32((int32x4_t)vcgtq_f64(v150.val[1], v151.val[1]), (int32x4_t)vcgtq_f64(v152.val[1], v85));
            int32x4_t v64 = vsubq_s32(v64, (int32x4_t)vmvnq_s8(veorq_s8((int8x16_t)vuzp1q_s32(v88, v87), (int8x16_t)v149.val[1])));
            int32x4_t v62 = vsubq_s32(v62, (int32x4_t)veorq_s8((int8x16_t)v149.val[1], (int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_f64(v150.val[0], (float64x2_t)v70), (int32x4_t)vcgtq_f64(v152.val[0], (float64x2_t)v73))));
            int32x4_t v65 = vsubq_s32(v65, (int32x4_t)vmvnq_s8(veorq_s8((int8x16_t)vuzp1q_s32(v89, (int32x4_t)vcgtq_f64(v85, (float64x2_t)v92)), (int8x16_t)v151.val[0])));
            int32x4_t v63 = vsubq_s32(v63, (int32x4_t)veorq_s8((int8x16_t)v151.val[0], (int8x16_t)vuzp1q_s32((int32x4_t)v149.val[0], (int32x4_t)vcgtq_f64(v152.val[1], (float64x2_t)v92))));
            int32x4_t v93 = vsubq_s32(v148, (int32x4_t)veorq_s8((int8x16_t)v149.val[1], (int8x16_t)vuzp1q_s32((int32x4_t)vcgtq_f64(v83, (float64x2_t)v70), (int32x4_t)vcgtq_f64(v84, (float64x2_t)v73))));
            int32x4_t v57 = v93;
            int32x4_t v61 = vsubq_s32(v61, (int32x4_t)veorq_s8((int8x16_t)v151.val[0], (int8x16_t)vuzp1q_s32(v91, (int32x4_t)vcgtq_f64(v90, (float64x2_t)v92))));
            v59 += 16;
            v58 += 16;
            v60 -= 8;
          }
          while (v60);
          int v56 = vaddvq_s32(vaddq_s32(v65, v64));
          int v55 = vaddvq_s32(vaddq_s32(v63, v62));
          int v54 = vaddvq_s32(vaddq_s32(v61, v93));
          uint64_t v53 = v25;
          double v52 = v128;
          double v49 = *(double *)(a4 + 40);
          double v50 = v126;
          double v51 = v127;
          double v18 = *(double *)(a4 + 80);
          double v14 = *(double *)a4;
          double v31 = v129;
          double v43 = v130;
          double v19 = *(double *)(a4 + 112);
          double v17 = *(double *)(a4 + 88);
          double v21 = *(double *)(a4 + 136);
          double v20 = *(double *)(a4 + 120);
          double v23 = v124;
          double v22 = v125;
          double v26 = v123;
          double v27 = v146;
          long long v6 = v147;
          double v28 = v122;
          double v33 = v120;
          double v32 = v121;
          double v34 = v119;
        }
        else
        {
          double v49 = v7;
          double v50 = v12;
          double v51 = v10;
          double v52 = v9;
          uint64_t v53 = 0;
          int v54 = 0;
          int v55 = 0;
          int v56 = 0;
        }
        uint64_t v94 = a3 - v53;
        uint64_t v95 = 16 * v53;
        float32x4_t v96 = (double *)(v38 + 16 * v53);
        uint64_t v97 = (double *)(v39 + v95);
        do
        {
          double v98 = *(v97 - 1);
          double v99 = *v96;
          v96 += 2;
          double v100 = *v97 * *(double *)&v6 + v138 * v98;
          double v101 = *v97 * v27 + v26 * v98;
          double v102 = (v137 + v100) / (v32 + v101);
          double v103 = (v136 + v100) / (v33 + v101);
          BOOL v104 = v102 < v103;
          v56 += (v99 >= v102) ^ v104;
          v55 += v104 ^ (v99 < v103);
          v54 += v104 ^ (v99 < (v135 + v100) / (v34 + v101));
          v97 += 2;
          --v94;
        }
        while (v94);
        double v12 = v50;
        double v9 = v52;
        double v10 = v51;
        double v105 = v50 * (double)(v54 - v55) + (double)v56 * v52 + (double)v55 * v51;
        if (v105 < v31)
        {
          double v7 = v49;
          double v41 = v49 - v43;
          if (v49 - v43 < 0.0) {
            double v41 = -(v49 - v43);
          }
          double v133 = v41;
          double v31 = v105;
        }
        else
        {
          double v7 = v49;
          if (v105 == v31)
          {
            double v106 = v49 - v43;
            if (v49 - v43 < 0.0) {
              double v106 = -(v49 - v43);
            }
            double v107 = v133;
            BOOL v108 = v106 < v133;
            if (v106 < v133) {
              double v107 = v106;
            }
            double v133 = v107;
            if (!v108) {
              double v43 = v134;
            }
          }
          else
          {
            double v43 = v134;
          }
        }
        double v29 = v132;
        double v13 = *(double *)(a4 + 8);
        double v30 = v131;
        double v40 = v43;
      }
      while (v11++ != v8);
    }
  }
  long long v109 = *(_OWORD *)(a4 + 112);
  *(_OWORD *)(a6 + 96) = *(_OWORD *)(a4 + 96);
  *(_OWORD *)(a6 + 112) = v109;
  *(_OWORD *)(a6 + 128) = *(_OWORD *)(a4 + 128);
  long long v110 = *(_OWORD *)(a4 + 48);
  *(_OWORD *)(a6 + 32) = *(_OWORD *)(a4 + 32);
  *(_OWORD *)(a6 + 48) = v110;
  long long v111 = *(_OWORD *)(a4 + 80);
  *(_OWORD *)(a6 + 64) = *(_OWORD *)(a4 + 64);
  *(_OWORD *)(a6 + 80) = v111;
  __n128 result = *(__n128 *)(a4 + 16);
  *(_OWORD *)a6 = *(_OWORD *)a4;
  *(__n128 *)(a6 + 16) = result;
  *(double *)(a6 + 40) = v43;
  return result;
}

void sub_215F69530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_215F6972C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F699A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F69B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  double v13 = v12;

  _Unwind_Resume(a1);
}

void sub_215F69BD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  double v12 = v11;

  _Unwind_Resume(a1);
}

void sub_215F69C54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F69CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F69D30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F69DA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F69E18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F69EDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F69F80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F6A0EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADStereoExecutor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F6A874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, void *a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v7);

  _Unwind_Resume(a1);
}

void sub_215F6AB4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_215F6ABC4()
{
}

void sub_215F6AD24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F6AFA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F6B068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADFlowFrameInput;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F6B200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADFlowFrameOutput;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

double CalcDirectZPlaneHomographyAtoBCoords(double *a1, double *a2, double a3)
{
  double v3 = a1[1];
  double v4 = a1[2];
  double v5 = a1[3];
  double v6 = a1[4];
  double v7 = a1[5];
  double v8 = a1[6];
  double v9 = a1[7];
  double v10 = a1[10];
  double v11 = a1[11];
  double v12 = a1[14];
  double v13 = a1[15];
  double v14 = a1[17];
  double v15 = v3 * v8 - v5 * v12;
  double v16 = v3 * v10 - v7 * v12;
  double v17 = v3 * v9 - v5 * v13;
  double v18 = v3 * v11 - v7 * v13;
  double v19 = v6 * v9 + v8 * v4;
  double v20 = -(*a1 * v3);
  double v21 = v6 * v13 + v12 * v4 + *a1 * a1[16];
  double v22 = *a1 * (v5 * v14 - v3 * a1[9]) / a3 + v20 * a1[8] - v3 * v19 + v5 * v21;
  double v23 = *a1 * (v7 * v14 - v3 * a1[13]) / a3 + v20 * a1[12] - v3 * (v6 * v11 + v10 * v4) + v7 * v21;
  double v24 = *a1 * v14;
  *a2 = v15;
  a2[1] = v17;
  a2[2] = v22;
  a2[3] = v16;
  a2[4] = v18;
  a2[5] = v23;
  double result = v24 / a3 + v21;
  a2[6] = -v12;
  a2[7] = -v13;
  a2[8] = result;
  return result;
}

double *FundamentalDistortionError_MeanValPlusGradient(uint64_t a1, uint64_t a2, int a3, double *a4, uint64_t a5, long long *a6, double *a7, double *a8)
{
  double v555 = 0.0;
  long long v554 = 0u;
  long long v553 = 0u;
  long long v552 = 0u;
  long long v551 = 0u;
  long long v550 = 0u;
  long long v549 = 0u;
  long long v548 = 0u;
  long long v547 = 0u;
  long long v546 = 0u;
  long long v545 = 0u;
  long long v544 = 0u;
  long long v543 = 0u;
  long long v542 = 0u;
  long long v541 = 0u;
  long long v540 = 0u;
  long long v539 = 0u;
  long long v16 = a6[7];
  v538[6] = a6[6];
  v538[7] = v16;
  v538[8] = a6[8];
  long long v17 = a6[3];
  v538[2] = a6[2];
  v538[3] = v17;
  long long v18 = a6[4];
  v538[5] = a6[5];
  v538[4] = v18;
  long long v19 = *a6;
  v538[1] = a6[1];
  v538[0] = v19;
  double result = FundamentalEpipolarError_precomputeFundamental((double *)v538, 1, (uint64_t)&v539);
  if (a1 && a2 && a3 >= 1 && a6 && a7 && a8)
  {
    uint64_t v25 = *((uint64_t *)a4 + 18);
    uint64_t v24 = *((uint64_t *)a4 + 19);
    uint64_t v26 = *(uint64_t *)(a5 + 136);
    double v27 = a4[1] * *a4;
    uint64_t v440 = *((uint64_t *)a4 + 12);
    double v28 = a4[4] + v27 * *(double *)&v440;
    double v515 = a4[13];
    double v29 = a4[5] + v27 * v515;
    uint64_t v439 = *((uint64_t *)a4 + 14);
    double v30 = a4[6] + v27 * *(double *)&v439;
    uint64_t v438 = *((uint64_t *)a4 + 15);
    double v31 = a4[7] + v27 * *(double *)&v438;
    uint64_t v437 = *((uint64_t *)a4 + 16);
    double v32 = a4[8] + v27 * *(double *)&v437;
    uint64_t v436 = *((uint64_t *)a4 + 17);
    double v33 = a4[9] + v27 * *(double *)&v436;
    double v34 = a4[10] + v27 * *(double *)&v25;
    double v35 = a4[11] + v27 * *(double *)&v24;
    double v36 = *(double *)(a5 + 8) * *(double *)a5;
    uint64_t v435 = *(uint64_t *)(a5 + 96);
    double v37 = *(double *)(a5 + 32) + v36 * *(double *)&v435;
    double v517 = *(double *)(a5 + 104);
    uint64_t v434 = *(uint64_t *)(a5 + 112);
    double v38 = *(double *)(a5 + 48) + v36 * *(double *)&v434;
    uint64_t v433 = *(uint64_t *)(a5 + 120);
    double v39 = *(double *)(a5 + 56) + v36 * *(double *)&v433;
    uint64_t v432 = *(uint64_t *)(a5 + 128);
    double v40 = *(double *)(a5 + 64) + v36 * *(double *)&v432;
    double v41 = *(double *)(a5 + 72) + v36 * *(double *)&v26;
    uint64_t v42 = *(uint64_t *)(a5 + 144);
    uint64_t v43 = *(uint64_t *)(a5 + 152);
    double v44 = *(double *)(a5 + 80) + v36 * *(double *)&v42;
    double v45 = *(double *)(a5 + 88) + v36 * *(double *)&v43;
    double v518 = v30 * 4.0;
    double v505 = v38 * 4.0;
    double v431 = v31 * 6.0;
    double v430 = v39 * 6.0;
    double v429 = v32 * 8.0;
    double v428 = v33 * 10.0;
    double v427 = v34 * 12.0;
    double v426 = v35 * 14.0;
    double v425 = v45 * 14.0;
    *(void *)&long long v23 = *(void *)(a5 + 16);
    double v520 = *a4;
    double v504 = -(v520 * v520);
    double v503 = -(*(double *)a5 * *(double *)a5);
    double v424 = v29 + v29;
    double v516 = *(double *)(a5 + 40) + v36 * v517;
    double v423 = v516 + v516;
    uint64_t v510 = *((uint64_t *)a4 + 2);
    double v509 = -*(double *)&v510;
    uint64_t v46 = *((uint64_t *)a4 + 3);
    double v506 = -*(double *)&v46;
    long long v404 = v23;
    uint64_t v405 = *(uint64_t *)(a5 + 24);
    double v508 = -*(double *)&v23;
    double v507 = -*(double *)&v405;
    *(void *)&long long v21 = v543;
    *(void *)&long long v22 = v544;
    long long v403 = v22;
    double v519 = v29;
    double v422 = v28;
    double v421 = v30;
    double v420 = v31;
    double v419 = v32;
    double v418 = v33;
    double v417 = v34;
    double v416 = v35;
    double v415 = v37;
    double v414 = v38;
    double v412 = v40;
    double v413 = v39;
    double v411 = v41;
    double v410 = v44;
    double v408 = v40 * 8.0;
    double v409 = v45;
    double v406 = v44 * 12.0;
    double v407 = v41 * 10.0;
    double v502 = *(double *)&v46;
    double v521 = *(double *)a5;
    if (a3 > 3)
    {
      float64x2_t v401 = (float64x2_t)vdupq_lane_s64(v46, 0);
      float64x2_t v402 = (float64x2_t)vdupq_lane_s64(v510, 0);
      float64x2_t v399 = (float64x2_t)vdupq_lane_s64(v405, 0);
      float64x2_t v400 = (float64x2_t)vdupq_lane_s64(v23, 0);
      float64x2_t v501 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v28, 0);
      float64x2_t v500 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v30, 0);
      float64x2_t v499 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v31, 0);
      float64x2_t v498 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32, 0);
      float64x2_t v497 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v33, 0);
      float64x2_t v496 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v34, 0);
      float64x2_t v495 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v35, 0);
      float64x2_t v494 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v37, 0);
      float64x2_t v398 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v38, 0);
      float64x2_t v493 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v39, 0);
      float64x2_t v397 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v40, 0);
      float64x2_t v492 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v41, 0);
      float64x2_t v491 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v44, 0);
      float64x2_t v395 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v539 + 1), 0);
      float64x2_t v396 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v45, 0);
      long long v356 = v21;
      float64x2_t v393 = (float64x2_t)vdupq_lane_s64(v540, 0);
      float64x2_t v394 = (float64x2_t)vdupq_lane_s64(v539, 0);
      float64x2_t v391 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v541 + 1), 0);
      float64x2_t v392 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v540 + 1), 0);
      float64x2_t v389 = (float64x2_t)vdupq_lane_s64(v542, 0);
      float64x2_t v390 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v542 + 1), 0);
      float64x2_t v490 = (float64x2_t)vdupq_lane_s64(v440, 0);
      float64x2_t v489 = (float64x2_t)vdupq_lane_s64(v439, 0);
      float64x2_t v488 = (float64x2_t)vdupq_lane_s64(v438, 0);
      float64x2_t v487 = (float64x2_t)vdupq_lane_s64(v437, 0);
      uint64_t v47 = a3 & 0xFFFFFFFC;
      float64x2_t v387 = (float64x2_t)vdupq_lane_s64(v436, 0);
      float64x2_t v388 = (float64x2_t)vdupq_lane_s64(v543, 0);
      float64x2_t v486 = (float64x2_t)vdupq_lane_s64(v25, 0);
      int32x4_t v65 = (const double *)(a2 + 32);
      uint64_t v66 = (const double *)(a1 + 32);
      float64x2_t v485 = (float64x2_t)vdupq_lane_s64(v24, 0);
      float64x2_t v385 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v431, 0);
      float64x2_t v386 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v424, 0);
      float64x2_t v383 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v428, 0);
      float64x2_t v384 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v429, 0);
      float64x2_t v381 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v426, 0);
      float64x2_t v382 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v427, 0);
      float64x2_t v484 = (float64x2_t)vdupq_lane_s64(v435, 0);
      float64x2_t v483 = (float64x2_t)vdupq_lane_s64(v434, 0);
      float64x2_t v482 = (float64x2_t)vdupq_lane_s64(v433, 0);
      float64x2_t v481 = (float64x2_t)vdupq_lane_s64(v432, 0);
      float64x2_t v379 = (float64x2_t)vdupq_lane_s64(v42, 0);
      float64x2_t v380 = (float64x2_t)vdupq_lane_s64(v26, 0);
      float64x2_t v480 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v423, 0);
      float64x2_t v479 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v430, 0);
      float64x2_t v377 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v40 * 8.0), 0);
      float64x2_t v378 = (float64x2_t)vdupq_lane_s64(v43, 0);
      float64x2_t v478 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v41 * 10.0), 0);
      float64x2_t v477 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v44 * 12.0), 0);
      uint64_t v67 = v47;
      float64x2_t v476 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v425, 0);
      double v54 = 0.0;
      float64x2_t v375 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v506, 0);
      float64x2_t v376 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v509, 0);
      float64x2_t v373 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v507, 0);
      float64x2_t v374 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v508, 0);
      double v55 = 0.0;
      double v52 = 0.0;
      float64x2_t v371 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v547 + 1), 0);
      float64x2_t v372 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v546 + 1), 0);
      double v48 = 0.0;
      float64x2_t v369 = (float64x2_t)vdupq_lane_s64(v549, 0);
      float64x2_t v370 = (float64x2_t)vdupq_lane_s64(v548, 0);
      double v49 = 0.0;
      float64x2_t v367 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v550 + 1), 0);
      float64x2_t v368 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v549 + 1), 0);
      double v50 = 0.0;
      float64x2_t v365 = (float64x2_t)vdupq_lane_s64(v552, 0);
      float64x2_t v366 = (float64x2_t)vdupq_lane_s64(v551, 0);
      double v53 = 0.0;
      float64x2_t v363 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v553 + 1), 0);
      float64x2_t v364 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v552 + 1), 0);
      float64x2_t v361 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v555, 0);
      float64x2_t v362 = (float64x2_t)vdupq_lane_s64(v554, 0);
      double v62 = 0.0;
      double v64 = 0.0;
      float64x2_t v359 = (float64x2_t)vdupq_lane_s64(v546, 0);
      float64x2_t v360 = (float64x2_t)vdupq_lane_s64(v545, 0);
      double v63 = 0.0;
      double v51 = 0.0;
      float64x2_t v357 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v544 + 1), 0);
      float64x2_t v358 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v543 + 1), 0);
      do
      {
        double v522 = v52;
        double v532 = v53;
        double v536 = v54;
        double v528 = v49;
        double v526 = v48;
        double v529 = v64;
        double v524 = v55;
        double v530 = v51;
        double v474 = v62;
        double v475 = v63;
        double v534 = v50;
        float v68 = v66 - 4;
        float64x2x2_t v559 = vld2q_f64(v68);
        float64x2x2_t v557 = vld2q_f64(v66);
        float64x2_t v511 = vsubq_f64(v557.val[0], v402);
        float64x2_t v69 = vsubq_f64(v559.val[0], v402);
        float64x2_t v70 = vsubq_f64(v559.val[1], v401);
        float64x2_t v513 = vsubq_f64(v557.val[1], v401);
        float64x2_t v71 = vmulq_n_f64(vsqrtq_f64(vmlaq_f64(vmulq_f64(v70, v70), v69, v69)), v520);
        float64x2_t v72 = vmulq_n_f64(vsqrtq_f64(vmlaq_f64(vmulq_f64(v513, v513), v511, v511)), v520);
        float64x2_t v455 = vmulq_f64(v72, v72);
        float64x2_t v73 = vmulq_f64(v71, v71);
        float64x2_t v74 = vmulq_f64(v71, v73);
        float64x2_t v75 = vmulq_f64(v71, v74);
        float64x2_t v76 = vmulq_f64(v71, v75);
        float64x2_t v77 = vmulq_f64(v71, v76);
        float64x2_t v78 = vmulq_f64(v71, v77);
        float64x2_t v79 = vmulq_f64(v71, v78);
        float64x2_t v80 = vmulq_f64(v71, v79);
        float64x2_t v81 = vmlaq_f64(vaddq_f64(v501, vmulq_n_f64(v73, v29)), v75, v500);
        float64x2_t v82 = vmulq_f64(v71, v80);
        float64x2_t v83 = vmlaq_f64(vaddq_f64(v490, vmulq_n_f64(v73, v515)), v75, v489);
        float64x2_t v84 = vmulq_f64(v71, v82);
        float64x2_t v85 = vmulq_f64(v71, v84);
        float64x2_t v86 = vmulq_f64(v71, v85);
        float64x2_t v87 = vmlaq_f64(vmlaq_f64(vmlaq_f64(v81, v77, v499), v79, v498), v82, v497);
        float64x2_t v88 = vmlaq_f64(vmlaq_f64(vmlaq_f64(v83, v77, v488), v79, v487), v82, v387);
        float64x2_t v89 = vmulq_f64(v71, v86);
        float64x2_t v90 = vmlaq_f64(vmlaq_f64(v87, v85, v496), v89, v495);
        float64x2_t v91 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
        float64x2_t v92 = vmlaq_f64(vmlaq_f64(v88, v85, v486), v89, v485);
        float64x2_t v452 = vmulq_f64(v72, v455);
        __asm { FMOV            V8.2D, #1.0 }
        float64x2_t v98 = vdivq_f64(_Q8, vaddq_f64(vdivq_f64(v90, v91), _Q8));
        float64x2_t v99 = vsubq_f64(_Q8, v98);
        float64x2_t v100 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmulq_n_f64(v74, v518), v71, v386), v76, v385), v78, v384), v80, v383), v84, v382), v86, v381);
        float64x2_t v101 = vaddq_f64(v90, v91);
        float64x2_t v472 = vmlaq_f64(vmulq_n_f64(v99, *(double *)&v510), v559.val[0], v98);
        float64x2_t v442 = (float64x2_t)vdupq_n_s64(0xC059000000000000);
        float64x2_t v102 = vdivq_f64(v442, vmulq_f64(v101, v101));
        float64x2_t v103 = vmulq_f64(vmulq_n_f64(v92, v520), v102);
        float64x2_t v470 = vmlaq_f64(vmulq_n_f64(v99, v502), v559.val[1], v98);
        float64x2_t v104 = vmulq_f64(vmulq_f64(vdivq_f64(vmulq_n_f64(v69, v504), v71), v100), v102);
        float64x2_t v105 = vmulq_f64(vmulq_f64(vdivq_f64(vmulq_n_f64(v70, v504), v71), v100), v102);
        float64x2_t v466 = vmlaq_f64(vmulq_n_f64(v103, v509), v559.val[0], v103);
        float64x2_t v462 = vmlaq_f64(vmulq_n_f64(v103, v506), v559.val[1], v103);
        float64x2_t v464 = vmlaq_f64(vmlaq_f64(v99, v104, v376), v559.val[0], v104);
        float64x2_t v460 = vmlaq_f64(vmulq_n_f64(v104, v506), v559.val[1], v104);
        float64x2_t v458 = vmlaq_f64(vmulq_n_f64(v105, v509), v559.val[0], v105);
        float64x2_t v468 = vmlaq_f64(vmlaq_f64(v99, v105, v375), v559.val[1], v105);
        float64x2_t v106 = vmulq_f64(v72, v452);
        float64x2_t v107 = vmulq_f64(v72, v106);
        float64x2_t v108 = vmlaq_f64(vaddq_f64(v501, vmulq_n_f64(v455, v519)), v106, v500);
        float64x2_t v109 = vmlaq_f64(vaddq_f64(v490, vmulq_n_f64(v455, v515)), v106, v489);
        float64x2_t v110 = vmulq_f64(v72, v107);
        float64x2_t v111 = vmlaq_f64(v108, v110, v499);
        float64x2_t v112 = vmlaq_f64(v109, v110, v488);
        float64x2_t v113 = vmulq_f64(v72, v110);
        float64x2_t v114 = vmulq_f64(v72, v113);
        float64x2_t v115 = vmlaq_f64(v111, v114, v498);
        float64x2_t v116 = vmlaq_f64(v112, v114, v487);
        float64x2_t v117 = vmulq_f64(v72, v114);
        float64x2_t v118 = vmulq_f64(v72, v117);
        float64x2_t v119 = vmlaq_f64(v115, v118, v497);
        float64x2_t v120 = vmlaq_f64(v116, v118, v387);
        float64x2_t v121 = vmulq_f64(v72, v118);
        float64x2_t v122 = vmulq_f64(v72, v121);
        float64x2_t v123 = vmlaq_f64(v119, v122, v496);
        float64x2_t v124 = vdivq_f64(vmulq_n_f64(v511, v504), v72);
        float64x2_t v125 = vmlaq_f64(v120, v122, v486);
        float64x2_t v126 = vmulq_f64(v72, v122);
        float64x2_t v127 = vdivq_f64(vmulq_n_f64(v513, v504), v72);
        float64x2_t v128 = vmlaq_f64(vmulq_n_f64(v452, v518), v72, v386);
        float64x2_t v129 = vmulq_f64(v72, v126);
        float64x2_t v130 = vmlaq_f64(v123, v129, v495);
        float64x2_t v131 = vmlaq_f64(vmlaq_f64(vmlaq_f64(v128, v107, v385), v113, v384), v117, v383);
        float64x2_t v132 = vdivq_f64(_Q8, vaddq_f64(vdivq_f64(v130, v91), _Q8));
        float64x2_t v133 = vsubq_f64(_Q8, v132);
        float64x2_t v134 = vmlaq_f64(vmlaq_f64(v131, v121, v382), v126, v381);
        float64x2_t v514 = vmlaq_f64(vmulq_n_f64(v133, *(double *)&v510), v557.val[0], v132);
        float64x2_t v135 = vaddq_f64(v130, v91);
        float64x2_t v512 = vmlaq_f64(vmulq_n_f64(v133, v502), v557.val[1], v132);
        float64x2_t v136 = vdivq_f64(v442, vmulq_f64(v135, v135));
        float64x2_t v137 = vmulq_f64(vmulq_n_f64(vmlaq_f64(v125, v129, v485), v520), v136);
        float64x2_t v138 = vmulq_f64(vmulq_f64(v124, v134), v136);
        float64x2_t v139 = vmulq_f64(vmulq_f64(v127, v134), v136);
        float64x2_t v456 = vmlaq_f64(vmulq_n_f64(v137, v509), v557.val[0], v137);
        float64x2_t v453 = vmlaq_f64(vmulq_n_f64(v137, v506), v557.val[1], v137);
        float64x2_t v451 = vmlaq_f64(vmlaq_f64(v133, v138, v376), v557.val[0], v138);
        float64x2_t v449 = vmlaq_f64(vmulq_n_f64(v138, v506), v557.val[1], v138);
        float64x2_t v450 = vmlaq_f64(vmulq_n_f64(v139, v509), v557.val[0], v139);
        float64x2_t v140 = vmlaq_f64(vmlaq_f64(v133, v139, v375), v557.val[1], v139);
        float64x2_t v141 = v65 - 4;
        float64x2x2_t v558 = vld2q_f64(v141);
        float64x2_t v142 = vsubq_f64(v558.val[1], v399);
        float64x2_t v143 = vsubq_f64(v558.val[0], v400);
        float64x2_t v144 = vmulq_n_f64(vsqrtq_f64(vmlaq_f64(vmulq_f64(v142, v142), v143, v143)), v521);
        float64x2_t v145 = vmulq_f64(v144, v144);
        float64x2_t v146 = vmulq_f64(v144, v145);
        float64x2_t v147 = vmulq_f64(v144, v146);
        float64x2_t v148 = vmlaq_f64(vaddq_f64(v494, vmulq_n_f64(v145, v516)), v147, v398);
        float64x2_t v149 = vmlaq_f64(vaddq_f64(v484, vmulq_n_f64(v145, v517)), v147, v483);
        float64x2_t v150 = vmulq_f64(v144, v147);
        float64x2_t v151 = vmlaq_f64(vmlaq_f64(vmulq_n_f64(v146, v505), v144, v480), v150, v479);
        float64x2_t v152 = vmulq_f64(v144, v150);
        float64x2_t v153 = vmlaq_f64(v148, v152, v493);
        float64x2_t v154 = vmlaq_f64(v149, v152, v482);
        float64x2_t v155 = vmulq_f64(v144, v152);
        float64x2_t v156 = vmlaq_f64(v151, v155, v377);
        float64x2_t v157 = vmulq_f64(v144, v155);
        float64x2_t v158 = vmlaq_f64(v153, v157, v397);
        float64x2_t v159 = vmlaq_f64(v154, v157, v481);
        float64x2_t v160 = vmulq_f64(v144, v157);
        float64x2_t v161 = vmlaq_f64(v156, v160, v478);
        float64x2_t v162 = vmulq_f64(v144, v160);
        float64x2_t v163 = vmlaq_f64(v158, v162, v492);
        float64x2_t v164 = vmlaq_f64(v159, v162, v380);
        float64x2_t v165 = vmulq_f64(v144, v162);
        v559.val[0] = vmulq_f64(v144, v165);
        float64x2_t v166 = vmlaq_f64(v163, v559.val[0], v491);
        float64x2_t v167 = vmlaq_f64(v164, v559.val[0], v379);
        v559.val[0] = vmulq_f64(v144, v559.val[0]);
        float64x2_t v168 = vdivq_f64(vmulq_n_f64(v143, v503), v144);
        float64x2_t v169 = vdivq_f64(vmulq_n_f64(v142, v503), v144);
        float64x2_t v170 = vmulq_f64(v144, v559.val[0]);
        float64x2_t v171 = vmlaq_f64(v166, v170, v396);
        float64x2_t v172 = vmlaq_f64(v167, v170, v378);
        float64x2_t v173 = vmlaq_f64(vmlaq_f64(v161, v165, v477), v559.val[0], v476);
        float64x2_t v174 = vmulq_f64(v168, v173);
        float64x2_t v175 = vmulq_f64(v169, v173);
        float64x2_t v176 = vdivq_f64(_Q8, vaddq_f64(vdivq_f64(v171, v91), _Q8));
        float64x2_t v177 = vsubq_f64(_Q8, v176);
        v559.val[0] = vmlaq_f64(vmulq_n_f64(v177, *(double *)&v404), v558.val[0], v176);
        float64x2_t v178 = vmlaq_f64(vmulq_n_f64(v177, *(double *)&v405), v558.val[1], v176);
        float64x2_t v179 = vmulq_n_f64(v172, v521);
        float64x2_t v180 = vaddq_f64(v171, v91);
        float64x2_t v181 = vdivq_f64(v442, vmulq_f64(v180, v180));
        float64x2_t v182 = vmulq_f64(v179, v181);
        float64x2_t v183 = vmulq_f64(v174, v181);
        float64x2_t v184 = vmulq_f64(v175, v181);
        float64x2_t v448 = vmlaq_f64(vmulq_n_f64(v182, v508), v558.val[0], v182);
        float64x2_t v447 = vmlaq_f64(vmulq_n_f64(v182, v507), v558.val[1], v182);
        float64x2_t v446 = vmlaq_f64(vmlaq_f64(v177, v183, v374), v558.val[0], v183);
        float64x2_t v445 = vmlaq_f64(vmulq_n_f64(v183, v507), v558.val[1], v183);
        float64x2_t v444 = vmlaq_f64(vmulq_n_f64(v184, v508), v558.val[0], v184);
        float64x2_t v185 = vmlaq_f64(vmlaq_f64(v177, v184, v373), v558.val[1], v184);
        float64x2x2_t v556 = vld2q_f64(v65);
        float64x2_t v186 = vsubq_f64(v556.val[0], v400);
        float64x2_t v187 = vsubq_f64(v556.val[1], v399);
        float64x2_t v188 = vmulq_n_f64(vsqrtq_f64(vmlaq_f64(vmulq_f64(v187, v187), v186, v186)), v521);
        float64x2_t v189 = vmulq_f64(v188, v188);
        v558.val[1] = vmulq_f64(v188, v189);
        float64x2_t v190 = vmulq_f64(v188, v558.val[1]);
        v558.val[0] = vmlaq_f64(vaddq_f64(v494, vmulq_n_f64(v189, v516)), v190, v398);
        float64x2_t v191 = vmlaq_f64(vaddq_f64(v484, vmulq_n_f64(v189, v517)), v190, v483);
        float64x2_t v192 = vmulq_f64(v188, v190);
        v558.val[1] = vmlaq_f64(vmlaq_f64(vmulq_n_f64(v558.val[1], v505), v188, v480), v192, v479);
        float64x2_t v193 = vmulq_f64(v188, v192);
        v558.val[0] = vmlaq_f64(v558.val[0], v193, v493);
        float64x2_t v194 = vmlaq_f64(v191, v193, v482);
        float64x2_t v195 = vmulq_f64(v188, v193);
        float64x2_t v196 = vmulq_f64(v188, v195);
        v558.val[0] = vmlaq_f64(v558.val[0], v196, v397);
        float64x2_t v197 = vmlaq_f64(v194, v196, v481);
        float64x2_t v198 = vmulq_f64(v188, v196);
        float64x2_t v199 = vmulq_f64(v188, v198);
        v558.val[0] = vmlaq_f64(v558.val[0], v199, v492);
        float64x2_t v200 = vmlaq_f64(v197, v199, v380);
        float64x2_t v201 = vmulq_f64(v188, v199);
        float64x2_t v202 = vmulq_f64(v188, v201);
        v558.val[0] = vmlaq_f64(v558.val[0], v202, v491);
        float64x2_t v203 = vmlaq_f64(v200, v202, v379);
        float64x2_t v204 = vmulq_f64(v188, v202);
        float64x2_t v205 = vdivq_f64(vmulq_n_f64(v186, v503), v188);
        float64x2_t v206 = vdivq_f64(vmulq_n_f64(v187, v503), v188);
        float64x2_t v207 = vmulq_f64(v188, v204);
        v558.val[0] = vmlaq_f64(v558.val[0], v207, v396);
        float64x2_t v208 = vmlaq_f64(v203, v207, v378);
        v558.val[1] = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(v558.val[1], v195, v377), v198, v478), v201, v477), v204, v476);
        float64x2_t v209 = vdivq_f64(_Q8, vaddq_f64(vdivq_f64(v558.val[0], v91), _Q8));
        float64x2_t v210 = vsubq_f64(_Q8, v209);
        float64x2_t v211 = vmlaq_f64(vmulq_n_f64(v210, *(double *)&v404), v556.val[0], v209);
        float64x2_t v212 = vmlaq_f64(vmulq_n_f64(v210, *(double *)&v405), v556.val[1], v209);
        float64x2_t v213 = vmulq_f64(v205, v558.val[1]);
        float64x2_t v214 = vmulq_f64(v206, v558.val[1]);
        float64x2_t v215 = vaddq_f64(v558.val[0], v91);
        float64x2_t v216 = vdivq_f64(v442, vmulq_f64(v215, v215));
        float64x2_t v217 = vmulq_f64(vmulq_n_f64(v208, v521), v216);
        float64x2_t v218 = vmulq_f64(v213, v216);
        float64x2_t v219 = vmulq_f64(v214, v216);
        v558.val[0] = vmlaq_f64(vmulq_n_f64(v217, v508), v556.val[0], v217);
        float64x2_t v220 = vmlaq_f64(vmulq_n_f64(v217, v507), v556.val[1], v217);
        v558.val[1] = vmlaq_f64(vmlaq_f64(v210, v218, v374), v556.val[0], v218);
        float64x2_t v221 = vmlaq_f64(vmulq_n_f64(v218, v507), v556.val[1], v218);
        float64x2_t v222 = vmlaq_f64(vmulq_n_f64(v219, v508), v556.val[0], v219);
        float64x2_t v223 = vmlaq_f64(vmlaq_f64(v210, v219, v373), v556.val[1], v219);
        v556.val[0] = vaddq_f64(v389, vmlaq_f64(vmulq_n_f64(v178, *((double *)&v540 + 1)), v394, v559.val[0]));
        v556.val[1] = vaddq_f64(v390, vmlaq_f64(vmulq_n_f64(v178, *(double *)&v541), v395, v559.val[0]));
        float64x2_t v443 = vmlaq_f64(vmulq_f64(v462, v556.val[1]), v466, v556.val[0]);
        float64x2_t v441 = vmlaq_f64(vmulq_f64(v460, v556.val[1]), v464, v556.val[0]);
        float64x2_t v459 = vmlaq_f64(vmulq_f64(v468, v556.val[1]), v458, v556.val[0]);
        float64x2_t v224 = vaddq_f64(v389, vmlaq_f64(vmulq_n_f64(v212, *((double *)&v540 + 1)), v394, v211));
        v556.val[1] = vaddq_f64(v390, vmlaq_f64(vmulq_n_f64(v212, *(double *)&v541), v395, v211));
        float64x2_t v469 = vmlaq_f64(vmulq_f64(v453, v556.val[1]), v456, v224);
        float64x2_t v467 = vmlaq_f64(vmulq_f64(v449, v556.val[1]), v451, v224);
        float64x2_t v465 = vmlaq_f64(vmulq_f64(v140, v556.val[1]), v450, v224);
        float64x2_t v225 = vaddq_f64(v393, vmlaq_f64(vmulq_n_f64(v512, *((double *)&v539 + 1)), v514, v394));
        float64x2_t v226 = vaddq_f64(v391, vmlaq_f64(vmulq_n_f64(v512, *(double *)&v541), v514, v392));
        float64x2_t v463 = vmlaq_f64(vmulq_f64(v220, v226), v225, v558.val[0]);
        float64x2_t v461 = vmlaq_f64(vmulq_f64(v221, v226), v225, v558.val[1]);
        float64x2_t v457 = vmlaq_f64(vmulq_f64(v223, v226), v225, v222);
        float64x2_t v227 = vmlaq_f64(vmulq_f64(v212, v226), v225, v211);
        v559.val[1] = vmlaq_f64(vmulq_n_f64(v470, *((double *)&v542 + 1)), v472, v389);
        float64x2_t v228 = vmlaq_f64(vmulq_n_f64(v470, *(double *)&v547), v472, v372);
        float64x2_t v229 = vmlaq_f64(vmulq_n_f64(v470, *((double *)&v548 + 1)), v472, v370);
        float64x2_t v230 = vmlaq_f64(vmulq_n_f64(v470, *(double *)&v550), v472, v368);
        float64x2_t v231 = vmlaq_f64(vmulq_n_f64(v470, *((double *)&v551 + 1)), v472, v366);
        v558.val[0] = vmlaq_f64(vmulq_n_f64(v470, *(double *)&v553), v472, v364);
        v558.val[1] = vmlaq_f64(vmulq_n_f64(v470, *((double *)&v554 + 1)), v472, v362);
        float64x2_t v232 = vmlaq_f64(vmulq_n_f64(v470, *((double *)&v545 + 1)), v472, v360);
        float64x2_t v233 = vaddq_f64(v393, vmlaq_f64(vmulq_n_f64(v470, *((double *)&v539 + 1)), v472, v394));
        float64x2_t v234 = vaddq_f64(v391, vmlaq_f64(vmulq_n_f64(v470, *(double *)&v541), v472, v392));
        float64x2_t v473 = vmlaq_f64(vmulq_f64(v447, v234), v233, v448);
        float64x2_t v454 = vmlaq_f64(vmulq_f64(v445, v234), v233, v446);
        float64x2_t v471 = vmlaq_f64(vmulq_f64(v185, v234), v233, v444);
        float64x2_t v235 = vmlaq_f64(vmulq_f64(v178, v234), v233, v559.val[0]);
        float64x2_t v236 = vaddq_f64(vaddq_f64(v388, vmlaq_f64(vmulq_n_f64(v512, *((double *)&v542 + 1)), v514, v389)), v227);
        long long v61 = v403;
        float64x2_t v237 = vaddq_f64(vaddq_f64(v367, vmlaq_f64(vmulq_n_f64(v512, *(double *)&v550), v514, v368)), vmlaq_f64(vmulq_f64(v212, vaddq_f64(v369, vmlaq_f64(vmulq_n_f64(v512, *((double *)&v548 + 1)), v514, v370))), vaddq_f64(v371, vmlaq_f64(vmulq_n_f64(v512, *(double *)&v547), v514, v372)), v211));
        float64x2_t v238 = vmlaq_f64(vmulq_f64(v178, vaddq_f64(v363, v558.val[0])), vaddq_f64(v365, v231), v559.val[0]);
        float64x2_t v239 = vaddq_f64(vaddq_f64(v388, v559.val[1]), v235);
        float64x2_t v240 = vmlaq_f64(vmulq_n_f64(v212, *(double *)&v403), v358, v211);
        v556.val[0] = vaddq_f64(vmlaq_f64(vmulq_f64(v212, vaddq_f64(v363, vmlaq_f64(vmulq_n_f64(v512, *(double *)&v553), v514, v364))), vaddq_f64(v365, vmlaq_f64(vmulq_n_f64(v512, *((double *)&v551 + 1)), v514, v366)), v211), vaddq_f64(v361, vmlaq_f64(vmulq_n_f64(v512, *((double *)&v554 + 1)), v514, v362)));
        float64x2_t v241 = (float64x2_t)vdupq_n_s64(0x3ECC4BE7CE3F6732uLL);
        float64x2_t v242 = vsqrtq_f64(vmlaq_f64(v241, v239, v239));
        float64x2_t v243 = vdivq_f64(v239, v242);
        v556.val[1] = vmulq_f64(vaddq_f64(vaddq_f64(v367, v230), vmlaq_f64(vmulq_f64(v178, vaddq_f64(v369, v229)), vaddq_f64(v371, v228), v559.val[0])), v243);
        v559.val[0] = vmulq_f64(vaddq_f64(v357, vmlaq_f64(vmulq_n_f64(v178, *(double *)&v403), v358, v559.val[0])), v243);
        float64x2_t v244 = vmulq_f64(v243, vaddq_f64(v238, vaddq_f64(v361, v558.val[1])));
        float64x2_t v245 = vmulq_f64(v243, vaddq_f64(v359, v232));
        v559.val[1] = vmulq_f64(v443, v243);
        float64x2_t v246 = vmulq_f64(v441, v243);
        float64x2_t v247 = vmulq_f64(v459, v243);
        float64x2_t v248 = vmulq_f64(v473, v243);
        float64x2_t v249 = vmulq_f64(v454, v243);
        float64x2_t v250 = vmulq_f64(v471, v243);
        float64x2_t v251 = vsqrtq_f64(vmlaq_f64(v241, v236, v236));
        float64x2_t v252 = vdivq_f64(v236, v251);
        float64x2_t v253 = vmulq_f64(v237, v252);
        float64x2_t v254 = vmulq_f64(vaddq_f64(v357, v240), v252);
        v556.val[0] = vmulq_f64(v252, v556.val[0]);
        float64x2_t v255 = vmulq_f64(v252, vaddq_f64(v359, vmlaq_f64(vmulq_n_f64(v512, *((double *)&v545 + 1)), v514, v360)));
        float64x2_t v256 = vmulq_f64(v469, v252);
        float64x2_t v257 = vmulq_f64(v467, v252);
        float64x2_t v258 = vmulq_f64(v465, v252);
        float64x2_t v259 = vmulq_f64(v463, v252);
        float64x2_t v260 = vmulq_f64(v461, v252);
        float64x2_t v261 = vmulq_f64(v457, v252);
        double v54 = v536 + v242.f64[0] + v242.f64[1] + v251.f64[0] + v251.f64[1];
        v252.f64[0] = v522 + v559.val[0].f64[0] + v559.val[0].f64[1];
        double v55 = v524 + v556.val[1].f64[0] + v556.val[1].f64[1] + v253.f64[0] + v253.f64[1];
        double v52 = v252.f64[0] + v254.f64[0] + v254.f64[1];
        double v48 = v526 + v244.f64[0] + v244.f64[1] + v556.val[0].f64[0] + v556.val[0].f64[1];
        double v49 = v528 + v245.f64[0] + v245.f64[1] + v255.f64[0] + v255.f64[1];
        double v50 = v534 + v559.val[1].f64[0] + v559.val[1].f64[1] + v256.f64[0] + v256.f64[1];
        v556.val[1].f64[0] = v532 + v246.f64[0] + v246.f64[1] + v257.f64[0];
        double v29 = v519;
        double v53 = v556.val[1].f64[0] + v257.f64[1];
        double v62 = v474 + v247.f64[0] + v247.f64[1] + v258.f64[0] + v258.f64[1];
        double v64 = v529 + v248.f64[0] + v248.f64[1] + v259.f64[0] + v259.f64[1];
        double v63 = v475 + v249.f64[0] + v249.f64[1] + v260.f64[0] + v260.f64[1];
        double v51 = v530 + v250.f64[0] + v250.f64[1] + v261.f64[0] + v261.f64[1];
        v65 += 8;
        v66 += 8;
        v67 -= 4;
      }
      while (v67);
      double v60 = *(double *)a5;
      long long v58 = v404;
      double v57 = *(double *)(a5 + 24);
      long long v59 = v356;
      double v56 = *(double *)&v540;
      if (v47 == a3) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v47 = 0;
      double v48 = 0.0;
      double v49 = 0.0;
      double v50 = 0.0;
      double v51 = 0.0;
      double v52 = 0.0;
      double v53 = 0.0;
      double v54 = 0.0;
      double v55 = 0.0;
      double v56 = *(double *)&v540;
      long long v58 = v23;
      double v57 = *(double *)(a5 + 24);
      long long v59 = v21;
      double v60 = *(double *)a5;
      long long v61 = v22;
      double v62 = 0.0;
      double v63 = 0.0;
      double v64 = 0.0;
    }
    uint64_t v262 = a3 - v47;
    uint64_t v263 = (16 * v47) | 8;
    long long v264 = (double *)(a2 + v263);
    long long v265 = (double *)(a1 + v263);
    do
    {
      double v525 = v55;
      double v523 = v52;
      double v527 = v48;
      double v531 = v51;
      double v533 = v53;
      double v535 = v50;
      double v537 = v54;
      double v266 = *(v265 - 1);
      double v267 = *(v264 - 1);
      double v268 = *v265 - v502;
      double v269 = v520 * sqrt(v268 * v268 + (v266 - *(double *)&v510) * (v266 - *(double *)&v510));
      double v270 = v267 - *(double *)&v58;
      double v271 = *v264 - v57;
      double v272 = v60 * sqrt(v271 * v271 + v270 * v270);
      double v273 = v269 * (v269 * v269);
      double v274 = v269 * (v269 * v273);
      double v275 = v269 * (v269 * v274);
      double v276 = v269 * (v269 * v275);
      long long v277 = v59;
      long long v278 = v58;
      double v279 = v29 * (v269 * v269);
      double v280 = v269 * (v269 * v276);
      double v281 = v269 * (v269 * v280);
      double v282 = v272 * (v272 * v272);
      double v283 = v422
           + v279
           + v421 * (v269 * v273)
           + v420 * (v269 * v274)
           + v419 * (v269 * v275)
           + v418 * (v269 * v276)
           + v417 * (v269 * v280)
           + v416 * (v269 * v281);
      long long v284 = v61;
      double v285 = v504 * (v266 - *(double *)&v510) / v269;
      double v286 = *(double *)&v440
           + v515 * (v269 * v269)
           + *(double *)&v439 * (v269 * v273)
           + *(double *)&v438 * (v269 * v274)
           + *(double *)&v437 * (v269 * v275)
           + *(double *)&v436 * (v269 * v276)
           + a4[18] * (v269 * v280)
           + a4[19] * (v269 * v281);
      double v287 = v504 * v268 / v269;
      double v288 = v518 * v273 + v424 * v269;
      double v289 = v272 * (v272 * v282);
      double v290 = v288 + v431 * v274 + v429 * v275;
      double v291 = v272 * (v272 * v289);
      double v292 = v290 + v428 * v276 + v427 * v280 + v426 * v281;
      double v293 = v272 * (v272 * v291);
      double v294 = v272 * (v272 * v293);
      double v295 = v272 * (v272 * v294);
      double v296 = v415
           + v516 * (v272 * v272)
           + v414 * (v272 * v282)
           + v413 * (v272 * v289)
           + v412 * (v272 * v291)
           + v411 * (v272 * v293)
           + v410 * (v272 * v294)
           + v409 * (v272 * v295);
      double v297 = *(double *)&v435
           + v517 * (v272 * v272)
           + *(double *)&v434 * (v272 * v282)
           + *(double *)&v433 * (v272 * v289)
           + *(double *)&v432 * (v272 * v291)
           + *(double *)(a5 + 136) * (v272 * v293)
           + *(double *)(a5 + 144) * (v272 * v294)
           + *(double *)(a5 + 152) * (v272 * v295);
      double v298 = v503 * v270 / v272;
      double v299 = v503 * v271 / v272;
      double v300 = v505 * v282 + v423 * v272 + v430 * v289;
      double v301 = 1.0 / (v283 / 100.0 + 1.0);
      double v302 = 1.0 - v301;
      double v303 = v300 + v408 * v291 + v407 * v293 + v406 * v294 + v425 * v295;
      double v304 = *(double *)&v510 * (1.0 - v301) + v301 * v266;
      double v305 = v502 * (1.0 - v301) + v301 * *v265;
      double v306 = 1.0 / (v296 / 100.0 + 1.0);
      double v307 = v285 * v292;
      double v308 = v287 * v292;
      double v309 = v298 * v303;
      double v310 = v283 + 100.0;
      long long v58 = v278;
      double v311 = 1.0 - v306;
      double v312 = -100.0 / (v310 * v310);
      double v313 = v520 * v286 * v312;
      double v314 = v307 * v312;
      double v315 = v308 * v312;
      double v316 = *(double *)&v278 * (1.0 - v306) + v306 * v267;
      double v317 = -100.0 / ((v296 + 100.0) * (v296 + 100.0));
      double v318 = v57 * (1.0 - v306) + v306 * *v264;
      double v319 = v521 * v297 * v317;
      double v320 = v309 * v317;
      double v321 = v299 * v303 * v317;
      double v322 = v313 * v509 + v313 * v266;
      double v323 = v313 * v506 + v313 * *v265;
      double v29 = v519;
      double v324 = v302 + v509 * v314 + v314 * v266;
      long long v61 = v284;
      double v325 = v315 * v509 + v315 * v266;
      double v326 = v302 + v506 * v315 + v315 * *v265;
      double v327 = v319 * v508 + v319 * v267;
      double v328 = v319 * v507 + v319 * *v264;
      double v329 = v311 + v508 * v320 + v320 * v267;
      double v330 = v321 * v508 + v321 * v267;
      double v331 = v311 + v507 * v321 + v321 * *v264;
      double v332 = *(double *)&v542 + *((double *)&v540 + 1) * v318 + v316 * *(double *)&v539;
      double v333 = *((double *)&v542 + 1) + *(double *)&v541 * v318 + v316 * *((double *)&v539 + 1);
      double v334 = v323 * v333 + v332 * v322;
      double v335 = (v314 * v506 + v314 * *v265) * v333 + v332 * v324;
      double v336 = v326 * v333;
      double v337 = v56 + *((double *)&v539 + 1) * v305 + *(double *)&v539 * v304;
      long long v59 = v277;
      double v338 = *((double *)&v541 + 1) + *(double *)&v541 * v305 + *((double *)&v540 + 1) * v304;
      double v339 = v336 + v332 * v325;
      double v340 = *(double *)&v277 + *((double *)&v542 + 1) * v305 + *(double *)&v542 * v304 + v318 * v338 + v316 * v337;
      double v341 = *(double *)&v547 * v305 + *((double *)&v546 + 1) * v304;
      double v342 = v328 * v338 + v327 * v337;
      double v343 = (v320 * v507 + v320 * *v264) * v338 + v329 * v337;
      double v344 = *((double *)&v548 + 1) * v305 + *(double *)&v548 * v304;
      double v345 = *(double *)&v550 * v305 + *((double *)&v549 + 1) * v304;
      double v346 = v331 * v338 + v330 * v337;
      double v347 = *((double *)&v551 + 1) * v305 + *(double *)&v551 * v304;
      double v348 = v305 * *(double *)&v553 + *((double *)&v552 + 1) * v304;
      double v349 = v305 * *((double *)&v554 + 1) + *(double *)&v554 * v304;
      double v350 = v305 * *((double *)&v545 + 1) + *(double *)&v545 * v304;
      double v351 = *((double *)&v550 + 1) + v345 + v318 * (*(double *)&v549 + v344) + v316 * (*((double *)&v547 + 1) + v341);
      double v352 = v318 * (*((double *)&v553 + 1) + v348) + v316 * (*(double *)&v552 + v347);
      double v60 = *(double *)a5;
      double v353 = *(double *)&v284 * v318 + v316 * *((double *)&v543 + 1);
      double v354 = sqrt(v340 * v340 + 0.00000337320636);
      double v54 = v537 + v354;
      double v355 = v340 / v354;
      double v55 = v525 + v351 * v355;
      double v52 = v523 + (*((double *)&v544 + 1) + v353) * v355;
      double v48 = v527 + v355 * (v352 + v555 + v349);
      double v49 = v49 + v355 * (*(double *)&v546 + v350);
      double v50 = v535 + v334 * v355;
      double v53 = v533 + v335 * v355;
      double v62 = v62 + v339 * v355;
      double v64 = v64 + v342 * v355;
      double v63 = v63 + v343 * v355;
      double v51 = v531 + v346 * v355;
      v264 += 2;
      v265 += 2;
      --v262;
    }
    while (v262);
LABEL_14:
    *a7 = v54 / (double)a3;
    *a8 = v55 / (double)a3;
    a8[1] = v52 / (double)a3;
    a8[2] = v48 / (double)a3;
    a8[3] = v49 / (double)a3;
    a8[4] = v50 / (double)a3;
    a8[5] = v53 / (double)a3;
    a8[6] = v62 / (double)a3;
    a8[7] = v64 / (double)a3;
    a8[8] = v63 / (double)a3;
    a8[9] = v51 / (double)a3;
  }
  return result;
}

double FundamentalDistortionError_MeanVal(const double *a1, const double *a2, int a3, double *a4, double *a5, uint64_t a6, double *a7, double result, __n128 a9, double a10, double a11, __n128 a12, double a13, double a14, __n128 a15)
{
  if (a1 && a2 && a3 >= 1 && a7)
  {
    a9.n128_u64[0] = *(void *)(a6 + 8);
    double v16 = *(double *)(a6 + 48);
    double v17 = *(double *)(a6 + 56);
    double v18 = *(double *)(a6 + 64);
    double v19 = *(double *)(a6 + 72);
    double v20 = *(double *)(a6 + 80);
    double v21 = *(double *)(a6 + 88);
    double v22 = *(double *)(a6 + 96);
    double v23 = *(double *)(a6 + 104);
    double v24 = *(double *)(a6 + 112);
    double v25 = *(double *)(a6 + 120);
    double v26 = *(double *)(a6 + 128);
    double v27 = *(double *)(a6 + 136);
    double v28 = -1.0 / *(double *)a6;
    double v29 = *(double *)(a6 + 16) / *(double *)a6;
    double v30 = *(double *)(a6 + 32) / *(double *)a6;
    double v31 = -1.0 / a9.n128_f64[0];
    double v32 = *(double *)(a6 + 24) / a9.n128_f64[0];
    double v33 = v23 * v24 - v27 * v20;
    double v34 = v23 * v25 - v27 * v21;
    double v35 = v23 * v26 - v27 * v22;
    double v36 = v27 * v16 - v19 * v24;
    double v37 = v27 * v17 - v19 * v25;
    double v38 = v27 * v18 - v19 * v26;
    double v39 = v19 * v20 - v23 * v16;
    double v40 = v19 * v21 - v23 * v17;
    double v41 = v19 * v22 - v23 * v18;
    double v42 = *(double *)(a6 + 40) / a9.n128_f64[0];
    double v43 = v28 * v33;
    double v44 = v28 * v36;
    double v45 = v28 * v39;
    double v46 = v28 * v34;
    double v47 = v28 * v37;
    double v48 = v28 * v40;
    double v49 = v35 + v30 * v34 + v29 * v33;
    double v50 = v38 + v30 * v37 + v29 * v36;
    double v51 = v41 + v30 * v40 + v29 * v39;
    *(double *)&long long v15 = -1.0 / a9.n128_f64[0] * v43;
    a9.n128_f64[0] = -1.0 / a9.n128_f64[0] * v46;
    __n128 v171 = a9;
    double v197 = v31 * v49;
    double v196 = v31 * v44;
    a12.n128_f64[0] = v31 * v47;
    double v195 = v31 * v50;
    double v194 = v45 + v42 * v44 + v43 * v32;
    a15.n128_f64[0] = v48 + v42 * v47 + v46 * v32;
    double v193 = v51 + v42 * v50 + v49 * v32;
    double v52 = a4[1] * *a4;
    double v53 = a4[4] + v52 * a4[12];
    double v54 = a4[5] + v52 * a4[13];
    double v55 = a4[6] + v52 * a4[14];
    double v56 = a4[7] + v52 * a4[15];
    double v57 = a4[8] + v52 * a4[16];
    double v58 = a4[9] + v52 * a4[17];
    double v59 = a4[10] + v52 * a4[18];
    double v60 = a4[11] + v52 * a4[19];
    double v61 = a5[1] * *a5;
    double v62 = a5[4] + v61 * a5[12];
    double v63 = a5[5] + v61 * a5[13];
    double v64 = a5[6] + v61 * a5[14];
    double v65 = a5[7] + v61 * a5[15];
    double v66 = a5[8] + v61 * a5[16];
    double v67 = a5[9] + v61 * a5[17];
    double v68 = a5[10] + v61 * a5[18];
    uint64_t v69 = *((uint64_t *)a4 + 2);
    uint64_t v70 = *((uint64_t *)a4 + 3);
    double v71 = a5[11] + v61 * a5[19];
    uint64_t v72 = *((uint64_t *)a5 + 2);
    uint64_t v73 = *((uint64_t *)a5 + 3);
    double v191 = v55;
    double v192 = v53;
    double v189 = v58;
    double v190 = v56;
    double v188 = v54;
    if (a3 > 1)
    {
      float64x2_t v186 = (float64x2_t)vdupq_lane_s64(v69, 0);
      uint64_t v74 = a3 & 0xFFFFFFFE;
      float64x2_t v185 = (float64x2_t)vdupq_lane_s64(v70, 0);
      float64x2_t v184 = (float64x2_t)vdupq_lane_s64(v72, 0);
      float64x2_t v183 = (float64x2_t)vdupq_lane_s64(v73, 0);
      float64x2_t v182 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v53, 0);
      float64x2_t v181 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v55, 0);
      float64x2_t v179 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v57, 0);
      float64x2_t v180 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v56, 0);
      float64x2_t v177 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v59, 0);
      float64x2_t v178 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v58, 0);
      double v168 = v62;
      double v169 = v60;
      float64x2_t v175 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v62, 0);
      float64x2_t v176 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v60, 0);
      double v166 = v65;
      double v167 = v64;
      float64x2_t v173 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v65, 0);
      float64x2_t v174 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v64, 0);
      double v164 = v67;
      double v165 = v66;
      float64x2_t v172 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v66, 0);
      double v187 = v63;
      double v87 = v54;
      __n128 v88 = a15;
      float64x2_t v89 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v67, 0);
      double v162 = v71;
      double v163 = v68;
      float64x2_t v90 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v68, 0);
      float64x2_t v91 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v71, 0);
      long long v170 = v15;
      float64x2_t v92 = (float64x2_t)vdupq_lane_s64(v15, 0);
      float64x2_t v93 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v197, 0);
      float64x2_t v94 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v196, 0);
      double v76 = 0.0;
      float64x2_t v95 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v195, 0);
      float64x2_t v96 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v194, 0);
      uint64_t v97 = a1;
      float64x2_t v98 = a2;
      uint64_t v99 = v74;
      float64x2_t v100 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v193, 0);
      do
      {
        float64x2x2_t v199 = vld2q_f64(v97);
        v97 += 4;
        float64x2_t v101 = vsubq_f64(v199.val[1], v185);
        float64x2_t v102 = vsubq_f64(v199.val[0], v186);
        float64x2_t v103 = vmulq_f64(v101, v101);
        float64x2x2_t v198 = vld2q_f64(v98);
        v98 += 4;
        float64x2_t v104 = vmulq_n_f64(vsqrtq_f64(vmlaq_f64(v103, v102, v102)), *a4);
        float64x2_t v105 = vsubq_f64(v198.val[0], v184);
        float64x2_t v106 = vsubq_f64(v198.val[1], v183);
        float64x2_t v107 = vmlaq_f64(vmulq_f64(v106, v106), v105, v105);
        float64x2_t v108 = vmulq_f64(v104, v104);
        float64x2_t v109 = vmulq_f64(v104, vmulq_f64(v104, v108));
        float64x2_t v110 = vmulq_f64(v104, vmulq_f64(v104, v109));
        float64x2_t v111 = vmulq_f64(v104, vmulq_f64(v104, v110));
        float64x2_t v112 = vmulq_f64(v104, vmulq_f64(v104, v111));
        float64x2_t v113 = vmlaq_f64(vaddq_f64(v182, vmulq_n_f64(v108, v87)), v109, v181);
        float64x2_t v114 = vmulq_f64(v104, vmulq_f64(v104, v112));
        float64x2_t v115 = vmulq_n_f64(vsqrtq_f64(v107), *a5);
        float64x2_t v116 = vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(v113, v110, v180), v111, v179), v112, v178), v114, v177), vmulq_f64(v104, vmulq_f64(v104, v114)), v176);
        float64x2_t v117 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
        __asm { FMOV            V25.2D, #1.0 }
        float64x2_t v123 = vdivq_f64(_Q25, vaddq_f64(vdivq_f64(v116, v117), _Q25));
        float64x2_t v124 = vsubq_f64(_Q25, v123);
        float64x2_t v125 = vmlaq_f64(vmulq_n_f64(v124, *(double *)&v69), v199.val[0], v123);
        float64x2_t v126 = vmlaq_f64(vmulq_n_f64(v124, *(double *)&v70), v199.val[1], v123);
        v199.val[0] = vmulq_f64(v115, v115);
        v199.val[1] = vmulq_f64(v115, vmulq_f64(v115, v199.val[0]));
        float64x2_t v127 = vmulq_f64(v115, vmulq_f64(v115, v199.val[1]));
        v199.val[0] = vmlaq_f64(vaddq_f64(v175, vmulq_n_f64(v199.val[0], v187)), v199.val[1], v174);
        v199.val[1] = vmulq_f64(v115, vmulq_f64(v115, v127));
        v199.val[0] = vmlaq_f64(v199.val[0], v127, v173);
        float64x2_t v128 = vmulq_f64(v115, vmulq_f64(v115, v199.val[1]));
        v199.val[0] = vmlaq_f64(v199.val[0], v199.val[1], v172);
        v199.val[1] = vmulq_f64(v115, vmulq_f64(v115, v128));
        float64x2_t v129 = vdivq_f64(_Q25, vaddq_f64(vdivq_f64(vmlaq_f64(vmlaq_f64(vmlaq_f64(v199.val[0], v128, v89), v199.val[1], v90), vmulq_f64(v115, vmulq_f64(v115, v199.val[1])), v91), v117), _Q25));
        v199.val[0] = vsubq_f64(_Q25, v129);
        float64x2_t v130 = vaddq_f64(vaddq_f64(v100, vmlaq_f64(vmulq_n_f64(v126, v88.n128_f64[0]), v125, v96)), vmlaq_f64(vmulq_f64(vmlaq_f64(vmulq_n_f64(v199.val[0], *(double *)&v73), v198.val[1], v129), vaddq_f64(v95, vmlaq_f64(vmulq_n_f64(v126, a12.n128_f64[0]), v125, v94))), vaddq_f64(v93, vmlaq_f64(vmulq_n_f64(v126, v171.n128_f64[0]), v125, v92)), vmlaq_f64(vmulq_n_f64(v199.val[0], *(double *)&v72), v198.val[0], v129)));
        float64x2_t v131 = vsqrtq_f64(vmlaq_f64((float64x2_t)vdupq_n_s64(0x3ECC4BE7CE3F6732uLL), v130, v130));
        double v76 = v76 + v131.f64[0] + v131.f64[1];
        v99 -= 2;
      }
      while (v99);
      a15 = v88;
      __n128 v77 = a12;
      __n128 v79 = v171;
      long long v75 = v170;
      double v78 = v187;
      double v80 = *a4;
      double v60 = v169;
      double v82 = v167;
      double v81 = v168;
      double v84 = v165;
      double v83 = v166;
      double v85 = v163;
      double v67 = v164;
      double v86 = v162;
      if (v74 == a3) {
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v74 = 0;
      long long v75 = v15;
      double v76 = 0.0;
      __n128 v77 = a12;
      double v78 = v63;
      double v80 = *a4;
      __n128 v79 = v171;
      double v81 = v62;
      double v82 = v64;
      double v83 = v65;
      double v84 = v66;
      double v85 = v68;
      double v86 = v71;
    }
    uint64_t v132 = a3 - v74;
    uint64_t v133 = (16 * v74) | 8;
    float64x2_t v134 = (double *)((char *)a2 + v133);
    float64x2_t v135 = (double *)((char *)a1 + v133);
    do
    {
      double v136 = *(v135 - 1);
      double v137 = *(v134 - 1);
      double v138 = v80
           * sqrt((*v135 - *(double *)&v70) * (*v135 - *(double *)&v70)+ (v136 - *(double *)&v69) * (v136 - *(double *)&v69));
      __n128 v139 = v79;
      __n128 v140 = v77;
      double v141 = v138 * (v138 * (v138 * v138));
      __n128 v142 = a15;
      long long v143 = v75;
      double v144 = v138 * (v138 * v141);
      double v145 = v192 + v188 * (v138 * v138) + v191 * v141;
      double v146 = v138 * (v138 * v144);
      double v147 = v145 + v190 * v144;
      double v148 = v138 * (v138 * v146);
      double v149 = v147 + v57 * v146;
      double v150 = v138 * (v138 * v148);
      double v151 = v149 + v189 * v148;
      long long v75 = v143;
      double v152 = *a5
           * sqrt((*v134 - *(double *)&v73) * (*v134 - *(double *)&v73)+ (v137 - *(double *)&v72) * (v137 - *(double *)&v72));
      double v153 = v151 + v59 * v150 + v60 * (v138 * (v138 * v150));
      double v154 = v152 * (v152 * (v152 * v152));
      double v155 = v81 + v78 * (v152 * v152) + v82 * v154;
      double v156 = v152 * (v152 * v154);
      double v157 = (v155
            + v83 * v156
            + v84 * (v152 * (v152 * v156))
            + v67 * (v152 * (v152 * (v152 * (v152 * v156))))
            + v85 * (v152 * (v152 * (v152 * (v152 * (v152 * (v152 * v156))))))
            + v86 * (v152 * (v152 * (v152 * (v152 * (v152 * (v152 * (v152 * (v152 * v156)))))))))
           / 100.0;
      double v158 = 1.0 / (v153 / 100.0 + 1.0);
      double v159 = *(double *)&v69 * (1.0 - v158) + v158 * v136;
      __n128 v77 = v140;
      __n128 v79 = v139;
      double v160 = *(double *)&v70 * (1.0 - v158) + v158 * *v135;
      a15 = v142;
      double v161 = (*(double *)&v73 * (1.0 - 1.0 / (v157 + 1.0)) + 1.0 / (v157 + 1.0) * *v134)
           * (v195 + v77.n128_f64[0] * v160 + v196 * v159)
           + (*(double *)&v72 * (1.0 - 1.0 / (v157 + 1.0)) + 1.0 / (v157 + 1.0) * v137)
           * (v197 + v139.n128_f64[0] * v160 + *(double *)&v75 * v159);
      double v76 = v76
          + sqrt((v193 + v142.n128_f64[0] * v160 + v194 * v159 + v161)* (v193 + v142.n128_f64[0] * v160 + v194 * v159 + v161)+ 0.00000337320636);
      v134 += 2;
      v135 += 2;
      --v132;
    }
    while (v132);
LABEL_12:
    double result = v76 / (double)a3;
    *a7 = result;
  }
  return result;
}

void sub_215F6D770(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F6D904(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F6DA54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F6DB8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F6E540(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F6EC60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33,void *a34)
{
  _Unwind_Resume(a1);
}

id ADCommonUtils::matrixNxMToArrayColumnFirst<4ul,3ul,simd_float4x3>(_DWORD *a1)
{
  CMTime v2 = objc_opt_new();
  LODWORD(v3) = *a1;
  double v4 = [NSNumber numberWithFloat:v3];
  [v2 addObject:v4];

  LODWORD(v5) = a1[1];
  double v6 = [NSNumber numberWithFloat:v5];
  [v2 addObject:v6];

  LODWORD(v7) = a1[2];
  double v8 = [NSNumber numberWithFloat:v7];
  [v2 addObject:v8];

  LODWORD(v9) = a1[4];
  double v10 = [NSNumber numberWithFloat:v9];
  [v2 addObject:v10];

  LODWORD(v11) = a1[5];
  double v12 = [NSNumber numberWithFloat:v11];
  [v2 addObject:v12];

  LODWORD(v13) = a1[6];
  double v14 = [NSNumber numberWithFloat:v13];
  [v2 addObject:v14];

  LODWORD(v15) = a1[8];
  double v16 = [NSNumber numberWithFloat:v15];
  [v2 addObject:v16];

  LODWORD(v17) = a1[9];
  double v18 = [NSNumber numberWithFloat:v17];
  [v2 addObject:v18];

  LODWORD(v19) = a1[10];
  double v20 = [NSNumber numberWithFloat:v19];
  [v2 addObject:v20];

  LODWORD(v21) = a1[12];
  double v22 = [NSNumber numberWithFloat:v21];
  [v2 addObject:v22];

  LODWORD(v23) = a1[13];
  double v24 = [NSNumber numberWithFloat:v23];
  [v2 addObject:v24];

  LODWORD(v25) = a1[14];
  double v26 = [NSNumber numberWithFloat:v25];
  [v2 addObject:v26];

  return v2;
}

void sub_215F6F068(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F6F118(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F6F3F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F6FC4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  _Unwind_Resume(a1);
}

void sub_215F70EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40)
{
  _Unwind_Resume(a1);
}

void sub_215F71250(_Unwind_Exception *a1)
{
  double v5 = v4;

  _Unwind_Resume(a1);
}

void sub_215F71398(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7164C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F718B4(_Unwind_Exception *a1)
{
  double v3 = v2;

  _Unwind_Resume(a1);
}

void sub_215F71BE0(_Unwind_Exception *a1)
{
  double v8 = v7;

  _Unwind_Resume(a1);
}

void sub_215F71CFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F71DD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F72298(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F72344(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F72B90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F73838(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F73BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F74374(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7448C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F744E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  double v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)ADPearlColorInFieldCalibrationPipeline;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F74984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F74D5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F74DF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F74ED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F75058(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F75120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7559C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F75650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F75880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F75FE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F76314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7652C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, objc_super a11)
{
  a11.super_class = (Class)ADDeviceConfiguration;
  [(_Unwind_Exception *)&a11 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F76820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_215F76A38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F76B40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F76C6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F76D48(_Unwind_Exception *a1)
{
  double v3 = v2;

  _Unwind_Resume(a1);
}

void sub_215F76E1C(_Unwind_Exception *a1)
{
  double v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F76F00(_Unwind_Exception *a1)
{
  double v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F76FE0(_Unwind_Exception *a1)
{
  double v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F77468(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F77834(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F77BF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F77E60(_Unwind_Exception *a1)
{
  double v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F7805C(_Unwind_Exception *a1)
{
  double v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F78258(_Unwind_Exception *a1)
{
  double v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F78478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);

  _Unwind_Resume(a1);
}

void sub_215F78728(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F78850(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F788FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F789A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F78AAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F78BCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F78EB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  double v8 = v6;

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F78F58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F792A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_215F797A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_215F79D54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F79DEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7A0C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, objc_super a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  a10.super_class = (Class)ADExecutor;
  [(_Unwind_Exception *)&a10 dealloc];
  _Unwind_Resume(a1);
}

id calibrationFromAttachment(__CVBuffer *a1)
{
  if (!a1) {
    goto LABEL_5;
  }
  CFTypeRef Attachment = CVBufferGetAttachment(a1, @"Calibration Data", 0);
  CMTime v2 = (void *)Attachment;
  if (Attachment)
  {
    CFRetain(Attachment);
    CFTypeID v3 = CFGetTypeID(v2);
    if (v3 != CFDictionaryGetTypeID())
    {
      CFRelease(v2);
LABEL_5:
      CMTime v2 = 0;
    }
  }
  return v2;
}

void calibrationAttach(__CVBuffer *a1, CFTypeRef value)
{
}

void sub_215F7A458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F7A4E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7AD3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7B374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28)
{
  _Unwind_Resume(a1);
}

void sub_215F7B6D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7B8B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7BBB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7BE3C(_Unwind_Exception *a1)
{
  double v5 = v4;

  _Unwind_Resume(a1);
}

void sub_215F7BF84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7C198(_Unwind_Exception *a1)
{
  CFTypeID v3 = v2;

  _Unwind_Resume(a1);
}

void sub_215F7C254(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7CC98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,void *a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  _Unwind_Resume(a1);
}

void sub_215F7DCFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40)
{
  _Unwind_Resume(a1);
}

void sub_215F7E6A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7E9F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7EBB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7EEF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);

  _Unwind_Resume(a1);
}

void sub_215F7F13C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7F3D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7FB5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F7FC50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t isJasperFrameValidImpl(void *a1, void *a2, void *a3, _OWORD *a4, float32x4_t *a5, unsigned char *a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, float32x4_t a10, int32x4_t a11, int32x4_t a12, int32x4_t a13, int32x4_t a14)
{
  float32x4_t v50 = a10;
  id v19 = a1;
  id v20 = a3;
  double v21 = [a2 deviceName];
  char v22 = [v21 hasPrefix:@"N301"];

  unsigned int v23 = [v19 length];
  double v24 = (float *)[v19 euclideanDistances];
  if (v23 >= [v20 numberOfValidSpotsForValidFrame])
  {
    [v20 minRotationBetweenFrames];
    if (v29 != 0.0)
    {
      int32x4_t v30 = vzip2q_s32(a11, a13);
      int32x4_t v31 = vzip2q_s32(a12, a14);
      float32x4_t v32 = (float32x4_t)vzip2q_s32(v30, v31);
      float32x4_t v33 = (float32x4_t)vzip1q_s32(v30, v31);
      int32x4_t v34 = vzip1q_s32(a11, a13);
      int32x4_t v35 = vzip1q_s32(a12, a14);
      float32x4_t v36 = (float32x4_t)vzip2q_s32(v34, v35);
      float32x4_t v37 = (float32x4_t)vzip1q_s32(v34, v35);
      float32x4_t v38 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, a7.f32[0]), v36, *(float32x2_t *)a7.f32, 1), v33, a7, 2), v32, a7, 3);
      float32x4_t v39 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, a8.f32[0]), v36, *(float32x2_t *)a8.f32, 1), v33, a8, 2), v32, a8, 3);
      float32x4_t v54 = v37;
      float32x4_t v56 = v36;
      float32x4_t v58 = v33;
      float32x4_t v60 = v32;
      float32x4_t v40 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, a9.f32[0]), v36, *(float32x2_t *)a9.f32, 1), v33, a9, 2), v32, a9, 3);
      *(_DWORD *)&unsigned char buf[12] = 0;
      *(_DWORD *)&buf[8] = v38.i32[2];
      uint64_t v66 = v39.u32[2];
      *(void *)buf = v38.i64[0];
      uint64_t v65 = v39.i64[0];
      uint64_t v68 = v40.u32[2];
      uint64_t v67 = v40.i64[0];
      +[ADUtils calcRotationAngle:buf];
      long long v62 = v41;
      [v20 minRotationBetweenFrames];
      float32x2_t v43 = vabs_f32(*(float32x2_t *)&v62);
      if (v43.f32[0] <= v43.f32[1]) {
        v43.f32[0] = v43.f32[1];
      }
      if (v43.f32[0] < v42)
      {
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_6;
        }
        __int16 v63 = 0;
        double v26 = &_os_log_internal;
        double v27 = "ADJasperColorInFieldCalibration jasper controller failed: frame not passing minimum rotation";
        double v28 = (uint8_t *)&v63;
LABEL_5:
        _os_log_impl(&dword_215F16000, v26, OS_LOG_TYPE_DEFAULT, v27, v28, 2u);
LABEL_6:
        uint64_t v25 = 0;
        goto LABEL_30;
      }
      if (a4) {
        *a4 = v62;
      }
      if (a5) {
        *a5 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v54, v50.f32[0]), v56, *(float32x2_t *)v50.f32, 1), v58, v50, 2), v60, v50, 3);
      }
    }
    unsigned int v44 = 0;
    if (v23)
    {
      uint64_t v45 = v23;
      do
      {
        float v46 = *v24;
        objc_msgSend(v20, "thresholdDepthValue", *(_OWORD *)&v50);
        if (v46 < v47) {
          ++v44;
        }
        ++v24;
        --v45;
      }
      while (v45);
    }
    if (v22)
    {
      [v20 thresholdPrecOfValidDepth];
      if ((float)((float)v44 / (float)v23) > v48)
      {
        uint64_t v25 = 0;
        if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_30;
        }
        *(_WORD *)buf = 0;
        double v26 = &_os_log_internal;
        double v27 = "ADJasperColorInFieldCalibration jasper controller failed: percentage of valid depth is too low";
        goto LABEL_4;
      }
    }
    else if (v23 - v44 < [v20 numberOfMinimalRangeSpots])
    {
      uint64_t v25 = 0;
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      *(_WORD *)buf = 0;
      double v26 = &_os_log_internal;
      double v27 = "ADJasperColorInFieldCalibration jasper controller failed: number of good spots is too low";
      goto LABEL_4;
    }
    if (a6) {
      *a6 = 100 * (v23 - v44) / v23;
    }
    uint64_t v25 = 1;
  }
  else
  {
    uint64_t v25 = 0;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      double v26 = &_os_log_internal;
      double v27 = "ADJasperColorInFieldCalibration jasper controller failed: number of valid spots is too low";
LABEL_4:
      double v28 = buf;
      goto LABEL_5;
    }
  }
LABEL_30:

  return v25;
}

void sub_215F7FFFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F80174(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t isColorFrameValidImpl(__CVBuffer *a1, NSDictionary *a2, ADJasperColorInFieldCalibrationPipelineParameters *a3, ADJasperColorInFieldCalibrationControllerParameters *a4)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  double v7 = a2;
  double v8 = a3;
  double v9 = a4;
  double v10 = [(ADPipelineParameters *)v8 deviceName];
  if ([v10 hasPrefix:@"N301"])
  {

    uint64_t v11 = 1;
    goto LABEL_51;
  }
  BOOL v12 = [(ADJasperColorInFieldCalibrationPipelineParameters *)v8 forceRun];

  if (v12)
  {
    uint64_t v11 = 1;
    goto LABEL_51;
  }
  BOOL v13 = +[ADJasperColorInFieldCalibrationPipeline isInSupportedFormat:a1];
  BOOL v14 = v13;
  if (ADDebugUtilsADVerboseLogsEnabled) {
    char v15 = v13;
  }
  else {
    char v15 = 1;
  }
  if ((v15 & 1) == 0 && os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "AD-RGB controller unsupported pixel format", buf, 2u);
  }
  [MEMORY[0x263F26C68] getFrameTransformsFromMetadataDictionary:v7 sensorCropRect:v42 rawSensorSize:&v40 postReadCropRect:&v36];
  if (ADDebugUtilsADVerboseLogsEnabled)
  {
    if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_55;
    }
    *(_DWORD *)buf = 134218752;
    double v44 = *(double *)&v42[2];
    __int16 v45 = 2048;
    double v46 = *(double *)&v42[3];
    __int16 v47 = 2048;
    double v48 = *(double *)v42;
    __int16 v49 = 2048;
    double v50 = *(double *)&v42[1];
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "AD-RGBJ controller SensorCropRect       size.width:%f,  size.height:%f,  origin.x:%f,    origin.y:%f\n", buf, 0x2Au);
    if (ADDebugUtilsADVerboseLogsEnabled)
    {
LABEL_55:
      if (!os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT)
        || (*(_DWORD *)buf = 134218240,
            double v44 = v40,
            __int16 v45 = 2048,
            double v46 = v41,
            _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "AD-RGBJ controller rawSensorSize        size.width:%f,  size.height:%f\n", buf, 0x16u), ADDebugUtilsADVerboseLogsEnabled))
      {
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218752;
          double v44 = v38;
          __int16 v45 = 2048;
          double v46 = v39;
          __int16 v47 = 2048;
          double v48 = v36;
          __int16 v49 = 2048;
          double v50 = v37;
          _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "AD-RGBJ controller TotalSensorCropRect  size.width:%f,  size.height:%f,  origin.x:%f,    origin.y:%f\n", buf, 0x2Au);
        }
      }
    }
  }
  if (!v14) {
    goto LABEL_44;
  }
  double v16 = v40;
  double v17 = v36;
  double v18 = v38;
  [(ADJasperColorInFieldCalibrationControllerParameters *)v9 allowedDriftFromSymmetricCrop];
  LODWORD(v20) = v19;
  if (+[ADJasperColorInFieldCalibrationPipeline isCroppingPointInThresholdRange:v17 distanceFromSymmetricCroppingPoint:(v16 - v18) * 0.5 normalizedBySensorDimention:v16 andAllowedDriftFromSymmetricCrop:v20])
  {
    double v21 = v41;
    double v22 = v37;
    double v23 = v39;
    [(ADJasperColorInFieldCalibrationControllerParameters *)v9 allowedDriftFromSymmetricCrop];
    LODWORD(v25) = v24;
    if (+[ADJasperColorInFieldCalibrationPipeline isCroppingPointInThresholdRange:v22 distanceFromSymmetricCroppingPoint:(v21 - v23) * 0.5 normalizedBySensorDimention:v21 andAllowedDriftFromSymmetricCrop:v25])
    {
      double v26 = [(ADPipelineParameters *)v8 deviceName];
      int v27 = [v26 hasPrefix:@"J7"];
      if (v27) {
        double v28 = 96.0;
      }
      else {
        double v28 = 1067.0;
      }
      if (v27) {
        double v29 = 76.0;
      }
      else {
        double v29 = 656.0;
      }
      if (v27) {
        double v30 = 4032.0;
      }
      else {
        double v30 = 6314.0;
      }
      if (v27) {
        double v31 = 3024.0;
      }
      else {
        double v31 = 4736.0;
      }

      size_t Width = CVPixelBufferGetWidth(a1);
      objc_msgSend(MEMORY[0x263F26C68], "calcSensorCrop:onImageWithDimensions:metadataDictionary:negativeCropHandling:", v7, 1, v28, v29, v30, v31, (double)Width, (double)CVPixelBufferGetHeight(a1));
      if (!CGRectIsNull(v52))
      {
        uint64_t v11 = 1;
LABEL_45:
        if (!ADDebugUtilsADVerboseLogsEnabled) {
          goto LABEL_51;
        }
        goto LABEL_49;
      }
      if (ADDebugUtilsADVerboseLogsEnabled)
      {
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          float32x4_t v33 = &_os_log_internal;
          int32x4_t v34 = "AD-RGBJ cannot create crop rectangle";
LABEL_43:
          _os_log_impl(&dword_215F16000, v33, OS_LOG_TYPE_DEFAULT, v34, buf, 2u);
LABEL_44:
          uint64_t v11 = 0;
          goto LABEL_45;
        }
        goto LABEL_48;
      }
    }
    else if (ADDebugUtilsADVerboseLogsEnabled)
    {
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        float32x4_t v33 = &_os_log_internal;
        int32x4_t v34 = "AD-RGBJ None ISP symmetric height";
        goto LABEL_43;
      }
      goto LABEL_48;
    }
LABEL_47:
    uint64_t v11 = 0;
    goto LABEL_51;
  }
  if (!ADDebugUtilsADVerboseLogsEnabled) {
    goto LABEL_47;
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    float32x4_t v33 = &_os_log_internal;
    int32x4_t v34 = "AD-RGBJ None ISP symmetric width";
    goto LABEL_43;
  }
LABEL_48:
  uint64_t v11 = 0;
LABEL_49:
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v44) = v11;
    _os_log_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "AD-RGBJ controller status:%d\n", buf, 8u);
  }
LABEL_51:

  return v11;
}

void sub_215F80700(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F8085C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F80968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADJasperColorInFieldCalibrationPipeline;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F80AE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F810B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F811B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F81280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F814B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F816B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F81A10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F821F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F8248C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADJasperColorExecutor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F83EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,void *a47,id obj,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,void *a58,void *a59)
{
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)(v60 - 176));
  objc_sync_exit(obj);

  _Unwind_Resume(a1);
}

void sub_215F841BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F84428(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_215F84E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_215F85214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F852A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float postProcessingLogarithmicVarianceToStd(float a1)
{
  float v1 = 1.0;
  if (a1 <= 0.0)
  {
    float v2 = (float)((float)(a1 * 0.0019531) + 1.0) * (float)((float)(a1 * 0.0019531) + 1.0);
    float v3 = (float)((float)(v2 * v2) * (float)(v2 * v2)) * (float)((float)(v2 * v2) * (float)(v2 * v2));
    float v4 = (float)((float)(v3 * v3) * (float)(v3 * v3)) * (float)((float)(v3 * v3) * (float)(v3 * v3));
    return v4 * v4;
  }
  return v1;
}

float postProcessingConfidenceToStandardDeviation(float a1)
{
  return 1.0 - a1;
}

float postProcessingStandardDeviationToConfidence(float a1)
{
  float v1 = 1.0;
  float v2 = 1.0 - a1;
  if (v2 <= 1.0) {
    float v1 = v2;
  }
  BOOL v3 = v2 < 0.0;
  float result = 0.0;
  if (!v3) {
    return v1;
  }
  return result;
}

float postProcessingLogarithmicVarianceToConfidence(float a1)
{
  float v1 = 1.0;
  float v2 = 1.0;
  if (a1 <= 0.0)
  {
    float v3 = (float)((float)(a1 * 0.0019531) + 1.0) * (float)((float)(a1 * 0.0019531) + 1.0);
    float v4 = (float)((float)(v3 * v3) * (float)(v3 * v3)) * (float)((float)(v3 * v3) * (float)(v3 * v3));
    float v5 = (float)((float)(v4 * v4) * (float)(v4 * v4)) * (float)((float)(v4 * v4) * (float)(v4 * v4));
    float v2 = v5 * v5;
  }
  if ((float)(1.0 - v2) <= 1.0) {
    float v1 = 1.0 - v2;
  }
  float result = 0.0;
  if ((float)(1.0 - v2) >= 0.0) {
    return v1;
  }
  return result;
}

void sub_215F85748(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F89648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F8B9EC(_Unwind_Exception *a1)
{
  if (v3 < 0) {
    operator delete(v2);
  }

  _Unwind_Resume(a1);
}

uint64_t copyModifyPixelBuffer<&(postProcessingNone(float))>(__CVBuffer *a1, __CVBuffer *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  uint64_t v82 = *MEMORY[0x263EF8340];
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  unint64_t v13 = CVPixelBufferGetPixelFormatType(a2);
  unint64_t v14 = v13;
  if ((int)PixelFormatType > 1717856626)
  {
    if (PixelFormatType == 1717856627) {
      goto LABEL_14;
    }
    if (PixelFormatType != 1751411059 && PixelFormatType != 1751410032) {
      goto LABEL_87;
    }
LABEL_9:
    if ((int)v13 <= 1717856626)
    {
      if (v13 == 1278226536) {
        goto LABEL_89;
      }
      if (v13 != 1717855600)
      {
LABEL_87:
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
        {
          PixelBufferUtils::pixelFormatAsString(PixelFormatType, v72);
          int v62 = SHIBYTE(v75);
          __int16 v63 = *(unsigned char **)v72;
          PixelBufferUtils::pixelFormatAsString(v14, (char *)__p);
          double v64 = v72;
          if (v62 < 0) {
            double v64 = v63;
          }
          if (v67 >= 0) {
            uint64_t v65 = __p;
          }
          else {
            uint64_t v65 = (void **)__p[0];
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v69 = v64;
          __int16 v70 = 2082;
          double v71 = v65;
          _os_log_error_impl(&dword_215F16000, &_os_log_internal, OS_LOG_TYPE_ERROR, "unsupported map format (%{public}s, %{public}s)", buf, 0x16u);
          if (v67 < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v75) < 0) {
            operator delete(*(void **)v72);
          }
        }
        return -22956;
      }
    }
    else if (v13 != 1717856627)
    {
      if (v13 != 1751411059 && v13 != 1751410032) {
        goto LABEL_87;
      }
LABEL_89:
      int Width = CVPixelBufferGetWidth(a1);
      int Height = CVPixelBufferGetHeight(a1);
      int v17 = CVPixelBufferGetWidth(a2);
      int v18 = CVPixelBufferGetHeight(a2);
      int BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
      int v52 = CVPixelBufferGetBytesPerRow(a2);
      v86.origin.x = a3;
      v86.origin.y = a4;
      v86.size.double width = a5;
      v86.size.vImagePixelCount height = a6;
      if (CGRectIsEmpty(v86))
      {
        a3 = *MEMORY[0x263F00148];
        a4 = *(double *)(MEMORY[0x263F00148] + 8);
        a5 = (double)Width;
        a6 = (double)Height;
      }
      if (a5 <= (double)v17 && a6 <= (double)v18)
      {
        if (a3 + a5 > (double)Width || a4 + a6 > (double)Height) {
          goto LABEL_101;
        }
        if (a1 != a2) {
          CVPixelBufferLockBaseAddress(a1, 1uLL);
        }
        CVPixelBufferLockBaseAddress(a2, 0);
        BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
        double v59 = (char *)CVPixelBufferGetBaseAddress(a2);
        if (a5 > 0.0 && a6 > 0.0)
        {
          unsigned int v60 = 0;
          do
          {
            uint64_t v61 = 0;
            do
            {
              *(_WORD *)&v59[2 * v61 + v52 * (unint64_t)v60] = *(_WORD *)&BaseAddress[2 * (unint64_t)a3
                                                                                           + 2 * v61
                                                                                           + BytesPerRow
                                                                                           * ((unint64_t)a4 + v60)];
              ++v61;
            }
            while (a5 > (double)v61);
            ++v60;
          }
          while (a6 > (double)v60);
        }
        goto LABEL_111;
      }
      goto LABEL_95;
    }
    int Width = CVPixelBufferGetWidth(a1);
    int Height = CVPixelBufferGetHeight(a1);
    int v17 = CVPixelBufferGetWidth(a2);
    int v18 = CVPixelBufferGetHeight(a2);
    int v40 = CVPixelBufferGetBytesPerRow(a1);
    int v41 = CVPixelBufferGetBytesPerRow(a2);
    v85.origin.x = a3;
    v85.origin.y = a4;
    v85.size.double width = a5;
    v85.size.vImagePixelCount height = a6;
    if (CGRectIsEmpty(v85))
    {
      a3 = *MEMORY[0x263F00148];
      a4 = *(double *)(MEMORY[0x263F00148] + 8);
      a6 = (double)Height;
      a5 = (double)Width;
    }
    if (a5 <= (double)v17 && a6 <= (double)v18)
    {
      if (a3 + a5 > (double)Width || a4 + a6 > (double)Height) {
        goto LABEL_101;
      }
      if (a1 != a2) {
        CVPixelBufferLockBaseAddress(a1, 1uLL);
      }
      CVPixelBufferLockBaseAddress(a2, 0);
      double v44 = (char *)CVPixelBufferGetBaseAddress(a1);
      __int16 v45 = (char *)CVPixelBufferGetBaseAddress(a2);
      if (a5 > 0.0 && a6 > 0.0)
      {
        unsigned int v46 = 0;
        do
        {
          uint64_t v47 = 0;
          do
          {
            _H0 = *(_WORD *)&v44[2 * (unint64_t)a3 + 2 * v47 + v40 * ((unint64_t)a4 + v46)];
            __asm { FCVT            S0, H0 }
            *(_DWORD *)&v45[4 * v47++ + v41 * (unint64_t)v46] = _S0;
          }
          while (a5 > (double)v47);
          ++v46;
        }
        while (a6 > (double)v46);
      }
      goto LABEL_111;
    }
LABEL_95:
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v72 = 134218752;
      *(CGFloat *)&v72[4] = a5;
      __int16 v73 = 2048;
      CGFloat v74 = a6;
      __int16 v75 = 1024;
      *(_DWORD *)double v76 = v17;
      *(_WORD *)&v76[4] = 1024;
      *(_DWORD *)&v76[6] = v18;
      float32x4_t v54 = &_os_log_internal;
      double v55 = "Dimensions mismatch. Cannot fit ROI (%f,%f) inside output (%d,%d)";
      uint32_t v56 = 34;
LABEL_124:
      _os_log_error_impl(&dword_215F16000, v54, OS_LOG_TYPE_ERROR, v55, v72, v56);
      return -22957;
    }
    return -22957;
  }
  if (PixelFormatType == 1278226534) {
    goto LABEL_14;
  }
  if (PixelFormatType == 1278226536) {
    goto LABEL_9;
  }
  if (PixelFormatType != 1717855600) {
    goto LABEL_87;
  }
LABEL_14:
  if ((int)v13 > 1717856626)
  {
    if (v13 != 1717856627)
    {
      if (v13 != 1751411059 && v13 != 1751410032) {
        goto LABEL_87;
      }
LABEL_22:
      int Width = CVPixelBufferGetWidth(a1);
      int Height = CVPixelBufferGetHeight(a1);
      int v17 = CVPixelBufferGetWidth(a2);
      int v18 = CVPixelBufferGetHeight(a2);
      int v19 = CVPixelBufferGetBytesPerRow(a1);
      int v20 = CVPixelBufferGetBytesPerRow(a2);
      v83.origin.x = a3;
      v83.origin.y = a4;
      v83.size.double width = a5;
      v83.size.vImagePixelCount height = a6;
      if (CGRectIsEmpty(v83))
      {
        a3 = *MEMORY[0x263F00148];
        a4 = *(double *)(MEMORY[0x263F00148] + 8);
        a6 = (double)Height;
        a5 = (double)Width;
      }
      if (a5 <= (double)v17 && a6 <= (double)v18)
      {
        if (a3 + a5 > (double)Width || a4 + a6 > (double)Height) {
          goto LABEL_101;
        }
        if (a1 != a2) {
          CVPixelBufferLockBaseAddress(a1, 1uLL);
        }
        CVPixelBufferLockBaseAddress(a2, 0);
        double v23 = (char *)CVPixelBufferGetBaseAddress(a1);
        int v24 = (char *)CVPixelBufferGetBaseAddress(a2);
        if (a5 > 0.0 && a6 > 0.0)
        {
          unsigned int v25 = 0;
          do
          {
            uint64_t v26 = 0;
            do
            {
              _S0 = *(_DWORD *)&v23[4 * (unint64_t)a3 + 4 * v26 + v19 * ((unint64_t)a4 + v25)];
              __asm { FCVT            H0, S0 }
              *(_WORD *)&v24[2 * v26++ + v20 * (unint64_t)v25] = _S0;
            }
            while (a5 > (double)v26);
            ++v25;
          }
          while (a6 > (double)v25);
        }
        goto LABEL_111;
      }
      goto LABEL_95;
    }
  }
  else if (v13 != 1278226534)
  {
    if (v13 != 1278226536)
    {
      if (v13 != 1717855600) {
        goto LABEL_87;
      }
      goto LABEL_43;
    }
    goto LABEL_22;
  }
LABEL_43:
  int Width = CVPixelBufferGetWidth(a1);
  int Height = CVPixelBufferGetHeight(a1);
  int v17 = CVPixelBufferGetWidth(a2);
  int v18 = CVPixelBufferGetHeight(a2);
  int v32 = CVPixelBufferGetBytesPerRow(a1);
  int v33 = CVPixelBufferGetBytesPerRow(a2);
  v84.origin.x = a3;
  v84.origin.y = a4;
  v84.size.double width = a5;
  v84.size.vImagePixelCount height = a6;
  if (CGRectIsEmpty(v84))
  {
    a3 = *MEMORY[0x263F00148];
    a4 = *(double *)(MEMORY[0x263F00148] + 8);
    a6 = (double)Height;
    a5 = (double)Width;
  }
  if (a5 > (double)v17 || a6 > (double)v18) {
    goto LABEL_95;
  }
  if (a3 + a5 > (double)Width || a4 + a6 > (double)Height)
  {
LABEL_101:
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v72 = 134219264;
      *(CGFloat *)&v72[4] = a3;
      __int16 v73 = 2048;
      CGFloat v74 = a4;
      __int16 v75 = 2048;
      *(CGFloat *)double v76 = a5;
      *(_WORD *)&v76[8] = 2048;
      CGFloat v77 = a6;
      __int16 v78 = 1024;
      int v79 = Width;
      __int16 v80 = 1024;
      int v81 = Height;
      float32x4_t v54 = &_os_log_internal;
      double v55 = "Dimensions mismatch. Cannot fit ROI (%f,%f,%f,%f) inside input (%d,%d)";
      uint32_t v56 = 54;
      goto LABEL_124;
    }
    return -22957;
  }
  if (a1 != a2) {
    CVPixelBufferLockBaseAddress(a1, 1uLL);
  }
  CVPixelBufferLockBaseAddress(a2, 0);
  double v36 = (char *)CVPixelBufferGetBaseAddress(a1);
  double v37 = (char *)CVPixelBufferGetBaseAddress(a2);
  if (a5 > 0.0 && a6 > 0.0)
  {
    unsigned int v38 = 0;
    do
    {
      uint64_t v39 = 0;
      do
      {
        *(_DWORD *)&v37[4 * v39 + v33 * (unint64_t)v38] = *(_DWORD *)&v36[4 * (unint64_t)a3
                                                                               + 4 * v39
                                                                               + v32 * ((unint64_t)a4 + v38)];
        ++v39;
      }
      while (a5 > (double)v39);
      ++v38;
    }
    while (a6 > (double)v38);
  }
LABEL_111:
  if (a1 != a2) {
    CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  }
  CVPixelBufferUnlockBaseAddress(a2, 0);
  return 0;
}

void sub_215F8C318(_Unwind_Exception *exception_object)
{
  if (v2 < 0)
  {
    operator delete(v1);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_215F8CD8C(_Unwind_Exception *exception_object)
{
  if (v2 < 0)
  {
    operator delete(v1);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_215F8ED58(_Unwind_Exception *a1)
{
  if (v3 < 0) {
    operator delete(v2);
  }

  _Unwind_Resume(a1);
}

float postProcessingStandardDeviationToLogarithmicVariance(float a1)
{
  float v1 = logf(a1);
  return v1 + v1;
}

float postProcessingConfidenceToLogarithmicVariance(float a1)
{
  float v1 = logf(1.0 - a1);
  return v1 + v1;
}

void sub_215F8F6D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F8FC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  kdebug_trace();

  _Unwind_Resume(a1);
}

void sub_215F9025C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F903DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F90850(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F90950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADJasperColorV2Executor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F91E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30,uint64_t a31,char a32)
{
  objc_sync_exit(v32);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)&a32);

  _Unwind_Resume(a1);
}

void sub_215F92130(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F923F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  objc_sync_exit(v2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F927CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F92B9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F92C40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F92CA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F92F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_215F93088(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F930EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  double v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)ADUserNotifier;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F931F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL37ADUserNotificationAlertResultBlockMapv_block_invoke()
{
  id v0 = objc_alloc_init(MEMORY[0x263F08968]);
  float v1 = (void *)ADUserNotificationAlertResultBlockMap(void)::s_map;
  ADUserNotificationAlertResultBlockMap(void)::s_map = (uint64_t)v0;
}

void sub_215F93678(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void userNotificationCallback(__CFUserNotification *a1, char a2)
{
  if (a1)
  {
    if (ADUserNotificationAlertResultBlockMap(void)::onceToken != -1) {
      dispatch_once(&ADUserNotificationAlertResultBlockMap(void)::onceToken, &__block_literal_global);
    }
    id v6 = (id)ADUserNotificationAlertResultBlockMap(void)::s_map;
    float v4 = [MEMORY[0x263F08D40] valueWithPointer:a1];
    float v5 = [v6 objectForKey:v4];
    [v6 removeObjectForKey:v4];
    v5[2](v5, a2 & 3);
  }
}

void sub_215F937B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F93884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F93B54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_215F93C0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_215F93DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_215F93E14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F94218(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F944F8(_Unwind_Exception *a1)
{
  float v4 = v3;

  _Unwind_Resume(a1);
}

void sub_215F94704(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F94830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F94918(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F94A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F94B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F94C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F94D14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F94DC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F94F08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F95090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_215F95544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F95634(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F95700(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F957A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F95A44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F95B00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADMonocularV2Executor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F961B8(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v5);

  _Unwind_Resume(a1);
}

void sub_215F964A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_215F96624(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9685C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215F96910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F9698C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F96A1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F96AA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F96CE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F96E54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F96FA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F97128(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F97280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_215F973C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9753C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F975E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F97754(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9790C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F97AF8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_215F97BF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F97CA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F97FEC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_215F98154(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_215F98380(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_215F984C8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_215F98914(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);
  _Unwind_Resume(a1);
}

void sub_215F98A0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  _Unwind_Resume(a1);
}

void sub_215F98AA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  _Unwind_Resume(a1);
}

void sub_215F98B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADVisualLoggerHandler;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F98D40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F98E74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F98F4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F990B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F99198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F99314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F993F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F99570(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F99660(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F997CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F998AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F99A28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F99B08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F99C74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F99D5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F99FFC(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);
  _Unwind_Resume(a1);
}

void sub_215F9A1B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);
  _Unwind_Resume(a1);
}

void sub_215F9A30C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_215F9A444(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_215F9A59C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9A8C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9AA48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9AB38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADLogManager;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F9AC70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9B02C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9B18C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F9B220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215F9B358(_Unwind_Exception *a1)
{
  float v5 = v3;

  _Unwind_Resume(a1);
}

void sub_215F9B44C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9B6F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9B7F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADMonocularExecutor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F9BE70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v3);

  _Unwind_Resume(a1);
}

void sub_215F9C048(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_215F9C220(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9C414(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9C524(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9CA00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9CB60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADJasperColorStillsExecutor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F9DD70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,void *a35,id obj,uint64_t a37,char a38)
{
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)&a38);
  objc_sync_exit(obj);

  _Unwind_Resume(a1);
}

void mergePointCloudsUsingSameTransform(void *a1, uint64_t a2, void *a3)
{
  id v4 = a1;
  [a3 count];
  operator new[]();
}

void sub_215F9DFF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9E3AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  BOOL v12 = v9;

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v6);

  _Unwind_Resume(a1);
}

void sub_215F9E448()
{
}

void sub_215F9E450()
{
}

void sub_215F9E8A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9EC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);

  _Unwind_Resume(a1);
}

void sub_215F9ECC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9ED38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9EEA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9F204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215F9F310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADStereoV2Executor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215F9FE28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, void *a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v7);

  _Unwind_Resume(a1);
}

void sub_215FA01F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_215FA0518(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FA058C()
{
}

void sub_215FA086C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  double v7 = v6;

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215FA0C8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FA1204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);

  _Unwind_Resume(a1);
}

void sub_215FA140C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

double *FundamentalEpipolarError_precomputeFundamental@<X0>(double *result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 248) = 0u;
  *(_OWORD *)(a3 + 232) = 0u;
  *(_OWORD *)(a3 + 216) = 0u;
  *(_OWORD *)(a3 + 200) = 0u;
  *(_OWORD *)(a3 + 184) = 0u;
  *(_OWORD *)(a3 + 168) = 0u;
  *(_OWORD *)(a3 + 152) = 0u;
  *(_OWORD *)(a3 + 136) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  double v4 = *result;
  double v3 = result[1];
  double v6 = result[2];
  double v5 = result[3];
  double v8 = result[4];
  double v7 = result[5];
  double v9 = -1.0 / *result;
  double v10 = v6 / *result;
  double v11 = v8 / *result;
  double v12 = -1.0 / v3;
  double v13 = v5 / v3;
  double v14 = v7 / v3;
  double v15 = result[6];
  double v16 = result[7];
  double v17 = result[10];
  double v18 = result[11];
  double v19 = result[14];
  double v20 = result[15];
  double v22 = result[8];
  double v21 = result[9];
  double v23 = result[12];
  double v24 = result[13];
  double v25 = result[16];
  double v26 = result[17];
  double v27 = v24 * v19 - v26 * v17;
  double v28 = v24 * v20 - v26 * v18;
  double v29 = v24 * v25 - v26 * v23;
  double v30 = v26 * v15 - v21 * v19;
  double v31 = v26 * v16 - v21 * v20;
  double v32 = v26 * v22 - v21 * v25;
  double v33 = v21 * v17 - v24 * v15;
  double v34 = v21 * v18 - v24 * v16;
  double v35 = v21 * v23 - v24 * v22;
  double v36 = v9 * v27;
  double v37 = v9 * v30;
  double v38 = v9 * v33;
  double v39 = v9 * v28;
  double v40 = v9 * v31;
  double v41 = v9 * v34;
  double v42 = v29 + v11 * v28 + v10 * v27;
  double v43 = v32 + v11 * v31 + v10 * v30;
  *(double *)a3 = -1.0 / v3 * v36;
  *(double *)(a3 + 8) = -1.0 / v3 * v39;
  *(double *)(a3 + 16) = -1.0 / v3 * v42;
  *(double *)(a3 + 24) = -1.0 / v3 * v37;
  *(double *)(a3 + 32) = -1.0 / v3 * v40;
  *(double *)(a3 + 40) = -1.0 / v3 * v43;
  *(double *)(a3 + 48) = v38 + v7 / v3 * v37 + v36 * (v5 / v3);
  *(double *)(a3 + 56) = v41 + v7 / v3 * v40 + v39 * (v5 / v3);
  *(double *)(a3 + 64) = v35 + v11 * v34 + v10 * v33 + v7 / v3 * v43 + v42 * (v5 / v3);
  if (a2)
  {
    double v44 = v12 * v27;
    double v45 = v12 * v28;
    double v46 = v12 * v30;
    double v47 = v12 * v31;
    double v48 = v33 + v14 * v30 + v13 * v27;
    double v49 = v34 + v14 * v31 + v13 * v28;
    double v50 = 1.0 / v4;
    double v51 = v4 * v4;
    double v52 = 1.0 / v51;
    double v53 = -v6 / v51;
    double v54 = -v8 / v51;
    double v55 = 1.0 / v3;
    double v56 = v3 * v3;
    *(double *)(a3 + 72) = v50 * v44;
    *(double *)(a3 + 80) = v50 * v46;
    *(double *)(a3 + 120) = v52 * v44;
    *(double *)(a3 + 128) = v52 * v45;
    *(double *)(a3 + 136) = v54 * v45 + v44 * v53;
    *(double *)(a3 + 144) = v52 * v46;
    *(double *)(a3 + 152) = v52 * v47;
    *(double *)(a3 + 160) = v54 * v47 + v46 * v53;
    double v57 = -v7 / v56;
    *(double *)(a3 + 168) = v52 * v48;
    *(double *)(a3 + 176) = v52 * v49;
    *(double *)(a3 + 88) = v50 * v48;
    *(double *)(a3 + 96) = v55 * v36;
    *(double *)(a3 + 104) = v55 * v39;
    *(double *)(a3 + 112) = v55 * v42;
    *(double *)(a3 + 184) = v54 * v49 + v48 * v53;
    *(double *)(a3 + 192) = 1.0 / v56 * v36;
    *(double *)(a3 + 200) = 1.0 / v56 * v39;
    *(double *)(a3 + 208) = 1.0 / v56 * v42;
    *(double *)(a3 + 216) = 1.0 / v56 * v37;
    *(double *)(a3 + 224) = 1.0 / v56 * v40;
    double v58 = 1.0 / v56 * v43;
    double v59 = -v5 / v56;
    *(double *)(a3 + 232) = v58;
    *(double *)(a3 + 240) = v57 * v37 + v36 * v59;
    *(double *)(a3 + 248) = v57 * v40 + v39 * v59;
    *(double *)(a3 + 256) = v57 * v43 + v42 * v59;
  }
  return result;
}

const double *FundamentalEpipolarError_ABSVec(const double *result, const double *a2, unsigned int a3, double *a4, float64x2_t *a5)
{
  if ((int)a3 >= 1)
  {
    double v5 = a4[1];
    double v6 = a4[6];
    double v7 = a4[7];
    double v8 = a4[8];
    double v9 = a4[9];
    double v10 = a4[10];
    double v11 = a4[11];
    double v12 = a4[12];
    double v13 = a4[13];
    double v14 = a4[14];
    double v15 = a4[15];
    double v16 = a4[16];
    double v17 = a4[17];
    double v18 = -1.0 / *a4;
    double v19 = a4[2] / *a4;
    double v20 = a4[4] / *a4;
    double v21 = -1.0 / v5;
    double v22 = a4[3] / v5;
    double v23 = v13 * v14 - v17 * v10;
    double v24 = v13 * v15 - v17 * v11;
    double v25 = a4[5] / v5;
    double v26 = v13 * v16 - v17 * v12;
    double v27 = v17 * v6 - v9 * v14;
    double v28 = v17 * v7 - v9 * v15;
    double v29 = v17 * v8 - v9 * v16;
    double v30 = v9 * v10 - v13 * v6;
    double v31 = v9 * v11 - v13 * v7;
    double v32 = v9 * v12 - v13 * v8;
    double v33 = v18 * v23;
    double v34 = v18 * v27;
    double v35 = v18 * v24;
    double v36 = v18 * v28;
    double v37 = v26 + v20 * v24 + v19 * v23;
    double v38 = v29 + v20 * v28 + v19 * v27;
    double v39 = v32 + v20 * v31 + v19 * v30;
    double v40 = v21 * (v18 * v23);
    double v41 = v21 * (v18 * v24);
    double v42 = v21 * v37;
    double v43 = v21 * (v18 * v27);
    double v44 = v21 * v36;
    double v45 = v21 * v38;
    double v46 = v18 * v30 + v25 * v34 + v33 * v22;
    double v47 = v18 * v31 + v25 * v36 + v35 * v22;
    double v48 = v39 + v25 * v38 + v37 * v22;
    if (a3 <= 3)
    {
      uint64_t v49 = 0;
LABEL_18:
      uint64_t v67 = a3 - v49;
      uint64_t v68 = &a5->f64[v49];
      uint64_t v69 = (16 * v49) | 8;
      __int16 v70 = (double *)((char *)result + v69);
      double v71 = (double *)((char *)a2 + v69);
      do
      {
        double v72 = *(v70 - 1);
        double v73 = v42 + v41 * *v70 + v40 * v72;
        double v74 = v45 + v44 * *v70 + v43 * v72;
        double v75 = v48 + v47 * *v70 + v46 * v72 + *v71 * v74 + v73 * *(v71 - 1);
        *v68++ = sqrt(v75 * v75 / (v74 * v74 + v73 * v73) + 0.00155346992);
        v70 += 2;
        v71 += 2;
        --v67;
      }
      while (v67);
      return result;
    }
    uint64_t v49 = 0;
    double v50 = (char *)&a5->f64[a3];
    BOOL v52 = &a2[2 * a3] > (const double *)a5 && v50 > (char *)a2;
    if (v50 > (char *)result && &result[2 * a3] > (const double *)a5) {
      goto LABEL_18;
    }
    if (v52) {
      goto LABEL_18;
    }
    float64x2_t v54 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v40, 0);
    float64x2_t v55 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v42, 0);
    float64x2_t v56 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v43, 0);
    float64x2_t v57 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v45, 0);
    uint64_t v49 = a3 & 0xFFFFFFFE;
    float64x2_t v58 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v46, 0);
    float64x2_t v59 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v48, 0);
    unsigned int v60 = result;
    uint64_t v61 = a2;
    int v62 = a5;
    uint64_t v63 = v49;
    float64x2_t v64 = (float64x2_t)vdupq_n_s64(0x3F5973B9A04DB73CuLL);
    do
    {
      float64x2x2_t v76 = vld2q_f64(v60);
      v60 += 4;
      float64x2x2_t v77 = vld2q_f64(v61);
      v61 += 4;
      float64x2_t v65 = vaddq_f64(v55, vmlaq_f64(vmulq_n_f64(v76.val[1], v41), v76.val[0], v54));
      float64x2_t v66 = vaddq_f64(v57, vmlaq_f64(vmulq_n_f64(v76.val[1], v44), v76.val[0], v56));
      v76.val[0] = vaddq_f64(vaddq_f64(v59, vmlaq_f64(vmulq_n_f64(v76.val[1], v47), v76.val[0], v58)), vmlaq_f64(vmulq_f64(v77.val[1], v66), v77.val[0], v65));
      *v62++ = vsqrtq_f64(vaddq_f64(vdivq_f64(vmulq_f64(v76.val[0], v76.val[0]), vmlaq_f64(vmulq_f64(v66, v66), v65, v65)), v64));
      v63 -= 2;
    }
    while (v63);
    if (v49 != a3) {
      goto LABEL_18;
    }
  }
  return result;
}

double FundamentalEpipolarError_MeanVal(uint64_t a1, uint64_t a2, int a3, double *a4, double *a5)
{
  if (a3 < 1)
  {
    double v50 = 0.0;
    goto LABEL_10;
  }
  double v5 = a4[1];
  double v6 = a4[6];
  double v7 = a4[7];
  double v8 = a4[8];
  double v9 = a4[9];
  double v10 = a4[10];
  double v11 = a4[11];
  double v12 = a4[12];
  double v13 = a4[13];
  double v14 = a4[14];
  double v15 = a4[15];
  double v16 = a4[16];
  double v17 = a4[17];
  double v18 = -1.0 / *a4;
  double v19 = a4[2] / *a4;
  double v20 = a4[4] / *a4;
  double v21 = -1.0 / v5;
  double v22 = a4[3] / v5;
  double v23 = v13 * v14 - v17 * v10;
  double v24 = v13 * v15 - v17 * v11;
  double v25 = a4[5] / v5;
  double v26 = v13 * v16 - v17 * v12;
  double v27 = v17 * v6 - v9 * v14;
  double v28 = v17 * v7 - v9 * v15;
  double v29 = v17 * v8 - v9 * v16;
  double v30 = v9 * v10 - v13 * v6;
  double v31 = v9 * v11 - v13 * v7;
  double v32 = v9 * v12 - v13 * v8;
  double v33 = v18 * v23;
  double v34 = v18 * v27;
  double v35 = v18 * v24;
  double v36 = v18 * v28;
  double v37 = v26 + v20 * v24 + v19 * v23;
  double v38 = v29 + v20 * v28 + v19 * v27;
  double v39 = v32 + v20 * v31 + v19 * v30;
  double v40 = v21 * (v18 * v23);
  double v41 = v21 * (v18 * v24);
  double v42 = v21 * v37;
  double v43 = v21 * (v18 * v27);
  double v44 = v21 * v36;
  double v45 = v21 * v38;
  double v46 = v18 * v30 + v25 * v34 + v33 * v22;
  double v47 = v18 * v31 + v25 * v36 + v35 * v22;
  double v48 = v39 + v25 * v38 + v37 * v22;
  if (a3 <= 3)
  {
    uint64_t v49 = 0;
    double v50 = 0.0;
LABEL_8:
    uint64_t v67 = a3 - v49;
    uint64_t v68 = (16 * v49) | 8;
    uint64_t v69 = (double *)(a2 + v68);
    __int16 v70 = (double *)(a1 + v68);
    do
    {
      double v71 = *(v70 - 1);
      double v72 = v42 + v41 * *v70 + v40 * v71;
      double v73 = v45 + v44 * *v70 + v43 * v71;
      double v74 = v48 + v47 * *v70 + v46 * v71 + *v69 * v73 + v72 * *(v69 - 1);
      double v50 = v50 + sqrt(v74 * v74 / (v73 * v73 + v72 * v72) + 0.00155346992);
      v69 += 2;
      v70 += 2;
      --v67;
    }
    while (v67);
    goto LABEL_10;
  }
  float64x2_t v51 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v40, 0);
  float64x2_t v52 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v42, 0);
  float64x2_t v53 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v43, 0);
  float64x2_t v54 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v45, 0);
  uint64_t v49 = a3 & 0xFFFFFFFC;
  float64x2_t v55 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v46, 0);
  float64x2_t v56 = (const double *)(a2 + 32);
  float64x2_t v57 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v48, 0);
  float64x2_t v58 = (const double *)(a1 + 32);
  double v50 = 0.0;
  uint64_t v59 = v49;
  float64x2_t v60 = (float64x2_t)vdupq_n_s64(0x3F5973B9A04DB73CuLL);
  do
  {
    uint64_t v61 = v58 - 4;
    float64x2x2_t v77 = vld2q_f64(v61);
    float64x2x2_t v78 = vld2q_f64(v58);
    float64x2x2_t v79 = vld2q_f64(v56);
    int v62 = v56 - 4;
    float64x2x2_t v76 = vld2q_f64(v62);
    float64x2_t v63 = vaddq_f64(v52, vmlaq_f64(vmulq_n_f64(v78.val[1], v41), v78.val[0], v51));
    float64x2_t v64 = vaddq_f64(v54, vmlaq_f64(vmulq_n_f64(v77.val[1], v44), v77.val[0], v53));
    float64x2_t v65 = vaddq_f64(v54, vmlaq_f64(vmulq_n_f64(v78.val[1], v44), v78.val[0], v53));
    float64x2_t v66 = vmlaq_f64(vmulq_n_f64(v77.val[1], v47), v77.val[0], v55);
    v77.val[0] = vaddq_f64(v52, vmlaq_f64(vmulq_n_f64(v77.val[1], v41), v77.val[0], v51));
    v77.val[1] = vaddq_f64(vaddq_f64(v57, v66), vmlaq_f64(vmulq_f64(v76.val[1], v64), v76.val[0], v77.val[0]));
    v78.val[0] = vaddq_f64(vaddq_f64(v57, vmlaq_f64(vmulq_n_f64(v78.val[1], v47), v78.val[0], v55)), vmlaq_f64(vmulq_f64(v79.val[1], v65), v79.val[0], v63));
    v77.val[0] = vsqrtq_f64(vaddq_f64(vdivq_f64(vmulq_f64(v77.val[1], v77.val[1]), vmlaq_f64(vmulq_f64(v64, v64), v77.val[0], v77.val[0])), v60));
    v77.val[1] = vsqrtq_f64(vaddq_f64(vdivq_f64(vmulq_f64(v78.val[0], v78.val[0]), vmlaq_f64(vmulq_f64(v65, v65), v63, v63)), v60));
    double v50 = v50 + v77.val[0].f64[0] + v77.val[0].f64[1] + v77.val[1].f64[0] + v77.val[1].f64[1];
    v56 += 8;
    v58 += 8;
    v59 -= 4;
  }
  while (v59);
  if (v49 != a3) {
    goto LABEL_8;
  }
LABEL_10:
  double result = v50 / (double)a3;
  *a5 = result;
  return result;
}

double FundamentalEpipolarError_MeanValPlusGradient(uint64_t a1, uint64_t a2, int a3, long long *a4, double *a5, double *a6)
{
  double v185 = 0.0;
  long long v184 = 0u;
  long long v183 = 0u;
  long long v182 = 0u;
  long long v181 = 0u;
  long long v180 = 0u;
  long long v179 = 0u;
  long long v178 = 0u;
  long long v177 = 0u;
  long long v176 = 0u;
  long long v175 = 0u;
  long long v174 = 0u;
  long long v173 = 0u;
  long long v172 = 0u;
  long long v171 = 0u;
  long long v170 = 0u;
  long long v169 = 0u;
  long long v12 = a4[7];
  v168[6] = a4[6];
  v168[7] = v12;
  v168[8] = a4[8];
  long long v13 = a4[2];
  v168[3] = a4[3];
  long long v14 = a4[4];
  v168[5] = a4[5];
  v168[4] = v14;
  long long v15 = *a4;
  v168[1] = a4[1];
  v168[2] = v13;
  v168[0] = v15;
  FundamentalEpipolarError_precomputeFundamental((double *)v168, 1, (uint64_t)&v169);
  if (a3 < 1)
  {
    double v35 = 0.0;
    double v34 = 0.0;
    double v33 = 0.0;
    double v31 = 0.0;
    double v30 = 0.0;
    goto LABEL_10;
  }
  double v20 = *((double *)&v169 + 1);
  *(void *)&long long v16 = v169;
  *(void *)&long long v6 = *((void *)&v170 + 1);
  *(void *)&long long v17 = *((void *)&v171 + 1);
  double v21 = *((double *)&v172 + 1);
  *(void *)&long long v19 = v172;
  *(void *)&long long v18 = *((void *)&v174 + 1);
  double v22 = *(double *)&v174;
  double v23 = *((double *)&v175 + 1);
  double v24 = *(double *)&v177;
  double v26 = *((double *)&v178 + 1);
  double v25 = *(double *)&v178;
  double v27 = *(double *)&v180;
  if (a3 <= 3)
  {
    uint64_t v28 = 0;
    long long v29 = v6;
    double v30 = 0.0;
    double v31 = 0.0;
    long long v32 = v16;
    double v33 = 0.0;
    double v34 = 0.0;
    double v35 = 0.0;
    double v36 = *(double *)&v179;
    double v37 = v185;
    double v38 = *(double *)&v170;
LABEL_8:
    uint64_t v97 = a3 - v28;
    uint64_t v98 = (16 * v28) | 8;
    uint64_t v99 = (double *)(a2 + v98);
    float64x2_t v100 = (double *)(a1 + v98);
    do
    {
      double v101 = *(v100 - 1);
      double v102 = *(v99 - 1);
      double v103 = v38 + *v100 * v20 + *(double *)&v32 * v101;
      double v104 = *(double *)&v17 + *v100 * *(double *)&v171 + *(double *)&v29 * v101;
      long long v105 = v17;
      long long v106 = v18;
      double v107 = *(double *)&v173 + *v100 * v21 + *(double *)&v19 * v101;
      long long v108 = v29;
      long long v109 = v32;
      double v110 = *v100 * *((double *)&v175 + 1) + *(double *)&v175 * v101;
      long long v111 = v19;
      double v112 = *((double *)&v177 + 1) + *v100 * *(double *)&v177 + *((double *)&v176 + 1) * v101;
      double v113 = v36 + *v100 * v26 + v25 * v101;
      double v114 = *v99 * v104 + v103 * v102 + v107;
      double v115 = *(double *)&v182 + *v100 * *((double *)&v181 + 1) + *(double *)&v181 * v101;
      double v116 = *v99 * v113 + v102 * v112 + *((double *)&v180 + 1) + *v100 * v27 + *((double *)&v179 + 1) * v101;
      double v117 = *((double *)&v183 + 1) + *v100 * *(double *)&v183 + *((double *)&v182 + 1) * v101;
      double v118 = *v99 * v22 + v102 * *((double *)&v173 + 1);
      double v119 = *v99 * v117 + v102 * v115 + v37 + *v100 * *((double *)&v184 + 1) + *(double *)&v184 * v101;
      double v120 = v104 * v104 + v103 * v103;
      double v121 = v104 * v113;
      long long v19 = v111;
      double v122 = v121 + v103 * v112;
      double v123 = v114 * v114 / v120;
      double v124 = v114 / v120;
      double v125 = v104 * v117 + v103 * v115;
      long long v18 = v106;
      double v126 = v104 * v22 + v103 * *((double *)&v173 + 1);
      double v127 = *(double *)&v106 + v118;
      double v27 = *(double *)&v180;
      double v26 = *((double *)&v178 + 1);
      double v128 = v127 - v124 * v126;
      double v129 = v116 - v124 * v122;
      double v130 = v119 - v124 * v125;
      long long v17 = v105;
      double v131 = v123 + 0.00155346992;
      long long v32 = v109;
      double v132 = sqrt(v131);
      double v133 = v124 / v132;
      double v134 = *(double *)&v176 + v110;
      long long v29 = v108;
      double v30 = v30 + v132;
      double v31 = v31 + v128 * v133;
      double v33 = v33 + v133 * v134;
      double v34 = v34 + v133 * v129;
      double v35 = v35 + v133 * v130;
      v99 += 2;
      v100 += 2;
      --v97;
    }
    while (v97);
    goto LABEL_10;
  }
  long long v140 = v16;
  float64x2_t v161 = (float64x2_t)vdupq_lane_s64(v170, 0);
  float64x2_t v162 = (float64x2_t)vdupq_lane_s64(v169, 0);
  long long v138 = v17;
  long long v139 = v6;
  float64x2_t v159 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v171 + 1), 0);
  float64x2_t v160 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v170 + 1), 0);
  long long v137 = v19;
  float64x2_t v157 = (float64x2_t)vdupq_lane_s64(v173, 0);
  float64x2_t v158 = (float64x2_t)vdupq_lane_s64(v172, 0);
  float64x2_t v155 = (float64x2_t)vdupq_lane_s64(v176, 0);
  float64x2_t v156 = (float64x2_t)vdupq_lane_s64(v175, 0);
  float64x2_t v153 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v177 + 1), 0);
  float64x2_t v154 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v176 + 1), 0);
  float64x2_t v151 = (float64x2_t)vdupq_lane_s64(v179, 0);
  float64x2_t v152 = (float64x2_t)vdupq_lane_s64(v178, 0);
  uint64_t v28 = a3 & 0xFFFFFFFC;
  double v39 = (const double *)(a2 + 32);
  float64x2_t v149 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v180 + 1), 0);
  float64x2_t v150 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v179 + 1), 0);
  double v40 = (const double *)(a1 + 32);
  double v30 = 0.0;
  uint64_t v41 = v28;
  float64x2_t v147 = (float64x2_t)vdupq_lane_s64(v182, 0);
  float64x2_t v148 = (float64x2_t)vdupq_lane_s64(v181, 0);
  float64x2_t v145 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v183 + 1), 0);
  float64x2_t v146 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v182 + 1), 0);
  double v31 = 0.0;
  double v33 = 0.0;
  float64x2_t v143 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v185, 0);
  float64x2_t v144 = (float64x2_t)vdupq_lane_s64(v184, 0);
  double v34 = 0.0;
  long long v136 = v18;
  double v35 = 0.0;
  float64x2_t v141 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v174 + 1), 0);
  float64x2_t v142 = (float64x2_t)vdupq_lane_s64(*((uint64_t *)&v173 + 1), 0);
  do
  {
    double v165 = v30;
    double v42 = v40 - 4;
    float64x2x2_t v188 = vld2q_f64(v42);
    float64x2x2_t v187 = vld2q_f64(v40);
    float64x2x2_t v189 = vld2q_f64(v39);
    double v43 = v39 - 4;
    float64x2x2_t v186 = vld2q_f64(v43);
    float64x2_t v44 = vmlaq_f64(vmulq_n_f64(v187.val[1], v20), v187.val[0], v162);
    float64x2_t v45 = vmlaq_f64(vmulq_n_f64(v187.val[1], *(double *)&v171), v187.val[0], v160);
    float64x2_t v164 = vmlaq_f64(vmulq_n_f64(v188.val[1], v21), v188.val[0], v158);
    float64x2_t v163 = vmlaq_f64(vmulq_n_f64(v187.val[1], v21), v187.val[0], v158);
    float64x2_t v166 = vmlaq_f64(vmulq_n_f64(v188.val[1], v23), v188.val[0], v156);
    float64x2_t v167 = vmlaq_f64(vmulq_n_f64(v187.val[1], v23), v187.val[0], v156);
    float64x2_t v46 = vaddq_f64(v161, vmlaq_f64(vmulq_n_f64(v188.val[1], v20), v188.val[0], v162));
    float64x2_t v47 = vmlaq_f64(vmulq_n_f64(v187.val[1], v24), v187.val[0], v154);
    float64x2_t v48 = vaddq_f64(v159, vmlaq_f64(vmulq_n_f64(v188.val[1], *(double *)&v171), v188.val[0], v160));
    float64x2_t v49 = vmlaq_f64(vmulq_n_f64(v187.val[1], v26), v187.val[0], v152);
    float64x2_t v50 = vaddq_f64(v153, vmlaq_f64(vmulq_n_f64(v188.val[1], v24), v188.val[0], v154));
    float64x2_t v51 = vmlaq_f64(vmulq_n_f64(v188.val[1], v27), v188.val[0], v150);
    float64x2_t v52 = vmlaq_f64(vmulq_n_f64(v187.val[1], v27), v187.val[0], v150);
    float64x2_t v53 = vaddq_f64(v151, vmlaq_f64(vmulq_n_f64(v188.val[1], v26), v188.val[0], v152));
    float64x2_t v54 = vmlaq_f64(vmulq_n_f64(v187.val[1], *((double *)&v181 + 1)), v187.val[0], v148);
    float64x2_t v55 = vaddq_f64(v147, vmlaq_f64(vmulq_n_f64(v188.val[1], *((double *)&v181 + 1)), v188.val[0], v148));
    float64x2_t v56 = vmlaq_f64(vmulq_n_f64(v188.val[1], *((double *)&v184 + 1)), v188.val[0], v144);
    float64x2_t v57 = vmlaq_f64(vmulq_n_f64(v187.val[1], *(double *)&v183), v187.val[0], v146);
    v188.val[1] = vaddq_f64(v145, vmlaq_f64(vmulq_n_f64(v188.val[1], *(double *)&v183), v188.val[0], v146));
    float64x2_t v58 = vmlaq_f64(vmulq_f64(v186.val[1], v48), v186.val[0], v46);
    float64x2_t v59 = vmlaq_f64(vmulq_n_f64(v187.val[1], *((double *)&v184 + 1)), v187.val[0], v144);
    v188.val[0] = vmlaq_f64(vmulq_n_f64(v186.val[1], *(double *)&v174), v142, v186.val[0]);
    v187.val[0] = vmlaq_f64(vmulq_f64(v186.val[1], v53), v50, v186.val[0]);
    v187.val[1] = vmlaq_f64(vmulq_f64(v186.val[1], v188.val[1]), v55, v186.val[0]);
    float64x2_t v60 = vaddq_f64(v161, v44);
    float64x2_t v61 = vaddq_f64(v159, v45);
    float64x2_t v62 = vaddq_f64(v153, v47);
    float64x2_t v63 = vaddq_f64(v151, v49);
    float64x2_t v64 = vaddq_f64(v147, v54);
    float64x2_t v65 = vaddq_f64(v145, v57);
    v186.val[1] = vmlaq_f64(vmulq_n_f64(v189.val[1], *(double *)&v174), v142, v189.val[0]);
    float64x2_t v66 = vaddq_f64(v58, vaddq_f64(v157, v164));
    float64x2_t v67 = vaddq_f64(vmlaq_f64(vmulq_f64(v189.val[1], v61), v189.val[0], v60), vaddq_f64(v157, v163));
    float64x2_t v68 = vaddq_f64(vmlaq_f64(vmulq_f64(v189.val[1], v63), v62, v189.val[0]), vaddq_f64(v149, v52));
    v189.val[0] = vaddq_f64(vmlaq_f64(vmulq_f64(v189.val[1], v65), v64, v189.val[0]), vaddq_f64(v143, v59));
    float64x2_t v69 = vmlaq_f64(vmulq_f64(v48, v53), v50, v46);
    v188.val[1] = vmlaq_f64(vmulq_f64(v48, v188.val[1]), v55, v46);
    double v22 = *(double *)&v174;
    v189.val[1] = vmlaq_f64(vmulq_f64(v48, v48), v46, v46);
    float64x2_t v70 = vmlaq_f64(vmulq_n_f64(v48, *(double *)&v174), v142, v46);
    float64x2_t v71 = vmlaq_f64(vmulq_f64(v61, v61), v60, v60);
    float64x2_t v72 = vmulq_f64(v61, v63);
    double v21 = *((double *)&v172 + 1);
    float64x2_t v73 = vmlaq_f64(v72, v62, v60);
    float64x2_t v74 = vmulq_f64(v67, v67);
    float64x2_t v75 = vdivq_f64(v67, v71);
    float64x2_t v76 = vdivq_f64(v74, v71);
    float64x2_t v77 = vmlaq_f64(vmulq_f64(v61, v65), v64, v60);
    float64x2_t v78 = vmlaq_f64(vmulq_n_f64(v61, *(double *)&v174), v142, v60);
    float64x2_t v79 = vdivq_f64(v66, v189.val[1]);
    v188.val[0] = vmlsq_f64(vaddq_f64(v141, v188.val[0]), v70, v79);
    float64x2_t v80 = vmlsq_f64(vaddq_f64(v141, v186.val[1]), v78, v75);
    float64x2_t v81 = vmlsq_f64(vaddq_f64(v187.val[0], vaddq_f64(v149, v51)), v69, v79);
    float64x2_t v82 = vmulq_f64(v66, v66);
    double v27 = *(double *)&v180;
    double v26 = *((double *)&v178 + 1);
    float64x2_t v83 = vmlsq_f64(v68, v73, v75);
    double v20 = *((double *)&v169 + 1);
    float64x2_t v84 = vmlsq_f64(vaddq_f64(v187.val[1], vaddq_f64(v143, v56)), v188.val[1], v79);
    float64x2_t v85 = (float64x2_t)vdupq_n_s64(0x3F5973B9A04DB73CuLL);
    float64x2_t v86 = vaddq_f64(v76, v85);
    v189.val[0] = vmlsq_f64(v189.val[0], v77, v75);
    float64x2_t v87 = vsqrtq_f64(vaddq_f64(vdivq_f64(v82, v189.val[1]), v85));
    float64x2_t v88 = vdivq_f64(v79, v87);
    float64x2_t v89 = vmulq_f64(v188.val[0], v88);
    float64x2_t v90 = vmulq_f64(v88, vaddq_f64(v155, v166));
    v188.val[0] = vmulq_f64(v88, v81);
    float64x2_t v91 = vmulq_f64(v88, v84);
    float64x2_t v92 = vsqrtq_f64(v86);
    float64x2_t v93 = vdivq_f64(v75, v92);
    float64x2_t v94 = vmulq_f64(v80, v93);
    v188.val[1] = vmulq_f64(v93, vaddq_f64(v155, v167));
    float64x2_t v95 = vmulq_f64(v93, v83);
    double v24 = *(double *)&v177;
    float64x2_t v96 = vmulq_f64(v93, v189.val[0]);
    double v30 = v165 + v87.f64[0] + v87.f64[1] + v92.f64[0] + v92.f64[1];
    double v31 = v31 + v89.f64[0] + v89.f64[1] + v94.f64[0] + v94.f64[1];
    double v33 = v33 + v90.f64[0] + v90.f64[1] + v188.val[1].f64[0] + v188.val[1].f64[1];
    v92.f64[0] = v35 + v91.f64[0] + v91.f64[1];
    v91.f64[0] = v34 + v188.val[0].f64[0] + v188.val[0].f64[1] + v95.f64[0];
    double v23 = *((double *)&v175 + 1);
    double v34 = v91.f64[0] + v95.f64[1];
    double v35 = v92.f64[0] + v96.f64[0] + v96.f64[1];
    v39 += 8;
    v40 += 8;
    v41 -= 4;
  }
  while (v41);
  double v38 = *(double *)&v170;
  long long v32 = v140;
  long long v17 = v138;
  long long v29 = v139;
  long long v19 = v137;
  double v25 = *(double *)&v178;
  long long v18 = v136;
  double v37 = v185;
  double v36 = *(double *)&v179;
  if (v28 != a3) {
    goto LABEL_8;
  }
LABEL_10:
  *a5 = v30 / (double)a3;
  *a6 = v31 / (double)a3;
  a6[1] = v33 / (double)a3;
  double result = v35 / (double)a3;
  a6[2] = v34 / (double)a3;
  a6[3] = result;
  return result;
}

void SelectPointsWithEpipolarThreshold(const double *a1, const double *a2, signed int a3, double *a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8, double a9)
{
  long long v18 = (float64x2_t *)malloc_type_malloc(8 * a3, 0x100004000313F17uLL);
  if (v18 && (FundamentalEpipolarError_ABSVec(a1, a2, a3, a4, v18), a3 >= 1))
  {
    uint64_t v19 = a3;
    if (a8)
    {
      unint64_t v20 = 0;
      int v21 = 0;
      double v22 = a2 + 1;
      double v23 = a1 + 1;
      do
      {
        if (v18->f64[v20] < a9)
        {
          if (v20 <= 0x7FF) {
            *(unsigned char *)(a8 + v20) = 1;
          }
          uint64_t v24 = 16 * v21;
          *(void *)(a5 + v24) = *(v23 - 1);
          uint64_t v25 = (16 * v21) | 8;
          *(void *)(a5 + v25) = *v23;
          *(void *)(a6 + v24) = *(v22 - 1);
          *(void *)(a6 + v25) = *v22;
          ++v21;
        }
        ++v20;
        v22 += 2;
        v23 += 2;
      }
      while (a3 != v20);
    }
    else
    {
      int v21 = 0;
      double v26 = a2 + 1;
      double v27 = a1 + 1;
      uint64_t v28 = (double *)v18;
      do
      {
        if (*v28 < a9)
        {
          uint64_t v29 = 16 * v21;
          *(void *)(a5 + v29) = *(v27 - 1);
          uint64_t v30 = (16 * v21) | 8;
          *(void *)(a5 + v30) = *v27;
          *(void *)(a6 + v29) = *(v26 - 1);
          *(void *)(a6 + v30) = *v26;
          ++v21;
        }
        v26 += 2;
        v27 += 2;
        ++v28;
        --v19;
      }
      while (v19);
    }
  }
  else
  {
    int v21 = 0;
  }
  *a7 = v21;
  free(v18);
}

void sub_215FA2770(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FA2810(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FA2894(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FA3934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_215FA3F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)(v24 - 128));
  _Unwind_Resume(a1);
}

void sub_215FA4100(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FA4460(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215FA4544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215FA48D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_215FA4E9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_215FA5014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADPearlColorInFieldCalibrationExecutor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215FA50F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215FA55D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

CFTypeRef PixelBufferUtils::copyAttachment(PixelBufferUtils *this, const __CFString *a2, CVAttachmentMode *a3, CVAttachmentMode *a4)
{
  CFTypeRef v4 = 0;
  if (this)
  {
    if (a2)
    {
      CFTypeRef Attachment = CVBufferGetAttachment(this, a2, a3);
      CFTypeRef v4 = Attachment;
      if (Attachment) {
        CFRetain(Attachment);
      }
    }
  }
  return v4;
}

CFDictionaryRef PixelBufferUtils::copyAttachments(PixelBufferUtils *this, __CVBuffer *a2, CVAttachmentMode a3)
{
  if (!this) {
    return 0;
  }
  CFDictionaryRef Attachments = CVBufferGetAttachments(this, (CVAttachmentMode)a2);
  CFDictionaryRef v4 = Attachments;
  if (Attachments) {
    CFRetain(Attachments);
  }
  return v4;
}

unint64_t PixelBufferUtils::pixelFormatAsString@<X0>(unint64_t this@<X0>, char *a2@<X8>)
{
  if (this == 32)
  {
    a2[23] = 4;
    int v3 = 1111970369;
    goto LABEL_5;
  }
  if (this == 24)
  {
    a2[23] = 4;
    int v3 = 1196569650;
LABEL_5:
    *(_DWORD *)a2 = v3;
    a2[4] = 0;
    return this;
  }
  __s[0] = BYTE3(this);
  __s[1] = BYTE2(this);
  __s[2] = BYTE1(this);
  __s[3] = this;
  __s[4] = 0;
  this = strlen(__s);
  if (this > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v4 = this;
  if (this >= 0x17)
  {
    uint64_t v6 = (this & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((this | 7) != 0x17) {
      uint64_t v6 = this | 7;
    }
    uint64_t v7 = v6 + 1;
    double v5 = operator new(v6 + 1);
    *((void *)a2 + 1) = v4;
    *((void *)a2 + 2) = v7 | 0x8000000000000000;
    *(void *)a2 = v5;
    goto LABEL_14;
  }
  a2[23] = this;
  double v5 = a2;
  if (this) {
LABEL_14:
  }
    this = (unint64_t)memcpy(v5, __s, v4);
  *((unsigned char *)v5 + v4) = 0;
  if (a2[23] >= 0) {
    double v8 = a2;
  }
  else {
    double v8 = *(char **)a2;
  }
  if (*v8 <= 31)
  {
    int v40 = a2[23];
    std::string __p = *(void **)a2;
    uint64_t v9 = MEMORY[0x263F8C328] + 104;
    v50[0] = MEMORY[0x263F8C328] + 104;
    uint64_t v10 = MEMORY[0x263F8C328] + 64;
    uint64_t v45 = MEMORY[0x263F8C328] + 64;
    double v11 = (void *)MEMORY[0x263F8C2B8];
    uint64_t v12 = *(void *)(MEMORY[0x263F8C2B8] + 24);
    *(void *)__s = *(void *)(MEMORY[0x263F8C2B8] + 16);
    *(void *)&__s[*(void *)(*(void *)__s - 24)] = v12;
    uint64_t v44 = 0;
    long long v13 = (std::ios_base *)&__s[*(void *)(*(void *)__s - 24)];
    std::ios_base::init(v13, v46);
    uint64_t v14 = MEMORY[0x263F8C328] + 24;
    v13[1].__vftable = 0;
    v13[1].__fmtflags_ = -1;
    uint64_t v15 = v11[5];
    uint64_t v45 = v11[4];
    *(void *)((char *)&v46[-1] + *(void *)(v45 - 24)) = v15;
    *(void *)__s = v11[1];
    *(void *)&__s[*(void *)(*(void *)__s - 24)] = v11[6];
    v50[0] = v9;
    *(void *)__s = v14;
    uint64_t v45 = v10;
    std::streambuf::basic_streambuf();
    uint64_t v16 = MEMORY[0x263F8C318] + 16;
    v46[0] = MEMORY[0x263F8C318] + 16;
    *(_OWORD *)float64x2_t v47 = 0u;
    long long v48 = 0u;
    int v49 = 24;
    MEMORY[0x2166C5C70](&v41, &v45);
    if ((_BYTE)v41)
    {
      uint64_t v38 = v16;
      long long v17 = (char *)&v46[-1] + *(void *)(v45 - 24);
      uint64_t v18 = *((void *)v17 + 5);
      int v19 = *((_DWORD *)v17 + 2);
      int v20 = *((_DWORD *)v17 + 36);
      if (v20 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)&v46[-1] + *(void *)(v45 - 24)));
        int v21 = std::locale::use_facet(&__b, MEMORY[0x263F8C108]);
        int v20 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 32);
        std::locale::~locale(&__b);
        *((_DWORD *)v17 + 36) = v20;
      }
      if ((v19 & 0xB0) == 0x20) {
        double v22 = "";
      }
      else {
        double v22 = "0x";
      }
      if (!v18) {
        goto LABEL_47;
      }
      uint64_t v23 = *((void *)v17 + 3);
      BOOL v24 = v23 <= 2;
      uint64_t v25 = v23 - 2;
      size_t v26 = v24 ? 0 : v25;
      uint64_t v27 = v22 - "0x";
      if (v22 - "0x" >= 1)
      {
        uint64_t v28 = v22;
        uint64_t v29 = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(void *)v18 + 96))(v18, "0x", v27);
        double v22 = v28;
        if (v29 != v27) {
          goto LABEL_47;
        }
      }
      if ((uint64_t)v26 >= 1)
      {
        if (v26 > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        double v37 = v22;
        if (v26 >= 0x17)
        {
          uint64_t v31 = (v26 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v26 | 7) != 0x17) {
            uint64_t v31 = v26 | 7;
          }
          uint64_t v32 = v31 + 1;
          p_b = (std::locale::__imp *)operator new(v31 + 1);
          size_t v52 = v26;
          int64_t v53 = v32 | 0x8000000000000000;
          __b.__locale_ = p_b;
        }
        else
        {
          HIBYTE(v53) = v26;
          p_b = (std::locale::__imp *)&__b;
        }
        memset(p_b, v20, v26);
        *((unsigned char *)p_b + v26) = 0;
        if (v53 >= 0) {
          locale = &__b;
        }
        else {
          locale = __b.__locale_;
        }
        uint64_t v34 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v18 + 96))(v18, locale, v26);
        double v22 = v37;
        if (SHIBYTE(v53) < 0)
        {
          operator delete(__b.__locale_);
          double v22 = v37;
        }
        if (v34 != v26) {
          goto LABEL_47;
        }
      }
      uint64_t v35 = "0x" - v22 + 2;
      if (v35 < 1 || (*(uint64_t (**)(uint64_t))(*(void *)v18 + 96))(v18) == v35)
      {
        *((void *)v17 + 3) = 0;
        double v11 = (void *)MEMORY[0x263F8C2B8];
        uint64_t v16 = v38;
      }
      else
      {
LABEL_47:
        double v11 = (void *)MEMORY[0x263F8C2B8];
        uint64_t v16 = v38;
        std::ios_base::clear((std::ios_base *)((char *)&v46[-1] + *(void *)(v45 - 24)), *(_DWORD *)((char *)&v46[3] + *(void *)(v45 - 24)) | 5);
      }
    }
    MEMORY[0x2166C5C80](&v41);
    *(_DWORD *)((char *)v46 + *(void *)(v45 - 24)) = *(_DWORD *)((unsigned char *)v46 + *(void *)(v45 - 24)) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    std::stringbuf::str();
    if (v40 < 0) {
      operator delete(__p);
    }
    *(_OWORD *)a2 = v41;
    *((void *)a2 + 2) = v42;
    *(void *)__s = *v11;
    uint64_t v36 = v11[9];
    *(void *)&__s[*(void *)(*(void *)__s - 24)] = v11[8];
    uint64_t v45 = v36;
    v46[0] = v16;
    if (SBYTE7(v48) < 0) {
      operator delete(v47[0]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    return MEMORY[0x2166C5D20](v50);
  }
  return this;
}

void sub_215FA5E6C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, int a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21)
{
  if (*(char *)(v22 - 89) < 0) {
    operator delete(*(void **)(v22 - 112));
  }
  MEMORY[0x2166C5C80](&a16);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)(v21 + *(void *)(a21 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x215FA5D18);
}

void sub_215FA5EEC()
{
}

void sub_215FA5EFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2B8];
  uint64_t v3 = *MEMORY[0x263F8C2B8];
  *(void *)a1 = *MEMORY[0x263F8C2B8];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2166C5D20](a1 + 128);
  return a1;
}

uint64_t PixelBufferUtils::pixelFormatFromString(PixelBufferUtils *this, const char *a2)
{
  if (!strcmp((const char *)this, "24RG")) {
    return 24;
  }
  if (!strcmp((const char *)this, "ARGB")) {
    return 32;
  }
  return bswap32(*(_DWORD *)this);
}

unint64_t PixelBufferUtils::pixelFormatAsFileExtension@<X0>(PixelBufferUtils *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t result = PixelBufferUtils::pixelFormatAsString((unint64_t)this, (char *)a2);
  unint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  char v5 = v4;
  uint64_t v6 = *(unsigned char **)a2;
  unint64_t v7 = *(void *)(a2 + 8);
  if ((v4 & 0x80u) == 0) {
    double v8 = (unsigned char *)a2;
  }
  else {
    double v8 = *(unsigned char **)a2;
  }
  if ((v4 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  if (!v9) {
    goto LABEL_30;
  }
  uint64_t v10 = v8;
  if (v9 < 8) {
    goto LABEL_60;
  }
  unint64_t v11 = v9 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v12 = v8 + 3;
  unint64_t v13 = v9 & 0xFFFFFFFFFFFFFFF8;
  do
  {
    int8x8_t v14 = vceq_s8(*(int8x8_t *)(v12 - 3), (int8x8_t)0x2F2F2F2F2F2F2F2FLL);
    if (v14.i8[0])
    {
      *(v12 - 3) = 58;
      if ((v14.i8[1] & 1) == 0)
      {
LABEL_13:
        if ((v14.i8[2] & 1) == 0) {
          goto LABEL_14;
        }
        goto LABEL_22;
      }
    }
    else if ((v14.i8[1] & 1) == 0)
    {
      goto LABEL_13;
    }
    *(v12 - 2) = 58;
    if ((v14.i8[2] & 1) == 0)
    {
LABEL_14:
      if ((v14.i8[3] & 1) == 0) {
        goto LABEL_15;
      }
      goto LABEL_23;
    }
LABEL_22:
    *(v12 - 1) = 58;
    if ((v14.i8[3] & 1) == 0)
    {
LABEL_15:
      if ((v14.i8[4] & 1) == 0) {
        goto LABEL_16;
      }
      goto LABEL_24;
    }
LABEL_23:
    unsigned char *v12 = 58;
    if ((v14.i8[4] & 1) == 0)
    {
LABEL_16:
      if ((v14.i8[5] & 1) == 0) {
        goto LABEL_17;
      }
      goto LABEL_25;
    }
LABEL_24:
    v12[1] = 58;
    if ((v14.i8[5] & 1) == 0)
    {
LABEL_17:
      if (v14.i8[6]) {
        goto LABEL_26;
      }
      goto LABEL_18;
    }
LABEL_25:
    v12[2] = 58;
    if (v14.i8[6])
    {
LABEL_26:
      v12[3] = 58;
      if ((v14.i8[7] & 1) == 0) {
        goto LABEL_10;
      }
      goto LABEL_27;
    }
LABEL_18:
    if ((v14.i8[7] & 1) == 0) {
      goto LABEL_10;
    }
LABEL_27:
    v12[4] = 58;
LABEL_10:
    v12 += 8;
    v13 -= 8;
  }
  while (v13);
  if (v9 == v11) {
    goto LABEL_29;
  }
  uint64_t v10 = &v8[v11];
LABEL_60:
  uint64_t v22 = &v8[v9];
  do
  {
    if (*v10 == 47) {
      *uint64_t v10 = 58;
    }
    ++v10;
  }
  while (v10 != v22);
LABEL_29:
  unint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  uint64_t v6 = *(unsigned char **)a2;
  unint64_t v7 = *(void *)(a2 + 8);
  char v5 = *(unsigned char *)(a2 + 23);
LABEL_30:
  if (v5 >= 0) {
    uint64_t v15 = (unsigned char *)a2;
  }
  else {
    uint64_t v15 = v6;
  }
  if (v5 >= 0) {
    unint64_t v16 = v4;
  }
  else {
    unint64_t v16 = v7;
  }
  if (!v16) {
    return result;
  }
  long long v17 = v15;
  if (v16 < 8) {
    goto LABEL_65;
  }
  unint64_t v18 = v16 & 0xFFFFFFFFFFFFFFF8;
  int v19 = v15 + 3;
  unint64_t v20 = v16 & 0xFFFFFFFFFFFFFFF8;
  while (2)
  {
    int8x8_t v21 = vceq_s8(*(int8x8_t *)(v19 - 3), (int8x8_t)0x2E2E2E2E2E2E2E2ELL);
    if (v21.i8[0])
    {
      *(v19 - 3) = 95;
      if (v21.i8[1]) {
        goto LABEL_50;
      }
LABEL_42:
      if ((v21.i8[2] & 1) == 0) {
        goto LABEL_43;
      }
LABEL_51:
      *(v19 - 1) = 95;
      if (v21.i8[3]) {
        goto LABEL_52;
      }
LABEL_44:
      if ((v21.i8[4] & 1) == 0) {
        goto LABEL_45;
      }
LABEL_53:
      v19[1] = 95;
      if (v21.i8[5]) {
        goto LABEL_54;
      }
LABEL_46:
      if ((v21.i8[6] & 1) == 0) {
        goto LABEL_47;
      }
LABEL_55:
      _OWORD v19[3] = 95;
      if (v21.i8[7]) {
LABEL_56:
      }
        v19[4] = 95;
    }
    else
    {
      if ((v21.i8[1] & 1) == 0) {
        goto LABEL_42;
      }
LABEL_50:
      *(v19 - 2) = 95;
      if (v21.i8[2]) {
        goto LABEL_51;
      }
LABEL_43:
      if ((v21.i8[3] & 1) == 0) {
        goto LABEL_44;
      }
LABEL_52:
      unsigned char *v19 = 95;
      if (v21.i8[4]) {
        goto LABEL_53;
      }
LABEL_45:
      if ((v21.i8[5] & 1) == 0) {
        goto LABEL_46;
      }
LABEL_54:
      v19[2] = 95;
      if (v21.i8[6]) {
        goto LABEL_55;
      }
LABEL_47:
      if (v21.i8[7]) {
        goto LABEL_56;
      }
    }
    v19 += 8;
    v20 -= 8;
    if (v20) {
      continue;
    }
    break;
  }
  if (v16 == v18) {
    return result;
  }
  long long v17 = &v15[v18];
LABEL_65:
  uint64_t v23 = &v15[v16];
  do
  {
    if (*v17 == 46) {
      unsigned char *v17 = 95;
    }
    ++v17;
  }
  while (v17 != v23);
  return result;
}

uint64_t PixelBufferUtils::pixelFormatFromFileExtension(PixelBufferUtils *this, const char *a2)
{
  id v2 = [NSString stringWithUTF8String:this];
  if (([v2 isEqualToString:&stru_26C6879A8] & 1) != 0 || objc_msgSend(v2, "length") != 4)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v3 = [v2 stringByReplacingOccurrencesOfString:@":" withString:@"/"];

    unint64_t v4 = [v3 stringByReplacingOccurrencesOfString:@"_" withString:@"."];

    id v2 = v4;
    char v5 = (unsigned int *)[v2 UTF8String];
    if (!strcmp((const char *)v5, "24RG"))
    {
      uint64_t v6 = 24;
    }
    else if (!strcmp((const char *)v5, "ARGB"))
    {
      uint64_t v6 = 32;
    }
    else
    {
      uint64_t v6 = bswap32(*v5);
    }
  }

  return v6;
}

void sub_215FA6460(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t PixelBufferUtils::wrapAsDifferentPixelFormat(PixelBufferUtils *this, __CVBuffer *a2, CVPixelBufferRef *a3, __CVBuffer **a4)
{
  OSType v5 = a2;
  CVPixelBufferRetain(this);
  CVPixelBufferLockBaseAddress(this, 1uLL);
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  size_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  BaseAddress = CVPixelBufferGetBaseAddress(this);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(this);
  CVPixelBufferCreateWithBytes(v7, Width, Height, v5, BaseAddress, BytesPerRow, (CVPixelBufferReleaseBytesCallback)pixelBufferDeallocator, this, 0, a3);
  return CVPixelBufferUnlockBaseAddress(this, 1uLL);
}

void PixelBufferUtils::asVImageBuffer(PixelBufferUtils *this@<X0>, __CVBuffer *a2@<X1>, CGRect a3@<0:D0, 8:D1, 16:D2, 24:D3>, vImage_Buffer *a4@<X8>)
{
  CGFloat height = a3.size.height;
  CGFloat width = a3.size.width;
  CGFloat y = a3.origin.y;
  CGFloat x = a3.origin.x;
  BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(this, (size_t)a2);
  size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(this, (size_t)a2);
  size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(this, (size_t)a2);
  size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(this, (size_t)a2);
  if (!BaseAddressOfPlane)
  {
    NSLog(&cfstr_SDErrorAsvimag.isa, "asVImageBuffer", 231);
    size_t BytesPerRowOfPlane = 0;
    size_t WidthOfPlane = 0;
    size_t HeightOfPlane = 0;
  }
  v16[0] = BaseAddressOfPlane;
  v16[1] = HeightOfPlane;
  v16[2] = WidthOfPlane;
  v16[3] = BytesPerRowOfPlane;
  unint64_t PixelFormatType = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(this);
  v17.origin.CGFloat x = x;
  v17.origin.CGFloat y = y;
  v17.size.CGFloat width = width;
  v17.size.CGFloat height = height;
  cropVImageBuffer(a4, (uint64_t)v16, v17, PixelFormatType, (uint64_t)a2);
}

void cropVImageBuffer(vImage_Buffer *a1, uint64_t a2, CGRect a3, PixelBufferUtils *a4, uint64_t a5)
{
  double height = a3.size.height;
  double width = a3.size.width;
  double y = a3.origin.y;
  double x = a3.origin.x;
  long long v13 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&a1->data = *(_OWORD *)a2;
  *(_OWORD *)&a1->double width = v13;
  *(double *)&long long v13 = y;
  if (!CGRectIsEmpty(a3))
  {
    unint64_t v14 = PixelBufferUtils::verticalSubsamplingForPixelFormat(a4, a5);
    unint64_t v15 = PixelBufferUtils::horizontalSubsamplingForPixelFormat(a4, a5);
    unint64_t v16 = PixelBufferUtils::pixelSizeForPixelFormat(a4, a5);
    uint64_t v17 = *(void *)(a2 + 24);
    unint64_t v19 = *(void *)a2;
    uint64_t v18 = *(void *)(a2 + 8);
    vImagePixelCount v20 = vcvtpd_u64_f64(width / (double)v15);
    int8x8_t v21 = (void *)(*(void *)a2 + v17 * ((unint64_t)y / v14) + (unint64_t)x / v15 * v16);
    vImagePixelCount v22 = vcvtpd_u64_f64(height / (double)v14);
    a1->double height = v22;
    a1->double width = v20;
    a1->data = v21;
    unint64_t v23 = v19 + v18 * v17;
    BOOL v24 = (unint64_t)v21 < v19 || (unint64_t)v21 >= v23;
    if (v24 || (width >= (double)v20 ? (BOOL v25 = height < (double)v22) : (BOOL v25 = 1), v25))
    {
      NSLog(&cfstr_SDErrorCropOri.isa, "cropVImageBuffer", 206, *(void *)&x, *(void *)&y, *(void *)&width, *(void *)&height, *(void *)(a2 + 16) * v15, v18 * v14);
      *(_OWORD *)&a1->data = 0u;
      *(_OWORD *)&a1->double width = 0u;
    }
  }
}

uint64_t PixelBufferUtils::verticalSubsamplingForPixelFormat(PixelBufferUtils *this, uint64_t a2)
{
  uint64_t v4 = 1;
  if ((int)this > 1380401728)
  {
    if ((int)this > 1717856626)
    {
      if ((int)this <= 1751411058)
      {
        if (this == 1717856627) {
          return v4;
        }
        int v5 = 1751410032;
      }
      else
      {
        if (this == 1751411059 || this == 1919365990) {
          return v4;
        }
        int v5 = 1932996149;
      }
    }
    else if ((int)this <= 1380411456)
    {
      if (this == 1380401729) {
        return v4;
      }
      int v5 = 1380410945;
    }
    else
    {
      if (this == 1380411457 || this == 1647392359) {
        return v4;
      }
      int v5 = 1717855600;
    }
  }
  else if ((int)this > 875704437)
  {
    if ((int)this <= 1111970368)
    {
      if (this == 875704438) {
        goto LABEL_35;
      }
      int v5 = 1094862674;
    }
    else
    {
      if (this == 1111970369 || this == 1278226488) {
        return v4;
      }
      int v5 = 1278226536;
    }
  }
  else
  {
    if ((int)this > 825437746)
    {
      if (this == 825437747 || this == 843264104) {
        return v4;
      }
      if (this != 875704422) {
        goto LABEL_30;
      }
LABEL_35:
      if (a2) {
        return 2;
      }
      else {
        return 1;
      }
    }
    if (this == 32) {
      return v4;
    }
    int v5 = 825306677;
  }
  if (this == v5) {
    return v4;
  }
LABEL_30:
  uint64_t v6 = CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  if (v6)
  {
    CFAllocatorRef v7 = (void *)v6;
    if (PixelBufferUtils::planeCountForPixelFormat(this))
    {
      double v8 = [v7 objectForKeyedSubscript:*MEMORY[0x263F042C8]];
      uint64_t v9 = [v8 objectAtIndexedSubscript:a2];

      CFAllocatorRef v7 = (void *)v9;
    }
    uint64_t v10 = [v7 objectForKeyedSubscript:*MEMORY[0x263F042D0]];
    unint64_t v11 = v10;
    if (v10) {
      uint64_t v4 = (int)[v10 intValue];
    }
    else {
      uint64_t v4 = 1;
    }
  }
  else
  {
    PixelBufferUtils::pixelFormatAsString((unint64_t)this, (char *)__p);
    if (v15 >= 0) {
      uint64_t v12 = __p;
    }
    else {
      uint64_t v12 = (void **)__p[0];
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "verticalSubsamplingForPixelFormat", 416, this, v12);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  return v4;
}

void sub_215FA6A58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_215FA6A74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t PixelBufferUtils::horizontalSubsamplingForPixelFormat(PixelBufferUtils *this, uint64_t a2)
{
  uint64_t v4 = 1;
  if ((int)this > 1380401728)
  {
    if ((int)this > 1717856626)
    {
      if ((int)this <= 1751411058)
      {
        if (this == 1717856627) {
          return v4;
        }
        int v5 = 1751410032;
      }
      else
      {
        if (this == 1751411059 || this == 1919365990) {
          return v4;
        }
        int v5 = 1932996149;
      }
    }
    else if ((int)this <= 1380411456)
    {
      if (this == 1380401729) {
        return v4;
      }
      int v5 = 1380410945;
    }
    else
    {
      if (this == 1380411457 || this == 1647392359) {
        return v4;
      }
      int v5 = 1717855600;
    }
  }
  else if ((int)this > 875704437)
  {
    if ((int)this <= 1111970368)
    {
      if (this == 875704438) {
        goto LABEL_35;
      }
      int v5 = 1094862674;
    }
    else
    {
      if (this == 1111970369 || this == 1278226488) {
        return v4;
      }
      int v5 = 1278226536;
    }
  }
  else
  {
    if ((int)this > 825437746)
    {
      if (this == 825437747 || this == 843264104) {
        return v4;
      }
      if (this != 875704422) {
        goto LABEL_30;
      }
LABEL_35:
      if (a2) {
        return 2;
      }
      else {
        return 1;
      }
    }
    if (this == 32) {
      return v4;
    }
    int v5 = 825306677;
  }
  if (this == v5) {
    return v4;
  }
LABEL_30:
  uint64_t v6 = CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  if (v6)
  {
    CFAllocatorRef v7 = (void *)v6;
    if (PixelBufferUtils::planeCountForPixelFormat(this))
    {
      double v8 = [v7 objectForKeyedSubscript:*MEMORY[0x263F042C8]];
      uint64_t v9 = [v8 objectAtIndexedSubscript:a2];

      CFAllocatorRef v7 = (void *)v9;
    }
    uint64_t v10 = [v7 objectForKeyedSubscript:*MEMORY[0x263F042B8]];
    unint64_t v11 = v10;
    if (v10) {
      uint64_t v4 = (int)[v10 intValue];
    }
    else {
      uint64_t v4 = 1;
    }
  }
  else
  {
    PixelBufferUtils::pixelFormatAsString((unint64_t)this, (char *)__p);
    if (v15 >= 0) {
      uint64_t v12 = __p;
    }
    else {
      uint64_t v12 = (void **)__p[0];
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "horizontalSubsamplingForPixelFormat", 369, this, v12);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  return v4;
}

void sub_215FA6D6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_215FA6D88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t PixelBufferUtils::pixelSizeForPixelFormat(PixelBufferUtils *this, uint64_t a2)
{
  if ((int)this > 1278226535)
  {
    if ((int)this <= 1717855599)
    {
      if ((int)this <= 1380410944)
      {
        if (this != 1278226536)
        {
          if (this != 1380401729) {
            goto LABEL_41;
          }
          return 4;
        }
        return 2;
      }
      if (this == 1380410945) {
        return 16;
      }
      if (this == 1380411457) {
        return 8;
      }
      int v5 = 1647392359;
    }
    else if ((int)this > 1751411058)
    {
      if (this == 1751411059) {
        return 2;
      }
      if (this == 1919365990) {
        return 4;
      }
      int v5 = 1932996149;
    }
    else
    {
      if (this == 1717855600 || this == 1717856627) {
        return 4;
      }
      int v5 = 1751410032;
    }
LABEL_33:
    if (this != v5) {
      goto LABEL_41;
    }
    return 2;
  }
  if ((int)this <= 875704437)
  {
    if ((int)this > 825437746)
    {
      if (this != 825437747)
      {
        if (this != 843264104)
        {
          int v4 = 875704422;
          goto LABEL_16;
        }
        return 4;
      }
      return 2;
    }
    if (this == 32) {
      return 4;
    }
    int v5 = 825306677;
    goto LABEL_33;
  }
  if ((int)this > 1094862673)
  {
    if (this != 1094862674 && this != 1111970369)
    {
      if (this == 1278226488) {
        return 1;
      }
      goto LABEL_41;
    }
    return 4;
  }
  if (this == 875704438 || this == 875836518) {
    goto LABEL_17;
  }
  int v4 = 875836534;
LABEL_16:
  if (this == v4)
  {
LABEL_17:
    if (a2) {
      return 2;
    }
    else {
      return 1;
    }
  }
LABEL_41:
  double v8 = CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  if (PixelBufferUtils::planeCountForPixelFormat(this))
  {
    uint64_t v9 = [v8 objectForKeyedSubscript:*MEMORY[0x263F042C8]];
    uint64_t v10 = [v9 objectAtIndexedSubscript:a2];

    double v8 = (void *)v10;
  }
  unint64_t v11 = [v8 objectForKeyedSubscript:*MEMORY[0x263F04250]];
  uint64_t v12 = v11;
  if (v11)
  {
    [v11 floatValue];
    unint64_t v6 = vcvtps_u32_f32(v13 * 0.125);
  }
  else
  {

    PixelBufferUtils::pixelFormatAsString((unint64_t)this, (char *)__p);
    if (v16 >= 0) {
      unint64_t v14 = __p;
    }
    else {
      unint64_t v14 = (void **)__p[0];
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "pixelSizeForPixelFormat", 464, this, v14);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  return v6;
}

void sub_215FA70C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void PixelBufferUtils::asVImageBuffer(PixelBufferUtils *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, vImage_Buffer *a3@<X8>)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  BaseAddress = CVPixelBufferGetBaseAddress(this);
  size_t v11 = CVPixelBufferGetHeight(this);
  size_t v12 = CVPixelBufferGetWidth(this);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(this);
  if (!BaseAddress)
  {
    NSLog(&cfstr_SDErrorAsvimag.isa, "asVImageBuffer", 249);
    size_t BytesPerRow = 0;
    size_t v12 = 0;
    size_t v11 = 0;
  }
  v15[0] = BaseAddress;
  v15[1] = v11;
  v15[2] = v12;
  v15[3] = BytesPerRow;
  unint64_t PixelFormatType = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(this);
  v16.origin.CGFloat x = x;
  v16.origin.CGFloat y = y;
  v16.size.CGFloat width = width;
  v16.size.CGFloat height = height;
  cropVImageBuffer(a3, (uint64_t)v15, v16, PixelFormatType, 0);
}

void PixelBufferUtils::releasePixelBuffer(CVPixelBufferRef *this, __CVBuffer **a2)
{
  *this = 0;
}

CVPixelBufferRef PixelBufferUtils::createPixelBuffer(size_t width, size_t height, OSType pixelFormatType, int a4)
{
  CFDictionaryRef BufferAttributes = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  if (a4) {
    CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  }
  if (CVPixelBufferCreate(v8, width, height, pixelFormatType, BufferAttributes, &pixelBufferOut)) {
    return 0;
  }
  else {
    return pixelBufferOut;
  }
}

uint64_t getBufferAttributes(void)
{
  v3[2] = *MEMORY[0x263EF8340];
  {
    uint64_t v1 = *MEMORY[0x263F04078];
    v2[0] = *MEMORY[0x263F04130];
    v2[1] = v1;
    v3[0] = MEMORY[0x263EFFA78];
    v3[1] = &unk_26C6984D8;
    getBufferAttributes(void)::bufAttr = [NSDictionary dictionaryWithObjects:v3 forKeys:v2 count:2];
  }
  return getBufferAttributes(void)::bufAttr;
}

void sub_215FA7374(_Unwind_Exception *a1)
{
}

CVPixelBufferRef PixelBufferUtils::createPixelBufferWithSameSizeAndFormat(PixelBufferUtils *this, __CVBuffer *a2)
{
  int v2 = (int)a2;
  size_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  CFDictionaryRef BufferAttributes = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  if (v2) {
    CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  }
  if (CVPixelBufferCreate(v8, Width, Height, PixelFormatType, BufferAttributes, &pixelBufferOut)) {
    return 0;
  }
  else {
    return pixelBufferOut;
  }
}

CVPixelBufferRef PixelBufferUtils::createPixelBufferWithSameSize(PixelBufferUtils *this, __CVBuffer *a2, int a3)
{
  OSType v4 = a2;
  size_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  CFDictionaryRef BufferAttributes = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  if (a3) {
    CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  }
  if (CVPixelBufferCreate(v9, Width, Height, v4, BufferAttributes, &pixelBufferOut)) {
    return 0;
  }
  else {
    return pixelBufferOut;
  }
}

CVPixelBufferRef PixelBufferUtils::createPixelBuffer(OSType pixelFormatType, CGSize a2, int a3)
{
  double height = a2.height;
  double width = a2.width;
  CFDictionaryRef BufferAttributes = 0;
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  if (a3) {
    CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  }
  if (CVPixelBufferCreate(v7, (unint64_t)width, (unint64_t)height, pixelFormatType, BufferAttributes, &pixelBufferOut))
  {
    return 0;
  }
  else
  {
    return pixelBufferOut;
  }
}

BOOL PixelBufferUtils::isPixelFormatCompressed(PixelBufferUtils *this)
{
  int v2 = CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  unint64_t v3 = 0;
  uint64_t v4 = *MEMORY[0x263F042C8];
  uint64_t v5 = *MEMORY[0x263F04278];
  while (v3 < PixelBufferUtils::planeCountForPixelFormat(this))
  {
    unint64_t v6 = [v2 objectForKeyedSubscript:v4];
    CFAllocatorRef v7 = [v6 objectAtIndexedSubscript:v3];

    CFAllocatorRef v8 = [v7 objectForKeyedSubscript:v5];
    CFAllocatorRef v9 = v8;
    if (v8 && [v8 intValue])
    {

      BOOL v10 = 1;
      goto LABEL_10;
    }

    ++v3;
  }
  size_t v11 = [v2 objectForKeyedSubscript:v5];
  CFAllocatorRef v7 = v11;
  if (v11) {
    BOOL v10 = [v11 intValue] != 0;
  }
  else {
    BOOL v10 = 0;
  }
LABEL_10:

  return v10;
}

void sub_215FA7654(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

PixelBufferUtils *PixelBufferUtils::uncompressedEquivalentForPixelFormat(PixelBufferUtils *this)
{
  int v2 = CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  unint64_t v3 = [v2 objectForKeyedSubscript:*MEMORY[0x263F042B0]];
  uint64_t v4 = v3;
  if (v3)
  {
    this = (PixelBufferUtils *)[v3 unsignedIntValue];
  }
  else if (PixelBufferUtils::isPixelFormatCompressed(this))
  {
    PixelBufferUtils::pixelFormatAsString((unint64_t)this, (char *)__p);
    if (v8 >= 0) {
      uint64_t v5 = __p;
    }
    else {
      uint64_t v5 = (void **)__p[0];
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "uncompressedEquivalentForPixelFormat", 593, this, v5);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
    this = 0;
  }

  return this;
}

void sub_215FA776C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

__CVBuffer *PixelBufferUtils::createRotatedPixelBuffer(PixelBufferUtils *this, __CVBuffer *a2, int a3)
{
  if (!this) {
    return 0;
  }
  size_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  if ((a2 & 0xFFFFFFFD) == 1) {
    size_t v9 = Height;
  }
  else {
    size_t v9 = Width;
  }
  if ((a2 & 0xFFFFFFFD) != 1) {
    size_t Width = Height;
  }
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v10, v9, Width, PixelFormatType, BufferAttributes, &pixelBufferOut)) {
    size_t v12 = 0;
  }
  else {
    size_t v12 = pixelBufferOut;
  }
  if (PixelBufferUtils::rotatePixelBuffer(this, v12, a2, a3))
  {
    CVPixelBufferRelease(v12);
    return 0;
  }
  return v12;
}

uint64_t PixelBufferUtils::rotatePixelBuffer(CVPixelBufferRef pixelBuffer, __CVBuffer *a2, __CVBuffer *a3, int a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t result = 0xFFFFFFFFLL;
  if (pixelBuffer && a2)
  {
    uint8_t v8 = a3;
    unsigned int v9 = a3 & 0xFFFFFFFD;
    size_t Width = CVPixelBufferGetWidth(pixelBuffer);
    if (v9 == 1)
    {
      if (Width != CVPixelBufferGetHeight(a2)
        || (size_t Height = CVPixelBufferGetHeight(pixelBuffer), Height != CVPixelBufferGetWidth(a2)))
      {
LABEL_15:
        NSLog(&cfstr_SDErrorInvalid.isa, "rotatePixelBuffer", 879);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      if (Width != CVPixelBufferGetWidth(a2)) {
        goto LABEL_15;
      }
      size_t v12 = CVPixelBufferGetHeight(pixelBuffer);
      if (v12 != CVPixelBufferGetHeight(a2)) {
        goto LABEL_15;
      }
    }
    signed int PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
    if (a4)
    {
      if (PixelFormatType <= 1717856626)
      {
        if (PixelFormatType > 1380410944)
        {
          if (PixelFormatType == 1380410945) {
            goto LABEL_26;
          }
          int v14 = 1380411457;
        }
        else
        {
          if (PixelFormatType == 825306677) {
            goto LABEL_26;
          }
          int v14 = 825437747;
        }
      }
      else if (PixelFormatType <= 1919365989)
      {
        if (PixelFormatType == 1717856627) {
          goto LABEL_26;
        }
        int v14 = 1751411059;
      }
      else
      {
        if (PixelFormatType == 1919365990 || PixelFormatType == 1919365992) {
          goto LABEL_26;
        }
        int v14 = 1932996149;
      }
      if (PixelFormatType != v14)
      {
        src.data = 0;
        if (VTImageRotationSessionCreate())
        {
          MEMORY[0x2166C59F0](src.data);
          CFRelease(src.data);
          NSLog(&cfstr_SDErrorUnableT_2.isa, "createVTRotationSession", 802);
          int v21 = MEMORY[0x2166C5A00](0, pixelBuffer, a2);
        }
        else
        {
          int v21 = MEMORY[0x2166C5A00](src.data, pixelBuffer, a2);
        }
        if (!v21) {
          return 0;
        }
        NSLog(&cfstr_SDErrorVtimage.isa, "rotatePixelBufferVT", 842);
        return 0xFFFFFFFFLL;
      }
    }
LABEL_26:
    unint64_t v15 = CVPixelBufferGetPixelFormatType(pixelBuffer);
    CVPixelBufferLockBaseAddress(a2, 0);
    CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
    memset(&src, 0, sizeof(src));
    CGRect v16 = (CGRect *)MEMORY[0x263F001A8];
    PixelBufferUtils::asVImageBuffer(pixelBuffer, *MEMORY[0x263F001A8], &src);
    memset(&dest, 0, sizeof(dest));
    PixelBufferUtils::asVImageBuffer(a2, *v16, &dest);
    if (v9 == 1)
    {
      if (src.width != dest.height || src.height != dest.width)
      {
LABEL_40:
        CVPixelBufferUnlockBaseAddress(a2, 0);
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
        return 0xFFFFFFFFLL;
      }
    }
    else if (src.width != dest.width || src.height != dest.height)
    {
      goto LABEL_40;
    }
    *(void *)backColor = 0;
    uint64_t v27 = 0;
    if ((int)v15 > 1380410944)
    {
      if ((int)v15 > 1751410031)
      {
        if ((int)v15 <= 1919365989)
        {
          if (v15 == 1751410032) {
            goto LABEL_70;
          }
          int v20 = 1751411059;
        }
        else
        {
          if (v15 == 1919365990)
          {
            PixelBufferUtils::asVImageBuffer(pixelBuffer, 0, *v16, &__p);
            vImage_Buffer src = __p;
            PixelBufferUtils::asVImageBuffer(a2, 0, *v16, &__p);
            vImage_Buffer dest = __p;
            vImage_Error v17 = vImageRotate90_PlanarF(&src, &dest, v8, 0.0, 0);
            if (v17) {
              goto LABEL_72;
            }
            PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)1, *v16, &__p);
            vImage_Buffer src = __p;
            PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, *v16, &__p);
            vImage_Buffer dest = __p;
            vImage_Error v17 = vImageRotate90_PlanarF(&src, &dest, v8, 0.0, 0);
            if (v17) {
              goto LABEL_72;
            }
            PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)2, *v16, &__p);
            vImage_Buffer src = __p;
            PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)2, *v16, &__p);
            vImage_Buffer dest = __p;
            vImage_Error v18 = vImageRotate90_PlanarF(&src, &dest, v8, 0.0, 0);
            goto LABEL_71;
          }
          if (v15 == 1919365992)
          {
            PixelBufferUtils::asVImageBuffer(pixelBuffer, 0, *v16, &__p);
            vImage_Buffer src = __p;
            PixelBufferUtils::asVImageBuffer(a2, 0, *v16, &__p);
            vImage_Buffer dest = __p;
            vImage_Error v17 = vImageRotate90_Planar16F(&src, &dest, v8, 0, 0);
            if (v17) {
              goto LABEL_72;
            }
            PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)1, *v16, &__p);
            vImage_Buffer src = __p;
            PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, *v16, &__p);
            vImage_Buffer dest = __p;
            vImage_Error v17 = vImageRotate90_Planar16F(&src, &dest, v8, 0, 0);
            if (v17) {
              goto LABEL_72;
            }
            PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)2, *v16, &__p);
            vImage_Buffer src = __p;
            PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)2, *v16, &__p);
            vImage_Buffer dest = __p;
            vImage_Error v18 = vImageRotate90_Planar16F(&src, &dest, v8, 0, 0);
            goto LABEL_71;
          }
          int v20 = 1932996149;
        }
        goto LABEL_69;
      }
      if ((int)v15 <= 1647392358)
      {
        if (v15 == 1380410945)
        {
          vImage_Error v18 = vImageRotate90_ARGBFFFF(&src, &dest, v8, (const float *)backColor, 0);
          goto LABEL_71;
        }
        if (v15 == 1380411457)
        {
          vImage_Error v18 = vImageRotate90_ARGB16U(&src, &dest, v8, backColor, 0);
          goto LABEL_71;
        }
        goto LABEL_84;
      }
      if (v15 == 1647392359)
      {
LABEL_70:
        vImage_Error v18 = vImageRotate90_Planar16U(&src, &dest, v8, 0, 0);
        goto LABEL_71;
      }
      if (v15 != 1717855600 && v15 != 1717856627) {
        goto LABEL_84;
      }
    }
    else
    {
      if ((int)v15 <= 1094862673)
      {
        if ((int)v15 > 825437746)
        {
          if (v15 != 825437747)
          {
            if (v15 == 875704422 || v15 == 875704438)
            {
              PixelBufferUtils::asVImageBuffer(pixelBuffer, 0, *v16, &src);
              PixelBufferUtils::asVImageBuffer(a2, 0, *v16, &dest);
              vImage_Error v17 = vImageRotate90_Planar8(&src, &dest, v8, 0, 0);
              if (v17)
              {
LABEL_72:
                CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
                CVPixelBufferUnlockBaseAddress(a2, 0);
                return v17 != 0;
              }
              PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)1, *v16, &__p);
              vImage_Buffer src = __p;
              PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, *v16, &__p);
              vImage_Buffer dest = __p;
              vImage_Error v18 = vImageRotate90_Planar16U(&src, &dest, v8, 0, 0);
LABEL_71:
              vImage_Error v17 = v18;
              goto LABEL_72;
            }
LABEL_84:
            PixelBufferUtils::pixelFormatAsString(v15, (char *)&__p);
            if ((__p.width & 0x8000000000000000) == 0) {
              p_p = &__p;
            }
            else {
              p_p = (vImage_Buffer *)__p.data;
            }
            NSLog(&cfstr_SDErrorPixelFo.isa, "rotatePixelBufferVImage", 765, v15, p_p);
            if (SHIBYTE(__p.width) < 0) {
              operator delete(__p.data);
            }
            vImage_Error v17 = -21773;
            goto LABEL_72;
          }
          goto LABEL_70;
        }
        if (v15 != 32)
        {
          int v20 = 825306677;
LABEL_69:
          if (v15 != v20) {
            goto LABEL_84;
          }
          goto LABEL_70;
        }
LABEL_66:
        vImage_Error v18 = vImageRotate90_ARGB8888(&src, &dest, v8, (const uint8_t *)backColor, 0);
        goto LABEL_71;
      }
      if ((int)v15 <= 1278226533)
      {
        if (v15 == 1094862674) {
          goto LABEL_66;
        }
        int v19 = 1111970369;
        goto LABEL_65;
      }
      if (v15 != 1278226534)
      {
        if (v15 == 1278226536) {
          goto LABEL_70;
        }
        int v19 = 1380401729;
LABEL_65:
        if (v15 != v19) {
          goto LABEL_84;
        }
        goto LABEL_66;
      }
    }
    vImage_Error v18 = vImageRotate90_PlanarF(&src, &dest, v8, 0.0, 0);
    goto LABEL_71;
  }
  return result;
}

void sub_215FA8190(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

__CVBuffer *PixelBufferUtils::createCroppedAndScaledPixelBuffer(PixelBufferUtils *this, __CVBuffer *a2, CGRect a3, CGSize a4)
{
  double height = a4.height;
  double width = a4.width;
  double v7 = a3.size.height;
  double v8 = a3.size.width;
  CGFloat y = a3.origin.y;
  CGFloat x = a3.origin.x;
  if (CGRectIsEmpty(a3))
  {
    double v8 = (double)CVPixelBufferGetWidth(this);
    double v7 = (double)CVPixelBufferGetHeight(this);
    CGFloat x = 0.0;
    CGFloat y = 0.0;
  }
  if (width == *MEMORY[0x263F001B0] && height == *(double *)(MEMORY[0x263F001B0] + 8))
  {
    double width = v8;
    double height = v7;
  }
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v13, (unint64_t)width, (unint64_t)height, PixelFormatType, BufferAttributes, &pixelBufferOut))
  {
    unint64_t v15 = 0;
  }
  else
  {
    unint64_t v15 = pixelBufferOut;
  }
  v18.origin.CGFloat x = x;
  v18.origin.CGFloat y = y;
  v18.size.double width = v8;
  v18.size.double height = v7;
  if (PixelBufferUtils::cropAndScalePixelBuffer(this, v15, a2, v18, *MEMORY[0x263F001A8]))
  {
    CVPixelBufferRelease(v15);
    return 0;
  }
  return v15;
}

uint64_t PixelBufferUtils::cropAndScalePixelBuffer(CVPixelBufferRef pixelBuffer, __CVBuffer *a2, __CVBuffer *a3, CGRect a4, CGRect a5)
{
  double height = a5.size.height;
  double width = a5.size.width;
  double y = a5.origin.y;
  double x = a5.origin.x;
  double v8 = a4.size.height;
  double v9 = a4.size.width;
  double v10 = a4.origin.y;
  double v11 = a4.origin.x;
  if (!a3) {
    goto LABEL_17;
  }
  signed int PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  if (PixelFormatType <= 1751410031)
  {
    if (PixelFormatType > 1717855599)
    {
      if (PixelFormatType == 1717855600 || PixelFormatType == 1717856627) {
        goto LABEL_17;
      }
    }
    else if (PixelFormatType == 825306677 || PixelFormatType == 825437747)
    {
      goto LABEL_17;
    }
  }
  else
  {
    if (PixelFormatType > 1919365989)
    {
      if (PixelFormatType != 1919365990 && PixelFormatType != 1919365992 && PixelFormatType != 1932996149) {
        goto LABEL_47;
      }
LABEL_17:
      size_t v15 = CVPixelBufferGetWidth(pixelBuffer);
      size_t v16 = CVPixelBufferGetHeight(pixelBuffer);
      size_t v17 = CVPixelBufferGetWidth(a2);
      size_t v18 = CVPixelBufferGetHeight(a2);
      v83.origin.double x = v11;
      v83.origin.double y = v10;
      v83.size.double width = v9;
      v83.size.double height = v8;
      IsEmptdouble y = CGRectIsEmpty(v83);
      double v20 = (double)v16;
      if (IsEmpty)
      {
        double v11 = 0.0;
        double v10 = 0.0;
        double v9 = (double)v15;
      }
      else
      {
        double v20 = v8;
      }
      CGFloat v75 = v20;
      v84.origin.double x = x;
      v84.origin.double y = y;
      v84.size.double width = width;
      v84.size.double height = height;
      BOOL v21 = CGRectIsEmpty(v84);
      if (v21) {
        double v22 = 0.0;
      }
      else {
        double v22 = x;
      }
      if (v21) {
        double v23 = 0.0;
      }
      else {
        double v23 = y;
      }
      double v72 = v23;
      if (v21) {
        double v24 = (double)v17;
      }
      else {
        double v24 = width;
      }
      double v73 = v24;
      double v74 = v22;
      if (v21) {
        double v25 = (double)v18;
      }
      else {
        double v25 = height;
      }
      v85.origin.double x = v11;
      v85.origin.double y = v10;
      v85.size.double width = v9;
      v85.size.double height = v75;
      CGRect v86 = CGRectIntegral(v85);
      CGFloat v26 = v86.origin.x;
      CGFloat v27 = v86.origin.y;
      CGFloat v28 = v86.size.width;
      CGFloat v29 = v86.size.height;
      if (v86.origin.x < 0.0
        || v86.origin.y < 0.0
        || (v86.origin.x + v86.size.width <= (double)v15
          ? (BOOL v30 = v86.origin.y + v86.size.height <= (double)v16)
          : (BOOL v30 = 0),
            !v30))
      {
        NSLog(&cfstr_SDErrorCropOri_0.isa, "cropAndScalePixelBufferVImage", 945, *(void *)&v86.origin.x, *(void *)&v86.origin.y, *(void *)&v86.size.width, *(void *)&v86.size.height);
        return 0xFFFFFFFFLL;
      }
      if (v74 < 0.0 || v72 < 0.0 || (v74 + v73 <= (double)v17 ? (BOOL v32 = v72 + v25 <= (double)v18) : (BOOL v32 = 0), !v32))
      {
        NSLog(&cfstr_SDErrorDestrec.isa, "cropAndScalePixelBufferVImage", 951, *(void *)&v74, *(void *)&v72, *(void *)&v73, *(void *)&v25);
        return 0xFFFFFFFFLL;
      }
      CVPixelBufferLockBaseAddress(a2, 0);
      CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
      memset(&v82, 0, sizeof(v82));
      v88.origin.double x = v26;
      v88.origin.double y = v27;
      v88.size.double width = v28;
      v88.size.double height = v29;
      PixelBufferUtils::asVImageBuffer(pixelBuffer, v88, &v82);
      memset(&v81, 0, sizeof(v81));
      v89.origin.double x = v74;
      v89.origin.double y = v72;
      v89.size.double width = v73;
      v89.size.double height = v25;
      PixelBufferUtils::asVImageBuffer(a2, v89, &v81);
      unint64_t v35 = CVPixelBufferGetPixelFormatType(pixelBuffer);
      unint64_t v36 = v35;
      if ((int)v35 > 1380401728)
      {
        if ((int)v35 <= 1717856626)
        {
          if ((int)v35 <= 1380411456)
          {
            if (v35 != 1380401729)
            {
              if (v35 == 1380410945)
              {
                vImage_Error v39 = vImageScale_ARGBFFFF(&v82, &v81, 0, 0);
                goto LABEL_110;
              }
              goto LABEL_119;
            }
            goto LABEL_109;
          }
          if (v35 == 1380411457)
          {
            vImage_Error v39 = vImageScale_ARGB16F(&v82, &v81, 0, 0);
            goto LABEL_110;
          }
          if (v35 != 1647392359)
          {
            if (v35 != 1717855600) {
              goto LABEL_119;
            }
            goto LABEL_89;
          }
LABEL_99:
          vImagePixelCount v61 = v81.height;
          if (v81.height)
          {
            vImagePixelCount v62 = v81.width;
            if (v81.width)
            {
              unint64_t v63 = 0;
              data = (char *)v82.data;
              size_t rowBytes = v82.rowBytes;
              float v66 = (float)v82.height / (float)v81.height;
              float64x2_t v67 = (char *)v81.data;
              size_t v68 = v81.rowBytes;
              float v69 = (float)v82.width / (float)v81.width;
              do
              {
                unint64_t v70 = 0;
                do
                {
                  *(_WORD *)&v67[2 * v70] = *(_WORD *)&data[2 * (int)(float)(v69 * (float)v70)
                                                          + rowBytes * (int)(float)(v66 * (float)v63)];
                  ++v70;
                }
                while (v62 != v70);
                ++v63;
                v67 += v68;
              }
              while (v63 != v61);
            }
          }
          goto LABEL_105;
        }
        if ((int)v35 <= 1919365989)
        {
          if (v35 != 1717856627)
          {
            if (v35 == 1751410032)
            {
LABEL_79:
              vImagePixelCount v40 = v81.height;
              if (v81.height)
              {
                vImagePixelCount v41 = v81.width;
                if (v81.width)
                {
                  unint64_t v42 = 0;
                  double v43 = (char *)v82.data;
                  size_t v44 = v82.rowBytes;
                  float v45 = (float)v82.height / (float)v81.height;
                  float64x2_t v46 = (char *)v81.data;
                  size_t v47 = v81.rowBytes;
                  float v48 = (float)v82.width / (float)v81.width;
                  do
                  {
                    unint64_t v49 = 0;
                    do
                    {
                      *(_WORD *)&v46[2 * v49] = *(_WORD *)&v43[2 * (int)(float)(v48 * (float)v49)
                                                             + v44 * (int)(float)(v45 * (float)v42)];
                      ++v49;
                    }
                    while (v41 != v49);
                    ++v42;
                    v46 += v47;
                  }
                  while (v42 != v40);
                }
              }
LABEL_105:
              vImage_Error v38 = 0;
              goto LABEL_111;
            }
            int v37 = 1751411059;
            goto LABEL_78;
          }
LABEL_89:
          vImagePixelCount v51 = v81.height;
          if (v81.height)
          {
            vImagePixelCount v52 = v81.width;
            if (v81.width)
            {
              unint64_t v53 = 0;
              float64x2_t v54 = (char *)v82.data;
              size_t v55 = v82.rowBytes;
              float v56 = (float)v82.height / (float)v81.height;
              float64x2_t v57 = (char *)v81.data;
              size_t v58 = v81.rowBytes;
              float v59 = (float)v82.width / (float)v81.width;
              do
              {
                unint64_t v60 = 0;
                do
                {
                  *(_DWORD *)&v57[4 * v60] = *(_DWORD *)&v54[4 * (int)(float)(v59 * (float)v60)
                                                           + v55 * (int)(float)(v56 * (float)v53)];
                  ++v60;
                }
                while (v52 != v60);
                ++v53;
                v57 += v58;
              }
              while (v53 != v51);
            }
          }
          goto LABEL_105;
        }
        if (v35 == 1919365990)
        {
          v94.origin.double x = v26;
          v94.origin.double y = v27;
          v94.size.double width = v28;
          v94.size.double height = v29;
          PixelBufferUtils::asVImageBuffer(pixelBuffer, 0, v94, &src);
          vImage_Buffer v82 = src;
          v95.origin.double x = v74;
          v95.origin.double y = v72;
          v95.size.double width = v73;
          v95.size.double height = v25;
          PixelBufferUtils::asVImageBuffer(a2, 0, v95, &src);
          vImage_Buffer v81 = src;
          vImage_Error v38 = vImageScale_PlanarF(&v82, &v81, 0, 0);
          if (v38) {
            goto LABEL_111;
          }
          v96.origin.double x = v26;
          v96.origin.double y = v27;
          v96.size.double width = v28;
          v96.size.double height = v29;
          PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)1, v96, &src);
          vImage_Buffer v82 = src;
          v97.origin.double x = v74;
          v97.origin.double y = v72;
          v97.size.double width = v73;
          v97.size.double height = v25;
          PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, v97, &src);
          vImage_Buffer v81 = src;
          vImage_Error v38 = vImageScale_PlanarF(&v82, &v81, 0, 0);
          if (v38) {
            goto LABEL_111;
          }
          v98.origin.double x = v26;
          v98.origin.double y = v27;
          v98.size.double width = v28;
          v98.size.double height = v29;
          PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)2, v98, &src);
          vImage_Buffer v82 = src;
          v99.origin.double x = v74;
          v99.origin.double y = v72;
          v99.size.double width = v73;
          v99.size.double height = v25;
          PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)2, v99, &src);
          vImage_Buffer v81 = src;
          vImage_Error v39 = vImageScale_PlanarF(&v82, &v81, 0, 0);
          goto LABEL_110;
        }
        if (v35 == 1919365992)
        {
          v100.origin.double x = v26;
          v100.origin.double y = v27;
          v100.size.double width = v28;
          v100.size.double height = v29;
          PixelBufferUtils::asVImageBuffer(pixelBuffer, 0, v100, &src);
          vImage_Buffer v82 = src;
          v101.origin.double x = v74;
          v101.origin.double y = v72;
          v101.size.double width = v73;
          v101.size.double height = v25;
          PixelBufferUtils::asVImageBuffer(a2, 0, v101, &src);
          vImage_Buffer v81 = src;
          vImage_Error v38 = vImageScale_Planar16F(&v82, &v81, 0, 0);
          if (v38) {
            goto LABEL_111;
          }
          v102.origin.double x = v26;
          v102.origin.double y = v27;
          v102.size.double width = v28;
          v102.size.double height = v29;
          PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)1, v102, &src);
          vImage_Buffer v82 = src;
          v103.origin.double x = v74;
          v103.origin.double y = v72;
          v103.size.double width = v73;
          v103.size.double height = v25;
          PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, v103, &src);
          vImage_Buffer v81 = src;
          vImage_Error v38 = vImageScale_Planar16F(&v82, &v81, 0, 0);
          if (v38) {
            goto LABEL_111;
          }
          v104.origin.double x = v26;
          v104.origin.double y = v27;
          v104.size.double width = v28;
          v104.size.double height = v29;
          PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)2, v104, &src);
          vImage_Buffer v82 = src;
          v105.origin.double x = v74;
          v105.origin.double y = v72;
          v105.size.double width = v73;
          v105.size.double height = v25;
          PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)2, v105, &src);
          vImage_Buffer v81 = src;
          vImage_Error v39 = vImageScale_Planar16F(&v82, &v81, 0, 0);
          goto LABEL_110;
        }
        int v50 = 1932996149;
      }
      else
      {
        if ((int)v35 > 875836517)
        {
          if ((int)v35 <= 1111970368)
          {
            if (v35 != 875836518 && v35 != 875836534)
            {
              if (v35 != 1094862674) {
                goto LABEL_119;
              }
              goto LABEL_109;
            }
LABEL_68:
            memset(&src, 0, sizeof(src));
            v90.origin.double x = v26;
            v90.origin.double y = v27;
            v90.size.double width = v28;
            v90.size.double height = v29;
            PixelBufferUtils::asVImageBuffer(pixelBuffer, 0, v90, &src);
            memset(&dest, 0, sizeof(dest));
            v91.origin.double x = v74;
            v91.origin.double y = v72;
            v91.size.double width = v73;
            v91.size.double height = v25;
            PixelBufferUtils::asVImageBuffer(a2, 0, v91, &dest);
            vImage_Error v38 = vImageScale_Planar8(&src, &dest, 0, 0);
            if (!v38)
            {
              memset(&v78, 0, sizeof(v78));
              v92.origin.double x = v26;
              v92.origin.double y = v27;
              v92.size.double width = v28;
              v92.size.double height = v29;
              PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)1, v92, &v78);
              memset(&v77, 0, sizeof(v77));
              v93.origin.double x = v74;
              v93.origin.double y = v72;
              v93.size.double width = v73;
              v93.size.double height = v25;
              PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, v93, &v77);
              vImage_Error v39 = vImageScale_CbCr8(&v78, &v77, 0, 0);
LABEL_110:
              vImage_Error v38 = v39;
            }
LABEL_111:
            CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
            CVPixelBufferUnlockBaseAddress(a2, 0);
            return v38 != 0;
          }
          if (v35 != 1111970369)
          {
            if (v35 != 1278226534)
            {
              int v37 = 1278226536;
LABEL_78:
              if (v35 == v37) {
                goto LABEL_79;
              }
LABEL_119:
              PixelBufferUtils::pixelFormatAsString(v35, (char *)&src);
              if ((src.width & 0x8000000000000000) == 0) {
                p_vImage_Buffer src = &src;
              }
              else {
                p_vImage_Buffer src = src.data;
              }
              NSLog(&cfstr_SDErrorPixelFo.isa, "cropAndScalePixelBufferVImage", 1044, v36, p_src);
              if (SHIBYTE(src.width) < 0) {
                operator delete(src.data);
              }
              vImage_Error v38 = -21778;
              goto LABEL_111;
            }
            goto LABEL_89;
          }
LABEL_109:
          vImage_Error v39 = vImageScale_ARGB8888(&v82, &v81, 0, 0);
          goto LABEL_110;
        }
        if ((int)v35 > 825437746)
        {
          if (v35 != 825437747)
          {
            if (v35 == 875704422 || v35 == 875704438) {
              goto LABEL_68;
            }
            goto LABEL_119;
          }
          goto LABEL_99;
        }
        if (v35 == 32) {
          goto LABEL_109;
        }
        int v50 = 825306677;
      }
      if (v35 != v50) {
        goto LABEL_119;
      }
      goto LABEL_99;
    }
    if (PixelFormatType == 1751410032 || PixelFormatType == 1751411059) {
      goto LABEL_17;
    }
  }
LABEL_47:
  v87.origin.double x = v11;
  v87.origin.double y = v10;
  v87.size.double width = v9;
  v87.size.double height = v8;
  v106.origin.double x = x;
  v106.origin.double y = y;
  v106.size.double width = width;
  v106.size.double height = height;
  VTTransferSession = createVTTransferSession(v87, v106);
  OSStatus v34 = VTPixelTransferSessionTransferImage(VTTransferSession, pixelBuffer, a2);
  if (VTTransferSession)
  {
    VTPixelTransferSessionInvalidate(VTTransferSession);
    CFRelease(VTTransferSession);
  }
  if (v34)
  {
    NSLog(&cfstr_SDErrorVtpixel.isa, "cropAndScalePixelBufferVT", 1109);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

void sub_215FA8E3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

VTPixelTransferSessionRef createVTTransferSession(CGRect a1, CGRect a2)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  CGFloat v6 = a1.size.height;
  CGFloat v7 = a1.size.width;
  CGFloat v8 = a1.origin.y;
  CGFloat v9 = a1.origin.x;
  VTPixelTransferSessionRef pixelTransferSessionOut = 0;
  OSStatus v10 = VTPixelTransferSessionCreate(0, &pixelTransferSessionOut);
  v15.origin.CGFloat x = v9;
  v15.origin.CGFloat y = v8;
  v15.size.CGFloat width = v7;
  v15.size.CGFloat height = v6;
  if (!CGRectIsEmpty(v15))
  {
    v16.origin.CGFloat x = v9;
    v16.origin.CGFloat y = v8;
    v16.size.CGFloat width = v7;
    v16.size.CGFloat height = v6;
    CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v16);
    v10 |= VTSessionSetProperty(pixelTransferSessionOut, (CFStringRef)*MEMORY[0x263F1EA10], DictionaryRepresentation);
    CFRelease(DictionaryRepresentation);
  }
  v17.origin.CGFloat x = x;
  v17.origin.CGFloat y = y;
  v17.size.CGFloat width = width;
  v17.size.CGFloat height = height;
  if (!CGRectIsEmpty(v17))
  {
    v18.origin.CGFloat x = x;
    v18.origin.CGFloat y = y;
    v18.size.CGFloat width = width;
    v18.size.CGFloat height = height;
    CFDictionaryRef v12 = CGRectCreateDictionaryRepresentation(v18);
    v10 |= VTSessionSetProperty(pixelTransferSessionOut, (CFStringRef)*MEMORY[0x263F1E9D8], v12);
    CFRelease(v12);
  }
  VTPixelTransferSessionRef result = pixelTransferSessionOut;
  if (v10)
  {
    VTPixelTransferSessionInvalidate(pixelTransferSessionOut);
    CFRelease(pixelTransferSessionOut);
    NSLog(&cfstr_SDErrorUnableT_1.isa, "createVTTransferSession", 1080);
    return 0;
  }
  return result;
}

uint64_t PixelBufferUtils::cropAndScalePixelBuffer(PixelBufferUtils *this, __CVBuffer *a2, __CVBuffer *a3, CGRect a4)
{
  return PixelBufferUtils::cropAndScalePixelBuffer(this, a2, a3, a4, *MEMORY[0x263F001A8]);
}

__CVBuffer *PixelBufferUtils::createConvertedPixelBufferFormat(PixelBufferUtils *this, __CVBuffer *a2, __CVBuffer *a3)
{
  OSType v4 = a2;
  size_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v8, Width, Height, v4, BufferAttributes, &pixelBufferOut)) {
    OSStatus v10 = 0;
  }
  else {
    OSStatus v10 = pixelBufferOut;
  }
  if (PixelBufferUtils::convertPixelBufferFormat(this, v10, a3))
  {
    CVPixelBufferRelease(v10);
    return 0;
  }
  return v10;
}

uint64_t PixelBufferUtils::convertPixelBufferFormat(PixelBufferUtils *this, __CVBuffer *a2, __CVBuffer *a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (!this || !a2) {
    return v3;
  }
  int v5 = (int)a3;
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  unint64_t v8 = CVPixelBufferGetPixelFormatType(a2);
  OSStatus v10 = (PixelBufferUtils *)v8;
  if (v5)
  {
    if ((int)PixelFormatType <= 1751410031)
    {
      if ((int)PixelFormatType > 1717855599)
      {
        if (PixelFormatType == 1717855600) {
          goto LABEL_17;
        }
        int v11 = 1717856627;
      }
      else
      {
        if (PixelFormatType == 825306677) {
          goto LABEL_17;
        }
        int v11 = 825437747;
      }
    }
    else if ((int)PixelFormatType <= 1919365989)
    {
      if (PixelFormatType == 1751410032) {
        goto LABEL_17;
      }
      int v11 = 1751411059;
    }
    else
    {
      if (PixelFormatType == 1919365990 || PixelFormatType == 1919365992) {
        goto LABEL_17;
      }
      int v11 = 1932996149;
    }
    if (PixelFormatType == v11) {
      goto LABEL_17;
    }
    if ((int)v8 <= 1751410031)
    {
      if ((int)v8 > 1717855599)
      {
        if (v8 == 1717855600) {
          goto LABEL_17;
        }
        int v30 = 1717856627;
      }
      else
      {
        if (v8 == 825306677) {
          goto LABEL_17;
        }
        int v30 = 825437747;
      }
    }
    else if ((int)v8 <= 1919365989)
    {
      if (v8 == 1751410032) {
        goto LABEL_17;
      }
      int v30 = 1751411059;
    }
    else
    {
      if (v8 == 1919365990 || v8 == 1919365992) {
        goto LABEL_17;
      }
      int v30 = 1932996149;
    }
    if (v8 != v30)
    {
      CGRect v96 = *(CGRect *)*(void *)&MEMORY[0x263F001A8];
      v97.origin.CGFloat x = *(CGFloat *)MEMORY[0x263F001A8];
      v97.origin.CGFloat y = v96.origin.y;
      v97.size.vImagePixelCount width = v96.size.width;
      v97.size.vImagePixelCount height = v96.size.height;
      VTTransferSession = createVTTransferSession(*MEMORY[0x263F001A8], v97);
      OSStatus v55 = VTPixelTransferSessionTransferImage(VTTransferSession, this, a2);
      if (VTTransferSession)
      {
        VTPixelTransferSessionInvalidate(VTTransferSession);
        CFRelease(VTTransferSession);
      }
      if (!v55) {
        return 0;
      }
      NSLog(&cfstr_SDErrorVtpixel.isa, "cropAndScalePixelBufferVT", 1109);
      return 0xFFFFFFFFLL;
    }
  }
LABEL_17:
  if (PixelFormatType == v8)
  {
    OSType v12 = CVPixelBufferGetPixelFormatType(this);
    if (v12 == CVPixelBufferGetPixelFormatType(a2))
    {
      uint64_t v13 = *MEMORY[0x263F00148];
      uint64_t v14 = *(void *)(MEMORY[0x263F00148] + 8);
      uint64_t v15 = *MEMORY[0x263F001A8];
      uint64_t v16 = *(void *)(MEMORY[0x263F001A8] + 8);
      uint64_t v17 = *(void *)(MEMORY[0x263F001A8] + 16);
      uint64_t v18 = *(void *)(MEMORY[0x263F001A8] + 24);
      return copyPixelBufferVImage(a2, *(CGPoint *)&v13, this, *(CGRect *)&v15);
    }
    return 0xFFFFFFFFLL;
  }
  BOOL v20 = 0;
  if ((int)PixelFormatType <= 1751410031)
  {
    if (PixelFormatType != 1717855600)
    {
      if (PixelFormatType != 1717856627) {
        goto LABEL_36;
      }
      goto LABEL_28;
    }
LABEL_30:
    BOOL v20 = v8 == 1751411059 || v8 == 1717856627;
    goto LABEL_36;
  }
  if (PixelFormatType == 1751410032) {
    goto LABEL_30;
  }
  if (PixelFormatType != 1751411059) {
    goto LABEL_36;
  }
LABEL_28:
  BOOL v20 = 1;
  if (v8 != 1717855600) {
    BOOL v20 = v8 == 1751410032;
  }
LABEL_36:
  if ((int)PixelFormatType > 1380401728)
  {
    if ((int)PixelFormatType <= 1717856626)
    {
      if ((int)PixelFormatType > 1380411456)
      {
        if (PixelFormatType != 1380411457)
        {
          if (PixelFormatType != 1647392359)
          {
            if (PixelFormatType != 1717855600) {
              goto LABEL_156;
            }
            goto LABEL_85;
          }
LABEL_58:
          unint64_t v23 = CVPixelBufferGetPixelFormatType(a2);
          CVPixelBufferLockBaseAddress(this, 1uLL);
          CVPixelBufferLockBaseAddress(a2, 0);
          memset(&src, 0, sizeof(src));
          double v24 = (CGRect *)MEMORY[0x263F001A8];
          PixelBufferUtils::asVImageBuffer(this, *MEMORY[0x263F001A8], &src);
          memset(&dest, 0, sizeof(dest));
          PixelBufferUtils::asVImageBuffer(a2, *v24, &dest);
          if (v23 == 1278226536 || v23 == 1751410032)
          {
            vImagePixelCount width = src.width;
            if (src.width == dest.width)
            {
              vImagePixelCount height = src.height;
              if (src.height == dest.height)
              {
                data = (unsigned __int16 *)src.data;
                if (src.data)
                {
                  vImage_Error v39 = (char *)dest.data;
                  if (dest.data)
                  {
                    if (src.height && src.width)
                    {
                      size_t rowBytes = src.rowBytes;
                      size_t v41 = dest.rowBytes;
                      if (src.width > 0xF)
                      {
                        vImagePixelCount v65 = src.width & 0xFFFFFFFFFFFFFFF0;
                        vImagePixelCount v66 = src.width - (src.width & 0xFFFFFFFFFFFFFFF0);
                        if (src.width == (src.width & 0xFFFFFFFFFFFFFFF0))
                        {
                          uint64_t v67 = 0;
                          size_t v68 = (float16x8_t *)((char *)dest.data + 16);
                          float v69 = (uint16x4_t *)((char *)src.data + 16);
                          float32x4_t v70 = (float32x4_t)vdupq_n_s32(0x3903126Fu);
                          do
                          {
                            float64x2_t v71 = v69;
                            double v72 = v68;
                            vImagePixelCount v73 = width;
                            do
                            {
                              float16x8_t v74 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32((float32x4_t)0, v70, vcvtq_f32_u32(vmovl_u16(*v71)))), vmlaq_f32((float32x4_t)0, v70, vcvtq_f32_u32(vmovl_high_u16(*(uint16x8_t *)v71->i8))));
                              v72[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32((float32x4_t)0, v70, vcvtq_f32_u32(vmovl_u16(v71[-2])))), vmlaq_f32((float32x4_t)0, v70, vcvtq_f32_u32(vmovl_high_u16(*(uint16x8_t *)v71[-2].i8))));
                              *double v72 = v74;
                              v72 += 2;
                              v71 += 4;
                              v73 -= 16;
                            }
                            while (v73);
                            uint64_t v3 = 0;
                            ++v67;
                            size_t v68 = (float16x8_t *)((char *)v68 + v41);
                            float v69 = (uint16x4_t *)((char *)v69 + rowBytes);
                          }
                          while (v67 != height);
                        }
                        else
                        {
                          uint64_t v75 = 0;
                          float64x2_t v76 = (float16x8_t *)((char *)dest.data + 16);
                          vImage_Buffer v77 = (uint16x4_t *)((char *)src.data + 16);
                          vImagePixelCount v78 = (2 * src.width) & 0xFFFFFFFFFFFFFFE0;
                          float64x2_t v79 = (char *)dest.data + v78;
                          float64x2_t v80 = (char *)src.data + v78;
                          float32x4_t v81 = (float32x4_t)vdupq_n_s32(0x3903126Fu);
                          do
                          {
                            vImage_Buffer v82 = v77;
                            CGRect v83 = v76;
                            vImagePixelCount v84 = v65;
                            do
                            {
                              float16x8_t v85 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32((float32x4_t)0, v81, vcvtq_f32_u32(vmovl_u16(*v82)))), vmlaq_f32((float32x4_t)0, v81, vcvtq_f32_u32(vmovl_high_u16(*(uint16x8_t *)v82->i8))));
                              v83[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32((float32x4_t)0, v81, vcvtq_f32_u32(vmovl_u16(v82[-2])))), vmlaq_f32((float32x4_t)0, v81, vcvtq_f32_u32(vmovl_high_u16(*(uint16x8_t *)v82[-2].i8))));
                              float16x8_t *v83 = v85;
                              v83 += 2;
                              v82 += 4;
                              v84 -= 16;
                            }
                            while (v84);
                            CGRect v86 = (unsigned __int16 *)v80;
                            CGRect v87 = v79;
                            vImagePixelCount v88 = v66;
                            do
                            {
                              unsigned int v89 = *v86++;
                              _S2 = (float)((float)v89 * 0.000125) + 0.0;
                              __asm { FCVT            H2, S2 }
                              *v87++ = LOWORD(_S2);
                              --v88;
                            }
                            while (v88);
                            uint64_t v3 = 0;
                            ++v75;
                            float64x2_t v76 = (float16x8_t *)((char *)v76 + v41);
                            vImage_Buffer v77 = (uint16x4_t *)((char *)v77 + rowBytes);
                            v79 += v41;
                            v80 += rowBytes;
                          }
                          while (v75 != height);
                        }
                      }
                      else
                      {
                        uint64_t v42 = 0;
                        do
                        {
                          double v43 = data;
                          size_t v44 = v39;
                          vImagePixelCount v45 = width;
                          do
                          {
                            unsigned int v46 = *v43++;
                            _S1 = (float)((float)v46 * 0.000125) + 0.0;
                            __asm { FCVT            H1, S1 }
                            *v44++ = LOWORD(_S1);
                            --v45;
                          }
                          while (v45);
                          uint64_t v3 = 0;
                          ++v42;
                          v39 += v41;
                          data = (unsigned __int16 *)((char *)data + rowBytes);
                        }
                        while (v42 != height);
                      }
                    }
                    else
                    {
                      uint64_t v3 = 0;
                    }
                    goto LABEL_184;
                  }
                }
              }
            }
          }
          else
          {
            if (v23 == 1717855600)
            {
              if (vImageConvert_16UToF(&src, &dest, 0.0, 0.000125, 0)) {
                uint64_t v3 = 0xFFFFFFFFLL;
              }
              else {
                uint64_t v3 = 0;
              }
              goto LABEL_184;
            }
            PixelBufferUtils::pixelFormatAsString(v23, (char *)__p);
            if (v92 >= 0) {
              unint64_t v53 = __p;
            }
            else {
              unint64_t v53 = (void **)__p[0];
            }
            NSLog(&cfstr_SDErrorPixelFo.isa, "convertfp13_3ToDepthMeters", 1701, v23, v53);
            if (v92 < 0) {
              operator delete(__p[0]);
            }
          }
          uint64_t v3 = 0xFFFFFFFFLL;
LABEL_184:
          CVPixelBufferUnlockBaseAddress(this, 1uLL);
          CVPixelBufferUnlockBaseAddress(a2, 0);
          return v3;
        }
        goto LABEL_69;
      }
      if (PixelFormatType != 1380401729)
      {
        int v25 = 1380410945;
        goto LABEL_68;
      }
      goto LABEL_69;
    }
    if ((int)PixelFormatType > 1751411058)
    {
      if (PixelFormatType != 1751411059)
      {
        if (PixelFormatType == 1919365990)
        {
          return convertRGBPlanarFloat(this, a2);
        }
        if (PixelFormatType == 1919365992)
        {
          return convertRGBPlanarHalf(this, a2);
        }
        goto LABEL_156;
      }
LABEL_81:
      if ((int)v8 <= 1717856626)
      {
        if (v8 == 1278226534) {
          goto LABEL_105;
        }
        unsigned __int16 v28 = 25968;
      }
      else
      {
        if (v8 == 1751411059 || v8 == 1751410032)
        {
          double v33 = &__block_literal_global_213;
          goto LABEL_151;
        }
        unsigned __int16 v28 = 26995;
      }
      if (v8 != (v28 | 0x66640000)) {
        goto LABEL_189;
      }
LABEL_105:
      uint64_t v3 = convertFloat16ToFloat32(this, a2);
      if (v3) {
        BOOL v31 = 0;
      }
      else {
        BOOL v31 = v20;
      }
      if (!v31) {
        return v3;
      }
      BOOL v32 = &__block_literal_global_211;
LABEL_118:
      PixelBufferUtils::forEveryPixel(a2, v32, -1);
      return 0;
    }
    if (PixelFormatType != 1717856627)
    {
      int v22 = 1751410032;
LABEL_80:
      if (PixelFormatType != v22) {
        goto LABEL_156;
      }
      goto LABEL_81;
    }
    goto LABEL_85;
  }
  if ((int)PixelFormatType <= 1094862673)
  {
    if ((int)PixelFormatType <= 875704421)
    {
      if (PixelFormatType != 32)
      {
        if (PixelFormatType == 825437747) {
          goto LABEL_58;
        }
        goto LABEL_156;
      }
      goto LABEL_69;
    }
    if (PixelFormatType != 875704422 && PixelFormatType != 875704438) {
      goto LABEL_156;
    }
    if ((int)v8 > 1380401728)
    {
      if ((int)v8 <= 1380411456)
      {
        if (v8 == 1380401729) {
          goto LABEL_214;
        }
        unsigned __int16 v51 = 26177;
      }
      else
      {
        if (v8 == 1919365992)
        {
          return createRGBPlanarHalfFromBuffer(this, a2);
        }
        if (v8 == 1919365990)
        {
          return createRGBPlanarFloatFromBuffer(this, a2);
        }
        unsigned __int16 v51 = 26689;
      }
      int v29 = v51 | 0x52470000;
LABEL_213:
      if (v8 == v29) {
        goto LABEL_214;
      }
LABEL_235:
      PixelBufferUtils::pixelFormatAsString(v8, (char *)&src);
      if ((src.width & 0x8000000000000000) == 0) {
        p_vImage_Buffer src = &src;
      }
      else {
        p_vImage_Buffer src = src.data;
      }
      NSLog(&cfstr_SDErrorPixelFo.isa, "convertPixelBufferFormat", 2142, v10, p_src);
      goto LABEL_243;
    }
    if ((int)v8 <= 875704437)
    {
      if (v8 == 32) {
        goto LABEL_214;
      }
      if (v8 != 875704422) {
        goto LABEL_235;
      }
    }
    else if (v8 != 875704438)
    {
      if (v8 != 1094862674)
      {
        int v29 = 1111970369;
        goto LABEL_213;
      }
LABEL_214:
      return createBGRAPermutesFromYUV(this, v8, a2);
    }
    NSLog(&cfstr_WarningIncorre.isa);
    uint64_t v57 = *MEMORY[0x263F00148];
    uint64_t v58 = *(void *)(MEMORY[0x263F00148] + 8);
    uint64_t v59 = *MEMORY[0x263F001A8];
    uint64_t v60 = *(void *)(MEMORY[0x263F001A8] + 8);
    uint64_t v61 = *(void *)(MEMORY[0x263F001A8] + 16);
    uint64_t v62 = *(void *)(MEMORY[0x263F001A8] + 24);
    return copyPixelBufferMultiPlane(a2, *(CGPoint *)&v57, this, *(CGRect *)&v59);
  }
  if ((int)PixelFormatType > 1278226487)
  {
    if (PixelFormatType == 1278226488)
    {
      if ((int)v8 > 1380401728)
      {
        if (v8 == 1380401729 || v8 == 1380411457) {
          goto LABEL_189;
        }
        int v35 = 1380410945;
      }
      else
      {
        if (v8 == 32 || v8 == 1094862674) {
          goto LABEL_189;
        }
        int v35 = 1111970369;
      }
      if (v8 == v35) {
        goto LABEL_189;
      }
      PixelBufferUtils::pixelFormatAsString(v8, (char *)&src);
      if ((src.width & 0x8000000000000000) == 0) {
        float64x2_t v64 = &src;
      }
      else {
        float64x2_t v64 = src.data;
      }
      NSLog(&cfstr_SDErrorPixelFo.isa, "convertPixelBufferFormat", 2207, v10, v64);
      goto LABEL_243;
    }
    if (PixelFormatType != 1278226534)
    {
      int v22 = 1278226536;
      goto LABEL_80;
    }
LABEL_85:
    if ((int)v8 > 1717856626)
    {
      if (v8 != 1717856627)
      {
        if (v8 != 1751411059 && v8 != 1751410032) {
          goto LABEL_189;
        }
        goto LABEL_113;
      }
LABEL_112:
      double v33 = &__block_literal_global_209;
LABEL_151:
      PixelBufferUtils::forEveryPixel(this, a2, v33, 0xFFFFFFFFuLL);
      return 0;
    }
    if (v8 == 1278226536)
    {
LABEL_113:
      uint64_t v3 = convertFloat32ToFloat16(this, a2);
      if (v3) {
        BOOL v34 = 0;
      }
      else {
        BOOL v34 = v20;
      }
      if (!v34) {
        return v3;
      }
      BOOL v32 = &__block_literal_global_5099;
      goto LABEL_118;
    }
    if (v8 == 1717855600) {
      goto LABEL_112;
    }
LABEL_189:
    return convertGrayscaleAsColor(this, v8, a2);
  }
  if (PixelFormatType != 1094862674)
  {
    int v25 = 1111970369;
LABEL_68:
    if (PixelFormatType == v25) {
      goto LABEL_69;
    }
LABEL_156:
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&src);
    if ((src.width & 0x8000000000000000) == 0) {
      vImagePixelCount v52 = &src;
    }
    else {
      vImagePixelCount v52 = src.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convertPixelBufferFormat", 2214, PixelFormatType, v52);
    goto LABEL_243;
  }
LABEL_69:
  if ((int)v8 > 1380401728)
  {
    if ((int)v8 <= 1380411456)
    {
      if (v8 == 1380401729) {
        goto LABEL_128;
      }
      unsigned __int16 v27 = 26177;
    }
    else
    {
      if (v8 == 1919365992)
      {
        if (PixelFormatType == 1380410945)
        {
          return convert4ChannelToPlanar<float,half>(this, a2);
        }
        else if (PixelFormatType == 1380411457)
        {
          return convert4ChannelToPlanar<half,half>(this, a2);
        }
        else
        {
          return convert4ChannelToPlanar<unsigned char,half>(this, a2);
        }
      }
      if (v8 == 1919365990)
      {
        if (PixelFormatType == 1380410945)
        {
          return convert4ChannelToPlanar<float,float>(this, a2);
        }
        else if (PixelFormatType == 1380411457)
        {
          return convert4ChannelToPlanar<half,float>(this, a2);
        }
        else
        {
          return convert4ChannelToPlanar<unsigned char,float>(this, a2);
        }
      }
      unsigned __int16 v27 = 26689;
    }
    int v26 = v27 | 0x52470000;
LABEL_127:
    if (v8 == v26) {
      goto LABEL_128;
    }
    goto LABEL_173;
  }
  if ((int)v8 <= 875704437)
  {
    if (v8 == 32) {
      goto LABEL_128;
    }
    if (v8 != 875704422)
    {
LABEL_173:
      if (!PixelBufferUtils::planeCountForPixelFormat((PixelBufferUtils *)v8)
        && PixelBufferUtils::componentsPerPixelForPixelFormat(v10, 0) == 1)
      {
        return convertColorToGrayscale(this, a2);
      }
      PixelBufferUtils::pixelFormatAsString((unint64_t)v10, (char *)&src);
      if ((src.width & 0x8000000000000000) == 0) {
        float v56 = &src;
      }
      else {
        float v56 = src.data;
      }
      NSLog(&cfstr_SDErrorPixelFo.isa, "convertPixelBufferFormat", 2103, v10, v56);
LABEL_243:
      if (SHIBYTE(src.width) < 0) {
        operator delete(src.data);
      }
      return 0xFFFFFFFFLL;
    }
  }
  else if (v8 != 875704438)
  {
    if (v8 != 1094862674)
    {
      int v26 = 1111970369;
      goto LABEL_127;
    }
LABEL_128:
    return convert4ChannelFormats(this, v8, a2);
  }
  return YUVFromBGRAPermutes(this, a2, v9);
}

void sub_215FAA0B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (*(char *)(v19 - 57) < 0) {
    operator delete(*(void **)(v19 - 80));
  }
  _Unwind_Resume(exception_object);
}

uint64_t copyPixelBufferVImage(__CVBuffer *a1, CGPoint a2, __CVBuffer *a3, CGRect a4)
{
  if (a1 == a3) {
    return 0;
  }
  double height = a4.size.height;
  double width = a4.size.width;
  double y = a4.origin.y;
  double x = a4.origin.x;
  double v9 = a2.y;
  double v10 = a2.x;
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a3);
  if (PixelFormatType != CVPixelBufferGetPixelFormatType(a1)) {
    return 0xFFFFFFFFLL;
  }
  if (!CVPixelBufferGetPlaneCount(a3))
  {
    BOOL v20 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(a3);
    CVPixelBufferLockBaseAddress(a1, 0);
    CVPixelBufferLockBaseAddress(a3, 1uLL);
    memset(&src, 0, sizeof(src));
    BOOL v21 = (CGRect *)MEMORY[0x263F001A8];
    PixelBufferUtils::asVImageBuffer(a3, *MEMORY[0x263F001A8], &src);
    memset(&dest, 0, sizeof(dest));
    PixelBufferUtils::asVImageBuffer(a1, *v21, &dest);
    size_t v22 = PixelBufferUtils::pixelSizeForPixelFormat(v20, 0);
    v33.origin.double x = x;
    v33.origin.double y = y;
    v33.size.double width = width;
    v33.size.double height = height;
    IsEmptdouble y = CGRectIsEmpty(v33);
    vImagePixelCount v24 = src.width;
    if (IsEmpty)
    {
      vImagePixelCount v25 = src.height;
    }
    else
    {
      if (x >= (double)src.width || y >= (double)src.height) {
        goto LABEL_29;
      }
      if (width > (double)src.width || height > (double)src.height) {
        goto LABEL_29;
      }
      vImagePixelCount v24 = (unint64_t)width;
      vImagePixelCount v25 = (unint64_t)height;
      src.data = (char *)src.data + src.rowBytes * (unint64_t)y + v22 * (unint64_t)x;
      src.double height = (unint64_t)height;
      src.double width = (unint64_t)width;
    }
    double v26 = (double)v24;
    double v27 = (double)v25;
    v34.origin.double x = v10;
    v34.origin.double y = v9;
    v34.size.double width = (double)v24;
    v34.size.double height = (double)v25;
    if (!CGRectIsEmpty(v34))
    {
      if (v10 >= (double)dest.width
        || v9 >= (double)dest.height
        || (v26 <= (double)dest.width ? (BOOL v28 = v27 <= (double)dest.height) : (BOOL v28 = 0), !v28))
      {
LABEL_29:
        NSLog(&cfstr_SDErrorRegionI.isa, "updateVImageBufferToRegion", 1923);
        return 0xFFFFFFFFLL;
      }
      dest.data = (char *)dest.data + dest.rowBytes * (unint64_t)v9 + v22 * (unint64_t)v10;
      dest.double height = (unint64_t)v27;
      dest.double width = (unint64_t)v26;
    }
    vImageCopyBuffer(&src, &dest, v22, 0);
    CVPixelBufferUnlockBaseAddress(a1, 0);
    CVPixelBufferUnlockBaseAddress(a3, 1uLL);
    return 0;
  }
  double v13 = v10;
  double v14 = v9;
  double v15 = x;
  double v16 = y;
  double v17 = width;
  double v18 = height;
  return copyPixelBufferMultiPlane(a1, *(CGPoint *)&v13, a3, *(CGRect *)&v15);
}

uint64_t convert4ChannelFormats(__CVBuffer *a1, int a2, __CVBuffer *a3)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  uint64_t v7 = RGBA_FORMAT_MAP();
  LODWORD(src.data) = a2;
  HIDWORD(src.data) = PixelFormatType;
  unint64_t v8 = std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v7, (unint64_t)src.data, &src);
  double v9 = (const uint8_t *)v8[3];
  int v10 = *((_DWORD *)v8 + 8);
  CVPixelBufferLockBaseAddress(a3, 0);
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  memset(&src, 0, sizeof(src));
  int v11 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &src);
  memset(&v86, 0, sizeof(v86));
  PixelBufferUtils::asVImageBuffer(a3, *v11, &v86);
  _S0 = 1.0;
  long long maxFloat = xmmword_215FC4720;
  minFloat[0] = 0;
  minFloat[1] = 0;
  switch(v10)
  {
    case 0:
      vImage_Error v13 = vImagePermuteChannels_ARGB8888(&src, &v86, v9, 0);
      goto LABEL_23;
    case 1:
      vImagePixelCount height = src.height;
      if (src.height != v86.height) {
        goto LABEL_46;
      }
      vImagePixelCount width = src.width;
      if (src.width != v86.width) {
        goto LABEL_46;
      }
      if (!src.height || !src.width) {
        goto LABEL_56;
      }
      uint64_t v16 = 0;
      size_t rowBytes = v86.rowBytes;
      data = (char *)src.data;
      size_t v19 = src.rowBytes;
      BOOL v20 = (char *)v86.data;
      do
      {
        BOOL v21 = &data[v16 * v19];
        vImagePixelCount v22 = width;
        unint64_t v23 = &v20[v16 * rowBytes];
        do
        {
          LOBYTE(_S0) = *v21;
          *(float *)&unsigned int v24 = (float)LODWORD(_S0) * 0.0039216;
          *(float *)&v23[4 * *v9] = *(float *)&v24;
          LOBYTE(v24) = v21[1];
          *(float *)&unsigned int v25 = (float)v24 * 0.0039216;
          *(float *)&v23[4 * v9[1]] = *(float *)&v25;
          LOBYTE(v25) = v21[2];
          *(float *)&unsigned int v26 = (float)v25 * 0.0039216;
          *(float *)&v23[4 * v9[2]] = *(float *)&v26;
          LOBYTE(v26) = v21[3];
          _S0 = (float)v26 * 0.0039216;
          *(float *)&v23[4 * v9[3]] = _S0;
          v21 += 4;
          v23 += 16;
          --v22;
        }
        while (v22);
        uint64_t v27 = 0;
        ++v16;
      }
      while (v16 != height);
      break;
    case 2:
      vImagePixelCount v28 = src.height;
      if (src.height != v86.height) {
        goto LABEL_46;
      }
      vImagePixelCount v29 = src.width;
      if (src.width != v86.width) {
        goto LABEL_46;
      }
      if (!src.height || !src.width) {
        goto LABEL_56;
      }
      uint64_t v30 = 0;
      size_t v32 = v86.rowBytes;
      BOOL v31 = (char *)src.data;
      size_t v33 = src.rowBytes;
      CGRect v34 = (char *)v86.data;
      do
      {
        int v35 = &v31[v30 * v33];
        vImagePixelCount v36 = v29;
        int v37 = &v34[v30 * v32];
        do
        {
          LOBYTE(_S0) = *v35;
          *(float *)&_S0 = (float)LODWORD(_S0) * 0.0039216;
          __asm { FCVT            H0, S0 }
          *(_WORD *)&v37[2 * *v9] = _S0;
          LOBYTE(_S0) = v35[1];
          *(float *)&_S0 = (float)_S0 * 0.0039216;
          __asm { FCVT            H0, S0 }
          *(_WORD *)&v37[2 * v9[1]] = _S0;
          LOBYTE(_S0) = v35[2];
          *(float *)&_S0 = (float)_S0 * 0.0039216;
          __asm { FCVT            H0, S0 }
          *(_WORD *)&v37[2 * v9[2]] = _S0;
          LOBYTE(_S0) = v35[3];
          _S0 = (float)_S0 * 0.0039216;
          __asm { FCVT            H0, S0 }
          *(_WORD *)&v37[2 * v9[3]] = LOWORD(_S0);
          v35 += 4;
          v37 += 8;
          --v36;
        }
        while (v36);
        uint64_t v27 = 0;
        ++v30;
      }
      while (v30 != v28);
      break;
    case 3:
      vImage_Error v13 = vImageConvert_ARGBFFFFtoARGB8888_dithered(&src, &v86, (const float *)&maxFloat, (const float *)minFloat, 0, v9, 0);
      goto LABEL_23;
    case 4:
      vImage_Error v13 = vImagePermuteChannels_ARGBFFFF(&src, &v86, v9, 0);
LABEL_23:
      uint64_t v27 = v13;
      break;
    case 5:
      vImagePixelCount v45 = src.height;
      if (src.height != v86.height) {
        goto LABEL_46;
      }
      vImagePixelCount v46 = src.width;
      if (src.width != v86.width) {
        goto LABEL_46;
      }
      if (!src.height || !src.width) {
        goto LABEL_56;
      }
      uint64_t v47 = 0;
      size_t v49 = v86.rowBytes;
      float v48 = (char *)src.data;
      size_t v50 = src.rowBytes;
      unsigned __int16 v51 = (char *)v86.data;
      do
      {
        vImagePixelCount v52 = &v48[v47 * v50];
        vImagePixelCount v53 = v46;
        float64x2_t v54 = &v51[v47 * v49];
        do
        {
          _S0 = *(_DWORD *)v52;
          __asm { FCVT            H0, S0 }
          *(_WORD *)&v54[2 * *v9] = _S0;
          _S0 = *((_DWORD *)v52 + 1);
          __asm { FCVT            H0, S0 }
          *(_WORD *)&v54[2 * v9[1]] = _S0;
          _S0 = *((_DWORD *)v52 + 2);
          __asm { FCVT            H0, S0 }
          *(_WORD *)&v54[2 * v9[2]] = _S0;
          _S0 = *((_DWORD *)v52 + 3);
          __asm { FCVT            H0, S0 }
          *(_WORD *)&v54[2 * v9[3]] = _S0;
          v54 += 8;
          v52 += 16;
          --v53;
        }
        while (v53);
        uint64_t v27 = 0;
        ++v47;
      }
      while (v47 != v45);
      break;
    case 6:
      vImagePixelCount v59 = src.height;
      if (src.height != v86.height) {
        goto LABEL_46;
      }
      vImagePixelCount v60 = src.width;
      if (src.width != v86.width) {
        goto LABEL_46;
      }
      if (!src.height || !src.width) {
        goto LABEL_56;
      }
      uint64_t v61 = 0;
      size_t v63 = v86.rowBytes;
      uint64_t v62 = (char *)src.data;
      size_t v64 = src.rowBytes;
      vImagePixelCount v65 = (char *)v86.data;
      do
      {
        vImagePixelCount v66 = &v62[v61 * v64];
        vImagePixelCount v67 = v60;
        size_t v68 = &v65[v61 * v63];
        do
        {
          _H0 = *(_WORD *)v66;
          __asm { FCVT            S0, H0 }
          *(_DWORD *)&v68[4 * *v9] = _S0;
          LOWORD(_S0) = *((_WORD *)v66 + 1);
          __asm { FCVT            S0, H0 }
          *(_DWORD *)&v68[4 * v9[1]] = _S0;
          LOWORD(_S0) = *((_WORD *)v66 + 2);
          __asm { FCVT            S0, H0 }
          *(_DWORD *)&v68[4 * v9[2]] = _S0;
          LOWORD(_S0) = *((_WORD *)v66 + 3);
          __asm { FCVT            S0, H0 }
          *(_DWORD *)&v68[4 * v9[3]] = _S0;
          v68 += 16;
          v66 += 8;
          --v67;
        }
        while (v67);
        uint64_t v27 = 0;
        ++v61;
      }
      while (v61 != v59);
      break;
    case 7:
      vImagePixelCount v74 = src.height;
      if (*(_OWORD *)&src.height != *(_OWORD *)&v86.height) {
        goto LABEL_46;
      }
      if (src.height && src.width)
      {
        vImagePixelCount v75 = 0;
        vImagePixelCount v76 = 1;
        do
        {
          if (v76)
          {
            vImagePixelCount v78 = 0;
            float64x2_t v79 = (char *)v86.data + v86.rowBytes * v75;
            float64x2_t v80 = (__int16 *)((char *)src.data + src.rowBytes * v75);
            do
            {
              _H0 = *v80;
              __asm { FCVT            S0, H0 }
              v79[*v9] = (int)(float)(_S0 * 255.0);
              LOWORD(_S0) = v80[1];
              __asm { FCVT            S0, H0 }
              v79[v9[1]] = (int)(float)(_S0 * 255.0);
              LOWORD(_S0) = v80[2];
              __asm { FCVT            S0, H0 }
              v79[v9[2]] = (int)(float)(_S0 * 255.0);
              LOWORD(_S0) = v80[3];
              __asm { FCVT            S0, H0 }
              v79[v9[3]] = (int)(float)(_S0 * 255.0);
              ++v78;
              v79 += 4;
              vImagePixelCount v76 = src.width;
              v80 += 4;
            }
            while (v78 < src.width);
            vImagePixelCount v74 = src.height;
          }
          uint64_t v27 = 0;
          ++v75;
        }
        while (v75 < v74);
      }
      else
      {
LABEL_56:
        uint64_t v27 = 0;
      }
      break;
    default:
LABEL_46:
      uint64_t v27 = -1;
      break;
  }
  CVPixelBufferUnlockBaseAddress(a3, 0);
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  if (v27) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

BOOL YUVFromBGRAPermutes(__CVBuffer *a1, __CVBuffer *a2, __CVBuffer *a3)
{
  uint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  if (PixelFormatType == 1380411457 || (uint64_t v6 = PixelFormatType, PixelFormatType == 1380410945))
  {
    uint64_t v6 = 1111970369;
    size_t Width = CVPixelBufferGetWidth(a1);
    size_t Height = CVPixelBufferGetHeight(a1);
    pixelBufferOut.data = 0;
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
    if (CVPixelBufferCreate(v9, Width, Height, 0x42475241u, BufferAttributes, (CVPixelBufferRef *)&pixelBufferOut)) {
      data = 0;
    }
    else {
      data = (__CVBuffer *)pixelBufferOut.data;
    }
    vImage_Error v12 = (int)convert4ChannelFormats(a1, 1111970369, data);
  }
  else
  {
    vImage_Error v12 = 0;
    data = a1;
  }
  uint64_t v13 = RGBA_FORMAT_MAP();
  pixelBufferOut.data = (void *)((v6 << 32) | 0x20);
  double v14 = (const uint8_t *)std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v13, (unint64_t)pixelBufferOut.data, &pixelBufferOut)[3];
  CVPixelBufferLockBaseAddress(a2, 0);
  CVPixelBufferLockBaseAddress(data, 1uLL);
  memset(&pixelBufferOut, 0, sizeof(pixelBufferOut));
  double v15 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(data, *MEMORY[0x263F001A8], &pixelBufferOut);
  memset(&destYp, 0, sizeof(destYp));
  PixelBufferUtils::asVImageBuffer(a2, 0, *v15, &destYp);
  memset(&destCbCr, 0, sizeof(destCbCr));
  PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, *v15, &destCbCr);
  if ((YUVFromBGRAPermutes(__CVBuffer *,unsigned int,__CVBuffer *)::isConvesionInfoDefined & 1) == 0)
  {
    vImage_YpCbCrPixelRange v17 = *(vImage_YpCbCrPixelRange *)ymmword_215FC544C;
    vImage_Error v12 = vImageConvert_ARGBToYpCbCr_GenerateConversion((const vImage_ARGBToYpCbCrMatrix *)*MEMORY[0x263EFAA10], &v17, &YUVFromBGRAPermutes(__CVBuffer *,unsigned int,__CVBuffer *)::conversionInfo, kvImageARGB8888, kvImage420Yp8_CbCr8, 0);
    YUVFromBGRAPermutes(__CVBuffer *,unsigned int,__CVBuffer *)::isConvesionInfoDefined = 1;
  }
  if (!v12) {
    vImage_Error v12 = vImageConvert_ARGB8888To420Yp8_CbCr8(&pixelBufferOut, &destYp, &destCbCr, &YUVFromBGRAPermutes(__CVBuffer *,unsigned int,__CVBuffer *)::conversionInfo, v14, 0);
  }
  CVPixelBufferUnlockBaseAddress(data, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  if (CVPixelBufferGetPixelFormatType(a1) == 1380410945) {
    CVPixelBufferRelease(data);
  }
  return v12 != 0;
}

uint64_t convert4ChannelToPlanar<half,float>(__CVBuffer *a1, __CVBuffer *a2)
{
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  unint64_t v5 = CVPixelBufferGetPixelFormatType(a2);
  unint64_t v6 = PixelBufferUtils::planeCountForPixelFormat((PixelBufferUtils *)v5);
  if (PixelBufferUtils::componentsPerPixelForPixelFormat((PixelBufferUtils *)PixelFormatType, 0) == 4)
  {
    if (v6)
    {
      CVPixelBufferLockBaseAddress(a2, 0);
      CVPixelBufferLockBaseAddress(a1, 1uLL);
      uint64_t v7 = RGBA_FORMAT_MAP();
      LODWORD(__p.data) = v5;
      HIDWORD(__p.data) = PixelFormatType;
      unint64_t v8 = std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v7, (unint64_t)__p.data, &__p);
      CFAllocatorRef v9 = (unsigned __int8 *)v8[3];
      unsigned int v10 = *((_DWORD *)v8 + 8) - 1;
      float v11 = 1.0;
      if (v10 <= 6) {
        float v11 = flt_215FC546C[v10];
      }
      memset(&__p, 0, sizeof(__p));
      vImage_Error v12 = (CGRect *)MEMORY[0x263F001A8];
      PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &__p);
      int v103 = 0;
      uint64_t v13 = (__CVBuffer *)*v9;
      if (v6 <= (unint64_t)v13)
      {
        size_t rowBytes = 0;
        data = &v103;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v13, *v12, &v102);
        data = (int *)v102.data;
        size_t rowBytes = v102.rowBytes;
      }
      double v18 = (__CVBuffer *)v9[1];
      if (v6 <= (unint64_t)v18)
      {
        size_t v20 = 0;
        size_t v19 = &v103;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v18, *v12, &v102);
        size_t v19 = (int *)v102.data;
        size_t v20 = v102.rowBytes;
      }
      BOOL v21 = (__CVBuffer *)v9[2];
      pixelBuffer = a2;
      if (v6 <= (unint64_t)v21)
      {
        size_t v23 = 0;
        vImagePixelCount v22 = &v103;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v21, *v12, &v102);
        vImagePixelCount v22 = (int *)v102.data;
        size_t v23 = v102.rowBytes;
      }
      CGRect v99 = a1;
      unsigned int v24 = (__CVBuffer *)v9[3];
      if (v6 <= (unint64_t)v24)
      {
        size_t v26 = 0;
        unsigned int v25 = &v103;
        vImagePixelCount height = __p.height;
        if (!__p.height) {
          goto LABEL_66;
        }
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(pixelBuffer, v24, *v12, &v102);
        unsigned int v25 = (int *)v102.data;
        size_t v26 = v102.rowBytes;
        vImagePixelCount height = __p.height;
        if (!__p.height) {
          goto LABEL_66;
        }
      }
      vImagePixelCount width = __p.width;
      if (__p.width)
      {
        uint64_t v29 = 0;
        vImagePixelCount v30 = __p.width & 0xFFFFFFFFFFFFFFFELL;
        BOOL v31 = data;
        size_t v32 = (float *)(data + 1);
        size_t v33 = (char *)__p.data;
        size_t v34 = __p.rowBytes;
        int v35 = (char *)__p.data + 8;
        vImagePixelCount v36 = (char *)__p.data + 10;
        int v37 = (float *)(v19 + 1);
        vImage_Error v38 = (char *)__p.data + 12;
        vImage_Error v39 = (float *)(v22 + 1);
        vImagePixelCount v40 = (char *)__p.data + 14;
        size_t v41 = (float *)(v25 + 1);
        uint64_t v42 = v25;
        double v43 = v22;
        size_t v44 = v19;
        while (1)
        {
          if ((int *)((char *)data + rowBytes * v29) == &v103) {
            goto LABEL_41;
          }
          if (width == 1) {
            break;
          }
          vImagePixelCount v46 = (__int16 *)v35;
          uint64_t v47 = v32;
          unint64_t v48 = width & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            _H0 = *(v46 - 4);
            _H1 = *v46;
            __asm
            {
              FCVT            S0, H0
              FCVT            S1, H1
            }
            *(v47 - 1) = v11 * _S0;
            *uint64_t v47 = v11 * _S1;
            v47 += 2;
            v46 += 8;
            v48 -= 2;
          }
          while (v48);
          unint64_t v45 = width & 0xFFFFFFFFFFFFFFFELL;
          if (width != v30) {
            goto LABEL_39;
          }
LABEL_41:
          if ((int *)((char *)v19 + v20 * v29) == &v103) {
            goto LABEL_49;
          }
          if (width == 1)
          {
            unint64_t v63 = 0;
LABEL_47:
            vImagePixelCount v71 = width - v63;
            uint64_t v72 = 4 * v63;
            do
            {
              _H0 = *(_WORD *)&v33[2 * v72 + 2];
              __asm { FCVT            S0, H0 }
              *(float *)&v44[(unint64_t)v72 / 4] = v11 * _S0;
              v72 += 4;
              --v71;
            }
            while (v71);
            goto LABEL_49;
          }
          size_t v64 = v37;
          vImagePixelCount v65 = (__int16 *)v36;
          unint64_t v66 = width & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            _H0 = *(v65 - 4);
            _H1 = *v65;
            __asm
            {
              FCVT            S0, H0
              FCVT            S1, H1
            }
            *(v64 - 1) = v11 * _S0;
            *size_t v64 = v11 * _S1;
            v65 += 8;
            v64 += 2;
            v66 -= 2;
          }
          while (v66);
          unint64_t v63 = width & 0xFFFFFFFFFFFFFFFELL;
          if (width != v30) {
            goto LABEL_47;
          }
LABEL_49:
          if ((int *)((char *)v22 + v23 * v29) == &v103) {
            goto LABEL_57;
          }
          if (width == 1)
          {
            unint64_t v75 = 0;
LABEL_55:
            vImagePixelCount v83 = width - v75;
            uint64_t v84 = 4 * v75;
            do
            {
              _H0 = *(_WORD *)&v33[2 * v84 + 4];
              __asm { FCVT            S0, H0 }
              *(float *)&v43[(unint64_t)v84 / 4] = v11 * _S0;
              v84 += 4;
              --v83;
            }
            while (v83);
            goto LABEL_57;
          }
          vImagePixelCount v76 = v39;
          vImage_Buffer v77 = (__int16 *)v38;
          unint64_t v78 = width & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            _H0 = *(v77 - 4);
            _H1 = *v77;
            __asm
            {
              FCVT            S0, H0
              FCVT            S1, H1
            }
            *(v76 - 1) = v11 * _S0;
            *vImagePixelCount v76 = v11 * _S1;
            v77 += 8;
            v76 += 2;
            v78 -= 2;
          }
          while (v78);
          unint64_t v75 = width & 0xFFFFFFFFFFFFFFFELL;
          if (width != v30) {
            goto LABEL_55;
          }
LABEL_57:
          if ((int *)((char *)v25 + v26 * v29) != &v103)
          {
            if (width == 1)
            {
              unint64_t v87 = 0;
            }
            else
            {
              vImagePixelCount v88 = v41;
              unsigned int v89 = (__int16 *)v40;
              unint64_t v90 = width & 0xFFFFFFFFFFFFFFFELL;
              do
              {
                _H0 = *(v89 - 4);
                _H1 = *v89;
                __asm
                {
                  FCVT            S0, H0
                  FCVT            S1, H1
                }
                *(v88 - 1) = v11 * _S0;
                *vImagePixelCount v88 = v11 * _S1;
                v89 += 8;
                v88 += 2;
                v90 -= 2;
              }
              while (v90);
              unint64_t v87 = width & 0xFFFFFFFFFFFFFFFELL;
              if (width == v30) {
                goto LABEL_32;
              }
            }
            vImagePixelCount v95 = width - v87;
            uint64_t v96 = 4 * v87;
            do
            {
              _H0 = *(_WORD *)&v33[2 * v96 + 6];
              __asm { FCVT            S0, H0 }
              *(float *)&v42[(unint64_t)v96 / 4] = v11 * _S0;
              v96 += 4;
              --v95;
            }
            while (v95);
          }
LABEL_32:
          ++v29;
          size_t v32 = (float *)((char *)v32 + rowBytes);
          v35 += v34;
          BOOL v31 = (int *)((char *)v31 + rowBytes);
          v33 += v34;
          v36 += v34;
          int v37 = (float *)((char *)v37 + v20);
          size_t v44 = (int *)((char *)v44 + v20);
          v38 += v34;
          vImage_Error v39 = (float *)((char *)v39 + v23);
          double v43 = (int *)((char *)v43 + v23);
          v40 += v34;
          size_t v41 = (float *)((char *)v41 + v26);
          uint64_t v42 = (int *)((char *)v42 + v26);
          if (v29 == height) {
            goto LABEL_66;
          }
        }
        unint64_t v45 = 0;
LABEL_39:
        vImagePixelCount v57 = width - v45;
        uint64_t v58 = (float *)&v31[v45];
        vImagePixelCount v59 = &v33[8 * v45];
        do
        {
          __int16 v60 = *(_WORD *)v59;
          v59 += 8;
          _H0 = v60;
          __asm { FCVT            S0, H0 }
          *v58++ = v11 * _S0;
          --v57;
        }
        while (v57);
        goto LABEL_41;
      }
LABEL_66:
      CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
      CVPixelBufferUnlockBaseAddress(v99, 1uLL);
      return 0;
    }
    PixelBufferUtils::pixelFormatAsString(v5, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1264, v5, p_p);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 4294967294;
  }
  else
  {
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      double v15 = &__p;
    }
    else {
      double v15 = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1258, PixelFormatType, v15);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_215FAB0E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t convert4ChannelToPlanar<float,float>(__CVBuffer *a1, __CVBuffer *a2)
{
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  unint64_t v5 = CVPixelBufferGetPixelFormatType(a2);
  unint64_t v6 = PixelBufferUtils::planeCountForPixelFormat((PixelBufferUtils *)v5);
  if (PixelBufferUtils::componentsPerPixelForPixelFormat((PixelBufferUtils *)PixelFormatType, 0) == 4)
  {
    if (v6)
    {
      CVPixelBufferLockBaseAddress(a2, 0);
      CVPixelBufferLockBaseAddress(a1, 1uLL);
      uint64_t v7 = RGBA_FORMAT_MAP();
      LODWORD(__p.data) = v5;
      HIDWORD(__p.data) = PixelFormatType;
      unint64_t v8 = std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v7, (unint64_t)__p.data, &__p);
      CFAllocatorRef v9 = (unsigned __int8 *)v8[3];
      unsigned int v10 = *((_DWORD *)v8 + 8) - 1;
      float v11 = 1.0;
      if (v10 <= 6) {
        float v11 = flt_215FC546C[v10];
      }
      memset(&__p, 0, sizeof(__p));
      vImage_Error v12 = (CGRect *)MEMORY[0x263F001A8];
      PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &__p);
      int v49 = 0;
      uint64_t v13 = (__CVBuffer *)*v9;
      if (v6 <= (unint64_t)v13)
      {
        size_t rowBytes = 0;
        data = (float *)&v49;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v13, *v12, &v48);
        data = (float *)v48.data;
        size_t rowBytes = v48.rowBytes;
      }
      pixelBuffer = a1;
      size_t v19 = (__CVBuffer *)v9[1];
      if (v6 <= (unint64_t)v19)
      {
        size_t v21 = 0;
        size_t v20 = &v49;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v19, *v12, &v48);
        size_t v20 = (int *)v48.data;
        size_t v21 = v48.rowBytes;
      }
      vImagePixelCount v22 = (__CVBuffer *)v9[2];
      if (v6 <= (unint64_t)v22)
      {
        size_t v24 = 0;
        size_t v23 = &v49;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v22, *v12, &v48);
        size_t v23 = (int *)v48.data;
        size_t v24 = v48.rowBytes;
      }
      unsigned int v25 = (__CVBuffer *)v9[3];
      if (v6 <= (unint64_t)v25)
      {
        size_t v27 = 0;
        size_t v26 = &v49;
        vImagePixelCount height = __p.height;
        if (!__p.height)
        {
LABEL_46:
          CVPixelBufferUnlockBaseAddress(a2, 0);
          CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
          return 0;
        }
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v25, *v12, &v48);
        size_t v26 = (int *)v48.data;
        size_t v27 = v48.rowBytes;
        vImagePixelCount height = __p.height;
        if (!__p.height) {
          goto LABEL_46;
        }
      }
      vImagePixelCount width = __p.width;
      if (__p.width)
      {
        uint64_t v30 = 0;
        BOOL v31 = (float *)__p.data;
        size_t v32 = __p.rowBytes;
        size_t v33 = v26;
        size_t v34 = v23;
        int v35 = v20;
        vImagePixelCount v36 = data;
        do
        {
          if ((int *)((char *)data + rowBytes * v30) != &v49)
          {
            int v37 = v31;
            vImage_Error v38 = v36;
            vImagePixelCount v39 = width;
            do
            {
              float v40 = *v37;
              v37 += 4;
              *v38++ = v11 * v40;
              --v39;
            }
            while (v39);
          }
          if ((int *)((char *)v20 + v21 * v30) != &v49)
          {
            uint64_t v41 = 0;
            vImagePixelCount v42 = width;
            do
            {
              *(float *)&v35[v41] = v11 * v31[v41 * 4 + 1];
              ++v41;
              --v42;
            }
            while (v42);
          }
          if ((int *)((char *)v23 + v24 * v30) != &v49)
          {
            uint64_t v43 = 0;
            vImagePixelCount v44 = width;
            do
            {
              *(float *)&v34[v43] = v11 * v31[v43 * 4 + 2];
              ++v43;
              --v44;
            }
            while (v44);
          }
          if ((int *)((char *)v26 + v27 * v30) != &v49)
          {
            uint64_t v45 = 0;
            vImagePixelCount v46 = width;
            do
            {
              *(float *)&v33[v45] = v11 * v31[v45 * 4 + 3];
              ++v45;
              --v46;
            }
            while (v46);
          }
          ++v30;
          vImagePixelCount v36 = (float *)((char *)v36 + rowBytes);
          BOOL v31 = (float *)((char *)v31 + v32);
          int v35 = (int *)((char *)v35 + v21);
          size_t v34 = (int *)((char *)v34 + v24);
          size_t v33 = (int *)((char *)v33 + v27);
        }
        while (v30 != height);
      }
      goto LABEL_46;
    }
    PixelBufferUtils::pixelFormatAsString(v5, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1264, v5, p_p);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 4294967294;
  }
  else
  {
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      uint64_t v16 = &__p;
    }
    else {
      uint64_t v16 = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1258, PixelFormatType, v16);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_215FAB4C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t convert4ChannelToPlanar<unsigned char,float>(__CVBuffer *a1, __CVBuffer *a2)
{
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  unint64_t v5 = CVPixelBufferGetPixelFormatType(a2);
  unint64_t v6 = PixelBufferUtils::planeCountForPixelFormat((PixelBufferUtils *)v5);
  if (PixelBufferUtils::componentsPerPixelForPixelFormat((PixelBufferUtils *)PixelFormatType, 0) == 4)
  {
    if (v6)
    {
      CVPixelBufferLockBaseAddress(a2, 0);
      CVPixelBufferLockBaseAddress(a1, 1uLL);
      uint64_t v7 = RGBA_FORMAT_MAP();
      LODWORD(__p.data) = v5;
      HIDWORD(__p.data) = PixelFormatType;
      unint64_t v8 = std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v7, (unint64_t)__p.data, &__p);
      CFAllocatorRef v9 = (unsigned __int8 *)v8[3];
      unsigned int v10 = *((_DWORD *)v8 + 8) - 1;
      float v11 = 1.0;
      if (v10 <= 6) {
        float v11 = flt_215FC546C[v10];
      }
      memset(&__p, 0, sizeof(__p));
      vImage_Error v12 = (CGRect *)MEMORY[0x263F001A8];
      PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &__p);
      int v50 = 0;
      double v14 = (__CVBuffer *)*v9;
      if (v6 <= (unint64_t)v14)
      {
        size_t rowBytes = 0;
        data = (float *)&v50;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v14, *v12, &v49);
        data = (float *)v49.data;
        size_t rowBytes = v49.rowBytes;
      }
      pixelBuffer = a1;
      size_t v20 = (__CVBuffer *)v9[1];
      if (v6 <= (unint64_t)v20)
      {
        size_t v22 = 0;
        size_t v21 = &v50;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v20, *v12, &v49);
        size_t v21 = (int *)v49.data;
        size_t v22 = v49.rowBytes;
      }
      size_t v23 = (__CVBuffer *)v9[2];
      if (v6 <= (unint64_t)v23)
      {
        size_t v25 = 0;
        size_t v24 = &v50;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v23, *v12, &v49);
        size_t v24 = (int *)v49.data;
        size_t v25 = v49.rowBytes;
      }
      size_t v26 = (__CVBuffer *)v9[3];
      if (v6 <= (unint64_t)v26)
      {
        size_t v28 = 0;
        size_t v27 = &v50;
        vImagePixelCount height = __p.height;
        if (!__p.height)
        {
LABEL_46:
          CVPixelBufferUnlockBaseAddress(a2, 0);
          CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
          return 0;
        }
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v26, *v12, &v49);
        size_t v27 = (int *)v49.data;
        size_t v28 = v49.rowBytes;
        vImagePixelCount height = __p.height;
        if (!__p.height) {
          goto LABEL_46;
        }
      }
      vImagePixelCount width = __p.width;
      if (__p.width)
      {
        uint64_t v31 = 0;
        size_t v32 = (unsigned __int8 *)__p.data;
        size_t v33 = __p.rowBytes;
        size_t v34 = v27;
        int v35 = v24;
        vImagePixelCount v36 = v21;
        int v37 = data;
        do
        {
          if ((int *)((char *)data + rowBytes * v31) != &v50)
          {
            vImage_Error v38 = v32;
            vImagePixelCount v39 = v37;
            vImagePixelCount v40 = width;
            do
            {
              unsigned int v41 = *v38;
              v38 += 4;
              float v13 = v11 * (float)v41;
              *v39++ = v13;
              --v40;
            }
            while (v40);
          }
          if ((int *)((char *)v21 + v22 * v31) != &v50)
          {
            uint64_t v42 = 0;
            vImagePixelCount v43 = width;
            do
            {
              LOBYTE(v13) = v32[v42 * 4 + 1];
              float v13 = v11 * (float)LODWORD(v13);
              *(float *)&v36[v42++] = v13;
              --v43;
            }
            while (v43);
          }
          if ((int *)((char *)v24 + v25 * v31) != &v50)
          {
            uint64_t v44 = 0;
            vImagePixelCount v45 = width;
            do
            {
              LOBYTE(v13) = v32[v44 * 4 + 2];
              float v13 = v11 * (float)LODWORD(v13);
              *(float *)&v35[v44++] = v13;
              --v45;
            }
            while (v45);
          }
          if ((int *)((char *)v27 + v28 * v31) != &v50)
          {
            uint64_t v46 = 0;
            vImagePixelCount v47 = width;
            do
            {
              LOBYTE(v13) = v32[v46 * 4 + 3];
              float v13 = v11 * (float)LODWORD(v13);
              *(float *)&v34[v46++] = v13;
              --v47;
            }
            while (v47);
          }
          ++v31;
          int v37 = (float *)((char *)v37 + rowBytes);
          v32 += v33;
          vImagePixelCount v36 = (int *)((char *)v36 + v22);
          int v35 = (int *)((char *)v35 + v25);
          size_t v34 = (int *)((char *)v34 + v28);
        }
        while (v31 != height);
      }
      goto LABEL_46;
    }
    PixelBufferUtils::pixelFormatAsString(v5, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1264, v5, p_p);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 4294967294;
  }
  else
  {
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      vImage_YpCbCrPixelRange v17 = &__p;
    }
    else {
      vImage_YpCbCrPixelRange v17 = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1258, PixelFormatType, v17);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_215FAB8B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t convert4ChannelToPlanar<half,half>(__CVBuffer *a1, __CVBuffer *a2)
{
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  unint64_t v5 = CVPixelBufferGetPixelFormatType(a2);
  unint64_t v6 = PixelBufferUtils::planeCountForPixelFormat((PixelBufferUtils *)v5);
  if (PixelBufferUtils::componentsPerPixelForPixelFormat((PixelBufferUtils *)PixelFormatType, 0) == 4)
  {
    if (v6)
    {
      CVPixelBufferLockBaseAddress(a2, 0);
      CVPixelBufferLockBaseAddress(a1, 1uLL);
      uint64_t v7 = RGBA_FORMAT_MAP();
      LODWORD(__p.data) = v5;
      HIDWORD(__p.data) = PixelFormatType;
      unint64_t v8 = std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v7, (unint64_t)__p.data, &__p);
      CFAllocatorRef v9 = (unsigned __int8 *)v8[3];
      unsigned int v10 = *((_DWORD *)v8 + 8) - 1;
      float v11 = 1.0;
      if (v10 <= 6) {
        float v11 = flt_215FC546C[v10];
      }
      memset(&__p, 0, sizeof(__p));
      vImage_Error v12 = (CGRect *)MEMORY[0x263F001A8];
      PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &__p);
      __int16 v68 = 0;
      float v13 = (__CVBuffer *)*v9;
      if (v6 <= (unint64_t)v13)
      {
        size_t rowBytes = 0;
        data = &v68;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v13, *v12, &v67);
        data = (__int16 *)v67.data;
        size_t rowBytes = v67.rowBytes;
      }
      pixelBuffer = a1;
      size_t v19 = (__CVBuffer *)v9[1];
      if (v6 <= (unint64_t)v19)
      {
        size_t v21 = 0;
        size_t v20 = &v68;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v19, *v12, &v67);
        size_t v20 = (__int16 *)v67.data;
        size_t v21 = v67.rowBytes;
      }
      size_t v22 = (__CVBuffer *)v9[2];
      if (v6 <= (unint64_t)v22)
      {
        size_t v24 = 0;
        size_t v23 = &v68;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v22, *v12, &v67);
        size_t v23 = (__int16 *)v67.data;
        size_t v24 = v67.rowBytes;
      }
      size_t v25 = (__CVBuffer *)v9[3];
      if (v6 <= (unint64_t)v25)
      {
        size_t v27 = 0;
        size_t v26 = &v68;
        vImagePixelCount height = __p.height;
        if (!__p.height)
        {
LABEL_46:
          CVPixelBufferUnlockBaseAddress(a2, 0);
          CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
          return 0;
        }
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v25, *v12, &v67);
        size_t v26 = (__int16 *)v67.data;
        size_t v27 = v67.rowBytes;
        vImagePixelCount height = __p.height;
        if (!__p.height) {
          goto LABEL_46;
        }
      }
      vImagePixelCount width = __p.width;
      if (__p.width)
      {
        uint64_t v30 = 0;
        uint64_t v31 = (char *)__p.data;
        size_t v32 = __p.rowBytes;
        size_t v33 = v26;
        size_t v34 = v23;
        int v35 = v20;
        vImagePixelCount v36 = data;
        do
        {
          if ((__int16 *)((char *)data + rowBytes * v30) != &v68)
          {
            int v37 = (__int16 *)v31;
            vImage_Error v38 = v36;
            vImagePixelCount v39 = width;
            do
            {
              __int16 v40 = *v37;
              v37 += 4;
              _H0 = v40;
              __asm { FCVT            S0, H0 }
              _S0 = v11 * _S0;
              __asm { FCVT            H0, S0 }
              *v38++ = LOWORD(_S0);
              --v39;
            }
            while (v39);
          }
          if ((__int16 *)((char *)v20 + v21 * v30) != &v68)
          {
            uint64_t v48 = 2;
            vImage_Buffer v49 = v35;
            vImagePixelCount v50 = width;
            do
            {
              _H0 = *(_WORD *)&v31[v48];
              __asm { FCVT            S0, H0 }
              _S0 = v11 * _S0;
              __asm { FCVT            H0, S0 }
              *v49++ = LOWORD(_S0);
              v48 += 8;
              --v50;
            }
            while (v50);
          }
          if ((__int16 *)((char *)v23 + v24 * v30) != &v68)
          {
            uint64_t v54 = 4;
            OSStatus v55 = v34;
            vImagePixelCount v56 = width;
            do
            {
              _H0 = *(_WORD *)&v31[v54];
              __asm { FCVT            S0, H0 }
              _S0 = v11 * _S0;
              __asm { FCVT            H0, S0 }
              *v55++ = LOWORD(_S0);
              v54 += 8;
              --v56;
            }
            while (v56);
          }
          if ((__int16 *)((char *)v26 + v27 * v30) != &v68)
          {
            uint64_t v60 = 6;
            uint64_t v61 = v33;
            vImagePixelCount v62 = width;
            do
            {
              _H0 = *(_WORD *)&v31[v60];
              __asm { FCVT            S0, H0 }
              _S0 = v11 * _S0;
              __asm { FCVT            H0, S0 }
              *v61++ = LOWORD(_S0);
              v60 += 8;
              --v62;
            }
            while (v62);
          }
          ++v30;
          vImagePixelCount v36 = (__int16 *)((char *)v36 + rowBytes);
          v31 += v32;
          int v35 = (__int16 *)((char *)v35 + v21);
          size_t v34 = (__int16 *)((char *)v34 + v24);
          size_t v33 = (__int16 *)((char *)v33 + v27);
        }
        while (v30 != height);
      }
      goto LABEL_46;
    }
    PixelBufferUtils::pixelFormatAsString(v5, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1264, v5, p_p);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 4294967294;
  }
  else
  {
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      uint64_t v16 = &__p;
    }
    else {
      uint64_t v16 = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1258, PixelFormatType, v16);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_215FABCBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t convert4ChannelToPlanar<float,half>(__CVBuffer *a1, __CVBuffer *a2)
{
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  unint64_t v5 = CVPixelBufferGetPixelFormatType(a2);
  unint64_t v6 = PixelBufferUtils::planeCountForPixelFormat((PixelBufferUtils *)v5);
  if (PixelBufferUtils::componentsPerPixelForPixelFormat((PixelBufferUtils *)PixelFormatType, 0) == 4)
  {
    if (v6)
    {
      CVPixelBufferLockBaseAddress(a2, 0);
      CVPixelBufferLockBaseAddress(a1, 1uLL);
      uint64_t v7 = RGBA_FORMAT_MAP();
      LODWORD(__p.data) = v5;
      HIDWORD(__p.data) = PixelFormatType;
      unint64_t v8 = std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v7, (unint64_t)__p.data, &__p);
      CFAllocatorRef v9 = (unsigned __int8 *)v8[3];
      unsigned int v10 = *((_DWORD *)v8 + 8) - 1;
      float v11 = 1.0;
      if (v10 <= 6) {
        float v11 = flt_215FC546C[v10];
      }
      memset(&__p, 0, sizeof(__p));
      vImage_Error v12 = (CGRect *)MEMORY[0x263F001A8];
      PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &__p);
      __int16 v121 = 0;
      float v13 = (__CVBuffer *)*v9;
      if (v6 <= (unint64_t)v13)
      {
        size_t rowBytes = 0;
        data = &v121;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v13, *v12, &v120);
        data = (__int16 *)v120.data;
        size_t rowBytes = v120.rowBytes;
      }
      double v18 = (__CVBuffer *)v9[1];
      if (v6 <= (unint64_t)v18)
      {
        size_t v19 = 0;
        double v118 = &v121;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v18, *v12, &v120);
        double v118 = (__int16 *)v120.data;
        size_t v19 = v120.rowBytes;
      }
      size_t v20 = (__CVBuffer *)v9[2];
      if (v6 <= (unint64_t)v20)
      {
        size_t v22 = 0;
        size_t v21 = &v121;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v20, *v12, &v120);
        size_t v21 = (__int16 *)v120.data;
        size_t v22 = v120.rowBytes;
      }
      size_t v23 = (__CVBuffer *)v9[3];
      pixelBuffer = a2;
      if (v6 <= (unint64_t)v23)
      {
        size_t v25 = 0;
        size_t v24 = &v121;
        vImagePixelCount height = __p.height;
        if (!__p.height) {
          goto LABEL_66;
        }
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v23, *v12, &v120);
        size_t v24 = (__int16 *)v120.data;
        size_t v25 = v120.rowBytes;
        vImagePixelCount height = __p.height;
        if (!__p.height) {
          goto LABEL_66;
        }
      }
      vImagePixelCount width = __p.width;
      if (__p.width)
      {
        uint64_t v28 = 0;
        vImagePixelCount v29 = __p.width & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v31 = v118;
        uint64_t v30 = data;
        size_t v32 = data + 1;
        size_t v33 = (char *)__p.data;
        size_t v34 = __p.rowBytes;
        int v35 = (char *)__p.data + 16;
        vImagePixelCount v36 = (char *)__p.data + 20;
        int v37 = v118 + 1;
        vImage_Error v38 = (char *)__p.data + 24;
        vImagePixelCount v39 = v21 + 1;
        __int16 v40 = (char *)__p.data + 28;
        unsigned int v41 = v24 + 1;
        uint64_t v42 = v24;
        vImagePixelCount v43 = v21;
        while (1)
        {
          if ((__int16 *)((char *)data + rowBytes * v28) == &v121) {
            goto LABEL_41;
          }
          if (width == 1) {
            break;
          }
          vImagePixelCount v45 = (int *)v35;
          uint64_t v46 = v32;
          unint64_t v47 = width & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            _S0 = *(v45 - 4);
            int v49 = *v45;
            v45 += 8;
            _S1 = v49;
            __asm
            {
              FCVT            H0, S0
              FCVT            H1, S1
              FCVT            S0, H0
              FCVT            S1, H1
            }
            _S0 = v11 * _S0;
            _S1 = v11 * _S1;
            __asm
            {
              FCVT            H0, S0
              FCVT            H1, S1
            }
            *(v46 - 1) = LOWORD(_S0);
            *uint64_t v46 = LOWORD(_S1);
            v46 += 2;
            v47 -= 2;
          }
          while (v47);
          unint64_t v44 = width & 0xFFFFFFFFFFFFFFFELL;
          if (width != v29) {
            goto LABEL_39;
          }
LABEL_41:
          if ((__int16 *)((char *)v118 + v19 * v28) == &v121) {
            goto LABEL_49;
          }
          if (width == 1)
          {
            unint64_t v66 = 0;
LABEL_47:
            vImagePixelCount v77 = width - v66;
            unint64_t v78 = &v31[v66];
            uint64_t v79 = (16 * v66) | 4;
            do
            {
              _S0 = *(_DWORD *)&v33[v79];
              __asm
              {
                FCVT            H0, S0
                FCVT            S0, H0
              }
              _S0 = v11 * _S0;
              __asm { FCVT            H0, S0 }
              *v78++ = LOWORD(_S0);
              v79 += 16;
              --v77;
            }
            while (v77);
            goto LABEL_49;
          }
          vImage_Buffer v67 = v37;
          __int16 v68 = (int *)v36;
          unint64_t v69 = width & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            _S0 = *(v68 - 4);
            int v71 = *v68;
            v68 += 8;
            _S1 = v71;
            __asm
            {
              FCVT            H0, S0
              FCVT            H1, S1
              FCVT            S0, H0
              FCVT            S1, H1
            }
            _S0 = v11 * _S0;
            _S1 = v11 * _S1;
            __asm
            {
              FCVT            H0, S0
              FCVT            H1, S1
            }
            *(v67 - 1) = LOWORD(_S0);
            *vImage_Buffer v67 = LOWORD(_S1);
            v67 += 2;
            v69 -= 2;
          }
          while (v69);
          unint64_t v66 = width & 0xFFFFFFFFFFFFFFFELL;
          if (width != v29) {
            goto LABEL_47;
          }
LABEL_49:
          if ((__int16 *)((char *)v21 + v22 * v28) == &v121) {
            goto LABEL_57;
          }
          if (width == 1)
          {
            unint64_t v83 = 0;
LABEL_55:
            vImagePixelCount v94 = width - v83;
            vImagePixelCount v95 = &v43[v83];
            uint64_t v96 = (16 * v83) | 8;
            do
            {
              _S0 = *(_DWORD *)&v33[v96];
              __asm
              {
                FCVT            H0, S0
                FCVT            S0, H0
              }
              _S0 = v11 * _S0;
              __asm { FCVT            H0, S0 }
              *v95++ = LOWORD(_S0);
              v96 += 16;
              --v94;
            }
            while (v94);
            goto LABEL_57;
          }
          uint64_t v84 = v39;
          float16x8_t v85 = (int *)v38;
          unint64_t v86 = width & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            _S0 = *(v85 - 4);
            int v88 = *v85;
            v85 += 8;
            _S1 = v88;
            __asm
            {
              FCVT            H0, S0
              FCVT            H1, S1
              FCVT            S0, H0
              FCVT            S1, H1
            }
            _S0 = v11 * _S0;
            _S1 = v11 * _S1;
            __asm
            {
              FCVT            H0, S0
              FCVT            H1, S1
            }
            *(v84 - 1) = LOWORD(_S0);
            _WORD *v84 = LOWORD(_S1);
            v84 += 2;
            v86 -= 2;
          }
          while (v86);
          unint64_t v83 = width & 0xFFFFFFFFFFFFFFFELL;
          if (width != v29) {
            goto LABEL_55;
          }
LABEL_57:
          if ((__int16 *)((char *)v24 + v25 * v28) != &v121)
          {
            if (width == 1)
            {
              unint64_t v100 = 0;
            }
            else
            {
              CGRect v101 = v41;
              vImage_Buffer v102 = (int *)v40;
              unint64_t v103 = width & 0xFFFFFFFFFFFFFFFELL;
              do
              {
                _S0 = *(v102 - 4);
                int v105 = *v102;
                v102 += 8;
                _S1 = v105;
                __asm
                {
                  FCVT            H0, S0
                  FCVT            H1, S1
                  FCVT            S0, H0
                  FCVT            S1, H1
                }
                _S0 = v11 * _S0;
                _S1 = v11 * _S1;
                __asm
                {
                  FCVT            H0, S0
                  FCVT            H1, S1
                }
                *(v101 - 1) = LOWORD(_S0);
                _WORD *v101 = LOWORD(_S1);
                v101 += 2;
                v103 -= 2;
              }
              while (v103);
              unint64_t v100 = width & 0xFFFFFFFFFFFFFFFELL;
              if (width == v29) {
                goto LABEL_32;
              }
            }
            vImagePixelCount v111 = width - v100;
            double v112 = &v42[v100];
            uint64_t v113 = (16 * v100) | 0xC;
            do
            {
              _S0 = *(_DWORD *)&v33[v113];
              __asm
              {
                FCVT            H0, S0
                FCVT            S0, H0
              }
              _S0 = v11 * _S0;
              __asm { FCVT            H0, S0 }
              *v112++ = LOWORD(_S0);
              v113 += 16;
              --v111;
            }
            while (v111);
          }
LABEL_32:
          ++v28;
          size_t v32 = (_WORD *)((char *)v32 + rowBytes);
          v35 += v34;
          uint64_t v30 = (__int16 *)((char *)v30 + rowBytes);
          v33 += v34;
          v36 += v34;
          int v37 = (_WORD *)((char *)v37 + v19);
          uint64_t v31 = (__int16 *)((char *)v31 + v19);
          v38 += v34;
          vImagePixelCount v39 = (_WORD *)((char *)v39 + v22);
          vImagePixelCount v43 = (__int16 *)((char *)v43 + v22);
          v40 += v34;
          unsigned int v41 = (_WORD *)((char *)v41 + v25);
          uint64_t v42 = (__int16 *)((char *)v42 + v25);
          if (v28 == height) {
            goto LABEL_66;
          }
        }
        unint64_t v44 = 0;
LABEL_39:
        vImagePixelCount v59 = width - v44;
        uint64_t v60 = &v30[v44];
        uint64_t v61 = &v33[16 * v44];
        do
        {
          int v62 = *(_DWORD *)v61;
          v61 += 16;
          _S0 = v62;
          __asm
          {
            FCVT            H0, S0
            FCVT            S0, H0
          }
          _S0 = v11 * _S0;
          __asm { FCVT            H0, S0 }
          *v60++ = LOWORD(_S0);
          --v59;
        }
        while (v59);
        goto LABEL_41;
      }
LABEL_66:
      CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
      CVPixelBufferUnlockBaseAddress(a1, 1uLL);
      return 0;
    }
    PixelBufferUtils::pixelFormatAsString(v5, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1264, v5, p_p);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 4294967294;
  }
  else
  {
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      double v15 = &__p;
    }
    else {
      double v15 = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1258, PixelFormatType, v15);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_215FAC2E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t convert4ChannelToPlanar<unsigned char,half>(__CVBuffer *a1, __CVBuffer *a2)
{
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  unint64_t v5 = CVPixelBufferGetPixelFormatType(a2);
  unint64_t v6 = PixelBufferUtils::planeCountForPixelFormat((PixelBufferUtils *)v5);
  if (PixelBufferUtils::componentsPerPixelForPixelFormat((PixelBufferUtils *)PixelFormatType, 0) == 4)
  {
    if (v6)
    {
      CVPixelBufferLockBaseAddress(a2, 0);
      CVPixelBufferLockBaseAddress(a1, 1uLL);
      uint64_t v7 = RGBA_FORMAT_MAP();
      LODWORD(__p.data) = v5;
      HIDWORD(__p.data) = PixelFormatType;
      unint64_t v8 = std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v7, (unint64_t)__p.data, &__p);
      CFAllocatorRef v9 = (unsigned __int8 *)v8[3];
      unsigned int v10 = *((_DWORD *)v8 + 8) - 1;
      float v11 = 1.0;
      if (v10 <= 6) {
        float v11 = flt_215FC546C[v10];
      }
      memset(&__p, 0, sizeof(__p));
      vImage_Error v12 = (CGRect *)MEMORY[0x263F001A8];
      PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &__p);
      _S0 = 0.0;
      __int16 v57 = 0;
      double v14 = (__CVBuffer *)*v9;
      if (v6 <= (unint64_t)v14)
      {
        size_t rowBytes = 0;
        data = &v57;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v14, *v12, &v56);
        data = (__int16 *)v56.data;
        size_t rowBytes = v56.rowBytes;
      }
      pixelBuffer = a1;
      size_t v20 = (__CVBuffer *)v9[1];
      if (v6 <= (unint64_t)v20)
      {
        size_t v22 = 0;
        size_t v21 = &v57;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v20, *v12, &v56);
        size_t v21 = (__int16 *)v56.data;
        size_t v22 = v56.rowBytes;
      }
      size_t v23 = (__CVBuffer *)v9[2];
      if (v6 <= (unint64_t)v23)
      {
        size_t v25 = 0;
        size_t v24 = &v57;
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v23, *v12, &v56);
        size_t v24 = (__int16 *)v56.data;
        size_t v25 = v56.rowBytes;
      }
      size_t v26 = (__CVBuffer *)v9[3];
      if (v6 <= (unint64_t)v26)
      {
        size_t v28 = 0;
        size_t v27 = &v57;
        vImagePixelCount height = __p.height;
        if (!__p.height)
        {
LABEL_46:
          CVPixelBufferUnlockBaseAddress(a2, 0);
          CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
          return 0;
        }
      }
      else
      {
        PixelBufferUtils::asVImageBuffer(a2, v26, *v12, &v56);
        size_t v27 = (__int16 *)v56.data;
        size_t v28 = v56.rowBytes;
        vImagePixelCount height = __p.height;
        if (!__p.height) {
          goto LABEL_46;
        }
      }
      vImagePixelCount width = __p.width;
      if (__p.width)
      {
        uint64_t v31 = 0;
        size_t v32 = (unsigned __int8 *)__p.data;
        size_t v33 = __p.rowBytes;
        size_t v34 = v27;
        int v35 = v24;
        vImagePixelCount v36 = v21;
        int v37 = data;
        do
        {
          if ((__int16 *)((char *)data + rowBytes * v31) != &v57)
          {
            vImage_Error v38 = v32;
            vImagePixelCount v39 = v37;
            vImagePixelCount v40 = width;
            do
            {
              unsigned int v41 = *v38;
              v38 += 4;
              _S0 = v11 * (float)v41;
              __asm { FCVT            H0, S0 }
              *v39++ = LOWORD(_S0);
              --v40;
            }
            while (v40);
          }
          if ((__int16 *)((char *)v21 + v22 * v31) != &v57)
          {
            uint64_t v46 = 1;
            unint64_t v47 = v36;
            vImagePixelCount v48 = width;
            do
            {
              LOBYTE(_S0) = v32[v46];
              _S0 = v11 * (float)LODWORD(_S0);
              __asm { FCVT            H0, S0 }
              *v47++ = LOWORD(_S0);
              v46 += 4;
              --v48;
            }
            while (v48);
          }
          if ((__int16 *)((char *)v24 + v25 * v31) != &v57)
          {
            uint64_t v49 = 2;
            vImagePixelCount v50 = v35;
            vImagePixelCount v51 = width;
            do
            {
              LOBYTE(_S0) = v32[v49];
              _S0 = v11 * (float)LODWORD(_S0);
              __asm { FCVT            H0, S0 }
              *v50++ = LOWORD(_S0);
              v49 += 4;
              --v51;
            }
            while (v51);
          }
          if ((__int16 *)((char *)v27 + v28 * v31) != &v57)
          {
            uint64_t v52 = 3;
            vImagePixelCount v53 = v34;
            vImagePixelCount v54 = width;
            do
            {
              LOBYTE(_S0) = v32[v52];
              _S0 = v11 * (float)LODWORD(_S0);
              __asm { FCVT            H0, S0 }
              *v53++ = LOWORD(_S0);
              v52 += 4;
              --v54;
            }
            while (v54);
          }
          ++v31;
          int v37 = (__int16 *)((char *)v37 + rowBytes);
          v32 += v33;
          vImagePixelCount v36 = (__int16 *)((char *)v36 + v22);
          int v35 = (__int16 *)((char *)v35 + v25);
          size_t v34 = (__int16 *)((char *)v34 + v28);
        }
        while (v31 != height);
      }
      goto LABEL_46;
    }
    PixelBufferUtils::pixelFormatAsString(v5, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1264, v5, p_p);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 4294967294;
  }
  else
  {
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&__p);
    if ((__p.width & 0x8000000000000000) == 0) {
      vImage_YpCbCrPixelRange v17 = &__p;
    }
    else {
      vImage_YpCbCrPixelRange v17 = (vImage_Buffer *)__p.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convert4ChannelToPlanar", 1258, PixelFormatType, v17);
    if (SHIBYTE(__p.width) < 0) {
      operator delete(__p.data);
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_215FAC6E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t convertColorToGrayscale(__CVBuffer *a1, __CVBuffer *a2)
{
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  pixelBufferOut.data = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v6, Width, Height, 0x34323066u, BufferAttributes, (CVPixelBufferRef *)&pixelBufferOut)) {
    data = 0;
  }
  else {
    data = (__CVBuffer *)pixelBufferOut.data;
  }
  if (!PixelBufferUtils::convertPixelBufferFormat(a1, data, 0, v8))
  {
    if (!data) {
      return 0xFFFFFFFFLL;
    }
    CVPixelBufferLockBaseAddress(a2, 0);
    memset(&pixelBufferOut, 0, sizeof(pixelBufferOut));
    float v11 = (CGRect *)MEMORY[0x263F001A8];
    PixelBufferUtils::asVImageBuffer(a2, 0, *MEMORY[0x263F001A8], &pixelBufferOut);
    CVPixelBufferLockBaseAddress(data, 1uLL);
    memset(&src, 0, sizeof(src));
    PixelBufferUtils::asVImageBuffer(data, 0, *v11, &src);
    unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a2);
    unint64_t v13 = PixelFormatType;
    if ((int)PixelFormatType > 1278226535)
    {
      if (PixelFormatType != 1278226536 && PixelFormatType != 1647392359)
      {
LABEL_20:
        PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)__p);
        if (v18 >= 0) {
          uint64_t v16 = __p;
        }
        else {
          uint64_t v16 = (void **)__p[0];
        }
        NSLog(&cfstr_SDErrorPixelFo.isa, "convertColorToGrayscale", 2021, v13, v16);
        if (v18 < 0) {
          operator delete(__p[0]);
        }
        BOOL v10 = 1;
        goto LABEL_18;
      }
      vImage_Error v14 = vImageConvert_Planar8toPlanar16F(&src, &pixelBufferOut, 0);
    }
    else
    {
      if (PixelFormatType == 1278226488)
      {
        vImageCopyBuffer(&src, &pixelBufferOut, 1uLL, 0);
      }
      else if (PixelFormatType != 1278226534)
      {
        goto LABEL_20;
      }
      vImage_Error v14 = vImageConvert_Planar8toPlanarF(&src, &pixelBufferOut, 1.0, 0.0, 0);
    }
    BOOL v10 = v14 != 0;
LABEL_18:
    CVPixelBufferUnlockBaseAddress(data, 1uLL);
    CVPixelBufferUnlockBaseAddress(a2, 0);
    CVPixelBufferRelease(data);
    return v10;
  }
  CVPixelBufferRelease(data);
  return 0xFFFFFFFFLL;
}

void sub_215FAC940(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t convertRGBPlanarFloat(__CVBuffer *a1, __CVBuffer *a2)
{
  void minFloat[2] = *MEMORY[0x263EF8340];
  if (CVPixelBufferGetPixelFormatType(a1) != 1919365990) {
    return 0xFFFFFFFFLL;
  }
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 0);
  memset(&dest, 0, sizeof(dest));
  OSType v4 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a2, *MEMORY[0x263F001A8], &dest);
  memset(&blue, 0, sizeof(blue));
  PixelBufferUtils::asVImageBuffer(a1, 0, *v4, &blue);
  memset(&green, 0, sizeof(green));
  PixelBufferUtils::asVImageBuffer(a1, (__CVBuffer *)1, *v4, &green);
  memset(&red, 0, sizeof(red));
  PixelBufferUtils::asVImageBuffer(a1, (__CVBuffer *)2, *v4, &red);
  minFloat[0] = 0;
  minFloat[1] = 0;
  long long maxFloat = xmmword_215FC4720;
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a2);
  unint64_t v6 = PixelFormatType;
  if ((int)PixelFormatType <= 1111970368)
  {
    if (PixelFormatType == 32)
    {
      vImage_Error v7 = vImageConvert_PlanarFToXRGB8888(0xFFu, &blue, &green, &red, &dest, (const float *)&maxFloat, (const float *)minFloat, 0);
      goto LABEL_14;
    }
    if (PixelFormatType == 1094862674)
    {
      vImage_Error v7 = vImageConvert_PlanarFToXRGB8888(0xFFu, &red, &green, &blue, &dest, (const float *)&maxFloat, (const float *)minFloat, 0);
      goto LABEL_14;
    }
LABEL_19:
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)__p);
    if (v12 >= 0) {
      BOOL v10 = __p;
    }
    else {
      BOOL v10 = (void **)__p[0];
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convertRGBPlanarFloat", 1889, v6, v10);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v9 = -21783;
    goto LABEL_15;
  }
  if (PixelFormatType == 1111970369)
  {
    vImage_Error v7 = vImageConvert_PlanarFToBGRX8888(&red, &green, &blue, 0xFFu, &dest, (const float *)&maxFloat, (const float *)minFloat, 0);
    goto LABEL_14;
  }
  if (PixelFormatType == 1380401729)
  {
    vImage_Error v7 = vImageConvert_PlanarFToBGRX8888(&blue, &green, &red, 0xFFu, &dest, (const float *)&maxFloat, (const float *)minFloat, 0);
    goto LABEL_14;
  }
  if (PixelFormatType != 1380410945) {
    goto LABEL_19;
  }
  vImage_Error v7 = vImageConvert_PlanarFToBGRXFFFF(&blue, &green, &red, 1.0, &dest, 0);
LABEL_14:
  uint64_t v9 = v7;
LABEL_15:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  if (v9) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

void sub_215FACC34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t convertRGBPlanarHalf(__CVBuffer *a1, __CVBuffer *a2)
{
  if (CVPixelBufferGetPixelFormatType(a1) != 1919365992) {
    return 0xFFFFFFFFLL;
  }
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v6, Width, Height, 0x72673366u, BufferAttributes, &pixelBufferOut)) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = pixelBufferOut;
  }
  uint64_t v9 = convertFloat16ToFloat32(a1, v8);
  if (!v9) {
    uint64_t v9 = convertRGBPlanarFloat(v8, a2);
  }
  CVPixelBufferRelease(v8);
  return v9;
}

uint64_t createBGRAPermutesFromYUV(CVPixelBufferRef pixelBuffer, int a2, CVPixelBufferRef a3)
{
  BOOL v6 = a2 == 1380411457 || a2 == 1380410945;
  data = a3;
  unsigned int v8 = a2;
  if (v6)
  {
    unsigned int v8 = 1111970369;
    size_t Width = CVPixelBufferGetWidth(a3);
    size_t Height = CVPixelBufferGetHeight(a3);
    pixelBufferOut.data = 0;
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
    if (CVPixelBufferCreate(v11, Width, Height, 0x42475241u, BufferAttributes, (CVPixelBufferRef *)&pixelBufferOut)) {
      data = 0;
    }
    else {
      data = (__CVBuffer *)pixelBufferOut.data;
    }
  }
  CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
  CVPixelBufferLockBaseAddress(data, 0);
  memset(&pixelBufferOut, 0, sizeof(pixelBufferOut));
  unint64_t v13 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(pixelBuffer, 0, *MEMORY[0x263F001A8], &pixelBufferOut);
  memset(&srcCbCr, 0, sizeof(srcCbCr));
  PixelBufferUtils::asVImageBuffer(pixelBuffer, (__CVBuffer *)1, *v13, &srcCbCr);
  memset(&dest, 0, sizeof(dest));
  PixelBufferUtils::asVImageBuffer(data, *v13, &dest);
  uint64_t v14 = RGBA_FORMAT_MAP();
  *(void *)&v18.Yp_bias = v8 | 0x2000000000;
  double v15 = (const uint8_t *)std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v14, *(unint64_t *)&v18.Yp_bias, &v18)[3];
  if ((createBGRAPermutesFromYUV(__CVBuffer *,unsigned int,__CVBuffer *)::isConvesionInfoDefined & 1) != 0
    || (vImage_YpCbCrPixelRange v18 = *(vImage_YpCbCrPixelRange *)ymmword_215FC544C,
        vImage_Error v16 = vImageConvert_YpCbCrToARGB_GenerateConversion((const vImage_YpCbCrToARGBMatrix *)*MEMORY[0x263EFAA28], &v18, &createBGRAPermutesFromYUV(__CVBuffer *,unsigned int,__CVBuffer *)::conversionInfo, kvImage420Yp8_CbCr8, kvImageARGB8888, 0), createBGRAPermutesFromYUV(__CVBuffer *,unsigned int,__CVBuffer *)::isConvesionInfoDefined = 1, !v16))
  {
    vImage_Error v16 = vImageConvert_420Yp8_CbCr8ToARGB8888(&pixelBufferOut, &srcCbCr, &dest, &createBGRAPermutesFromYUV(__CVBuffer *,unsigned int,__CVBuffer *)::conversionInfo, v15, 0xFFu, 0);
  }
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
  CVPixelBufferUnlockBaseAddress(data, 0);
  if (a2 == 1380411457 || a2 == 1380410945)
  {
    vImage_Error v16 = (int)convert4ChannelFormats(data, a2, a3);
    CVPixelBufferRelease(data);
  }
  if (v16) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t createRGBPlanarFloatFromBuffer(__CVBuffer *a1, __CVBuffer *a2)
{
  size_t Width = CVPixelBufferGetWidth(a1);
  size_t Height = CVPixelBufferGetHeight(a1);
  pixelBufferOut.data = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v6, Width, Height, 0x52476641u, BufferAttributes, (CVPixelBufferRef *)&pixelBufferOut)) {
    data = 0;
  }
  else {
    data = (__CVBuffer *)pixelBufferOut.data;
  }
  if (PixelBufferUtils::convertPixelBufferFormat(a1, data, 0, v8))
  {
    CVPixelBufferRelease(data);
    return 0xFFFFFFFFLL;
  }
  if (!data) {
    return 0xFFFFFFFFLL;
  }
  CVPixelBufferLockBaseAddress(data, 1uLL);
  CVPixelBufferLockBaseAddress(a2, 0);
  memset(&pixelBufferOut, 0, sizeof(pixelBufferOut));
  CFAllocatorRef v11 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(data, *MEMORY[0x263F001A8], &pixelBufferOut);
  memset(&destA, 0, sizeof(destA));
  PixelBufferUtils::asVImageBuffer(a2, 0, *v11, &destA);
  memset(&destR, 0, sizeof(destR));
  PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, *v11, &destR);
  memset(&destG, 0, sizeof(destG));
  PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)2, *v11, &destG);
  vImage_Error v12 = MEMORY[0x2166C65B0](&v13, pixelBufferOut.height, pixelBufferOut.width, 32, 0);
  if (!v12)
  {
    vImage_Error v12 = vImageConvert_ARGBFFFFtoPlanarF(&pixelBufferOut, &destA, &destR, &destG, &v13, 0);
    free(v13.data);
  }
  CVPixelBufferUnlockBaseAddress(data, 1uLL);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  CVPixelBufferRelease(data);
  if (v12) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t createRGBPlanarHalfFromBuffer(__CVBuffer *a1, CVPixelBufferRef pixelBuffer)
{
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  size_t Height = CVPixelBufferGetHeight(pixelBuffer);
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v6, Width, Height, 0x72673366u, BufferAttributes, &pixelBufferOut)) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = pixelBufferOut;
  }
  if (createRGBPlanarFloatFromBuffer(a1, v8)) {
    uint64_t v9 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v9 = convertFloat32ToFloat16(v8, pixelBuffer);
  }
  CVPixelBufferRelease(v8);
  return v9;
}

uint64_t copyPixelBufferMultiPlane(__CVBuffer *a1, CGPoint a2, __CVBuffer *a3, CGRect a4)
{
  double height = a4.size.height;
  double width = a4.size.width;
  double y = a4.origin.y;
  double x = a4.origin.x;
  double v9 = a2.y;
  double v10 = a2.x;
  size_t PlaneCount = CVPixelBufferGetPlaneCount(a3);
  unint64_t PixelFormatType = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(a3);
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a3, 1uLL);
  if (!PlaneCount)
  {
LABEL_27:
    CVPixelBufferUnlockBaseAddress(a1, 0);
    CVPixelBufferUnlockBaseAddress(a3, 1uLL);
    return 0;
  }
  uint64_t v14 = 0;
  double v15 = (CGRect *)MEMORY[0x263F001A8];
  while (1)
  {
    size_t v16 = PixelBufferUtils::pixelSizeForPixelFormat(PixelFormatType, (uint64_t)v14);
    memset(&src, 0, sizeof(src));
    PixelBufferUtils::asVImageBuffer(a3, v14, *v15, &src);
    memset(&dest, 0, sizeof(dest));
    PixelBufferUtils::asVImageBuffer(a1, v14, *v15, &dest);
    v29.origin.double x = x;
    v29.origin.double y = y;
    v29.size.double width = width;
    v29.size.double height = height;
    IsEmptdouble y = CGRectIsEmpty(v29);
    vImagePixelCount v18 = src.width;
    if (IsEmpty)
    {
      vImagePixelCount v19 = src.height;
      goto LABEL_16;
    }
    if (x >= (double)src.width) {
      break;
    }
    BOOL v20 = y < (double)src.height && width <= (double)src.width;
    if (!v20 || height > (double)src.height) {
      break;
    }
    src.double height = (unint64_t)height;
    src.double width = (unint64_t)width;
    src.data = (char *)src.data + src.rowBytes * (unint64_t)y + v16 * (unint64_t)x;
    vImagePixelCount v19 = (unint64_t)height;
    vImagePixelCount v18 = (unint64_t)width;
LABEL_16:
    double v22 = (double)v18;
    double v23 = (double)v19;
    v30.origin.double x = v10;
    v30.origin.double y = v9;
    v30.size.double width = (double)v18;
    v30.size.double height = (double)v19;
    if (!CGRectIsEmpty(v30))
    {
      if (v10 >= (double)dest.width) {
        break;
      }
      BOOL v24 = v9 < (double)dest.height && v22 <= (double)dest.width;
      if (!v24 || v23 > (double)dest.height) {
        break;
      }
      dest.data = (char *)dest.data + dest.rowBytes * (unint64_t)v9 + v16 * (unint64_t)v10;
      dest.double height = (unint64_t)v23;
      dest.double width = (unint64_t)v22;
    }
    vImageCopyBuffer(&src, &dest, v16, 0);
    uint64_t v14 = (__CVBuffer *)((char *)v14 + 1);
    if ((__CVBuffer *)PlaneCount == v14) {
      goto LABEL_27;
    }
  }
  NSLog(&cfstr_SDErrorRegionI.isa, "updateVImageBufferToRegion", 1923);
  return 0xFFFFFFFFLL;
}

uint64_t convertFloat32ToFloat16(__CVBuffer *a1, __CVBuffer *a2)
{
  unint64_t PixelFormatType = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(a1);
  unint64_t v5 = PixelBufferUtils::planeCountForPixelFormat(PixelFormatType);
  CFAllocatorRef v6 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(a2);
  if (v5 == PixelBufferUtils::planeCountForPixelFormat(v6))
  {
    CVPixelBufferLockBaseAddress(a1, 1uLL);
    CVPixelBufferLockBaseAddress(a2, 0);
    if (v5)
    {
      unint64_t v7 = 1;
      BOOL v8 = (CGRect *)MEMORY[0x263F001A8];
      do
      {
        memset(&src, 0, sizeof(src));
        PixelBufferUtils::asVImageBuffer(a1, (__CVBuffer *)(v7 - 1), *v8, &src);
        memset(&dest, 0, sizeof(dest));
        PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)(v7 - 1), *v8, &dest);
        vImage_Error v9 = vImageConvert_PlanarFtoPlanar16F(&src, &dest, 0);
        vImage_Error v10 = v9;
        if (v7 >= v5) {
          break;
        }
        ++v7;
      }
      while (!v9);
    }
    else
    {
      memset(&src, 0, sizeof(src));
      vImage_Error v12 = (CGRect *)MEMORY[0x263F001A8];
      PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &src);
      memset(&dest, 0, sizeof(dest));
      PixelBufferUtils::asVImageBuffer(a2, *v12, &dest);
      vImage_Error v10 = vImageConvert_PlanarFtoPlanar16F(&src, &dest, 0);
    }
    CVPixelBufferUnlockBaseAddress(a1, 1uLL);
    CVPixelBufferUnlockBaseAddress(a2, 0);
    return v10 != 0;
  }
  else
  {
    NSLog(&cfstr_SDErrorInputAn.isa, "convertFloat32ToFloat16", 1592);
    return 0xFFFFFFFFLL;
  }
}

void PixelBufferUtils::forEveryPixel(__CVBuffer *a1, void *a2, int a3)
{
  vImagePixelCount v18 = a2;
  unint64_t PixelFormatType = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(a1);
  unint64_t v6 = PixelBufferUtils::pixelSizeForPixelFormat(PixelFormatType, a3);
  size_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount)
  {
    uint64_t v8 = 3516;
    vImage_Error v9 = @"%s:%d - ERROR - multiplane pixel buffer with nonmatching plane index";
    if (a3 < 0 || PlaneCount <= a3) {
      goto LABEL_7;
    }
  }
  else if (a3 != -1)
  {
    uint64_t v8 = 3521;
    vImage_Error v9 = @"%s:%d - ERROR - cannot request plane for single-plane image";
LABEL_7:
    NSLog(&v9->isa, "forEveryPixel", v8);
    goto LABEL_18;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  pixelBuffer = a1;
  if (PlaneCount) {
    PixelBufferUtils::asVImageBuffer(a1, (__CVBuffer *)a3, *MEMORY[0x263F001A8], &v19);
  }
  else {
    PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v19);
  }
  data = (char *)v19.data;
  vImagePixelCount height = v19.height;
  vImagePixelCount width = v19.width;
  size_t rowBytes = v19.rowBytes;
  if (v19.height && v19.width)
  {
    uint64_t v14 = 0;
    do
    {
      double v15 = data;
      vImagePixelCount v16 = width;
      do
      {
        ((void (**)(id, char *, PixelBufferUtils *))v18)[2](v18, v15, PixelFormatType);
        v15 += v6;
        --v16;
      }
      while (v16);
      ++v14;
      data += rowBytes;
    }
    while (v14 != height);
  }
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
LABEL_18:
}

void sub_215FAD788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void PixelBufferUtils::forEveryPixel(__CVBuffer *a1, __CVBuffer *a2, void *a3, vImagePixelCount a4)
{
  uint64_t v31 = a3;
  unint64_t PixelFormatType = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(a1);
  vImage_Error v9 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(a2);
  unint64_t v10 = PixelBufferUtils::pixelSizeForPixelFormat(PixelFormatType, 0);
  unint64_t v11 = PixelBufferUtils::pixelSizeForPixelFormat(v9, 0);
  size_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  if (PlaneCount != CVPixelBufferGetPlaneCount(a2))
  {
    uint64_t v13 = 3556;
    uint64_t v14 = @"%s:%d - ERROR - mismatching planes number in input buffers";
LABEL_7:
    NSLog(&v14->isa, "forEveryPixel", v13);
    goto LABEL_30;
  }
  if (PlaneCount)
  {
    uint64_t v13 = 3561;
    uint64_t v14 = @"%s:%d - ERROR - multiplane pixel buffers with nonmatching plane index";
    if ((a4 & 0x80000000) != 0 || PlaneCount <= a4) {
      goto LABEL_7;
    }
  }
  else if (a4 != -1)
  {
    NSLog(&cfstr_SDErrorCannotR_0.isa, "forEveryPixel", 3566);
    goto LABEL_30;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  if (PlaneCount)
  {
    if ((a4 & 0x80000000) != 0) {
      goto LABEL_17;
    }
    double v15 = (CGRect *)MEMORY[0x263F001A8];
    PixelBufferUtils::asVImageBuffer(a1, (__CVBuffer *)a4, *MEMORY[0x263F001A8], &v32);
    vImagePixelCount height = v32.height;
    data = (char *)v32.data;
    size_t rowBytes = v32.rowBytes;
    vImagePixelCount width = v32.width;
    PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)a4, *v15, &v32);
  }
  else
  {
    vImagePixelCount v16 = (CGRect *)MEMORY[0x263F001A8];
    PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &v32);
    vImagePixelCount height = v32.height;
    data = (char *)v32.data;
    size_t rowBytes = v32.rowBytes;
    vImagePixelCount width = v32.width;
    PixelBufferUtils::asVImageBuffer(a2, *v16, &v32);
  }
  OSType v4 = (char *)v32.data;
  a4 = v32.height;
  size_t PlaneCount = v32.width;
  size_t v25 = v32.rowBytes;
  if (height != v32.height || width != v32.width)
  {
LABEL_17:
    NSLog(&cfstr_WarningSizesIn.isa);
    if (height >= a4) {
      vImagePixelCount v17 = a4;
    }
    else {
      vImagePixelCount v17 = height;
    }
    vImagePixelCount v18 = width;
    if (width >= PlaneCount) {
      vImagePixelCount v18 = PlaneCount;
    }
    vImagePixelCount width = v18;
    vImagePixelCount height = v17;
  }
  pixelBuffer = a1;
  BOOL v24 = a2;
  vImage_Buffer v19 = data;
  if (height && width)
  {
    for (uint64_t i = 0; i != height; ++i)
    {
      CGRect v30 = v19;
      size_t v21 = v4;
      vImagePixelCount v22 = width;
      do
      {
        v31[2](v31, v19, PixelFormatType, v21, v9);
        v21 += v11;
        v19 += v10;
        --v22;
      }
      while (v22);
      v4 += v25;
      vImage_Buffer v19 = &v30[rowBytes];
    }
  }
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
  CVPixelBufferUnlockBaseAddress(v24, 0);
LABEL_30:
}

void sub_215FADA74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
  _Unwind_Resume(a1);
}

uint64_t convertGrayscaleAsColor(__CVBuffer *a1, unint64_t a2, __CVBuffer *a3)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  if ((int)a2 > 1380401728)
  {
    if (a2 != 1380401729 && a2 != 1380410945 && a2 != 1380411457)
    {
LABEL_37:
      PixelBufferUtils::pixelFormatAsString(a2, (char *)&red);
      if ((red.width & 0x8000000000000000) == 0) {
        p_vImage_Buffer red = &red;
      }
      else {
        p_vImage_Buffer red = red.data;
      }
      NSLog(&cfstr_SDErrorPixelFo.isa, "convertGrayscaleAsColor", 1468, a2, p_red);
      if ((SHIBYTE(red.width) & 0x80000000) == 0) {
        return 0xFFFFFFFFLL;
      }
      data = red.data;
LABEL_62:
      operator delete(data);
      return 0xFFFFFFFFLL;
    }
  }
  else if (a2 != 32 && a2 != 1094862674 && a2 != 1111970369)
  {
    goto LABEL_37;
  }
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  CVPixelBufferLockBaseAddress(a3, 0);
  memset(&red, 0, sizeof(red));
  unint64_t v7 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &red);
  memset(&dest, 0, sizeof(dest));
  PixelBufferUtils::asVImageBuffer(a3, *v7, &dest);
  uint64_t v8 = RGBA_FORMAT_MAP();
  pixelBufferOut.data = (void *)(a2 | 0x2000000000);
  vImage_Error v9 = 0;
  char v10 = 0;
  unint64_t v11 = (unsigned char *)std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v8, (unint64_t)pixelBufferOut.data, &pixelBufferOut)[3];
  long long maxFloat = xmmword_215FC4720;
  minFloat[0] = 0;
  minFloat[1] = 0;
  if ((int)PixelFormatType <= 1717855599)
  {
    if (PixelFormatType == 1278226488)
    {
      if (a2 == 1380411457)
      {
        size_t Width = CVPixelBufferGetWidth(a3);
        size_t Height = CVPixelBufferGetHeight(a3);
        pixelBufferOut.data = 0;
        CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
        if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], Width, Height, 0x52476641u, BufferAttributes, (CVPixelBufferRef *)&pixelBufferOut))
        {
          vImage_Error v12 = 0;
        }
        else
        {
          vImage_Error v12 = (__CVBuffer *)pixelBufferOut.data;
        }
        CVPixelBufferLockBaseAddress(v12, 0);
        memset(&pixelBufferOut, 0, sizeof(pixelBufferOut));
        PixelBufferUtils::asVImageBuffer(v12, *v7, &pixelBufferOut);
        vImage_Error v13 = vImageConvert_Planar8ToBGRXFFFF(&red, &red, &red, 1.0, &pixelBufferOut, (const float *)&maxFloat, (const float *)minFloat, 0);
        if (!v13)
        {
          pixelBufferOut.width *= 4;
          vImage_Error v13 = vImageConvert_PlanarFtoPlanar16F(&pixelBufferOut, &dest, 0);
        }
        vImage_Error v9 = 0;
        goto LABEL_48;
      }
      if (a2 == 1380410945)
      {
        vImage_Error v25 = vImageConvert_Planar8ToXRGBFFFF(1.0, &red, &red, &red, &dest, (const float *)&maxFloat, (const float *)minFloat, 0);
      }
      else if (*v11 == 3)
      {
        vImage_Error v25 = vImageConvert_Planar8ToBGRX8888(&red, &red, &red, 0xFFu, &dest, 0);
      }
      else
      {
        if (*v11)
        {
          vImage_Error v9 = 0;
          goto LABEL_76;
        }
        vImage_Error v25 = vImageConvert_Planar8ToXRGB8888(0xFFu, &red, &red, &red, &dest, 0);
      }
      vImage_Error v13 = v25;
      vImage_Error v9 = 0;
      goto LABEL_47;
    }
    if (PixelFormatType == 1278226534)
    {
LABEL_26:
      if (a2 == 1380411457)
      {
        size_t v20 = CVPixelBufferGetWidth(a3);
        size_t v21 = CVPixelBufferGetHeight(a3);
        pixelBufferOut.data = 0;
        CFDictionaryRef v22 = (const __CFDictionary *)getBufferAttributes();
        if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v20, v21, 0x52476641u, v22, (CVPixelBufferRef *)&pixelBufferOut))
        {
          vImage_Error v12 = 0;
        }
        else
        {
          vImage_Error v12 = (__CVBuffer *)pixelBufferOut.data;
        }
        CVPixelBufferLockBaseAddress(v12, 0);
        memset(&pixelBufferOut, 0, sizeof(pixelBufferOut));
        PixelBufferUtils::asVImageBuffer(v12, *v7, &pixelBufferOut);
        vImage_Error v13 = vImageConvert_PlanarFToBGRXFFFF(&red, &red, &red, 1.0, &pixelBufferOut, 0);
        if (!v13)
        {
          pixelBufferOut.width *= 4;
          vImage_Error v13 = vImageConvert_PlanarFtoPlanar16F(&pixelBufferOut, &dest, 0);
        }
        goto LABEL_48;
      }
      if (a2 == 1380410945)
      {
        vImage_Error v19 = vImageConvert_PlanarFToBGRXFFFF(&red, &red, &red, 1.0, &dest, 0);
LABEL_46:
        vImage_Error v13 = v19;
LABEL_47:
        vImage_Error v12 = 0;
LABEL_48:
        char v10 = 1;
        goto LABEL_49;
      }
      if (*v11 == 3)
      {
        vImage_Error v19 = vImageConvert_PlanarFToBGRX8888(&red, &red, &red, 0xFFu, &dest, (const float *)&maxFloat, (const float *)minFloat, 0);
        goto LABEL_46;
      }
      if (!*v11)
      {
        vImage_Error v19 = vImageConvert_PlanarFToXRGB8888(0xFFu, &red, &red, &red, &dest, (const float *)&maxFloat, (const float *)minFloat, 0);
        goto LABEL_46;
      }
LABEL_76:
      vImage_Error v12 = 0;
      char v10 = 0;
      vImage_Error v13 = 0;
      goto LABEL_49;
    }
    int v14 = 1278226536;
    goto LABEL_19;
  }
  if ((int)PixelFormatType > 1751410031)
  {
    if (PixelFormatType == 1751411059)
    {
LABEL_20:
      size_t v15 = CVPixelBufferGetWidth(a1);
      size_t v16 = CVPixelBufferGetHeight(a1);
      pixelBufferOut.data = 0;
      CFDictionaryRef v17 = (const __CFDictionary *)getBufferAttributes();
      if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v15, v16, 0x4C303066u, v17, (CVPixelBufferRef *)&pixelBufferOut))
      {
        vImage_Error v9 = 0;
      }
      else
      {
        vImage_Error v9 = (__CVBuffer *)pixelBufferOut.data;
      }
      if (PixelBufferUtils::convertPixelBufferFormat(a1, v9, 0, v18))
      {
        CVPixelBufferRelease(v9);
        vImage_Error v9 = 0;
      }
      CVPixelBufferLockBaseAddress(v9, 1uLL);
      PixelBufferUtils::asVImageBuffer(v9, *v7, &red);
      goto LABEL_26;
    }
    int v14 = 1751410032;
LABEL_19:
    vImage_Error v12 = 0;
    vImage_Error v13 = 0;
    if (PixelFormatType != v14) {
      goto LABEL_49;
    }
    goto LABEL_20;
  }
  if (PixelFormatType == 1717855600) {
    goto LABEL_26;
  }
  vImage_Error v12 = 0;
  vImage_Error v13 = 0;
  if (PixelFormatType == 1717856627) {
    goto LABEL_26;
  }
LABEL_49:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  CVPixelBufferUnlockBaseAddress(a3, 0);
  if (v9)
  {
    CVPixelBufferUnlockBaseAddress(v9, 1uLL);
    CVPixelBufferRelease(v9);
  }
  if (v12)
  {
    CVPixelBufferUnlockBaseAddress(v12, 0);
    CVPixelBufferRelease(v12);
  }
  if ((v10 & 1) == 0)
  {
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&pixelBufferOut);
    if ((pixelBufferOut.width & 0x8000000000000000) == 0) {
      p_vImage_Buffer pixelBufferOut = &pixelBufferOut;
    }
    else {
      p_vImage_Buffer pixelBufferOut = (vImage_Buffer *)pixelBufferOut.data;
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "convertGrayscaleAsColor", 1580, PixelFormatType, p_pixelBufferOut);
    if ((SHIBYTE(pixelBufferOut.width) & 0x80000000) == 0) {
      return 0xFFFFFFFFLL;
    }
    data = pixelBufferOut.data;
    goto LABEL_62;
  }
  if (v13) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

void sub_215FAE154(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t convertFloat16ToFloat32(__CVBuffer *a1, __CVBuffer *a2)
{
  unint64_t PixelFormatType = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(a1);
  unint64_t v5 = PixelBufferUtils::planeCountForPixelFormat(PixelFormatType);
  unint64_t v6 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(a2);
  if (v5 == PixelBufferUtils::planeCountForPixelFormat(v6))
  {
    CVPixelBufferLockBaseAddress(a1, 1uLL);
    CVPixelBufferLockBaseAddress(a2, 0);
    if (v5)
    {
      unint64_t v7 = 1;
      uint64_t v8 = (CGRect *)MEMORY[0x263F001A8];
      do
      {
        memset(&src, 0, sizeof(src));
        PixelBufferUtils::asVImageBuffer(a1, (__CVBuffer *)(v7 - 1), *v8, &src);
        memset(&dest, 0, sizeof(dest));
        PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)(v7 - 1), *v8, &dest);
        vImage_Error v9 = vImageConvert_Planar16FtoPlanarF(&src, &dest, 0);
        vImage_Error v10 = v9;
        if (v7 >= v5) {
          break;
        }
        ++v7;
      }
      while (!v9);
    }
    else
    {
      memset(&src, 0, sizeof(src));
      vImage_Error v12 = (CGRect *)MEMORY[0x263F001A8];
      PixelBufferUtils::asVImageBuffer(a1, *MEMORY[0x263F001A8], &src);
      memset(&dest, 0, sizeof(dest));
      PixelBufferUtils::asVImageBuffer(a2, *v12, &dest);
      vImage_Error v10 = vImageConvert_Planar16FtoPlanarF(&src, &dest, 0);
    }
    CVPixelBufferUnlockBaseAddress(a1, 1uLL);
    CVPixelBufferUnlockBaseAddress(a2, 0);
    return v10 != 0;
  }
  else
  {
    NSLog(&cfstr_SDErrorInputAn.isa, "convertFloat16ToFloat32", 1626);
    return 0xFFFFFFFFLL;
  }
}

__int16 ___ZL23invertPixelBufferValuesIDhEiP10__CVBufferS1__block_invoke@<H0>(uint64_t a1@<X0>, short float *a2@<X1>, uint64_t a3@<X2>, short float *a4@<X3>)
{
  *(short float *)&__int16 result = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / *a2;
  *a4 = *(short float *)&result;
  return result;
}

float ___ZL23invertPixelBufferValuesIfEiP10__CVBuffer_block_invoke(uint64_t a1, float *a2)
{
  float result = 1.0 / *a2;
  *a2 = result;
  return result;
}

uint64_t RGBA_FORMAT_MAP(void)
{
  uint64_t v1 = *MEMORY[0x263EF8340];
  {
    operator new();
  }
  return RGBA_FORMAT_MAP(void)::result;
}

void sub_215FAE874(_Unwind_Exception *a1)
{
  MEMORY[0x2166C5D90](v1, 0x10A0C408EF24B1CLL);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    vImage_Error v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      vImage_Error v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            vImage_Error v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          vImage_Error v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  vImage_Error v10 = operator new(0x28uLL);
  *vImage_Error v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  *((_DWORD *)v10 + 8) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v22 = *(void *)a1;
  double v23 = *(void **)(*(void *)a1 + 8 * v5);
  if (v23)
  {
    *vImage_Error v10 = *v23;
LABEL_58:
    void *v23 = v10;
    goto LABEL_59;
  }
  *vImage_Error v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v5) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    double v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_215FAEB78(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (!a2)
  {
    BOOL v15 = *(void **)a1;
    *(void *)a1 = 0;
    if (v15) {
      operator delete(v15);
    }
    *(void *)(a1 + 8) = 0;
    return;
  }
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  OSType v4 = operator new(8 * a2);
  unint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = 0;
  *(void *)(a1 + 8) = a2;
  do
    *(void *)(*(void *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void **)(a1 + 16);
  if (v7)
  {
    unint64_t v9 = v7[1];
    unint64_t v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      uint64_t v11 = v9 & v10;
      *(void *)(*(void *)a1 + 8 * v11) = v8;
      while (1)
      {
        uint64_t v12 = (void *)*v7;
        if (!*v7) {
          break;
        }
        uint64_t v13 = v12[1] & v10;
        if (v13 == v11)
        {
          unint64_t v7 = (void *)*v7;
        }
        else if (*(void *)(*(void *)a1 + 8 * v13))
        {
          void *v7 = *v12;
          uint64_t v14 = 8 * v13;
          void *v12 = **(void **)(*(void *)a1 + v14);
          **(void **)(*(void *)a1 + v14) = v12;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v13) = v7;
          unint64_t v7 = v12;
          uint64_t v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2) {
      v9 %= a2;
    }
    *(void *)(*(void *)a1 + 8 * v9) = v8;
    unint64_t v16 = (void *)*v7;
    if (*v7)
    {
      do
      {
        unint64_t v18 = v16[1];
        if (v18 >= a2) {
          v18 %= a2;
        }
        if (v18 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v18))
          {
            *(void *)(*(void *)a1 + 8 * v18) = v7;
            goto LABEL_26;
          }
          void *v7 = *v16;
          uint64_t v17 = 8 * v18;
          *unint64_t v16 = **(void **)(*(void *)a1 + v17);
          **(void **)(*(void *)a1 + v17) = v16;
          unint64_t v16 = v7;
        }
        unint64_t v18 = v9;
LABEL_26:
        unint64_t v7 = v16;
        unint64_t v16 = (void *)*v16;
        unint64_t v9 = v18;
      }
      while (v16);
    }
  }
}

uint64_t std::unordered_map<unsigned long long,std::pair<unsigned char *,int>>::unordered_map(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    unint64_t v5 = a2;
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    uint64_t v8 = &a2[3 * a3];
    unint64_t v9 = (void *)(a1 + 16);
    do
    {
      unint64_t v10 = *v5;
      if (v7)
      {
        uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
        v11.i16[0] = vaddlv_u8(v11);
        if (v11.u32[0] > 1uLL)
        {
          unint64_t v3 = *v5;
          if (v10 >= v7) {
            unint64_t v3 = v10 % v7;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v10;
        }
        uint64_t v12 = *(void **)(*(void *)a1 + 8 * v3);
        if (v12)
        {
          uint64_t v13 = (void *)*v12;
          if (v13)
          {
            if (v11.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v15 = v13[1];
                if (v15 == v10)
                {
                  if (v13[2] == v10) {
                    goto LABEL_61;
                  }
                }
                else if ((v15 & (v7 - 1)) != v3)
                {
                  goto LABEL_23;
                }
                uint64_t v13 = (void *)*v13;
                if (!v13) {
                  goto LABEL_23;
                }
              }
            }
            do
            {
              unint64_t v14 = v13[1];
              if (v14 == v10)
              {
                if (v13[2] == v10) {
                  goto LABEL_61;
                }
              }
              else
              {
                if (v14 >= v7) {
                  v14 %= v7;
                }
                if (v14 != v3) {
                  break;
                }
              }
              uint64_t v13 = (void *)*v13;
            }
            while (v13);
          }
        }
      }
LABEL_23:
      unint64_t v16 = operator new(0x28uLL);
      *unint64_t v16 = 0;
      v16[1] = v10;
      long long v17 = *(_OWORD *)v5;
      void v16[4] = v5[2];
      *((_OWORD *)v16 + 1) = v17;
      float v18 = (float)(unint64_t)(v6 + 1);
      float v19 = *(float *)(a1 + 32);
      if (!v7 || (float)(v19 * (float)v7) < v18)
      {
        BOOL v20 = (v7 & (v7 - 1)) != 0;
        if (v7 < 3) {
          BOOL v20 = 1;
        }
        unint64_t v21 = v20 | (2 * v7);
        unint64_t v22 = vcvtps_u32_f32(v18 / v19);
        if (v21 <= v22) {
          size_t prime = v22;
        }
        else {
          size_t prime = v21;
        }
        if (prime == 1)
        {
          size_t prime = 2;
        }
        else if ((prime & (prime - 1)) != 0)
        {
          size_t prime = std::__next_prime(prime);
          unint64_t v7 = *(void *)(a1 + 8);
        }
        if (prime > v7) {
          goto LABEL_45;
        }
        if (prime < v7)
        {
          unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
          if (v7 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
          {
            unint64_t v24 = std::__next_prime(v24);
          }
          else
          {
            uint64_t v26 = 1 << -(char)__clz(v24 - 1);
            if (v24 >= 2) {
              unint64_t v24 = v26;
            }
          }
          if (prime <= v24) {
            size_t prime = v24;
          }
          if (prime < v7) {
LABEL_45:
          }
            std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned char *,int>>>>::__do_rehash<true>(a1, prime);
        }
        unint64_t v7 = *(void *)(a1 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v10 >= v7) {
            unint64_t v3 = v10 % v7;
          }
          else {
            unint64_t v3 = v10;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v10;
        }
      }
      uint64_t v27 = *(void *)a1;
      size_t v28 = *(void **)(*(void *)a1 + 8 * v3);
      if (v28)
      {
        *unint64_t v16 = *v28;
      }
      else
      {
        *unint64_t v16 = *v9;
        void *v9 = v16;
        *(void *)(v27 + 8 * v3) = v9;
        if (!*v16) {
          goto LABEL_60;
        }
        unint64_t v29 = *(void *)(*v16 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v29 >= v7) {
            v29 %= v7;
          }
        }
        else
        {
          v29 &= v7 - 1;
        }
        size_t v28 = (void *)(*(void *)a1 + 8 * v29);
      }
      *size_t v28 = v16;
LABEL_60:
      uint64_t v6 = *(void *)(a1 + 24) + 1;
      *(void *)(a1 + 24) = v6;
LABEL_61:
      v5 += 3;
    }
    while (v5 != v8);
  }
  return a1;
}

void sub_215FAF02C(_Unwind_Exception *a1)
{
  operator delete(v2);
  unint64_t v5 = *v3;
  if (*v3)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      unint64_t v5 = v6;
    }
    while (v6);
  }
  unint64_t v7 = *v1;
  void *v1 = 0;
  if (v7) {
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

float ___ZL23invertPixelBufferValuesIfEiP10__CVBufferS1__block_invoke(uint64_t a1, float *a2, uint64_t a3, float *a4)
{
  float result = 1.0 / *a2;
  *a4 = result;
  return result;
}

__int16 ___ZL23invertPixelBufferValuesIDhEiP10__CVBuffer_block_invoke@<H0>(uint64_t a1@<X0>, short float *a2@<X1>)
{
  *(short float *)&__int16 result = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) / *a2;
  *a2 = *(short float *)&result;
  return result;
}

uint64_t PixelBufferUtils::copyPixelBuffer(PixelBufferUtils *this, CVPixelBufferRef pixelBuffer, __CVBuffer *a3)
{
  int v3 = (int)a3;
  signed int PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  if (PixelFormatType != CVPixelBufferGetPixelFormatType(this)) {
    return 0xFFFFFFFFLL;
  }
  if (v3)
  {
    if (PixelFormatType <= 1751410031)
    {
      if (PixelFormatType > 1717855599)
      {
        if (PixelFormatType != 1717855600)
        {
          int v7 = 1717856627;
          goto LABEL_15;
        }
      }
      else if (PixelFormatType != 825306677)
      {
        int v7 = 825437747;
        goto LABEL_15;
      }
    }
    else if (PixelFormatType <= 1919365989)
    {
      if (PixelFormatType != 1751410032)
      {
        int v7 = 1751411059;
        goto LABEL_15;
      }
    }
    else if (PixelFormatType != 1919365990 && PixelFormatType != 1919365992)
    {
      int v7 = 1932996149;
LABEL_15:
      if (PixelFormatType == v7) {
        goto LABEL_16;
      }
      CGRect v18 = *(CGRect *)*(void *)&MEMORY[0x263F001A8];
      v19.origin.double x = *(CGFloat *)MEMORY[0x263F001A8];
      v19.origin.double y = v18.origin.y;
      v19.size.vImagePixelCount width = v18.size.width;
      v19.size.vImagePixelCount height = v18.size.height;
      VTTransferSession = createVTTransferSession(*MEMORY[0x263F001A8], v19);
      OSStatus v16 = VTPixelTransferSessionTransferImage(VTTransferSession, pixelBuffer, this);
      if (VTTransferSession)
      {
        VTPixelTransferSessionInvalidate(VTTransferSession);
        CFRelease(VTTransferSession);
      }
      if (!v16) {
        return 0;
      }
      NSLog(&cfstr_SDErrorVtpixel.isa, "cropAndScalePixelBufferVT", 1109);
      return 0xFFFFFFFFLL;
    }
  }
LABEL_16:
  uint64_t v8 = *MEMORY[0x263F00148];
  uint64_t v9 = *(void *)(MEMORY[0x263F00148] + 8);
  uint64_t v10 = *MEMORY[0x263F001A8];
  uint64_t v11 = *(void *)(MEMORY[0x263F001A8] + 8);
  uint64_t v12 = *(void *)(MEMORY[0x263F001A8] + 16);
  uint64_t v13 = *(void *)(MEMORY[0x263F001A8] + 24);
  return copyPixelBufferVImage(this, *(CGPoint *)&v8, pixelBuffer, *(CGRect *)&v10);
}

uint64_t PixelBufferUtils::countDifferentPixels(PixelBufferUtils *this, __CVBuffer *a2, __CVBuffer *a3, int32x2_t a4, int32x2_t a5)
{
  size_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  size_t v9 = CVPixelBufferGetWidth(a2);
  size_t v10 = CVPixelBufferGetHeight(a2);
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  uint64_t result = -1;
  if (Width == v9 && Height == v10)
  {
    CVPixelBufferLockBaseAddress(this, 1uLL);
    CVPixelBufferLockBaseAddress(a2, 1uLL);
    memset(&v535, 0, sizeof(v535));
    uint64_t v13 = (CGRect *)MEMORY[0x263F001A8];
    PixelBufferUtils::asVImageBuffer(this, *MEMORY[0x263F001A8], &v535);
    memset(&v534, 0, sizeof(v534));
    PixelBufferUtils::asVImageBuffer(a2, *v13, &v534);
    if ((int)PixelFormatType <= 1380410944)
    {
      int32x2_t v15 = a4;
      int32x2_t v14 = a5;
      if ((int)PixelFormatType > 1111970368)
      {
        if ((int)PixelFormatType > 1278226533)
        {
          if (PixelFormatType != 1278226534)
          {
            if (PixelFormatType != 1278226536)
            {
              if (PixelFormatType != 1380401729) {
                goto LABEL_221;
              }
LABEL_95:
              if (*(_OWORD *)&v535.height == *(_OWORD *)&v534.height)
              {
                if (v535.height)
                {
                  vImagePixelCount v194 = 4 * v535.width;
                  if (4 * v535.width)
                  {
                    uint64_t v195 = 0;
                    LODWORD(PixelFormatType) = 0;
                    if (v194) {
                      BOOL v196 = (v194 - 1) >> 32 == 0;
                    }
                    else {
                      BOOL v196 = 0;
                    }
                    char v197 = !v196;
                    unint64_t v198 = v194 & 0xFFFFFFFFFFFFFFF0;
                    float32x4_t v199 = (float32x4_t)vdupq_lane_s32(a5, 0);
                    float32x4_t v200 = (float32x4_t)vdupq_lane_s32(a4, 0);
                    unint64_t v201 = v194 & 0xFFFFFFFFFFFFFFF8;
                    float64x2_t v202 = (float64x2_t)vdupq_n_s64(0x3B5E392010175EE6uLL);
                    v203.i64[0] = 0x100000001;
                    v203.i64[1] = 0x100000001;
                    data = (int8x16_t *)v534.data;
                    float64x2_t v205 = (uint8x16_t *)v535.data;
                    while (1)
                    {
                      float64x2_t v206 = (unsigned __int8 *)v535.data + v195 * v535.rowBytes;
                      float64x2_t v207 = (unsigned __int8 *)v534.data + v195 * v534.rowBytes;
                      if (v194 < 8 || (v197 & 1) != 0)
                      {
                        int v208 = 0;
                        goto LABEL_109;
                      }
                      if (v194 >= 0x10)
                      {
                        int32x4_t v233 = (int32x4_t)PixelFormatType;
                        int32x4_t v234 = 0uLL;
                        float64x2_t v235 = data;
                        float64x2_t v236 = v205;
                        unint64_t v237 = v194 & 0xFFFFFFFFFFFFFFF0;
                        int32x4_t v238 = 0uLL;
                        int32x4_t v239 = 0uLL;
                        do
                        {
                          uint8x16_t v240 = *v236++;
                          uint8x16_t v241 = v240;
                          int8x16_t v242 = *v235++;
                          int16x8_t v243 = (int16x8_t)vsubl_u8(*(uint8x8_t *)v241.i8, *(uint8x8_t *)v242.i8);
                          int32x4_t v244 = vmovl_high_s16(v243);
                          int16x8_t v245 = (int16x8_t)vsubl_high_u8(v241, (uint8x16_t)v242);
                          int32x4_t v246 = vmovl_high_s16(v245);
                          float32x4_t v247 = vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v245.i8));
                          float32x4_t v248 = vcvtq_f32_s32(v246);
                          float32x4_t v249 = vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v243.i8));
                          float32x4_t v250 = vcvtq_f32_s32(v244);
                          int16x8_t v251 = (int16x8_t)vcgtq_f32(v247, v199);
                          float64x2_t v252 = vcvtq_f64_f32(*(float32x2_t *)v247.f32);
                          float64x2_t v253 = vcvt_hight_f64_f32(v247);
                          float64x2_t v254 = vcvtq_f64_f32(*(float32x2_t *)v249.f32);
                          float64x2_t v255 = vcvt_hight_f64_f32(v249);
                          int8x8_t v256 = (int8x8_t)vextq_s8(v242, v242, 8uLL).u64[0];
                          int16x8_t v257 = vuzp1q_s16((int16x8_t)vcgtq_f32(v249, v199), (int16x8_t)vcgtq_f32(v250, v199));
                          v258.i32[0] = v256.u8[6];
                          v258.i32[1] = v256.u8[7];
                          int8x16_t v259 = (int8x16_t)vuzp1q_s16(v251, (int16x8_t)vcgtq_f32(v248, v199));
                          v260.i32[0] = v256.u8[4];
                          v260.i32[1] = v256.u8[5];
                          int8x8_t v261 = vand_s8(v258, (int8x8_t)0xFF000000FFLL);
                          v262.i32[0] = v256.u8[2];
                          v262.i32[1] = v256.u8[3];
                          int8x8_t v263 = vand_s8(v260, (int8x8_t)0xFF000000FFLL);
                          v251.i32[0] = v256.u8[0];
                          v264.i64[0] = v261.u32[0];
                          v264.i64[1] = v261.u32[1];
                          uint64x2_t v265 = v264;
                          int8x8_t v266 = vand_s8(v262, (int8x8_t)0xFF000000FFLL);
                          v251.i32[1] = v256.u8[1];
                          v264.i64[0] = v263.u32[0];
                          v264.i64[1] = v263.u32[1];
                          uint64x2_t v267 = v264;
                          v256.i32[0] = v242.u8[6];
                          v256.i32[1] = v242.u8[7];
                          v264.i64[0] = v266.u32[0];
                          v264.i64[1] = v266.u32[1];
                          uint64x2_t v268 = v264;
                          *(int8x8_t *)v251.i8 = vand_s8(*(int8x8_t *)v251.i8, (int8x8_t)0xFF000000FFLL);
                          int8x8_t v269 = vand_s8(v256, (int8x8_t)0xFF000000FFLL);
                          v264.i64[0] = v269.u32[0];
                          v264.i64[1] = v269.u32[1];
                          uint64x2_t v270 = v264;
                          v264.i64[0] = v251.u32[0];
                          v264.i64[1] = v251.u32[1];
                          uint64x2_t v271 = v264;
                          v272.i32[0] = v242.u8[4];
                          v272.i32[1] = v242.u8[5];
                          int8x8_t v273 = vand_s8(v272, (int8x8_t)0xFF000000FFLL);
                          v264.i64[0] = v273.u32[0];
                          v264.i64[1] = v273.u32[1];
                          float64x2_t v274 = vcvtq_f64_u64(v264);
                          v275.i32[0] = v242.u8[2];
                          v275.i32[1] = v242.u8[3];
                          int8x8_t v276 = vand_s8(v275, (int8x8_t)0xFF000000FFLL);
                          v264.i64[0] = v276.u32[0];
                          v264.i64[1] = v276.u32[1];
                          float64x2_t v277 = vcvtq_f64_u64(v264);
                          v278.i32[0] = v242.u8[0];
                          v278.i32[1] = v242.u8[1];
                          float64x2_t v279 = vcvtq_f64_u64(v271);
                          *(int8x8_t *)v271.i8 = vand_s8(v278, (int8x8_t)0xFF000000FFLL);
                          v264.i64[0] = v271.u32[0];
                          v264.i64[1] = v271.u32[1];
                          *(int8x8_t *)v259.i8 = vmovn_s16((int16x8_t)vandq_s8(v259, (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v252, vaddq_f64(v279, v202))), vdivq_f64(v253, vaddq_f64(vcvtq_f64_u64(v268), v202))), v200), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v248.f32), vaddq_f64(vcvtq_f64_u64(v267), v202))), vdivq_f64(vcvt_hight_f64_f32(v248), vaddq_f64(vcvtq_f64_u64(v265), v202))), v200))));
                          *(int8x8_t *)v257.i8 = vand_s8(vmovn_s16(v257), vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v254, vaddq_f64(vcvtq_f64_u64(v264), v202))), vdivq_f64(v255, vaddq_f64(v277, v202))), v200), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v250.f32), vaddq_f64(v274, v202))),
                                                                      vdivq_f64(vcvt_hight_f64_f32(v250), vaddq_f64(vcvtq_f64_u64(v270), v202))), v200))));
                          int32x4_t v234 = vaddq_s32(v234, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v257.i8, *(int8x8_t *)v199.f32)), v203));
                          int32x4_t v233 = vaddq_s32(v233, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v257.i8, *(int8x8_t *)v199.f32)), v203));
                          int32x4_t v239 = vaddq_s32(v239, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v259.i8, *(int8x8_t *)v199.f32)), v203));
                          int32x4_t v238 = vaddq_s32(v238, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v259.i8, *(int8x8_t *)v199.f32)), v203));
                          v237 -= 16;
                        }
                        while (v237);
                        LODWORD(PixelFormatType) = vaddvq_s32(vaddq_s32(vaddq_s32(v233, v238), vaddq_s32(v234, v239)));
                        if (v194 == v198) {
                          goto LABEL_105;
                        }
                        if ((v535.width & 2) == 0)
                        {
                          v206 += v198;
                          v207 += v198;
                          int v208 = v194 & 0xFFFFFFF0;
LABEL_109:
                          unsigned int v209 = v208 + 1;
                          do
                          {
                            unsigned int v210 = *v207;
                            float v211 = (float)(int)(*v206 - v210);
                            if (v211 > *(float *)a5.i32)
                            {
                              float v212 = v211 / ((double)v210 + 1.0e-22);
                              if (v212 > *(float *)a4.i32) {
                                LODWORD(PixelFormatType) = PixelFormatType + 1;
                              }
                            }
                            ++v206;
                            ++v207;
                            BOOL v52 = v194 > v209++;
                          }
                          while (v52);
                          goto LABEL_105;
                        }
                        unint64_t v213 = v194 & 0xFFFFFFFFFFFFFFF0;
                      }
                      else
                      {
                        unint64_t v213 = 0;
                      }
                      v207 += v201;
                      int32x4_t v214 = 0uLL;
                      int32x4_t v215 = (int32x4_t)PixelFormatType;
                      do
                      {
                        uint8x8_t v216 = *(uint8x8_t *)&data->i8[v213];
                        int16x8_t v217 = (int16x8_t)vsubl_u8(*(uint8x8_t *)&v205->i8[v213], v216);
                        int32x4_t v218 = vmovl_high_s16(v217);
                        float32x4_t v219 = vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v217.i8));
                        float32x4_t v220 = vcvtq_f32_s32(v218);
                        v221.i32[0] = v216.u8[6];
                        v221.i32[1] = v216.u8[7];
                        v222.i32[0] = v216.u8[4];
                        int8x8_t v223 = vand_s8(v221, (int8x8_t)0xFF000000FFLL);
                        v222.i32[1] = v216.u8[5];
                        int8x8_t v224 = vand_s8(v222, (int8x8_t)0xFF000000FFLL);
                        v225.i64[0] = v223.u32[0];
                        v225.i64[1] = v223.u32[1];
                        v226.i32[0] = v216.u8[2];
                        v226.i32[1] = v216.u8[3];
                        float64x2_t v227 = vcvtq_f64_u64(v225);
                        v225.i64[0] = v224.u32[0];
                        v225.i64[1] = v224.u32[1];
                        uint64x2_t v228 = v225;
                        int8x8_t v229 = vand_s8(v226, (int8x8_t)0xFF000000FFLL);
                        v225.i64[0] = v229.u32[0];
                        v225.i64[1] = v229.u32[1];
                        v230.i32[0] = v216.u8[0];
                        v230.i32[1] = v216.u8[1];
                        float64x2_t v231 = vcvtq_f64_u64(v225);
                        int8x8_t v232 = vand_s8(v230, (int8x8_t)0xFF000000FFLL);
                        v225.i64[0] = v232.u32[0];
                        v225.i64[1] = v232.u32[1];
                        *(int8x8_t *)v219.f32 = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v219, v199), (int16x8_t)vcgtq_f32(v220, v199)), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v219.f32), vaddq_f64(vcvtq_f64_u64(v225), v202))), vdivq_f64(vcvt_hight_f64_f32(v219), vaddq_f64(v231, v202))), v200), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v220.f32), vaddq_f64(vcvtq_f64_u64(v228), v202))), vdivq_f64(vcvt_hight_f64_f32(v220), vaddq_f64(v227, v202))), v200))));
                        int32x4_t v214 = vaddq_s32(v214, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v219.f32, *(int8x8_t *)v199.f32)), v203));
                        int32x4_t v215 = vaddq_s32(v215, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v219.f32, *(int8x8_t *)v199.f32)), v203));
                        v213 += 8;
                      }
                      while (v201 != v213);
                      LODWORD(PixelFormatType) = vaddvq_s32(vaddq_s32(v215, v214));
                      if (v194 != v201)
                      {
                        v206 += v201;
                        int v208 = v194 & 0xFFFFFFF8;
                        goto LABEL_109;
                      }
LABEL_105:
                      ++v195;
                      float64x2_t v205 = (uint8x16_t *)((char *)v205 + v535.rowBytes);
                      data = (int8x16_t *)((char *)data + v534.rowBytes);
                      if (v535.height <= v195) {
                        goto LABEL_261;
                      }
                    }
                  }
                }
LABEL_226:
                LODWORD(PixelFormatType) = 0;
              }
LABEL_261:
              CVPixelBufferUnlockBaseAddress(this, 1uLL);
              CVPixelBufferUnlockBaseAddress(a2, 1uLL);
              return (int)PixelFormatType;
            }
            goto LABEL_177;
          }
LABEL_167:
          if (*(_OWORD *)&v535.height == *(_OWORD *)&v534.height)
          {
            if (v535.height && v535.width)
            {
              uint64_t v365 = 0;
              LODWORD(PixelFormatType) = 0;
              float64x2_t v366 = (float *)v535.data;
              float64x2_t v367 = (float *)v534.data;
              do
              {
                uint64_t v368 = 0;
                do
                {
                  float v369 = v367[v368];
                  float v370 = v366[v368] - v369;
                  if (v370 > *(float *)v14.i32)
                  {
                    float v371 = v370 / (v369 + 1.0e-22);
                    if (v371 > *(float *)v15.i32) {
                      LODWORD(PixelFormatType) = PixelFormatType + 1;
                    }
                  }
                  ++v368;
                }
                while (v535.width > v368);
                ++v365;
                float64x2_t v367 = (float *)((char *)v367 + v534.rowBytes);
                float64x2_t v366 = (float *)((char *)v366 + v535.rowBytes);
              }
              while (v535.height > v365);
              goto LABEL_261;
            }
            goto LABEL_226;
          }
          goto LABEL_261;
        }
        if (PixelFormatType == 1111970369) {
          goto LABEL_95;
        }
        int v193 = 1278226488;
        goto LABEL_166;
      }
      if ((int)PixelFormatType <= 875704421)
      {
        if (PixelFormatType == 32) {
          goto LABEL_95;
        }
        if (PixelFormatType != 843264104) {
          goto LABEL_221;
        }
        if (*(_OWORD *)&v535.height != *(_OWORD *)&v534.height) {
          goto LABEL_261;
        }
        if (!v535.height) {
          goto LABEL_226;
        }
        vImagePixelCount v26 = 2 * v535.width;
        if (!(2 * v535.width)) {
          goto LABEL_226;
        }
        uint64_t v27 = 0;
        LODWORD(PixelFormatType) = 0;
        if (v26) {
          BOOL v28 = (v26 - 1) >> 32 == 0;
        }
        else {
          BOOL v28 = 0;
        }
        char v29 = !v28;
        unint64_t v30 = 2 * (v26 & 0xFFFFFFFFFFFFFFF0);
        float32x4_t v31 = (float32x4_t)vdupq_lane_s32(a5, 0);
        float32x4_t v32 = (float32x4_t)vdupq_lane_s32(a4, 0);
        size_t v33 = (float16x4_t *)((char *)v535.data + 16);
        float64x2_t v34 = (float64x2_t)vdupq_n_s64(0x3B5E392010175EE6uLL);
        int v35 = (float16x4_t *)((char *)v534.data + 16);
        v36.i64[0] = 0x100000001;
        v36.i64[1] = 0x100000001;
        while (1)
        {
          CGRect v99 = (__int16 *)((char *)v535.data + v27 * v535.rowBytes);
          unint64_t v100 = (__int16 *)((char *)v534.data + v27 * v534.rowBytes);
          if (v26 < 0x10 || (v29 & 1) != 0) {
            break;
          }
          unint64_t v100 = (__int16 *)((char *)v100 + v30);
          int32x4_t v109 = (int32x4_t)PixelFormatType;
          int32x4_t v110 = 0uLL;
          vImagePixelCount v111 = v35;
          double v112 = v33;
          unint64_t v113 = v26 & 0xFFFFFFFFFFFFFFF0;
          int32x4_t v114 = 0uLL;
          int32x4_t v115 = 0uLL;
          do
          {
            _Q17 = *(float16x8_t *)v112[-2].i8;
            float32x4_t v117 = vcvt_hight_f32_f16(_Q17);
            float32x4_t v118 = vcvtq_f32_f16(*(float16x4_t *)_Q17.i8);
            _Q26 = *(float16x8_t *)v111[-2].i8;
            _Q20 = *(float64x2_t *)v111->i8;
            _D27 = vextq_s8((int8x16_t)_Q26, (int8x16_t)_Q26, 8uLL).u64[0];
            _Q17.i64[0] = vextq_s8((int8x16_t)_Q20, (int8x16_t)_Q20, 8uLL).u64[0];
            float32x4_t v122 = vsubq_f32(v118, vcvtq_f32_f16(*(float16x4_t *)_Q26.i8));
            _Q30 = (float64x2_t)vsubq_f32(v117, vcvt_hight_f32_f16(_Q26));
            float32x4_t v124 = vsubq_f32(vcvtq_f32_f16(*v112), vcvtq_f32_f16(*v111));
            float32x4_t v125 = vsubq_f32(vcvt_hight_f32_f16(*(float16x8_t *)v112->i8), vcvt_hight_f32_f16(*(float16x8_t *)v111->i8));
            int16x8_t v126 = (int16x8_t)vcgtq_f32((float32x4_t)_Q30, v31);
            float64x2_t v127 = vcvtq_f64_f32(*(float32x2_t *)&_Q30.f64[0]);
            _H25 = HIWORD(*(void *)&v111[-2]);
            __asm { FCVT            D31, H25 }
            _H8 = WORD2(*(void *)&v111[-2]);
            float64x2_t v131 = vcvt_hight_f64_f32((float32x4_t)_Q30);
            __asm { FCVT            D30, H8 }
            _Q30.f64[1] = _D31;
            LOWORD(_D31) = _Q26.i16[1];
            __asm
            {
              FCVT            D31, H31
              FCVT            D26, H26
            }
            _Q26.i64[1] = _D31;
            LOWORD(_D31) = HIWORD(_D27);
            __asm { FCVT            D31, H31 }
            _H9 = WORD2(_D27);
            __asm { FCVT            D9, H9 }
            _H10 = WORD1(_D27);
            __asm { FCVT            D10, H10 }
            _Q9.f64[1] = _D31;
            __asm { FCVT            D27, H27 }
            LOWORD(_D31) = HIWORD(*(unint64_t *)v111);
            __asm { FCVT            D31, H31 }
            _H11 = WORD2(*(unint64_t *)v111);
            __asm { FCVT            D11, H11 }
            _Q11.f64[1] = _D31;
            LOWORD(_D31) = WORD1(*(_OWORD *)v111->i8);
            __asm
            {
              FCVT            D31, H31
              FCVT            D20, H20
            }
            _Q20.f64[1] = _D31;
            LOWORD(_D31) = _Q17.i16[3];
            __asm { FCVT            D31, H31 }
            _Q27.f64[1] = _D10;
            LOWORD(_D10) = _Q17.i16[2];
            __asm { FCVT            D10, H10 }
            _Q10.f64[1] = _D31;
            LOWORD(_D31) = _Q17.i16[1];
            __asm
            {
              FCVT            D24, H31
              FCVT            D17, H17
            }
            _Q17.i64[1] = _D24;
            *(int8x8_t *)&v127.f64[0] = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v122, v31), v126), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v122.f32), vaddq_f64((float64x2_t)_Q26, v34))), vdivq_f64(vcvt_hight_f64_f32(v122), vaddq_f64(_Q30, v34))), v32), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v127, vaddq_f64(_Q27, v34))), vdivq_f64(v131, vaddq_f64(_Q9, v34))), v32))));
            *(int8x8_t *)_Q17.i8 = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v124, v31), (int16x8_t)vcgtq_f32(v125, v31)), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v124.f32), vaddq_f64(_Q20, v34))), vdivq_f64(vcvt_hight_f64_f32(v124), vaddq_f64(_Q11, v34))), v32), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v125.f32),
                                                                                                     vaddq_f64((float64x2_t)_Q17, v34))),
                                                                                      vdivq_f64(vcvt_hight_f64_f32(v125), vaddq_f64(_Q10, v34))), v32))));
            int32x4_t v110 = vaddq_s32(v110, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)&v127.f64[0], *(int8x8_t *)v31.f32)), v36));
            int32x4_t v109 = vaddq_s32(v109, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)&v127.f64[0], *(int8x8_t *)v31.f32)), v36));
            int32x4_t v115 = vaddq_s32(v115, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)_Q17.i8, *(int8x8_t *)v31.f32)), v36));
            int32x4_t v114 = vaddq_s32(v114, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)_Q17.i8, *(int8x8_t *)v31.f32)), v36));
            v112 += 4;
            v111 += 4;
            v113 -= 16;
          }
          while (v113);
          LODWORD(PixelFormatType) = vaddvq_s32(vaddq_s32(vaddq_s32(v114, v109), vaddq_s32(v115, v110)));
          if (v26 != (v26 & 0xFFFFFFFFFFFFFFF0))
          {
            CGRect v99 = (__int16 *)((char *)v99 + v30);
            int v101 = v26 & 0xFFFFFFF0;
LABEL_69:
            unsigned int v102 = v101 + 1;
            do
            {
              _H5 = *v99;
              __asm { FCVT            S6, H5 }
              _H5 = *v100;
              __asm { FCVT            S7, H5 }
              float v107 = _S6 - _S7;
              if (v107 > *(float *)a5.i32)
              {
                __asm { FCVT            D5, H5 }
                *(float *)&_D5 = v107 / (_D5 + 1.0e-22);
                if (*(float *)&_D5 > *(float *)a4.i32) {
                  LODWORD(PixelFormatType) = PixelFormatType + 1;
                }
              }
              ++v99;
              ++v100;
              BOOL v52 = v26 > v102++;
            }
            while (v52);
          }
          ++v27;
          size_t v33 = (float16x4_t *)((char *)v33 + v535.rowBytes);
          int v35 = (float16x4_t *)((char *)v35 + v534.rowBytes);
          if (v535.height <= v27) {
            goto LABEL_261;
          }
        }
        int v101 = 0;
        goto LABEL_69;
      }
      if (PixelFormatType != 875704422 && PixelFormatType != 875704438) {
        goto LABEL_221;
      }
      PixelBufferUtils::asVImageBuffer(this, 0, *v13, &v535);
      PixelBufferUtils::asVImageBuffer(a2, 0, *v13, &v534);
      if (*(_OWORD *)&v535.height == *(_OWORD *)&v534.height)
      {
        if (v535.height && v535.width)
        {
          uint64_t v280 = 0;
          LODWORD(PixelFormatType) = 0;
          if (LODWORD(v535.width)) {
            BOOL v281 = (v535.width - 1) >> 32 == 0;
          }
          else {
            BOOL v281 = 0;
          }
          char v282 = !v281;
          vImagePixelCount v283 = v535.width & 0xFFFFFFFFFFFFFFF0;
          float32x4_t v284 = (float32x4_t)vdupq_lane_s32(a5, 0);
          float32x4_t v285 = (float32x4_t)vdupq_lane_s32(a4, 0);
          vImagePixelCount v286 = v535.width & 0xFFFFFFFFFFFFFFF8;
          float64x2_t v287 = (float64x2_t)vdupq_n_s64(0x3B5E392010175EE6uLL);
          v288.i64[0] = 0x100000001;
          v288.i64[1] = 0x100000001;
          double v289 = (int8x16_t *)v534.data;
          double v290 = (uint8x16_t *)v535.data;
          while (1)
          {
            double v291 = (unsigned __int8 *)v535.data + v280 * v535.rowBytes;
            double v292 = (unsigned __int8 *)v534.data + v280 * v534.rowBytes;
            if (v535.width < 8 || (v282 & 1) != 0)
            {
              unsigned int v293 = 0;
              goto LABEL_146;
            }
            if (v535.width >= 0x10)
            {
              int32x4_t v318 = (int32x4_t)PixelFormatType;
              int32x4_t v319 = 0uLL;
              double v320 = v289;
              double v321 = v290;
              vImagePixelCount v322 = v535.width & 0xFFFFFFFFFFFFFFF0;
              int32x4_t v323 = 0uLL;
              int32x4_t v324 = 0uLL;
              do
              {
                uint8x16_t v325 = *v321++;
                uint8x16_t v326 = v325;
                int8x16_t v327 = *v320++;
                int16x8_t v328 = (int16x8_t)vsubl_u8(*(uint8x8_t *)v326.i8, *(uint8x8_t *)v327.i8);
                int32x4_t v329 = vmovl_high_s16(v328);
                int16x8_t v330 = (int16x8_t)vsubl_high_u8(v326, (uint8x16_t)v327);
                int32x4_t v331 = vmovl_high_s16(v330);
                float32x4_t v332 = vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v330.i8));
                float32x4_t v333 = vcvtq_f32_s32(v331);
                float32x4_t v334 = vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v328.i8));
                float32x4_t v335 = vcvtq_f32_s32(v329);
                int16x8_t v336 = (int16x8_t)vcgtq_f32(v332, v284);
                float64x2_t v337 = vcvtq_f64_f32(*(float32x2_t *)v332.f32);
                float64x2_t v338 = vcvt_hight_f64_f32(v332);
                float64x2_t v339 = vcvtq_f64_f32(*(float32x2_t *)v334.f32);
                float64x2_t v340 = vcvt_hight_f64_f32(v334);
                int8x8_t v341 = (int8x8_t)vextq_s8(v327, v327, 8uLL).u64[0];
                int16x8_t v342 = vuzp1q_s16((int16x8_t)vcgtq_f32(v334, v284), (int16x8_t)vcgtq_f32(v335, v284));
                v343.i32[0] = v341.u8[6];
                v343.i32[1] = v341.u8[7];
                int8x16_t v344 = (int8x16_t)vuzp1q_s16(v336, (int16x8_t)vcgtq_f32(v333, v284));
                v345.i32[0] = v341.u8[4];
                v345.i32[1] = v341.u8[5];
                int8x8_t v346 = vand_s8(v343, (int8x8_t)0xFF000000FFLL);
                v347.i32[0] = v341.u8[2];
                v347.i32[1] = v341.u8[3];
                int8x8_t v348 = vand_s8(v345, (int8x8_t)0xFF000000FFLL);
                v336.i32[0] = v341.u8[0];
                v349.i64[0] = v346.u32[0];
                v349.i64[1] = v346.u32[1];
                uint64x2_t v350 = v349;
                int8x8_t v351 = vand_s8(v347, (int8x8_t)0xFF000000FFLL);
                v336.i32[1] = v341.u8[1];
                v349.i64[0] = v348.u32[0];
                v349.i64[1] = v348.u32[1];
                uint64x2_t v352 = v349;
                v341.i32[0] = v327.u8[6];
                v341.i32[1] = v327.u8[7];
                v349.i64[0] = v351.u32[0];
                v349.i64[1] = v351.u32[1];
                uint64x2_t v353 = v349;
                *(int8x8_t *)v336.i8 = vand_s8(*(int8x8_t *)v336.i8, (int8x8_t)0xFF000000FFLL);
                int8x8_t v354 = vand_s8(v341, (int8x8_t)0xFF000000FFLL);
                v349.i64[0] = v354.u32[0];
                v349.i64[1] = v354.u32[1];
                uint64x2_t v355 = v349;
                v349.i64[0] = v336.u32[0];
                v349.i64[1] = v336.u32[1];
                uint64x2_t v356 = v349;
                v357.i32[0] = v327.u8[4];
                v357.i32[1] = v327.u8[5];
                int8x8_t v358 = vand_s8(v357, (int8x8_t)0xFF000000FFLL);
                v349.i64[0] = v358.u32[0];
                v349.i64[1] = v358.u32[1];
                float64x2_t v359 = vcvtq_f64_u64(v349);
                v360.i32[0] = v327.u8[2];
                v360.i32[1] = v327.u8[3];
                int8x8_t v361 = vand_s8(v360, (int8x8_t)0xFF000000FFLL);
                v349.i64[0] = v361.u32[0];
                v349.i64[1] = v361.u32[1];
                float64x2_t v362 = vcvtq_f64_u64(v349);
                v363.i32[0] = v327.u8[0];
                v363.i32[1] = v327.u8[1];
                float64x2_t v364 = vcvtq_f64_u64(v356);
                *(int8x8_t *)v356.i8 = vand_s8(v363, (int8x8_t)0xFF000000FFLL);
                v349.i64[0] = v356.u32[0];
                v349.i64[1] = v356.u32[1];
                *(int8x8_t *)v344.i8 = vmovn_s16((int16x8_t)vandq_s8(v344, (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v337, vaddq_f64(v364, v287))), vdivq_f64(v338, vaddq_f64(vcvtq_f64_u64(v353), v287))), v285), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v333.f32), vaddq_f64(vcvtq_f64_u64(v352), v287))), vdivq_f64(vcvt_hight_f64_f32(v333), vaddq_f64(vcvtq_f64_u64(v350), v287))),
                                                                                        v285))));
                *(int8x8_t *)v342.i8 = vand_s8(vmovn_s16(v342), vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v339, vaddq_f64(vcvtq_f64_u64(v349), v287))), vdivq_f64(v340, vaddq_f64(v362, v287))), v285), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v335.f32), vaddq_f64(v359, v287))), vdivq_f64(vcvt_hight_f64_f32(v335),
                                                              vaddq_f64(vcvtq_f64_u64(v355), v287))),
                                                          v285))));
                int32x4_t v319 = vaddq_s32(v319, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v342.i8, *(int8x8_t *)v284.f32)), v288));
                int32x4_t v318 = vaddq_s32(v318, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v342.i8, *(int8x8_t *)v284.f32)), v288));
                int32x4_t v324 = vaddq_s32(v324, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v344.i8, *(int8x8_t *)v284.f32)), v288));
                int32x4_t v323 = vaddq_s32(v323, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v344.i8, *(int8x8_t *)v284.f32)), v288));
                v322 -= 16;
              }
              while (v322);
              LODWORD(PixelFormatType) = vaddvq_s32(vaddq_s32(vaddq_s32(v318, v323), vaddq_s32(v319, v324)));
              if (v535.width == v283) {
                goto LABEL_142;
              }
              if ((v535.width & 8) == 0)
              {
                v291 += v283;
                v292 += v283;
                unsigned int v293 = v535.width & 0xFFFFFFF0;
LABEL_146:
                unsigned int v294 = v293 + 1;
                do
                {
                  unsigned int v295 = *v292;
                  float v296 = (float)(int)(*v291 - v295);
                  if (v296 > *(float *)a5.i32)
                  {
                    float v297 = v296 / ((double)v295 + 1.0e-22);
                    if (v297 > *(float *)a4.i32) {
                      LODWORD(PixelFormatType) = PixelFormatType + 1;
                    }
                  }
                  ++v291;
                  ++v292;
                  BOOL v52 = v535.width > v294++;
                }
                while (v52);
                goto LABEL_142;
              }
              vImagePixelCount v298 = v535.width & 0xFFFFFFFFFFFFFFF0;
            }
            else
            {
              vImagePixelCount v298 = 0;
            }
            v292 += v286;
            int32x4_t v299 = 0uLL;
            int32x4_t v300 = (int32x4_t)PixelFormatType;
            do
            {
              uint8x8_t v301 = *(uint8x8_t *)&v289->i8[v298];
              int16x8_t v302 = (int16x8_t)vsubl_u8(*(uint8x8_t *)&v290->i8[v298], v301);
              int32x4_t v303 = vmovl_high_s16(v302);
              float32x4_t v304 = vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v302.i8));
              float32x4_t v305 = vcvtq_f32_s32(v303);
              v306.i32[0] = v301.u8[6];
              v306.i32[1] = v301.u8[7];
              v307.i32[0] = v301.u8[4];
              int8x8_t v308 = vand_s8(v306, (int8x8_t)0xFF000000FFLL);
              v307.i32[1] = v301.u8[5];
              int8x8_t v309 = vand_s8(v307, (int8x8_t)0xFF000000FFLL);
              v310.i64[0] = v308.u32[0];
              v310.i64[1] = v308.u32[1];
              v311.i32[0] = v301.u8[2];
              v311.i32[1] = v301.u8[3];
              float64x2_t v312 = vcvtq_f64_u64(v310);
              v310.i64[0] = v309.u32[0];
              v310.i64[1] = v309.u32[1];
              uint64x2_t v313 = v310;
              int8x8_t v314 = vand_s8(v311, (int8x8_t)0xFF000000FFLL);
              v310.i64[0] = v314.u32[0];
              v310.i64[1] = v314.u32[1];
              v315.i32[0] = v301.u8[0];
              v315.i32[1] = v301.u8[1];
              float64x2_t v316 = vcvtq_f64_u64(v310);
              int8x8_t v317 = vand_s8(v315, (int8x8_t)0xFF000000FFLL);
              v310.i64[0] = v317.u32[0];
              v310.i64[1] = v317.u32[1];
              *(int8x8_t *)v304.f32 = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v304, v284), (int16x8_t)vcgtq_f32(v305, v284)), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v304.f32), vaddq_f64(vcvtq_f64_u64(v310), v287))), vdivq_f64(vcvt_hight_f64_f32(v304), vaddq_f64(v316, v287))), v285), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v305.f32), vaddq_f64(vcvtq_f64_u64(v313), v287))), vdivq_f64(vcvt_hight_f64_f32(v305), vaddq_f64(v312, v287))), v285))));
              int32x4_t v299 = vaddq_s32(v299, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v304.f32, *(int8x8_t *)v284.f32)), v288));
              int32x4_t v300 = vaddq_s32(v300, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v304.f32, *(int8x8_t *)v284.f32)), v288));
              v298 += 8;
            }
            while (v286 != v298);
            LODWORD(PixelFormatType) = vaddvq_s32(vaddq_s32(v300, v299));
            if (v535.width != v286)
            {
              v291 += v286;
              unsigned int v293 = v535.width & 0xFFFFFFF8;
              goto LABEL_146;
            }
LABEL_142:
            ++v280;
            double v290 = (uint8x16_t *)((char *)v290 + v535.rowBytes);
            double v289 = (int8x16_t *)((char *)v289 + v534.rowBytes);
            if (v535.height <= v280) {
              goto LABEL_228;
            }
          }
        }
        LODWORD(PixelFormatType) = 0;
      }
LABEL_228:
      PixelBufferUtils::asVImageBuffer(this, (__CVBuffer *)1, *v13, &v535);
      PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, *v13, &v534);
      if (*(_OWORD *)&v535.height != *(_OWORD *)&v534.height)
      {
LABEL_260:
        LODWORD(PixelFormatType) = v444 + PixelFormatType;
        goto LABEL_261;
      }
      if (!v535.height) {
        goto LABEL_261;
      }
      vImagePixelCount v445 = 2 * v535.width;
      if (!(2 * v535.width)) {
        goto LABEL_261;
      }
      uint64_t v446 = 0;
      unsigned int v444 = 0;
      if (v445) {
        BOOL v447 = (v445 - 1) >> 32 == 0;
      }
      else {
        BOOL v447 = 0;
      }
      char v448 = !v447;
      unint64_t v449 = v445 & 0xFFFFFFFFFFFFFFF0;
      float32x4_t v450 = (float32x4_t)vdupq_lane_s32(a5, 0);
      float32x4_t v451 = (float32x4_t)vdupq_lane_s32(a4, 0);
      unint64_t v452 = v445 & 0xFFFFFFFFFFFFFFF8;
      float64x2_t v453 = (float64x2_t)vdupq_n_s64(0x3B5E392010175EE6uLL);
      v454.i64[0] = 0x100000001;
      v454.i64[1] = 0x100000001;
      float64x2_t v455 = (int8x16_t *)v534.data;
      float64x2_t v456 = (uint8x16_t *)v535.data;
      while (1)
      {
        float64x2_t v457 = (unsigned __int8 *)v535.data + v446 * v535.rowBytes;
        float64x2_t v458 = (unsigned __int8 *)v534.data + v446 * v534.rowBytes;
        if (v445 < 8 || (v448 & 1) != 0)
        {
          int v459 = 0;
          goto LABEL_242;
        }
        if (v445 >= 0x10)
        {
          int32x4_t v484 = (int32x4_t)v444;
          int32x4_t v485 = 0uLL;
          float64x2_t v486 = v455;
          float64x2_t v487 = v456;
          unint64_t v488 = v445 & 0xFFFFFFFFFFFFFFF0;
          int32x4_t v489 = 0uLL;
          int32x4_t v490 = 0uLL;
          do
          {
            uint8x16_t v491 = *v487++;
            uint8x16_t v492 = v491;
            int8x16_t v493 = *v486++;
            int16x8_t v494 = (int16x8_t)vsubl_u8(*(uint8x8_t *)v492.i8, *(uint8x8_t *)v493.i8);
            int32x4_t v495 = vmovl_high_s16(v494);
            int16x8_t v496 = (int16x8_t)vsubl_high_u8(v492, (uint8x16_t)v493);
            int32x4_t v497 = vmovl_high_s16(v496);
            float32x4_t v498 = vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v496.i8));
            float32x4_t v499 = vcvtq_f32_s32(v497);
            float32x4_t v500 = vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v494.i8));
            float32x4_t v501 = vcvtq_f32_s32(v495);
            int16x8_t v502 = (int16x8_t)vcgtq_f32(v498, v450);
            float64x2_t v503 = vcvtq_f64_f32(*(float32x2_t *)v498.f32);
            float64x2_t v504 = vcvt_hight_f64_f32(v498);
            float64x2_t v505 = vcvtq_f64_f32(*(float32x2_t *)v500.f32);
            float64x2_t v506 = vcvt_hight_f64_f32(v500);
            int8x8_t v507 = (int8x8_t)vextq_s8(v493, v493, 8uLL).u64[0];
            int16x8_t v508 = vuzp1q_s16((int16x8_t)vcgtq_f32(v500, v450), (int16x8_t)vcgtq_f32(v501, v450));
            v509.i32[0] = v507.u8[6];
            v509.i32[1] = v507.u8[7];
            int8x16_t v510 = (int8x16_t)vuzp1q_s16(v502, (int16x8_t)vcgtq_f32(v499, v450));
            v511.i32[0] = v507.u8[4];
            v511.i32[1] = v507.u8[5];
            int8x8_t v512 = vand_s8(v509, (int8x8_t)0xFF000000FFLL);
            v513.i32[0] = v507.u8[2];
            v513.i32[1] = v507.u8[3];
            int8x8_t v514 = vand_s8(v511, (int8x8_t)0xFF000000FFLL);
            v502.i32[0] = v507.u8[0];
            v515.i64[0] = v512.u32[0];
            v515.i64[1] = v512.u32[1];
            uint64x2_t v516 = v515;
            int8x8_t v517 = vand_s8(v513, (int8x8_t)0xFF000000FFLL);
            v502.i32[1] = v507.u8[1];
            v515.i64[0] = v514.u32[0];
            v515.i64[1] = v514.u32[1];
            uint64x2_t v518 = v515;
            v507.i32[0] = v493.u8[6];
            v507.i32[1] = v493.u8[7];
            v515.i64[0] = v517.u32[0];
            v515.i64[1] = v517.u32[1];
            uint64x2_t v519 = v515;
            *(int8x8_t *)v502.i8 = vand_s8(*(int8x8_t *)v502.i8, (int8x8_t)0xFF000000FFLL);
            int8x8_t v520 = vand_s8(v507, (int8x8_t)0xFF000000FFLL);
            v515.i64[0] = v520.u32[0];
            v515.i64[1] = v520.u32[1];
            uint64x2_t v521 = v515;
            v515.i64[0] = v502.u32[0];
            v515.i64[1] = v502.u32[1];
            uint64x2_t v522 = v515;
            v523.i32[0] = v493.u8[4];
            v523.i32[1] = v493.u8[5];
            int8x8_t v524 = vand_s8(v523, (int8x8_t)0xFF000000FFLL);
            v515.i64[0] = v524.u32[0];
            v515.i64[1] = v524.u32[1];
            float64x2_t v525 = vcvtq_f64_u64(v515);
            v526.i32[0] = v493.u8[2];
            v526.i32[1] = v493.u8[3];
            int8x8_t v527 = vand_s8(v526, (int8x8_t)0xFF000000FFLL);
            v515.i64[0] = v527.u32[0];
            v515.i64[1] = v527.u32[1];
            float64x2_t v528 = vcvtq_f64_u64(v515);
            v529.i32[0] = v493.u8[0];
            v529.i32[1] = v493.u8[1];
            float64x2_t v530 = vcvtq_f64_u64(v522);
            *(int8x8_t *)v522.i8 = vand_s8(v529, (int8x8_t)0xFF000000FFLL);
            v515.i64[0] = v522.u32[0];
            v515.i64[1] = v522.u32[1];
            *(int8x8_t *)v510.i8 = vmovn_s16((int16x8_t)vandq_s8(v510, (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v503, vaddq_f64(v530, v453))), vdivq_f64(v504, vaddq_f64(vcvtq_f64_u64(v519), v453))), v451), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v499.f32),
                                                                                                     vaddq_f64(vcvtq_f64_u64(v518), v453))),
                                                                                      vdivq_f64(vcvt_hight_f64_f32(v499), vaddq_f64(vcvtq_f64_u64(v516), v453))), v451))));
            *(int8x8_t *)v508.i8 = vand_s8(vmovn_s16(v508), vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v505, vaddq_f64(vcvtq_f64_u64(v515), v453))), vdivq_f64(v506, vaddq_f64(v528, v453))), v451), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v501.f32), vaddq_f64(v525, v453))), vdivq_f64(vcvt_hight_f64_f32(v501),
                                                          vaddq_f64(vcvtq_f64_u64(v521), v453))),
                                                      v451))));
            int32x4_t v485 = vaddq_s32(v485, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v508.i8, *(int8x8_t *)v450.f32)), v454));
            int32x4_t v484 = vaddq_s32(v484, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v508.i8, *(int8x8_t *)v450.f32)), v454));
            int32x4_t v490 = vaddq_s32(v490, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v510.i8, *(int8x8_t *)v450.f32)), v454));
            int32x4_t v489 = vaddq_s32(v489, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v510.i8, *(int8x8_t *)v450.f32)), v454));
            v488 -= 16;
          }
          while (v488);
          unsigned int v444 = vaddvq_s32(vaddq_s32(vaddq_s32(v484, v489), vaddq_s32(v485, v490)));
          if (v445 == v449) {
            goto LABEL_238;
          }
          if ((v535.width & 4) == 0)
          {
            v457 += v449;
            v458 += v449;
            int v459 = v445 & 0xFFFFFFF0;
LABEL_242:
            unsigned int v460 = v459 + 1;
            do
            {
              unsigned int v461 = *v458;
              float v462 = (float)(int)(*v457 - v461);
              if (v462 > *(float *)a5.i32)
              {
                float v463 = v462 / ((double)v461 + 1.0e-22);
                if (v463 > *(float *)a4.i32) {
                  ++v444;
                }
              }
              ++v457;
              ++v458;
              BOOL v52 = v445 > v460++;
            }
            while (v52);
            goto LABEL_238;
          }
          unint64_t v464 = v445 & 0xFFFFFFFFFFFFFFF0;
        }
        else
        {
          unint64_t v464 = 0;
        }
        v458 += v452;
        int32x4_t v465 = 0uLL;
        int32x4_t v466 = (int32x4_t)v444;
        do
        {
          uint8x8_t v467 = *(uint8x8_t *)&v455->i8[v464];
          int16x8_t v468 = (int16x8_t)vsubl_u8(*(uint8x8_t *)&v456->i8[v464], v467);
          int32x4_t v469 = vmovl_high_s16(v468);
          float32x4_t v470 = vcvtq_f32_s32(vmovl_s16(*(int16x4_t *)v468.i8));
          float32x4_t v471 = vcvtq_f32_s32(v469);
          v472.i32[0] = v467.u8[6];
          v472.i32[1] = v467.u8[7];
          v473.i32[0] = v467.u8[4];
          int8x8_t v474 = vand_s8(v472, (int8x8_t)0xFF000000FFLL);
          v473.i32[1] = v467.u8[5];
          int8x8_t v475 = vand_s8(v473, (int8x8_t)0xFF000000FFLL);
          v476.i64[0] = v474.u32[0];
          v476.i64[1] = v474.u32[1];
          v477.i32[0] = v467.u8[2];
          v477.i32[1] = v467.u8[3];
          float64x2_t v478 = vcvtq_f64_u64(v476);
          v476.i64[0] = v475.u32[0];
          v476.i64[1] = v475.u32[1];
          uint64x2_t v479 = v476;
          int8x8_t v480 = vand_s8(v477, (int8x8_t)0xFF000000FFLL);
          v476.i64[0] = v480.u32[0];
          v476.i64[1] = v480.u32[1];
          v481.i32[0] = v467.u8[0];
          v481.i32[1] = v467.u8[1];
          float64x2_t v482 = vcvtq_f64_u64(v476);
          int8x8_t v483 = vand_s8(v481, (int8x8_t)0xFF000000FFLL);
          v476.i64[0] = v483.u32[0];
          v476.i64[1] = v483.u32[1];
          *(int8x8_t *)v470.f32 = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v470, v450), (int16x8_t)vcgtq_f32(v471, v450)), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v470.f32), vaddq_f64(vcvtq_f64_u64(v476), v453))), vdivq_f64(vcvt_hight_f64_f32(v470), vaddq_f64(v482, v453))), v451), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v471.f32),
                                                                                                    vaddq_f64(vcvtq_f64_u64(v479), v453))),
                                                                                     vdivq_f64(vcvt_hight_f64_f32(v471), vaddq_f64(v478, v453))), v451))));
          int32x4_t v465 = vaddq_s32(v465, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v470.f32, *(int8x8_t *)v450.f32)), v454));
          int32x4_t v466 = vaddq_s32(v466, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v470.f32, *(int8x8_t *)v450.f32)), v454));
          v464 += 8;
        }
        while (v452 != v464);
        unsigned int v444 = vaddvq_s32(vaddq_s32(v466, v465));
        if (v445 != v452)
        {
          v457 += v452;
          int v459 = v445 & 0xFFFFFFF8;
          goto LABEL_242;
        }
LABEL_238:
        ++v446;
        float64x2_t v456 = (uint8x16_t *)((char *)v456 + v535.rowBytes);
        float64x2_t v455 = (int8x16_t *)((char *)v455 + v534.rowBytes);
        if (v535.height <= v446) {
          goto LABEL_260;
        }
      }
    }
    int32x2_t v15 = a4;
    int32x2_t v14 = a5;
    if ((int)PixelFormatType > 1717856626)
    {
      if ((int)PixelFormatType <= 1751411058)
      {
        if (PixelFormatType == 1717856627) {
          goto LABEL_167;
        }
        if (PixelFormatType != 1751410032) {
          goto LABEL_221;
        }
      }
      else if (PixelFormatType != 1751411059)
      {
        if (PixelFormatType == 1919365990)
        {
          PixelBufferUtils::asVImageBuffer(this, 0, *v13, &__p);
          PixelBufferUtils::asVImageBuffer(a2, 0, *v13, &__p);
          PixelBufferUtils::asVImageBuffer(this, (__CVBuffer *)1, *v13, &__p);
          PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, *v13, &__p);
          PixelBufferUtils::asVImageBuffer(this, (__CVBuffer *)2, *v13, &__p);
          vImage_Buffer v535 = __p;
          PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)2, *v13, &__p);
          vImage_Buffer v534 = __p;
          if (*(_OWORD *)&v535.height == *(_OWORD *)&__p.height)
          {
            if (v535.height && v535.width)
            {
              uint64_t v429 = 0;
              LODWORD(PixelFormatType) = 0;
              double v430 = (float *)v535.data;
              double v431 = (float *)v534.data;
              do
              {
                uint64_t v432 = 0;
                do
                {
                  float v433 = v431[v432];
                  float v434 = v430[v432] - v433;
                  if (v434 > *(float *)a5.i32)
                  {
                    float v435 = v434 / (v433 + 1.0e-22);
                    if (v435 > *(float *)a4.i32) {
                      LODWORD(PixelFormatType) = PixelFormatType + 1;
                    }
                  }
                  ++v432;
                }
                while (v535.width > v432);
                ++v429;
                double v431 = (float *)((char *)v431 + v534.rowBytes);
                double v430 = (float *)((char *)v430 + v535.rowBytes);
              }
              while (v535.height > v429);
              goto LABEL_261;
            }
            goto LABEL_226;
          }
          goto LABEL_261;
        }
        if (PixelFormatType != 1919365992) {
          goto LABEL_221;
        }
        PixelBufferUtils::asVImageBuffer(this, 0, *v13, &__p);
        PixelBufferUtils::asVImageBuffer(a2, 0, *v13, &__p);
        PixelBufferUtils::asVImageBuffer(this, (__CVBuffer *)1, *v13, &__p);
        PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, *v13, &__p);
        PixelBufferUtils::asVImageBuffer(this, (__CVBuffer *)2, *v13, &__p);
        vImage_Buffer v535 = __p;
        PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)2, *v13, &__p);
        vImage_Buffer v534 = __p;
        if (*(_OWORD *)&v535.height != *(_OWORD *)&__p.height) {
          goto LABEL_261;
        }
        if (!v535.height || !v535.width) {
          goto LABEL_226;
        }
        uint64_t v16 = 0;
        LODWORD(PixelFormatType) = 0;
        if (LODWORD(v535.width)) {
          _ZF = (v535.width - 1) >> 32 == 0;
        }
        else {
          _ZF = 0;
        }
        char v18 = !_ZF;
        vImagePixelCount v19 = 2 * (v535.width & 0xFFFFFFFFFFFFFFF0);
        float32x4_t v20 = (float32x4_t)vdupq_lane_s32(a5, 0);
        float32x4_t v21 = (float32x4_t)vdupq_lane_s32(a4, 0);
        unint64_t v22 = (float16x4_t *)((char *)v535.data + 16);
        float64x2_t v23 = (float64x2_t)vdupq_n_s64(0x3B5E392010175EE6uLL);
        unint64_t v24 = (float16x4_t *)((char *)v534.data + 16);
        v25.i64[0] = 0x100000001;
        v25.i64[1] = 0x100000001;
        while (1)
        {
          vImagePixelCount v48 = (__int16 *)((char *)v535.data + v16 * v535.rowBytes);
          uint64_t v49 = (__int16 *)((char *)v534.data + v16 * v534.rowBytes);
          if (v535.width < 0x10 || (v18 & 1) != 0) {
            break;
          }
          uint64_t v49 = (__int16 *)((char *)v49 + v19);
          int32x4_t v62 = (int32x4_t)PixelFormatType;
          int32x4_t v63 = 0uLL;
          size_t v64 = v24;
          vImagePixelCount v65 = v22;
          vImagePixelCount v66 = v535.width & 0xFFFFFFFFFFFFFFF0;
          int32x4_t v67 = 0uLL;
          int32x4_t v68 = 0uLL;
          do
          {
            _Q17 = *(float16x8_t *)v65[-2].i8;
            float32x4_t v70 = vcvt_hight_f32_f16(_Q17);
            float32x4_t v71 = vcvtq_f32_f16(*(float16x4_t *)_Q17.i8);
            _Q26 = *(float16x8_t *)v64[-2].i8;
            _Q20 = *(float64x2_t *)v64->i8;
            _D27 = vextq_s8((int8x16_t)_Q26, (int8x16_t)_Q26, 8uLL).u64[0];
            _Q17.i64[0] = vextq_s8((int8x16_t)_Q20, (int8x16_t)_Q20, 8uLL).u64[0];
            float32x4_t v75 = vsubq_f32(v71, vcvtq_f32_f16(*(float16x4_t *)_Q26.i8));
            _Q30 = (float64x2_t)vsubq_f32(v70, vcvt_hight_f32_f16(_Q26));
            float32x4_t v77 = vsubq_f32(vcvtq_f32_f16(*v65), vcvtq_f32_f16(*v64));
            float32x4_t v78 = vsubq_f32(vcvt_hight_f32_f16(*(float16x8_t *)v65->i8), vcvt_hight_f32_f16(*(float16x8_t *)v64->i8));
            int16x8_t v79 = (int16x8_t)vcgtq_f32((float32x4_t)_Q30, v20);
            float64x2_t v80 = vcvtq_f64_f32(*(float32x2_t *)&_Q30.f64[0]);
            _H25 = HIWORD(*(void *)&v64[-2]);
            __asm { FCVT            D31, H25 }
            _H8 = WORD2(*(void *)&v64[-2]);
            float64x2_t v84 = vcvt_hight_f64_f32((float32x4_t)_Q30);
            __asm { FCVT            D30, H8 }
            _Q30.f64[1] = _D31;
            LOWORD(_D31) = _Q26.i16[1];
            __asm
            {
              FCVT            D31, H31
              FCVT            D26, H26
            }
            _Q26.i64[1] = _D31;
            LOWORD(_D31) = HIWORD(_D27);
            __asm { FCVT            D31, H31 }
            _H9 = WORD2(_D27);
            __asm { FCVT            D9, H9 }
            _H10 = WORD1(_D27);
            __asm { FCVT            D10, H10 }
            _Q9.f64[1] = _D31;
            __asm { FCVT            D27, H27 }
            LOWORD(_D31) = HIWORD(*(unint64_t *)v64);
            __asm { FCVT            D31, H31 }
            _H11 = WORD2(*(unint64_t *)v64);
            __asm { FCVT            D11, H11 }
            _Q11.f64[1] = _D31;
            LOWORD(_D31) = WORD1(*(_OWORD *)v64->i8);
            __asm
            {
              FCVT            D31, H31
              FCVT            D20, H20
            }
            _Q20.f64[1] = _D31;
            LOWORD(_D31) = _Q17.i16[3];
            __asm { FCVT            D31, H31 }
            _Q27.f64[1] = _D10;
            LOWORD(_D10) = _Q17.i16[2];
            __asm { FCVT            D10, H10 }
            _Q10.f64[1] = _D31;
            LOWORD(_D31) = _Q17.i16[1];
            __asm
            {
              FCVT            D24, H31
              FCVT            D17, H17
            }
            _Q17.i64[1] = _D24;
            *(int8x8_t *)&v80.f64[0] = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v75, v20), v79), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v75.f32), vaddq_f64((float64x2_t)_Q26, v23))), vdivq_f64(vcvt_hight_f64_f32(v75), vaddq_f64(_Q30, v23))), v21), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v80, vaddq_f64(_Q27, v23))), vdivq_f64(v84, vaddq_f64(_Q9, v23))), v21))));
            *(int8x8_t *)_Q17.i8 = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v77, v20), (int16x8_t)vcgtq_f32(v78, v20)), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v77.f32), vaddq_f64(_Q20, v23))), vdivq_f64(vcvt_hight_f64_f32(v77), vaddq_f64(_Q11, v23))), v21), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v78.f32),
                                                                                                     vaddq_f64((float64x2_t)_Q17, v23))),
                                                                                      vdivq_f64(vcvt_hight_f64_f32(v78), vaddq_f64(_Q10, v23))), v21))));
            int32x4_t v63 = vaddq_s32(v63, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)&v80.f64[0], *(int8x8_t *)v20.f32)), v25));
            int32x4_t v62 = vaddq_s32(v62, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)&v80.f64[0], *(int8x8_t *)v20.f32)), v25));
            int32x4_t v68 = vaddq_s32(v68, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)_Q17.i8, *(int8x8_t *)v20.f32)), v25));
            int32x4_t v67 = vaddq_s32(v67, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)_Q17.i8, *(int8x8_t *)v20.f32)), v25));
            v65 += 4;
            v64 += 4;
            v66 -= 16;
          }
          while (v66);
          LODWORD(PixelFormatType) = vaddvq_s32(vaddq_s32(vaddq_s32(v67, v62), vaddq_s32(v68, v63)));
          if (v535.width != (v535.width & 0xFFFFFFFFFFFFFFF0))
          {
            vImagePixelCount v48 = (__int16 *)((char *)v48 + v19);
            unsigned int v50 = v535.width & 0xFFFFFFF0;
LABEL_55:
            unsigned int v51 = v50 + 1;
            do
            {
              _H5 = *v48;
              __asm { FCVT            S6, H5 }
              _H5 = *v49;
              __asm { FCVT            S7, H5 }
              float v60 = _S6 - _S7;
              if (v60 > *(float *)a5.i32)
              {
                __asm { FCVT            D5, H5 }
                *(float *)&_D5 = v60 / (_D5 + 1.0e-22);
                if (*(float *)&_D5 > *(float *)a4.i32) {
                  LODWORD(PixelFormatType) = PixelFormatType + 1;
                }
              }
              ++v48;
              ++v49;
              BOOL v52 = v535.width > v51++;
            }
            while (v52);
          }
          ++v16;
          unint64_t v22 = (float16x4_t *)((char *)v22 + v535.rowBytes);
          unint64_t v24 = (float16x4_t *)((char *)v24 + v534.rowBytes);
          if (v535.height <= v16) {
            goto LABEL_261;
          }
        }
        unsigned int v50 = 0;
        goto LABEL_55;
      }
LABEL_177:
      if (*(_OWORD *)&v535.height != *(_OWORD *)&v534.height) {
        goto LABEL_261;
      }
      if (!v535.height || !v535.width) {
        goto LABEL_226;
      }
      uint64_t v372 = 0;
      LODWORD(PixelFormatType) = 0;
      if (LODWORD(v535.width)) {
        BOOL v373 = (v535.width - 1) >> 32 == 0;
      }
      else {
        BOOL v373 = 0;
      }
      char v374 = !v373;
      vImagePixelCount v375 = 2 * (v535.width & 0xFFFFFFFFFFFFFFF0);
      float32x4_t v376 = (float32x4_t)vdupq_lane_s32(v14, 0);
      float32x4_t v377 = (float32x4_t)vdupq_lane_s32(v15, 0);
      float64x2_t v378 = (float16x4_t *)((char *)v535.data + 16);
      float64x2_t v379 = (float64x2_t)vdupq_n_s64(0x3B5E392010175EE6uLL);
      float64x2_t v380 = (float16x4_t *)((char *)v534.data + 16);
      v381.i64[0] = 0x100000001;
      v381.i64[1] = 0x100000001;
      while (1)
      {
        float64x2_t v382 = (__int16 *)((char *)v535.data + v372 * v535.rowBytes);
        float64x2_t v383 = (__int16 *)((char *)v534.data + v372 * v534.rowBytes);
        if (v535.width < 0x10 || (v374 & 1) != 0) {
          break;
        }
        float64x2_t v383 = (__int16 *)((char *)v383 + v375);
        int32x4_t v392 = (int32x4_t)PixelFormatType;
        int32x4_t v393 = 0uLL;
        float64x2_t v394 = v380;
        float64x2_t v395 = v378;
        vImagePixelCount v396 = v535.width & 0xFFFFFFFFFFFFFFF0;
        int32x4_t v397 = 0uLL;
        int32x4_t v398 = 0uLL;
        do
        {
          _Q17 = *(float16x8_t *)v395[-2].i8;
          float32x4_t v400 = vcvt_hight_f32_f16(_Q17);
          float32x4_t v401 = vcvtq_f32_f16(*(float16x4_t *)_Q17.i8);
          _Q26 = *(float16x8_t *)v394[-2].i8;
          _Q20 = *(float64x2_t *)v394->i8;
          _D27 = vextq_s8((int8x16_t)_Q26, (int8x16_t)_Q26, 8uLL).u64[0];
          _Q17.i64[0] = vextq_s8((int8x16_t)_Q20, (int8x16_t)_Q20, 8uLL).u64[0];
          float32x4_t v405 = vsubq_f32(v401, vcvtq_f32_f16(*(float16x4_t *)_Q26.i8));
          _Q30 = (float64x2_t)vsubq_f32(v400, vcvt_hight_f32_f16(_Q26));
          float32x4_t v407 = vsubq_f32(vcvtq_f32_f16(*v395), vcvtq_f32_f16(*v394));
          float32x4_t v408 = vsubq_f32(vcvt_hight_f32_f16(*(float16x8_t *)v395->i8), vcvt_hight_f32_f16(*(float16x8_t *)v394->i8));
          int16x8_t v409 = (int16x8_t)vcgtq_f32((float32x4_t)_Q30, v376);
          float64x2_t v410 = vcvtq_f64_f32(*(float32x2_t *)&_Q30.f64[0]);
          _H25 = HIWORD(*(void *)&v394[-2]);
          __asm { FCVT            D31, H25 }
          _H8 = WORD2(*(void *)&v394[-2]);
          float64x2_t v414 = vcvt_hight_f64_f32((float32x4_t)_Q30);
          __asm { FCVT            D30, H8 }
          _Q30.f64[1] = _D31;
          LOWORD(_D31) = _Q26.i16[1];
          __asm
          {
            FCVT            D31, H31
            FCVT            D26, H26
          }
          _Q26.i64[1] = _D31;
          LOWORD(_D31) = HIWORD(_D27);
          __asm { FCVT            D31, H31 }
          _H9 = WORD2(_D27);
          __asm { FCVT            D9, H9 }
          _H10 = WORD1(_D27);
          __asm { FCVT            D10, H10 }
          _Q9.f64[1] = _D31;
          __asm { FCVT            D27, H27 }
          LOWORD(_D31) = HIWORD(*(unint64_t *)v394);
          __asm { FCVT            D31, H31 }
          _H11 = WORD2(*(unint64_t *)v394);
          __asm { FCVT            D11, H11 }
          _Q11.f64[1] = _D31;
          LOWORD(_D31) = WORD1(*(_OWORD *)v394->i8);
          __asm
          {
            FCVT            D31, H31
            FCVT            D20, H20
          }
          _Q20.f64[1] = _D31;
          LOWORD(_D31) = _Q17.i16[3];
          __asm { FCVT            D31, H31 }
          _Q27.f64[1] = _D10;
          LOWORD(_D10) = _Q17.i16[2];
          __asm { FCVT            D10, H10 }
          _Q10.f64[1] = _D31;
          LOWORD(_D31) = _Q17.i16[1];
          __asm
          {
            FCVT            D24, H31
            FCVT            D17, H17
          }
          _Q17.i64[1] = _D24;
          *(int8x8_t *)&v410.f64[0] = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v405, v376), v409), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v405.f32), vaddq_f64((float64x2_t)_Q26, v379))), vdivq_f64(vcvt_hight_f64_f32(v405), vaddq_f64(_Q30, v379))), v377), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v410, vaddq_f64(_Q27, v379))), vdivq_f64(v414, vaddq_f64(_Q9, v379))), v377))));
          *(int8x8_t *)_Q17.i8 = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v407, v376), (int16x8_t)vcgtq_f32(v408, v376)), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v407.f32), vaddq_f64(_Q20, v379))), vdivq_f64(vcvt_hight_f64_f32(v407), vaddq_f64(_Q11, v379))), v377), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v408.f32),
                                                                                                   vaddq_f64((float64x2_t)_Q17, v379))), vdivq_f64(vcvt_hight_f64_f32(v408), vaddq_f64(_Q10, v379))), v377))));
          int32x4_t v393 = vaddq_s32(v393, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)&v410.f64[0], *(int8x8_t *)v376.f32)), v381));
          int32x4_t v392 = vaddq_s32(v392, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)&v410.f64[0], *(int8x8_t *)v376.f32)), v381));
          int32x4_t v398 = vaddq_s32(v398, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)_Q17.i8, *(int8x8_t *)v376.f32)), v381));
          int32x4_t v397 = vaddq_s32(v397, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)_Q17.i8, *(int8x8_t *)v376.f32)), v381));
          v395 += 4;
          v394 += 4;
          v396 -= 16;
        }
        while (v396);
        LODWORD(PixelFormatType) = vaddvq_s32(vaddq_s32(vaddq_s32(v397, v392), vaddq_s32(v398, v393)));
        if (v535.width != (v535.width & 0xFFFFFFFFFFFFFFF0))
        {
          float64x2_t v382 = (__int16 *)((char *)v382 + v375);
          unsigned int v384 = v535.width & 0xFFFFFFF0;
LABEL_191:
          unsigned int v385 = v384 + 1;
          do
          {
            _H5 = *v382;
            __asm { FCVT            S6, H5 }
            _H5 = *v383;
            __asm { FCVT            S7, H5 }
            float v390 = _S6 - _S7;
            if (v390 > *(float *)v14.i32)
            {
              __asm { FCVT            D5, H5 }
              *(float *)&_D5 = v390 / (_D5 + 1.0e-22);
              if (*(float *)&_D5 > *(float *)v15.i32) {
                LODWORD(PixelFormatType) = PixelFormatType + 1;
              }
            }
            ++v382;
            ++v383;
            BOOL v52 = v535.width > v385++;
          }
          while (v52);
        }
        ++v372;
        float64x2_t v378 = (float16x4_t *)((char *)v378 + v535.rowBytes);
        float64x2_t v380 = (float16x4_t *)((char *)v380 + v534.rowBytes);
        if (v535.height <= v372) {
          goto LABEL_261;
        }
      }
      unsigned int v384 = 0;
      goto LABEL_191;
    }
    if ((int)PixelFormatType > 1647392358)
    {
      if (PixelFormatType != 1647392359)
      {
        int v193 = 1717855600;
LABEL_166:
        if (PixelFormatType == v193) {
          goto LABEL_167;
        }
LABEL_221:
        PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&__p);
        if ((__p.width & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (vImage_Buffer *)__p.data;
        }
        NSLog(&cfstr_SDErrorPixelFo.isa, "countDifferentPixels", 2363, PixelFormatType, p_p);
        if (SHIBYTE(__p.width) < 0) {
          operator delete(__p.data);
        }
        goto LABEL_226;
      }
      goto LABEL_177;
    }
    if (PixelFormatType == 1380410945)
    {
      if (*(_OWORD *)&v535.height == *(_OWORD *)&v534.height)
      {
        if (v535.height && 4 * v535.width)
        {
          uint64_t v436 = 0;
          LODWORD(PixelFormatType) = 0;
          uint64_t v437 = (float *)v535.data;
          uint64_t v438 = (float *)v534.data;
          do
          {
            uint64_t v439 = 0;
            do
            {
              float v440 = v438[v439];
              float v441 = v437[v439] - v440;
              if (v441 > *(float *)a5.i32)
              {
                float v442 = v441 / (v440 + 1.0e-22);
                if (v442 > *(float *)a4.i32) {
                  LODWORD(PixelFormatType) = PixelFormatType + 1;
                }
              }
              ++v439;
            }
            while (4 * v535.width > v439);
            ++v436;
            uint64_t v438 = (float *)((char *)v438 + v534.rowBytes);
            uint64_t v437 = (float *)((char *)v437 + v535.rowBytes);
          }
          while (v535.height > v436);
          goto LABEL_261;
        }
        goto LABEL_226;
      }
      goto LABEL_261;
    }
    if (PixelFormatType != 1380411457) {
      goto LABEL_221;
    }
    if (*(_OWORD *)&v535.height != *(_OWORD *)&v534.height) {
      goto LABEL_261;
    }
    if (!v535.height) {
      goto LABEL_226;
    }
    vImagePixelCount v37 = 4 * v535.width;
    if (!(4 * v535.width)) {
      goto LABEL_226;
    }
    uint64_t v38 = 0;
    LODWORD(PixelFormatType) = 0;
    if (v37) {
      BOOL v39 = (v37 - 1) >> 32 == 0;
    }
    else {
      BOOL v39 = 0;
    }
    char v40 = !v39;
    unint64_t v41 = 2 * (v37 & 0xFFFFFFFFFFFFFFF0);
    float32x4_t v42 = (float32x4_t)vdupq_lane_s32(a5, 0);
    float32x4_t v43 = (float32x4_t)vdupq_lane_s32(a4, 0);
    unint64_t v44 = (float16x4_t *)((char *)v535.data + 16);
    float64x2_t v45 = (float64x2_t)vdupq_n_s64(0x3B5E392010175EE6uLL);
    uint64_t v46 = (float16x4_t *)((char *)v534.data + 16);
    v47.i64[0] = 0x100000001;
    v47.i64[1] = 0x100000001;
    while (1)
    {
      float64x2_t v146 = (__int16 *)((char *)v535.data + v38 * v535.rowBytes);
      float64x2_t v147 = (__int16 *)((char *)v534.data + v38 * v534.rowBytes);
      if (v37 < 0x10 || (v40 & 1) != 0) {
        break;
      }
      float64x2_t v147 = (__int16 *)((char *)v147 + v41);
      int32x4_t v156 = (int32x4_t)PixelFormatType;
      int32x4_t v157 = 0uLL;
      float64x2_t v158 = v46;
      float64x2_t v159 = v44;
      unint64_t v160 = v37 & 0xFFFFFFFFFFFFFFF0;
      int32x4_t v161 = 0uLL;
      int32x4_t v162 = 0uLL;
      do
      {
        _Q17 = *(float16x8_t *)v159[-2].i8;
        float32x4_t v164 = vcvt_hight_f32_f16(_Q17);
        float32x4_t v165 = vcvtq_f32_f16(*(float16x4_t *)_Q17.i8);
        _Q26 = *(float16x8_t *)v158[-2].i8;
        _Q20 = *(float64x2_t *)v158->i8;
        _D27 = vextq_s8((int8x16_t)_Q26, (int8x16_t)_Q26, 8uLL).u64[0];
        _Q17.i64[0] = vextq_s8((int8x16_t)_Q20, (int8x16_t)_Q20, 8uLL).u64[0];
        float32x4_t v169 = vsubq_f32(v165, vcvtq_f32_f16(*(float16x4_t *)_Q26.i8));
        _Q30 = (float64x2_t)vsubq_f32(v164, vcvt_hight_f32_f16(_Q26));
        float32x4_t v171 = vsubq_f32(vcvtq_f32_f16(*v159), vcvtq_f32_f16(*v158));
        float32x4_t v172 = vsubq_f32(vcvt_hight_f32_f16(*(float16x8_t *)v159->i8), vcvt_hight_f32_f16(*(float16x8_t *)v158->i8));
        int16x8_t v173 = (int16x8_t)vcgtq_f32((float32x4_t)_Q30, v42);
        float64x2_t v174 = vcvtq_f64_f32(*(float32x2_t *)&_Q30.f64[0]);
        _H25 = HIWORD(*(void *)&v158[-2]);
        __asm { FCVT            D31, H25 }
        _H8 = WORD2(*(void *)&v158[-2]);
        float64x2_t v178 = vcvt_hight_f64_f32((float32x4_t)_Q30);
        __asm { FCVT            D30, H8 }
        _Q30.f64[1] = _D31;
        LOWORD(_D31) = _Q26.i16[1];
        __asm
        {
          FCVT            D31, H31
          FCVT            D26, H26
        }
        _Q26.i64[1] = _D31;
        LOWORD(_D31) = HIWORD(_D27);
        __asm { FCVT            D31, H31 }
        _H9 = WORD2(_D27);
        __asm { FCVT            D9, H9 }
        _H10 = WORD1(_D27);
        __asm { FCVT            D10, H10 }
        _Q9.f64[1] = _D31;
        __asm { FCVT            D27, H27 }
        LOWORD(_D31) = HIWORD(*(unint64_t *)v158);
        __asm { FCVT            D31, H31 }
        _H11 = WORD2(*(unint64_t *)v158);
        __asm { FCVT            D11, H11 }
        _Q11.f64[1] = _D31;
        LOWORD(_D31) = WORD1(*(_OWORD *)v158->i8);
        __asm
        {
          FCVT            D31, H31
          FCVT            D20, H20
        }
        _Q20.f64[1] = _D31;
        LOWORD(_D31) = _Q17.i16[3];
        __asm { FCVT            D31, H31 }
        _Q27.f64[1] = _D10;
        LOWORD(_D10) = _Q17.i16[2];
        __asm { FCVT            D10, H10 }
        _Q10.f64[1] = _D31;
        LOWORD(_D31) = _Q17.i16[1];
        __asm
        {
          FCVT            D24, H31
          FCVT            D17, H17
        }
        _Q17.i64[1] = _D24;
        *(int8x8_t *)&v174.f64[0] = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v169, v42), v173), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v169.f32), vaddq_f64((float64x2_t)_Q26, v45))), vdivq_f64(vcvt_hight_f64_f32(v169), vaddq_f64(_Q30, v45))), v43), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(v174, vaddq_f64(_Q27, v45))), vdivq_f64(v178, vaddq_f64(_Q9, v45))), v43))));
        *(int8x8_t *)_Q17.i8 = vmovn_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(v171, v42), (int16x8_t)vcgtq_f32(v172, v42)), (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v171.f32), vaddq_f64(_Q20, v45))), vdivq_f64(vcvt_hight_f64_f32(v171), vaddq_f64(_Q11, v45))), v43), (int16x8_t)vcgtq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)v172.f32),
                                                                                                 vaddq_f64((float64x2_t)_Q17, v45))), vdivq_f64(vcvt_hight_f64_f32(v172), vaddq_f64(_Q10, v45))), v43))));
        int32x4_t v157 = vaddq_s32(v157, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)&v174.f64[0], *(int8x8_t *)v42.f32)), v47));
        int32x4_t v156 = vaddq_s32(v156, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)&v174.f64[0], *(int8x8_t *)v42.f32)), v47));
        int32x4_t v162 = vaddq_s32(v162, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)_Q17.i8, *(int8x8_t *)v42.f32)), v47));
        int32x4_t v161 = vaddq_s32(v161, (int32x4_t)vandq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)_Q17.i8, *(int8x8_t *)v42.f32)), v47));
        v159 += 4;
        v158 += 4;
        v160 -= 16;
      }
      while (v160);
      LODWORD(PixelFormatType) = vaddvq_s32(vaddq_s32(vaddq_s32(v161, v156), vaddq_s32(v162, v157)));
      if (v37 != (v37 & 0xFFFFFFFFFFFFFFF0))
      {
        float64x2_t v146 = (__int16 *)((char *)v146 + v41);
        int v148 = v37 & 0xFFFFFFF0;
LABEL_83:
        unsigned int v149 = v148 + 1;
        do
        {
          _H5 = *v146;
          __asm { FCVT            S6, H5 }
          _H5 = *v147;
          __asm { FCVT            S7, H5 }
          float v154 = _S6 - _S7;
          if (v154 > *(float *)a5.i32)
          {
            __asm { FCVT            D5, H5 }
            *(float *)&_D5 = v154 / (_D5 + 1.0e-22);
            if (*(float *)&_D5 > *(float *)a4.i32) {
              LODWORD(PixelFormatType) = PixelFormatType + 1;
            }
          }
          ++v146;
          ++v147;
          BOOL v52 = v37 > v149++;
        }
        while (v52);
      }
      ++v38;
      unint64_t v44 = (float16x4_t *)((char *)v44 + v535.rowBytes);
      uint64_t v46 = (float16x4_t *)((char *)v46 + v534.rowBytes);
      if (v535.height <= v38) {
        goto LABEL_261;
      }
    }
    int v148 = 0;
    goto LABEL_83;
  }
  return result;
}

void sub_215FB14F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CVBuffer *PixelBufferUtils::errorsPixelBuffer(PixelBufferUtils *this, __CVBuffer *a2, __CVBuffer *a3)
{
  return PixelBufferUtils::errorsPixelBuffer(this, a2, 0, 1);
}

__CVBuffer *PixelBufferUtils::errorsPixelBuffer(PixelBufferUtils *this, __CVBuffer *a2, __CVBuffer *a3, int a4)
{
  char v5 = (char)a3;
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  if (PixelFormatType == CVPixelBufferGetPixelFormatType(a2))
  {
    size_t Width = CVPixelBufferGetWidth(this);
    if (Width == CVPixelBufferGetWidth(a2))
    {
      size_t Height = CVPixelBufferGetHeight(this);
      if (Height == CVPixelBufferGetHeight(a2))
      {
        unint64_t v11 = CVPixelBufferGetPixelFormatType(this);
        size_t v12 = CVPixelBufferGetWidth(this);
        size_t v13 = CVPixelBufferGetHeight(this);
        pixelBufferOut.data = 0;
        CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
        CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
        if (CVPixelBufferCreate(v14, v12, v13, v11, BufferAttributes, (CVPixelBufferRef *)&pixelBufferOut)) {
          data = 0;
        }
        else {
          data = (__CVBuffer *)pixelBufferOut.data;
        }
        CVPixelBufferLockBaseAddress(this, 1uLL);
        CVPixelBufferLockBaseAddress(a2, 1uLL);
        CVPixelBufferLockBaseAddress(data, 0);
        memset(&pixelBufferOut, 0, sizeof(pixelBufferOut));
        long long v17 = (CGRect *)MEMORY[0x263F001A8];
        PixelBufferUtils::asVImageBuffer(this, *MEMORY[0x263F001A8], &pixelBufferOut);
        memset(&v241, 0, sizeof(v241));
        PixelBufferUtils::asVImageBuffer(a2, *v17, &v241);
        memset(&v240, 0, sizeof(v240));
        PixelBufferUtils::asVImageBuffer(data, *v17, &v240);
        pixelBuffer = this;
        double v191 = a2;
        float64x2x2_t v189 = data;
        if ((int)v11 > 1278226535)
        {
          if ((int)v11 <= 1717855599)
          {
            if ((int)v11 <= 1380410944)
            {
              if (v11 != 1278226536)
              {
                int v20 = 1380401729;
                goto LABEL_18;
              }
              goto LABEL_37;
            }
            if (v11 == 1380410945)
            {
              calcDiffsRaw<float>((float32x4_t **)&pixelBufferOut, (float32x4_t *)v241.data, v241.rowBytes, (float32x4_t *)v240.data, v240.rowBytes, v5, a4);
              goto LABEL_95;
            }
            int v28 = 1647392359;
            goto LABEL_36;
          }
          if ((int)v11 > 1751410031)
          {
            if (v11 == 1751410032) {
              goto LABEL_37;
            }
            int v28 = 1751411059;
LABEL_36:
            if (v11 == v28)
            {
LABEL_37:
              vImagePixelCount v29 = pixelBufferOut.height;
              if (!pixelBufferOut.height) {
                goto LABEL_95;
              }
              vImagePixelCount v30 = pixelBufferOut.width;
              if (!pixelBufferOut.width) {
                goto LABEL_95;
              }
              size_t rowBytes = v241.rowBytes;
              float32x4_t v32 = (char *)pixelBufferOut.data;
              size_t v33 = pixelBufferOut.rowBytes;
              size_t v35 = v240.rowBytes;
              float64x2_t v34 = (char *)v241.data;
              int8x16_t v36 = (char *)v240.data;
              double v37 = (double)a4;
              if (LODWORD(pixelBufferOut.width)) {
                _ZF = (pixelBufferOut.width - 1) >> 32 == 0;
              }
              else {
                _ZF = 0;
              }
              char v39 = !_ZF;
              char v185 = v39;
              vImagePixelCount v184 = pixelBufferOut.width & 0xFFFFFFFFFFFFFFF8;
              vImagePixelCount v182 = pixelBufferOut.height;
              vImagePixelCount v183 = 2 * (pixelBufferOut.width & 0xFFFFFFFFFFFFFFF8);
              long long v181 = (char *)pixelBufferOut.data;
              size_t v187 = pixelBufferOut.rowBytes;
              size_t v201 = v241.rowBytes;
              int8x16_t v203 = (char *)v241.data;
              size_t v197 = v240.rowBytes;
              float32x4_t v199 = (char *)v240.data;
              if (v5)
              {
                uint64_t v40 = 0;
                float64x2_t v205 = (float64x2_t)vdupq_n_s64(0x3BC79CA10C924223uLL);
                unint64_t v41 = pixelBufferOut.data;
                float32x4_t v42 = v241.data;
                float32x4_t v43 = (float16x8_t *)v240.data;
                unint64_t v44 = (char *)pixelBufferOut.data;
                while (1)
                {
                  float64x2_t v45 = (short float *)&v36[v35 * v40];
                  uint64_t v46 = &v44[v33 * v40];
                  int8x16_t v47 = &v34[rowBytes * v40];
                  double v192 = v42;
                  vImagePixelCount v194 = v41;
                  if (v30 >= 8
                    && (v185 & 1) == 0
                    && ((unint64_t)((char *)v45 - v46) >= 0x10
                      ? (_CF = (unint64_t)((char *)v45 - v47) >= 0x10)
                      : (_CF = 0),
                        _CF))
                  {
                    unint64_t v62 = v30 & 0xFFFFFFFFFFFFFFF8;
                    v47 += v183;
                    int32x4_t v63 = (float16x8_t *)v41;
                    size_t v64 = (float16x8_t *)v42;
                    vImagePixelCount v65 = v43;
                    do
                    {
                      float16x8_t v66 = *v63++;
                      float16x8_t v67 = v66;
                      float32x4_t v68 = vcvtq_f32_f16(*(float16x4_t *)v66.i8);
                      float16x8_t v69 = *v64++;
                      _Q2 = (float64x2_t)v69;
                      _D3 = vextq_s8((int8x16_t)_Q2, (int8x16_t)_Q2, 8uLL).u64[0];
                      _H6 = WORD1(_D3);
                      __asm
                      {
                        FCVT            D6, H6
                        FCVT            D7, H3
                      }
                      _Q7.f64[1] = _D6;
                      LOWORD(_D6) = HIWORD(_D3);
                      __asm { FCVT            D6, H6 }
                      LOWORD(_D3) = WORD2(_D3);
                      __asm { FCVT            D3, H3 }
                      _Q3.f64[1] = _D6;
                      LOWORD(_D6) = v69.i16[1];
                      __asm
                      {
                        FCVT            D6, H6
                        FCVT            D16, H2
                      }
                      _Q16.f64[1] = _D6;
                      LOWORD(_D6) = v69.i16[3];
                      __asm { FCVT            D6, H6 }
                      LOWORD(_Q2.f64[0]) = v69.i16[2];
                      __asm { FCVT            D2, H2 }
                      _Q2.f64[1] = _D6;
                      float32x4_t v80 = vdivq_f32(vsubq_f32(vcvtq_f32_f16(*(float16x4_t *)v69.i8), v68), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(_Q16, v205)), vaddq_f64(_Q2, v205)));
                      float32x4_t v81 = vdivq_f32(vsubq_f32(vcvt_hight_f32_f16(v69), vcvt_hight_f32_f16(v67)), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(_Q7, v205)), vaddq_f64(_Q3, v205)));
                      float64x2_t v234 = vcvt_hight_f64_f32(v81);
                      float64x2_t __x = vcvt_hight_f64_f32(v80);
                      float64x2_t v230 = vcvtq_f64_f32(*(float32x2_t *)v81.f32);
                      float64x2_t v218 = vcvtq_f64_f32(*(float32x2_t *)v80.f32);
                      long double v222 = pow(v218.f64[0], v37);
                      v218.f64[0] = pow(v218.f64[1], v37);
                      long double v215 = pow(__x.f64[0], v37);
                      long double v212 = pow(__x.f64[1], v37);
                      __x.f64[0] = pow(v230.f64[0], v37);
                      v230.f64[0] = pow(v230.f64[1], v37);
                      long double v208 = pow(v234.f64[0], v37);
                      long double v82 = pow(v234.f64[1], v37);
                      v83.f64[0] = v215;
                      v83.f64[1] = v212;
                      v84.f64[0] = v222;
                      v84.f64[1] = v218.f64[0];
                      v85.f64[0] = v208;
                      v85.f64[1] = v82;
                      v86.f64[0] = __x.f64[0];
                      v86.f64[1] = v230.f64[0];
                      *v65++ = vabsq_f16(vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v84), v83)), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v86), v85)));
                      v62 -= 8;
                    }
                    while (v62);
                    unint64_t v44 = v181;
                    vImagePixelCount v29 = v182;
                    size_t v33 = v187;
                    if (v30 == v184) {
                      goto LABEL_56;
                    }
                    v46 += v183;
                    float64x2_t v45 = (short float *)((char *)v45 + v183);
                    int v49 = v184;
                  }
                  else
                  {
                    int v49 = 0;
                  }
                  unsigned int v50 = v49 + 1;
                  do
                  {
                    __int16 v51 = *(_WORD *)v46;
                    v46 += 2;
                    _H0 = v51;
                    __asm { FCVT            S0, H0 }
                    __int16 v56 = *(_WORD *)v47;
                    v47 += 2;
                    _H1 = v56;
                    __asm
                    {
                      FCVT            S2, H1
                      FCVT            D1, H1
                    }
                    *(float *)&_D1 = _D1 + 1.0e-20;
                    _S0 = pow((float)((float)(_S2 - _S0) / *(float *)&_D1), v37);
                    __asm { FCVT            H0, S0 }
                    *v45++ = fabsl(*(short float *)&_S0);
                    BOOL v61 = v30 > v50++;
                  }
                  while (v61);
LABEL_56:
                  ++v40;
                  size_t v35 = v197;
                  float32x4_t v43 = (float16x8_t *)((char *)v43 + v197);
                  size_t rowBytes = v201;
                  float64x2_t v34 = v203;
                  float32x4_t v42 = (_OWORD *)((char *)v192 + v201);
                  unint64_t v41 = (_OWORD *)((char *)v194 + v33);
                  int8x16_t v36 = v199;
                  if (v29 <= v40) {
                    goto LABEL_95;
                  }
                }
              }
              uint64_t v125 = 0;
              int16x8_t v126 = (float16x8_t *)pixelBufferOut.data;
              float64x2_t v127 = v241.data;
              double v128 = (float16x8_t *)v240.data;
              while (1)
              {
                double v129 = (short float *)&v36[v35 * v125];
                double v130 = &v32[v33 * v125];
                float64x2_t v131 = &v34[rowBytes * v125];
                float64x2_t v207 = v127;
                if (v30 >= 8
                  && (v185 & 1) == 0
                  && ((unint64_t)((char *)v129 - v130) >= 0x10
                    ? (BOOL v132 = (unint64_t)((char *)v129 - v131) >= 0x10)
                    : (BOOL v132 = 0),
                      v132))
                {
                  v131 += v183;
                  BOOL v196 = v126;
                  float64x2_t v142 = v126;
                  float64x2_t v143 = (float16x8_t *)v127;
                  float64x2_t v144 = v128;
                  unint64_t v145 = v30 & 0xFFFFFFFFFFFFFFF8;
                  do
                  {
                    float16x8_t v146 = *v142++;
                    float32x4_t v147 = vcvt_hight_f32_f16(v146);
                    float32x4_t v148 = vcvtq_f32_f16(*(float16x4_t *)v146.i8);
                    float16x8_t v149 = *v143++;
                    float32x4_t v150 = vsubq_f32(vcvtq_f32_f16(*(float16x4_t *)v149.i8), v148);
                    float32x4_t v151 = vsubq_f32(vcvt_hight_f32_f16(v149), v147);
                    float64x2_t v236 = vcvt_hight_f64_f32(v151);
                    float64x2_t __xb = vcvt_hight_f64_f32(v150);
                    float64x2_t v232 = vcvtq_f64_f32(*(float32x2_t *)v151.f32);
                    float64x2_t v220 = vcvtq_f64_f32(*(float32x2_t *)v150.f32);
                    long double v224 = pow(v220.f64[0], v37);
                    v220.f64[0] = pow(v220.f64[1], v37);
                    long double v217 = pow(__xb.f64[0], v37);
                    long double v214 = pow(__xb.f64[1], v37);
                    __xb.f64[0] = pow(v232.f64[0], v37);
                    v232.f64[0] = pow(v232.f64[1], v37);
                    long double v210 = pow(v236.f64[0], v37);
                    long double v152 = pow(v236.f64[1], v37);
                    v153.f64[0] = v217;
                    v153.f64[1] = v214;
                    v154.f64[0] = v224;
                    v154.f64[1] = v220.f64[0];
                    v155.f64[0] = v210;
                    v155.f64[1] = v152;
                    v156.f64[0] = __xb.f64[0];
                    v156.f64[1] = v232.f64[0];
                    *v144++ = vabsq_f16(vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v154), v153)), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v156), v155)));
                    v145 -= 8;
                  }
                  while (v145);
                  float32x4_t v32 = v181;
                  vImagePixelCount v29 = v182;
                  int16x8_t v126 = v196;
                  if (v30 == v184) {
                    goto LABEL_106;
                  }
                  v130 += v183;
                  double v129 = (short float *)((char *)v129 + v183);
                  int v133 = v184;
                }
                else
                {
                  int v133 = 0;
                }
                unsigned int v134 = v133 + 1;
                do
                {
                  __int16 v135 = *(_WORD *)v130;
                  v130 += 2;
                  _H0 = v135;
                  __asm { FCVT            S0, H0 }
                  __int16 v138 = *(_WORD *)v131;
                  v131 += 2;
                  _H1 = v138;
                  __asm { FCVT            S1, H1 }
                  _S0 = pow((float)(_S1 - _S0), v37);
                  __asm { FCVT            H0, S0 }
                  *v129++ = fabsl(*(short float *)&_S0);
                  BOOL v61 = v30 > v134++;
                }
                while (v61);
LABEL_106:
                ++v125;
                size_t v35 = v197;
                int8x16_t v36 = v199;
                double v128 = (float16x8_t *)((char *)v128 + v197);
                size_t rowBytes = v201;
                float64x2_t v34 = v203;
                float64x2_t v127 = (_OWORD *)((char *)v207 + v201);
                size_t v33 = v187;
                int16x8_t v126 = (float16x8_t *)((char *)v126 + v187);
                if (v29 <= v125) {
                  goto LABEL_95;
                }
              }
            }
LABEL_90:
            PixelBufferUtils::pixelFormatAsString(v11, (char *)v238);
            if (v239 >= 0) {
              float32x4_t v124 = v238;
            }
            else {
              float32x4_t v124 = (void **)v238[0];
            }
            NSLog(&cfstr_SDErrorPixelFo.isa, "errorsPixelBuffer", 2434, v11, v124);
            if (v239 < 0) {
              operator delete(v238[0]);
            }
            goto LABEL_95;
          }
          if (v11 == 1717855600) {
            goto LABEL_65;
          }
          int v23 = 1717856627;
          goto LABEL_32;
        }
        if ((int)v11 <= 875704437)
        {
          if (v11 == 32)
          {
LABEL_27:
            calcDiffsRaw<unsigned char>(&pixelBufferOut, &v241, &v240, v5, a4, 4, v18, v19);
            goto LABEL_95;
          }
          if (v11 == 843264104)
          {
            calcDiffsRaw<half>((float16x8_t **)&pixelBufferOut, (float16x8_t *)v241.data, v241.rowBytes, (float16x8_t *)v240.data, v240.rowBytes, v5, a4);
            goto LABEL_95;
          }
          if (v11 != 875704422) {
            goto LABEL_90;
          }
        }
        else
        {
          if ((int)v11 > 1278226487)
          {
            if (v11 == 1278226488)
            {
              calcDiffsRaw<unsigned char>(&pixelBufferOut, &v241, &v240, v5, a4, 1, v18, v19);
LABEL_65:
              vImagePixelCount v87 = pixelBufferOut.height;
              if (!pixelBufferOut.height) {
                goto LABEL_95;
              }
              vImagePixelCount v88 = pixelBufferOut.width;
              if (!pixelBufferOut.width) {
                goto LABEL_95;
              }
              size_t v89 = v241.rowBytes;
              unint64_t v90 = (char *)pixelBufferOut.data;
              size_t v91 = pixelBufferOut.rowBytes;
              size_t v93 = v240.rowBytes;
              char v92 = (char *)v241.data;
              vImagePixelCount v94 = (char *)v240.data;
              double v95 = (double)a4;
              if (LODWORD(pixelBufferOut.width)) {
                BOOL v96 = (pixelBufferOut.width - 1) >> 32 == 0;
              }
              else {
                BOOL v96 = 0;
              }
              char v97 = !v96;
              char v195 = v97;
              vImagePixelCount v193 = pixelBufferOut.width & 0xFFFFFFFFFFFFFFFCLL;
              vImagePixelCount v186 = pixelBufferOut.height;
              vImagePixelCount v188 = 4 * (pixelBufferOut.width & 0xFFFFFFFFFFFFFFFCLL);
              size_t v202 = pixelBufferOut.rowBytes;
              float64x2_t v204 = (char *)pixelBufferOut.data;
              unint64_t v198 = (char *)v240.data;
              float32x4_t v200 = (char *)v241.data;
              size_t v216 = v241.rowBytes;
              size_t v213 = v240.rowBytes;
              uint64_t v98 = 0;
              if (v5)
              {
                float64x2_t v219 = (float64x2_t)vdupq_n_s64(0x3BC79CA10C924223uLL);
                CGRect v99 = (float32x4_t *)pixelBufferOut.data;
                unint64_t v100 = v241.data;
                int v101 = (float32x4_t *)v240.data;
                unsigned int v102 = (char *)v241.data;
                while (1)
                {
                  unint64_t v103 = (float *)&v94[v93 * v98];
                  CGRect v104 = &v90[v91 * v98];
                  int v105 = (float *)&v102[v89 * v98];
                  unsigned int v209 = v99;
                  float64x2_t v206 = v100;
                  if (v88 >= 4
                    && (v195 & 1) == 0
                    && ((unint64_t)((char *)v103 - v104) >= 0x10
                      ? (BOOL v106 = (unint64_t)((char *)v103 - (char *)v105) >= 0x10)
                      : (BOOL v106 = 0),
                        v106))
                  {
                    int v105 = (float *)((char *)v105 + v188);
                    int32x4_t v114 = (float32x4_t *)v100;
                    int32x4_t v115 = v101;
                    unint64_t v116 = v88 & 0xFFFFFFFFFFFFFFFCLL;
                    do
                    {
                      float32x4_t v117 = *v99++;
                      float32x4_t v118 = v117;
                      float32x4_t v119 = *v114++;
                      float32x4_t v120 = vdivq_f32(vsubq_f32(v119, v118), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v119.f32), v219)), vaddq_f64(vcvt_hight_f64_f32(v119), v219)));
                      float64x2_t v235 = vcvt_hight_f64_f32(v120);
                      float64x2_t __xa = vcvtq_f64_f32(*(float32x2_t *)v120.f32);
                      long double v231 = pow(__xa.f64[0], v95);
                      __xa.f64[0] = pow(__xa.f64[1], v95);
                      long double v223 = pow(v235.f64[0], v95);
                      long double v121 = pow(v235.f64[1], v95);
                      v122.f64[0] = v223;
                      v122.f64[1] = v121;
                      v123.f64[0] = v231;
                      v123.f64[1] = __xa.f64[0];
                      *v115++ = vabsq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v123), v122));
                      v116 -= 4;
                    }
                    while (v116);
                    vImagePixelCount v87 = v186;
                    unint64_t v90 = v204;
                    unsigned int v102 = v200;
                    if (v88 == v193) {
                      goto LABEL_84;
                    }
                    v104 += v188;
                    unint64_t v103 = (float *)((char *)v103 + v188);
                    int v107 = v193;
                  }
                  else
                  {
                    int v107 = 0;
                  }
                  unsigned int v108 = v107 + 1;
                  do
                  {
                    float v109 = *(float *)v104;
                    v104 += 4;
                    float v110 = v109;
                    float v111 = *v105++;
                    float v112 = v111 + 1.0e-20;
                    float v113 = pow((float)((float)(v111 - v110) / v112), v95);
                    *v103++ = fabsf(v113);
                    BOOL v61 = v88 > v108++;
                  }
                  while (v61);
LABEL_84:
                  ++v98;
                  size_t v93 = v213;
                  int v101 = (float32x4_t *)((char *)v101 + v213);
                  size_t v89 = v216;
                  unint64_t v100 = (_OWORD *)((char *)v206 + v216);
                  size_t v91 = v202;
                  CGRect v99 = (float32x4_t *)((char *)v209 + v202);
                  vImagePixelCount v94 = v198;
                  if (v87 <= v98) {
                    goto LABEL_95;
                  }
                }
              }
              int32x4_t v157 = pixelBufferOut.data;
              float64x2_t v158 = v241.data;
              float64x2_t v159 = (float32x4_t *)v240.data;
              while (1)
              {
                unint64_t v160 = (float *)&v94[v93 * v98];
                int32x4_t v161 = &v90[v91 * v98];
                int32x4_t v162 = (float *)&v92[v89 * v98];
                int8x8_t v221 = v157;
                float v211 = v158;
                if (v88 >= 8
                  && (v195 & 1) == 0
                  && ((unint64_t)((char *)v160 - v161) >= 0x10
                    ? (BOOL v163 = (unint64_t)((char *)v160 - (char *)v162) >= 0x10)
                    : (BOOL v163 = 0),
                      v163))
                {
                  int32x4_t v162 = (float *)((char *)v162 + v188);
                  long long v170 = (float32x4_t *)v157;
                  float32x4_t v171 = (float32x4_t *)v158;
                  float32x4_t v172 = v159;
                  unint64_t v173 = v88 & 0xFFFFFFFFFFFFFFFCLL;
                  do
                  {
                    float32x4_t v174 = *v170++;
                    float32x4_t v175 = v174;
                    float32x4_t v176 = *v171++;
                    float32x4_t v177 = vsubq_f32(v176, v175);
                    float64x2_t v237 = vcvt_hight_f64_f32(v177);
                    float64x2_t __xc = vcvtq_f64_f32(*(float32x2_t *)v177.f32);
                    long double v233 = pow(__xc.f64[0], v95);
                    __xc.f64[0] = pow(__xc.f64[1], v95);
                    long double v225 = pow(v237.f64[0], v95);
                    long double v178 = pow(v237.f64[1], v95);
                    v179.f64[0] = v225;
                    v179.f64[1] = v178;
                    v180.f64[0] = v233;
                    v180.f64[1] = __xc.f64[0];
                    *v172++ = vabsq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v180), v179));
                    v173 -= 4;
                  }
                  while (v173);
                  vImagePixelCount v87 = v186;
                  size_t v91 = v202;
                  vImagePixelCount v94 = v198;
                  if (v88 == v193) {
                    goto LABEL_122;
                  }
                  v161 += v188;
                  unint64_t v160 = (float *)((char *)v160 + v188);
                  int v164 = v193;
                }
                else
                {
                  int v164 = 0;
                }
                unsigned int v165 = v164 + 1;
                do
                {
                  float v166 = *(float *)v161;
                  v161 += 4;
                  float v167 = v166;
                  float v168 = *v162++;
                  float v169 = pow((float)(v168 - v167), v95);
                  *v160++ = fabsf(v169);
                  BOOL v61 = v88 > v165++;
                }
                while (v61);
LABEL_122:
                ++v98;
                size_t v93 = v213;
                float64x2_t v159 = (float32x4_t *)((char *)v159 + v213);
                size_t v89 = v216;
                float64x2_t v158 = (_OWORD *)((char *)v211 + v216);
                int32x4_t v157 = (_OWORD *)((char *)v221 + v91);
                unint64_t v90 = v204;
                char v92 = v200;
                if (v87 <= v98) {
                  goto LABEL_95;
                }
              }
            }
            int v23 = 1278226534;
LABEL_32:
            if (v11 != v23) {
              goto LABEL_90;
            }
            goto LABEL_65;
          }
          if (v11 != 875704438)
          {
            int v20 = 1111970369;
LABEL_18:
            if (v11 != v20) {
              goto LABEL_90;
            }
            goto LABEL_27;
          }
        }
        PixelBufferUtils::asVImageBuffer(this, 0, *v17, &pixelBufferOut);
        PixelBufferUtils::asVImageBuffer(a2, 0, *v17, &v241);
        calcDiffsRaw<unsigned char>(&pixelBufferOut, &v241, &v240, v5, a4, 1, v24, v25);
        PixelBufferUtils::asVImageBuffer(this, (__CVBuffer *)1, *v17, &pixelBufferOut);
        PixelBufferUtils::asVImageBuffer(a2, (__CVBuffer *)1, *v17, &v241);
        calcDiffsRaw<unsigned char>(&pixelBufferOut, &v241, &v240, v5, a4, 2, v26, v27);
LABEL_95:
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
        CVPixelBufferUnlockBaseAddress(v191, 1uLL);
        float32x4_t v21 = v189;
        CVPixelBufferUnlockBaseAddress(v189, 0);
        return v21;
      }
    }
  }
  return 0;
}

void sub_215FB2244(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 209) < 0) {
    operator delete(*(void **)(v1 - 232));
  }
  _Unwind_Resume(exception_object);
}

void calcDiffsRaw<unsigned char>(void *a1, void *a2, void *a3, char a4, int a5, uint64_t a6, float a7, float a8)
{
  unint64_t v8 = a1[1];
  if (v8)
  {
    double v13 = (double)a5;
    uint64_t v14 = a1[2];
    LODWORD(v15) = 0;
    if (a4)
    {
      do
      {
        int v22 = v15;
        if (v14 * a6)
        {
          uint64_t v23 = 0;
          uint64_t v24 = *a1 + a1[3] * v15;
          uint64_t v25 = *a2 + a2[3] * v15;
          uint64_t v26 = *a3 + a3[3] * v15;
          do
          {
            LOBYTE(a7) = *(unsigned char *)(v24 + v23);
            unsigned int v27 = *(unsigned __int8 *)(v25 + v23);
            float v28 = (double)v27 + 1.0e-20;
            float v29 = pow((float)((float)((float)v27 - (float)LODWORD(a7)) / v28), v13);
            a7 = fabsf(v29);
            *(unsigned char *)(v26 + v23++) = (int)a7;
            uint64_t v14 = a1[2];
          }
          while (v14 * a6 > (unint64_t)v23);
          unint64_t v8 = a1[1];
        }
        unint64_t v15 = (v22 + 1);
      }
      while (v8 > v15);
    }
    else
    {
      do
      {
        int v16 = v15;
        if (v14 * a6)
        {
          uint64_t v17 = 0;
          uint64_t v18 = *a1 + a1[3] * v15;
          uint64_t v19 = *a2 + a2[3] * v15;
          uint64_t v20 = *a3 + a3[3] * v15;
          do
          {
            LOBYTE(a7) = *(unsigned char *)(v18 + v17);
            LOBYTE(a8) = *(unsigned char *)(v19 + v17);
            float v21 = pow((float)((float)LODWORD(a8) - (float)LODWORD(a7)), v13);
            a7 = fabsf(v21);
            *(unsigned char *)(v20 + v17++) = (int)a7;
            uint64_t v14 = a1[2];
          }
          while (v14 * a6 > (unint64_t)v17);
          unint64_t v8 = a1[1];
        }
        unint64_t v15 = (v16 + 1);
      }
      while (v8 > v15);
    }
  }
}

void calcDiffsRaw<half>(float16x8_t **a1, float16x8_t *a2, uint64_t a3, float16x8_t *a4, uint64_t a5, char a6, int a7)
{
  unint64_t v124 = (unint64_t)a1[1];
  if (!v124) {
    return;
  }
  unint64_t v7 = 2 * (void)a1[2];
  if (!v7) {
    return;
  }
  uint64_t v8 = a5;
  size_t v9 = a4;
  uint64_t v10 = a3;
  unint64_t v11 = a2;
  size_t v12 = *a1;
  uint64_t v13 = (uint64_t)a1[3];
  double v14 = (double)a7;
  uint64_t v116 = v13;
  if (a6)
  {
    uint64_t v15 = 0;
    if (v7) {
      _ZF = (v7 - 1) >> 32 == 0;
    }
    else {
      _ZF = 0;
    }
    char v17 = !_ZF;
    char v114 = v17;
    unint64_t v110 = 2 * (v7 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v18 = *a1;
    uint64_t v19 = a2;
    uint64_t v20 = a4;
    float64x2_t v125 = (float64x2_t)vdupq_n_s64(0x3BC79CA10C924223uLL);
    while (1)
    {
      float v21 = (short float *)((char *)v9->i16 + v15 * v8);
      int v22 = &v12->i8[v13 * v15];
      uint64_t v23 = &v11->i8[v15 * v10];
      float32x4_t v120 = v18;
      uint64_t v122 = v15;
      float32x4_t v117 = v20;
      float32x4_t v119 = v19;
      if (v7 >= 8
        && (v114 & 1) == 0
        && ((unint64_t)((char *)v21 - v22) >= 0x10
          ? (_CF = (unint64_t)((char *)v21 - v23) >= 0x10)
          : (_CF = 0),
            _CF))
      {
        v23 += v110;
        uint64_t v38 = v18;
        char v39 = v19;
        uint64_t v40 = v20;
        unint64_t v41 = v7 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          float16x8_t v42 = *v38++;
          float16x8_t v43 = v42;
          float32x4_t v44 = vcvtq_f32_f16(*(float16x4_t *)v42.i8);
          float16x8_t v45 = *v39++;
          _Q2 = (float64x2_t)v45;
          _D3 = vextq_s8((int8x16_t)_Q2, (int8x16_t)_Q2, 8uLL).u64[0];
          _H6 = WORD1(_D3);
          __asm
          {
            FCVT            D6, H6
            FCVT            D7, H3
          }
          _Q7.f64[1] = _D6;
          LOWORD(_D6) = HIWORD(_D3);
          __asm { FCVT            D6, H6 }
          LOWORD(_D3) = WORD2(_D3);
          __asm { FCVT            D3, H3 }
          _Q3.f64[1] = _D6;
          LOWORD(_D6) = v45.i16[1];
          __asm
          {
            FCVT            D6, H6
            FCVT            D16, H2
          }
          _Q16.f64[1] = _D6;
          LOWORD(_D6) = v45.i16[3];
          __asm { FCVT            D6, H6 }
          LOWORD(_Q2.f64[0]) = v45.i16[2];
          __asm { FCVT            D2, H2 }
          _Q2.f64[1] = _D6;
          float32x4_t v56 = vdivq_f32(vsubq_f32(vcvtq_f32_f16(*(float16x4_t *)v45.i8), v44), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(_Q16, v125)), vaddq_f64(_Q2, v125)));
          float32x4_t v57 = vdivq_f32(vsubq_f32(vcvt_hight_f32_f16(v45), vcvt_hight_f32_f16(v43)), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(_Q7, v125)), vaddq_f64(_Q3, v125)));
          float64x2_t v139 = vcvtq_f64_f32(*(float32x2_t *)v57.f32);
          float64x2_t v141 = vcvt_hight_f64_f32(v57);
          float64x2_t v137 = vcvt_hight_f64_f32(v56);
          float64x2_t v133 = vcvtq_f64_f32(*(float32x2_t *)v56.f32);
          long double v135 = pow(v133.f64[0], v14);
          v133.f64[0] = pow(v133.f64[1], v14);
          long double v131 = pow(v137.f64[0], v14);
          long double v129 = pow(v137.f64[1], v14);
          v137.f64[0] = pow(v139.f64[0], v14);
          v139.f64[0] = pow(v139.f64[1], v14);
          long double v127 = pow(v141.f64[0], v14);
          long double v58 = pow(v141.f64[1], v14);
          v59.f64[0] = v131;
          v59.f64[1] = v129;
          v60.f64[0] = v135;
          v60.f64[1] = v133.f64[0];
          v61.f64[0] = v127;
          v61.f64[1] = v58;
          v62.f64[0] = v137.f64[0];
          v62.f64[1] = v139.f64[0];
          *v40++ = vabsq_f16(vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v60), v59)), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v62), v61)));
          v41 -= 8;
        }
        while (v41);
        uint64_t v8 = a5;
        uint64_t v10 = a3;
        size_t v9 = a4;
        if (v7 == (v7 & 0xFFFFFFFFFFFFFFF8)) {
          goto LABEL_20;
        }
        v22 += v110;
        float v21 = (short float *)((char *)v21 + v110);
        int v25 = v7 & 0xFFFFFFF8;
      }
      else
      {
        int v25 = 0;
      }
      unsigned int v26 = v25 + 1;
      do
      {
        __int16 v27 = *(_WORD *)v22;
        v22 += 2;
        _H0 = v27;
        __asm { FCVT            S0, H0 }
        __int16 v32 = *(_WORD *)v23;
        v23 += 2;
        _H1 = v32;
        __asm
        {
          FCVT            S2, H1
          FCVT            D1, H1
        }
        *(float *)&_D1 = _D1 + 1.0e-20;
        _S0 = pow((float)((float)(_S2 - _S0) / *(float *)&_D1), v14);
        __asm { FCVT            H0, S0 }
        *v21++ = fabsl(*(short float *)&_S0);
        BOOL v37 = v7 > v26++;
      }
      while (v37);
LABEL_20:
      uint64_t v15 = v122 + 1;
      uint64_t v20 = (float16x8_t *)((char *)v117 + v8);
      uint64_t v19 = (float16x8_t *)((char *)v119 + v10);
      uint64_t v13 = v116;
      uint64_t v18 = (float16x8_t *)((char *)v120 + v116);
      if (v124 <= (v122 + 1)) {
        return;
      }
    }
  }
  if (v7 <= 7)
  {
    uint64_t v63 = 0;
    do
    {
      uint64_t v64 = 0;
      do
      {
        _H0 = v12->i16[v64];
        __asm { FCVT            S0, H0 }
        _H1 = v11->i16[v64];
        __asm { FCVT            S1, H1 }
        _S0 = pow((float)(_S1 - _S0), v14);
        __asm { FCVT            H0, S0 }
        *(short float *)&v9->i16[v64++] = fabsl(*(short float *)&_S0);
      }
      while (v7 > v64);
      ++v63;
      size_t v12 = (float16x8_t *)((char *)v12 + v13);
      unint64_t v11 = (float16x8_t *)((char *)v11 + v10);
      size_t v9 = (float16x8_t *)((char *)v9 + v8);
    }
    while (v124 > v63);
    return;
  }
  if (v7) {
    BOOL v70 = (v7 - 1) >> 32 == 0;
  }
  else {
    BOOL v70 = 0;
  }
  if (v70)
  {
    uint64_t v78 = 0;
    unint64_t v115 = 2 * (v7 & 0xFFFFFFFFFFFFFFF8);
    int16x8_t v79 = *a1;
    float32x4_t v80 = a2;
    float32x4_t v81 = a4;
    while (1)
    {
      long double v82 = (short float *)((char *)v9->i16 + v78 * v8);
      float64x2_t v83 = &v12->i8[v13 * v78];
      float64x2_t v84 = &v11->i8[v78 * v10];
      BOOL v85 = (unint64_t)((char *)v82 - v83) >= 0x10 && (unint64_t)((char *)v82 - v84) >= 0x10;
      int16x8_t v126 = v79;
      long double v121 = v81;
      float64x2_t v123 = v80;
      if (v85)
      {
        uint64_t v118 = v78;
        v84 += v115;
        vImagePixelCount v87 = v79;
        vImagePixelCount v88 = v80;
        size_t v89 = v81;
        unint64_t v90 = v7 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          float16x8_t v91 = *v87++;
          float32x4_t v92 = vcvt_hight_f32_f16(v91);
          float32x4_t v93 = vcvtq_f32_f16(*(float16x4_t *)v91.i8);
          float16x8_t v94 = *v88++;
          float32x4_t v95 = vsubq_f32(vcvtq_f32_f16(*(float16x4_t *)v94.i8), v93);
          float32x4_t v96 = vsubq_f32(vcvt_hight_f32_f16(v94), v92);
          float64x2_t v140 = vcvtq_f64_f32(*(float32x2_t *)v96.f32);
          float64x2_t v142 = vcvt_hight_f64_f32(v96);
          float64x2_t v138 = vcvt_hight_f64_f32(v95);
          float64x2_t v134 = vcvtq_f64_f32(*(float32x2_t *)v95.f32);
          long double v136 = pow(v134.f64[0], v14);
          v134.f64[0] = pow(v134.f64[1], v14);
          long double v132 = pow(v138.f64[0], v14);
          long double v130 = pow(v138.f64[1], v14);
          v138.f64[0] = pow(v140.f64[0], v14);
          v140.f64[0] = pow(v140.f64[1], v14);
          long double v128 = pow(v142.f64[0], v14);
          long double v97 = pow(v142.f64[1], v14);
          v98.f64[0] = v132;
          v98.f64[1] = v130;
          v99.f64[0] = v136;
          v99.f64[1] = v134.f64[0];
          v100.f64[0] = v128;
          v100.f64[1] = v97;
          v101.f64[0] = v138.f64[0];
          v101.f64[1] = v140.f64[0];
          *v89++ = vabsq_f16(vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v99), v98)), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v101), v100)));
          v90 -= 8;
        }
        while (v90);
        uint64_t v78 = v118;
        uint64_t v8 = a5;
        uint64_t v13 = v116;
        if (v7 == (v7 & 0xFFFFFFFFFFFFFFF8)) {
          goto LABEL_42;
        }
        v83 += v115;
        long double v82 = (short float *)((char *)v82 + v115);
        int v86 = v7 & 0xFFFFFFF8;
      }
      else
      {
        int v86 = 0;
      }
      unsigned int v102 = v86 + 1;
      do
      {
        __int16 v103 = *(_WORD *)v83;
        v83 += 2;
        _H0 = v103;
        __asm { FCVT            S0, H0 }
        __int16 v106 = *(_WORD *)v84;
        v84 += 2;
        _H1 = v106;
        __asm { FCVT            S1, H1 }
        _S0 = pow((float)(_S1 - _S0), v14);
        __asm { FCVT            H0, S0 }
        *v82++ = fabsl(*(short float *)&_S0);
        BOOL v37 = v7 > v102++;
      }
      while (v37);
LABEL_42:
      ++v78;
      float32x4_t v81 = (float16x8_t *)((char *)v121 + v8);
      uint64_t v10 = a3;
      size_t v9 = a4;
      float32x4_t v80 = (float16x8_t *)((char *)v123 + a3);
      int16x8_t v79 = (float16x8_t *)((char *)v126 + v13);
      if (v124 <= v78) {
        return;
      }
    }
  }
  uint64_t v71 = 0;
  do
  {
    uint64_t v72 = 0;
    do
    {
      _H0 = v12->i16[v72];
      __asm { FCVT            S0, H0 }
      _H1 = v11->i16[v72];
      __asm { FCVT            S1, H1 }
      _S0 = pow((float)(_S1 - _S0), v14);
      __asm { FCVT            H0, S0 }
      *(short float *)&v9->i16[v72++] = fabsl(*(short float *)&_S0);
    }
    while (v7 > v72);
    ++v71;
    size_t v12 = (float16x8_t *)((char *)v12 + v13);
    unint64_t v11 = (float16x8_t *)((char *)v11 + v10);
    size_t v9 = (float16x8_t *)((char *)v9 + v8);
  }
  while (v124 > v71);
}

void calcDiffsRaw<float>(float32x4_t **a1, float32x4_t *a2, uint64_t a3, float32x4_t *a4, uint64_t a5, char a6, int a7)
{
  unint64_t v65 = (unint64_t)a1[1];
  float16x8_t v66 = a2;
  if (v65)
  {
    unint64_t v7 = 4 * (void)a1[2];
    if (v7)
    {
      uint64_t v8 = a4;
      size_t v9 = *a1;
      float16x8_t v67 = a1[3];
      double v10 = (double)a7;
      if (a6)
      {
        uint64_t v11 = 0;
        if (v7) {
          BOOL v12 = (v7 - 1) >> 32 == 0;
        }
        else {
          BOOL v12 = 0;
        }
        int v13 = !v12;
        int v63 = v13;
        float64x2_t v70 = (float64x2_t)vdupq_n_s64(0x3BC79CA10C924223uLL);
        double v14 = *a1;
        uint64_t v15 = a2;
        int v16 = a4;
        do
        {
          if (!v63
            && ((uint64_t v17 = (uint64_t)v8 + v11 * a5,
                 unint64_t v18 = v17 - ((void)v9 + (void)v67 * v11),
                 unint64_t v19 = v17 - ((void)v66 + v11 * a3),
                 v18 >= 0x10)
              ? (BOOL v20 = v19 >= 0x10)
              : (BOOL v20 = 0),
                v20))
          {
            int v25 = v14;
            unsigned int v26 = v15;
            __int16 v27 = v16;
            unint64_t v28 = v7;
            do
            {
              float32x4_t v29 = *v25++;
              float32x4_t v30 = v29;
              float32x4_t v31 = *v26++;
              float32x4_t v32 = vdivq_f32(vsubq_f32(v31, v30), vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v31.f32), v70)), vaddq_f64(vcvt_hight_f64_f32(v31), v70)));
              float64x2_t __x = vcvt_hight_f64_f32(v32);
              float64x2_t v73 = vcvtq_f64_f32(*(float32x2_t *)v32.f32);
              long double v75 = pow(v73.f64[0], v10);
              v73.f64[0] = pow(v73.f64[1], v10);
              long double v71 = pow(__x.f64[0], v10);
              long double v33 = pow(__x.f64[1], v10);
              v34.f64[0] = v71;
              v34.f64[1] = v33;
              v35.f64[0] = v75;
              v35.f64[1] = v73.f64[0];
              *v27++ = vabsq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v35), v34));
              v28 -= 4;
            }
            while (v28);
          }
          else
          {
            uint64_t v21 = 0;
            do
            {
              float v22 = v15->f32[v21];
              float v23 = v22 + 1.0e-20;
              float v24 = pow((float)((float)(v22 - v14->f32[v21]) / v23), v10);
              v16->f32[v21++] = fabsf(v24);
            }
            while (v7 > v21);
          }
          ++v11;
          int v16 = (float32x4_t *)((char *)v16 + a5);
          uint64_t v15 = (float32x4_t *)((char *)v15 + a3);
          double v14 = (float32x4_t *)((char *)v67 + (void)v14);
          uint64_t v8 = a4;
        }
        while (v65 > v11);
      }
      else if (v7 > 7)
      {
        uint64_t v39 = 0;
        if (v7) {
          BOOL v40 = (v7 - 1) >> 32 == 0;
        }
        else {
          BOOL v40 = 0;
        }
        if (v40)
        {
          float16x8_t v43 = *a1;
          float32x4_t v44 = a2;
          float16x8_t v45 = a4;
          do
          {
            uint64_t v46 = (uint64_t)v8 + v39 * a5;
            unint64_t v47 = v46 - ((void)v9 + (void)v67 * v39);
            unint64_t v48 = v46 - ((void)v66 + v39 * a3);
            BOOL v49 = v47 >= 0x10 && v48 >= 0x10;
            unsigned int v50 = v43;
            __int16 v51 = v44;
            BOOL v52 = v45;
            unint64_t v53 = v7;
            if (v49)
            {
              do
              {
                float32x4_t v56 = *v50++;
                float32x4_t v57 = v56;
                float32x4_t v58 = *v51++;
                float32x4_t v59 = vsubq_f32(v58, v57);
                float64x2_t __xa = vcvt_hight_f64_f32(v59);
                float64x2_t v74 = vcvtq_f64_f32(*(float32x2_t *)v59.f32);
                long double v76 = pow(v74.f64[0], v10);
                v74.f64[0] = pow(v74.f64[1], v10);
                long double v72 = pow(__xa.f64[0], v10);
                long double v60 = pow(__xa.f64[1], v10);
                v61.f64[0] = v72;
                v61.f64[1] = v60;
                v62.f64[0] = v76;
                v62.f64[1] = v74.f64[0];
                *v52++ = vabsq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v62), v61));
                v53 -= 4;
              }
              while (v53);
            }
            else
            {
              uint64_t v54 = 0;
              do
              {
                float v55 = pow((float)(v44->f32[v54] - v43->f32[v54]), v10);
                v45->f32[v54++] = fabsf(v55);
              }
              while (v7 > v54);
            }
            ++v39;
            float16x8_t v45 = (float32x4_t *)((char *)v45 + a5);
            float32x4_t v44 = (float32x4_t *)((char *)v44 + a3);
            float16x8_t v43 = (float32x4_t *)((char *)v67 + (void)v43);
            uint64_t v8 = a4;
          }
          while (v65 > v39);
        }
        else
        {
          do
          {
            uint64_t v41 = 0;
            do
            {
              float v42 = pow((float)(v66->f32[v41] - v9->f32[v41]), v10);
              v8->f32[v41++] = fabsf(v42);
            }
            while (v7 > v41);
            ++v39;
            size_t v9 = (float32x4_t *)((char *)v67 + (void)v9);
            float16x8_t v66 = (float32x4_t *)((char *)v66 + a3);
            uint64_t v8 = (float32x4_t *)((char *)v8 + a5);
          }
          while (v65 > v39);
        }
      }
      else
      {
        uint64_t v36 = 0;
        do
        {
          uint64_t v37 = 0;
          do
          {
            float v38 = pow((float)(v66->f32[v37] - v9->f32[v37]), v10);
            v8->f32[v37++] = fabsf(v38);
          }
          while (v7 > v37);
          ++v36;
          size_t v9 = (float32x4_t *)((char *)v67 + (void)v9);
          float16x8_t v66 = (float32x4_t *)((char *)v66 + a3);
          uint64_t v8 = (float32x4_t *)((char *)v8 + a5);
        }
        while (v65 > v36);
      }
    }
  }
}

uint64_t PixelBufferUtils::scaleConvertRotatePixelBuffer(PixelBufferUtils *this, __CVBuffer *a2, CVPixelBufferRef pixelBuffer, CGRect a4, CVPixelBufferRef *a5, __CVBuffer **a6, __CVBuffer **a7)
{
  long double v60 = pixelBuffer;
  float64x2_t v61 = this;
  if (!this) {
    return 0xFFFFFFFFLL;
  }
  double height = a4.size.height;
  double width = a4.size.width;
  double y = a4.origin.y;
  double x = a4.origin.x;
  unsigned int v12 = a2;
  unsigned int v56 = a7;
  CVPixelBufferRef v58 = 0;
  CVPixelBufferRef texture = 0;
  if (a5) {
    p_CVPixelBufferRef texture = a5;
  }
  else {
    p_CVPixelBufferRef texture = &texture;
  }
  if (a6) {
    int v16 = a6;
  }
  else {
    int v16 = &v58;
  }
  size_t v17 = CVPixelBufferGetWidth(pixelBuffer);
  size_t v18 = CVPixelBufferGetHeight(pixelBuffer);
  signed int v19 = CVPixelBufferGetPixelFormatType(pixelBuffer);
  OSType v20 = CVPixelBufferGetPixelFormatType(this);
  unsigned int v57 = v12;
  if ((v12 & 0xFFFFFFFD) == 1) {
    double v21 = (double)(unint64_t)(double)v17;
  }
  else {
    double v21 = (double)v18;
  }
  if ((v12 & 0xFFFFFFFD) == 1) {
    double v22 = (double)v18;
  }
  else {
    double v22 = (double)v17;
  }
  size_t v23 = CVPixelBufferGetWidth(this);
  size_t v24 = CVPixelBufferGetHeight(this);
  signed int v25 = CVPixelBufferGetPixelFormatType(this);
  v63.origin.double x = x;
  v63.origin.double y = y;
  v63.size.double width = width;
  v63.size.double height = height;
  CGRect v68 = CGRectIntegral(v63);
  v64.origin.double x = x;
  v64.origin.double y = y;
  v64.size.double width = width;
  v64.size.double height = height;
  if (!CGRectEqualToRect(v64, v68))
  {
    NSLog(&cfstr_SDErrorCropDim.isa, "scaleConvertRotatePixelBuffer", 2538);
    return 0xFFFFFFFFLL;
  }
  v65.origin.double x = x;
  v65.origin.double y = y;
  v65.size.double width = width;
  v65.size.double height = height;
  if (CGRectIsEmpty(v65))
  {
    double x = 0.0;
    double y = 0.0;
    double width = (double)v23;
    double height = (double)v24;
  }
  v69.origin.double x = 0.0;
  v69.origin.double y = 0.0;
  v66.origin.double x = x;
  v66.origin.double y = y;
  v66.size.double width = width;
  v66.size.double height = height;
  v69.size.double width = (double)v23;
  v69.size.double height = (double)v24;
  BOOL v26 = !CGRectEqualToRect(v66, v69);
  if (v22 != (double)v23) {
    BOOL v26 = 1;
  }
  if (v21 != (double)v24) {
    BOOL v26 = 1;
  }
  if (v20 == v19 && !v57 && !v26) {
    return PixelBufferUtils::copyPixelBuffer(pixelBuffer, this, (__CVBuffer *)v56);
  }
  OSType pixelFormatType = v19;
  int v28 = !v26;
  float32x4_t v29 = (__CVBuffer *)v56;
  float32x4_t v30 = v16;
  float32x4_t v31 = a6;
  if ((v26 & v56) != 1) {
    goto LABEL_41;
  }
  if (v25 <= 1751410031)
  {
    if (v25 > 1717855599)
    {
      if (v25 == 1717855600) {
        goto LABEL_41;
      }
      int v32 = 1717856627;
    }
    else
    {
      if (v25 == 825306677) {
        goto LABEL_41;
      }
      int v32 = 825437747;
    }
  }
  else if (v25 <= 1919365989)
  {
    if (v25 == 1751410032) {
      goto LABEL_41;
    }
    int v32 = 1751411059;
  }
  else
  {
    if (v25 == 1919365990 || v25 == 1919365992) {
      goto LABEL_41;
    }
    int v32 = 1932996149;
  }
  if (v25 == v32) {
    goto LABEL_41;
  }
  BOOL v35 = 0;
  if (v19 <= 1751410031)
  {
    if (v19 > 1717855599)
    {
      if (v19 == 1717855600) {
        goto LABEL_41;
      }
      int v53 = 1717856627;
    }
    else
    {
      if (v19 == 825306677) {
        goto LABEL_41;
      }
      int v53 = 825437747;
    }
LABEL_104:
    long double v33 = p_texture;
    float64x2_t v34 = p_texture;
    if (v19 != v53) {
      goto LABEL_48;
    }
    goto LABEL_41;
  }
  if (v19 <= 1919365989)
  {
    if (v19 == 1751410032) {
      goto LABEL_41;
    }
    int v53 = 1751411059;
    goto LABEL_104;
  }
  if (v19 != 1919365990 && v19 != 1932996149)
  {
    int v53 = 1919365992;
    goto LABEL_104;
  }
LABEL_41:
  if (v26) {
    long double v33 = p_texture;
  }
  else {
    long double v33 = &v61;
  }
  if (v20 == v19) {
    float64x2_t v34 = v33;
  }
  else {
    float64x2_t v34 = v30;
  }
  BOOL v35 = v20 != v19;
LABEL_48:
  if (v57) {
    uint64_t v36 = v30;
  }
  else {
    uint64_t v36 = &v60;
  }
  if (!v57) {
    int v28 = 1;
  }
  if ((v28 & !v35) != 0) {
    uint64_t v37 = v36;
  }
  else {
    uint64_t v37 = p_texture;
  }
  if (v26)
  {
    float v38 = *v37;
    if (!*v37)
    {
      if (v35) {
        OSType v39 = v20;
      }
      else {
        OSType v39 = pixelFormatType;
      }
      CVPixelBufferRef pixelBufferOut = 0;
      CFAllocatorRef v40 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
      OSType v42 = v39;
      float32x4_t v29 = (__CVBuffer *)v56;
      if (CVPixelBufferCreate(v40, (unint64_t)v22, (unint64_t)v21, v42, BufferAttributes, &pixelBufferOut))
      {
        float v38 = 0;
      }
      else
      {
        float v38 = pixelBufferOut;
      }
      *uint64_t v37 = v38;
    }
    v67.origin.double x = x;
    v67.origin.double y = y;
    v67.size.double width = width;
    v67.size.double height = height;
    uint64_t v27 = PixelBufferUtils::cropAndScalePixelBuffer(this, v38, v29, v67, *MEMORY[0x263F001A8]);
  }
  else
  {
    uint64_t v27 = 0;
  }
  if (v27 == 0 && v35)
  {
    float16x8_t v43 = *v33;
    if (!*v36)
    {
      uint64_t v46 = v29;
      size_t v47 = CVPixelBufferGetWidth(*v33);
      size_t v48 = CVPixelBufferGetHeight(v43);
      CVPixelBufferRef pixelBufferOut = 0;
      CFAllocatorRef v49 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFDictionaryRef v50 = (const __CFDictionary *)getBufferAttributes();
      if (CVPixelBufferCreate(v49, v47, v48, pixelFormatType, v50, &pixelBufferOut)) {
        __int16 v51 = 0;
      }
      else {
        __int16 v51 = pixelBufferOut;
      }
      if (PixelBufferUtils::convertPixelBufferFormat(v43, v51, v46))
      {
        CVPixelBufferRelease(v51);
        __int16 v51 = 0;
      }
      char *v36 = v51;
      if (v51) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = 0xFFFFFFFFLL;
      }
      LODWORD(v29) = v56;
      float32x4_t v44 = (__CVBuffer *)v57;
      if (!v57) {
        goto LABEL_87;
      }
      goto LABEL_71;
    }
    uint64_t v27 = PixelBufferUtils::convertPixelBufferFormat(*v33, *v36, v29);
  }
  float32x4_t v44 = (__CVBuffer *)v57;
  if (v57)
  {
LABEL_71:
    if (!v27)
    {
      float16x8_t v45 = *v34;
      if (v60)
      {
        uint64_t v27 = PixelBufferUtils::rotatePixelBuffer(v45, v60, v44, (int)v29);
      }
      else if (PixelBufferUtils::createRotatedPixelBuffer(v45, v44, (int)v29))
      {
        uint64_t v27 = 0;
      }
      else
      {
        uint64_t v27 = 0xFFFFFFFFLL;
      }
    }
  }
LABEL_87:
  if (!a5) {
    CVPixelBufferRelease(texture);
  }
  if (!v31) {
    CVPixelBufferRelease(v58);
  }
  return v27;
}

CVPixelBufferRef PixelBufferUtils::pixelBufferFromCGImage(PixelBufferUtils *this, CGImage *a2)
{
  OSType v2 = a2;
  _OWORD v26[3] = *MEMORY[0x263EF8340];
  ColorSpace = CGImageGetColorSpace(this);
  size_t BitsPerComponent = CGImageGetBitsPerComponent(this);
  uint32_t BitmapInfo = CGImageGetBitmapInfo(this);
  CFStringRef Name = CGColorSpaceGetName(ColorSpace);
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  CFStringRef v9 = CGColorSpaceGetName(DeviceRGB);
  if (!Name)
  {
    CFStringRef Name = v9;
    ColorSpace = DeviceRGB;
  }
  if (CFEqual(Name, v9))
  {
    uint32_t BitmapInfo = 6;
    int v10 = 32;
    ColorSpace = DeviceRGB;
  }
  else
  {
    uint64_t v11 = (const void *)*MEMORY[0x263F002D8];
    if (CFEqual(Name, (CFTypeRef)*MEMORY[0x263F002D8])) {
      BOOL v12 = BitsPerComponent == 8;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12 || CFEqual(Name, (CFTypeRef)*MEMORY[0x263F001E8]))
    {
      uint32_t BitmapInfo = 6;
    }
    else
    {
      if (CFEqual(Name, v11) && BitsPerComponent == 32)
      {
        uint32_t BitmapInfo = 257;
        int v10 = 1380410945;
        goto LABEL_12;
      }
      if (!CFEqual(Name, (CFTypeRef)*MEMORY[0x263F00268]))
      {
        if (CFEqual(Name, (CFTypeRef)*MEMORY[0x263F00250]))
        {
          if (BitsPerComponent == 16) {
            int v10 = 1647392359;
          }
          else {
            int v10 = 1278226534;
          }
          if (BitsPerComponent == 16 || BitsPerComponent == 32) {
            goto LABEL_12;
          }
          NSLog(&cfstr_SDErrorThisCon.isa, "pixelBufferFromCGImage", 2713);
        }
        else
        {
          NSLog(&cfstr_SDErrorThisCon.isa, "pixelBufferFromCGImage", 2719);
        }
        return 0;
      }
      uint32_t BitmapInfo = 2;
    }
    int v10 = 32;
  }
LABEL_12:
  if (v2 == 1061109567) {
    OSType v13 = v10;
  }
  else {
    OSType v13 = v2;
  }
  unint64_t Width = CGImageGetWidth(this);
  unint64_t Height = CGImageGetHeight(this);
  uint64_t v16 = *MEMORY[0x263F04090];
  v25[0] = *MEMORY[0x263F040A0];
  v25[1] = v16;
  v26[0] = MEMORY[0x263EFFA88];
  v26[1] = MEMORY[0x263EFFA88];
  v25[2] = *MEMORY[0x263F04130];
  _OWORD v26[2] = MEMORY[0x263EFFA78];
  CFDictionaryRef v17 = [NSDictionary dictionaryWithObjects:v26 forKeys:v25 count:3];
  CVPixelBufferRef pixelBufferOut = 0;
  if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], Width, Height, v13, v17, &pixelBufferOut))
  {
    NSLog(&cfstr_SDErrorCouldNo.isa, "pixelBufferFromCGImage", 2743);
    CGColorSpaceRelease(DeviceRGB);
    CVPixelBufferRef v18 = 0;
  }
  else
  {
    CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
    BaseAddress = CVPixelBufferGetBaseAddress(pixelBufferOut);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBufferOut);
    double v21 = CGBitmapContextCreate(BaseAddress, Width, Height, BitsPerComponent, BytesPerRow, ColorSpace, BitmapInfo);
    double v22 = v21;
    if (v21)
    {
      v27.size.double width = (double)Width;
      v27.size.double height = (double)Height;
      v27.origin.double x = 0.0;
      v27.origin.double y = 0.0;
      CGContextDrawImage(v21, v27, this);
      CGContextRelease(v22);
      CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
    }
    else
    {
      NSLog(&cfstr_SDErrorCouldNo_0.isa, "pixelBufferFromCGImage", 2765);
      CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
      CVPixelBufferRelease(pixelBufferOut);
      CVPixelBufferRef pixelBufferOut = 0;
    }
    CGColorSpaceRelease(DeviceRGB);
    CVPixelBufferRef v18 = pixelBufferOut;
  }

  return v18;
}

void sub_215FB37F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void PixelBufferUtils::pixelBufferToImageFile(PixelBufferUtils *this, PixelBufferUtils *a2, const __CFString *a3, const __CFString *a4)
{
  uint64_t v6 = PixelBufferUtils::pixelBufferToCGImage(a2, a2);
  unint64_t v7 = NSURL;
  uint64_t v8 = [NSString stringWithUTF8String:this];
  CFURLRef url = [v7 fileURLWithPath:v8];
  if (!a3) {
    a3 = @"public.png";
  }

  CFStringRef v9 = CGImageDestinationCreateWithURL(url, a3, 1uLL, 0);
  CGImageDestinationAddImage(v9, v6, 0);
  CGImageDestinationFinalize(v9);
  CFRelease(v9);
  CGImageRelease(v6);
}

void sub_215FB38F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

CGImageRef PixelBufferUtils::pixelBufferToCGImage(PixelBufferUtils *this, __CVBuffer *a2)
{
  size_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  size_t v5 = CVPixelBufferGetWidth(this);
  size_t v6 = CVPixelBufferGetHeight(this);
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v7, v5, v6, 0x20u, BufferAttributes, &pixelBufferOut)) {
    CFStringRef v9 = 0;
  }
  else {
    CFStringRef v9 = pixelBufferOut;
  }
  if (PixelBufferUtils::convertPixelBufferFormat(this, v9, 0))
  {
    CVPixelBufferRelease(v9);
    CFStringRef v9 = 0;
  }
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  CVPixelBufferLockBaseAddress(v9, 1uLL);
  BaseAddress = CVPixelBufferGetBaseAddress(v9);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(v9);
  OSType v13 = CGBitmapContextCreate(BaseAddress, Width, Height, 8uLL, BytesPerRow, DeviceRGB, 6u);
  CFRelease(DeviceRGB);
  CGImageRef Image = CGBitmapContextCreateImage(v13);
  CVPixelBufferUnlockBaseAddress(v9, 1uLL);
  CGContextRelease(v13);
  CVPixelBufferRelease(v9);
  return Image;
}

uint64_t PixelBufferUtils::pixelBufferFromRawFileWithBuffer(PixelBufferUtils *this, CVPixelBufferRef pixelBuffer, __CVBuffer *a3)
{
  OSType PixelFormatType = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(pixelBuffer);
  unsigned int v56 = [NSString stringWithUTF8String:this];
  size_t v6 = objc_msgSend(MEMORY[0x263EFF8F8], "dataWithContentsOfFile:");
  if (!v6)
  {
    NSLog(&cfstr_SDErrorFailedR.isa, "pixelBufferFromRawFileWithBuffer", 2882);
LABEL_16:
    uint64_t v30 = 0xFFFFFFFFLL;
    goto LABEL_35;
  }
  unint64_t v7 = PixelBufferUtils::pixelSizeForPixelFormat(PixelFormatType, 0);
  uint64_t v8 = PixelBufferUtils::planeCountForPixelFormat(PixelFormatType);
  size_t Width = CVPixelBufferGetWidth(pixelBuffer);
  size_t Height = CVPixelBufferGetHeight(pixelBuffer);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
  if (v8)
  {
    id v55 = v6;
    size_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    do
    {
      unint64_t v15 = PixelBufferUtils::pixelSizeForPixelFormat(PixelFormatType, v12);
      size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, v12);
      v14 += WidthOfPlane * v15 * CVPixelBufferGetHeightOfPlane(pixelBuffer, v12);
      v13 += CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, v12++);
    }
    while (v8 != v12);
    uint64_t v17 = [v55 length];
    if (v17 == v14 || [v55 length] == v13)
    {
      uint64_t v18 = [v55 bytes];
      OSType v57 = CVPixelBufferGetPixelFormatType(pixelBuffer);
      size_t PlaneCount = CVPixelBufferGetPlaneCount(pixelBuffer);
      CVPixelBufferLockBaseAddress(pixelBuffer, 0);
      if (PlaneCount)
      {
        if (v17 == v14)
        {
          for (size_t i = 0; i != PlaneCount; ++i)
          {
            BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, i);
            unint64_t v22 = PixelBufferUtils::pixelSizeForPixelFormat((PixelBufferUtils *)v57, i);
            size_t v23 = CVPixelBufferGetWidthOfPlane(pixelBuffer, i);
            size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, i);
            size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, i);
            size_t v26 = v23 * v22;
            if (HeightOfPlane)
            {
              size_t v27 = BytesPerRowOfPlane;
              int v28 = (char *)v18;
              size_t v29 = HeightOfPlane;
              do
              {
                memcpy(BaseAddressOfPlane, v28, v26);
                BaseAddressOfPlane += v27;
                v28 += v26;
                --v29;
              }
              while (v29);
            }
            v18 += v26 * HeightOfPlane;
          }
        }
        else
        {
          for (size_t j = 0; j != PlaneCount; ++j)
          {
            float16x8_t v45 = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, j);
            unint64_t v46 = PixelBufferUtils::pixelSizeForPixelFormat((PixelBufferUtils *)v57, j);
            size_t v47 = CVPixelBufferGetWidthOfPlane(pixelBuffer, j);
            size_t v48 = CVPixelBufferGetHeightOfPlane(pixelBuffer, j);
            size_t v49 = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, j);
            size_t v50 = v47 * v46;
            if (v48)
            {
              size_t v51 = v49;
              uint64_t v52 = 0;
              size_t v53 = v48;
              do
              {
                memcpy(&v45[v52], (const void *)(v18 + v52), v50);
                v52 += v51;
                --v53;
              }
              while (v53);
            }
            v18 += v50 * v48;
          }
        }
      }
      CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
      uint64_t v30 = 0;
    }
    else
    {
      NSLog(&cfstr_SDErrorDataSiz.isa, "pixelBufferFromRawFileWithBuffer", 2926);
      uint64_t v30 = 0xFFFFFFFFLL;
    }
    size_t v6 = v55;
    goto LABEL_35;
  }
  size_t v31 = BytesPerRow;
  uint64_t v32 = [v6 length];
  size_t v33 = Width * v7 * Height;
  if (v32 != v33 && [v6 length] != v31 * Height)
  {
    NSLog(&cfstr_SDErrorDataSiz.isa, "pixelBufferFromRawFileWithBuffer", 2902);
    goto LABEL_16;
  }
  float64x2_t v34 = (char *)[v6 bytes];
  BOOL v35 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(pixelBuffer);
  size_t v36 = CVPixelBufferGetWidth(pixelBuffer);
  size_t v37 = CVPixelBufferGetHeight(pixelBuffer);
  size_t v38 = CVPixelBufferGetBytesPerRow(pixelBuffer);
  unint64_t v39 = PixelBufferUtils::pixelSizeForPixelFormat(v35, 0);
  size_t v40 = v39 * v36;
  if (v32 == v33) {
    size_t v41 = v39 * v36;
  }
  else {
    size_t v41 = v38;
  }
  CVPixelBufferLockBaseAddress(pixelBuffer, 0);
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(pixelBuffer);
  if (v37)
  {
    float16x8_t v43 = BaseAddress;
    do
    {
      memcpy(v43, v34, v40);
      v43 += v38;
      v34 += v41;
      --v37;
    }
    while (v37);
  }
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
  uint64_t v30 = 0;
LABEL_35:

  return v30;
}

void sub_215FB3E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

__CVBuffer *PixelBufferUtils::pixelBufferFromRawFile(PixelBufferUtils *this, const char *a2)
{
  return PixelBufferUtils::pixelBufferFromRawFile(this, 0, 0, 0x3F3F3F3Fu);
}

__CVBuffer *PixelBufferUtils::pixelBufferFromRawFile(PixelBufferUtils *this, unint64_t a2, size_t a3, OSType a4)
{
  uint64_t v8 = [NSString stringWithUTF8String:this];
  CFStringRef v9 = v8;
  if (a4 == 1061109567)
  {
    id v10 = [v8 pathExtension];
    uint64_t v11 = (PixelBufferUtils *)[v10 UTF8String];
    a4 = PixelBufferUtils::pixelFormatFromFileExtension(v11, v12);

    if (!a4)
    {
      NSLog(&cfstr_SDErrorCannotR.isa, "pixelBufferFromRawFile", 2947);
      goto LABEL_23;
    }
  }
  if (!a2 || !a3)
  {
    if (a3 | a2)
    {
      NSLog(&cfstr_SDErrorBadDime.isa, "pixelBufferFromRawFile", 2956);
      goto LABEL_23;
    }
    uint64_t v16 = [v9 stringByDeletingPathExtension];
    uint64_t v17 = [v16 pathExtension];

    if ([v17 isEqualToString:&stru_26C6879A8])
    {
      NSLog(&cfstr_SDErrorDidNotF.isa, "pixelBufferFromRawFile", 2963);
    }
    else
    {
      uint64_t v18 = [v17 lowercaseString];
      signed int v19 = [v18 componentsSeparatedByString:@"x"];

      if ([v19 count] == 2)
      {
        a3 = [v19 objectAtIndexedSubscript:0];
        LODWORD(a2) = [(id)a3 intValue];

        OSType v20 = [v19 objectAtIndexedSubscript:1];
        LODWORD(a3) = [v20 intValue];

        uint64_t v21 = 2980;
        unint64_t v22 = @"%s:%d - ERROR - did not find dimensions in file name - width/height ill formatted";
        if (a2 && a3)
        {
          a2 = (int)a2;
          a3 = (int)a3;

          goto LABEL_5;
        }
      }
      else
      {
        uint64_t v21 = 2969;
        unint64_t v22 = @"%s:%d - ERROR - did not find dimensions in file name - extension ill formatted";
      }
      NSLog(&v22->isa, "pixelBufferFromRawFile", v21);
    }
    goto LABEL_23;
  }
LABEL_5:
  CVPixelBufferRef pixelBufferOut = 0;
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], a2, a3, a4, BufferAttributes, &pixelBufferOut)) {
    unint64_t v15 = 0;
  }
  else {
    unint64_t v15 = pixelBufferOut;
  }
  if (PixelBufferUtils::pixelBufferFromRawFileWithBuffer(this, v15, v14))
  {
    CVPixelBufferRelease(v15);
LABEL_23:
    unint64_t v15 = 0;
  }

  return v15;
}

void sub_215FB4148(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void PixelBufferUtils::pixelBufferToRawFile(PixelBufferUtils *this, CVPixelBufferRef pixelBuffer, __CVBuffer *a3)
{
  if (!pixelBuffer) {
    return;
  }
  int v3 = pixelBuffer;
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  BOOL isPixelFormatCompressed = PixelBufferUtils::isPixelFormatCompressed((PixelBufferUtils *)PixelFormatType);
  if (isPixelFormatCompressed)
  {
    OSType v6 = PixelBufferUtils::uncompressedEquivalentForPixelFormat((PixelBufferUtils *)PixelFormatType);
    size_t Width = CVPixelBufferGetWidth(v3);
    size_t Height = CVPixelBufferGetHeight(v3);
    pixelBufferOut.__r_.__value_.__r.__words[0] = 0;
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
    CVReturn v11 = CVPixelBufferCreate(v9, Width, Height, v6, BufferAttributes, (CVPixelBufferRef *)&pixelBufferOut);
    std::string::size_type v12 = pixelBufferOut.__r_.__value_.__r.__words[0];
    if (v11) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = (__CVBuffer *)pixelBufferOut.__r_.__value_.__r.__words[0];
    }
    if (PixelBufferUtils::convertPixelBufferFormat(v3, v13, (__CVBuffer *)1))
    {
      CVPixelBufferRelease(v13);
LABEL_8:
      PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&pixelBufferOut);
      if ((pixelBufferOut.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_std::string pixelBufferOut = &pixelBufferOut;
      }
      else {
        p_std::string pixelBufferOut = (std::string *)pixelBufferOut.__r_.__value_.__r.__words[0];
      }
      NSLog(&cfstr_SDErrorPixelFo.isa, "pixelBufferToRawFile", 3011, PixelFormatType, p_pixelBufferOut);
      goto LABEL_127;
    }
    int v3 = (__CVBuffer *)v12;
    if (!v13) {
      goto LABEL_8;
    }
  }
  size_t v15 = strlen((const char *)this);
  if (v15 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v16 = v15;
  if (v15 >= 0x17)
  {
    uint64_t v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17) {
      uint64_t v18 = v15 | 7;
    }
    uint64_t v19 = v18 + 1;
    uint64_t v17 = (std::string *)operator new(v18 + 1);
    pixelBufferOut.__r_.__value_.__l.__size_ = v16;
    pixelBufferOut.__r_.__value_.__r.__words[2] = v19 | 0x8000000000000000;
    pixelBufferOut.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
    goto LABEL_20;
  }
  *((unsigned char *)&pixelBufferOut.__r_.__value_.__s + 23) = v15;
  uint64_t v17 = &pixelBufferOut;
  if (v15) {
LABEL_20:
  }
    memcpy(v17, this, v16);
  v17->__r_.__value_.__s.__data_[v16] = 0;
  OSType v20 = NSURL;
  uint64_t v21 = [NSString stringWithUTF8String:this];
  unint64_t v22 = [v20 fileURLWithPath:v21];
  size_t v23 = [v22 pathExtension];
  int v24 = [v23 isEqualToString:&stru_26C6879A8];

  if (!v24) {
    goto LABEL_105;
  }
  std::string::append(&pixelBufferOut, ".");
  size_t v25 = CVPixelBufferGetWidth(v3);
  size_t v26 = CVPixelBufferGetHeight(v3);
  std::to_string(&v80, v25);
  size_t v27 = std::string::append(&v80, "x");
  long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v81.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v81.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  v27->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v79, v26);
  if ((v79.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v29 = &v79;
  }
  else {
    size_t v29 = (std::string *)v79.__r_.__value_.__r.__words[0];
  }
  if ((v79.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v79.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v79.__r_.__value_.__l.__size_;
  }
  size_t v31 = std::string::append(&v81, (const std::string::value_type *)v29, size);
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  int64_t v83 = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)vImage_Buffer __p = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v81.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_30;
    }
LABEL_65:
    operator delete(v81.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_31;
    }
LABEL_66:
    operator delete(v80.__r_.__value_.__l.__data_);
    goto LABEL_31;
  }
  operator delete(v79.__r_.__value_.__l.__data_);
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_65;
  }
LABEL_30:
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_66;
  }
LABEL_31:
  if (v83 >= 0) {
    size_t v33 = __p;
  }
  else {
    size_t v33 = (void **)__p[0];
  }
  if (v83 >= 0) {
    std::string::size_type v34 = HIBYTE(v83);
  }
  else {
    std::string::size_type v34 = (std::string::size_type)__p[1];
  }
  std::string::append(&pixelBufferOut, (const std::string::value_type *)v33, v34);
  std::string::append(&pixelBufferOut, ".");
  unint64_t v35 = CVPixelBufferGetPixelFormatType(v3);
  PixelBufferUtils::pixelFormatAsString(v35, (char *)&v81);
  unint64_t v36 = HIBYTE(v81.__r_.__value_.__r.__words[2]);
  unsigned __int8 v37 = HIBYTE(v81.__r_.__value_.__r.__words[2]);
  std::string::size_type v39 = v81.__r_.__value_.__l.__size_;
  std::string::size_type v38 = v81.__r_.__value_.__r.__words[0];
  if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v40 = &v81;
  }
  else {
    size_t v40 = (std::string *)v81.__r_.__value_.__r.__words[0];
  }
  if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v41 = HIBYTE(v81.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v41 = v81.__r_.__value_.__l.__size_;
  }
  if (!v41) {
    goto LABEL_69;
  }
  OSType v42 = v40;
  if (v41 < 8) {
    goto LABEL_133;
  }
  unint64_t v43 = v41 & 0xFFFFFFFFFFFFFFF8;
  float32x4_t v44 = &v40->__r_.__value_.__s.__data_[3];
  unint64_t v45 = v41 & 0xFFFFFFFFFFFFFFF8;
  do
  {
    int8x8_t v46 = vceq_s8(*(int8x8_t *)(v44 - 3), (int8x8_t)0x2F2F2F2F2F2F2F2FLL);
    if (v46.i8[0])
    {
      *(v44 - 3) = 58;
      if ((v46.i8[1] & 1) == 0) {
        goto LABEL_49;
      }
    }
    else if ((v46.i8[1] & 1) == 0)
    {
LABEL_49:
      if (v46.i8[2]) {
        goto LABEL_50;
      }
      goto LABEL_58;
    }
    *(v44 - 2) = 58;
    if (v46.i8[2])
    {
LABEL_50:
      *(v44 - 1) = 58;
      if ((v46.i8[3] & 1) == 0) {
        goto LABEL_51;
      }
      goto LABEL_59;
    }
LABEL_58:
    if ((v46.i8[3] & 1) == 0)
    {
LABEL_51:
      if (v46.i8[4]) {
        goto LABEL_52;
      }
      goto LABEL_60;
    }
LABEL_59:
    *float32x4_t v44 = 58;
    if (v46.i8[4])
    {
LABEL_52:
      v44[1] = 58;
      if ((v46.i8[5] & 1) == 0) {
        goto LABEL_53;
      }
      goto LABEL_61;
    }
LABEL_60:
    if ((v46.i8[5] & 1) == 0)
    {
LABEL_53:
      if ((v46.i8[6] & 1) == 0) {
        goto LABEL_62;
      }
      goto LABEL_54;
    }
LABEL_61:
    v44[2] = 58;
    if ((v46.i8[6] & 1) == 0)
    {
LABEL_62:
      if ((v46.i8[7] & 1) == 0) {
        goto LABEL_46;
      }
      goto LABEL_63;
    }
LABEL_54:
    v44[3] = 58;
    if ((v46.i8[7] & 1) == 0) {
      goto LABEL_46;
    }
LABEL_63:
    v44[4] = 58;
LABEL_46:
    v44 += 8;
    v45 -= 8;
  }
  while (v45);
  if (v41 == v43) {
    goto LABEL_68;
  }
  OSType v42 = (std::string *)((char *)v40 + v43);
LABEL_133:
  long double v76 = (std::string *)((char *)v40 + v41);
  do
  {
    if (v42->__r_.__value_.__s.__data_[0] == 47) {
      v42->__r_.__value_.__s.__data_[0] = 58;
    }
    OSType v42 = (std::string *)((char *)v42 + 1);
  }
  while (v42 != v76);
LABEL_68:
  unint64_t v36 = HIBYTE(v81.__r_.__value_.__r.__words[2]);
  std::string::size_type v39 = v81.__r_.__value_.__l.__size_;
  std::string::size_type v38 = v81.__r_.__value_.__r.__words[0];
  unsigned __int8 v37 = HIBYTE(v81.__r_.__value_.__r.__words[2]);
LABEL_69:
  if ((v37 & 0x80u) == 0) {
    size_t v47 = &v81;
  }
  else {
    size_t v47 = (std::string *)v38;
  }
  if ((v37 & 0x80u) != 0) {
    unint64_t v36 = v39;
  }
  if (!v36) {
    goto LABEL_97;
  }
  size_t v48 = v47;
  if (v36 < 8) {
    goto LABEL_138;
  }
  unint64_t v49 = v36 & 0xFFFFFFFFFFFFFFF8;
  size_t v50 = &v47->__r_.__value_.__s.__data_[3];
  unint64_t v51 = v36 & 0xFFFFFFFFFFFFFFF8;
  while (2)
  {
    int8x8_t v52 = vceq_s8(*(int8x8_t *)(v50 - 3), (int8x8_t)0x2E2E2E2E2E2E2E2ELL);
    if (v52.i8[0])
    {
      *(v50 - 3) = 95;
      if ((v52.i8[1] & 1) == 0) {
        goto LABEL_80;
      }
LABEL_88:
      *(v50 - 2) = 95;
      if ((v52.i8[2] & 1) == 0) {
        goto LABEL_89;
      }
LABEL_81:
      *(v50 - 1) = 95;
      if ((v52.i8[3] & 1) == 0) {
        goto LABEL_82;
      }
LABEL_90:
      std::string::value_type *v50 = 95;
      if ((v52.i8[4] & 1) == 0) {
        goto LABEL_91;
      }
LABEL_83:
      v50[1] = 95;
      if ((v52.i8[5] & 1) == 0) {
        goto LABEL_84;
      }
LABEL_92:
      v50[2] = 95;
      if ((v52.i8[6] & 1) == 0) {
        goto LABEL_93;
      }
LABEL_85:
      v50[3] = 95;
      if (v52.i8[7]) {
        goto LABEL_94;
      }
    }
    else
    {
      if (v52.i8[1]) {
        goto LABEL_88;
      }
LABEL_80:
      if (v52.i8[2]) {
        goto LABEL_81;
      }
LABEL_89:
      if (v52.i8[3]) {
        goto LABEL_90;
      }
LABEL_82:
      if (v52.i8[4]) {
        goto LABEL_83;
      }
LABEL_91:
      if (v52.i8[5]) {
        goto LABEL_92;
      }
LABEL_84:
      if (v52.i8[6]) {
        goto LABEL_85;
      }
LABEL_93:
      if (v52.i8[7]) {
LABEL_94:
      }
        v50[4] = 95;
    }
    v50 += 8;
    v51 -= 8;
    if (v51) {
      continue;
    }
    break;
  }
  if (v36 == v49) {
    goto LABEL_96;
  }
  size_t v48 = (std::string *)((char *)v47 + v49);
LABEL_138:
  float32x4_t v77 = (std::string *)((char *)v47 + v36);
  do
  {
    if (v48->__r_.__value_.__s.__data_[0] == 46) {
      v48->__r_.__value_.__s.__data_[0] = 95;
    }
    size_t v48 = (std::string *)((char *)v48 + 1);
  }
  while (v48 != v77);
LABEL_96:
  unsigned __int8 v37 = HIBYTE(v81.__r_.__value_.__r.__words[2]);
  std::string::size_type v39 = v81.__r_.__value_.__l.__size_;
  std::string::size_type v38 = v81.__r_.__value_.__r.__words[0];
LABEL_97:
  if ((v37 & 0x80u) == 0) {
    size_t v53 = &v81;
  }
  else {
    size_t v53 = (std::string *)v38;
  }
  if ((v37 & 0x80u) == 0) {
    std::string::size_type v54 = v37;
  }
  else {
    std::string::size_type v54 = v39;
  }
  std::string::append(&pixelBufferOut, (const std::string::value_type *)v53, v54);
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v81.__r_.__value_.__l.__data_);
    if (SHIBYTE(v83) < 0) {
      goto LABEL_131;
    }
  }
  else
  {
    if ((SHIBYTE(v83) & 0x80000000) == 0) {
      goto LABEL_105;
    }
LABEL_131:
    operator delete(__p[0]);
  }
LABEL_105:
  if ((pixelBufferOut.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    id v55 = &pixelBufferOut;
  }
  else {
    id v55 = (std::string *)pixelBufferOut.__r_.__value_.__r.__words[0];
  }
  unsigned int v56 = fopen((const char *)v55, "wb");
  if (v56)
  {
    if (CVPixelBufferGetPlaneCount(v3))
    {
      CVPixelBufferLockBaseAddress(v3, 1uLL);
      OSType v57 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(v3);
      size_t PlaneCount = CVPixelBufferGetPlaneCount(v3);
      if (PlaneCount)
      {
        for (size_t i = 0; i != PlaneCount; ++i)
        {
          size_t v60 = PixelBufferUtils::pixelSizeForPixelFormat(v57, i);
          size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(v3, i);
          size_t WidthOfPlane = CVPixelBufferGetWidthOfPlane(v3, i);
          size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v3, i);
          BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(v3, i);
          if (HeightOfPlane)
          {
            CGRect v65 = BaseAddressOfPlane;
            do
            {
              fwrite(v65, v60, WidthOfPlane, v56);
              v65 += BytesPerRowOfPlane;
              --HeightOfPlane;
            }
            while (HeightOfPlane);
          }
        }
      }
    }
    else
    {
      CVPixelBufferLockBaseAddress(v3, 1uLL);
      CGRect v69 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(v3);
      size_t v70 = PixelBufferUtils::pixelSizeForPixelFormat(v69, 0);
      size_t v71 = CVPixelBufferGetHeight(v3);
      size_t v72 = CVPixelBufferGetWidth(v3);
      size_t BytesPerRow = CVPixelBufferGetBytesPerRow(v3);
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(v3);
      if (v71)
      {
        long double v75 = BaseAddress;
        do
        {
          fwrite(v75, v70, v72, v56);
          v75 += BytesPerRow;
          --v71;
        }
        while (v71);
      }
    }
    CVPixelBufferUnlockBaseAddress(v3, 1uLL);
  }
  else
  {
    if ((pixelBufferOut.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CGRect v66 = &pixelBufferOut;
    }
    else {
      CGRect v66 = (std::string *)pixelBufferOut.__r_.__value_.__r.__words[0];
    }
    CGRect v67 = __error();
    CGRect v68 = strerror(*v67);
    NSLog(&cfstr_SDErrorFailedO.isa, "pixelBufferToRawFile", 3036, v66, v68);
  }
  fclose(v56);
  if (isPixelFormatCompressed) {
    CVPixelBufferRelease(v3);
  }
LABEL_127:
  if (SHIBYTE(pixelBufferOut.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(pixelBufferOut.__r_.__value_.__l.__data_);
  }
}

void sub_215FB4970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  if (*(char *)(v39 - 89) < 0) {
    operator delete(*(void **)(v39 - 112));
  }
  _Unwind_Resume(exception_object);
}

CVPixelBufferRef PixelBufferUtils::pixelBufferFromImageFile(PixelBufferUtils *this, CGImage *a2)
{
  if (this)
  {
    int v3 = NSURL;
    OSType v4 = [NSString stringWithUTF8String:this];
    CFURLRef v5 = [v3 fileURLWithPath:v4];

    OSType v6 = CGImageSourceCreateWithURL(v5, 0);
    unint64_t v7 = v6;
    if (v6)
    {
      if (CGImageSourceGetCount(v6))
      {
        ImageAtIndedouble x = CGImageSourceCreateImageAtIndex(v7, 0, 0);
        CVPixelBufferRef v9 = PixelBufferUtils::pixelBufferFromCGImage(ImageAtIndex, a2);
        CGImageRelease(ImageAtIndex);
        CFRelease(v7);
LABEL_8:

        return v9;
      }
      CFRelease(v7);
    }
    CVPixelBufferRef v9 = 0;
    goto LABEL_8;
  }
  return 0;
}

void sub_215FB4B48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__CVBuffer *PixelBufferUtils::blacken(__CVBuffer *this, __CVBuffer *a2)
{
  if (this)
  {
    OSType v2 = this;
    size_t PlaneCount = CVPixelBufferGetPlaneCount(this);
    CVPixelBufferLockBaseAddress(v2, 0);
    if (PlaneCount)
    {
      for (size_t i = 0; i != PlaneCount; ++i)
      {
        size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v2, i);
        size_t v6 = CVPixelBufferGetHeightOfPlane(v2, i) * BytesPerRowOfPlane;
        BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(v2, i);
        bzero(BaseAddressOfPlane, v6);
      }
    }
    else
    {
      size_t DataSize = CVPixelBufferGetDataSize(v2);
      BaseAddress = CVPixelBufferGetBaseAddress(v2);
      bzero(BaseAddress, DataSize);
    }
    return (__CVBuffer *)CVPixelBufferUnlockBaseAddress(v2, 0);
  }
  return this;
}

float PixelBufferUtils::getTurboColor(PixelBufferUtils *this, float a2, float *a3, float *a4, float *a5)
{
  unsigned int v5 = (float)(a2 * 255.0);
  if (v5 + 1 < 0xFF) {
    unsigned int v6 = v5 + 1;
  }
  else {
    unsigned int v6 = 255;
  }
  float v7 = -(float)((float)(float)(a2 * 255.0) - (float)(a2 * 255.0));
  uint64_t v8 = 4 * v5;
  uint64_t v9 = 4 * v6;
  *(float *)this = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap + v8)
                 + (float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap
                                            + v9)
                                 - *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap
                                            + v8))
                         * v7);
  *a3 = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap + v8)
      + (float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap + v9)
                      - *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap + v8))
              * v7);
  float result = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::blueMap + v8)
         + (float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::blueMap
                                    + v9)
                         - *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::blueMap
                                    + v8))
                 * v7);
  *a4 = result;
  return result;
}

float *PixelBufferUtils::getJetColor(float *this, float a2, float *a3, float *a4, float *a5)
{
  *this = 1.5 - fabsf((float)(a2 * 4.0) + -3.0);
  *a3 = 1.5 - fabsf((float)(a2 * 4.0) + -2.0);
  *a4 = 1.5 - fabsf((float)(a2 * 4.0) + -1.0);
  float v5 = 0.0;
  if (*this <= 1.0) {
    float v6 = *this;
  }
  else {
    float v6 = 1.0;
  }
  if (*this >= 0.0) {
    float v7 = v6;
  }
  else {
    float v7 = 0.0;
  }
  *this = v7;
  if (*a3 <= 1.0) {
    float v8 = *a3;
  }
  else {
    float v8 = 1.0;
  }
  if (*a3 >= 0.0) {
    float v9 = v8;
  }
  else {
    float v9 = 0.0;
  }
  *a3 = v9;
  if (*a4 >= 0.0)
  {
    float v5 = 1.0;
    if (*a4 <= 1.0) {
      float v5 = *a4;
    }
  }
  *a4 = v5;
  return this;
}

uint64_t PixelBufferUtils::colorizedDepthPixelBuffer(PixelBufferUtils *this, __CVBuffer *a2, int a3, float a4, float a5, uint64_t a6, __CVBuffer *a7, __CVBuffer *a8)
{
  _S8 = a5;
  int v13 = (int)a2;
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  CVPixelBufferLockBaseAddress(this, 1uLL);
  CVPixelBufferLockBaseAddress(a7, 0);
  memset(&v136, 0, sizeof(v136));
  std::string::size_type v16 = (CGRect *)MEMORY[0x263F001A8];
  PixelBufferUtils::asVImageBuffer(this, *MEMORY[0x263F001A8], &v136);
  memset(&v135, 0, sizeof(v135));
  PixelBufferUtils::asVImageBuffer(a7, *v16, &v135);
  if ((int)PixelFormatType > 1717855599)
  {
    if ((int)PixelFormatType > 1751410031)
    {
      if (PixelFormatType != 1751410032 && PixelFormatType != 1751411059)
      {
        if (PixelFormatType != 1932996149) {
          goto LABEL_149;
        }
        goto LABEL_26;
      }
LABEL_12:
      vImagePixelCount height = v136.height;
      data = (char *)v136.data;
      if (v13)
      {
        if (!v136.height) {
          goto LABEL_146;
        }
        vImagePixelCount width = v136.width;
        if (!v136.width) {
          goto LABEL_146;
        }
        uint64_t v21 = 0;
        _H0 = *(_WORD *)v136.data;
        __asm { FCVT            S8, H0 }
        size_t v27 = (char *)v136.data;
        a4 = _S8;
        do
        {
          uint64_t v28 = 0;
          do
          {
            _H0 = *(_WORD *)&v27[2 * v28];
            __asm { FCVT            S0, H0 }
            if (_S8 > _S0) {
              _S8 = _S0;
            }
            if (a4 < _S0) {
              a4 = _S0;
            }
            ++v28;
          }
          while (v136.width > v28);
          ++v21;
          v27 += v136.rowBytes;
        }
        while (v136.height > v21);
      }
      else
      {
        if (!v136.height) {
          goto LABEL_146;
        }
        vImagePixelCount width = v136.width;
      }
      if (width)
      {
        uint64_t v71 = 0;
        float v72 = a4 - _S8;
        size_t rowBytes = v135.rowBytes;
        float64x2_t v74 = (char *)v135.data + 1;
        size_t v75 = v136.rowBytes;
        do
        {
          uint64_t v76 = 0;
          float32x4_t v77 = v74;
          if (a6)
          {
            do
            {
              _H3 = *(_WORD *)&data[2 * v76];
              __asm { FCVT            S4, H3 }
              if (a3 && _S4 == 0.0)
              {
                char v85 = 0;
              }
              else
              {
                float v78 = (float)(_S4 - _S8) / v72;
                float v79 = v78 * 255.0;
                if (v78 > 1.0) {
                  float v79 = 255.0;
                }
                if (v78 >= 0.0) {
                  float v80 = v79;
                }
                else {
                  float v80 = 0.0;
                }
                uint64_t v81 = 3 * (int)v80;
                long double v82 = (float *)(a6 + 4 * (int)v81);
                float v83 = *v82;
                float v84 = *(float *)(a6 + 4 * v81 + 4);
                *(v77 - 1) = (int)(float)(v82[2] * 255.0);
                unsigned char *v77 = (int)(float)(v84 * 255.0);
                v77[1] = (int)(float)(v83 * 255.0);
                char v85 = -1;
              }
              v77[2] = v85;
              ++v76;
              v77 += 4;
            }
            while (width > v76);
          }
          else
          {
            do
            {
              _H3 = *(_WORD *)&data[2 * v76];
              __asm { FCVT            S4, H3 }
              if (a3 && _S4 == 0.0)
              {
                char v92 = 0;
              }
              else
              {
                float v88 = (float)(_S4 - _S8) / v72;
                if (v88 <= 1.0) {
                  float v89 = (float)(_S4 - _S8) / v72;
                }
                else {
                  float v89 = 1.0;
                }
                if (v88 >= 0.0) {
                  float v90 = v89;
                }
                else {
                  float v90 = 0.0;
                }
                unsigned int v91 = (float)(v90 * 255.0);
                char v92 = -1;
                if (v91 + 1 < 0xFF) {
                  unsigned int v93 = v91 + 1;
                }
                else {
                  unsigned int v93 = 255;
                }
                uint64_t v94 = 4 * (float)(v90 * 255.0);
                float v95 = -(float)((float)(float)(v90 * 255.0) - (float)(v90 * 255.0));
                uint64_t v96 = 4 * v93;
                float v97 = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap + v94)
                    + (float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap
                                               + v96)
                                    - *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap
                                               + v94))
                            * v95);
                float v98 = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::blueMap + v94);
                float v99 = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::blueMap + v96)
                    - v98;
                LODWORD(v96) = (int)(float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap
                                                             + v94)
                                                  + (float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap
                                                                             + v96)
                                                                  - *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap
                                                                             + v94))
                                                          * v95))
                                          * 255.0);
                *(v77 - 1) = (int)(float)((float)(v98 + (float)(v99 * v95)) * 255.0);
                unsigned char *v77 = v96;
                v77[1] = (int)(float)(v97 * 255.0);
              }
              v77[2] = v92;
              ++v76;
              v77 += 4;
            }
            while (width > v76);
          }
          ++v71;
          data += v75;
          v74 += rowBytes;
        }
        while (height > v71);
      }
      goto LABEL_146;
    }
    if (PixelFormatType == 1717855600 || PixelFormatType == 1717856627)
    {
      vImagePixelCount v65 = v136.height;
      CGRect v64 = (float *)v136.data;
      if (v13)
      {
        if (!v136.height) {
          goto LABEL_146;
        }
        vImagePixelCount v66 = v136.width;
        if (!v136.width) {
          goto LABEL_146;
        }
        uint64_t v67 = 0;
        _S8 = *(float *)v136.data;
        CGRect v68 = (float *)v136.data;
        a4 = *(float *)v136.data;
        do
        {
          uint64_t v69 = 0;
          do
          {
            float v70 = v68[v69];
            if (v70 < _S8) {
              _S8 = v68[v69];
            }
            if (a4 < v70) {
              a4 = v68[v69];
            }
            ++v69;
          }
          while (v136.width > v69);
          ++v67;
          CGRect v68 = (float *)((char *)v68 + v136.rowBytes);
        }
        while (v136.height > v67);
      }
      else
      {
        if (!v136.height) {
          goto LABEL_146;
        }
        vImagePixelCount v66 = v136.width;
      }
      if (v66)
      {
        uint64_t v102 = 0;
        float v103 = a4 - _S8;
        size_t v104 = v135.rowBytes;
        int v105 = (char *)v135.data + 1;
        size_t v106 = v136.rowBytes;
        do
        {
          uint64_t v107 = 0;
          unsigned int v108 = v105;
          if (a6)
          {
            do
            {
              float v117 = v64[v107];
              if (a3 && v117 == 0.0)
              {
                char v116 = 0;
              }
              else
              {
                float v109 = (float)(v117 - _S8) / v103;
                float v110 = v109 * 255.0;
                if (v109 > 1.0) {
                  float v110 = 255.0;
                }
                if (v109 >= 0.0) {
                  float v111 = v110;
                }
                else {
                  float v111 = 0.0;
                }
                uint64_t v112 = 3 * (int)v111;
                float v113 = (float *)(a6 + 4 * (int)v112);
                float v114 = *v113;
                float v115 = *(float *)(a6 + 4 * v112 + 4);
                *(v108 - 1) = (int)(float)(v113[2] * 255.0);
                *unsigned int v108 = (int)(float)(v115 * 255.0);
                v108[1] = (int)(float)(v114 * 255.0);
                char v116 = -1;
              }
              v108[2] = v116;
              ++v107;
              v108 += 4;
            }
            while (v66 > v107);
          }
          else
          {
            do
            {
              float v130 = v64[v107];
              if (a3 && v130 == 0.0)
              {
                char v122 = 0;
              }
              else
              {
                float v118 = (float)(v130 - _S8) / v103;
                if (v118 <= 1.0) {
                  float v119 = v118;
                }
                else {
                  float v119 = 1.0;
                }
                if (v118 >= 0.0) {
                  float v120 = v119;
                }
                else {
                  float v120 = 0.0;
                }
                unsigned int v121 = (float)(v120 * 255.0);
                char v122 = -1;
                if (v121 + 1 < 0xFF) {
                  unsigned int v123 = v121 + 1;
                }
                else {
                  unsigned int v123 = 255;
                }
                uint64_t v124 = 4 * (float)(v120 * 255.0);
                float v125 = -(float)((float)(float)(v120 * 255.0) - (float)(v120 * 255.0));
                uint64_t v126 = 4 * v123;
                float v127 = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap + v124)
                     + (float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap
                                                + v126)
                                     - *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap
                                                + v124))
                             * v125);
                float v128 = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::blueMap + v124);
                float v129 = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::blueMap + v126)
                     - v128;
                LODWORD(v126) = (int)(float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap
                                                              + v124)
                                                   + (float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap
                                                                              + v126)
                                                                   - *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap
                                                                              + v124))
                                                           * v125))
                                           * 255.0);
                *(v108 - 1) = (int)(float)((float)(v128 + (float)(v129 * v125)) * 255.0);
                *unsigned int v108 = v126;
                v108[1] = (int)(float)(v127 * 255.0);
              }
              v108[2] = v122;
              ++v107;
              v108 += 4;
            }
            while (v66 > v107);
          }
          ++v102;
          CGRect v64 = (float *)((char *)v64 + v106);
          v105 += v104;
        }
        while (v65 > v102);
      }
      goto LABEL_146;
    }
LABEL_149:
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)__p);
    if (v134 >= 0) {
      long double v132 = __p;
    }
    else {
      long double v132 = (void **)__p[0];
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "colorizedDepthPixelBuffer", 3269, PixelFormatType, v132);
    if (v134 < 0) {
      operator delete(__p[0]);
    }
    CVPixelBufferUnlockBaseAddress(a7, 0);
    return 0xFFFFFFFFLL;
  }
  if ((int)PixelFormatType <= 1278226535)
  {
    if (PixelFormatType == 825306677 || PixelFormatType == 825437747) {
      goto LABEL_26;
    }
    goto LABEL_149;
  }
  if (PixelFormatType == 1278226536) {
    goto LABEL_12;
  }
  if (PixelFormatType != 1278226742 && PixelFormatType != 1647392359) {
    goto LABEL_149;
  }
LABEL_26:
  vImagePixelCount v32 = v136.height;
  size_t v31 = v136.data;
  if (v13)
  {
    if (v136.height)
    {
      vImagePixelCount v33 = v136.width;
      if (v136.width)
      {
        uint64_t v34 = 0;
        LOWORD(v17) = *(_WORD *)v136.data;
        _S8 = (float)LODWORD(v17);
        unint64_t v35 = (char *)v136.data;
        a4 = (float)LODWORD(v17);
        do
        {
          uint64_t v36 = 0;
          do
          {
            LOWORD(v17) = *(_WORD *)&v35[2 * v36];
            float v17 = (float)LODWORD(v17);
            if (_S8 > v17) {
              _S8 = v17;
            }
            if (a4 < v17) {
              a4 = v17;
            }
            ++v36;
          }
          while (v136.width > v36);
          ++v34;
          v35 += v136.rowBytes;
        }
        while (v136.height > v34);
        goto LABEL_40;
      }
    }
  }
  else if (v136.height)
  {
    vImagePixelCount v33 = v136.width;
    if (v136.width)
    {
LABEL_40:
      uint64_t v37 = 0;
      float v38 = a4 - _S8;
      size_t v39 = v135.rowBytes;
      size_t v40 = (char *)v135.data + 1;
      size_t v41 = v136.rowBytes;
      uint64_t v42 = 1;
      do
      {
        if (v42)
        {
          uint64_t v43 = 0;
          float32x4_t v44 = v40;
          if (a6)
          {
            do
            {
              LODWORD(v51) = (unsigned __int16)v31[v43];
              if (!a3 || v31[v43])
              {
                float v45 = (float)((float)v51 - _S8) / v38;
                float v46 = v45 * 255.0;
                if (v45 > 1.0) {
                  float v46 = 255.0;
                }
                if (v45 >= 0.0) {
                  float v47 = v46;
                }
                else {
                  float v47 = 0.0;
                }
                uint64_t v51 = 3 * (int)v47;
                size_t v48 = (float *)(a6 + 4 * (int)v51);
                float v49 = *v48;
                float v50 = *(float *)(a6 + 4 * v51 + 4);
                *(v44 - 1) = (int)(float)(v48[2] * 255.0);
                *float32x4_t v44 = (int)(float)(v50 * 255.0);
                v44[1] = (int)(float)(v49 * 255.0);
                LOBYTE(v51) = -1;
              }
              v44[2] = v51;
              ++v43;
              v44 += 4;
            }
            while (v33 > v43);
          }
          else
          {
            do
            {
              unsigned int v56 = (unsigned __int16)v31[v43];
              if (!a3 || v31[v43])
              {
                float v52 = (float)((float)v56 - _S8) / v38;
                if (v52 <= 1.0) {
                  float v53 = (float)((float)v56 - _S8) / v38;
                }
                else {
                  float v53 = 1.0;
                }
                if (v52 >= 0.0) {
                  float v54 = v53;
                }
                else {
                  float v54 = 0.0;
                }
                unsigned int v55 = (float)(v54 * 255.0);
                LOBYTE(v56) = -1;
                if (v55 + 1 < 0xFF) {
                  unsigned int v57 = v55 + 1;
                }
                else {
                  unsigned int v57 = 255;
                }
                uint64_t v58 = 4 * (float)(v54 * 255.0);
                float v59 = -(float)((float)(float)(v54 * 255.0) - (float)(v54 * 255.0));
                uint64_t v60 = 4 * v57;
                float v61 = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap + v58)
                    + (float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap
                                               + v60)
                                    - *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::redMap
                                               + v58))
                            * v59);
                float v62 = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::blueMap + v58);
                float v63 = *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::blueMap + v60)
                    - v62;
                LODWORD(v60) = (int)(float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap
                                                             + v58)
                                                  + (float)((float)(*(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap
                                                                             + v60)
                                                                  - *(float *)((char *)&PixelBufferUtils::getTurboColor(float,float &,float &,float &)::greenMap
                                                                             + v58))
                                                          * v59))
                                          * 255.0);
                *(v44 - 1) = (int)(float)((float)(v62 + (float)(v63 * v59)) * 255.0);
                *float32x4_t v44 = v60;
                v44[1] = (int)(float)(v61 * 255.0);
              }
              v44[2] = v56;
              ++v43;
              v44 += 4;
            }
            while (v33 > v43);
          }
          uint64_t v42 = v33;
        }
        ++v37;
        size_t v31 = (_WORD *)((char *)v31 + v41);
        v40 += v39;
      }
      while (v32 > v37);
    }
  }
LABEL_146:
  CVPixelBufferUnlockBaseAddress(this, 1uLL);
  if (a7) {
    CVPixelBufferUnlockBaseAddress(a7, 0);
  }
  return 0;
}

void sub_215FB5658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CVPixelBufferRef PixelBufferUtils::createColorizedDepthPixelBuffer(PixelBufferUtils *this, __CVBuffer *a2, __CVBuffer **a3, float a4, float a5, uint64_t a6, __CVBuffer *a7, __CVBuffer *a8, float a9)
{
  size_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v19, Width, Height, 0x42475241u, BufferAttributes, &pixelBufferOut)) {
    unint64_t v22 = 0;
  }
  else {
    unint64_t v22 = pixelBufferOut;
  }
  CVPixelBufferRef texture = v22;
  if (PixelBufferUtils::colorizedDepthPixelBuffer(this, a2, (int)a3, a5, a4, a6, v22, v21))
  {
    CVPixelBufferRelease(v22);
    unint64_t v22 = 0;
    CVPixelBufferRef texture = 0;
  }
  if (a7)
  {
    size_t v23 = CVPixelBufferGetWidth(a7);
    size_t v24 = CVPixelBufferGetHeight(a7);
    CVPixelBufferRef pixelBufferOut = 0;
    CFDictionaryRef v25 = (const __CFDictionary *)getBufferAttributes();
    if (CVPixelBufferCreate(v19, v23, v24, 0x42475241u, v25, &pixelBufferOut)) {
      size_t v26 = 0;
    }
    else {
      size_t v26 = pixelBufferOut;
    }
    if (PixelBufferUtils::convertPixelBufferFormat(a7, v26, 0))
    {
      CVPixelBufferRelease(v26);
    }
    else if (v26)
    {
      *(float *)&double v27 = a9;
      char v31 = PixelBufferUtils::alphaBlend(v26, v22, &texture, v27, a3);
      CVPixelBufferRelease(v26);
      if (v31) {
        return texture;
      }
      goto LABEL_13;
    }
    CVPixelBufferRelease(v22);
    CVPixelBufferRef texture = 0;
    *(float *)&double v28 = a9;
    char v29 = PixelBufferUtils::alphaBlend(0, 0, &texture, v28, a3);
    CVPixelBufferRelease(0);
    if ((v29 & 1) == 0)
    {
LABEL_13:
      CVPixelBufferRelease(texture);
      return 0;
    }
  }
  return texture;
}

uint64_t PixelBufferUtils::alphaBlend(PixelBufferUtils *this, __CVBuffer *a2, __CVBuffer **a3, double a4, __CVBuffer **a5)
{
  int v5 = (int)a5;
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  size_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  OSType v12 = CVPixelBufferGetPixelFormatType(a2);
  size_t v13 = CVPixelBufferGetWidth(a2);
  size_t v14 = CVPixelBufferGetHeight(a2);
  if (PixelFormatType == v12 && Width == v13 && Height == v14)
  {
    size_t v15 = *a3;
    if (!*a3)
    {
      size_t v16 = CVPixelBufferGetWidth(this);
      size_t v17 = CVPixelBufferGetHeight(this);
      pixelBufferOut[0] = 0;
      CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
      if (CVPixelBufferCreate(v18, v16, v17, PixelFormatType, BufferAttributes, pixelBufferOut)) {
        size_t v15 = 0;
      }
      else {
        size_t v15 = pixelBufferOut[0];
      }
      *a3 = v15;
    }
    int v261 = v5;
    if ((int)PixelFormatType <= 1380401728)
    {
      if ((int)PixelFormatType > 875704437)
      {
        if ((int)PixelFormatType > 1111970368)
        {
          if (PixelFormatType != 1111970369)
          {
            if (PixelFormatType != 1278226534)
            {
              if (PixelFormatType != 1278226536) {
                goto LABEL_185;
              }
LABEL_137:
              size_t v180 = CVPixelBufferGetWidth(this);
              size_t v181 = CVPixelBufferGetHeight(this);
              CVPixelBufferLockBaseAddress(v15, 0);
              CVPixelBufferLockBaseAddress(this, 1uLL);
              CVPixelBufferLockBaseAddress(a2, 1uLL);
              size_t BytesPerRow = CVPixelBufferGetBytesPerRow(this);
              size_t v183 = CVPixelBufferGetBytesPerRow(a2);
              size_t v184 = CVPixelBufferGetBytesPerRow(v15);
              BaseAddress = (float16x4_t *)CVPixelBufferGetBaseAddress(this);
              vImagePixelCount v186 = (float16x4_t *)CVPixelBufferGetBaseAddress(a2);
              pixelBuffer = v15;
              size_t v187 = (float16x4_t *)CVPixelBufferGetBaseAddress(v15);
              vImagePixelCount v188 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(this);
              uint64_t v189 = PixelBufferUtils::componentsPerPixelForPixelFormat(v188, 0);
              unint64_t v190 = v189 * v180;
              if (v261)
              {
                if (v181 && v190)
                {
                  for (uint64_t i = 0; i != v181; ++i)
                  {
                    double v192 = (char *)BaseAddress + i * BytesPerRow;
                    vImagePixelCount v193 = (char *)v186 + i * v183;
                    size_t v194 = v189 * v180;
                    char v195 = (char *)v187 + i * v184;
                    do
                    {
                      __asm { FCMP            H1, #0 }
                      if (_ZF)
                      {
                        _H1 = *(_WORD *)v192;
                      }
                      else
                      {
                        __asm { FCVT            S1, H1 }
                        _H2 = *(_WORD *)v192;
                        __asm { FCVT            S2, H2 }
                        _S1 = (float)((float)(1.0 - *(float *)&a4) * _S1) + (float)(_S2 * *(float *)&a4);
                        __asm { FCVT            H1, S1 }
                      }
                      *(_WORD *)char v195 = _H1;
                      v195 += 2;
                      v192 += 2;
                      v193 += 2;
                      --v194;
                    }
                    while (v194);
                  }
                }
                goto LABEL_164;
              }
              if (v181 && v190)
              {
                uint64_t v205 = 0;
                float v206 = 1.0 - *(float *)&a4;
                unint64_t v207 = 2 * (v190 & 0xFFFFFFFFFFFFFFF8);
                float32x4_t v208 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
                unsigned int v209 = v187 + 1;
                long double v210 = BaseAddress + 1;
                float v211 = v186 + 1;
                do
                {
                  long double v212 = (char *)BaseAddress + v205 * BytesPerRow;
                  size_t v213 = (char *)v186 + v205 * v183;
                  long double v214 = (char *)v187 + v205 * v184;
                  if (v190 >= 8
                    && ((long double v215 = (char *)v187 + v205 * v184,
                         (unint64_t)(v215 - &BaseAddress->i8[v205 * BytesPerRow]) >= 0x10)
                      ? (BOOL v216 = (unint64_t)(v215 - &v186->i8[v205 * v183]) >= 0x10)
                      : (BOOL v216 = 0),
                        v216))
                  {
                    v213 += v207;
                    int8x8_t v226 = v211;
                    float64x2_t v227 = v210;
                    uint64x2_t v228 = v209;
                    unint64_t v229 = v190 & 0xFFFFFFFFFFFFFFF8;
                    do
                    {
                      float16x4_t v230 = vcvt_f16_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_f16(*v226), v206), v208, vcvtq_f32_f16(*v227)));
                      v228[-1] = vcvt_f16_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_f16(v226[-1]), v206), v208, vcvtq_f32_f16(v227[-1])));
                      *uint64x2_t v228 = v230;
                      v228 += 2;
                      v227 += 2;
                      v226 += 2;
                      v229 -= 8;
                    }
                    while (v229);
                    if (v190 == (v190 & 0xFFFFFFFFFFFFFFF8)) {
                      goto LABEL_150;
                    }
                    v214 += v207;
                    v212 += v207;
                    unint64_t v217 = v190 & 0xFFFFFFFFFFFFFFF8;
                  }
                  else
                  {
                    unint64_t v217 = 0;
                  }
                  unint64_t v218 = v190 - v217;
                  do
                  {
                    __int16 v219 = *(_WORD *)v212;
                    v212 += 2;
                    _H2 = v219;
                    __asm { FCVT            S2, H2 }
                    __int16 v222 = *(_WORD *)v213;
                    v213 += 2;
                    _H3 = v222;
                    __asm { FCVT            S3, H3 }
                    _S2 = (float)(v206 * _S3) + (float)(_S2 * *(float *)&a4);
                    __asm { FCVT            H2, S2 }
                    *(_WORD *)long double v214 = LOWORD(_S2);
                    v214 += 2;
                    --v218;
                  }
                  while (v218);
LABEL_150:
                  ++v205;
                  unsigned int v209 = (float16x4_t *)((char *)v209 + v184);
                  long double v210 = (float16x4_t *)((char *)v210 + BytesPerRow);
                  float v211 = (float16x4_t *)((char *)v211 + v183);
                }
                while (v205 != v181);
              }
LABEL_164:
              uint64_t v20 = 1;
              CVPixelBufferUnlockBaseAddress(this, 1uLL);
              CVPixelBufferUnlockBaseAddress(a2, 1uLL);
              long double v231 = pixelBuffer;
LABEL_165:
              CVPixelBufferUnlockBaseAddress(v231, 0);
              return v20;
            }
            goto LABEL_34;
          }
          goto LABEL_72;
        }
        if (PixelFormatType != 875704438)
        {
          int v23 = 1094862674;
          goto LABEL_71;
        }
        goto LABEL_72;
      }
      if ((int)PixelFormatType > 843264103)
      {
        if (PixelFormatType == 843264104) {
          goto LABEL_137;
        }
        int v23 = 875704422;
LABEL_71:
        if (PixelFormatType == v23) {
          goto LABEL_72;
        }
LABEL_185:
        PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)pixelBufferOut);
        if (v264 >= 0) {
          int8x8_t v258 = pixelBufferOut;
        }
        else {
          int8x8_t v258 = (CVPixelBufferRef *)pixelBufferOut[0];
        }
        NSLog(&cfstr_SDErrorPixelFo.isa, "alphaBlend", 3985, PixelFormatType, v258);
        if (v264 < 0) {
          operator delete(pixelBufferOut[0]);
        }
        return 0;
      }
      if (PixelFormatType == 32)
      {
LABEL_72:
        size_t v79 = CVPixelBufferGetWidth(this);
        size_t v80 = CVPixelBufferGetHeight(this);
        CVPixelBufferLockBaseAddress(v15, 0);
        CVPixelBufferLockBaseAddress(this, 1uLL);
        CVPixelBufferLockBaseAddress(a2, 1uLL);
        size_t v81 = CVPixelBufferGetBytesPerRow(this);
        size_t v82 = CVPixelBufferGetBytesPerRow(a2);
        size_t v83 = CVPixelBufferGetBytesPerRow(v15);
        float v84 = (int8x16_t *)CVPixelBufferGetBaseAddress(this);
        char v85 = (int8x16_t *)CVPixelBufferGetBaseAddress(a2);
        int v86 = v15;
        vImagePixelCount v87 = v85;
        pixelBuffer = v86;
        float v88 = (int16x8_t *)CVPixelBufferGetBaseAddress(v86);
        float v89 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(this);
        unint64_t v90 = PixelBufferUtils::componentsPerPixelForPixelFormat(v89, 0) * v79;
        if (v261)
        {
          if (!v80 || !v90) {
            goto LABEL_164;
          }
          uint64_t v95 = 0;
          float v96 = 1.0 - *(float *)&a4;
          unint64_t v97 = v90 & 0xFFFFFFFFFFFFFFFCLL;
          float32x4_t v98 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
          float v99 = v88;
          float64x2_t v100 = (__int32 *)v87;
          float64x2_t v101 = (__int32 *)v84;
          while (1)
          {
            uint64_t v102 = &v84->i8[v95 * v81];
            float v103 = &v87->i8[v95 * v82];
            size_t v104 = &v88->i8[v95 * v83];
            if (v90 < 8) {
              break;
            }
            int v105 = &v88->i8[v95 * v83];
            if ((unint64_t)(v105 - &v87->i8[v95 * v82]) < 4
              || (unint64_t)(v105 - &v84->i8[v95 * v81]) < 4)
            {
              break;
            }
            v103 += v97;
            float v110 = v99;
            float v111 = v100;
            uint64_t v112 = v101;
            unint64_t v113 = v90 & 0xFFFFFFFFFFFFFFFCLL;
            do
            {
              __int32 v114 = *v111++;
              v91.i32[0] = v114;
              int16x4_t v115 = (int16x4_t)vmovl_u8(v91).u64[0];
              int8x8_t v116 = (int8x8_t)vceqz_s16(v115);
              __int32 v117 = *v112++;
              v92.i32[0] = v117;
              int8x8_t v92 = (int8x8_t)vmovl_u8((uint8x8_t)v92).u64[0];
              int16x8_t v118 = (int16x8_t)vcvtq_s32_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)v115)), v96), v98, vcvtq_f32_u32(vmovl_u16((uint16x4_t)v92))));
              *(int8x8_t *)v118.i8 = vbsl_s8(v116, v92, (int8x8_t)vmovn_s32((int32x4_t)v118));
              uint8x8_t v91 = (uint8x8_t)vmovn_s16(v118);
              v110->i32[0] = v91.i32[0];
              float v110 = (int16x8_t *)((char *)v110 + 4);
              v113 -= 4;
            }
            while (v113);
            if (v90 != v97)
            {
              v104 += v97;
              v102 += v97;
              unint64_t v107 = v90 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_83:
              unint64_t v108 = v90 - v107;
              do
              {
                unsigned int v109 = *v102;
                if (*v103) {
                  unsigned int v109 = (int)(float)((float)(v96 * (float)*v103) + (float)((float)v109 * *(float *)&a4));
                }
                *v104++ = v109;
                ++v102;
                ++v103;
                --v108;
              }
              while (v108);
            }
            ++v95;
            float64x2_t v101 = (__int32 *)((char *)v101 + v81);
            float64x2_t v100 = (__int32 *)((char *)v100 + v82);
            float v99 = (int16x8_t *)((char *)v99 + v83);
            if (v95 == v80) {
              goto LABEL_164;
            }
          }
          unint64_t v107 = 0;
          goto LABEL_83;
        }
        if (!v80 || !v90) {
          goto LABEL_164;
        }
        uint64_t v119 = 0;
        float v120 = 1.0 - *(float *)&a4;
        unint64_t v121 = v90 & 0xFFFFFFFFFFFFFFF0;
        float32x4_t v122 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
        unint64_t v123 = v90 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v124 = v88;
        float v125 = v87;
        uint64_t v126 = v84;
        while (1)
        {
          float v127 = &v84->i8[v119 * v81];
          float v128 = &v87->u8[v119 * v82];
          float v129 = &v88->i8[v119 * v83];
          if (v90 < 4
            || ((float v130 = &v88->i8[v119 * v83], (unint64_t)(v130 - &v84->i8[v119 * v81]) >= 0x10)
              ? (BOOL v131 = (unint64_t)(v130 - &v87->i8[v119 * v82]) >= 0x10)
              : (BOOL v131 = 0),
                !v131))
          {
            unint64_t v132 = 0;
            goto LABEL_101;
          }
          if (v90 >= 0x10)
          {
            float64x2_t v138 = v124;
            float64x2_t v139 = v125;
            float64x2_t v140 = v126;
            unint64_t v141 = v90 & 0xFFFFFFFFFFFFFFF0;
            do
            {
              int8x16_t v142 = *v140++;
              float32x4_t v143 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v142, (int8x16_t)xmmword_215FC46F0));
              float32x4_t v144 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v142, (int8x16_t)xmmword_215FC46E0));
              float32x4_t v145 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v142, (int8x16_t)xmmword_215FC46D0));
              float32x4_t v94 = vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v142, (int8x16_t)xmmword_215FC46C0));
              int8x16_t v146 = *v139++;
              v265.val[3] = (int8x16_t)vcvtq_u32_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v146, (int8x16_t)xmmword_215FC46F0)), v120), v122, v143));
              v265.val[2] = (int8x16_t)vcvtq_u32_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v146, (int8x16_t)xmmword_215FC46E0)), v120), v122, v144));
              v265.val[1] = (int8x16_t)vcvtq_u32_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v146, (int8x16_t)xmmword_215FC46D0)), v120), v122, v145));
              v265.val[0] = (int8x16_t)vcvtq_u32_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_u32((uint32x4_t)vqtbl1q_s8(v146, (int8x16_t)xmmword_215FC46C0)), v120), v122, v94));
              int16x8_t v93 = (int16x8_t)vqtbl4q_s8(v265, (int8x16_t)xmmword_215FC4700);
              *v138++ = v93;
              v141 -= 16;
            }
            while (v141);
            if (v90 == v121) {
              goto LABEL_94;
            }
            unint64_t v137 = v90 & 0xFFFFFFFFFFFFFFF0;
            if ((v90 & 0xC) == 0)
            {
              v127 += v121;
              v128 += v121;
              v129 += v121;
              unint64_t v132 = v90 & 0xFFFFFFFFFFFFFFF0;
              goto LABEL_101;
            }
          }
          else
          {
            unint64_t v137 = 0;
          }
          v128 += v123;
          do
          {
            v93.i32[0] = *(__int32 *)((char *)v126->i32 + v137);
            v94.i32[0] = *(__int32 *)((char *)v125->i32 + v137);
            float32x4_t v94 = vmlaq_f32(vmulq_n_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v94.f32))), v120), v122, vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v93.i8))));
            int16x8_t v93 = (int16x8_t)vcvtq_s32_f32(v94);
            *(int16x4_t *)v93.i8 = vmovn_s32((int32x4_t)v93);
            *(int8x8_t *)v93.i8 = vmovn_s16(v93);
            *(__int32 *)((char *)v124->i32 + v137) = v93.i32[0];
            v137 += 4;
          }
          while (v123 != v137);
          if (v90 == v123) {
            goto LABEL_94;
          }
          v129 += v123;
          v127 += v123;
          unint64_t v132 = v90 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_101:
          unint64_t v133 = v90 - v132;
          do
          {
            unsigned int v134 = *v127++;
            float v135 = (float)v134;
            unsigned int v136 = *v128++;
            *v129++ = (int)(float)((float)(v120 * (float)v136) + (float)(v135 * *(float *)&a4));
            --v133;
          }
          while (v133);
LABEL_94:
          ++v119;
          uint64_t v126 = (int8x16_t *)((char *)v126 + v81);
          float v125 = (int8x16_t *)((char *)v125 + v82);
          uint64_t v124 = (int16x8_t *)((char *)v124 + v83);
          if (v119 == v80) {
            goto LABEL_164;
          }
        }
      }
      int v22 = 825437747;
      goto LABEL_117;
    }
    if ((int)PixelFormatType <= 1717855599)
    {
      if ((int)PixelFormatType > 1380411456)
      {
        if (PixelFormatType == 1380411457) {
          goto LABEL_137;
        }
        int v22 = 1647392359;
LABEL_117:
        if (PixelFormatType != v22) {
          goto LABEL_185;
        }
        size_t pixelBuffera = CVPixelBufferGetWidth(this);
        size_t v147 = CVPixelBufferGetHeight(this);
        CVPixelBufferLockBaseAddress(v15, 0);
        CVPixelBufferLockBaseAddress(this, 1uLL);
        CVPixelBufferLockBaseAddress(a2, 1uLL);
        size_t v148 = CVPixelBufferGetBytesPerRow(this);
        size_t v149 = CVPixelBufferGetBytesPerRow(a2);
        size_t v150 = CVPixelBufferGetBytesPerRow(v15);
        float32x4_t v151 = (int8x8_t *)CVPixelBufferGetBaseAddress(this);
        long double v152 = (int16x4_t *)CVPixelBufferGetBaseAddress(a2);
        float64x2_t v153 = v15;
        float64x2_t v154 = (int8x8_t *)CVPixelBufferGetBaseAddress(v15);
        float64x2_t v155 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(this);
        unint64_t v156 = PixelBufferUtils::componentsPerPixelForPixelFormat(v155, 0) * pixelBuffera;
        if (v261)
        {
          if (v147 && v156)
          {
            uint64_t v157 = 0;
            float v158 = 1.0 - *(float *)&a4;
            unint64_t v159 = 2 * (v156 & 0xFFFFFFFFFFFFFFFCLL);
            float32x4_t v160 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
            int32x4_t v161 = v154;
            int32x4_t v162 = v152;
            BOOL v163 = v151;
            while (1)
            {
              int v164 = (char *)v151 + v157 * v148;
              unsigned int v165 = (char *)v152 + v157 * v149;
              float v166 = (char *)v154 + v157 * v150;
              if (v156 < 8) {
                break;
              }
              float v167 = (char *)v154 + v157 * v150;
              if ((unint64_t)(v167 - &v152->i8[v157 * v149]) < 8
                || (unint64_t)(v167 - &v151->i8[v157 * v148]) < 8)
              {
                break;
              }
              v165 += v159;
              float32x4_t v172 = v161;
              unint64_t v173 = v162;
              float32x4_t v174 = v163;
              unint64_t v175 = v156 & 0xFFFFFFFFFFFFFFFCLL;
              do
              {
                int16x4_t v176 = *v173++;
                uint16x4_t v177 = (uint16x4_t)v176;
                int8x8_t v178 = (int8x8_t)vceqz_s16(v176);
                int8x8_t v179 = *v174++;
                *v172++ = vbsl_s8(v178, v179, (int8x8_t)vmovn_s32((int32x4_t)vcvtq_u32_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_u32(vmovl_u16(v177)), v158), v160, vcvtq_f32_u32(vmovl_u16((uint16x4_t)v179))))));
                v175 -= 4;
              }
              while (v175);
              if (v156 != (v156 & 0xFFFFFFFFFFFFFFFCLL))
              {
                v166 += v159;
                v164 += v159;
                unint64_t v169 = v156 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_129:
                unint64_t v170 = v156 - v169;
                do
                {
                  unsigned int v171 = *(unsigned __int16 *)v164;
                  if (*(_WORD *)v165) {
                    unsigned int v171 = (int)(float)((float)(v158 * (float)*(unsigned __int16 *)v165)
                  }
                                      + (float)((float)v171 * *(float *)&a4));
                  *(_WORD *)float v166 = v171;
                  v166 += 2;
                  v164 += 2;
                  v165 += 2;
                  --v170;
                }
                while (v170);
              }
              ++v157;
              BOOL v163 = (int8x8_t *)((char *)v163 + v148);
              int32x4_t v162 = (int16x4_t *)((char *)v162 + v149);
              int32x4_t v161 = (int8x8_t *)((char *)v161 + v150);
              if (v157 == v147) {
                goto LABEL_184;
              }
            }
            unint64_t v169 = 0;
            goto LABEL_129;
          }
LABEL_184:
          uint64_t v20 = 1;
          CVPixelBufferUnlockBaseAddress(this, 1uLL);
          CVPixelBufferUnlockBaseAddress(a2, 1uLL);
          long double v231 = v153;
          goto LABEL_165;
        }
        if (!v147 || !v156) {
          goto LABEL_184;
        }
        uint64_t v233 = 0;
        float v234 = 1.0 - *(float *)&a4;
        unint64_t v235 = 2 * (v156 & 0xFFFFFFFFFFFFFFF8);
        float32x4_t v236 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
        float64x2_t v237 = (int16x8_t *)v154;
        int32x4_t v238 = (uint16x8_t *)v152;
        char v239 = (uint16x8_t *)v151;
        while (1)
        {
          vImage_Buffer v240 = (char *)v151 + v233 * v148;
          vImage_Buffer v241 = (char *)v152 + v233 * v149;
          int8x16_t v242 = (char *)v154 + v233 * v150;
          if (v156 >= 8
            && ((int16x8_t v243 = (char *)v154 + v233 * v150, (unint64_t)(v243 - &v151->i8[v233 * v148]) >= 0x10)
              ? (BOOL v244 = (unint64_t)(v243 - &v152->i8[v233 * v149]) >= 0x10)
              : (BOOL v244 = 0),
                v244))
          {
            v241 += v235;
            float32x4_t v250 = v237;
            int16x8_t v251 = v238;
            float64x2_t v252 = v239;
            unint64_t v253 = v156 & 0xFFFFFFFFFFFFFFF8;
            do
            {
              uint16x8_t v254 = *v252++;
              float32x4_t v255 = vcvtq_f32_u32(vmovl_high_u16(v254));
              float32x4_t v256 = vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v254.i8));
              uint16x8_t v257 = *v251++;
              *v250++ = vuzp1q_s16((int16x8_t)vcvtq_u32_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v257.i8)), v234), v236, v256)), (int16x8_t)vcvtq_u32_f32(vmlaq_f32(vmulq_n_f32(vcvtq_f32_u32(vmovl_high_u16(v257)), v234), v236, v255)));
              v253 -= 8;
            }
            while (v253);
            if (v156 == (v156 & 0xFFFFFFFFFFFFFFF8)) {
              goto LABEL_170;
            }
            v242 += v235;
            v240 += v235;
            unint64_t v245 = v156 & 0xFFFFFFFFFFFFFFF8;
          }
          else
          {
            unint64_t v245 = 0;
          }
          unint64_t v246 = v156 - v245;
          do
          {
            unsigned int v247 = *(unsigned __int16 *)v240;
            v240 += 2;
            float v248 = (float)v247;
            unsigned int v249 = *(unsigned __int16 *)v241;
            v241 += 2;
            *(_WORD *)int8x16_t v242 = (int)(float)((float)(v234 * (float)v249) + (float)(v248 * *(float *)&a4));
            v242 += 2;
            --v246;
          }
          while (v246);
LABEL_170:
          ++v233;
          char v239 = (uint16x8_t *)((char *)v239 + v148);
          int32x4_t v238 = (uint16x8_t *)((char *)v238 + v149);
          float64x2_t v237 = (int16x8_t *)((char *)v237 + v150);
          if (v233 == v147) {
            goto LABEL_184;
          }
        }
      }
      if (PixelFormatType == 1380401729) {
        goto LABEL_72;
      }
      int v21 = 1380410945;
    }
    else if ((int)PixelFormatType <= 1751410031)
    {
      if (PixelFormatType == 1717855600) {
        goto LABEL_34;
      }
      int v21 = 1717856627;
    }
    else
    {
      if (PixelFormatType == 1751410032 || PixelFormatType == 1751411059) {
        goto LABEL_137;
      }
      int v21 = 1919365990;
    }
    if (PixelFormatType != v21) {
      goto LABEL_185;
    }
LABEL_34:
    size_t v24 = CVPixelBufferGetWidth(this);
    size_t v25 = CVPixelBufferGetHeight(this);
    CVPixelBufferLockBaseAddress(v15, 0);
    CVPixelBufferLockBaseAddress(this, 1uLL);
    CVPixelBufferLockBaseAddress(a2, 1uLL);
    size_t v26 = CVPixelBufferGetBytesPerRow(this);
    size_t v27 = CVPixelBufferGetBytesPerRow(a2);
    size_t v28 = CVPixelBufferGetBytesPerRow(v15);
    char v29 = (int8x16_t *)CVPixelBufferGetBaseAddress(this);
    uint64_t v30 = (float32x4_t *)CVPixelBufferGetBaseAddress(a2);
    pixelBuffer = v15;
    char v31 = (int8x16_t *)CVPixelBufferGetBaseAddress(v15);
    vImagePixelCount v32 = (PixelBufferUtils *)CVPixelBufferGetPixelFormatType(this);
    unint64_t v33 = PixelBufferUtils::componentsPerPixelForPixelFormat(v32, 0) * v24;
    if (v261)
    {
      if (!v25 || !v33)
      {
LABEL_68:
        uint64_t v20 = 1;
        CVPixelBufferUnlockBaseAddress(this, 1uLL);
        CVPixelBufferUnlockBaseAddress(a2, 1uLL);
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
        return v20;
      }
      uint64_t v34 = 0;
      float v35 = 1.0 - *(float *)&a4;
      unint64_t v36 = 4 * (v33 & 0xFFFFFFFFFFFFFFF8);
      float32x4_t v37 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
      float v38 = v31 + 1;
      size_t v39 = v29 + 1;
      size_t v40 = v30 + 1;
      while (1)
      {
        size_t v41 = (float *)((char *)v29->i32 + v34 * v26);
        uint64_t v42 = (float *)((char *)v30->f32 + v34 * v27);
        size_t v43 = v34 * v28;
        float32x4_t v44 = (float *)((char *)v31->i32 + v34 * v28);
        if (v33 < 8) {
          break;
        }
        unint64_t v45 = 0;
        if ((unint64_t)(&v31->i8[v43] - ((char *)v30 + v34 * v27)) < 0x20
          || (unint64_t)(&v31->i8[v43] - &v29->i8[v34 * v26]) < 0x20)
        {
          goto LABEL_41;
        }
        uint64_t v42 = (float *)((char *)v42 + v36);
        float v53 = v40;
        float v54 = v39;
        unsigned int v55 = v38;
        unint64_t v56 = v33 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          int8x16_t v57 = vbslq_s8((int8x16_t)vceqzq_f32(*v53), *v54, (int8x16_t)vmlaq_f32(vmulq_n_f32(*v53, v35), v37, *(float32x4_t *)v54));
          v55[-1] = vbslq_s8((int8x16_t)vceqzq_f32(v53[-1]), v54[-1], (int8x16_t)vmlaq_f32(vmulq_n_f32(v53[-1], v35), v37, (float32x4_t)v54[-1]));
          int8x16_t *v55 = v57;
          v55 += 2;
          v54 += 2;
          v53 += 2;
          v56 -= 8;
        }
        while (v56);
        if (v33 != (v33 & 0xFFFFFFFFFFFFFFF8))
        {
          float32x4_t v44 = (float *)((char *)v44 + v36);
          size_t v41 = (float *)((char *)v41 + v36);
          unint64_t v45 = v33 & 0xFFFFFFFFFFFFFFF8;
LABEL_41:
          unint64_t v46 = v33 - v45;
          do
          {
            float v47 = *v42++;
            float v48 = v47;
            float v49 = *v41++;
            float v50 = v49;
            float v51 = (float)(v35 * v48) + (float)(v49 * *(float *)&a4);
            if (v48 == 0.0) {
              float v52 = v50;
            }
            else {
              float v52 = v51;
            }
            *v44++ = v52;
            --v46;
          }
          while (v46);
        }
        ++v34;
        float v38 = (int8x16_t *)((char *)v38 + v28);
        size_t v39 = (int8x16_t *)((char *)v39 + v26);
        size_t v40 = (float32x4_t *)((char *)v40 + v27);
        if (v34 == v25) {
          goto LABEL_68;
        }
      }
      unint64_t v45 = 0;
      goto LABEL_41;
    }
    if (!v25 || !v33) {
      goto LABEL_164;
    }
    uint64_t v58 = 0;
    float v59 = 1.0 - *(float *)&a4;
    unint64_t v60 = 4 * (v33 & 0xFFFFFFFFFFFFFFF8);
    float32x4_t v61 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    float v62 = (float32x4_t *)&v31[1];
    float v63 = (float32x4_t *)&v29[1];
    CGRect v64 = v30 + 1;
    while (1)
    {
      vImagePixelCount v65 = (float *)((char *)v29->i32 + v58 * v26);
      vImagePixelCount v66 = (float *)((char *)v30->f32 + v58 * v27);
      size_t v67 = v58 * v28;
      CGRect v68 = (float *)((char *)v31->i32 + v58 * v28);
      if (v33 >= 8)
      {
        unint64_t v69 = 0;
        if ((unint64_t)(&v31->i8[v67] - &v29->i8[v58 * v26]) >= 0x20
          && (unint64_t)(&v31->i8[v67] - ((char *)v30 + v58 * v27)) >= 0x20)
        {
          vImagePixelCount v66 = (float *)((char *)v66 + v60);
          float64x2_t v74 = v64;
          size_t v75 = v63;
          uint64_t v76 = v62;
          unint64_t v77 = v33 & 0xFFFFFFFFFFFFFFF8;
          do
          {
            float32x4_t v78 = vmlaq_f32(vmulq_n_f32(*v74, v59), v61, *v75);
            v76[-1] = vmlaq_f32(vmulq_n_f32(v74[-1], v59), v61, v75[-1]);
            *uint64_t v76 = v78;
            v76 += 2;
            v75 += 2;
            v74 += 2;
            v77 -= 8;
          }
          while (v77);
          if (v33 == (v33 & 0xFFFFFFFFFFFFFFF8)) {
            goto LABEL_56;
          }
          CGRect v68 = (float *)((char *)v68 + v60);
          vImagePixelCount v65 = (float *)((char *)v65 + v60);
          unint64_t v69 = v33 & 0xFFFFFFFFFFFFFFF8;
        }
      }
      else
      {
        unint64_t v69 = 0;
      }
      unint64_t v70 = v33 - v69;
      do
      {
        float v71 = *v65++;
        float v72 = v71;
        float v73 = *v66++;
        *v68++ = (float)(v59 * v73) + (float)(v72 * *(float *)&a4);
        --v70;
      }
      while (v70);
LABEL_56:
      ++v58;
      float v62 = (float32x4_t *)((char *)v62 + v28);
      float v63 = (float32x4_t *)((char *)v63 + v26);
      CGRect v64 = (float32x4_t *)((char *)v64 + v27);
      if (v58 == v25) {
        goto LABEL_164;
      }
    }
  }
  NSLog(&cfstr_SDErrorCannotA.isa, "alphaBlend", 3934);
  return 0;
}

void sub_215FB682C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void PixelBufferUtils::colorizePointCloudOnPixelBuffer(CVPixelBufferRef pixelBuffer, __CVBuffer *a2, unint64_t a3, const CGPoint *a4, const float *a5, float a6, float a7, float a8)
{
  if (a8 <= 0.0)
  {
    CVPixelBufferGetWidth(pixelBuffer);
    CVPixelBufferGetHeight(pixelBuffer);
  }
  operator new[]();
}

void sub_215FB6B28(_Unwind_Exception *a1)
{
  MEMORY[0x2166C5D70](v4, 0x1000C8052888210);
  MEMORY[0x2166C5D70](v3, 0x1000C8052888210);
  MEMORY[0x2166C5D70](v2, 0x1000C8052888210);
  MEMORY[0x2166C5D70](v1, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

uint64_t PixelBufferUtils::addCirclesToPixelBuffer(PixelBufferUtils *this, __CVBuffer *a2, float a3, uint64_t a4, const CGPoint *a5, const float *a6, const float *a7, const float *a8, const float *a9)
{
  if (!this || !a4 || (id v10 = a5) == 0 || (v11 = a6) == 0 || (v12 = a7) == 0 || (v13 = a8) == 0)
  {
    NSLog(&cfstr_SDErrorCannotA_2.isa, a2, a4, a5, a6, a7, a8, a9, "addCirclesToPixelBuffer", 4067);
    return 0;
  }
  size_t v14 = a2;
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  size_t v18 = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  if (PixelFormatType != 1111970369)
  {
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)__p);
    if (v39 >= 0) {
      float v35 = __p;
    }
    else {
      float v35 = (void **)__p[0];
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "addCirclesToPixelBuffer", 4077, PixelFormatType, v35);
    if (v39 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  size_t v20 = Height;
  size_t widtha = v18;
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  CVPixelBufferLockBaseAddress(this, 0);
  BaseAddress = CVPixelBufferGetBaseAddress(this);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(this);
  size_t v24 = widtha;
  vImagePixelCount width = DeviceRGB;
  size_t v25 = CGBitmapContextCreate(BaseAddress, v24, v20, 8uLL, BytesPerRow, DeviceRGB, 0x2002u);
  if (v14)
  {
    size_t v26 = (double *)(a4 + 8);
    do
    {
      float v27 = *(v26 - 1);
      double v28 = *v26;
      v26 += 2;
      float v29 = (double)v20 - v28;
      LODWORD(v28) = LODWORD(v10->x);
      id v10 = (const CGPoint *)((char *)v10 + 4);
      CGFloat v30 = *(float *)&v28;
      *(float *)&double v28 = *v11++;
      CGFloat v31 = *(float *)&v28;
      *(float *)&double v28 = *v12++;
      CGFloat v32 = *(float *)&v28;
      *(float *)&double v28 = *v13++;
      GenericRGB = CGColorCreateGenericRGB(v30, v31, v32, *(float *)&v28);
      CGContextSetFillColorWithColor(v25, GenericRGB);
      v40.origin.double x = (float)(v27 - a3);
      v40.origin.double y = (float)(v29 - a3);
      v40.size.vImagePixelCount width = (float)(a3 + a3);
      v40.size.vImagePixelCount height = v40.size.width;
      CGContextFillEllipseInRect(v25, v40);
      CFRelease(GenericRGB);
      size_t v14 = (__CVBuffer *)((char *)v14 - 1);
    }
    while (v14);
  }
  CVPixelBufferUnlockBaseAddress(this, 0);
  CFRelease(width);
  CGContextRelease(v25);
  return 1;
}

void sub_215FB6DE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PixelBufferUtils::createColorizedPointCloud(PixelBufferUtils *this, unint64_t a2, const CGPoint *a3, const float *a4, size_t a5, const float *a6, float a7, float a8, float a9)
{
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  CVReturn v21 = CVPixelBufferCreate(v18, (size_t)a4, a5, 0x42475241u, BufferAttributes, &pixelBufferOut);
  uint64_t result = 0;
  int v23 = pixelBufferOut;
  if (v21) {
    BOOL v24 = 1;
  }
  else {
    BOOL v24 = pixelBufferOut == 0;
  }
  if (!v24)
  {
    PixelBufferUtils::blacken(pixelBufferOut, v20);
    PixelBufferUtils::colorizePointCloudOnPixelBuffer(v23, this, a2, a3, a6, a7, a8, a9);
  }
  return result;
}

__CVBuffer *PixelBufferUtils::createPixelBufferCopy(PixelBufferUtils *this, __CVBuffer *a2)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  size_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v6, Width, Height, PixelFormatType, BufferAttributes, &pixelBufferOut)) {
    float v8 = 0;
  }
  else {
    float v8 = pixelBufferOut;
  }
  OSType v9 = CVPixelBufferGetPixelFormatType(this);
  if (v9 != CVPixelBufferGetPixelFormatType(v8)
    || copyPixelBufferVImage(v8, *MEMORY[0x263F00148], this, *MEMORY[0x263F001A8]))
  {
    CVPixelBufferRelease(v8);
    return 0;
  }
  return v8;
}

CVPixelBufferRef PixelBufferUtils::asPixelBuffer(unint64_t this, size_t a2, PixelBufferUtils *a3, char *a4, void *a5)
{
  planeWidth[3] = *MEMORY[0x263EF8340];
  if (PixelBufferUtils::planeCountForPixelFormat(a3))
  {
    CVPixelBufferRef v27 = 0;
    uint64_t v9 = PixelBufferUtils::planeCountForPixelFormat(a3);
    if ((unint64_t)(v9 - 4) > 0xFFFFFFFFFFFFFFFCLL)
    {
      size_t v12 = v9;
      planeWidth[1] = this;
      planeWidth[2] = this;
      planeHeight[1] = a2;
      planeHeight[2] = a2;
      v29[1] = this;
      double v29[2] = this;
      planeBaseAddress[1] = 0;
      planeBaseAddress[2] = 0;
      planeBaseAddress[0] = a4;
      unint64_t v13 = PixelBufferUtils::horizontalSubsamplingForPixelFormat(a3, 0);
      unint64_t v14 = PixelBufferUtils::verticalSubsamplingForPixelFormat(a3, 0);
      unint64_t v15 = PixelBufferUtils::pixelSizeForPixelFormat(a3, 0) / v13 * this;
      v29[0] = v15;
      size_t v26 = a2;
      planeWidth[0] = this / v13;
      size_t v16 = a2 / v14;
      planeHeight[0] = a2 / v14;
      if (v12 != 1)
      {
        uint64_t v17 = 1;
        do
        {
          unint64_t v18 = PixelBufferUtils::horizontalSubsamplingForPixelFormat(a3, v17);
          size_t v19 = v12;
          unint64_t v20 = PixelBufferUtils::verticalSubsamplingForPixelFormat(a3, v17);
          unint64_t v21 = PixelBufferUtils::pixelSizeForPixelFormat(a3, v17);
          uint64_t v22 = v17;
          size_t v23 = v29[v17] * (v21 / v18);
          v29[v22] = v23;
          planeWidth[v22] = planeWidth[v17] / v18;
          a4 += v16 * v15;
          size_t v16 = planeHeight[v17] / v20;
          size_t v12 = v19;
          planeHeight[v22] = v16;
          planeBaseAddress[v22] = a4;
          ++v17;
          unint64_t v15 = v23;
        }
        while (v19 != v17);
      }
      CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
      CVPixelBufferCreateWithPlanarBytes(v24, this, v26, (OSType)a3, 0, 0, v12, planeBaseAddress, planeWidth, planeHeight, v29, 0, 0, BufferAttributes, &v27);
      return v27;
    }
    else
    {
      NSLog(&cfstr_SDErrorOnlyUpT.isa, "asPixelBufferMultiPlane", 3452);
      return 0;
    }
  }
  else
  {
    planeWidth[0] = 0;
    unint64_t v11 = PixelBufferUtils::pixelSizeForPixelFormat(a3, 0);
    CVPixelBufferCreateWithBytes((CFAllocatorRef)*MEMORY[0x263EFFB08], this, a2, (OSType)a3, a4, v11 * this, 0, 0, 0, (CVPixelBufferRef *)planeWidth);
    return (CVPixelBufferRef)planeWidth[0];
  }
}

void PixelBufferUtils::inPlaceColorScaling(PixelBufferUtils *this, __CVBuffer *a2, float a3, float a4, int a5)
{
  char v45 = (char)a2;
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  unint64_t v9 = PixelFormatType;
  if ((int)PixelFormatType <= 1380401728)
  {
    if ((int)PixelFormatType <= 875704437)
    {
      if ((int)PixelFormatType > 825437746)
      {
        if (PixelFormatType != 825437747)
        {
          if (PixelFormatType != 843264104)
          {
            if (PixelFormatType != 875704422) {
              goto LABEL_85;
            }
            goto LABEL_77;
          }
          goto LABEL_65;
        }
        goto LABEL_25;
      }
      if (PixelFormatType != 32)
      {
        int v11 = 825306677;
LABEL_24:
        if (PixelFormatType == v11)
        {
LABEL_25:
          CVPixelBufferLockBaseAddress(this, 0);
          OSType v46 = CVPixelBufferGetPixelFormatType(this);
          size_t PlaneCount = CVPixelBufferGetPlaneCount(this);
          size_t v13 = PlaneCount;
          uint64_t v14 = 0;
          unsigned int v15 = 0;
          if (PlaneCount <= 1) {
            unint64_t v16 = 1;
          }
          else {
            unint64_t v16 = PlaneCount;
          }
          uint64_t v17 = (CGRect *)MEMORY[0x263F001A8];
          do
          {
            if (v13)
            {
              PixelBufferUtils::asVImageBuffer(this, (__CVBuffer *)v14, *v17, &__p);
            }
            else
            {
              PixelBufferUtils::asVImageBuffer(this, *v17, &__p);
              uint64_t v14 = 0;
            }
            data = (char *)__p.data;
            vImagePixelCount height = __p.height;
            vImagePixelCount width = __p.width;
            size_t rowBytes = __p.rowBytes;
            unint64_t v22 = PixelBufferUtils::componentsPerPixelForPixelFormat((PixelBufferUtils *)v46, v14);
            if (height)
            {
              vImagePixelCount v24 = width * v22;
              if (width * v22)
              {
                if (v45)
                {
                  for (uint64_t i = 0; i != height; ++i)
                  {
                    unint64_t v26 = 0;
                    do
                    {
                      if (v26 % v22 != 0x7FFFFFFF)
                      {
                        LOWORD(v23) = *(_WORD *)&data[2 * v26];
                        float v23 = a4 + (float)((float)LODWORD(v23) * a3);
                        *(_WORD *)&data[2 * v26] = (int)v23;
                      }
                      ++v26;
                    }
                    while (v24 != v26);
                    data += rowBytes;
                  }
                }
                else
                {
                  for (uint64_t j = 0; j != height; ++j)
                  {
                    unint64_t v28 = 0;
                    do
                    {
                      if (v28 % v22 != 0x7FFFFFFF)
                      {
                        LOWORD(v23) = *(_WORD *)&data[2 * v28];
                        float v23 = (float)((float)LODWORD(v23) + a4) * a3;
                        *(_WORD *)&data[2 * v28] = (int)v23;
                      }
                      ++v28;
                    }
                    while (v24 != v28);
                    data += rowBytes;
                  }
                }
              }
            }
            uint64_t v14 = ++v15;
          }
          while (v16 > v15);
          CVPixelBufferUnlockBaseAddress(this, 0);
          return;
        }
LABEL_85:
        PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)&__p);
        if ((__p.width & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (vImage_Buffer *)__p.data;
        }
        NSLog(&cfstr_SDErrorPixelFo.isa, "inPlaceColorScaling", 3700, v9, p_p);
        if (SHIBYTE(__p.width) < 0) {
          operator delete(__p.data);
        }
        return;
      }
      goto LABEL_59;
    }
    if ((int)PixelFormatType <= 1111970368)
    {
      if (PixelFormatType == 875704438)
      {
LABEL_77:
        CGRect v40 = this;
        float v41 = a3;
        float v42 = a4;
        char v43 = v45;
        int v34 = 0x7FFFFFFF;
        goto LABEL_78;
      }
      if (PixelFormatType != 1094862674) {
        goto LABEL_85;
      }
LABEL_59:
      if (a5) {
        int v34 = 0x7FFFFFFF;
      }
      else {
        int v34 = 0;
      }
LABEL_76:
      CGRect v40 = this;
      float v41 = a3;
      float v42 = a4;
      char v43 = v45;
LABEL_78:
      scaleColorsRawInPlace<unsigned char>(v40, v43, v34, v41, v42);
      return;
    }
    if (PixelFormatType != 1111970369)
    {
      if (PixelFormatType != 1278226534)
      {
        int v10 = 1278226536;
        goto LABEL_64;
      }
      goto LABEL_69;
    }
    goto LABEL_73;
  }
  if ((int)PixelFormatType > 1717856626)
  {
    if ((int)PixelFormatType <= 1751411058)
    {
      if (PixelFormatType != 1717856627)
      {
        int v10 = 1751410032;
LABEL_64:
        if (PixelFormatType != v10) {
          goto LABEL_85;
        }
LABEL_65:
        float v35 = this;
        float v36 = a3;
        float v37 = a4;
        char v38 = v45;
        int v39 = 0x7FFFFFFF;
LABEL_66:
        scaleColorsRawInPlace<half>(v35, v38, v39, v36, v37);
        return;
      }
    }
    else
    {
      if (PixelFormatType == 1751411059) {
        goto LABEL_65;
      }
      if (PixelFormatType != 1919365990)
      {
        int v11 = 1932996149;
        goto LABEL_24;
      }
    }
    goto LABEL_69;
  }
  if ((int)PixelFormatType > 1380411456)
  {
    if (PixelFormatType == 1380411457)
    {
      if (a5) {
        int v39 = 0x7FFFFFFF;
      }
      else {
        int v39 = 3;
      }
      float v35 = this;
      float v36 = a3;
      float v37 = a4;
      char v38 = v45;
      goto LABEL_66;
    }
    if (PixelFormatType == 1647392359) {
      goto LABEL_25;
    }
    if (PixelFormatType != 1717855600) {
      goto LABEL_85;
    }
LABEL_69:
    CGFloat v30 = this;
    float v31 = a3;
    float v32 = a4;
    char v33 = v45;
    int v29 = 0x7FFFFFFF;
    goto LABEL_70;
  }
  if (PixelFormatType == 1380401729)
  {
LABEL_73:
    if (a5) {
      int v34 = 0x7FFFFFFF;
    }
    else {
      int v34 = 3;
    }
    goto LABEL_76;
  }
  if (PixelFormatType != 1380410945) {
    goto LABEL_85;
  }
  if (a5) {
    int v29 = 0x7FFFFFFF;
  }
  else {
    int v29 = 3;
  }
  CGFloat v30 = this;
  float v31 = a3;
  float v32 = a4;
  char v33 = v45;
LABEL_70:
  scaleColorsRawInPlace<float>(v30, v33, v29, v31, v32);
}

void sub_215FB77A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t scaleColorsRawInPlace<float>(__CVBuffer *a1, char a2, int a3, float a4, float a5)
{
  CVPixelBufferLockBaseAddress(a1, 0);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  size_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  size_t v10 = PlaneCount;
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  if (PlaneCount <= 1) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = PlaneCount;
  }
  unint64_t v27 = v13;
  uint64_t v14 = (CGRect *)MEMORY[0x263F001A8];
  do
  {
    if (v10)
    {
      PixelBufferUtils::asVImageBuffer(a1, (__CVBuffer *)v11, *v14, &v29);
    }
    else
    {
      PixelBufferUtils::asVImageBuffer(a1, *v14, &v29);
      uint64_t v11 = 0;
    }
    data = (float *)v29.data;
    vImagePixelCount height = v29.height;
    vImagePixelCount width = v29.width;
    size_t rowBytes = v29.rowBytes;
    unint64_t v19 = PixelBufferUtils::componentsPerPixelForPixelFormat((PixelBufferUtils *)PixelFormatType, v11);
    if (height)
    {
      vImagePixelCount v20 = width * v19;
      if (width * v19)
      {
        if (a2)
        {
          for (uint64_t i = 0; i != height; ++i)
          {
            unint64_t v22 = 0;
            do
            {
              if (v22 % v19 != a3) {
                data[v22] = a5 + (float)(data[v22] * a4);
              }
              ++v22;
            }
            while (v20 != v22);
            data = (float *)((char *)data + rowBytes);
          }
        }
        else
        {
          for (uint64_t j = 0; j != height; ++j)
          {
            unint64_t v24 = 0;
            do
            {
              if (v24 % v19 != a3) {
                data[v24] = (float)(data[v24] + a5) * a4;
              }
              ++v24;
            }
            while (v20 != v24);
            data = (float *)((char *)data + rowBytes);
          }
        }
      }
    }
    uint64_t v11 = ++v12;
  }
  while (v27 > v12);
  return CVPixelBufferUnlockBaseAddress(a1, 0);
}

uint64_t scaleColorsRawInPlace<half>(__CVBuffer *a1, char a2, int a3, float a4, float a5)
{
  CVPixelBufferLockBaseAddress(a1, 0);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  size_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  size_t v10 = PlaneCount;
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  if (PlaneCount <= 1) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = PlaneCount;
  }
  unint64_t v37 = v13;
  uint64_t v14 = (CGRect *)MEMORY[0x263F001A8];
  do
  {
    if (v10)
    {
      PixelBufferUtils::asVImageBuffer(a1, (__CVBuffer *)v11, *v14, &v39);
    }
    else
    {
      PixelBufferUtils::asVImageBuffer(a1, *v14, &v39);
      uint64_t v11 = 0;
    }
    data = (char *)v39.data;
    vImagePixelCount height = v39.height;
    vImagePixelCount width = v39.width;
    size_t rowBytes = v39.rowBytes;
    unint64_t v19 = PixelBufferUtils::componentsPerPixelForPixelFormat((PixelBufferUtils *)PixelFormatType, v11);
    if (height)
    {
      vImagePixelCount v20 = width * v19;
      if (width * v19)
      {
        if (a2)
        {
          for (uint64_t i = 0; i != height; ++i)
          {
            unint64_t v22 = 0;
            do
            {
              if (v22 % v19 != a3)
              {
                _H0 = *(_WORD *)&data[2 * v22];
                __asm { FCVT            S0, H0 }
                _S0 = a5 + (float)(_S0 * a4);
                __asm { FCVT            H0, S0 }
                *(_WORD *)&data[2 * v22] = LOWORD(_S0);
              }
              ++v22;
            }
            while (v20 != v22);
            data += rowBytes;
          }
        }
        else
        {
          for (uint64_t j = 0; j != height; ++j)
          {
            unint64_t v31 = 0;
            do
            {
              if (v31 % v19 != a3)
              {
                _H0 = *(_WORD *)&data[2 * v31];
                __asm { FCVT            S0, H0 }
                _S0 = (float)(_S0 + a5) * a4;
                __asm { FCVT            H0, S0 }
                *(_WORD *)&data[2 * v31] = LOWORD(_S0);
              }
              ++v31;
            }
            while (v20 != v31);
            data += rowBytes;
          }
        }
      }
    }
    uint64_t v11 = ++v12;
  }
  while (v37 > v12);
  return CVPixelBufferUnlockBaseAddress(a1, 0);
}

uint64_t scaleColorsRawInPlace<unsigned char>(__CVBuffer *a1, char a2, int a3, float a4, float a5)
{
  CVPixelBufferLockBaseAddress(a1, 0);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  size_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  size_t v10 = PlaneCount;
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  if (PlaneCount <= 1) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = PlaneCount;
  }
  unint64_t v28 = v13;
  uint64_t v14 = (CGRect *)MEMORY[0x263F001A8];
  do
  {
    if (v10)
    {
      PixelBufferUtils::asVImageBuffer(a1, (__CVBuffer *)v11, *v14, &v30);
    }
    else
    {
      PixelBufferUtils::asVImageBuffer(a1, *v14, &v30);
      uint64_t v11 = 0;
    }
    data = v30.data;
    vImagePixelCount height = v30.height;
    vImagePixelCount width = v30.width;
    size_t rowBytes = v30.rowBytes;
    unint64_t v19 = PixelBufferUtils::componentsPerPixelForPixelFormat((PixelBufferUtils *)PixelFormatType, v11);
    if (height)
    {
      vImagePixelCount v21 = width * v19;
      if (width * v19)
      {
        if (a2)
        {
          for (uint64_t i = 0; i != height; ++i)
          {
            unint64_t v23 = 0;
            do
            {
              if (v23 % v19 != a3)
              {
                LOBYTE(v20) = data[v23];
                float v20 = a5 + (float)((float)LODWORD(v20) * a4);
                data[v23] = (int)v20;
              }
              ++v23;
            }
            while (v21 != v23);
            data += rowBytes;
          }
        }
        else
        {
          for (uint64_t j = 0; j != height; ++j)
          {
            unint64_t v25 = 0;
            do
            {
              if (v25 % v19 != a3)
              {
                LOBYTE(v20) = data[v25];
                float v20 = (float)((float)LODWORD(v20) + a5) * a4;
                data[v25] = (int)v20;
              }
              ++v25;
            }
            while (v21 != v25);
            data += rowBytes;
          }
        }
      }
    }
    uint64_t v11 = ++v12;
  }
  while (v28 > v12);
  return CVPixelBufferUnlockBaseAddress(a1, 0);
}

uint64_t PixelBufferUtils::rotationAngleAndMirroringFromExifOrientation(PixelBufferUtils *this, char *a2, BOOL *a3)
{
  switch((int)this)
  {
    case 2:
      uint64_t result = 0;
      char v4 = 1;
      break;
    case 3:
      char v4 = 0;
      uint64_t result = 180;
      break;
    case 4:
      char v4 = 1;
      uint64_t result = 180;
      break;
    case 5:
      char v4 = 1;
      goto LABEL_10;
    case 6:
      char v4 = 0;
      uint64_t result = 90;
      break;
    case 7:
      char v4 = 1;
      uint64_t result = 90;
      break;
    case 8:
      char v4 = 0;
LABEL_10:
      uint64_t result = 270;
      break;
    default:
      uint64_t result = 0;
      char v4 = 0;
      break;
  }
  if (a2) {
    *a2 = v4;
  }
  return result;
}

uint64_t PixelBufferUtils::rotationBetweenOrientations(PixelBufferUtils *this, CGImagePropertyOrientation a2, CGImagePropertyOrientation a3)
{
  switch((int)this)
  {
    case 2:
      int v3 = 0;
      int v4 = 1;
      break;
    case 3:
      int v4 = 0;
      int v3 = -180;
      break;
    case 4:
      int v4 = 1;
      int v3 = -180;
      break;
    case 5:
      int v4 = 1;
      goto LABEL_10;
    case 6:
      int v4 = 0;
      int v3 = -90;
      break;
    case 7:
      int v4 = 1;
      int v3 = -90;
      break;
    case 8:
      int v4 = 0;
LABEL_10:
      int v3 = -270;
      break;
    default:
      int v3 = 0;
      int v4 = 0;
      break;
  }
  int v5 = 0;
  switch(a2)
  {
    case kCGImagePropertyOrientationUpMirrored:
      goto LABEL_17;
    case kCGImagePropertyOrientationDown:
      int v5 = 180;
      if ((v4 & 1) == 0) {
        goto LABEL_25;
      }
      return 0xFFFFFFFFLL;
    case kCGImagePropertyOrientationDownMirrored:
      int v5 = 180;
      if (v4) {
        goto LABEL_25;
      }
      return 0xFFFFFFFFLL;
    case kCGImagePropertyOrientationLeftMirrored:
      int v5 = 270;
LABEL_17:
      if (v4) {
        goto LABEL_25;
      }
      return 0xFFFFFFFFLL;
    case kCGImagePropertyOrientationRight:
      int v5 = 90;
      goto LABEL_20;
    case kCGImagePropertyOrientationRightMirrored:
      int v5 = 90;
      if (v4) {
        goto LABEL_25;
      }
      return 0xFFFFFFFFLL;
    case kCGImagePropertyOrientationLeft:
      int v5 = 270;
      if ((v4 & 1) == 0) {
        goto LABEL_25;
      }
      return 0xFFFFFFFFLL;
    default:
LABEL_20:
      if (v4) {
        return 0xFFFFFFFFLL;
      }
LABEL_25:
      unsigned int v7 = v5 + v3;
      unsigned int v8 = v5 + v3 + 360;
      if (v7 <= 0xFFFFFE97) {
        uint64_t result = v7;
      }
      else {
        uint64_t result = v8;
      }
      if ((int)result > 179)
      {
        if (result == 180)
        {
          return 2;
        }
        else
        {
          if (result != 270) {
            return 0xFFFFFFFFLL;
          }
          return 1;
        }
      }
      else if (result)
      {
        if (result == 90) {
          return 3;
        }
        return 0xFFFFFFFFLL;
      }
      return result;
  }
}

__CVBuffer *PixelBufferUtils::savePlyFromDepthBuffer(__CVBuffer *this, __CVBuffer *a2, const char *a3, float a4, CGPoint a5, float a6, float a7, float a8)
{
  if (this)
  {
    unsigned int v8 = this;
    CVPixelBufferGetWidth(this);
    CVPixelBufferGetHeight(v8);
    CVPixelBufferLockBaseAddress(v8, 1uLL);
    CVPixelBufferGetBytesPerRow(v8);
    CVPixelBufferGetBaseAddress(v8);
    operator new[]();
  }
  return this;
}

uint64_t PixelBufferUtils::addTextToPixelBuffer(PixelBufferUtils *this, __CVBuffer *a2, const char *a3, CGPoint a4)
{
  v36[3] = *MEMORY[0x263EF8340];
  if (!this || !a2)
  {
    NSLog(&cfstr_SDErrorCannotA_0.isa, a2, a3, a4.x, a4.y, "addTextToPixelBuffer", 3998);
    return 0;
  }
  double y = a4.y;
  double x = a4.x;
  unint64_t PixelFormatType = CVPixelBufferGetPixelFormatType(this);
  unint64_t Width = CVPixelBufferGetWidth(this);
  size_t Height = CVPixelBufferGetHeight(this);
  size_t v12 = Height;
  if (PixelFormatType != 32 && PixelFormatType != 1111970369)
  {
    PixelBufferUtils::pixelFormatAsString(PixelFormatType, (char *)__p);
    if (v34 >= 0) {
      unint64_t v16 = __p;
    }
    else {
      unint64_t v16 = (void **)__p[0];
    }
    NSLog(&cfstr_SDErrorPixelFo.isa, "addTextToPixelBuffer", 4008, PixelFormatType, v16);
    if (v34 < 0) {
      operator delete(__p[0]);
    }
    return 0;
  }
  double v13 = (double)Height;
  if (x > (double)Width || y > v13)
  {
    NSLog(&cfstr_SDErrorCannotA_1.isa, "addTextToPixelBuffer", 4014);
    return 0;
  }
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  CVPixelBufferLockBaseAddress(this, 0);
  BaseAddress = CVPixelBufferGetBaseAddress(this);
  size_t BytesPerRow = CVPixelBufferGetBytesPerRow(this);
  float v20 = CGBitmapContextCreate(BaseAddress, Width, v12, 8uLL, BytesPerRow, DeviceRGB, 6u);
  long long v21 = *(_OWORD *)(MEMORY[0x263F000D0] + 16);
  *(_OWORD *)&v32.a = *MEMORY[0x263F000D0];
  *(_OWORD *)&v32.c = v21;
  *(_OWORD *)&v32.tdouble x = *(_OWORD *)(MEMORY[0x263F000D0] + 32);
  CGContextSetTextMatrix(v20, &v32);
  CGContextSetTextDrawingMode(v20, kCGTextFill);
  CGColorRef GenericRGB = CGColorCreateGenericRGB(1.0, 1.0, 1.0, 1.0);
  CGColorRef v23 = CGColorCreateGenericRGB(0.0, 0.0, 0.0, 0.0);
  CTFontRef v24 = CTFontCreateWithName(@"Courier", (double)(unint64_t)a3, 0);
  {
    {
      uint64_t v31 = *MEMORY[0x263F03C60];
      v35[0] = *MEMORY[0x263F039A0];
      v35[1] = v31;
      v36[0] = v24;
      v36[1] = GenericRGB;
      v35[2] = *MEMORY[0x263F03988];
      v36[2] = v23;
      PixelBufferUtils::addTextToPixelBuffer(__CVBuffer *,char const*,unsigned long,CGPoint)::stringAttributes = [NSDictionary dictionaryWithObjects:v36 forKeys:v35 count:3];
    }
  }
  id v25 = objc_alloc(MEMORY[0x263F086A0]);
  unint64_t v26 = [NSString stringWithUTF8String:a2];
  CFAttributedStringRef v27 = (const __CFAttributedString *)[v25 initWithString:v26 attributes:PixelBufferUtils::addTextToPixelBuffer(__CVBuffer *,char const*,unsigned long,CGPoint)::stringAttributes];

  unint64_t v28 = CTLineCreateWithAttributedString(v27);
  float v29 = x;
  float v30 = v13 - y;
  CGContextSetTextPosition(v20, v29, v30);
  CTLineDraw(v28, v20);
  CVPixelBufferUnlockBaseAddress(this, 0);
  CFRelease(DeviceRGB);
  CGContextRelease(v20);
  CFRelease(GenericRGB);
  CFRelease(v23);
  CFRelease(v24);

  return 1;
}

void sub_215FB88D8(_Unwind_Exception *a1)
{
}

void sub_215FB88F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  _Unwind_Resume(a1);
}

uint64_t PixelBufferUtilsSession::PixelBufferUtilsSession(uint64_t a1, int a2, signed int a3, int a4, int a5, double a6, double a7, double a8, double a9, CGFloat a10, CGFloat a11, CGFloat a12, CGFloat a13)
{
  double v16 = a13;
  double v17 = a12;
  double v18 = a11;
  double v19 = a10;
  double v20 = a9;
  double v21 = a8;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(double *)(a1 + 24) = a6;
  *(double *)(a1 + 32) = a7;
  *(_DWORD *)(a1 + 40) = a2;
  *(double *)(a1 + 48) = a8;
  *(double *)(a1 + 56) = a9;
  *(_DWORD *)(a1 + 64) = a3;
  *(CGFloat *)(a1 + 72) = a10;
  *(CGFloat *)(a1 + 80) = a11;
  *(CGFloat *)(a1 + 88) = a12;
  *(CGFloat *)(a1 + 96) = a13;
  *(_DWORD *)(a1 + 104) = a4;
  *(_DWORD *)(a1 + 108) = a5;
  v41.origin.double x = a10;
  v41.origin.double y = a11;
  v41.size.vImagePixelCount width = a12;
  v41.size.vImagePixelCount height = a13;
  if (CGRectIsEmpty(v41))
  {
    double v19 = 0.0;
    double v18 = 0.0;
    double v17 = a6;
    double v16 = a7;
  }
  if (a2 == a3 && a6 == v21 && a7 == v20)
  {
    BOOL v26 = (a5 | a4) == 0;
    if (v17 == a6 && v16 == a7)
    {
      if (!(a5 | a4))
      {
        LOBYTE(v27) = 1;
        goto LABEL_37;
      }
      int v27 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    BOOL v26 = (a5 | a4) == 0;
  }
  if (a2 <= 1751410031)
  {
    if (a2 > 1717855599)
    {
      if (a2 == 1717855600 || a2 == 1717856627) {
        goto LABEL_53;
      }
    }
    else if (a2 == 825306677 || a2 == 825437747)
    {
      goto LABEL_53;
    }
  }
  else if (a2 <= 1919365989)
  {
    if (a2 == 1751410032 || a2 == 1751411059) {
      goto LABEL_53;
    }
  }
  else if (a2 == 1919365990 || a2 == 1919365992 || a2 == 1932996149)
  {
    goto LABEL_53;
  }
  if (a3 <= 1751410031)
  {
    if (a3 > 1717855599)
    {
      if (a3 != 1717855600)
      {
        int v29 = 1717856627;
        goto LABEL_52;
      }
    }
    else if (a3 != 825306677)
    {
      int v29 = 825437747;
      goto LABEL_52;
    }
LABEL_53:
    NSLog(&cfstr_SDErrorTransfe.isa, "PixelBufferUtilsSession", 4145);
    return a1;
  }
  if (a3 <= 1919365989)
  {
    if (a3 != 1751410032)
    {
      int v29 = 1751411059;
      goto LABEL_52;
    }
    goto LABEL_53;
  }
  if (a3 == 1919365990 || a3 == 1919365992) {
    goto LABEL_53;
  }
  int v29 = 1932996149;
LABEL_52:
  if (a3 == v29) {
    goto LABEL_53;
  }
  int v27 = 1;
  if (v26) {
    goto LABEL_37;
  }
LABEL_10:
  if (a3 > 1717856626)
  {
    if (a3 > 1919365989)
    {
      if (a3 == 1919365990 || a3 == 1932996149) {
        goto LABEL_60;
      }
      int v28 = 1919365992;
      goto LABEL_59;
    }
    if (a3 != 1717856627)
    {
      int v28 = 1751411059;
      goto LABEL_59;
    }
LABEL_60:
    NSLog(&cfstr_SDErrorRotatio.isa, "PixelBufferUtilsSession", 4151);
    return a1;
  }
  if (a3 > 1380410944)
  {
    if (a3 != 1380410945)
    {
      int v28 = 1380411457;
      goto LABEL_59;
    }
    goto LABEL_60;
  }
  if (a3 == 825306677) {
    goto LABEL_60;
  }
  int v28 = 825437747;
LABEL_59:
  if (a3 == v28) {
    goto LABEL_60;
  }
  if (!v27) {
    goto LABEL_39;
  }
  double v32 = (double)(unint64_t)v21;
  if ((a4 & 0xFFFFFFFD) == 1)
  {
    double v21 = v20;
    double v20 = v32;
  }
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  CVReturn v35 = CVPixelBufferCreate(v33, (unint64_t)v21, (unint64_t)v20, a3, BufferAttributes, &pixelBufferOut);
  CVPixelBufferRef v36 = pixelBufferOut;
  if (v35) {
    CVPixelBufferRef v36 = 0;
  }
  *(void *)a1 = v36;
  if (!v36)
  {
    NSLog(&cfstr_SDErrorFailedA.isa, "PixelBufferUtilsSession", 4175);
    return a1;
  }
  LOBYTE(v27) = 0;
LABEL_37:
  v42.origin.double x = v19;
  v42.origin.double y = v18;
  v42.size.vImagePixelCount width = v17;
  v42.size.vImagePixelCount height = v16;
  VTPixelTransferSessionRef VTTransferSession = createVTTransferSession(v42, *MEMORY[0x263F001A8]);
  *(void *)(a1 + 8) = VTTransferSession;
  if (!VTTransferSession)
  {
    CVPixelBufferRelease(*(CVPixelBufferRef *)a1);
    *(void *)a1 = 0;
    return a1;
  }
  if ((v27 & 1) == 0)
  {
LABEL_39:
    if (a5)
    {
      NSLog(&cfstr_SDErrorReflect.isa, "createVTRotationSession", 781);
    }
    else
    {
      CVPixelBufferRef pixelBufferOut = 0;
      int v37 = VTImageRotationSessionCreate();
      CVPixelBufferRef v38 = pixelBufferOut;
      if (!v37)
      {
        *(void *)(a1 + 16) = pixelBufferOut;
        if (v38) {
          return a1;
        }
        goto LABEL_73;
      }
      MEMORY[0x2166C59F0](pixelBufferOut);
      CFRelease(pixelBufferOut);
      NSLog(&cfstr_SDErrorUnableT_2.isa, "createVTRotationSession", 802);
    }
    *(void *)(a1 + 16) = 0;
LABEL_73:
    CVPixelBufferRelease(*(CVPixelBufferRef *)a1);
    *(void *)a1 = 0;
    vImage_Buffer v39 = *(OpaqueVTPixelTransferSession **)(a1 + 8);
    if (v39)
    {
      VTPixelTransferSessionInvalidate(v39);
      CFRelease(*(CFTypeRef *)(a1 + 8));
    }
    *(void *)(a1 + 8) = 0;
  }
  return a1;
}

void PixelBufferUtilsSession::~PixelBufferUtilsSession(PixelBufferUtilsSession *this)
{
  CVPixelBufferRelease(this->var0);
  this->var0 = 0;
  if (this->var2)
  {
    MEMORY[0x2166C59F0]();
    CFRelease(this->var2);
  }
  this->var2 = 0;
  var1 = this->var1;
  if (var1)
  {
    VTPixelTransferSessionInvalidate(var1);
    CFRelease(this->var1);
  }
  this->var1 = 0;
}

{
  OpaqueVTPixelTransferSession *var1;

  CVPixelBufferRelease(this->var0);
  this->var0 = 0;
  if (this->var2)
  {
    MEMORY[0x2166C59F0]();
    CFRelease(this->var2);
  }
  this->var2 = 0;
  var1 = this->var1;
  if (var1)
  {
    VTPixelTransferSessionInvalidate(var1);
    CFRelease(this->var1);
  }
  this->var1 = 0;
}

CVPixelBufferRef PixelBufferUtilsSession::createOutputPixelBuffer(PixelBufferUtilsSession *this)
{
  double width = this->var5.width;
  double height = this->var5.height;
  OSType var6 = this->var6;
  CVPixelBufferRef pixelBufferOut = 0;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
  if (CVPixelBufferCreate(v4, (unint64_t)width, (unint64_t)height, var6, BufferAttributes, &pixelBufferOut))
  {
    return 0;
  }
  else
  {
    return pixelBufferOut;
  }
}

BOOL PixelBufferUtilsSession::verifyInput(PixelBufferUtilsSession *this, CVPixelBufferRef pixelBuffer)
{
  if (!pixelBuffer) {
    return 0;
  }
  unsigned int var4 = this->var4;
  double width = this->var3.width;
  double height = this->var3.height;
  return width == (double)CVPixelBufferGetWidth(pixelBuffer)
      && height == (double)CVPixelBufferGetHeight(pixelBuffer)
      && CVPixelBufferGetPixelFormatType(pixelBuffer) == var4;
}

BOOL PixelBufferUtilsSession::verifyOutput(PixelBufferUtilsSession *this, CVPixelBufferRef pixelBuffer)
{
  if (!pixelBuffer) {
    return 0;
  }
  unsigned int var6 = this->var6;
  double width = this->var5.width;
  double height = this->var5.height;
  return width == (double)CVPixelBufferGetWidth(pixelBuffer)
      && height == (double)CVPixelBufferGetHeight(pixelBuffer)
      && CVPixelBufferGetPixelFormatType(pixelBuffer) == var6;
}

BOOL PixelBufferUtilsSession::setScalingMode(uint64_t a1, int a2)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2)
  {
    if (a2 == 1)
    {
      CFStringRef v3 = (const __CFString *)*MEMORY[0x263F1EA08];
      CFAllocatorRef v4 = (CFTypeRef *)MEMORY[0x263F1EC70];
      return VTSessionSetProperty(v2, v3, *v4) == 0;
    }
    if (!a2)
    {
      CFStringRef v3 = (const __CFString *)*MEMORY[0x263F1EA08];
      CFAllocatorRef v4 = (CFTypeRef *)MEMORY[0x263F1EC78];
      return VTSessionSetProperty(v2, v3, *v4) == 0;
    }
    NSLog(&cfstr_SDErrorUnknown.isa, "setScalingMode", 4249);
  }
  else
  {
    NSLog(&cfstr_SDErrorSession.isa, "setScalingMode", 4239);
  }
  return 0;
}

uint64_t PixelBufferUtilsSession::setHardwareAcceleration(PixelBufferUtilsSession *this, int a2)
{
  var1 = this->var1;
  uint64_t v5 = MEMORY[0x263EFFB40];
  uint64_t v6 = MEMORY[0x263EFFB38];
  if (var1)
  {
    unsigned int v7 = (CFTypeRef *)(a2 ? MEMORY[0x263EFFB40] : MEMORY[0x263EFFB38]);
    if (VTSessionSetProperty(var1, (CFStringRef)*MEMORY[0x263F1E9F0], *v7))
    {
      NSLog(&cfstr_SDErrorFailedS.isa, "setHardwareAcceleration", 4265);
      return 0;
    }
  }
  var2 = this->var2;
  if (var2)
  {
    unint64_t v9 = (CFTypeRef *)(a2 ? v5 : v6);
    if (VTSessionSetProperty(var2, (CFStringRef)*MEMORY[0x263F1E980], *v9))
    {
      NSLog(&cfstr_SDErrorFailedS_0.isa, "setHardwareAcceleration", 4277);
      return 0;
    }
  }
  return 1;
}

uint64_t PixelBufferUtilsSession::run(PixelBufferUtilsSession *this, CVPixelBufferRef pixelBuffer, __CVBuffer *a3)
{
  if (!pixelBuffer
    || (unsigned int var4 = this->var4,
        double width = this->var3.width,
        double height = this->var3.height,
        width != (double)CVPixelBufferGetWidth(pixelBuffer))
    || height != (double)CVPixelBufferGetHeight(pixelBuffer)
    || CVPixelBufferGetPixelFormatType(pixelBuffer) != var4
    || !a3
    || (var6 = this->var6, v11 = this->var5.width, double v10 = this->var5.height, v11 != (double)CVPixelBufferGetWidth(a3))
    || v10 != (double)CVPixelBufferGetHeight(a3)
    || CVPixelBufferGetPixelFormatType(a3) != var6)
  {
    NSLog(&cfstr_SDErrorProvide.isa, "run", 4295);
    return 0;
  }
  var1 = this->var1;
  if (this->var0) {
    var0 = this->var0;
  }
  else {
    var0 = pixelBuffer;
  }
  if (var1)
  {
    if (this->var0) {
      uint64_t v14 = this->var0;
    }
    else {
      uint64_t v14 = a3;
    }
    OSStatus v15 = VTPixelTransferSessionTransferImage(var1, pixelBuffer, v14);
    var2 = this->var2;
    if (var2)
    {
      int v17 = MEMORY[0x2166C5A00](var2, var0, a3);
      if (!v15) {
        goto LABEL_23;
      }
    }
    else if (!v15)
    {
      return 1;
    }
    NSLog(&cfstr_SDErrorPixelTr.isa, "run", 4333);
    return 0;
  }
  double v19 = this->var2;
  if (!v19) {
    return 1;
  }
  int v17 = MEMORY[0x2166C5A00](v19, var0, a3);
LABEL_23:
  if (v17)
  {
    NSLog(&cfstr_SDErrorRotatio_0.isa, "run", 4339);
    return 0;
  }
  return 1;
}

uint64_t PixelBufferUtilsSession::updateCrop(PixelBufferUtilsSession *this, CGRect a2)
{
  if (!this->var1)
  {
    NSLog(&cfstr_SDErrorCannotU.isa, a2.origin.x, a2.origin.y, a2.size.width, a2.size.height, "updateCrop", 4351);
    return 0;
  }
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  if (CGRectEqualToRect(a2, this->var7)) {
    return 1;
  }
  v14.origin.CGFloat x = x;
  v14.origin.CGFloat y = y;
  v14.size.CGFloat width = width;
  v14.size.CGFloat height = height;
  if (CGRectIsEmpty(v14))
  {
    CFDictionaryRef DictionaryRepresentation = 0;
  }
  else
  {
    v15.origin.CGFloat x = x;
    v15.origin.CGFloat y = y;
    v15.size.CGFloat width = width;
    v15.size.CGFloat height = height;
    CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v15);
  }
  OSStatus v9 = VTSessionSetProperty(this->var1, (CFStringRef)*MEMORY[0x263F1EA10], DictionaryRepresentation);
  if (DictionaryRepresentation) {
    CFRelease(DictionaryRepresentation);
  }
  if (v9)
  {
    NSLog(&cfstr_SDErrorPixelbu.isa, v10, v11, v12, v13, "updateCrop", 4373);
    return 0;
  }
  this->var7.origin.CGFloat x = x;
  this->var7.origin.CGFloat y = y;
  uint64_t result = 1;
  this->var7.size.CGFloat width = width;
  this->var7.size.CGFloat height = height;
  return result;
}

void PixelBufferUtilsSession::createCropScaleConvertRotateSession(PixelBufferUtilsSession *this, CGSize a2, CGSize a3, CGRect a4)
{
}

void sub_215FB95F8(_Unwind_Exception *a1)
{
  MEMORY[0x2166C5D90](v1, 0x1020C403F2F7F0DLL);
  _Unwind_Resume(a1);
}

void PixelBufferUtilsSession::createCropScaleConvertSession(PixelBufferUtilsSession *this, CGSize a2, CGSize a3, CGRect a4)
{
}

void PixelBufferUtilsSession::createScaleConvertSession(PixelBufferUtilsSession *this, CGSize a2, CGSize a3)
{
}

uint64_t PixelBufferUtilsSession::copySession(PixelBufferUtilsSession *this, PixelBufferUtilsSession *a2)
{
  if (this) {
    operator new();
  }
  NSLog(&cfstr_SDErrorCannotC.isa, a2, "copySession", 4420);
  return 0;
}

void sub_215FB9734(_Unwind_Exception *a1)
{
  MEMORY[0x2166C5D90](v1, 0x1020C403F2F7F0DLL);
  _Unwind_Resume(a1);
}

uint64_t PixelBufferUtilsTiledView::TileConfig::TileConfig(uint64_t this)
{
  *(unsigned char *)(this + 8) = 0;
  *(void *)this = 0;
  return this;
}

{
  *(unsigned char *)(this + 8) = 0;
  *(void *)this = 0;
  return this;
}

uint64_t PixelBufferUtilsTiledView::TileConfig::TileConfig(uint64_t this, char a2, float a3, float a4)
{
  *(float *)this = a4;
  *(float *)(this + 4) = a3;
  *(unsigned char *)(this + 8) = a2;
  return this;
}

{
  *(float *)this = a4;
  *(float *)(this + 4) = a3;
  *(unsigned char *)(this + 8) = a2;
  return this;
}

int32x2_t PixelBufferUtilsTiledView::TileConfig::TileConfig(PixelBufferUtilsTiledView::TileConfig *this, int32x2_t *a2)
{
  __int8 v2 = a2[1].i8[0];
  int32x2_t result = vrev64_s32(*a2);
  *(int32x2_t *)this = result;
  *((unsigned char *)this + 8) = v2;
  return result;
}

{
  __int8 v2;
  int32x2_t result;

  __int8 v2 = a2[1].i8[0];
  int32x2_t result = vrev64_s32(*a2);
  *(int32x2_t *)this = result;
  *((unsigned char *)this + 8) = v2;
  return result;
}

void PixelBufferUtilsTiledView::createTiledView(PixelBufferUtilsTiledView *this, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, PixelBufferUtilsTiledView::TileConfig *a6)
{
}

PixelBufferUtils *PixelBufferUtilsTiledView::render(PixelBufferUtilsTiledView *this, __CVBuffer **a2, uint64_t a3, __CVBuffer *a4, __CVBuffer *a5, unint64_t a6)
{
  uint64_t v6 = *((void *)this + 2);
  uint64_t v7 = *((void *)this + 4);
  if (v7 * v6 != a3)
  {
    NSLog(&cfstr_SDErrorUnableT.isa, a2, "render", 4480);
    return 0;
  }
  uint64_t v10 = *((void *)this + 5);
  if (v10) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = ((unint64_t)a5 | a6) == 0;
  }
  if (!v11)
  {
    NSLog(&cfstr_SDErrorUnableT_0.isa, a2, "render", 4486);
    return 0;
  }
  CGRect v14 = (const __CFAllocator **)MEMORY[0x263EFFB08];
  CGRect v15 = (CGRect *)MEMORY[0x263F001A8];
  if (a4)
  {
    data = (__CVBuffer *)*((void *)this + 6);
    if (!data)
    {
      size_t v17 = *((void *)this + 1);
      size_t v18 = *((void *)this + 3);
      pixelBufferOut.data = 0;
      CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFDictionaryRef BufferAttributes = (const __CFDictionary *)getBufferAttributes();
      if (CVPixelBufferCreate(v19, v17, v18, 0x42475241u, BufferAttributes, (CVPixelBufferRef *)&pixelBufferOut)) {
        data = 0;
      }
      else {
        data = (__CVBuffer *)pixelBufferOut.data;
      }
      *((void *)this + 6) = data;
    }
    PixelBufferUtils::scaleConvertRotatePixelBuffer(a4, 0, data, *v15, 0, 0, (__CVBuffer **)1);
    uint64_t v6 = *((void *)this + 2);
    uint64_t v7 = *((void *)this + 4);
    uint64_t v10 = *((void *)this + 5);
  }
  __s = (char *)a6;
  size_t v21 = v6 * *((void *)this + 1);
  size_t v22 = v10 + v7 * *((void *)this + 3);
  pixelBufferOut.data = 0;
  CFAllocatorRef v23 = *v14;
  CFDictionaryRef v24 = (const __CFDictionary *)getBufferAttributes();
  CFAllocatorRef v67 = v23;
  unint64_t v61 = v21;
  if (CVPixelBufferCreate(v23, v21, v22, 0x42475241u, v24, (CVPixelBufferRef *)&pixelBufferOut)) {
    id v25 = 0;
  }
  else {
    id v25 = (__CVBuffer *)pixelBufferOut.data;
  }
  CVPixelBufferLockBaseAddress(v25, 0);
  memset(&pixelBufferOut, 0, sizeof(pixelBufferOut));
  float v63 = v25;
  PixelBufferUtils::asVImageBuffer(v25, *v15, &pixelBufferOut);
  unint64_t v26 = *((void *)this + 5);
  if (v26 && pixelBufferOut.rowBytes * v26 >= 4) {
    memset_pattern16(pixelBufferOut.data, &unk_215FC4730, (pixelBufferOut.rowBytes * v26) & 0xFFFFFFFFFFFFFFFCLL);
  }
  double v27 = (double)v26 * 0.15;
  float v62 = (char *)((double)v26 * 0.8);
  uint64_t v28 = *((void *)this + 2);
  uint64_t v29 = *((void *)this + 4);
  if (v29 * v28)
  {
    unint64_t v30 = 0;
    unsigned int v31 = 1;
    vImagePixelCount v66 = (char *)pixelBufferOut.data;
    size_t rowBytes = pixelBufferOut.rowBytes;
    do
    {
      CFAllocatorRef v33 = a2[v30];
      if (v33)
      {
        size_t Width = CVPixelBufferGetWidth(a2[v30]);
        size_t Height = CVPixelBufferGetHeight(v33);
        unint64_t v36 = *((void *)this + 2);
        size_t v37 = *((void *)this + 3);
        size_t v38 = *((void *)this + 1);
        unint64_t v39 = v30 / v36;
        size_t v40 = v30 % v36 * v38;
        size_t v41 = *((void *)this + 5) + v39 * v37;
        float v42 = (float)v37;
        float v43 = (float)Height;
        float v44 = (float)v37 / (float)Height;
        float v45 = (float)v38;
        float v46 = (float)Width;
        float v47 = (float)v38 / (float)Width;
        if (v44 != v47)
        {
          if (v44 < v47)
          {
            v40 += (v38 - (unint64_t)(float)((float)(v46 / v43) * v45)) >> 1;
            size_t v38 = (unint64_t)(float)((float)(v46 / v43) * v45);
          }
          else
          {
            v41 += (v37 - (unint64_t)(float)((float)(v43 / v46) * v42)) >> 1;
            size_t v37 = (unint64_t)(float)((float)(v43 / v46) * v42);
          }
        }
        CVPixelBufferRef texture = 0;
        CVPixelBufferCreateWithBytes(v67, v38, v37, 0x42475241u, &v66[4 * v40 + rowBytes * v41], rowBytes, 0, 0, 0, &texture);
        uint64_t v48 = *(void *)this + 12 * v30;
        int v49 = *(unsigned __int8 *)(v48 + 8);
        float v50 = *(float *)v48;
        float v51 = *(float *)(v48 + 4);
        OSType PixelFormatType = CVPixelBufferGetPixelFormatType(v33);
        v72.CGFloat width = (double)v38;
        v72.CGFloat height = (double)v37;
        CroppedAndScaledPixelBuffer = PixelBufferUtils::createCroppedAndScaledPixelBuffer(v33, 0, *v15, v72);
        unsigned int v55 = CroppedAndScaledPixelBuffer;
        if (PixelFormatType == 1717855600 || PixelFormatType == 1751411059 || PixelFormatType == 1751410032)
        {
          int v56 = PixelBufferUtils::colorizedDepthPixelBuffer(CroppedAndScaledPixelBuffer, 0, v49 != 0, v51, v50, 0, texture, v54);
          if (v49)
          {
            if (!v56)
            {
              LODWORD(v57) = 0.5;
              if ((PixelBufferUtils::alphaBlend(*((PixelBufferUtils **)this + 6), texture, &texture, v57, (__CVBuffer **)1) & 1) == 0)NSLog(&cfstr_SDErrorFailedC.isa, "render", 4582); {
            }
              }
          }
        }
        else
        {
          PixelBufferUtils::convertPixelBufferFormat(CroppedAndScaledPixelBuffer, texture, 0);
        }
        CVPixelBufferRelease(v55);
        CVPixelBufferRelease(texture);
        uint64_t v28 = *((void *)this + 2);
        uint64_t v29 = *((void *)this + 4);
      }
      unint64_t v30 = v31++;
    }
    while (v29 * v28 > v30);
  }
  unint64_t v59 = (unint64_t)v27;
  uint64_t v58 = v63;
  if (a5)
  {
    v70.CGFloat x = (double)v59;
    v70.CGFloat y = (double)(*((void *)this + 5) - v59);
    PixelBufferUtils::addTextToPixelBuffer(v63, a5, v62, v70);
  }
  if (__s)
  {
    v71.CGFloat x = (double)v61 + (double)(strlen(__s) * (unint64_t)v62) * -0.6 - (double)v59;
    v71.CGFloat y = (double)(*((void *)this + 5) - v59);
    PixelBufferUtils::addTextToPixelBuffer(v63, (__CVBuffer *)__s, v62, v71);
  }
  CVPixelBufferUnlockBaseAddress(v63, 0);
  return v58;
}

void PixelBufferUtilsTiledView::~PixelBufferUtilsTiledView(CVPixelBufferRef *this)
{
  if (*this) {
    MEMORY[0x2166C5D70](*this, 0x1000C8005A209FELL);
  }
}

{
  CVPixelBufferRelease(this[6]);
  if (*this) {
    MEMORY[0x2166C5D70](*this, 0x1000C8005A209FELL);
  }
}

void sub_215FBA2E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FBA440(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FBA528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FBAA0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FBAB9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ADPCEDisparityColorExecutor;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_215FBBB3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v11);

  _Unwind_Resume(a1);
}

void sub_215FBC158(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FBC624(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FBC938(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_215FBCC1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FBCFEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215FBD15C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215FBD5DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, void *a20,void *a21,id a22)
{
  MEMORY[0x2166C5D70](v23, 0x1000C80FA0F61DDLL);
  _Unwind_Resume(a1);
}

void sub_215FBD7C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_215FBD95C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FBDC40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_215FBDF78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_215FBE064(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  InstrumentsTraceGuard::~InstrumentsTraceGuard((InstrumentsTraceGuard *)va);
  _Unwind_Resume(a1);
}

void *fmincon_spg(void (*a1)(void, void, void, void), void (*a2)(void, void, void), uint64_t a3, uint64_t a4, int a5, double *a6, double *a7, double *a8, void *a9, uint64_t a10)
{
  uint64_t v11 = a10;
  v152[9] = *MEMORY[0x263EF8340];
  char v132 = 0;
  __int16 v131 = 0;
  memset(v150, 0, sizeof(v150));
  memset(&__src[2], 0, 48);
  double v12 = (double *)&defaultSPGConfig;
  if (a8) {
    double v12 = a8;
  }
  memset(__src, 0, 32);
  if ((a5 - 11) < 0xFFFFFFF6 || (int v13 = *((_DWORD *)v12 + 2), v13 > 10) || v13 <= 0)
  {
    int v113 = 0;
    BOOL v114 = 0;
    double v23 = 0.0;
    double v123 = 0.0;
    int32x2_t result = memcpy(a9, __src, 8 * a5);
    goto LABEL_113;
  }
  CGRect v14 = a7;
  uint64_t v121 = *((unsigned int *)v12 + 2);
  uint64_t v16 = 0;
  int v17 = *((_DWORD *)v12 + 14);
  double v18 = *v12;
  double v19 = v12[2];
  double v20 = v12[3];
  double v117 = v12[4];
  double v118 = v12[6];
  double v122 = v12[5];
  do
  {
    double v21 = *(double *)(a4 + v16 * 8);
    if (v21 >= a7[v16]) {
      double v21 = a7[v16];
    }
    if (v21 <= a6[v16]) {
      double v21 = a6[v16];
    }
    *(double *)((char *)v150 + v16 * 8) = v21;
    ++v16;
  }
  while (a5 != v16);
  double v133 = 0.0;
  double v22 = v12[8];
  a1(v150, a3, &v133, v148);
  double v23 = v133;
  __memcpy_chk();
  uint64_t v24 = 0;
  do
    *(double *)&v146[v24++] = v23;
  while (v121 != v24);
  if (v17 < 1)
  {
    int v113 = 0;
    double v123 = v23;
    goto LABEL_112;
  }
  int v125 = 0;
  uint64_t v25 = 8 * a5;
  int v26 = v121;
  double v116 = v23;
  double v123 = v23;
  uint64_t v119 = v14;
  while (1)
  {
    double v130 = 0.0;
    if (a5 < 1) {
      goto LABEL_50;
    }
    unint64_t v27 = 0;
    do
    {
      *(double *)&v152[v27 / 8 - 1] = *(double *)((char *)v150 + v27) - *(double *)&v148[v27];
      v27 += 8;
    }
    while (v25 != v27);
    unint64_t v28 = 0;
    do
    {
      double v29 = *(double *)&v152[v28 / 8 - 1];
      if (v29 >= v14[v28 / 8]) {
        double v29 = v14[v28 / 8];
      }
      if (v29 <= a6[v28 / 8]) {
        double v29 = a6[v28 / 8];
      }
      *(double *)&v152[v28 / 8 - 1] = v29;
      v28 += 8;
    }
    while (v25 != v28);
    unint64_t v30 = 0;
    do
    {
      *(double *)&v152[v30 / 8 - 1] = *(double *)&v152[v30 / 8 - 1] - *(double *)((char *)v150 + v30);
      v30 += 8;
    }
    while (v25 != v30);
    unint64_t v31 = 0;
    do
    {
      double v32 = *(double *)&v152[v31 / 8 - 1];
      if (v32 < 0.0) {
        double v32 = -v32;
      }
      *(double *)&v152[v31 / 8 - 1] = v32;
      v31 += 8;
    }
    while (v25 != v31);
    double v33 = v151;
    if (a5 >= 2)
    {
      char v34 = (double *)v152;
      uint64_t v35 = a5 - 1;
      do
      {
        double v36 = *v34++;
        double v37 = v36;
        if (v36 > v33) {
          double v33 = v37;
        }
        --v35;
      }
      while (v35);
    }
    if (v33 <= v118) {
      break;
    }
    size_t v38 = (double *)v143;
    unint64_t v39 = (double *)v148;
    uint64_t v40 = a5;
    do
    {
      double v41 = *v39++;
      *v38++ = v22 * v41;
      --v40;
    }
    while (v40);
    float v42 = (double *)v143;
    float v43 = (double *)v150;
    uint64_t v44 = a5;
    do
    {
      double v45 = *v43++;
      double *v42 = v45 - *v42;
      ++v42;
      --v44;
    }
    while (v44);
    float v46 = (double *)v143;
    float v47 = v14;
    uint64_t v48 = a6;
    uint64_t v49 = a5;
    do
    {
      double v50 = *v46;
      double v51 = *v47++;
      double v52 = v51;
      BOOL v53 = *v46 < v51;
      double v54 = *v48++;
      double v55 = v54;
      if (!v53) {
        double v50 = v52;
      }
      if (v50 <= v55) {
        double v50 = v55;
      }
      *v46++ = v50;
      --v49;
    }
    while (v49);
    int v56 = (double *)v150;
    double v57 = (double *)v143;
    uint64_t v58 = a5;
    do
    {
      double v59 = *v56++;
      double *v57 = *v57 - v59;
      ++v57;
      --v58;
    }
    while (v58);
LABEL_50:
    double v60 = *(double *)v146;
    if (v26 > 1)
    {
      unint64_t v61 = (double *)&v147;
      uint64_t v62 = v121 - 1;
      do
      {
        double v63 = *v61++;
        double v64 = v63;
        if (v63 > v60) {
          double v60 = v64;
        }
        --v62;
      }
      while (v62);
    }
    if (a5 < 1)
    {
      int v124 = 0;
    }
    else
    {
      unint64_t v65 = 0;
      do
      {
        *(double *)&v141[v65 / 8] = *(double *)&v148[v65] * *(double *)&v143[v65];
        v65 += 8;
      }
      while (v25 != v65);
      double v10 = *(double *)v141;
      if (a5 < 2)
      {
        int v124 = 0;
      }
      else
      {
        vImagePixelCount v66 = (double *)&v142;
        uint64_t v67 = a5 - 1;
        do
        {
          double v68 = *v66++;
          double v10 = v10 + v68;
          --v67;
        }
        while (v67);
        int v124 = 1;
      }
    }
    int v69 = 0;
    double v70 = 1.0;
    do
    {
      double v129 = 0.0;
      if (a5 >= 1)
      {
        CGPoint v71 = &v151;
        CGSize v72 = (double *)v143;
        uint64_t v73 = a5;
        do
        {
          double v74 = *v72++;
          *v71++ = v70 * v74;
          --v73;
        }
        while (v73);
        size_t v75 = (double *)v134;
        uint64_t v76 = &v151;
        unint64_t v77 = (double *)v150;
        uint64_t v78 = a5;
        do
        {
          double v79 = *v77++;
          double v80 = v79;
          double v81 = *v76++;
          *v75++ = v80 + v81;
          --v78;
        }
        while (v78);
      }
      a2(v134, a3, &v129);
      v82.n128_f64[0] = v129;
      if (v129 <= v60 + v18 * v70 * v10) {
        break;
      }
      v82.n128_f64[0] = v10 * (v70 * v70 * -0.5) / (v129 - v133 - v70 * v10);
      BOOL v83 = v82.n128_f64[0] > v20 * v70 || v19 > v82.n128_f64[0];
      double v70 = v83 ? v70 * 0.5 : v10 * (v70 * v70 * -0.5) / (v129 - v133 - v70 * v10);
      ++v69;
    }
    while (v69 != 1000);
    if (a5 >= 1)
    {
      uint64_t v84 = 0;
      do
      {
        *(double *)&v145[v84] = v70 * *(double *)&v143[v84];
        v84 += 8;
      }
      while (v25 != v84);
      uint64_t v85 = 0;
      do
      {
        *(double *)&v145[v85] = *(double *)&v145[v85] + *(double *)((char *)v150 + v85);
        v85 += 8;
      }
      while (v25 != v85);
      int v86 = (double *)v145;
      a1(v145, a3, &v130, v144);
      vImagePixelCount v87 = (double *)v140;
      float v88 = (double *)v150;
      uint64_t v89 = a5;
      do
      {
        double v90 = *v86++;
        double v91 = v90;
        double v92 = *v88++;
        *v87++ = v91 - v92;
        --v89;
      }
      while (v89);
      int16x8_t v93 = (double *)v139;
      float32x4_t v94 = (double *)v148;
      uint64_t v95 = (double *)v144;
      uint64_t v96 = a5;
      do
      {
        double v97 = *v95++;
        double v98 = v97;
        double v99 = *v94++;
        *v93++ = v98 - v99;
        --v96;
      }
      while (v96);
      unint64_t v100 = 0;
      int v101 = v124;
      do
      {
        double v102 = *(double *)&v139[v100];
        *(double *)&v135[v100 / 8] = *(double *)&v140[v100] * v102;
        v100 += 8;
      }
      while (v25 != v100);
      double v103 = *(double *)v135;
      if (!v124) {
        goto LABEL_94;
      }
LABEL_92:
      size_t v104 = (double *)&v136;
      uint64_t v105 = a5 - 1;
      do
      {
        double v106 = *v104++;
        double v102 = v106;
        double v103 = v103 + v106;
        --v105;
      }
      while (v105);
      goto LABEL_94;
    }
    ((void (*)(unsigned char *, uint64_t, double *, unsigned char *, __n128))a1)(v145, a3, &v130, v144, v82);
    int v101 = v124;
    if (v124) {
      goto LABEL_92;
    }
LABEL_94:
    double v22 = v122;
    if (v103 > 0.0)
    {
      if (a5 >= 1)
      {
        unint64_t v107 = 0;
        do
        {
          *(double *)&v137[v107 / 8] = *(double *)&v140[v107] * *(double *)&v140[v107];
          v107 += 8;
        }
        while (v25 != v107);
        double v102 = *(double *)v137;
      }
      if (v101)
      {
        unint64_t v108 = (double *)&v138;
        uint64_t v109 = a5 - 1;
        do
        {
          double v110 = *v108++;
          double v102 = v102 + v110;
          --v109;
        }
        while (v109);
      }
      double v111 = v102 / v103;
      if (v111 >= v122) {
        double v111 = v122;
      }
      if (v117 <= v111) {
        double v22 = v111;
      }
      else {
        double v22 = v117;
      }
    }
    __memcpy_chk();
    double v112 = v130;
    double v133 = v130;
    __memcpy_chk();
    int v26 = v121;
    *(double *)&v146[++v125 % (int)v121] = v112;
    if (v112 < v123)
    {
      __memcpy_chk();
      double v123 = v112;
    }
    CGRect v14 = v119;
    if (v125 == v17)
    {
      int v113 = v17;
      uint64_t v11 = a10;
      double v23 = v116;
      goto LABEL_112;
    }
  }
  uint64_t v11 = a10;
  double v23 = v116;
  int v113 = v125;
LABEL_112:
  BOOL v114 = v113 < v17;
  int32x2_t result = memcpy(a9, __src, 8 * a5);
LABEL_113:
  if (v11)
  {
    *(_DWORD *)uint64_t v11 = v113;
    *(unsigned char *)(v11 + 4) = v114;
    *(_WORD *)(v11 + 5) = v131;
    *(unsigned char *)(v11 + 7) = v132;
    *(double *)(v11 + 8) = v23;
    *(double *)(v11 + 16) = v123;
  }
  return result;
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x270F18A48]();
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x270EE4948]();
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x270EE4998](cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x270EE4A30](cf);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x270EE4E10](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x270EE4E68]();
}

void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source)
{
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  return MEMORY[0x270EE54B8](userNotification);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return (CFUserNotificationRef)MEMORY[0x270EE54C8](allocator, flags, error, dictionary, timeout);
}

CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource(CFAllocatorRef allocator, CFUserNotificationRef userNotification, CFUserNotificationCallBack callout, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x270EE54D0](allocator, userNotification, callout, order);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x270EE59E8](data, width, height, bitsPerComponent, bytesPerRow, space, *(void *)&bitmapInfo);
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  return (CGImageRef)MEMORY[0x270EE59F8](context);
}

CGColorRef CGColorCreateGenericRGB(CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  return (CGColorRef)MEMORY[0x270EE5B80](red, green, blue, alpha);
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x270EE5C68]();
}

CFStringRef CGColorSpaceGetName(CGColorSpaceRef space)
{
  return (CFStringRef)MEMORY[0x270EE5D10](space);
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
}

void CGContextFillEllipseInRect(CGContextRef c, CGRect rect)
{
}

void CGContextRelease(CGContextRef c)
{
}

void CGContextSetFillColorWithColor(CGContextRef c, CGColorRef color)
{
}

void CGContextSetTextDrawingMode(CGContextRef c, CGTextDrawingMode mode)
{
}

void CGContextSetTextMatrix(CGContextRef c, CGAffineTransform *t)
{
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
}

CGImageDestinationRef CGImageDestinationCreateWithURL(CFURLRef url, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x270EF4F38](url, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return MEMORY[0x270EF4F48](idst);
}

CGBitmapInfo CGImageGetBitmapInfo(CGImageRef image)
{
  return MEMORY[0x270EE6780](image);
}

size_t CGImageGetBitsPerComponent(CGImageRef image)
{
  return MEMORY[0x270EE6790](image);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x270EE67D8](image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x270EE6800](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x270EE6868](image);
}

void CGImageRelease(CGImageRef image)
{
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x270EF5018](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithURL(CFURLRef url, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x270EF5040](url, options);
}

size_t CGImageSourceGetCount(CGImageSourceRef isrc)
{
  return MEMORY[0x270EF5048](isrc);
}

BOOL CGRectContainsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x270EE7180]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x270EE7188]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x270EE71A0]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CGRect CGRectIntegral(CGRect rect)
{
  MEMORY[0x270EE7230]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.CGFloat height = v4;
  result.size.CGFloat width = v3;
  result.origin.CGFloat y = v2;
  result.origin.CGFloat x = v1;
  return result;
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x270EE7260]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsNull(CGRect rect)
{
  return MEMORY[0x270EE7270]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGRect CGRectStandardize(CGRect rect)
{
  MEMORY[0x270EE7288]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.CGFloat height = v4;
  result.size.CGFloat width = v3;
  result.origin.CGFloat y = v2;
  result.origin.CGFloat x = v1;
  return result;
}

CMTime *__cdecl CMClockMakeHostTimeFromSystemUnits(CMTime *__return_ptr retstr, uint64_t hostTime)
{
  return (CMTime *)MEMORY[0x270EE7AB8](retstr, hostTime);
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  MEMORY[0x270EE7E08](time);
  return result;
}

CTFontRef CTFontCreateWithName(CFStringRef name, CGFloat size, const CGAffineTransform *matrix)
{
  return (CTFontRef)MEMORY[0x270EE9AF8](name, matrix, size);
}

CTLineRef CTLineCreateWithAttributedString(CFAttributedStringRef attrString)
{
  return (CTLineRef)MEMORY[0x270EE9D70](attrString);
}

void CTLineDraw(CTLineRef line, CGContextRef context)
{
}

CFTypeRef CVBufferGetAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x270EE9FD0](buffer, key, attachmentMode);
}

CFDictionaryRef CVBufferGetAttachments(CVBufferRef buffer, CVAttachmentMode attachmentMode)
{
  return (CFDictionaryRef)MEMORY[0x270EE9FD8](buffer, *(void *)&attachmentMode);
}

void CVBufferSetAttachment(CVBufferRef buffer, CFStringRef key, CFTypeRef value, CVAttachmentMode attachmentMode)
{
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x270EEA150](allocator, width, height, *(void *)&pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

CVReturn CVPixelBufferCreateWithBytes(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, void *baseAddress, size_t bytesPerRow, CVPixelBufferReleaseBytesCallback releaseCallback, void *releaseRefCon, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x270EEA168](allocator, width, height, *(void *)&pixelFormatType, baseAddress, bytesPerRow, releaseCallback, releaseRefCon);
}

CVReturn CVPixelBufferCreateWithPlanarBytes(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, void *dataPtr, size_t dataSize, size_t numberOfPlanes, void **planeBaseAddress, size_t *planeWidth, size_t *planeHeight, size_t *planeBytesPerRow, CVPixelBufferReleasePlanarBytesCallback releaseCallback, void *releaseRefCon, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x270EEA178](allocator, width, height, *(void *)&pixelFormatType, dataPtr, dataSize, numberOfPlanes, planeBaseAddress);
}

uint64_t CVPixelBufferGetAttributes()
{
  return MEMORY[0x270EEA188]();
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return (void *)MEMORY[0x270EEA190](pixelBuffer);
}

void *__cdecl CVPixelBufferGetBaseAddressOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return (void *)MEMORY[0x270EEA1A0](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA1B0](pixelBuffer);
}

size_t CVPixelBufferGetBytesPerRowOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x270EEA1C8](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetDataSize(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA1D0](pixelBuffer);
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA1E8](pixelBuffer);
}

size_t CVPixelBufferGetHeightOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x270EEA1F8](pixelBuffer, planeIndex);
}

IOSurfaceRef CVPixelBufferGetIOSurface(CVPixelBufferRef pixelBuffer)
{
  return (IOSurfaceRef)MEMORY[0x270EEA200](pixelBuffer);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA218](pixelBuffer);
}

size_t CVPixelBufferGetPlaneCount(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA220](pixelBuffer);
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA240](pixelBuffer);
}

size_t CVPixelBufferGetWidthOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x270EEA250](pixelBuffer, planeIndex);
}

Boolean CVPixelBufferIsPlanar(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA258](pixelBuffer);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return MEMORY[0x270EEA260](pixelBuffer, lockFlags);
}

void CVPixelBufferRelease(CVPixelBufferRef texture)
{
}

CVPixelBufferRef CVPixelBufferRetain(CVPixelBufferRef texture)
{
  return (CVPixelBufferRef)MEMORY[0x270EEA320](texture);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return MEMORY[0x270EEA330](pixelBuffer, unlockFlags);
}

uint64_t CVPixelFormatDescriptionGetDescriptionWithPixelFormatType()
{
  return MEMORY[0x270EEA348]();
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x270EF4820](*(void *)&object);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x270EF49D8](*(void *)&entry, key, allocator, *(void *)&options);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x270EF4AB0](*(void *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EF4AD8](name);
}

size_t IOSurfaceGetHeightOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x270EF4D58](buffer, planeIndex);
}

size_t IOSurfaceGetWidthOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x270EF4DF0](buffer, planeIndex);
}

void IOSurfaceSetValue(IOSurfaceRef buffer, CFStringRef key, CFTypeRef value)
{
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x270F95F98]();
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x270EF5E20]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x270EF2A50](aClassName);
}

void NSLog(NSString *format, ...)
{
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return (NSArray *)MEMORY[0x270EF2BD8](directory, domainMask, expandTilde);
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x270EF2BE8](aSelectorName);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x270EF2C08](aClass);
}

uint64_t VTImageRotationSessionCreate()
{
  return MEMORY[0x270F06758]();
}

uint64_t VTImageRotationSessionInvalidate()
{
  return MEMORY[0x270F06760]();
}

uint64_t VTImageRotationSessionTransferImage()
{
  return MEMORY[0x270F06778]();
}

OSStatus VTPixelTransferSessionCreate(CFAllocatorRef allocator, VTPixelTransferSessionRef *pixelTransferSessionOut)
{
  return MEMORY[0x270F067E0](allocator, pixelTransferSessionOut);
}

void VTPixelTransferSessionInvalidate(VTPixelTransferSessionRef session)
{
}

OSStatus VTPixelTransferSessionTransferImage(VTPixelTransferSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return MEMORY[0x270F067F0](session, sourceBuffer, destinationBuffer);
}

OSStatus VTSessionSetProperty(VTSessionRef session, CFStringRef propertyKey, CFTypeRef propertyValue)
{
  return MEMORY[0x270F06820](session, propertyKey, propertyValue);
}

uint64_t VZClientOptionsCreate()
{
  return MEMORY[0x270F84190]();
}

uint64_t VZClientOptionsSetTcpIpAddress()
{
  return MEMORY[0x270F841A0]();
}

uint64_t VZDataCreateBlobWithCFData()
{
  return MEMORY[0x270F841B0]();
}

uint64_t VZDataCreateImageWithCVPixelBuffer()
{
  return MEMORY[0x270F841D0]();
}

uint64_t VZDataGetDictionaryDataTypeID()
{
  return MEMORY[0x270F841F8]();
}

uint64_t VZDataGetMeshDataTypeID()
{
  return MEMORY[0x270F84208]();
}

uint64_t VZDataInfoCreate()
{
  return MEMORY[0x270F84210]();
}

uint64_t VZDataInfoSetName()
{
  return MEMORY[0x270F84228]();
}

uint64_t VZDataInfoSetTimestampMachContinuousNanoseconds()
{
  return MEMORY[0x270F84230]();
}

uint64_t VZDestinationCreateWithClient()
{
  return MEMORY[0x270F84240]();
}

uint64_t VZDestinationCreateWithFileExporter()
{
  return MEMORY[0x270F84258]();
}

uint64_t VZFileExportOptionsAddFilteredStoragePreference()
{
  return MEMORY[0x270F84260]();
}

uint64_t VZFileExportOptionsCreate()
{
  return MEMORY[0x270F84278]();
}

uint64_t VZFileExportOptionsSetAsyncQueueMaxElementCount()
{
  return MEMORY[0x270F84288]();
}

uint64_t VZLogMessageFilterCreate()
{
  return MEMORY[0x270F84290]();
}

uint64_t VZLogMessageFilterRequireDataTypeIDExact()
{
  return MEMORY[0x270F842A8]();
}

uint64_t VZLoggerAddDestination()
{
  return MEMORY[0x270F842B0]();
}

uint64_t VZLoggerCreate()
{
  return MEMORY[0x270F842C0]();
}

uint64_t VZLoggerDisable()
{
  return MEMORY[0x270F842D0]();
}

uint64_t VZLoggerEnable()
{
  return MEMORY[0x270F842E0]();
}

uint64_t VZLoggerLogData()
{
  return MEMORY[0x270F84300]();
}

uint64_t VZLoggerRemoveDestination()
{
  return MEMORY[0x270F84308]();
}

uint64_t VZRelease()
{
  return MEMORY[0x270F84328]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x270F98268]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x270F982E8](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x270F982F8](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x270F98458](__n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x270F98498](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x270F984A0](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x270F984E0](this, __pos, __s);
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x270F98758]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x270F98760]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x270F987B0]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x270F98870]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x270F988A8]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x270F988B0]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x270F98C28]();
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x270F98DE8]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x270F98E10](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return (std::string *)MEMORY[0x270F98E20](retstr, __val);
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x270F98F10](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int *__error(void)
{
  return (int *)MEMORY[0x270ED7DC0]();
}

simd_float2x2 __invert_f2(simd_float2x2 a1)
{
  MEMORY[0x270ED7E10]((__n128)a1, *(__n128 *)((char *)&a1 + 8));
  result.columns[1] = v2;
  result.columns[0] = v1;
  return result;
}

simd_float3x3 __invert_f3(simd_float3x3 a1)
{
  MEMORY[0x270ED7E18]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2]);
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

simd_float4x4 __invert_f4(simd_float4x4 a1)
{
  MEMORY[0x270ED7E20]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2], (__n128)a1.columns[3]);
  result.columns[3].i64[1] = v8;
  result.columns[3].i64[0] = v7;
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x270ED7E38]();
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x270ED7E90](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_signpost_emit_unreliably_with_name_impl()
{
  return MEMORY[0x270ED8118]();
}

long double acos(long double __x)
{
  MEMORY[0x270ED8588](__x);
  return result;
}

long double asin(long double __x)
{
  MEMORY[0x270ED8610](__x);
  return result;
}

long double atan(long double __x)
{
  MEMORY[0x270ED86A0](__x);
  return result;
}

long double atan2(long double __y, long double __x)
{
  MEMORY[0x270ED86A8](__y, __x);
  return result;
}

float atan2f(float a1, float a2)
{
  MEMORY[0x270ED86B8](a1, a2);
  return result;
}

int atoi(const char *a1)
{
  return MEMORY[0x270ED86E8](a1);
}

void bzero(void *a1, size_t a2)
{
}

BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
{
  return MEMORY[0x270F9A400](cls, name, imp, types);
}

BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)
{
  return MEMORY[0x270F9A410](cls, name, attributes, *(void *)&attributeCount);
}

long double cos(long double __x)
{
  MEMORY[0x270ED9128](__x);
  return result;
}

float cosf(float a1)
{
  MEMORY[0x270ED9130](a1);
  return result;
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  return MEMORY[0x270F9C690](crc, buf, *(void *)&len);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9448](attr, frequency);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

uint64_t espresso_get_version_string()
{
  return MEMORY[0x270F27F70]();
}

long double exp(long double __x)
{
  MEMORY[0x270ED9858](__x);
  return result;
}

long double exp2(long double __x)
{
  MEMORY[0x270ED9860](__x);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x270ED98C8](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x270ED99F0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x270ED9A08](a1, a2);
}

void free(void *a1)
{
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9B88](__ptr, __size, __nitems, __stream);
}

const char *getprogname(void)
{
  return (const char *)MEMORY[0x270ED9D00]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x270ED9F50]();
}

long double log(long double __x)
{
  MEMORY[0x270EDA0A8](__x);
  return result;
}

float logf(float a1)
{
  MEMORY[0x270EDA0F8](a1);
  return result;
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA388](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x270F9A568](a1);
}

{
  MEMORY[0x270F9A570](context);
}

{
  return (void *)MEMORY[0x270F9A588]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_enumerationMutation(id obj)
{
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x270F9A678](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x270F9A688](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x270F9A6B0](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x270F9A700]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x270F9A710]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x270F9A728]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x270F9A898](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x270F9AA18](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x270F9AA20](obj);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x270EDAA58](log);
}

uint64_t os_variant_allows_internal_security_policies()
{
  return MEMORY[0x270EDAB10]();
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x270EDACF8](__x, __y);
  return result;
}

int rmdir(const char *a1)
{
  return MEMORY[0x270EDB268](a1);
}

long double sin(long double __x)
{
  MEMORY[0x270EDB4E8](__x);
  return result;
}

float sinf(float a1)
{
  MEMORY[0x270EDB4F0](a1);
  return result;
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x270EDB5D8](*(void *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

long double tan(long double __x)
{
  MEMORY[0x270EDB810](__x);
  return result;
}

vImage_Error vImageBuffer_Init(vImage_Buffer *buf, vImagePixelCount height, vImagePixelCount width, uint32_t pixelBits, vImage_Flags flags)
{
  return MEMORY[0x270EDEF20](buf, height, width, *(void *)&pixelBits, *(void *)&flags);
}

vImage_Error vImageConvert_16UToF(const vImage_Buffer *src, const vImage_Buffer *dest, float offset, float scale, vImage_Flags flags)
{
  return MEMORY[0x270EDEF58](src, dest, *(void *)&flags, offset, scale);
}

vImage_Error vImageConvert_420Yp8_CbCr8ToARGB8888(const vImage_Buffer *srcYp, const vImage_Buffer *srcCbCr, const vImage_Buffer *dest, const vImage_YpCbCrToARGB *info, const uint8_t permuteMap[4], const uint8_t alpha, vImage_Flags flags)
{
  return MEMORY[0x270EDEF68](srcYp, srcCbCr, dest, info, permuteMap, alpha, *(void *)&flags);
}

vImage_Error vImageConvert_ARGB8888To420Yp8_CbCr8(const vImage_Buffer *src, const vImage_Buffer *destYp, const vImage_Buffer *destCbCr, const vImage_ARGBToYpCbCr *info, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x270EDEF90](src, destYp, destCbCr, info, permuteMap, *(void *)&flags);
}

vImage_Error vImageConvert_ARGBFFFFtoARGB8888_dithered(const vImage_Buffer *src, const vImage_Buffer *dest, const Pixel_FFFF maxFloat, const Pixel_FFFF minFloat, int dither, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x270EDEFC0](src, dest, maxFloat, minFloat, *(void *)&dither, permuteMap, *(void *)&flags);
}

vImage_Error vImageConvert_ARGBFFFFtoPlanarF(const vImage_Buffer *srcARGB, const vImage_Buffer *destA, const vImage_Buffer *destR, const vImage_Buffer *destG, const vImage_Buffer *destB, vImage_Flags flags)
{
  return MEMORY[0x270EDEFD0](srcARGB, destA, destR, destG, destB, *(void *)&flags);
}

vImage_Error vImageConvert_ARGBToYpCbCr_GenerateConversion(const vImage_ARGBToYpCbCrMatrix *matrix, const vImage_YpCbCrPixelRange *pixelRange, vImage_ARGBToYpCbCr *outInfo, vImageARGBType inARGBType, vImageYpCbCrType outYpCbCrType, vImage_Flags flags)
{
  return MEMORY[0x270EDEFD8](matrix, pixelRange, outInfo, *(void *)&inARGBType, *(void *)&outYpCbCrType, *(void *)&flags);
}

vImage_Error vImageConvert_ChunkyToPlanarF(const void *srcChannels[], const vImage_Buffer *destPlanarBuffers[], unsigned int channelCount, size_t srcStrideBytes, vImagePixelCount srcWidth, vImagePixelCount srcHeight, size_t srcRowBytes, vImage_Flags flags)
{
  return MEMORY[0x270EDF000](srcChannels, destPlanarBuffers, *(void *)&channelCount, srcStrideBytes, srcWidth, srcHeight, srcRowBytes, *(void *)&flags);
}

vImage_Error vImageConvert_Planar16FtoPlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x270EDF018](src, dest, *(void *)&flags);
}

vImage_Error vImageConvert_Planar8ToBGRX8888(const vImage_Buffer *blue, const vImage_Buffer *green, const vImage_Buffer *red, Pixel_8 alpha, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x270EDF040](blue, green, red, alpha, dest, *(void *)&flags);
}

vImage_Error vImageConvert_Planar8ToBGRXFFFF(const vImage_Buffer *blue, const vImage_Buffer *green, const vImage_Buffer *red, Pixel_F alpha, const vImage_Buffer *dest, const Pixel_FFFF maxFloat, const Pixel_FFFF minFloat, vImage_Flags flags)
{
  return MEMORY[0x270EDF048](blue, green, red, dest, maxFloat, minFloat, *(void *)&flags, alpha);
}

vImage_Error vImageConvert_Planar8ToXRGB8888(Pixel_8 alpha, const vImage_Buffer *red, const vImage_Buffer *green, const vImage_Buffer *blue, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x270EDF058](alpha, red, green, blue, dest, *(void *)&flags);
}

vImage_Error vImageConvert_Planar8ToXRGBFFFF(Pixel_F alpha, const vImage_Buffer *red, const vImage_Buffer *green, const vImage_Buffer *blue, const vImage_Buffer *dest, const Pixel_FFFF maxFloat, const Pixel_FFFF minFloat, vImage_Flags flags)
{
  return MEMORY[0x270EDF070](red, green, blue, dest, maxFloat, minFloat, *(void *)&flags, alpha);
}

vImage_Error vImageConvert_Planar8toPlanar16F(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x270EDF080](src, dest, *(void *)&flags);
}

vImage_Error vImageConvert_Planar8toPlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, Pixel_F maxFloat, Pixel_F minFloat, vImage_Flags flags)
{
  return MEMORY[0x270EDF098](src, dest, *(void *)&flags, maxFloat, minFloat);
}

vImage_Error vImageConvert_PlanarFToBGRX8888(const vImage_Buffer *blue, const vImage_Buffer *green, const vImage_Buffer *red, Pixel_8 alpha, const vImage_Buffer *dest, const Pixel_FFFF maxFloat, const Pixel_FFFF minFloat, vImage_Flags flags)
{
  return MEMORY[0x270EDF0B8](blue, green, red, alpha, dest, maxFloat, minFloat, *(void *)&flags);
}

vImage_Error vImageConvert_PlanarFToBGRXFFFF(const vImage_Buffer *blue, const vImage_Buffer *green, const vImage_Buffer *red, Pixel_F alpha, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x270EDF0C8](blue, green, red, dest, *(void *)&flags, alpha);
}

vImage_Error vImageConvert_PlanarFToXRGB8888(Pixel_8 alpha, const vImage_Buffer *red, const vImage_Buffer *green, const vImage_Buffer *blue, const vImage_Buffer *dest, const Pixel_FFFF maxFloat, const Pixel_FFFF minFloat, vImage_Flags flags)
{
  return MEMORY[0x270EDF0D0](alpha, red, green, blue, dest, maxFloat, minFloat, *(void *)&flags);
}

vImage_Error vImageConvert_PlanarFtoPlanar16F(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x270EDF0F0](src, dest, *(void *)&flags);
}

vImage_Error vImageConvert_YpCbCrToARGB_GenerateConversion(const vImage_YpCbCrToARGBMatrix *matrix, const vImage_YpCbCrPixelRange *pixelRange, vImage_YpCbCrToARGB *outInfo, vImageYpCbCrType inYpCbCrType, vImageARGBType outARGBType, vImage_Flags flags)
{
  return MEMORY[0x270EDF148](matrix, pixelRange, outInfo, *(void *)&inYpCbCrType, *(void *)&outARGBType, *(void *)&flags);
}

vImage_Error vImageCopyBuffer(const vImage_Buffer *src, const vImage_Buffer *dest, size_t pixelSize, vImage_Flags flags)
{
  return MEMORY[0x270EDF1A8](src, dest, pixelSize, *(void *)&flags);
}

vImage_Error vImagePermuteChannels_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x270EDF270](src, dest, permuteMap, *(void *)&flags);
}

vImage_Error vImagePermuteChannels_ARGBFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x270EDF280](src, dest, permuteMap, *(void *)&flags);
}

vImage_Error vImageRotate90_ARGB16U(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, const Pixel_ARGB_16U backColor, vImage_Flags flags)
{
  return MEMORY[0x270EDF298](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageRotate90_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, const Pixel_8888 backColor, vImage_Flags flags)
{
  return MEMORY[0x270EDF2B0](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageRotate90_ARGBFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, const Pixel_FFFF backColor, vImage_Flags flags)
{
  return MEMORY[0x270EDF2C0](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageRotate90_Planar16F(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, const Pixel_16F backColor, vImage_Flags flags)
{
  return MEMORY[0x270EDF2C8](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageRotate90_Planar16U(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_16U backColor, vImage_Flags flags)
{
  return MEMORY[0x270EDF2E0](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageRotate90_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_8 backColor, vImage_Flags flags)
{
  return MEMORY[0x270EDF2F0](src, dest, rotationConstant, backColor, *(void *)&flags);
}

vImage_Error vImageRotate90_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_F backColor, vImage_Flags flags)
{
  return MEMORY[0x270EDF2F8](src, dest, rotationConstant, *(void *)&flags, backColor);
}

vImage_Error vImageScale_ARGB16F(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x270EDF310](src, dest, tempBuffer, *(void *)&flags);
}

vImage_Error vImageScale_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x270EDF330](src, dest, tempBuffer, *(void *)&flags);
}

vImage_Error vImageScale_ARGBFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x270EDF338](src, dest, tempBuffer, *(void *)&flags);
}

vImage_Error vImageScale_CbCr8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x270EDF350](src, dest, tempBuffer, *(void *)&flags);
}

vImage_Error vImageScale_Planar16F(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x270EDF368](src, dest, tempBuffer, *(void *)&flags);
}

vImage_Error vImageScale_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x270EDF388](src, dest, tempBuffer, *(void *)&flags);
}

vImage_Error vImageScale_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x270EDF398](src, dest, tempBuffer, *(void *)&flags);
}