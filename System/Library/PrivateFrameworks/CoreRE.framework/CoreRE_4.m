uint64_t re::EncoderOPACK<re::SeekableInputStream>::readRaw(uint64_t a1, const char *a2, unsigned char *a3, size_t __n, uint64_t a5, char a6)
{
  size_t v10;
  size_t v11;
  int64_t v12;
  int64_t v13;
  char *v14;

  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  v10 = *(void *)(a1 + 168);
  if (v10)
  {
    if (v10 >= __n) {
      v11 = __n;
    }
    else {
      v11 = *(void *)(a1 + 168);
    }
    v12 = v10 - v11;
    if ((uint64_t)(v10 - 1) >= (uint64_t)(v10 - v11))
    {
      do
      {
        *a3++ = *(unsigned char *)(a1 + 159 + v10);
        v13 = v10 - 2;
        --v10;
      }
      while (v13 >= v12);
    }
    *(void *)(a1 + 168) = v12;
    __n -= v11;
  }
  if (__n)
  {
    v14 = (a6 & 1) != 0 ? 0 : a3;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v14, __n) & 1) == 0)
    {
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
      return 0;
    }
  }
  return 1;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readStringTag(uint64_t result, const char *a2, uint64_t *a3)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  uint64_t v5 = result;
  unsigned __int8 __dst = 0;
  uint64_t v6 = *(void *)(result + 168);
  if (v6)
  {
    uint64_t v7 = v6 - 1;
    result = *(unsigned __int8 *)(result + v7 + 160);
    unsigned __int8 __dst = *(unsigned char *)(v5 + v7 + 160);
    *(void *)(v5 + 168) = v7;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, (char *)&__dst, 1uLL) & 1) == 0)return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String"); {
    result = __dst;
    }
  }
  if ((result - 64) > 0x20)
  {
    switch((int)result)
    {
      case 'a':
        LOBYTE(v32) = 0;
        if (!*(unsigned char *)(v5 + 40))
        {
          uint64_t v8 = *(void *)(v5 + 168);
          if (v8)
          {
            uint64_t v9 = v8 - 1;
            LODWORD(v8) = *(unsigned __int8 *)(v5 + v8 - 1 + 160);
            *(void *)(v5 + 168) = v9;
          }
          else
          {
            result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, (char *)&v32, 1uLL);
            if (!result) {
              return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
            }
            LODWORD(v8) = v32;
          }
          uint64_t v8 = v8;
          goto LABEL_8;
        }
        return result;
      case 'b':
        LOWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v11 = *(void *)(v5 + 168);
        if (v11)
        {
          uint64_t v12 = 2;
          if (v11 < 2) {
            uint64_t v12 = *(void *)(v5 + 168);
          }
          int64_t v13 = v11 - v12;
          if ((uint64_t)(v11 - 1) >= (uint64_t)(v11 - v12))
          {
            v14 = (char *)&v32;
            uint64_t v26 = *(void *)(v5 + 168);
            do
            {
              *v14++ = *(unsigned char *)(v5 + 159 + v26);
              int64_t v27 = v26 - 2;
              --v26;
            }
            while (v27 >= v13);
          }
          else
          {
            v14 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v13;
          if (v11 > 1)
          {
LABEL_43:
            uint64_t v8 = (unsigned __int16)v32;
            goto LABEL_8;
          }
          size_t v25 = 2 - v12;
        }
        else
        {
          v14 = (char *)&v32;
          size_t v25 = 2;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v14, v25);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
        }
        goto LABEL_43;
      case 'c':
        LODWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v15 = *(void *)(v5 + 168);
        if (v15)
        {
          uint64_t v16 = 4;
          if (v15 < 4) {
            uint64_t v16 = *(void *)(v5 + 168);
          }
          int64_t v17 = v15 - v16;
          if ((uint64_t)(v15 - 1) >= (uint64_t)(v15 - v16))
          {
            v18 = (char *)&v32;
            uint64_t v28 = *(void *)(v5 + 168);
            do
            {
              *v18++ = *(unsigned char *)(v5 + 159 + v28);
              int64_t v29 = v28 - 2;
              --v28;
            }
            while (v29 >= v17);
          }
          else
          {
            v18 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v17;
          if (v15 > 3) {
            goto LABEL_49;
          }
          size_t v23 = 4 - v16;
        }
        else
        {
          v18 = (char *)&v32;
          size_t v23 = 4;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v18, v23);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
        }
LABEL_49:
        uint64_t v8 = v32;
        goto LABEL_8;
      case 'd':
        uint64_t v32 = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v19 = *(void *)(v5 + 168);
        if (v19)
        {
          uint64_t v20 = 8;
          if (v19 < 8) {
            uint64_t v20 = *(void *)(v5 + 168);
          }
          int64_t v21 = v19 - v20;
          if ((uint64_t)(v19 - 1) >= (uint64_t)(v19 - v20))
          {
            v22 = (char *)&v32;
            uint64_t v30 = *(void *)(v5 + 168);
            do
            {
              *v22++ = *(unsigned char *)(v5 + 159 + v30);
              int64_t v31 = v30 - 2;
              --v30;
            }
            while (v31 >= v21);
          }
          else
          {
            v22 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v21;
          if (v19 > 7) {
            goto LABEL_55;
          }
          size_t v24 = 8 - v20;
        }
        else
        {
          v22 = (char *)&v32;
          size_t v24 = 8;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v22, v24);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
        }
LABEL_55:
        uint64_t v8 = v32;
        goto LABEL_8;
      default:
        v10 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"String", (uint64_t)v10);
    }
  }
  uint64_t v8 = result - 64;
LABEL_8:
  *a3 = v8;
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readDataTag(uint64_t result, const char *a2, uint64_t *a3)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  uint64_t v5 = result;
  unsigned __int8 __dst = 0;
  uint64_t v6 = *(void *)(result + 168);
  if (v6)
  {
    uint64_t v7 = v6 - 1;
    result = *(unsigned __int8 *)(result + v7 + 160);
    unsigned __int8 __dst = *(unsigned char *)(v5 + v7 + 160);
    *(void *)(v5 + 168) = v7;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, (char *)&__dst, 1uLL) & 1) == 0)return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB"); {
    result = __dst;
    }
  }
  if ((result - 112) > 0x20)
  {
    switch((int)result)
    {
      case 145:
        LOBYTE(v32) = 0;
        if (!*(unsigned char *)(v5 + 40))
        {
          uint64_t v8 = *(void *)(v5 + 168);
          if (v8)
          {
            uint64_t v9 = v8 - 1;
            LODWORD(v8) = *(unsigned __int8 *)(v5 + v8 - 1 + 160);
            *(void *)(v5 + 168) = v9;
          }
          else
          {
            result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, (char *)&v32, 1uLL);
            if (!result) {
              return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
            }
            LODWORD(v8) = v32;
          }
          uint64_t v8 = v8;
          goto LABEL_8;
        }
        return result;
      case 146:
        LOWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v11 = *(void *)(v5 + 168);
        if (v11)
        {
          uint64_t v12 = 2;
          if (v11 < 2) {
            uint64_t v12 = *(void *)(v5 + 168);
          }
          int64_t v13 = v11 - v12;
          if ((uint64_t)(v11 - 1) >= (uint64_t)(v11 - v12))
          {
            v14 = (char *)&v32;
            uint64_t v26 = *(void *)(v5 + 168);
            do
            {
              *v14++ = *(unsigned char *)(v5 + 159 + v26);
              int64_t v27 = v26 - 2;
              --v26;
            }
            while (v27 >= v13);
          }
          else
          {
            v14 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v13;
          if (v11 > 1)
          {
LABEL_43:
            uint64_t v8 = (unsigned __int16)v32;
            goto LABEL_8;
          }
          size_t v25 = 2 - v12;
        }
        else
        {
          v14 = (char *)&v32;
          size_t v25 = 2;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v14, v25);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
        }
        goto LABEL_43;
      case 147:
        LODWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v15 = *(void *)(v5 + 168);
        if (v15)
        {
          uint64_t v16 = 4;
          if (v15 < 4) {
            uint64_t v16 = *(void *)(v5 + 168);
          }
          int64_t v17 = v15 - v16;
          if ((uint64_t)(v15 - 1) >= (uint64_t)(v15 - v16))
          {
            v18 = (char *)&v32;
            uint64_t v28 = *(void *)(v5 + 168);
            do
            {
              *v18++ = *(unsigned char *)(v5 + 159 + v28);
              int64_t v29 = v28 - 2;
              --v28;
            }
            while (v29 >= v17);
          }
          else
          {
            v18 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v17;
          if (v15 > 3) {
            goto LABEL_49;
          }
          size_t v23 = 4 - v16;
        }
        else
        {
          v18 = (char *)&v32;
          size_t v23 = 4;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v18, v23);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
        }
LABEL_49:
        uint64_t v8 = v32;
        goto LABEL_8;
      case 148:
        uint64_t v32 = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v19 = *(void *)(v5 + 168);
        if (v19)
        {
          uint64_t v20 = 8;
          if (v19 < 8) {
            uint64_t v20 = *(void *)(v5 + 168);
          }
          int64_t v21 = v19 - v20;
          if ((uint64_t)(v19 - 1) >= (uint64_t)(v19 - v20))
          {
            v22 = (char *)&v32;
            uint64_t v30 = *(void *)(v5 + 168);
            do
            {
              *v22++ = *(unsigned char *)(v5 + 159 + v30);
              int64_t v31 = v30 - 2;
              --v30;
            }
            while (v31 >= v21);
          }
          else
          {
            v22 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v21;
          if (v19 > 7) {
            goto LABEL_55;
          }
          size_t v24 = 8 - v20;
        }
        else
        {
          v22 = (char *)&v32;
          size_t v24 = 8;
        }
        result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v22, v24);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
        }
LABEL_55:
        uint64_t v8 = v32;
        goto LABEL_8;
      default:
        v10 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"BLOB", (uint64_t)v10);
    }
  }
  uint64_t v8 = result - 112;
LABEL_8:
  *a3 = v8;
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readArrayTag(uint64_t result, const char *a2, char *__dst)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v5 = (void *)result;
    unsigned __int8 __dsta = 0;
    uint64_t v6 = *(void *)(result + 168);
    if (v6)
    {
      uint64_t v7 = v6 - 1;
      result = *(unsigned __int8 *)(result + v7 + 160);
      unsigned __int8 __dsta = *((unsigned char *)v5 + v7 + 160);
      v5[21] = v7;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, (char *)&__dsta, 1uLL) & 1) == 0)return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Array"); {
      result = __dsta;
      }
    }
    if ((result + 48) > 0xEu)
    {
      if (result == 223)
      {
        return re::EncoderOPACK<re::SeekableInputStream>::readUint64((uint64_t)v5, a2, __dst);
      }
      else
      {
        uint64_t v8 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"Array", (uint64_t)v8);
      }
    }
    else
    {
      *(void *)unsigned __int8 __dst = result - 208;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readDictionaryTag(uint64_t result, const char *a2, char *__dst)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v5 = result;
    unsigned __int8 __dsta = 0;
    uint64_t v6 = *(void *)(result + 168);
    if (v6)
    {
      uint64_t v7 = v6 - 1;
      result = *(unsigned __int8 *)(result + v7 + 160);
      unsigned __int8 __dsta = *(unsigned char *)(v5 + v7 + 160);
      *(void *)(v5 + 168) = v7;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, (char *)&__dsta, 1uLL) & 1) == 0)return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Dictionary"); {
      result = __dsta;
      }
    }
    if ((result + 32) <= 0xEu)
    {
      *(void *)unsigned __int8 __dst = result - 224;
      return result;
    }
    if (result != 210) {
      goto LABEL_17;
    }
    result = re::EncoderOPACK<re::SeekableInputStream>::readUint64(v5, a2, __dst);
    if (!result || *(unsigned char *)(v5 + 40)) {
      return result;
    }
    uint64_t v8 = *(void *)(v5 + 168);
    if (v8)
    {
      uint64_t v9 = v8 - 1;
      result = *(unsigned __int8 *)(v5 + v9 + 160);
      unsigned __int8 __dsta = *(unsigned char *)(v5 + v9 + 160);
      *(void *)(v5 + 168) = v9;
      goto LABEL_16;
    }
    if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, (char *)&__dsta, 1uLL))
    {
      result = __dsta;
LABEL_16:
      if (result == 239) {
        return result;
      }
LABEL_17:
      v10 = re::OPACK::toString(result);
      return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"Dictionary", (uint64_t)v10);
    }
    return re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Dictionary");
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readUint64(uint64_t a1, const char *a2, char *__dst)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  unsigned __int8 __dsta = 0;
  uint64_t v7 = *(void *)(a1 + 168);
  if (v7)
  {
    uint64_t v8 = v7 - 1;
    int v9 = *(unsigned __int8 *)(a1 + v7 - 1 + 160);
    unsigned __int8 __dsta = v9;
    *(void *)(a1 + 168) = v8;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dsta, 1uLL) & 1) == 0)
    {
LABEL_25:
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"UInt64");
      return 0;
    }
    int v9 = __dsta;
  }
  if (v9 != 120)
  {
    unint64_t v16 = *(void *)(a1 + 168);
    if (v16 <= 7)
    {
      *(void *)(a1 + 168) = v16 + 1;
      *(unsigned char *)(a1 + v16 + 160) = v9;
    }
    uint64_t v18 = 0;
    if ((re::EncoderOPACK<re::SeekableInputStream>::readInteger(a1, a2, (char *)&v18, (uint64_t)"Int64") & 1) == 0) {
      return 0;
    }
    *(void *)unsigned __int8 __dst = v18;
    return 1;
  }
  if (!*(unsigned char *)(a1 + 40))
  {
    unint64_t v10 = *(void *)(a1 + 168);
    if (v10)
    {
      uint64_t v11 = 8;
      if (v10 < 8) {
        uint64_t v11 = *(void *)(a1 + 168);
      }
      int64_t v12 = v10 - v11;
      if ((uint64_t)(v10 - 1) >= (uint64_t)(v10 - v11))
      {
        uint64_t v13 = *(void *)(a1 + 168);
        do
        {
          *__dst++ = *(unsigned char *)(a1 + 159 + v13);
          int64_t v14 = v13 - 2;
          --v13;
        }
        while (v14 >= v12);
      }
      *(void *)(a1 + 168) = v12;
      if (v10 > 7) {
        return 1;
      }
      size_t v15 = 8 - v11;
    }
    else
    {
      size_t v15 = 8;
    }
    if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, __dst, v15))return 1; {
    goto LABEL_25;
    }
  }
  return 0;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readInteger(uint64_t a1, const char *a2, char *__dst, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  unsigned __int8 __dsta = 0;
  uint64_t v9 = *(void *)(a1 + 168);
  if (v9)
  {
    uint64_t v10 = v9 - 1;
    unsigned int v11 = *(unsigned __int8 *)(a1 + v10 + 160);
    unsigned __int8 __dsta = *(unsigned char *)(a1 + v10 + 160);
    *(void *)(a1 + 168) = v10;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dsta, 1uLL) & 1) == 0)
    {
      int64_t v14 = (_anonymous_namespace_ *)a1;
      size_t v15 = a2;
      unint64_t v16 = (const char *)a4;
      goto LABEL_17;
    }
    unsigned int v11 = __dsta;
  }
  if (v11 - 7 > 0x28)
  {
    switch(v11)
    {
      case '0':
        uint64_t result = 0;
        char v40 = 0;
        if (*(unsigned char *)(a1 + 40)) {
          return result;
        }
        uint64_t v12 = *(void *)(a1 + 168);
        if (v12)
        {
          uint64_t v13 = v12 - 1;
          LOBYTE(v12) = *(unsigned char *)(a1 + v12 - 1 + 160);
          *(void *)(a1 + 168) = v13;
LABEL_46:
          uint64_t v12 = (char)v12;
          goto LABEL_10;
        }
        if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, &v40, 1uLL))
        {
          LOBYTE(v12) = v40;
          goto LABEL_46;
        }
        unint64_t v16 = "8-Bit Signed Integer";
        goto LABEL_63;
      case '1':
        uint64_t result = 0;
        __int16 v39 = 0;
        if (*(unsigned char *)(a1 + 40)) {
          return result;
        }
        unint64_t v18 = *(void *)(a1 + 168);
        if (v18)
        {
          uint64_t v19 = 2;
          if (v18 < 2) {
            uint64_t v19 = *(void *)(a1 + 168);
          }
          int64_t v20 = v18 - v19;
          if ((uint64_t)(v18 - 1) >= (uint64_t)(v18 - v19))
          {
            int64_t v21 = (char *)&v39;
            uint64_t v34 = *(void *)(a1 + 168);
            do
            {
              *v21++ = *(unsigned char *)(a1 + 159 + v34);
              int64_t v35 = v34 - 2;
              --v34;
            }
            while (v35 >= v20);
          }
          else
          {
            int64_t v21 = (char *)&v39;
          }
          *(void *)(a1 + 168) = v20;
          if (v18 > 1) {
            goto LABEL_53;
          }
          size_t v33 = 2 - v19;
        }
        else
        {
          int64_t v21 = (char *)&v39;
          size_t v33 = 2;
        }
        if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v21, v33))
        {
LABEL_53:
          uint64_t v12 = v39;
          goto LABEL_10;
        }
        unint64_t v16 = "16-Bit Signed Integer";
        goto LABEL_63;
      case '2':
        uint64_t result = 0;
        int v38 = 0;
        if (*(unsigned char *)(a1 + 40)) {
          return result;
        }
        unint64_t v22 = *(void *)(a1 + 168);
        if (v22)
        {
          uint64_t v23 = 4;
          if (v22 < 4) {
            uint64_t v23 = *(void *)(a1 + 168);
          }
          int64_t v24 = v22 - v23;
          if ((uint64_t)(v22 - 1) >= (uint64_t)(v22 - v23))
          {
            size_t v25 = (char *)&v38;
            uint64_t v36 = *(void *)(a1 + 168);
            do
            {
              *v25++ = *(unsigned char *)(a1 + 159 + v36);
              int64_t v37 = v36 - 2;
              --v36;
            }
            while (v37 >= v24);
          }
          else
          {
            size_t v25 = (char *)&v38;
          }
          *(void *)(a1 + 168) = v24;
          if (v22 > 3) {
            goto LABEL_60;
          }
          size_t v32 = 4 - v23;
        }
        else
        {
          size_t v25 = (char *)&v38;
          size_t v32 = 4;
        }
        if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v25, v32))
        {
LABEL_60:
          uint64_t v12 = v38;
          goto LABEL_10;
        }
        unint64_t v16 = "32-Bit Signed Integer";
LABEL_63:
        int64_t v14 = (_anonymous_namespace_ *)a1;
        size_t v15 = a2;
        break;
      case '3':
        if (*(unsigned char *)(a1 + 40)) {
          return 0;
        }
        unint64_t v26 = *(void *)(a1 + 168);
        if (v26)
        {
          uint64_t v27 = 8;
          if (v26 < 8) {
            uint64_t v27 = *(void *)(a1 + 168);
          }
          int64_t v28 = v26 - v27;
          if ((uint64_t)(v26 - 1) >= (uint64_t)(v26 - v27))
          {
            uint64_t v29 = *(void *)(a1 + 168);
            do
            {
              *__dst++ = *(unsigned char *)(a1 + 159 + v29);
              int64_t v30 = v29 - 2;
              --v29;
            }
            while (v30 >= v28);
          }
          *(void *)(a1 + 168) = v28;
          if (v26 > 7) {
            return 1;
          }
          size_t v31 = 8 - v27;
        }
        else
        {
          size_t v31 = 8;
        }
        if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, __dst, v31))return 1; {
        unint64_t v16 = "64-Bit Signed Integer";
        }
        goto LABEL_63;
      default:
        int64_t v17 = re::OPACK::toString(v11);
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, a4, (uint64_t)v17);
        return 0;
    }
LABEL_17:
    re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v14, v15, (uint64_t)v16);
    return 0;
  }
  uint64_t v12 = v11 - 8;
LABEL_10:
  *(void *)unsigned __int8 __dst = v12;
  return 1;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<int>(_anonymous_namespace_ *a1, const char *a2, _DWORD *a3)
{
  uint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"Int32");
  if (result)
  {
    if (__dst == (int)__dst)
    {
      *a3 = __dst;
      return 1;
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "Int32", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      char v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<signed char>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<signed char>(_anonymous_namespace_ *a1, const char *a2, unsigned char *a3)
{
  uint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"Int8");
  if (result)
  {
    if (__dst == (char)__dst)
    {
      *a3 = __dst;
      return 1;
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "Int8", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<short>(uint64_t a1, const char *a2, int a3, __int16 *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      __int16 v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<short>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<short>(_anonymous_namespace_ *a1, const char *a2, _WORD *a3)
{
  uint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"Int16");
  if (result)
  {
    if (__dst == (__int16)__dst)
    {
      *a3 = __dst;
      return 1;
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "Int16", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<int>(uint64_t a1, const char *a2, int a3, int *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      int v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<int>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<long long>(uint64_t a1, const char *a2, int a3, void *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v14 = 0;
  uint64_t v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v14, 0);
  if (v5)
  {
    if (a5)
    {
      uint64_t __dst = 0;
      re::EncoderOPACK<re::SeekableInputStream>::readInteger(a1, a2, (char *)&__dst, (uint64_t)"Int64");
    }
    else
    {
      uint64_t __dst = 0;
      if (re::EncoderOPACK<re::SeekableInputStream>::readInteger(a1, a2, (char *)&__dst, (uint64_t)"Int64"))*a4 = __dst; {
    }
      }
    for (uint64_t i = v14; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v11 = *(void *)(a1 + 128);
      uint64_t v12 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v11 + 48 * v12) != 2) {
        ++*(void *)(v11 + 48 * v12 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned char>(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      char v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned char>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned char>(_anonymous_namespace_ *a1, const char *a2, unsigned char *a3)
{
  unint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"UInt8");
  if (result)
  {
    if (__dst > 0xFF)
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "UInt8", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
    else
    {
      *a3 = __dst;
      return 1;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned short>(uint64_t a1, const char *a2, int a3, __int16 *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      __int16 v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned short>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned short>(_anonymous_namespace_ *a1, const char *a2, _WORD *a3)
{
  unint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"UInt16");
  if (result)
  {
    if (__dst >> 16)
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "UInt16", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
    else
    {
      *a3 = __dst;
      return 1;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned int>(uint64_t a1, const char *a2, int a3, int *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      int v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned int>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned int>(_anonymous_namespace_ *a1, const char *a2, _DWORD *a3)
{
  unint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"UInt32");
  if (result)
  {
    if (HIDWORD(__dst))
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "UInt32", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
    else
    {
      *a3 = __dst;
      return 1;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      uint64_t v17 = 0;
      uint64_t v12 = (char *)&v17;
      uint64_t v10 = a1;
      uint64_t v11 = a2;
    }
    else
    {
      uint64_t v10 = a1;
      uint64_t v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::SeekableInputStream>::readUint64(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::SeekableInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::internal::serializeEnumAsBinary<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re::internal *a5, re::internal *a6, int a7)
{
  if (a7)
  {
    uint64_t v11 = *(re::internal **)(a1 + 208);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v11, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (!*(unsigned char *)(a1 + 64)) {
      return (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, void, uint64_t *, uint64_t *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, 0, &__src, &__src, 1);
    }
    return 0;
  }
  uint64_t v15 = *(void **)a5;
  if (a5 == a6) {
    goto LABEL_8;
  }
  if (v15 == *(void **)a6)
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v17 = (uint64_t *)*((void *)a6 + 2);
    uint64_t v18 = *v17;
    if ((unsigned __int16)v16 == (unsigned __int16)*v17)
    {
      BOOL v20 = WORD1(v16) == WORD1(v18);
      uint64_t v19 = (v18 ^ v16) & 0xFFFFFF00000000;
      BOOL v20 = v20 && v19 == 0;
      if (v20) {
        goto LABEL_8;
      }
    }
LABEL_21:
    uint64_t v23 = *(re::internal **)(a1 + 208);
    re::TypeRegistry::typeInfo(v15, v17[9], &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v23, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (*(_DWORD *)(v58[1] + 8) < 9u)
    {
      uint64_t v55 = 0;
      if (!*(unsigned char *)(a1 + 64)
        && (*(unsigned int (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, uint64_t *, uint64_t *, void))(*(void *)a1 + 72))(a1, a2, a3, &v55, &__src, &__src, 0))
      {
        unsigned int EnumConstantIndex = re::internal::getEnumConstantIndex(a6, (const re::TypeInfo *)&v55, v29);
        if ((EnumConstantIndex & 0x80000000) != 0)
        {
          char v41 = v55;
          re::TypeInfo::name(a6);
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v42, v43, v44, v45, v46, v41);
        }
        else
        {
          unsigned int v31 = EnumConstantIndex;
          size_t v32 = *(re::internal::TypeTranslationTable **)(*(void *)a6 + 856);
          if (v32)
          {
            size_t v33 = (const void *)re::internal::TypeTranslationTable::translateSerializedEnum(v32, a6, v31, a5);
            if (v33)
            {
              memcpy(a4, v33, *(unsigned int *)(*((void *)a5 + 2) + 8));
              int v34 = 0;
              return v34 == 0;
            }
          }
          v56[0] = re::TypeInfo::enumConstants(a6);
          v56[1] = v47;
          uint64_t v48 = *(void *)(re::Slice<re::EnumConstant>::operator[](v56, v31) + 16);
          re::TypeInfo::name(a5);
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Serialized enum constant \"%s\" does not exist in runtime type \"%s\".", v49, v50, v51, v52, v53, v48);
        }
      }
    }
    else
    {
      uint64_t v54 = re::TypeInfo::name((re::TypeInfo *)&__src)[1];
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Enum type \"%s\" has invalid size: %zu bytes.", v24, v25, v26, v27, v28, v54);
    }
    int v34 = 1;
    return v34 == 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
  {
    uint64_t v15 = *(void **)a6;
    uint64_t v17 = (uint64_t *)*((void *)a6 + 2);
    goto LABEL_21;
  }
  uint64_t v15 = *(void **)a5;
LABEL_8:
  re::TypeRegistry::typeInfo(v15, *(void *)(*((void *)a5 + 2) + 72), &__src);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
  uint64_t __src = 0;
  if (*(unsigned char *)(a1 + 64)) {
    return 0;
  }
  int v22 = (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, void *, void *, void))(*(void *)a1 + 72))(a1, a2, a3, &__src, v56, v56, 0);
  uint64_t result = 0;
  if (v22)
  {
    if ((re::internal::getEnumConstantIndex(a5, (const re::TypeInfo *)&__src, v21) & 0x80000000) != 0)
    {
      char v35 = __src;
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v36, v37, v38, v39, v40, v35);
      return 0;
    }
    memcpy(a4, &__src, *(unsigned int *)(*((void *)a5 + 2) + 8));
    return 1;
  }
  return result;
}

double re::EncoderOPACK<re::SeekableInputStream>::beginOptional(uint64_t a1, const char *a2, int a3, unsigned char *a4, int a5)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    uint64_t v22 = 0;
    if (re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v22, 0))
    {
      unsigned __int8 __dst = 0;
      if (*(unsigned char *)(a1 + 40))
      {
LABEL_4:
        uint64_t v9 = *a4;
        LOBYTE(v15) = 3;
        DWORD1(v15) = a5;
        *((void *)&v15 + 1) = a2;
        uint64_t v16 = 0;
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        uint64_t v17 = v9;
        double result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v15);
        *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v22;
        return result;
      }
      uint64_t v11 = *(void *)(a1 + 168);
      if (v11)
      {
        uint64_t v12 = v11 - 1;
        int v13 = *(unsigned __int8 *)(a1 + v11 - 1 + 160);
        *(void *)(a1 + 168) = v12;
      }
      else
      {
        if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL) & 1) == 0)
        {
          re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Optional");
          goto LABEL_4;
        }
        int v13 = __dst;
      }
      if (v13 == 4)
      {
        *a4 = 0;
      }
      else
      {
        *a4 = 1;
        unint64_t v14 = *(void *)(a1 + 168);
        if (v14 <= 7)
        {
          *(void *)(a1 + 168) = v14 + 1;
          *(unsigned char *)(a1 + v14 + 160) = v13;
        }
      }
      goto LABEL_4;
    }
    *a4 = 0;
    LOBYTE(v21[0]) = 3;
    DWORD1(v21[0]) = a5;
    *((void *)&v21[0] + 1) = a2;
    memset(&v21[1], 0, 32);
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, v21);
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endOptional(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      double result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 3);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if (v10) {
        uint64_t v7 = *(unsigned char **)&v11[7];
      }
      else {
        uint64_t v7 = v11;
      }
      if (*(uint64_t *)(*((void *)v1 + 16) + 48 * *((void *)v1 + 14) - 24) <= 0) {
        uint64_t v8 = "Optional should not have a value.";
      }
      else {
        uint64_t v8 = "Optional requires a value.";
      }
      re::DynamicString::format((re::DynamicString *)"Failed to serialize optional type \"%s\". %s", (re::DynamicString *)v12, v7, v8);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(void *)&v12[0])
      {
        if (BYTE8(v12[0])) {
          (*(void (**)(void))(**(void **)&v12[0] + 40))();
        }
        memset(v12, 0, sizeof(v12));
      }
      double result = v9;
      if (v9 && (v10 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v9 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginBLOB(uint64_t a1, const char *a2, int a3, uint64_t *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v16, 0);
  if (result)
  {
    re::EncoderOPACK<re::SeekableInputStream>::readDataTag(a1, a2, a4);
    uint64_t v10 = *a4;
    LOBYTE(v11) = 4;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeBLOB(uint64_t result, char *a2, char a3)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  v4 = (_anonymous_namespace_ *)result;
  uint64_t v5 = *(void *)(result + 128) + 48 * *(void *)(result + 112);
  unint64_t v6 = *(void *)(v5 - 24);
  unint64_t v7 = *(void *)(result + 168);
  if (v7)
  {
    if (v7 >= v6) {
      uint64_t v8 = *(void *)(v5 - 24);
    }
    else {
      uint64_t v8 = *(void *)(result + 168);
    }
    uint64_t v9 = v7 - v8;
    if ((uint64_t)(v7 - 1) >= (uint64_t)(v7 - v8))
    {
      do
      {
        *a2++ = *(unsigned char *)(result + 159 + v7);
        uint64_t v10 = v7 - 2;
        --v7;
      }
      while (v10 >= v9);
    }
    *(void *)(result + 168) = v9;
    size_t v11 = v6 - v8;
    if (v6 == v8) {
      goto LABEL_15;
    }
    goto LABEL_11;
  }
  size_t v11 = *(void *)(v5 - 24);
  if (v6)
  {
LABEL_11:
    if (a3) {
      a2 = 0;
    }
    uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, a2, v11);
    if ((result & 1) == 0) {
      uint64_t result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v4, 0, (uint64_t)"BLOB");
    }
  }
LABEL_15:
  if ((a3 & 2) == 0)
  {
    uint64_t v12 = *((void *)v4 + 16);
    uint64_t v13 = *((void *)v4 + 14) - 1;
    if (*(unsigned char *)(v12 + 48 * v13) != 2) {
      *(void *)(v12 + 48 * v13 + 32) += v6;
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endBLOB(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 4);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if (v10) {
        unint64_t v7 = *(unsigned char **)&v11[7];
      }
      else {
        unint64_t v7 = v11;
      }
      uint64_t v8 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize BLOB \"%s\". Expected number of bytes: %lld. Actual number of bytes: %lld.", (re::DynamicString *)v12, v7, *(void *)(v8 - 24), *(void *)(v8 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(void *)&v12[0])
      {
        if (BYTE8(v12[0])) {
          (*(void (**)(void))(**(void **)&v12[0] + 40))();
        }
        memset(v12, 0, sizeof(v12));
      }
      uint64_t result = v9;
      if (v9 && (v10 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v9 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginArray(uint64_t a1, const char *a2, int a3, char *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v16, 0);
  if (result)
  {
    re::EncoderOPACK<re::SeekableInputStream>::readArrayTag(a1, a2, a4);
    uint64_t v10 = *(void *)a4;
    LOBYTE(v11) = 5;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endArray(_anonymous_namespace_ *result)
{
  if (*((unsigned char *)result + 40)) {
    return result;
  }
  v1 = result;
  uint64_t v2 = *((void *)result + 16);
  uint64_t v3 = *((void *)result + 14) - 1;
  unint64_t v4 = *(void *)(v2 + 48 * v3 + 32);
  if (v4 == *(void *)(v2 + 48 * v3 + 24))
  {
    if (v4 < 0xF)
    {
LABEL_22:
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 5);
      uint64_t v12 = *((void *)v1 + 16);
      uint64_t v13 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v12 + 48 * v13) != 2) {
        ++*(void *)(v12 + 48 * v13 + 32);
      }
      return result;
    }
    LOBYTE(__dst[0]) = 0;
    uint64_t v5 = *((void *)result + 21);
    if (v5)
    {
      uint64_t v6 = v5 - 1;
      int v7 = *((unsigned __int8 *)result + v6 + 160);
      LOBYTE(__dst[0]) = v7;
      *((void *)v1 + 21) = v6;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>(result, (char *)__dst, 1uLL))
      {
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v1, 0, (uint64_t)"Array");
LABEL_21:
        uint64_t v2 = *((void *)v1 + 16);
        uint64_t v3 = *((void *)v1 + 14) - 1;
        goto LABEL_22;
      }
      int v7 = LOBYTE(__dst[0]);
    }
    if (v7 != 3)
    {
      uint64_t v10 = re::OPACK::toString(v7);
      return (_anonymous_namespace_ *)re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag(v1, (uint64_t)"Array", (uint64_t)v10);
    }
    goto LABEL_21;
  }
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v14);
  if (v15) {
    uint64_t v8 = *(unsigned char **)&v16[7];
  }
  else {
    uint64_t v8 = v16;
  }
  uint64_t v9 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)__dst, v8, *(void *)(v9 - 24), *(void *)(v9 - 16));
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)__dst);
  if (*(void *)&__dst[0])
  {
    if (BYTE8(__dst[0])) {
      (*(void (**)(void))(**(void **)&__dst[0] + 40))();
    }
    memset(__dst, 0, sizeof(__dst));
  }
  uint64_t result = v14;
  if (v14 && (v15 & 1) != 0) {
    return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v14 + 40))();
  }
  return result;
}

uint64_t re::anonymous namespace'::resizeArray<re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>>(uint64_t a1, void **a2, re::ArrayAccessor *a3, uint64_t a4, const re::TypeInfo *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((const re::TypeInfo *)a4 == a5) {
    return 1;
  }
  v25[10] = v8;
  v25[11] = v9;
  uint64_t v14 = *((void *)a3 + 2);
  if ((*(_DWORD *)(v14 + 84) & 0xFFFFFF) != 0)
  {
    re::TypeRegistry::typeInfo(*(void **)a3, *(void *)(v14 + 72), v24);
    re::TypeInfo::TypeInfo((uint64_t)v22, (uint64_t)v25);
    BOOL v21 = !is_mul_ok(*(unsigned int *)(v23 + 8), (unint64_t)a5);
    if (is_mul_ok(*(unsigned int *)(v23 + 8), (unint64_t)a5)) {
      re::ArrayAccessor::reset(a3, a2, *(re::Allocator **)(a1 + 48), a5);
    }
    else {
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Size overflow during deserialization. Element size = %zu, count = %zu", v16, v17, v18, v19, v20, *(_DWORD *)(v23 + 8));
    }
    return !v21;
  }
  else
  {
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid array size. Expected size = %zu, actual size = %zu", a4, (uint64_t)a5, a6, a7, a8, a4);
    return 0;
  }
}

uint64_t re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::setError(_anonymous_namespace_ *a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  re::DynamicString::setCapacity(&v23, 0);
  uint64_t v22 = &a9;
  re::DynamicString::vassignf((re::DynamicString *)&v23, a3, &a9);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v15);
  if (v16) {
    uint64_t v12 = *(unsigned char **)&v17[7];
  }
  else {
    uint64_t v12 = v17;
  }
  if (v24) {
    uint64_t v13 = v25;
  }
  else {
    uint64_t v13 = (char *)&v24 + 1;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: %s", (re::DynamicString *)&v18, "deserialize", v12, v13);
  *(void *)&v21[0] = 400;
  *((void *)&v21[0] + 1) = re::FoundationErrorCategory(void)::instance;
  *(void *)&v21[1] = v18;
  *((void *)&v21[2] + 1) = v20;
  *(long long *)((char *)&v21[1] + 8) = v19;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, v21);
  if (*(void *)&v21[1])
  {
    if (BYTE8(v21[1])) {
      (*(void (**)(void))(**(void **)&v21[1] + 40))();
    }
    memset(&v21[1], 0, 32);
  }
  if (v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t result = (uint64_t)v23;
  if (v23)
  {
    if (v24) {
      return (*(uint64_t (**)(void))(*v23 + 40))();
    }
  }
  return result;
}

uint64_t re::anonymous namespace'::resizeList<re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a4 == a5) {
    return 1;
  }
  v23[10] = v5;
  v23[11] = v6;
  re::TypeRegistry::typeInfo(*(void **)a3, *(void *)(*(void *)(a3 + 16) + 72), v22);
  re::TypeInfo::TypeInfo((uint64_t)v20, (uint64_t)v23);
  BOOL v17 = !is_mul_ok(*(unsigned int *)(v21 + 8), a5);
  if (is_mul_ok(*(unsigned int *)(v21 + 8), a5))
  {
    uint64_t v18 = *(void *)(a1 + 48);
    long long v19 = *(void (**)(uint64_t, unsigned char *, uint64_t, unint64_t))(*(void *)(a3 + 16) + 88);
    re::TypeInfo::TypeInfo((uint64_t)v22, a3);
    v19(a2, v22, v18, a5);
  }
  else
  {
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Size overflow during deserialization. Element size = %zu, count = %zu", v12, v13, v14, v15, v16, *(_DWORD *)(v21 + 8));
  }
  return !v17;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginDictionary(uint64_t a1, const char *a2, int a3, char *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v16, 0);
  if (result)
  {
    re::EncoderOPACK<re::SeekableInputStream>::readDictionaryTag(a1, a2, a4);
    uint64_t v10 = *(void *)a4;
    LOBYTE(v11) = 6;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endDictionaryEntry(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = (uint64_t)result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == 2)
    {
      uint64_t result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 7);
      uint64_t v2 = *(void *)(v1 + 128);
      uint64_t v3 = *(void *)(v1 + 112) - 1;
      if (*(unsigned char *)(v2 + 48 * v3) != 2) {
        ++*(void *)(v2 + 48 * v3 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if (v6) {
        unint64_t v4 = *(unsigned char **)&v7[7];
      }
      else {
        unint64_t v4 = v7;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary entry \"%s\". Expected 2 objects (key+value). Actual number of objects: %lld.", (re::DynamicString *)v8, v4, *(void *)(*(void *)(v1 + 128) + 48 * *(void *)(v1 + 112) - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(void *)&v8[0])
      {
        if (BYTE8(v8[0])) {
          (*(void (**)(void))(**(void **)&v8[0] + 40))();
        }
        memset(v8, 0, sizeof(v8));
      }
      uint64_t result = v5;
      if (v5 && (v6 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v5 + 40))();
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endDictionary(_anonymous_namespace_ *result)
{
  if (*((unsigned char *)result + 40)) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t v2 = *((void *)result + 16);
  uint64_t v3 = *((void *)result + 14) - 1;
  unint64_t v4 = *(void *)(v2 + 48 * v3 + 32);
  if (v4 == *(void *)(v2 + 48 * v3 + 24))
  {
    if (v4 < 0xF)
    {
LABEL_22:
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 6);
      uint64_t v12 = *((void *)v1 + 16);
      uint64_t v13 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v12 + 48 * v13) != 2) {
        ++*(void *)(v12 + 48 * v13 + 32);
      }
      return result;
    }
    LOBYTE(__dst[0]) = 0;
    uint64_t v5 = *((void *)result + 21);
    if (v5)
    {
      uint64_t v6 = v5 - 1;
      int v7 = *((unsigned __int8 *)result + v6 + 160);
      LOBYTE(__dst[0]) = v7;
      *((void *)v1 + 21) = v6;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>(result, (char *)__dst, 1uLL))
      {
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v1, 0, (uint64_t)"Dictionary");
LABEL_21:
        uint64_t v2 = *((void *)v1 + 16);
        uint64_t v3 = *((void *)v1 + 14) - 1;
        goto LABEL_22;
      }
      int v7 = LOBYTE(__dst[0]);
    }
    if (v7 != 3)
    {
      uint64_t v10 = re::OPACK::toString(v7);
      return (_anonymous_namespace_ *)re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag(v1, (uint64_t)"Dictionary", (uint64_t)v10);
    }
    goto LABEL_21;
  }
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v14);
  if (v15) {
    uint64_t v8 = *(unsigned char **)&v16[7];
  }
  else {
    uint64_t v8 = v16;
  }
  uint64_t v9 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)__dst, v8, *(void *)(v9 - 24), *(void *)(v9 - 16));
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)__dst);
  if (*(void *)&__dst[0])
  {
    if (BYTE8(__dst[0])) {
      (*(void (**)(void))(**(void **)&__dst[0] + 40))();
    }
    memset(__dst, 0, sizeof(__dst));
  }
  uint64_t result = v14;
  if (v14 && (v15 & 1) != 0) {
    return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v14 + 40))();
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginObject(uint64_t a1, const char *a2, int a3, int a4)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v20 = 0;
  if (!re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v20, 0)) {
    return 0;
  }
  unsigned __int8 __dst = 0;
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 168);
  if (v9)
  {
    uint64_t v10 = v9 - 1;
    int v11 = *(unsigned __int8 *)(a1 + v10 + 160);
    unsigned __int8 __dst = *(unsigned char *)(a1 + v10 + 160);
    *(void *)(a1 + 168) = v10;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL) & 1) == 0)
    {
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Object");
      return 0;
    }
    int v11 = __dst;
  }
  if (v11 != 223 && v11 != 239)
  {
    uint64_t v13 = re::OPACK::toString(v11);
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, (uint64_t)"Object", (uint64_t)v13);
    return 0;
  }
  uint64_t v7 = 1;
  if (v11 == 223) {
    char v12 = 1;
  }
  else {
    char v12 = 2;
  }
  LOBYTE(v14) = v12;
  DWORD1(v14) = a4;
  *((void *)&v14 + 1) = a2;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  unint64_t v17 = 0xFFFFFFFF80000000;
  uint64_t v18 = 0;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v14);
  *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v20;
  return v7;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::endObject(uint64_t result)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  uint64_t v1 = result;
  unsigned __int8 __dst = 0;
  while (1)
  {
    uint64_t v2 = *(void *)(v1 + 168);
    if (v2)
    {
      uint64_t v3 = v2 - 1;
      int v4 = *(unsigned __int8 *)(v1 + v2 - 1 + 160);
      unsigned __int8 __dst = v4;
      *(void *)(v1 + 168) = v3;
      goto LABEL_7;
    }
    uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v1, (char *)&__dst, 1uLL);
    if (!result) {
      break;
    }
    int v4 = __dst;
LABEL_7:
    if (v4 == 3) {
      goto LABEL_13;
    }
    unint64_t v5 = *(void *)(v1 + 168);
    if (v5 <= 7)
    {
      *(void *)(v1 + 168) = v5 + 1;
      *(unsigned char *)(v1 + v5 + 160) = v4;
    }
    uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::skipObject(v1);
    if (*(unsigned char *)(v1 + 40)) {
      return result;
    }
  }
  uint64_t result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)v1, 0, (uint64_t)"Object");
LABEL_13:
  if (!*(unsigned char *)(v1 + 40))
  {
    uint64_t v6 = *(void *)(v1 + 128);
    uint64_t v7 = *(void *)(v1 + 112) - 1;
    uint64_t v8 = *(void *)(v6 + 48 * v7 + 16);
    if (v8)
    {
      do
      {
        --v8;
        re::EncoderOPACK<re::SeekableInputStream>::skipObject(v1);
      }
      while (v8);
      uint64_t v6 = *(void *)(v1 + 128);
      uint64_t v7 = *(void *)(v1 + 112) - 1;
    }
    uint64_t result = (uint64_t)re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState((_anonymous_namespace_ *)v1, *(unsigned __int8 *)(v6 + 48 * v7));
    uint64_t v9 = *(void *)(v1 + 128);
    uint64_t v10 = *(void *)(v1 + 112) - 1;
    if (*(unsigned char *)(v9 + 48 * v10) != 2) {
      ++*(void *)(v9 + 48 * v10 + 32);
    }
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (long long v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v35 = 0;
    int v20 = re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v35, 0);
    BOOL result = 0;
    if (!v20) {
      return result;
    }
    if (v35) {
      re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  unint64_t v23 = a4[1];
  if (v23) {
    unint64_t v24 = v23 >> 1;
  }
  else {
    unint64_t v24 = v23 >> 1;
  }
  unint64_t v35 = v24;
  int v25 = re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v35, 0);
  BOOL result = 0;
  if (v25)
  {
    unint64_t v26 = v35;
    if (v26 <= (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))())
    {
      if (!*a4)
      {
        size_t v33 = v35 + 1;
        *a4 = *(void *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v33);
      }
      re::DynamicString::resize(a4, v35, 0);
      if (v35)
      {
        if (a4[1]) {
          int v34 = (char *)a4[2];
        }
        else {
          int v34 = (char *)a4 + 9;
        }
        re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, v34, 0);
      }
      uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      re::EncoderOPACK<re::SeekableInputStream>::endString(v22);
      return *(unsigned char *)(a1 + 64) == 0;
    }
    char v27 = v35;
    (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v28, v29, v30, v31, v32, v27);
    return 0;
  }
  return result;
}

uint64_t re::internal::serializeObjectWithOneMember<re::EncoderOPACK<re::SeekableInputStream>>(unsigned char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)v29, *a5, a5[2]);
  re::TypeMemberCollection::operator[](v14, 0, (uint64_t)&v27);
  uint64_t v15 = a4 + *(unsigned int *)(v28 + 24);
  re::TypeRegistry::typeInfo(v27, *(void *)v28, v29);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v30);
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*a5 == *a6)
  {
    uint64_t v18 = *(void *)a5[2];
    uint64_t v19 = a6[2];
    uint64_t v20 = *(void *)v19;
    if ((unsigned __int16)v18 != (unsigned __int16)*(void *)v19) {
      goto LABEL_14;
    }
    BOOL v22 = WORD1(v18) == WORD1(v20);
    uint64_t v21 = (v20 ^ v18) & 0xFFFFFF00000000;
    BOOL v22 = v22 && v21 == 0;
    if (!v22) {
      goto LABEL_14;
    }
LABEL_4:
    if (!a1[64]) {
      return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v26, a7);
    }
    return 0;
  }
  if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, v16)) {
    goto LABEL_4;
  }
  uint64_t v19 = a6[2];
LABEL_14:
  if (*(_DWORD *)(v19 + 88) != 1)
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
    return 0;
  }
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v23, *a6, v19);
  re::TypeMemberCollection::operator[](v23, 0, (uint64_t)v24);
  re::TypeRegistry::typeInfo(v24[0], *v24[2], v29);
  re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v30);
  if (a1[64]) {
    return 0;
  }
  return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v25, a7);
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginString(uint64_t a1, const char *a2, int a3, uint64_t *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v16, 0);
  if (result)
  {
    re::EncoderOPACK<re::SeekableInputStream>::readStringTag(a1, a2, a4);
    uint64_t v10 = *a4;
    LOBYTE(v11) = 8;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::serializeString(uint64_t result, char *a2, char a3)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  int v4 = (_anonymous_namespace_ *)result;
  uint64_t v5 = *(void *)(result + 128) + 48 * *(void *)(result + 112);
  unint64_t v6 = *(void *)(v5 - 24);
  unint64_t v7 = *(void *)(result + 168);
  if (v7)
  {
    if (v7 >= v6) {
      uint64_t v8 = *(void *)(v5 - 24);
    }
    else {
      uint64_t v8 = *(void *)(result + 168);
    }
    uint64_t v9 = v7 - v8;
    if ((uint64_t)(v7 - 1) >= (uint64_t)(v7 - v8))
    {
      do
      {
        *a2++ = *(unsigned char *)(result + 159 + v7);
        uint64_t v10 = v7 - 2;
        --v7;
      }
      while (v10 >= v9);
    }
    *(void *)(result + 168) = v9;
    size_t v11 = v6 - v8;
    if (v6 == v8) {
      goto LABEL_15;
    }
    goto LABEL_11;
  }
  size_t v11 = *(void *)(v5 - 24);
  if (v6)
  {
LABEL_11:
    if (a3) {
      a2 = 0;
    }
    uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, a2, v11);
    if ((result & 1) == 0) {
      uint64_t result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType(v4, 0, (uint64_t)"String");
    }
  }
LABEL_15:
  if ((a3 & 2) == 0)
  {
    uint64_t v12 = *((void *)v4 + 16);
    uint64_t v13 = *((void *)v4 + 14) - 1;
    if (*(unsigned char *)(v12 + 48 * v13) != 2) {
      *(void *)(v12 + 48 * v13 + 32) += v6;
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endString(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 8);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if (v10) {
        unint64_t v7 = *(unsigned char **)&v11[7];
      }
      else {
        unint64_t v7 = v11;
      }
      uint64_t v8 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize string \"%s\". Expected number of characters: %lld. Actual number of characters: %lld.", (re::DynamicString *)v12, v7, *(void *)(v8 - 24), *(void *)(v8 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(void *)&v12[0])
      {
        if (BYTE8(v12[0])) {
          (*(void (**)(void))(**(void **)&v12[0] + 40))();
        }
        memset(v12, 0, sizeof(v12));
      }
      uint64_t result = v9;
      if (v9 && (v10 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v9 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::SeekableInputStream>>(unsigned char *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v21);
  if (v21[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)&v22);
    if (*(_DWORD *)(v19 + 88) || (re::TypeRegistry::typeInfo(v18[0], *(void *)(v19 + 72), v23), v23[0]))
    {
      if (re::EncoderOPACK<re::SeekableInputStream>::beginObject((uint64_t)(a1 + 24), "@super", 0, 0))
      {
        re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::SeekableInputStream>>(a1, a2, v18, a4);
        re::EncoderOPACK<re::SeekableInputStream>::endObject((uint64_t)(a1 + 24));
      }
    }
  }
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v18, *a3, a3[2]);
  if (v20)
  {
    for (unint64_t i = 0; i < v20; ++i)
    {
      if (a1[64]) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v18, i, (uint64_t)&v16);
      if (*(unsigned char *)(v17 + 28))
      {
        uint64_t v10 = *(void *)(v17 + 16);
        if (strlen((const char *)v10) >= 3 && *(unsigned char *)v10 == 109) {
          v10 += 2 * (*(unsigned char *)(v10 + 1) == 95);
        }
        uint64_t v11 = *(unsigned int *)(v17 + 32);
        uint64_t v12 = a2 + *(unsigned int *)(v17 + 24);
        re::TypeRegistry::typeInfo(v16, *(void *)v17, v23);
        re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v24);
        if (a1[64]
          || (uint64_t result = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v10, v11, v12, v15, v15, a4), (result & 1) == 0))
        {
          uint64_t result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a3);
          if (v13)
          {
            uint64_t v14 = (_DWORD *)(result + 16);
            while (i != *v14)
            {
              v14 += 6;
              if (!--v13) {
                goto LABEL_22;
              }
            }
            if (!a1[64]) {
              uint64_t result = (*(uint64_t (**)(unsigned char *, void, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, *((void *)v14 - 1), v11, v12, v15, v15, a4);
            }
          }
        }
      }
LABEL_22:
      ;
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v52);
  re::TypeRegistry::typeInfo((void *)*a4, *(void *)(a4[2] + 72), v48);
  if (v48[0])
  {
    if (!v52[0])
    {
      uint64_t v11 = re::TypeInfo::name((re::TypeInfo *)&v49)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (re::EncoderOPACK<re::SeekableInputStream>::beginObject(a1 + 24, "@super", 0, 0))
    {
      if (v53 == v49)
      {
        uint64_t v18 = *v55;
        uint64_t v19 = *v51;
        if ((unsigned __int16)*v55 == (unsigned __int16)*v51)
        {
          BOOL v21 = WORD1(v18) == WORD1(v19);
          uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
          BOOL v21 = v21 && v20 == 0;
          if (v21) {
            goto LABEL_6;
          }
        }
      }
      else if (re::areSameTranslatedVersion((re *)&v53, (const re::TypeInfo *)&v49, v10))
      {
LABEL_6:
        re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::SeekableInputStream>>((unsigned char *)a1, a2, &v53, a5);
LABEL_16:
        re::EncoderOPACK<re::SeekableInputStream>::endObject(a1 + 24);
        goto LABEL_17;
      }
      if (v54 == v50)
      {
        re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::SeekableInputStream>>(a1, a2, &v53, &v49, a5);
      }
      else
      {
        uint64_t v22 = re::TypeInfo::name((re::TypeInfo *)&v53)[1];
        re::TypeInfo::name((re::TypeInfo *)&v49);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
      }
      goto LABEL_16;
    }
  }
LABEL_17:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v47, *a3, a3[2]);
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v45, *a4, a4[2]);
  if (v46)
  {
    for (unint64_t i = 0; i < v46; ++i)
    {
      if (*(unsigned char *)(a1 + 64)) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[](v45, i, (uint64_t)v43);
      if (*(unsigned char *)(v44 + 28))
      {
        uint64_t v29 = *(void *)(v44 + 16);
        if (strlen((const char *)v29) >= 3 && *(unsigned char *)v29 == 109) {
          v29 += 2 * (*(unsigned char *)(v29 + 1) == 95);
        }
        uint64_t v30 = *(unsigned int *)(v44 + 32);
        uint64_t v31 = *(re **)(*a4 + 856);
        if (!v31
          || (uint64_t v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v43),
              v31 == -1))
        {
          unint64_t v35 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            uint64_t v36 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            uint64_t v57 = v36;
            __int16 v58 = 2080;
            uint64_t v59 = v29;
            _os_log_impl(&dword_233120000, v35, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          uint64_t v37 = *(re::internal **)(a1 + 208);
          re::TypeRegistry::typeInfo(v43[0], *(void *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v57 + 4);
          uint64_t result = re::internal::translateType(v37, (const re::TypeRegistry *)v41, (uint64_t)buf);
          if (!*(unsigned char *)(a1 + 64)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint8_t *, uint8_t *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
          }
        }
        else
        {
          re::TypeMemberCollection::operator[](v47, (int)v31, (uint64_t)v41);
          uint64_t v32 = a2 + *(unsigned int *)(v42 + 24);
          re::TypeRegistry::typeInfo(v41[0], *(void *)v42, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
          re::TypeRegistry::typeInfo(v43[0], *(void *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
          if (*(unsigned char *)(a1 + 64)
            || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, v32, v40, v39, a5), (result & 1) == 0))
          {
            uint64_t result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a4);
            if (v33)
            {
              int v34 = (_DWORD *)(result + 16);
              while (i != *v34)
              {
                v34 += 6;
                if (!--v33) {
                  goto LABEL_37;
                }
              }
              uint64_t v38 = *((void *)v34 - 1);
              re::TypeRegistry::typeInfo(v41[0], *(void *)v42, buf);
              re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
              re::TypeRegistry::typeInfo(v43[0], *(void *)v44, buf);
              uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
              if (!*(unsigned char *)(a1 + 64)) {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v38, v30, v32, v40, v39, a5);
              }
            }
          }
        }
      }
LABEL_37:
      ;
    }
  }
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(void *a1)
{
  *a1 = &unk_26E6CBC68;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 59));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 54));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 43);
  return re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)a1);
}

void re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(void *a1)
{
  *a1 = &unk_26E6CBC68;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 59));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 54));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)a1);
  JUMPOUT(0x237DBCBD0);
}

void re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(void *)a1 + 80))(a1, a5);
  if (v14)
  {
    return v14(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    uint64_t v16 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
    return 0;
  }
}

uint64_t (*re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re::TypeInfo *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v2 = re::serializeType<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  if (*(void *)a2 == *(void *)(a1 + 272))
  {
    uint64_t v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **(void **)(a2 + 16) | 0xFFFFFFFF00000000);
    uint64_t v2 = re::serializeType<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
    if (v3) {
      return *(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, unsigned __int8 *, re::TypeInfo *, re::TypeInfo *, uint64_t, uint64_t))v3;
    }
  }
  return v2;
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  *(void *)a1 = &unk_26E6CBCD0;
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::deinit((void *)a1);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 288));
  re::DynamicArray<unsigned long>::deinit(a1 + 216);
  re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::close((_anonymous_namespace_ *)(a1 + 24));
  re::DynamicArray<unsigned long>::deinit(a1 + 120);
  if (*(unsigned char *)(a1 + 64)) {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 88));
  }
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

void re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::deinit(void *a1)
{
  if (a1[34])
  {
    (*(void (**)(void *))(*a1 + 40))(a1);
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 36));
    a1[34] = 0;
  }
}

_anonymous_namespace_ *re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::close(_anonymous_namespace_ *result)
{
  if (*(void *)result)
  {
    uint64_t v1 = result;
    if (*((void *)result + 21))
    {
      uint64_t v2 = (void *)*((void *)result + 20);
      if (v2)
      {
        uint64_t String = rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::GetString(v2);
        size_t v4 = *(void *)(*((void *)v1 + 20) + 24) - *(void *)(*((void *)v1 + 20) + 16);
        uint64_t v5 = (int *)((char *)v1 + 16);
        uint64_t v6 = (void **)((char *)v1 + 8);
        if (String)
        {
          unint64_t v7 = (char *)String;
          while (1)
          {
            size_t v8 = *v5;
            if (v4 <= v8) {
              break;
            }
            if ((int)v8 >= 1)
            {
              memcpy(*v6, v7, v8);
              uint64_t v9 = *v5;
              v7 += v9;
              v4 -= v9;
              *uint64_t v6 = 0;
              *uint64_t v5 = 0;
            }
            uint64_t v10 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void *, void *))(**(void **)v1 + 16))(*(void *)v1, (void *)v1 + 1, (void *)v1 + 2);
            if ((v10 & 1) == 0) {
              goto LABEL_10;
            }
          }
          memcpy(*v6, v7, v4);
LABEL_14:
          *uint64_t v6 = (char *)*v6 + v4;
          *v5 -= v4;
        }
        else
        {
          do
          {
            size_t v15 = *v5;
            if (v4 <= v15)
            {
              bzero(*v6, v4);
              goto LABEL_14;
            }
            if ((int)v15 >= 1)
            {
              bzero(*v6, v15);
              v4 -= *v5;
              *uint64_t v6 = 0;
              *uint64_t v5 = 0;
            }
            uint64_t v10 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void *, void *))(**(void **)v1 + 16))(*(void *)v1, (void *)v1 + 1, (void *)v1 + 2);
          }
          while ((v10 & 1) != 0);
LABEL_10:
          re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)&v16);
          if (v16 && (v17 & 1) != 0) {
            (*(void (**)(void))(*(void *)v16 + 40))();
          }
        }
        uint64_t v11 = *((void *)v1 + 20);
        if (v11)
        {
          uint64_t v12 = *((void *)v1 + 3);
          rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy(*((void *)v1 + 20));
          (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 40))(v12, v11);
        }
        *((void *)v1 + 20) = 0;
        uint64_t v13 = *((void *)v1 + 21);
        if (v13)
        {
          uint64_t v14 = *((void *)v1 + 3);
          rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy(v13 + 8);
          (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 40))(v14, v13);
        }
        *((void *)v1 + 21) = 0;
        re::DynamicArray<unsigned long>::deinit((uint64_t)v1 + 192);
      }
    }
    if (!*((unsigned char *)v1 + 40)) {
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 0);
    }
    uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::deinit((uint64_t)v1 + 96);
    if (*((int *)v1 + 4) >= 1)
    {
      uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)v1 + 24))();
      *((void *)v1 + 1) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *(void *)uint64_t v1 = 0;
    *((void *)v1 + 3) = 0;
    *((void *)v1 + 4) = 0;
  }
  return result;
}

uint64_t rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::GetString(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[3];
  if ((uint64_t)(a1[4] - (void)v2) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>((uint64_t)a1, 1);
    uint64_t v2 = (unsigned char *)a1[3];
  }
  a1[3] = v2 + 1;
  *uint64_t v2 = 0;
  uint64_t result = a1[2];
  --a1[3];
  return result;
}

char *rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(uint64_t a1, uint64_t a2)
{
  size_t v4 = *(void **)(a1 + 16);
  if (v4)
  {
    size_t v5 = *(void *)(a1 + 32) - (void)v4;
    size_t v6 = v5 + ((v5 + 1) >> 1);
    unint64_t v7 = *(re::internal::RapidJSONAllocator **)a1;
  }
  else
  {
    unint64_t v7 = *(re::internal::RapidJSONAllocator **)a1;
    if (*(void *)a1)
    {
      size_t v4 = 0;
    }
    else
    {
      unint64_t v7 = (re::internal::RapidJSONAllocator *)(*(uint64_t (**)(void *, uint64_t, void))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                                                  + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 1, 0);
      *(void *)a1 = v7;
      *(void *)(a1 + 8) = v7;
      size_t v4 = *(void **)(a1 + 16);
    }
    size_t v6 = *(void *)(a1 + 40);
    size_t v5 = *(void *)(a1 + 32) - (void)v4;
  }
  uint64_t v8 = *(void *)(a1 + 24) - (void)v4;
  if (v6 <= v8 + a2) {
    size_t v9 = v8 + a2;
  }
  else {
    size_t v9 = v6;
  }
  uint64_t result = (char *)re::internal::RapidJSONAllocator::Realloc(v7, v4, v5, v9);
  *(void *)(a1 + 16) = result;
  *(void *)(a1 + 24) = &result[v8];
  *(void *)(a1 + 32) = &result[v9];
  return result;
}

void *re::internal::RapidJSONAllocator::Realloc(re::internal::RapidJSONAllocator *this, void *a2, size_t a3, size_t a4)
{
  if (a3 != a4)
  {
    if (a4)
    {
      uint64_t v8 = (void *)(*(uint64_t (**)(void *, size_t, void))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                     + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, a4, 0);
      size_t v5 = v8;
      if (a3 && a2 && v8)
      {
        if (a4 >= a3) {
          size_t v9 = a3;
        }
        else {
          size_t v9 = a4;
        }
        memcpy(v8, a2, v9);
        goto LABEL_13;
      }
    }
    else
    {
      size_t v5 = 0;
    }
    if (!a2) {
      return v5;
    }
LABEL_13:
    (*(void (**)(void *, void *))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                           + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, a2);
    return v5;
  }
  return a2;
}

uint64_t rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy(uint64_t result)
{
  uint64_t v1 = result;
  if (*(void *)(result + 16)) {
    uint64_t result = (*(uint64_t (**)(void *))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
  }
                                               + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
  if (*(void *)(v1 + 8))
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                             + 40);
    return v2();
  }
  return result;
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  re::DynamicString::setCapacity(&v23, 0);
  uint64_t v22 = &a9;
  re::DynamicString::vassignf((re::DynamicString *)&v23, a3, &a9);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)(a1 + 24), a2, (re::DynamicString *)&v15);
  if (v16) {
    uint64_t v12 = *(unsigned char **)&v17[7];
  }
  else {
    uint64_t v12 = v17;
  }
  if (v24) {
    uint64_t v13 = v25;
  }
  else {
    uint64_t v13 = (char *)&v24 + 1;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: %s", (re::DynamicString *)&v18, "serialize", v12, v13);
  *(void *)&v21[0] = 400;
  *((void *)&v21[0] + 1) = re::FoundationErrorCategory(void)::instance;
  *(void *)&v21[1] = v18;
  *((void *)&v21[2] + 1) = v20;
  *(long long *)((char *)&v21[1] + 8) = v19;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1 + 24, v21);
  if (*(void *)&v21[1])
  {
    if (BYTE8(v21[1])) {
      (*(void (**)(void))(**(void **)&v21[1] + 40))();
    }
    memset(&v21[1], 0, 32);
  }
  if (v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t result = (uint64_t)v23;
  if (v23)
  {
    if (v24) {
      return (*(uint64_t (**)(void))(*v23 + 40))();
    }
  }
  return result;
}

uint64_t re::serializeType<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re::TypeInfo *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v173 = *MEMORY[0x263EF8340];
  if (this == a6) {
    goto LABEL_18;
  }
  if (*(void *)this == *(void *)a6)
  {
    uint64_t v15 = **((void **)this + 2);
    uint64_t v16 = **((void **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      BOOL v18 = WORD1(v15) == WORD1(v16);
      uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      BOOL v18 = v18 && v17 == 0;
      if (v18) {
        goto LABEL_18;
      }
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
    {
LABEL_231:
      re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, this, a6);
      return 0;
    }
    uint64_t v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
    if (v19) {
      int v20 = *(_DWORD *)(v19 + 16);
    }
    else {
      int v20 = -1;
    }
    uint64_t v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **((void **)a6 + 2));
    if (v21) {
      int v22 = *(_DWORD *)(v21 + 16);
    }
    else {
      int v22 = -1;
    }
    if (v20 != v22)
    {
      uint64_t v26 = re::TypeInfo::name(this)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
      re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **((void **)a6 + 2));
      LOBYTE(v148) = v26;
      uint64_t v36 = "Cannot serialize type \"%s\" version %u as version %u. Downgrading versions is not supported.";
LABEL_67:
      re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, v36, (uint64_t)a4, (uint64_t)this, (uint64_t)a6, a7, a8, v148);
      return 0;
    }
    goto LABEL_18;
  }
  if (!re::areSameTranslatedVersion(this, a6, a3)) {
    goto LABEL_10;
  }
LABEL_18:
  switch(*((unsigned char *)this + 12))
  {
    case 1:
      if (this == a6) {
        goto LABEL_22;
      }
      if (*(void *)this == *(void *)a6)
      {
        uint64_t v43 = **((void **)this + 2);
        uint64_t v44 = **((void **)a6 + 2);
        if ((unsigned __int16)v43 == (unsigned __int16)v44)
        {
          BOOL v18 = WORD1(v43) == WORD1(v44);
          uint64_t v45 = (v44 ^ v43) & 0xFFFFFF00000000;
          if (v18 && v45 == 0) {
            goto LABEL_22;
          }
        }
        goto LABEL_231;
      }
      if (!re::areSameTranslatedVersion(this, a6, a3)) {
        goto LABEL_231;
      }
LABEL_22:
      uint64_t v23 = re::TypeInfo::name(this);
      unint64_t v24 = (unint64_t)*v23 >> 1;
      if (v24 <= 0xCA3DEFB5)
      {
        if ((unint64_t)*v23 >> 1 <= 0x5D0225B)
        {
          if ((unint64_t)*v23 >> 1 <= 0x2E9355)
          {
            if (v24 != 104431)
            {
              if (v24 == 3029738)
              {
                return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, a4);
              }
LABEL_289:
              uint64_t v148 = re::TypeInfo::name(this)[1];
              uint64_t v36 = "Unsupported basic type \"%s\".";
              goto LABEL_67;
            }
            goto LABEL_252;
          }
          if (v24 == 3052374)
          {
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)a4);
          }
          uint64_t v132 = 3327612;
          goto LABEL_238;
        }
        if ((unint64_t)*v23 >> 1 > 0xB0F77BD0)
        {
          if (v24 == 2969009105)
          {
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (uint64_t)a3, (double *)a4, a7);
          }
          else
          {
            if (v24 != 3111160798) {
              goto LABEL_289;
            }
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, (char *)a4);
          }
        }
        if (v24 == 97526364)
        {
          return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (uint64_t)a3, (float *)a4, a7);
        }
        uint64_t v37 = 109413500;
        goto LABEL_162;
      }
      if ((unint64_t)*v23 >> 1 > 0x18E6A9A092)
      {
        if ((unint64_t)*v23 >> 1 <= 0x303EE8780EDLL)
        {
          if (v24 == 0x18E6A9A093)
          {
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, a4);
          }
          else
          {
            if (v24 != 0x303EE86A734) {
              goto LABEL_289;
            }
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, (unsigned __int16 *)a4);
          }
        }
        if (v24 == 0x303EE8780EELL)
        {
          return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, (uint64_t)a3, (unsigned int *)a4, a7);
        }
        if (v24 != 0x303EE88E58DLL) {
          goto LABEL_289;
        }
LABEL_249:
        return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, (rapidjson::internal **)a4);
      }
      if ((unint64_t)*v23 >> 1 > 0x16749DFF02)
      {
        if (v24 == 0x16749DFF03)
        {
LABEL_252:
          return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, (unsigned int *)a4);
        }
        uint64_t v132 = 0x16749F63A2;
LABEL_238:
        if (v24 != v132) {
          goto LABEL_289;
        }
        return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, (unint64_t *)a4);
      }
      if (v24 == 3393056694) {
        goto LABEL_249;
      }
      uint64_t v37 = 0x16749D2549;
LABEL_162:
      if (v24 != v37) {
        goto LABEL_289;
      }
      return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, (__int16 *)a4);
    case 2:
      return re::serializeEnum<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, (re::TypeInfo *)a4, (uint64_t)this, (uint64_t)a6, a7);
    case 3:
      if (this == a6) {
        goto LABEL_96;
      }
      if (*(void *)this == *(void *)a6)
      {
        uint64_t v47 = **((void **)this + 2);
        uint64_t v48 = **((void **)a6 + 2);
        if ((unsigned __int16)v47 == (unsigned __int16)v48
          && WORD1(v47) == WORD1(v48)
          && ((v48 ^ v47) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_96;
        }
        int v27 = 3;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3)) {
          goto LABEL_96;
        }
        int v27 = *((unsigned __int8 *)this + 12);
      }
      if (v27 != *((unsigned __int8 *)a6 + 12)) {
        goto LABEL_231;
      }
LABEL_96:
      if (a7)
      {
        v168.n128_u8[0] = 0;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(a1 + 24, a2, &v168);
        uint64_t v49 = (_anonymous_namespace_ *)(a1 + 24);
      }
      else
      {
        re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v168);
        re::TypeInfo::TypeInfo((uint64_t)&v150, (uint64_t)&v168.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v168);
        re::TypeInfo::TypeInfo((uint64_t)v163, (uint64_t)&v168.n128_i64[1]);
        re::TypeInfo::TypeInfo((uint64_t)&v168, (uint64_t)this);
        uint64_t v50 = (*(uint64_t (**)(unsigned __int8 *))(v169 + 80))(a4);
        LOBYTE(v161[0]) = v50 != 0;
        double v51 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(a1 + 24, a2, v161);
        if (v50)
        {
          uint64_t v52 = (*(uint64_t (**)(unsigned __int8 *, double))(v169 + 80))(a4, v51);
          if (!*(unsigned char *)(a1 + 64)) {
            (*(void (**)(uint64_t, const char *, void, uint64_t, rapidjson::internal **, unsigned char *, void))(*(void *)a1 + 72))(a1, a2, 0, v52, &v150, v163, 0);
          }
        }
        uint64_t v49 = (_anonymous_namespace_ *)(a1 + 24);
      }
      re::EncoderBinary<re::SeekableInputStream>::endOptional(v49);
      return *(unsigned char *)(a1 + 64) == 0;
    case 4:
      if (this == a6) {
        goto LABEL_111;
      }
      if (*(void *)this == *(void *)a6)
      {
        uint64_t v53 = **((void **)this + 2);
        uint64_t v54 = **((void **)a6 + 2);
        if ((unsigned __int16)v53 == (unsigned __int16)v54)
        {
          BOOL v18 = WORD1(v53) == WORD1(v54);
          uint64_t v55 = (v54 ^ v53) & 0xFFFFFF00000000;
          if (v18 && v55 == 0) {
            goto LABEL_111;
          }
        }
      }
      else if (re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_111;
      }
      if (*((unsigned char *)a6 + 12) != 4) {
        goto LABEL_231;
      }
      uint64_t v57 = *((void *)this + 2);
      __int16 v58 = (void *)*((void *)a6 + 2);
      int v59 = *((_DWORD *)v58 + 21) & 0xFFFFFF;
      if ((*(_DWORD *)(v57 + 84) & 0xFFFFFF) != 0)
      {
        if (!v59) {
          goto LABEL_231;
        }
        goto LABEL_111;
      }
      if (!v59 && *(_DWORD *)(v57 + 88) == *((_DWORD *)v58 + 22))
      {
LABEL_111:
        if (a7)
        {
          uint64_t v60 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v168);
          re::TypeInfo::TypeInfo((uint64_t)v163, (uint64_t)&v168.n128_i64[1]);
          re::internal::translateType(v60, (const re::TypeRegistry *)v163, (uint64_t)&v150);
          uint64_t v61 = (*(uint64_t (**)(uint64_t, rapidjson::internal **))(*(void *)a1 + 80))(a1, &v150);
          if (!v61) {
            goto LABEL_191;
          }
          v62 = (void (*)(uint64_t, void, void, void, rapidjson::internal **, rapidjson::internal **, uint64_t))v61;
          v63 = (void *)*((void *)a6 + 2);
          int v64 = *((_DWORD *)v63 + 21) & 0xFFFFFF;
          if (v64)
          {
            unint64_t v65 = 0;
            int v66 = 8;
          }
          else
          {
            unint64_t v65 = *((int *)v63 + 22);
            int v66 = 4;
          }
          v168.n128_u64[0] = v65;
          v71 = (_anonymous_namespace_ *)(a1 + 24);
          uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v168, v66);
          if (!result) {
            return result;
          }
          unint64_t v128 = v168.n128_u64[0];
          if (v64) {
            BOOL v129 = v168.n128_u64[0] == 0;
          }
          else {
            BOOL v129 = 1;
          }
          char v130 = v129;
          if (!v129)
          {
            v161[0] = 0;
            v161[1] = 0xFFFFFFFFLL;
            (*(void (**)(uint64_t, void, void *))(*(void *)a1 + 16))(a1, 0, v161);
            unint64_t v128 = v168.n128_u64[0];
          }
          if (v128)
          {
            unint64_t v131 = 0;
            do
            {
              v62(a1, 0, 0, 0, &v150, &v150, 1);
              ++v131;
            }
            while (v131 < v168.n128_u64[0]);
          }
          if ((v130 & 1) == 0) {
            goto LABEL_226;
          }
        }
        else
        {
          re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v168);
          re::TypeInfo::TypeInfo((uint64_t)&v150, (uint64_t)&v168.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v168);
          re::TypeInfo::TypeInfo((uint64_t)v163, (uint64_t)&v168.n128_i64[1]);
          re::TypeInfo::TypeInfo((uint64_t)&v168, (uint64_t)this);
          uint64_t v67 = (*(uint64_t (**)(uint64_t, rapidjson::internal **))(*(void *)a1 + 80))(a1, &v150);
          if (!v67) {
            goto LABEL_191;
          }
          v68 = (void (*)(uint64_t, void, void, uint64_t, rapidjson::internal **, unsigned char *, void))v67;
          v159[0] = re::ArrayAccessor::size((re::ArrayAccessor *)&v168, (char *)a4);
          int v69 = *(_DWORD *)(*((void *)this + 2) + 84) & 0xFFFFFF;
          if (v69) {
            int v70 = 8;
          }
          else {
            int v70 = 4;
          }
          v71 = (_anonymous_namespace_ *)(a1 + 24);
          uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, (uint64_t)a3, v159, v70);
          if (!result) {
            return result;
          }
          uint64_t v72 = v159[0];
          if (v69) {
            BOOL v73 = v159[0] == 0;
          }
          else {
            BOOL v73 = 1;
          }
          char v74 = v73;
          if (!v73)
          {
            uint64_t v75 = *(void *)a4;
            v160[0] = 0;
            v160[1] = 0xFFFFFFFFLL;
            (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 16))(a1, v75, v160);
            uint64_t v72 = v159[0];
          }
          if (v72)
          {
            unint64_t v76 = 0;
            do
            {
              uint64_t v77 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v168, (char *)a4, v76);
              v68(a1, 0, 0, v77, &v150, v163, 0);
              ++v76;
            }
            while (v76 < v159[0]);
          }
          if ((v74 & 1) == 0) {
LABEL_226:
          }
            (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
        }
LABEL_227:
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endArray(v71);
        return *(unsigned char *)(a1 + 64) == 0;
      }
      goto LABEL_231;
    case 5:
      if (this == a6) {
        goto LABEL_138;
      }
      if (*(void *)this == *(void *)a6)
      {
        uint64_t v78 = **((void **)this + 2);
        uint64_t v79 = **((void **)a6 + 2);
        if ((unsigned __int16)v78 == (unsigned __int16)v79
          && WORD1(v78) == WORD1(v79)
          && ((v79 ^ v78) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_138;
        }
        int v28 = 5;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3)) {
          goto LABEL_138;
        }
        int v28 = *((unsigned __int8 *)this + 12);
      }
      if (v28 != *((unsigned __int8 *)a6 + 12)) {
        goto LABEL_231;
      }
LABEL_138:
      if (a7)
      {
        v80 = *(re::internal **)(a1 + 272);
        re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v168);
        re::TypeInfo::TypeInfo((uint64_t)v163, (uint64_t)&v168.n128_i64[1]);
        re::internal::translateType(v80, (const re::TypeRegistry *)v163, (uint64_t)&v150);
        uint64_t v81 = (*(uint64_t (**)(uint64_t, rapidjson::internal **))(*(void *)a1 + 80))(a1, &v150);
        if (!v81) {
          goto LABEL_191;
        }
        v82 = (void (*)(uint64_t, void, void, void, rapidjson::internal **, rapidjson::internal **, uint64_t))v81;
        v168.n128_u64[0] = 0;
        v71 = (_anonymous_namespace_ *)(a1 + 24);
        BOOL v83 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v168, 0);
        uint64_t result = 0;
        if (v83)
        {
          if (v168.n128_u64[0])
          {
            unint64_t v84 = 0;
            do
            {
              v82(a1, 0, 0, 0, &v150, &v150, 1);
              ++v84;
            }
            while (v84 < v168.n128_u64[0]);
          }
          goto LABEL_227;
        }
        return result;
      }
      re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v168);
      re::TypeInfo::TypeInfo((uint64_t)&v150, (uint64_t)&v168.n128_i64[1]);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v168);
      re::TypeInfo::TypeInfo((uint64_t)v163, (uint64_t)&v168.n128_i64[1]);
      re::TypeInfo::TypeInfo((uint64_t)&v168, (uint64_t)this);
      uint64_t v85 = (*(uint64_t (**)(uint64_t, rapidjson::internal **))(*(void *)a1 + 80))(a1, &v150);
      if (!v85) {
        goto LABEL_191;
      }
      v86 = (void (*)(uint64_t, void, void, uint64_t, rapidjson::internal **, unsigned char *, void))v85;
      v160[0] = (*(uint64_t (**)(unsigned __int8 *))(v169 + 80))(a4);
      v71 = (_anonymous_namespace_ *)(a1 + 24);
      BOOL v87 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, (uint64_t)a3, v160, 0);
      uint64_t result = 0;
      if (!v87) {
        return result;
      }
      if (*(void *)(v169 + 96))
      {
        if (v160[0])
        {
          unint64_t v88 = 0;
          do
          {
            uint64_t v89 = (*(uint64_t (**)(unsigned __int8 *, unint64_t))(v169 + 96))(a4, v88);
            v86(a1, 0, 0, v89, &v150, v163, 0);
            ++v88;
          }
          while (v88 < v160[0]);
        }
      }
      else
      {
        v137 = *(uint64_t (**)(unsigned __int8 *, void))(v169 + 104);
        if (!v137 || !*(void *)(v169 + 112) || !*(void *)(v169 + 120))
        {
          re::TypeInfo::TypeInfo((uint64_t)v161, (uint64_t)&v168);
          uint64_t v148 = re::TypeInfo::name((re::TypeInfo *)v161)[1];
          uint64_t v36 = "List type \"%s\" does not provide an indexer or iterator.";
          goto LABEL_67;
        }
        uint64_t v138 = v137(a4, *(void *)(a1 + 56));
        uint64_t v139 = (*(uint64_t (**)(void))(v169 + 112))();
        if (v139)
        {
          uint64_t v140 = v139;
          do
          {
            v86(a1, 0, 0, v140, &v150, v163, 0);
            uint64_t v140 = (*(uint64_t (**)(uint64_t))(v169 + 112))(v138);
          }
          while (v140);
        }
        (*(void (**)(uint64_t, void))(v169 + 120))(v138, *(void *)(a1 + 56));
      }
      goto LABEL_227;
    case 6:
      re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v168);
      re::TypeInfo::TypeInfo((uint64_t)&v150, (uint64_t)&v168.n128_i64[1]);
      uint64_t v30 = re::TypeInfo::name((re::TypeInfo *)&v150);
      int v31 = BYTE4(v151);
      if (BYTE4(v151) != 1) {
        goto LABEL_78;
      }
      if (!re::TypeInfo::isInteger((re::TypeInfo *)&v150))
      {
        int v31 = BYTE4(v151);
LABEL_78:
        if (v31 == 8)
        {
          unint64_t v40 = (unint64_t)*v30 >> 1;
          if (v40 == 0x22C6ED80D0CLL)
          {
            v96 = (char *)v30[1];
            int v34 = re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
            if (v96 == "StringID") {
              return ((uint64_t (*)(uint64_t, const char *, const re::TypeInfo *, unsigned __int8 *, re::TypeInfo *, re::TypeInfo *, uint64_t))v34)(a1, a2, a3, a4, this, a6, a7);
            }
            int v97 = strcmp(v96, "StringID");
            int v34 = re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
            if (!v97) {
              return ((uint64_t (*)(uint64_t, const char *, const re::TypeInfo *, unsigned __int8 *, re::TypeInfo *, re::TypeInfo *, uint64_t))v34)(a1, a2, a3, a4, this, a6, a7);
            }
          }
          else if (v40 == 0x134375A94D9F7110)
          {
            char v41 = (char *)v30[1];
            int v34 = re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
            if (v41 == "DynamicString") {
              return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
            }
            int v42 = strcmp(v41, "DynamicString");
            int v34 = re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
            if (!v42) {
              return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
            }
          }
        }
LABEL_178:
        if (this == a6) {
          goto LABEL_186;
        }
        if (*(void *)this == *(void *)a6)
        {
          uint64_t v98 = **((void **)this + 2);
          uint64_t v99 = **((void **)a6 + 2);
          if ((unsigned __int16)v98 == (unsigned __int16)v99
            && WORD1(v98) == WORD1(v99)
            && ((v99 ^ v98) & 0xFFFFFF00000000) == 0)
          {
            goto LABEL_186;
          }
        }
        else if (re::areSameTranslatedVersion(this, a6, v29))
        {
          goto LABEL_186;
        }
        if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)) {
          goto LABEL_231;
        }
LABEL_186:
        if (a7)
        {
          v100 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v168);
          re::TypeInfo::TypeInfo((uint64_t)v163, (uint64_t)&v168.n128_i64[1]);
          re::internal::translateType(v100, (const re::TypeRegistry *)v163, (uint64_t)&v150);
          v101 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v168);
          re::TypeInfo::TypeInfo((uint64_t)v161, (uint64_t)&v168.n128_i64[1]);
          re::internal::translateType(v101, (const re::TypeRegistry *)v161, (uint64_t)v163);
          if ((*(uint64_t (**)(uint64_t, rapidjson::internal **))(*(void *)a1 + 80))(a1, &v150))
          {
            if ((*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v163))
            {
              v168.n128_u64[0] = 0;
              uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(a1 + 24, a2, (uint64_t *)&v168);
              if (!result) {
                return result;
              }
              v102 = (_anonymous_namespace_ *)(a1 + 24);
              goto LABEL_299;
            }
            v103 = (re::TypeInfo *)v163;
          }
          else
          {
LABEL_191:
            v103 = (re::TypeInfo *)&v150;
          }
LABEL_192:
          uint64_t v149 = re::TypeInfo::name(v103)[1];
          re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v104, v105, v106, v107, v108, v149);
          return 0;
        }
        re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v168);
        re::TypeInfo::TypeInfo((uint64_t)v161, (uint64_t)&v168.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 80), &v168);
        re::TypeInfo::TypeInfo((uint64_t)v160, (uint64_t)&v168.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v168);
        re::TypeInfo::TypeInfo((uint64_t)v159, (uint64_t)&v168.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v168);
        re::TypeInfo::TypeInfo((uint64_t)v158, (uint64_t)&v168.n128_i64[1]);
        re::TypeInfo::TypeInfo((uint64_t)v156, (uint64_t)this);
        uint64_t v109 = (*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 80))(a1, v161);
        if (!v109)
        {
          v103 = (re::TypeInfo *)v161;
          goto LABEL_192;
        }
        v110 = (void (*)(uint64_t, const char *, void, uint64_t, void *, uint64_t *, void))v109;
        uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 80))(a1, v160);
        if (!v111)
        {
          v103 = (re::TypeInfo *)v160;
          goto LABEL_192;
        }
        v112 = (void (*)(uint64_t, const char *, void, uint64_t, uint64_t *, unsigned char *, void))v111;
        unint64_t v113 = (*(uint64_t (**)(unsigned __int8 *))(v157 + 88))(a4);
        unint64_t v155 = v113;
        uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(a1 + 24, a2, (uint64_t *)&v155);
        if (!result) {
          return result;
        }
        if (v113)
        {
          v114 = *(void **)this;
          v168.n128_u64[0] = 0x449AD97C4B77BED4;
          v168.n128_u64[1] = (unint64_t)"_CompareFunc";
          v115 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)(v114 + 25), &v168);
          if (v115)
          {
            unint64_t v116 = *v115;
            re::StringID::destroyString((re::StringID *)&v168);
            if (v114)
            {
              unint64_t v117 = *(void *)v161[2];
              v168.n128_u64[0] = v116;
              v168.n128_u64[1] = v117;
              LODWORD(v169) = -1;
              v118 = (uint64_t (**)(uint64_t, uint64_t))re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v161[0] + 768, (uint64_t *)&v168);
              if (v118)
              {
                v119 = *v118;
                if (*v118)
                {
                  v154 = 0;
                  uint64_t v151 = 0;
                  unint64_t v152 = 0;
                  int v153 = 0;
                  v150 = *(rapidjson::internal **)(a1 + 56);
                  re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v150, v113);
                  ++v153;
                  uint64_t v120 = (*(uint64_t (**)(unsigned __int8 *, void))(v157 + 112))(a4, *(void *)(a1 + 56));
                  if ((*(unsigned int (**)(void))(v157 + 120))())
                  {
                    do
                    {
                      uint64_t v121 = (*(uint64_t (**)(uint64_t))(v157 + 128))(v120);
                      uint64_t v122 = (*(uint64_t (**)(uint64_t))(v157 + 136))(v120);
                      v168.n128_u64[0] = v121;
                      v168.n128_u64[1] = v122;
                      __n128 v123 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v150, &v168);
                    }
                    while (((*(uint64_t (**)(uint64_t, __n128))(v157 + 120))(v120, v123) & 1) != 0);
                  }
                  (*(void (**)(uint64_t, void))(v157 + 144))(v120, *(void *)(a1 + 56));
                  std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(v154, &v154[16 * v152], v119);
                  uint64_t v124 = 0;
                  unint64_t v125 = 0;
                  if (v113 <= 1) {
                    unint64_t v113 = 1;
                  }
                  do
                  {
                    double v126 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 0);
                    unint64_t v127 = v152;
                    if (v152 <= v125)
                    {
                      uint64_t v162 = 0;
                      long long v171 = 0u;
                      long long v172 = 0u;
                      long long v169 = 0u;
                      long long v170 = 0u;
                      __n128 v168 = 0u;
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v163 = 136315906;
                      *(void *)&v163[4] = "operator[]";
                      *(_WORD *)&v163[12] = 1024;
                      *(_DWORD *)&v163[14] = 789;
                      __int16 v164 = 2048;
                      unint64_t v165 = v125;
                      __int16 v166 = 2048;
                      unint64_t v167 = v127;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_301:
                      uint64_t v162 = 0;
                      long long v171 = 0u;
                      long long v172 = 0u;
                      long long v169 = 0u;
                      long long v170 = 0u;
                      __n128 v168 = 0u;
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v163 = 136315906;
                      *(void *)&v163[4] = "operator[]";
                      *(_WORD *)&v163[12] = 1024;
                      *(_DWORD *)&v163[14] = 789;
                      __int16 v164 = 2048;
                      unint64_t v165 = v125;
                      __int16 v166 = 2048;
                      unint64_t v167 = v127;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
                    }
                    ((void (*)(uint64_t, const char *, void, void, void *, uint64_t *, void, double))v110)(a1, "key", 0, *(void *)&v154[v124], v161, v159, 0, v126);
                    unint64_t v127 = v152;
                    if (v152 <= v125) {
                      goto LABEL_301;
                    }
                    v112(a1, "value", 0, *(void *)&v154[v124 + 8], v160, v158, 0);
                    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
                    ++v125;
                    v124 += 16;
                  }
                  while (v113 != v125);
                  if (v150 && v154) {
                    (*(void (**)(void))(*(void *)v150 + 40))();
                  }
                  goto LABEL_298;
                }
              }
            }
          }
          else
          {
            re::StringID::destroyString((re::StringID *)&v168);
          }
          uint64_t v144 = (*(uint64_t (**)(unsigned __int8 *, void))(v157 + 112))(a4, *(void *)(a1 + 56));
          (*(void (**)(void))(v157 + 120))();
          do
          {
            double v145 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 0);
            uint64_t v146 = (*(uint64_t (**)(uint64_t, double))(v157 + 128))(v144, v145);
            v110(a1, "key", 0, v146, v161, v159, 0);
            uint64_t v147 = (*(uint64_t (**)(uint64_t))(v157 + 136))(v144);
            v112(a1, "value", 0, v147, v160, v158, 0);
            re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
            (*(void (**)(uint64_t))(v157 + 120))(v144);
            --v113;
          }
          while (v113);
          (*(void (**)(uint64_t, void))(v157 + 144))(v144, *(void *)(a1 + 56));
        }
LABEL_298:
        v102 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_299:
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionary(v102);
        return *(unsigned char *)(a1 + 64) == 0;
      }
      unint64_t v32 = (unint64_t)*v30 >> 1;
      if (v32 > 0x303EE8780EDLL)
      {
        if (v32 == 0x303EE8780EELL)
        {
          v134 = (char *)v30[1];
          int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>;
          if (v134 == "uint32_t") {
            return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
          }
          int v135 = strcmp(v134, "uint32_t");
          int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>;
          if (!v135) {
            return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
          }
          goto LABEL_263;
        }
        if (v32 != 0x303EE88E58DLL)
        {
LABEL_263:
          v168.n128_u64[0] = 0x18E6A9A093;
          v168.n128_u64[1] = (unint64_t)"uint8_t";
          BOOL v136 = re::StringID::operator==(v30, &v168);
          int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>;
          if (v136) {
            return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
          }
          v168.n128_u64[0] = 0x16749F63A2;
          v168.n128_u64[1] = (unint64_t)"int64_t";
          if (re::StringID::operator==(v30, &v168)) {
            return ((uint64_t (*)(uint64_t, const char *, const re::TypeInfo *, unsigned __int8 *, re::TypeInfo *, re::TypeInfo *, uint64_t))re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>)(a1, a2, a3, a4, this, a6, a7);
          }
          *(void *)v163 = 3327612;
          *(void *)&v163[8] = "long";
          BOOL v141 = re::StringID::operator==(v30, v163);
          int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>;
          if (v141) {
            return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
          }
          v168.n128_u64[0] = 104431;
          v168.n128_u64[1] = (unint64_t)"int";
          BOOL v142 = re::StringID::operator==(v30, &v168);
          int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>;
          if (v142) {
            return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
          }
          v168.n128_u64[0] = 109413500;
          v168.n128_u64[1] = (unint64_t)"short";
          BOOL v143 = re::StringID::operator==(v30, &v168);
          int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>;
          if (v143) {
            return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
          }
          goto LABEL_178;
        }
        v94 = (char *)v30[1];
        int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
        if (v94 != "uint64_t")
        {
          v95 = "uint64_t";
          goto LABEL_259;
        }
      }
      else
      {
        if (v32 != 3393056694)
        {
          if (v32 == 0x303EE86A734)
          {
            uint64_t v33 = (char *)v30[1];
            int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>;
            if (v33 == "uint16_t") {
              return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
            }
            int v35 = strcmp(v33, "uint16_t");
            int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>;
            if (!v35) {
              return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
            }
          }
          goto LABEL_263;
        }
        v94 = (char *)v30[1];
        int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
        if (v94 != "size_t")
        {
          v95 = "size_t";
LABEL_259:
          int v133 = strcmp(v94, v95);
          int v34 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
          if (!v133) {
            return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
          }
          goto LABEL_263;
        }
      }
      return ((uint64_t (*)(void, void, void, void, void, void, void))v34)(a1, a2, a3, a4, this, a6, a7);
    case 7:
      if (this == a6) {
        goto LABEL_58;
      }
      if (*(void *)this == *(void *)a6)
      {
        uint64_t v90 = **((void **)this + 2);
        uint64_t v91 = **((void **)a6 + 2);
        if ((unsigned __int16)v90 != (unsigned __int16)v91) {
          goto LABEL_231;
        }
        BOOL v18 = WORD1(v90) == WORD1(v91);
        uint64_t v92 = (v91 ^ v90) & 0xFFFFFF00000000;
        if (!v18 || v92 != 0) {
          goto LABEL_231;
        }
      }
      else if (!re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_231;
      }
LABEL_58:
      uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 16);
      if (a7)
      {
        if (!result) {
          return result;
        }
        v150 = 0;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, "tag", &v150);
        if (*(_DWORD *)(*((void *)a6 + 2) + 88))
        {
          re::TypeInfo::unionMember(a6, 0, (uint64_t)&v168);
          if (!*(unsigned char *)(a1 + 64)) {
            (*(void (**)(uint64_t, const char *, void, void, __n128 *, __n128 *, uint64_t))(*(void *)a1 + 72))(a1, "value", 0, 0, &v168, &v168, 1);
          }
        }
      }
      else
      {
        if (!result) {
          return result;
        }
        uint64_t v38 = (re::UnionAccessor *)re::TypeInfo::TypeInfo((uint64_t)&v168, (uint64_t)this);
        unint64_t Tag = re::UnionAccessor::readTag(v38, (char *)a4);
        *(void *)v163 = Tag;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, "tag", (rapidjson::internal **)v163);
        if (Tag < *(unsigned int *)(*((void *)this + 2) + 88))
        {
          re::TypeInfo::unionMember(this, Tag, (uint64_t)&v150);
          if (!*(unsigned char *)(a1 + 64)) {
            (*(void (**)(uint64_t, const char *, void, unsigned __int8 *, rapidjson::internal **, rapidjson::internal **, void))(*(void *)a1 + 72))(a1, "value", 0, a4, &v150, &v150, 0);
          }
        }
      }
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(unsigned char *)(a1 + 64) == 0;
    case 8:
      return re::serializeObject<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, (uint64_t)a3, (uint64_t)a4, (uint64_t **)this, (uint64_t)a6, a7);
    case 9:
      uint64_t v148 = re::TypeInfo::name(this)[1];
      uint64_t v36 = "Pointer type (\"%s\") needs to be handled explicitly by the serializer.";
      goto LABEL_67;
    default:
      LOBYTE(v148) = *((unsigned char *)this + 12);
      uint64_t v36 = "Invalid type category. Value = %d";
      goto LABEL_67;
  }
}

uint64_t re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, re::TypeInfo *this, re::TypeInfo *a4)
{
  uint64_t v7 = re::TypeInfo::name(this)[1];
  re::TypeInfo::name(a4);
  return re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Type mismatch. Runtime type \"%s\" and serialized type \"%s\" are different.", v8, v9, v10, v11, v12, v7);
}

uint64_t re::serializeEnum<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, re::TypeInfo *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **(void **)(a5 + 16);
      uint64_t v15 = **(void **)(a6 + 16);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_12;
        }
      }
    }
    else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
    {
      goto LABEL_12;
    }
    if (*(unsigned __int8 *)(a5 + 12) != *(unsigned __int8 *)(a6 + 12)
      || (BOOL v18 = re::TypeInfo::name((re::TypeInfo *)a5),
          uint64_t v19 = re::TypeInfo::name((re::TypeInfo *)a6),
          !re::StringID::operator==(v18, v19)))
    {
      re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
      return 0;
    }
  }
LABEL_12:
  return re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, (re *)a5, (const re::TypeInfo *)a6, a7);
}

uint64_t re::serializeObject<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t **this, uint64_t a6, uint64_t a7)
{
  if (a7)
  {
    if (*((unsigned char *)this[2] + 49))
    {
      int v22 = *(re::TypeRegistry **)(a1 + 272);
      v36[0] = 0x2686EB529B3EE220;
      v36[1] = "DynamicString";
      re::TypeRegistry::typeInfo(v22, (const re::StringID *)v36, &v37);
      re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v38);
      re::StringID::destroyString((re::StringID *)v36);
      uint64_t v23 = (re *)v39;
      unint64_t v24 = (const re::TypeInfo *)v39;
      uint64_t v25 = a1;
      uint64_t v26 = a2;
      int v27 = (const re::TypeInfo *)a3;
    }
    else
    {
      uint64_t v14 = re::TypeInfo::name((re::TypeInfo *)this);
      if ((unint64_t)*v14 >> 1 != 0x134375A94D9F7110) {
        goto LABEL_6;
      }
      uint64_t v15 = (const char *)v14[1];
      if (v15 != "DynamicString")
      {
        if (strcmp(v15, "DynamicString")) {
          goto LABEL_6;
        }
      }
      uint64_t v25 = a1;
      uint64_t v26 = a2;
      int v27 = (const re::TypeInfo *)a3;
      uint64_t v23 = (re *)this;
      unint64_t v24 = (const re::TypeInfo *)this;
    }
    re::serializeDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(v25, v26, v27, 0, v23, v24, 1);
    return *(unsigned char *)(a1 + 64) == 0;
  }
LABEL_6:
  if ((this[2][6] & 4) == 0)
  {
    BOOL v16 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, a3, 0);
    uint64_t result = 0;
    if (!v16) {
      return result;
    }
    uint64_t v18 = re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(*this + 12), *this[2]);
    if (!v18 || *(_DWORD *)(v18 + 16) >= 2u)
    {
      uint64_t v20 = re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(*this + 12), *this[2]);
      if (v20) {
        unsigned int v21 = *(_DWORD *)(v20 + 16);
      }
      else {
        unsigned int v21 = -1;
      }
      unsigned int v37 = v21;
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, "@version", 0, &v37, 0);
    }
    if (this == (uint64_t **)a6) {
      goto LABEL_23;
    }
    if (*this == *(uint64_t **)a6)
    {
      uint64_t v28 = *this[2];
      uint64_t v29 = **(void **)(a6 + 16);
      if ((unsigned __int16)v28 == (unsigned __int16)v29
        && WORD1(v28) == WORD1(v29)
        && ((v29 ^ v28) & 0xFFFFFF00000000) == 0)
      {
        goto LABEL_23;
      }
    }
    else if (re::areSameTranslatedVersion((re *)this, (const re::TypeInfo *)a6, v19))
    {
LABEL_23:
      re::internal::serializeMembersWithoutVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((unsigned char *)a1, a4, (uint64_t *)this, a7);
LABEL_30:
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(unsigned char *)(a1 + 64) == 0;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    }
    else
    {
      uint64_t v30 = re::TypeInfo::name((re::TypeInfo *)this)[1];
      re::TypeInfo::name((re::TypeInfo *)a6);
      re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v31, v32, v33, v34, v35, v30);
    }
    goto LABEL_30;
  }
  return re::internal::serializeObjectWithOneMember<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((unsigned char *)a1, a2, a3, a4, (uint64_t *)this, (uint64_t *)a6, a7);
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(uint64_t a1, const char *a2, unsigned __int8 *a3)
{
  uint64_t v10 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v10);
    }
    size_t v6 = *(char **)(a1 + 168);
    int v7 = *a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteBool((uint64_t *)v6, v7);
    uint64_t v8 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v8 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v9 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v9);
    }
    size_t v6 = *(char **)(a1 + 168);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v6, a3, 1u);
    uint64_t v7 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v7 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(char *a1, const char **a2)
{
  int v3 = *a2;
  unsigned int v4 = strlen(*a2);
  rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(a1);
  return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)a1, (uint64_t)v3, v4);
}

char *rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(char *result)
{
  uint64_t v1 = *((void *)result + 4);
  if (v1 == *((void *)result + 3))
  {
    result[60] = 1;
  }
  else
  {
    uint64_t v2 = *(void *)(v1 - 16);
    if (v2)
    {
      uint64_t v3 = *(void *)result;
      if (*(unsigned char *)(v1 - 8))
      {
        unsigned int v4 = *(unsigned char **)(v3 + 24);
        if ((uint64_t)(*(void *)(v3 + 32) - (void)v4) <= 0)
        {
          uint64_t result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*(void *)result, 1);
          unsigned int v4 = *(unsigned char **)(v3 + 24);
        }
        *(void *)(v3 + 24) = v4 + 1;
        unsigned char *v4 = 44;
      }
      else
      {
        if (v2) {
          char v5 = 58;
        }
        else {
          char v5 = 44;
        }
        size_t v6 = *(char **)(v3 + 24);
        if ((uint64_t)(*(void *)(v3 + 32) - (void)v6) <= 0)
        {
          char v7 = v5;
          uint64_t result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*(void *)result, 1);
          char v5 = v7;
          size_t v6 = *(char **)(v3 + 24);
        }
        *(void *)(v3 + 24) = v6 + 1;
        *size_t v6 = v5;
      }
    }
    ++*(void *)(v1 - 16);
  }
  return result;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = 6 * a3 + 2;
  uint64_t v8 = *(unsigned char **)(v6 + 24);
  if (*(void *)(v6 + 32) - (void)v8 < v7)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v6, v7);
    uint64_t v6 = *a1;
    uint64_t v8 = *(unsigned char **)(*a1 + 24);
  }
  *(void *)(v6 + 24) = v8 + 1;
  *uint64_t v8 = 34;
  if (a3)
  {
    unint64_t v9 = 0;
    do
    {
      unint64_t v10 = *(unsigned __int8 *)(a2 + v9);
      int v11 = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString(char const*,unsigned int)::escape[v10];
      uint64_t v12 = *(unsigned char **)(*a1 + 24);
      *(void *)(*a1 + 24) = v12 + 1;
      if (v11)
      {
        *uint64_t v12 = 92;
        uint64_t v13 = *(unsigned char **)(*a1 + 24);
        *(void *)(*a1 + 24) = v13 + 1;
        *uint64_t v13 = v11;
        if (v11 == 117)
        {
          uint64_t v14 = *(unsigned char **)(*a1 + 24);
          *(void *)(*a1 + 24) = v14 + 1;
          unsigned char *v14 = 48;
          uint64_t v15 = *(unsigned char **)(*a1 + 24);
          *(void *)(*a1 + 24) = v15 + 1;
          *uint64_t v15 = 48;
          LOBYTE(v15) = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString(char const*,unsigned int)::hexDigits[v10 >> 4];
          BOOL v16 = *(unsigned char **)(*a1 + 24);
          *(void *)(*a1 + 24) = v16 + 1;
          *BOOL v16 = (_BYTE)v15;
          char v17 = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString(char const*,unsigned int)::hexDigits[v10 & 0xF];
          uint64_t v18 = *(unsigned char **)(*a1 + 24);
          *(void *)(*a1 + 24) = v18 + 1;
          unsigned char *v18 = v17;
        }
      }
      else
      {
        *uint64_t v12 = v10;
      }
      ++v9;
    }
    while (v9 < a3);
  }
  uint64_t v19 = *(unsigned char **)(*a1 + 24);
  *(void *)(*a1 + 24) = v19 + 1;
  *uint64_t v19 = 34;
  return 1;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteBool(uint64_t *a1, int a2)
{
  uint64_t v3 = *a1;
  unsigned int v4 = *(unsigned char **)(v3 + 24);
  uint64_t v5 = *(void *)(v3 + 32) - (void)v4;
  if (a2)
  {
    if (v5 <= 3)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v3, 4);
      uint64_t v3 = *a1;
      unsigned int v4 = *(unsigned char **)(*a1 + 24);
    }
    *(void *)(v3 + 24) = v4 + 1;
    unsigned char *v4 = 116;
    uint64_t v6 = *(unsigned char **)(*a1 + 24);
    *(void *)(*a1 + 24) = v6 + 1;
    *uint64_t v6 = 114;
    uint64_t v7 = *(char **)(*a1 + 24);
    *(void *)(*a1 + 24) = v7 + 1;
    char v8 = 117;
  }
  else
  {
    if (v5 <= 4)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v3, 5);
      uint64_t v3 = *a1;
      unsigned int v4 = *(unsigned char **)(*a1 + 24);
    }
    *(void *)(v3 + 24) = v4 + 1;
    unsigned char *v4 = 102;
    unint64_t v9 = *(unsigned char **)(*a1 + 24);
    *(void *)(*a1 + 24) = v9 + 1;
    *unint64_t v9 = 97;
    unint64_t v10 = *(unsigned char **)(*a1 + 24);
    *(void *)(*a1 + 24) = v10 + 1;
    unsigned char *v10 = 108;
    uint64_t v7 = *(char **)(*a1 + 24);
    *(void *)(*a1 + 24) = v7 + 1;
    char v8 = 115;
  }
  *uint64_t v7 = v8;
  int v11 = *(unsigned char **)(*a1 + 24);
  *(void *)(*a1 + 24) = v11 + 1;
  *int v11 = 101;
  return 1;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(uint64_t a1, const char *a2, char *a3)
{
  int v11 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    }
    uint64_t v6 = *(char **)(a1 + 168);
    uint64_t v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt((uint64_t *)v6, v7, v8);
    uint64_t v9 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v9 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt(uint64_t *a1, rapidjson::internal *this, char *a3)
{
  int v3 = this;
  *(void *)&v12[10] = *MEMORY[0x263EF8340];
  if ((this & 0x80000000) != 0)
  {
    uint64_t v5 = v12;
    char v11 = 45;
    int v3 = (rapidjson::internal *)-(int)v3;
  }
  else
  {
    uint64_t v5 = &v11;
  }
  uint64_t v6 = rapidjson::internal::u32toa(v3, v5, a3);
  if (*(void *)(*a1 + 32) - *(void *)(*a1 + 24) < v6 - &v11) {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, v6 - &v11);
  }
  if (&v11 != v6)
  {
    uint64_t v7 = &v11;
    do
    {
      char v8 = *v7++;
      uint64_t v9 = *(unsigned char **)(*a1 + 24);
      *(void *)(*a1 + 24) = v9 + 1;
      *uint64_t v9 = v8;
    }
    while (v7 != v6);
  }
  return 1;
}

unsigned char *rapidjson::internal::u32toa(rapidjson::internal *this, unsigned char *a2, char *a3)
{
  if (this >> 4 <= 0x270)
  {
    if (this < 0x3E8)
    {
      if (this < 0x64)
      {
        if (this < 0xA) {
          goto LABEL_10;
        }
        goto LABEL_9;
      }
    }
    else
    {
      *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * ((unsigned __int16)this / 0x64u));
    }
    *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((2 * ((unsigned __int16)this / 0x64u)) | 1));
LABEL_9:
    *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * ((unsigned __int16)this % 0x64u));
LABEL_10:
    *a2 = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
          + ((unsigned __int16)(2 * ((unsigned __int16)this % 0x64u)) | 1u));
    return a2 + 1;
  }
  if (this < 0x5F5E100)
  {
    unint64_t v3 = (this / 0x7A120uLL) & 0x3FFE;
    if (this < 0x989680)
    {
      if (this <= 0xF423F)
      {
        if (this >> 5 < 0xC35) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }
    }
    else
    {
      *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v3);
    }
    *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + (v3 | 1));
LABEL_15:
    *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + 2 * ((unsigned __int16)(this / 0x2710) % 0x64u));
LABEL_16:
    *a2 = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
          + ((unsigned __int16)(2 * ((unsigned __int16)(this / 0x2710) % 0x64u)) | 1u));
    a2[1] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this % 0x2710 / 0x64));
    a2[2] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((2 * (this % 0x2710 / 0x64)) | 1));
    a2[3] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this % 0x2710 % 0x64));
    a2[4] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((unsigned __int16)(2 * (this % 0x2710 % 0x64)) | 1u));
    return a2 + 5;
  }
  unsigned int v5 = this % 0x5F5E100;
  if (this < 0x3B9ACA00)
  {
    *a2 = this / 0x5F5E100 + 48;
    uint64_t v6 = a2 + 1;
  }
  else
  {
    *a2 = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this / 0x5F5E100));
    uint64_t v6 = a2 + 2;
    a2[1] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this / 0x5F5E100) + 1);
  }
  *(_WORD *)uint64_t v6 = *(_WORD *)((char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + ((v5 / 0x7A120uLL) & 0x3FFE));
  *((_WORD *)v6 + 1) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                       + (unsigned __int16)(v5 / 0x2710) % 0x64u);
  *((_WORD *)v6 + 2) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v5 % 0x2710 / 0x64);
  v6[6] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (v5 % 0x2710 % 0x64));
  unsigned int v4 = v6 + 8;
  v6[7] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
          + (unsigned __int16)(2 * (v5 % 0x2710 % 0x64))
          + 1);
  return v4;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(uint64_t a1, const char *a2, __int16 *a3)
{
  char v11 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    }
    uint64_t v6 = *(char **)(a1 + 168);
    uint64_t v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt((uint64_t *)v6, v7, v8);
    uint64_t v9 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(uint64_t a1, const char *a2, unsigned int *a3)
{
  char v11 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    }
    uint64_t v6 = *(char **)(a1 + 168);
    uint64_t v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt((uint64_t *)v6, v7, v8);
    uint64_t v9 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(uint64_t a1, const char *a2, unint64_t *a3)
{
  char v11 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    }
    uint64_t v6 = *(char **)(a1 + 168);
    unint64_t v7 = *a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt64((uint64_t *)v6, v7, v8);
    uint64_t v9 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v9 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt64(uint64_t *a1, unint64_t this, char *a3)
{
  unint64_t v3 = this;
  *(void *)&v12[20] = *MEMORY[0x263EF8340];
  if ((this & 0x8000000000000000) != 0)
  {
    unsigned int v5 = v12;
    char v11 = 45;
    unint64_t v3 = -(uint64_t)v3;
  }
  else
  {
    unsigned int v5 = &v11;
  }
  uint64_t v6 = rapidjson::internal::u64toa(v3, v5, a3);
  if (*(void *)(*a1 + 32) - *(void *)(*a1 + 24) < v6 - &v11) {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, v6 - &v11);
  }
  if (&v11 != v6)
  {
    unint64_t v7 = &v11;
    do
    {
      char v8 = *v7++;
      uint64_t v9 = *(unsigned char **)(*a1 + 24);
      *(void *)(*a1 + 24) = v9 + 1;
      *uint64_t v9 = v8;
    }
    while (v7 != v6);
  }
  return 1;
}

unsigned char *rapidjson::internal::u64toa(unint64_t this, unsigned char *a2, char *a3)
{
  if (this < 0x5F5E100)
  {
    if (this >> 4 <= 0x270)
    {
      if (this < 0x3E8)
      {
        if (this < 0x64)
        {
          if (this < 0xA) {
            goto LABEL_15;
          }
          goto LABEL_14;
        }
      }
      else
      {
        *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * ((unsigned __int16)this / 0x64u));
      }
      *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
              + ((2 * ((unsigned __int16)this / 0x64u)) | 1));
LABEL_14:
      *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * ((unsigned __int16)this % 0x64u));
LABEL_15:
      *a2 = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((unsigned __int16)(2 * ((unsigned __int16)this % 0x64u)) | 1u));
      return a2 + 1;
    }
    unint64_t v9 = (this / 0x7A120uLL) & 0x3FFE;
    if (this < 0x989680)
    {
      if (this < 0xF4240)
      {
        if (this >> 5 < 0xC35) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }
    }
    else
    {
      *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v9);
    }
    *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + (v9 | 1));
LABEL_26:
    *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + 2 * ((unsigned __int16)(this / 0x2710) % 0x64u));
LABEL_27:
    *a2 = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
          + ((unsigned __int16)(2 * ((unsigned __int16)(this / 0x2710) % 0x64u)) | 1u));
    a2[1] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this % 0x2710 / 0x64));
    a2[2] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((2 * (this % 0x2710 / 0x64)) | 1));
    a2[3] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this % 0x2710 % 0x64));
    a2[4] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + ((unsigned __int16)(2 * (this % 0x2710 % 0x64)) | 1u));
    return a2 + 5;
  }
  if (this < 0x2386F26FC10000)
  {
    unsigned int v3 = this % 0x5F5E100;
    unsigned int v4 = this / 0x5F5E100;
    unint64_t v5 = (v4 / 0x7A120uLL) & 0x3FFE;
    unsigned int v6 = v3 / 0x2710;
    unsigned int v7 = v3 % 0x2710;
    unint64_t v8 = (v3 / 0x7A120uLL) & 0x3FFE;
    if (this < 0x38D7EA4C68000)
    {
      if (this < 0x5AF3107A4000)
      {
        if (this < 0x9184E72A000)
        {
          if (this < 0xE8D4A51000)
          {
            if (this < 0x174876E800)
            {
              if (this < 0x2540BE400)
              {
                if (this < 0x3B9ACA00) {
                  goto LABEL_23;
                }
                goto LABEL_22;
              }
LABEL_21:
              *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + ((2 * (v4 % 0x2710 / 0x64)) | 1));
LABEL_22:
              *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (v4 % 0x2710 % 0x64));
LABEL_23:
              *a2 = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                    + ((unsigned __int16)(2 * (v4 % 0x2710 % 0x64)) | 1u));
              a2[1] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v8);
              a2[2] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + (v8 | 1));
              a2[3] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + 2 * ((unsigned __int16)v6 % 0x64u));
              a2[4] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + ((unsigned __int16)(2 * ((unsigned __int16)v6 % 0x64u)) | 1u));
              a2[5] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + 2 * ((unsigned __int16)v7 / 0x64u));
              a2[6] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + ((2 * ((unsigned __int16)v7 / 0x64u)) | 1));
              a2[7] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + 2 * ((unsigned __int16)v7 % 0x64u));
              a2[8] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                      + ((unsigned __int16)(2 * ((unsigned __int16)v7 % 0x64u)) | 1u));
              return a2 + 9;
            }
LABEL_20:
            *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (v4 % 0x2710 / 0x64));
            goto LABEL_21;
          }
LABEL_19:
          *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                  + ((unsigned __int16)(2 * ((unsigned __int16)(v4 / 0x2710) % 0x64u)) | 1u));
          goto LABEL_20;
        }
LABEL_18:
        *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                + 2 * ((unsigned __int16)(v4 / 0x2710) % 0x64u));
        goto LABEL_19;
      }
    }
    else
    {
      *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v5);
    }
    *a2++ = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + (v5 | 1));
    goto LABEL_18;
  }
  unint64_t v10 = this / 0x2386F26FC10000;
  unint64_t v11 = this % 0x2386F26FC10000;
  if ((this / 0x2386F26FC10000) > 9)
  {
    if (v10 > 0x63)
    {
      unsigned int v14 = (unsigned __int16)v10 / 0x64u;
      if (v10 > 0x3E7)
      {
        uint64_t v15 = 2 * ((unsigned __int16)v10 % 0x64u);
        *(_WORD *)a2 = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v14);
        a2[2] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v15);
        char v16 = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + ((unsigned __int16)v15 & 0xFFFE) + 1);
        uint64_t v12 = a2 + 4;
        a2[3] = v16;
      }
      else
      {
        *a2 = v14 + 48;
        *(_WORD *)(a2 + 1) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                             + (unsigned __int16)v10 % 0x64u);
        uint64_t v12 = a2 + 3;
      }
    }
    else
    {
      *a2 = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (this / 0x2386F26FC10000));
      uint64_t v12 = a2 + 2;
      a2[1] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
              + 2 * (this / 0x2386F26FC10000)
              + 1);
    }
  }
  else
  {
    *a2 = v10 + 48;
    uint64_t v12 = a2 + 1;
  }
  unsigned int v17 = v11 / 0x5F5E100;
  unsigned int v18 = v11 % 0x5F5E100;
  *(_WORD *)uint64_t v12 = *(_WORD *)((char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + ((v17 / 0x7A120uLL) & 0x3FFE));
  *((_WORD *)v12 + 1) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                        + (unsigned __int16)(v17 / 0x2710) % 0x64u);
  *((_WORD *)v12 + 2) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v17 % 0x2710 / 0x64);
  v12[6] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (v17 % 0x2710 % 0x64));
  v12[7] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
           + (unsigned __int16)(2 * (v17 % 0x2710 % 0x64))
           + 1);
  *((_WORD *)v12 + 4) = *(_WORD *)((char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                                 + ((v18 / 0x7A120uLL) & 0x3FFE));
  *((_WORD *)v12 + 5) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
                        + (unsigned __int16)(v18 / 0x2710) % 0x64u);
  *((_WORD *)v12 + 6) = *((_WORD *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + v18 % 0x2710 / 0x64);
  v12[14] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut + 2 * (v18 % 0x2710 % 0x64));
  uint64_t v13 = v12 + 16;
  v12[15] = *((unsigned char *)&rapidjson::internal::GetDigitsLut(void)::cDigitsLut
            + (unsigned __int16)(2 * (v18 % 0x2710 % 0x64))
            + 1);
  return v13;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(uint64_t a1, const char *a2, unsigned __int8 *a3)
{
  unint64_t v11 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    }
    unsigned int v6 = *(char **)(a1 + 168);
    unsigned int v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint((uint64_t *)v6, v7, v8);
    uint64_t v9 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v9 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint(uint64_t *a1, rapidjson::internal *this, char *a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unsigned int v4 = rapidjson::internal::u32toa(this, v9, a3);
  if (*(void *)(*a1 + 32) - *(void *)(*a1 + 24) < v4 - v9) {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, v4 - v9);
  }
  if (v9 != v4)
  {
    unint64_t v5 = v9;
    do
    {
      char v6 = *v5++;
      unsigned int v7 = *(unsigned char **)(*a1 + 24);
      *(void *)(*a1 + 24) = v7 + 1;
      *unsigned int v7 = v6;
    }
    while (v5 != v4);
  }
  return 1;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(uint64_t a1, const char *a2, unsigned __int16 *a3)
{
  unint64_t v11 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    }
    char v6 = *(char **)(a1 + 168);
    unsigned int v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint((uint64_t *)v6, v7, v8);
    uint64_t v9 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(uint64_t a1, const char *a2, uint64_t a3, unsigned int *a4, char a5)
{
  unsigned int v14 = a2;
  int v5 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v14);
    }
    uint64_t v9 = *(char **)(a1 + 168);
    uint64_t v10 = (rapidjson::internal *)*a4;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v9);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint((uint64_t *)v9, v10, v11);
    if ((a5 & 2) == 0)
    {
      uint64_t v12 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
      ++*(void *)(v12 - 16);
    }
  }
  return v5 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(uint64_t a1, const char *a2, rapidjson::internal **a3)
{
  unint64_t v11 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    }
    char v6 = *(char **)(a1 + 168);
    unsigned int v7 = *a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint64((uint64_t *)v6, v7, v8);
    uint64_t v9 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v9 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint64(uint64_t *a1, rapidjson::internal *this, char *a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unsigned int v4 = rapidjson::internal::u64toa((unint64_t)this, v9, a3);
  if (*(void *)(*a1 + 32) - *(void *)(*a1 + 24) < v4 - v9) {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, v4 - v9);
  }
  if (v9 != v4)
  {
    int v5 = v9;
    do
    {
      char v6 = *v5++;
      unsigned int v7 = *(unsigned char **)(*a1 + 24);
      *(void *)(*a1 + 24) = v7 + 1;
      *unsigned int v7 = v6;
    }
    while (v5 != v4);
  }
  return 1;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(uint64_t a1, const char *a2, uint64_t a3, float *a4, char a5)
{
  char v16 = a2;
  int v5 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v16);
    }
    float v9 = *a4;
    uint64_t v10 = *(char **)(a1 + 168);
    if (fabsf(v9) != INFINITY)
    {
      double v14 = v9;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble((uint64_t)v10, v14);
      if ((a5 & 2) != 0) {
        return v5 == 0;
      }
      goto LABEL_8;
    }
    unint64_t v11 = "-Infinity";
    if (v9 > 0.0) {
      unint64_t v11 = "Infinity";
    }
    uint64_t v15 = v11;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(v10, &v15);
    if ((a5 & 2) == 0)
    {
LABEL_8:
      uint64_t v12 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
      ++*(void *)(v12 - 16);
    }
  }
  return v5 == 0;
}

BOOL rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble(uint64_t a1, double a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)&a2 & 0x7FF0000000000000;
  if ((*(void *)&a2 & 0x7FF0000000000000) != 0x7FF0000000000000)
  {
    unsigned int v4 = rapidjson::internal::dtoa((rapidjson::internal *)v9, a2, (char *)*(unsigned int *)(a1 + 56));
    if (*(void *)(*(void *)a1 + 32) - *(void *)(*(void *)a1 + 24) < v4 - v9) {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*(void *)a1, v4 - v9);
    }
    if (v9 != v4)
    {
      int v5 = v9;
      do
      {
        char v6 = *v5++;
        unsigned int v7 = *(unsigned char **)(*(void *)a1 + 24);
        *(void *)(*(void *)a1 + 24) = v7 + 1;
        *unsigned int v7 = v6;
      }
      while (v5 != v4);
    }
  }
  return v2 != 0x7FF0000000000000;
}

char *rapidjson::internal::dtoa(rapidjson::internal *this, double a2, char *a3)
{
  int v3 = this;
  unint64_t v4 = *(void *)&a2;
  if ((*(void *)&a2 & 0x7FFFFFFFFFFFFFFFLL) != 0)
  {
    int v5 = (int)a3;
    if (a2 < 0.0)
    {
      *(unsigned char *)this = 45;
      int v3 = (rapidjson::internal *)((char *)this + 1);
      unint64_t v4 = *(void *)&a2 ^ 0x8000000000000000;
    }
    unsigned int v23 = 0;
    if (((v4 >> 52) & 0x7FF) != 0) {
      unint64_t v6 = v4 & 0xFFFFFFFFFFFFFLL | 0x10000000000000;
    }
    else {
      unint64_t v6 = v4 & 0xFFFFFFFFFFFFFLL;
    }
    if (((v4 >> 52) & 0x7FF) != 0) {
      int v7 = ((v4 >> 52) & 0x7FF) - 1075;
    }
    else {
      int v7 = -1074;
    }
    uint64_t v30 = (2 * (v6 & 0x1FFFFFFFFFFFFFLL)) | 1;
    int v31 = v7 - 1;
    uint64_t v8 = rapidjson::internal::DiyFp::NormalizeBoundary((rapidjson::internal::DiyFp *)&v30);
    uint64_t v10 = 2 * v6 - 1;
    if (v6 == 0x10000000000000) {
      char v11 = -2;
    }
    else {
      char v11 = -1;
    }
    if (v6 == 0x10000000000000) {
      uint64_t v10 = 0x3FFFFFFFFFFFFFLL;
    }
    uint64_t v28 = v8;
    int v29 = v9;
    uint64_t v30 = v10 << (v11 + v7 - v9);
    int v31 = v9;
    double v12 = (double)(-61 - v9) * 0.301029996 + 347.0;
    int v13 = (int)v12;
    if (v12 - (double)(int)v12 > 0.0) {
      ++v13;
    }
    int v14 = (v13 >> 3) + 1;
    int v22 = 348 - 8 * v14;
    uint64_t v15 = rapidjson::internal::GetCachedPowerByIndex(unsigned long)::kCachedPowers_F[v14];
    uint64_t v16 = rapidjson::internal::GetCachedPowerByIndex(unsigned long)::kCachedPowers_E[v14];
    v27[0] = v15;
    v27[1] = v16;
    LODWORD(v16) = __clz(v6);
    unint64_t v24 = v6 << v16;
    uint64_t v25 = (v7 - v16);
    v26[0] = rapidjson::internal::DiyFp::operator*(&v24, v27);
    v26[1] = v17;
    unint64_t v18 = rapidjson::internal::DiyFp::operator*(&v28, v27);
    uint64_t v25 = v19;
    unint64_t v20 = rapidjson::internal::DiyFp::operator*(&v30, v27);
    unint64_t v24 = v18 - 1;
    rapidjson::internal::DigitGen(v26, (uint64_t *)&v24, v18 - 1 + ~v20, (uint64_t)v3, (int *)&v23, &v22);
    return rapidjson::internal::Prettify(v3, (char *)v23, v22, v5);
  }
  else
  {
    if ((*(void *)&a2 & 0x8000000000000000) != 0)
    {
      *(unsigned char *)this = 45;
      int v3 = (rapidjson::internal *)((char *)this + 1);
    }
    *(_WORD *)int v3 = 11824;
    *((unsigned char *)v3 + 2) = 48;
    return (char *)v3 + 3;
  }
}

char *rapidjson::internal::Prettify(rapidjson::internal *this, char *a2, int a3, int a4)
{
  int v6 = (int)a2;
  int v8 = a3 + a2;
  if ((a3 & 0x80000000) == 0 && v8 <= 21)
  {
    if (a3)
    {
      int v9 = (char *)this + (int)a2;
      if (v8 <= (int)a2 + 1) {
        int v10 = a2 + 1;
      }
      else {
        int v10 = a3 + a2;
      }
      memset(v9, 48, (v10 + ~a2) + 1);
    }
    char v11 = (char *)this + v8;
    __int16 v12 = 12334;
    goto LABEL_9;
  }
  unsigned int v14 = v8 - 1;
  if ((v8 - 1) <= 0x14)
  {
    uint64_t v15 = (v8 + 1);
    memmove((char *)this + v15, (char *)this + v8, -a3);
    *((unsigned char *)this + v8) = 46;
    if (a4 + a3 >= 0) {
      return (char *)this + v6 + 1;
    }
    if (a4 >= 2)
    {
      unsigned int v20 = v8 + a4;
      while (*((unsigned char *)this + v20) == 48)
      {
        if ((int)--v20 <= (int)v15) {
          goto LABEL_32;
        }
      }
      return (char *)this + (int)(v20 + 1);
    }
LABEL_32:
    uint64_t v21 = (v8 + 2);
    return (char *)this + v21;
  }
  if (v8 == 0 || v8 >= 0xFFFFFFFB)
  {
    uint64_t v16 = 2 - v8;
    memmove((char *)this + v16, this, (int)a2);
    *(_WORD *)this = 11824;
    if (v8 < 0)
    {
      if ((int)v16 <= 3) {
        int v17 = 3;
      }
      else {
        int v17 = 2 - v8;
      }
      memset((char *)this + 2, 48, (v17 - 2));
    }
    if (-a3 <= a4)
    {
      uint64_t v21 = v16 + v6;
      return (char *)this + v21;
    }
    if (a4 >= 2)
    {
      for (unsigned int i = a4 + 2; ; --i)
      {
        int v19 = i - 1;
        if (*((unsigned char *)this + i - 1) != 48) {
          break;
        }
        if (v19 < 4) {
          return (char *)this + 3;
        }
      }
      return (char *)this + i;
    }
    return (char *)this + 3;
  }
  if (v8 < -a4)
  {
    *(_WORD *)this = 11824;
    *((unsigned char *)this + 2) = 48;
    return (char *)this + 3;
  }
  if (a2 == 1)
  {
    *((unsigned char *)this + 1) = 101;
    if ((v14 & 0x80000000) == 0)
    {
      char v11 = (char *)this + 2;
      goto LABEL_44;
    }
    char v11 = (char *)this + 3;
    *((unsigned char *)this + 2) = 45;
  }
  else
  {
    memmove((char *)this + 2, (char *)this + 1, (int)a2 - 1);
    *((unsigned char *)this + 1) = 46;
    *((unsigned char *)this + v6 + 1) = 101;
    char v11 = (char *)this + v6 + 2;
    if ((v14 & 0x80000000) == 0) {
      goto LABEL_44;
    }
    *v11++ = 45;
  }
  unsigned int v14 = 1 - v8;
LABEL_44:
  if (v14 < 0x64)
  {
    if (v14 >= 0xA)
    {
      __int16 v12 = rapidjson::internal::GetDigitsLut(void)::cDigitsLut[v14];
LABEL_9:
      *(_WORD *)char v11 = v12;
      return v11 + 2;
    }
    *char v11 = v14 + 48;
    return v11 + 1;
  }
  else
  {
    *char v11 = v14 / 0x64 + 48;
    *(_WORD *)(v11 + 1) = rapidjson::internal::GetDigitsLut(void)::cDigitsLut[v14 % 0x64];
    return v11 + 3;
  }
}

unint64_t rapidjson::internal::DiyFp::operator*(void *a1, void *a2)
{
  uint64_t v2 = HIDWORD(*a1);
  uint64_t v3 = HIDWORD(*a2);
  unint64_t v4 = v3 * (unint64_t)*a1;
  unint64_t v5 = *a2 * (unint64_t)v2;
  return HIDWORD(v5)
       + v3 * (unint64_t)v2
       + HIDWORD(v4)
       + ((((*a2 * (unint64_t)*a1) >> 32)
         + v5
         + v4
         + 0x80000000) >> 32);
}

unint64_t rapidjson::internal::DigitGen(uint64_t *a1, uint64_t *a2, unint64_t a3, uint64_t a4, int *a5, _DWORD *a6)
{
  int v6 = -*((_DWORD *)a2 + 2);
  unint64_t v7 = 1 << -*((unsigned char *)a2 + 8);
  uint64_t v8 = *a2;
  uint64_t v9 = *a1;
  unint64_t v10 = *a2 - *a1;
  unint64_t result = (unint64_t)*a2 >> -*((unsigned char *)a2 + 8);
  unint64_t v12 = (v7 - 1) & *a2;
  if (result < 0x5F5E100) {
    int v13 = 8;
  }
  else {
    int v13 = 9;
  }
  if (result >= 0x989680) {
    int v14 = v13;
  }
  else {
    int v14 = 7;
  }
  if (result >= 0xF4240) {
    int v15 = v14;
  }
  else {
    int v15 = 6;
  }
  if (result >= 0x186A0) {
    int v16 = v15;
  }
  else {
    int v16 = 5;
  }
  if (result >> 4 >= 0x271) {
    int v17 = v16;
  }
  else {
    int v17 = 4;
  }
  if (result >= 0x3E8) {
    int v18 = v17;
  }
  else {
    int v18 = 3;
  }
  if (result >= 0x64) {
    int v19 = v18;
  }
  else {
    int v19 = 2;
  }
  if (result >= 0xA) {
    int v20 = v19;
  }
  else {
    int v20 = 1;
  }
  *a5 = 0;
  while (2)
  {
    if (v20 <= 0)
    {
      uint64_t v35 = rapidjson::internal::DigitGen(rapidjson::internal::DiyFp const&,rapidjson::internal::DiyFp const&,unsigned long long,char *,int *,int *)::kPow10;
      int v36 = 1;
      do
      {
        unint64_t v37 = a3;
        unint64_t v38 = 10 * v12;
        unint64_t result = (v38 >> v6);
        int v39 = *a5;
        if ((v38 >> v6)) {
          BOOL v40 = 0;
        }
        else {
          BOOL v40 = v39 == 0;
        }
        if (!v40)
        {
          unint64_t result = (v39 + 1);
          *a5 = result;
          *(unsigned char *)(a4 + v39) = (v38 >> v6) + 48;
        }
        a3 *= 10;
        unint64_t v12 = v38 & (v7 - 1);
        ++v35;
        --v36;
      }
      while (10 * v37 <= v12);
      *a6 = *a6 + v36 - 1;
      if (v36 < -18) {
        uint64_t v41 = 0;
      }
      else {
        uint64_t v41 = *v35;
      }
      if (10 * v37 - v12 >= v7)
      {
        unint64_t v42 = v41 * v10;
        if (v12 < v41 * v10)
        {
          uint64_t v43 = *a5 - 1;
          uint64_t v44 = -(uint64_t)v12;
          uint64_t v45 = -(uint64_t)(v41 * v10);
          unint64_t v46 = v7 + v12;
          unint64_t v47 = 10 * v37 - v7;
          do
          {
            if (v46 >= v42 && v42 + v44 <= v45 + v46) {
              break;
            }
            --*(unsigned char *)(a4 + v43);
            if (v46 >= v42) {
              break;
            }
            unint64_t v48 = v47 + v44;
            v44 -= v7;
            v46 += v7;
          }
          while (v48 >= v7);
        }
      }
    }
    else
    {
      --v20;
      unint64_t v21 = 0;
      switch(v20)
      {
        case 0:
          goto LABEL_39;
        case 1:
          unsigned int v22 = result / 0xA;
          unint64_t v21 = result % 0xA;
          goto LABEL_33;
        case 2:
          unsigned int v22 = result / 0x64;
          unint64_t v21 = result % 0x64;
          goto LABEL_33;
        case 3:
          unsigned int v22 = result / 0x3E8;
          unint64_t v21 = result % 0x3E8;
          goto LABEL_33;
        case 4:
          unsigned int v22 = result / 0x2710;
          unint64_t v21 = result % 0x2710;
LABEL_33:
          LODWORD(result) = v22;
          goto LABEL_39;
        case 5:
          unsigned int v24 = result / 0x186A0;
          unint64_t v21 = result % 0x186A0;
          goto LABEL_38;
        case 6:
          unsigned int v24 = result / 0xF4240;
          unint64_t v21 = result % 0xF4240;
          goto LABEL_38;
        case 7:
          unsigned int v24 = result / 0x989680;
          unint64_t v21 = result % 0x989680;
          goto LABEL_38;
        case 8:
          unsigned int v24 = result / 0x5F5E100;
          unint64_t v21 = result % 0x5F5E100;
LABEL_38:
          LODWORD(result) = v24;
LABEL_39:
          int v25 = result;
          int v23 = *a5;
          unint64_t result = v21;
          if (!v25) {
            goto LABEL_40;
          }
          goto LABEL_42;
        default:
          int v23 = *a5;
LABEL_40:
          if (v23)
          {
            LOBYTE(v25) = 0;
LABEL_42:
            *a5 = v23 + 1;
            *(unsigned char *)(a4 + v23) = v25 + 48;
          }
          unint64_t v26 = (unint64_t)result << v6;
          if (a3 < v26 + v12) {
            continue;
          }
          *a6 += v20;
          if (v26 + v12 < v10)
          {
            unint64_t v27 = rapidjson::internal::DigitGen(rapidjson::internal::DiyFp const&,rapidjson::internal::DiyFp const&,unsigned long long,char *,int *,int *)::kPow10[v20] << v6;
            if (a3 - (v26 + v12) >= v27)
            {
              uint64_t v28 = *a5 - 1;
              unint64_t v29 = v10 - v12;
              uint64_t v30 = -(uint64_t)v26;
              uint64_t v31 = v9 - v8;
              unint64_t v32 = v12 + v27 + v26;
              unint64_t v33 = a3 - v12 - v27;
              do
              {
                if (v32 >= v10 && v29 + v30 <= v31 + v32) {
                  break;
                }
                --*(unsigned char *)(a4 + v28);
                if (v32 >= v10) {
                  break;
                }
                unint64_t v34 = v33 + v30;
                v30 -= v27;
                v32 += v27;
              }
              while (v34 >= v27);
            }
          }
          break;
      }
    }
    return result;
  }
}

uint64_t rapidjson::internal::DiyFp::NormalizeBoundary(rapidjson::internal::DiyFp *this)
{
  uint64_t v2 = *(void *)this;
  unint64_t v1 = *((void *)this + 1);
  if ((*(void *)this & 0x20000000000000) == 0)
  {
    unint64_t v3 = __clz(v2 & 0x1FFFFFFFFFFFFFLL) - 10;
    unint64_t v4 = v3;
    do
    {
      unint64_t v1 = (v1 - 1) | v1 & 0xFFFFFFFF00000000;
      --v4;
    }
    while (v4);
    v2 <<= v3;
  }
  return v2 << 10;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(uint64_t a1, const char *a2, uint64_t a3, double *a4, char a5)
{
  int v15 = a2;
  int v5 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v15);
    }
    double v9 = *a4;
    unint64_t v10 = *(char **)(a1 + 168);
    if (fabs(v9) != INFINITY)
    {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble((uint64_t)v10, v9);
      if ((a5 & 2) != 0) {
        return v5 == 0;
      }
      goto LABEL_8;
    }
    char v11 = "-Infinity";
    if (v9 > 0.0) {
      char v11 = "Infinity";
    }
    int v14 = v11;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(v10, &v14);
    if ((a5 & 2) == 0)
    {
LABEL_8:
      uint64_t v12 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
      ++*(void *)(v12 - 16);
    }
  }
  return v5 == 0;
}

uint64_t re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, re::TypeInfo *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v15 = **((void **)a5 + 2);
    uint64_t v16 = **((void **)a6 + 2);
    if ((unsigned __int16)v15 != (unsigned __int16)v16
      || ((v18 = WORD1(v15) == WORD1(v16), uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000, v18) ? (v18 = v17 == 0) : (v18 = 0),
          !v18))
    {
      BOOL v14 = 1;
      if (!a7) {
        goto LABEL_11;
      }
      goto LABEL_15;
    }
LABEL_14:
    BOOL v14 = 0;
    if (!a7) {
      goto LABEL_11;
    }
LABEL_15:
    size_t v23 = 0;
    BOOL v22 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v23, 0);
    uint64_t result = 0;
    if (!v22) {
      return result;
    }
    if (v23) {
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    }
    unint64_t v21 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_19;
  }
  BOOL v14 = !re::areSameTranslatedVersion(a5, a6, a3);
  if (a7) {
    goto LABEL_15;
  }
LABEL_11:
  uint64_t result = re::internal::findEnumConstantToSerialize<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a4, a5, a6, v14);
  if (!result) {
    return result;
  }
  int v20 = *(const char **)(result + 16);
  size_t v23 = strlen(v20);
  if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v23, 0))
  {
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, (uint64_t)v20, 0);
    unint64_t v21 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_19:
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString(v21);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(uint64_t a1, const char *a2, uint64_t a3, uint64_t *a4, int a5)
{
  uint64_t v17 = a2;
  int v5 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v17);
    }
    uint64_t v9 = *a4;
    if (!*a4)
    {
      unint64_t v10 = *(char **)(a1 + 168);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v10);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v10, (uint64_t)"", 0);
      uint64_t v9 = *a4;
    }
    LOBYTE(v12) = 8;
    DWORD1(v12) = a5 & 0xFFFFFFDF;
    *((void *)&v12 + 1) = v17;
    uint64_t v13 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v14 = v9;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v12);
  }
  return v5 == 0;
}

uint64_t re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(uint64_t result, uint64_t a2, char a3)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(*(void *)(result + 128) + 48 * *(void *)(result + 112) - 24);
    unint64_t v7 = *(char **)(result + 168);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v7);
    uint64_t result = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v7, a2, v6);
    if ((a3 & 2) == 0)
    {
      uint64_t v8 = *(void *)(v5 + 128) + 48 * *(void *)(v5 + 112);
      *(void *)(v8 - 16) += v6;
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = (uint64_t)result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == *(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 24))
    {
      uint64_t result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 8);
      uint64_t v2 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      ++*(void *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if (v6) {
        unint64_t v3 = *(unsigned char **)&v7[7];
      }
      else {
        unint64_t v3 = v7;
      }
      uint64_t v4 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize string \"%s\". Expected number of characters: %lld. Actual number of characters: %lld.", (re::DynamicString *)v8, v3, *(void *)(v4 - 24), *(void *)(v4 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(void *)&v8[0])
      {
        if (BYTE8(v8[0])) {
          (*(void (**)(void))(**(void **)&v8[0] + 40))();
        }
        memset(v8, 0, sizeof(v8));
      }
      uint64_t result = v5;
      if (v5)
      {
        if (v6) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v5 + 40))();
        }
      }
    }
  }
  return result;
}

uint64_t re::internal::findEnumConstantToSerialize<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, re::TypeInfo *a3, re::internal *this, re::TypeInfo *a5, int a6)
{
  if (*(_DWORD *)(*((void *)this + 2) + 8) >= 9u)
  {
    uint64_t v38 = re::TypeInfo::name(this)[1];
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Enum type \"%s\" has invalid size: %zu bytes", v9, v10, v11, v12, v13, v38);
    return 0;
  }
  unsigned int EnumConstantIndex = re::internal::getEnumConstantIndex(this, a3, a3);
  if ((EnumConstantIndex & 0x80000000) != 0)
  {
    uint64_t __dst = 0;
    memcpy(&__dst, a3, *(unsigned int *)(*((void *)this + 2) + 8));
    char v30 = __dst;
    re::TypeInfo::name(this);
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v31, v32, v33, v34, v35, v30);
    return 0;
  }
  unsigned int v18 = EnumConstantIndex;
  if (!a6)
  {
    uint64_t v36 = re::TypeInfo::enumConstants(this);
    if (v37 > v18) {
      return v36 + 24 * v18;
    }
    re::internal::assertLog((re::internal *)6, v37, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v18, v37);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  int v19 = *(re::internal::TypeTranslationTable **)(*(void *)a5 + 856);
  if (!v19 || (uint64_t result = re::internal::TypeTranslationTable::translateRuntimeEnum(v19, this, v18, a5)) == 0)
  {
    uint64_t v21 = re::TypeInfo::enumConstants(this);
    uint64_t v23 = v18;
    if (v22 > v18)
    {
      uint64_t v24 = *(void *)(v21 + 24 * v18 + 16);
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Runtime enum constant \"%s\" does not exist in serialized type \"%s\".", v25, v26, v27, v28, v29, v24);
      return 0;
    }
LABEL_15:
    re::internal::assertLog((re::internal *)6, v22, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v23, v22);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(uint64_t a1, const char *a2, unsigned char *a3)
{
  uint64_t v13 = a2;
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v13);
    }
    if (*a3)
    {
      uint64_t v5 = 1;
    }
    else
    {
      char v6 = *(char **)(a1 + 168);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull((uint64_t *)v6);
      uint64_t v5 = *a3;
    }
    LOBYTE(v8) = 3;
    DWORD1(v8) = 0;
    *((void *)&v8 + 1) = v13;
    uint64_t v9 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v10 = v5;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v8);
  }
  return result;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull(uint64_t *a1)
{
  uint64_t v2 = *a1;
  unint64_t v3 = *(unsigned char **)(v2 + 24);
  if ((uint64_t)(*(void *)(v2 + 32) - (void)v3) <= 3)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v2, 4);
    uint64_t v2 = *a1;
    unint64_t v3 = *(unsigned char **)(*a1 + 24);
  }
  *(void *)(v2 + 24) = v3 + 1;
  *unint64_t v3 = 110;
  uint64_t v4 = *(unsigned char **)(*a1 + 24);
  *(void *)(*a1 + 24) = v4 + 1;
  unsigned char *v4 = 117;
  uint64_t v5 = *(unsigned char **)(*a1 + 24);
  *(void *)(*a1 + 24) = v5 + 1;
  *uint64_t v5 = 108;
  char v6 = *(unsigned char **)(*a1 + 24);
  *(void *)(*a1 + 24) = v6 + 1;
  *char v6 = 108;
  return 1;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(uint64_t a1, const char *a2, uint64_t a3, uint64_t *a4, int a5)
{
  uint64_t v16 = a2;
  int v5 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v16);
    }
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(*(void *)(a1 + 168));
    uint64_t v9 = *a4;
    LOBYTE(v11) = 5;
    DWORD1(v11) = a5 & 0xFFFFFFDF;
    *((void *)&v11 + 1) = v16;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v9;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
  }
  return v5 == 0;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endArray(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == *(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 24))
    {
      uint64_t v2 = (uint64_t *)*((void *)result + 21);
      v2[4] -= 16;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndArray(v2);
      double result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 5);
      uint64_t v3 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      ++*(void *)(v3 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v6);
      if (v7) {
        uint64_t v4 = *(unsigned char **)&v8[7];
      }
      else {
        uint64_t v4 = v8;
      }
      uint64_t v5 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)v9, v4, *(void *)(v5 - 24), *(void *)(v5 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v9);
      if (*(void *)&v9[0])
      {
        if (BYTE8(v9[0])) {
          (*(void (**)(void))(**(void **)&v9[0] + 40))();
        }
        memset(v9, 0, sizeof(v9));
      }
      double result = v6;
      if (v6)
      {
        if (v7) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v6 + 40))();
        }
      }
    }
  }
  return result;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(uint64_t a1)
{
  rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix((char *)a1);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(a1 + 40) - v2 <= 15)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Level>(a1 + 8, 1);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  *(void *)(a1 + 32) = v2 + 16;
  *(void *)uint64_t v2 = 0;
  *(unsigned char *)(v2 + 8) = 1;
  return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteStartArray((uint64_t *)a1);
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteStartArray(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(unsigned char **)(*a1 + 24);
  if ((uint64_t)(*(void *)(*a1 + 32) - (void)v2) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, 1);
    uint64_t v2 = *(unsigned char **)(v1 + 24);
  }
  *(void *)(v1 + 24) = v2 + 1;
  *uint64_t v2 = 91;
  return 1;
}

char *rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Level>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 16);
  if (v4)
  {
    size_t v5 = *(void *)(a1 + 32) - (void)v4;
    unint64_t v6 = v5 + ((v5 + 1) >> 1);
    char v7 = *(re::internal::RapidJSONAllocator **)a1;
  }
  else
  {
    char v7 = *(re::internal::RapidJSONAllocator **)a1;
    if (*(void *)a1)
    {
      uint64_t v4 = 0;
    }
    else
    {
      char v7 = (re::internal::RapidJSONAllocator *)(*(uint64_t (**)(void *, uint64_t, void))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                                                  + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 1, 0);
      *(void *)a1 = v7;
      *(void *)(a1 + 8) = v7;
      uint64_t v4 = *(void **)(a1 + 16);
    }
    unint64_t v6 = *(void *)(a1 + 40);
    size_t v5 = *(void *)(a1 + 32) - (void)v4;
  }
  uint64_t v8 = *(void *)(a1 + 24) - (void)v4;
  if (v6 <= v8 + 16 * a2) {
    size_t v9 = v8 + 16 * a2;
  }
  else {
    size_t v9 = v6;
  }
  double result = (char *)re::internal::RapidJSONAllocator::Realloc(v7, v4, v5, v9);
  *(void *)(a1 + 16) = result;
  *(void *)(a1 + 24) = &result[v8];
  *(void *)(a1 + 32) = &result[v9];
  return result;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndArray(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(unsigned char **)(*a1 + 24);
  if ((uint64_t)(*(void *)(*a1 + 32) - (void)v2) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, 1);
    uint64_t v2 = *(unsigned char **)(v1 + 24);
  }
  *(void *)(v1 + 24) = v2 + 1;
  *uint64_t v2 = 93;
  return 1;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v44),
        re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45),
        v43[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v43))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v45);
  re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v43);
  if (v19)
  {
    int v20 = (void (*)(uint64_t, __n128 *, void, uint64_t, unsigned char *, unsigned char *, void))v19;
    BOOL v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    unint64_t v23 = (*(uint64_t (**)(uint64_t))(v41 + 88))(a4);
    if (v23)
    {
      unint64_t v48 = 0;
      uint64_t v45 = 0;
      unint64_t v46 = 0;
      int v47 = 0;
      uint64_t v44 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v44, v23);
      ++v47;
      uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v41 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v41 + 120))())
      {
        do
        {
          uint64_t v25 = (*(uint64_t (**)(uint64_t))(v41 + 128))(v24);
          uint64_t v26 = (*(uint64_t (**)(uint64_t))(v41 + 136))(v24);
          v49[0].n128_u64[0] = v25;
          v49[0].n128_u64[1] = v26;
          __n128 v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v44, v49);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v41 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v41 + 144))(v24, v18);
      unint64_t v28 = 126 - 2 * __clz(v46);
      if (v46) {
        uint64_t v29 = v28;
      }
      else {
        uint64_t v29 = 0;
      }
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(v48, (unint64_t **)&v48[v46], v29, 1);
      if (v46)
      {
        char v30 = v48;
        uint64_t v31 = &v48[v46];
        do
        {
          uint64_t v32 = *(unint64_t **)v30;
          uint64_t v33 = *((void *)v30++ + 1);
          *(unsigned char *)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v49, *v32) = 0;
          v20(a1, v49, 0, v33, v43, v42, 0);
        }
        while (v30 != v31);
      }
      if (v44)
      {
        if (v48) {
          (*(void (**)(void))(*(void *)v44 + 40))();
        }
      }
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v34 = re::TypeInfo::name((re::TypeInfo *)v43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v35, v36, v37, v38, v39, v34[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v44),
        re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45),
        v43[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v43))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v45);
  re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v43);
  if (v19)
  {
    int v20 = (void (*)(uint64_t, __n128 *, void, uint64_t, unsigned char *, unsigned char *, void))v19;
    BOOL v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    unint64_t v23 = (*(uint64_t (**)(uint64_t))(v41 + 88))(a4);
    if (v23)
    {
      unint64_t v48 = 0;
      uint64_t v45 = 0;
      unint64_t v46 = 0;
      int v47 = 0;
      uint64_t v44 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v44, v23);
      ++v47;
      uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v41 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v41 + 120))())
      {
        do
        {
          uint64_t v25 = (*(uint64_t (**)(uint64_t))(v41 + 128))(v24);
          uint64_t v26 = (*(uint64_t (**)(uint64_t))(v41 + 136))(v24);
          v49[0].n128_u64[0] = v25;
          v49[0].n128_u64[1] = v26;
          __n128 v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v44, v49);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v41 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v41 + 144))(v24, v18);
      unint64_t v28 = 126 - 2 * __clz(v46);
      if (v46) {
        uint64_t v29 = v28;
      }
      else {
        uint64_t v29 = 0;
      }
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(v48, (unsigned int **)&v48[v46], v29, 1);
      if (v46)
      {
        char v30 = v48;
        uint64_t v31 = &v48[v46];
        do
        {
          uint64_t v32 = *(unsigned int **)v30;
          uint64_t v33 = *((void *)v30++ + 1);
          *(unsigned char *)std::__itoa::__base_10_u32[abi:nn180100](v49, *v32) = 0;
          v20(a1, v49, 0, v33, v43, v42, 0);
        }
        while (v30 != v31);
      }
      if (v44)
      {
        if (v48) {
          (*(void (**)(void))(*(void *)v44 + 40))();
        }
      }
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v34 = re::TypeInfo::name((re::TypeInfo *)v43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v35, v36, v37, v38, v39, v34[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v44),
        re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45),
        v43[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v43))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v45);
  re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v43);
  if (v19)
  {
    int v20 = (void (*)(uint64_t, __n128 *, void, unsigned __int16 *, unsigned char *, unsigned char *, void))v19;
    BOOL v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    unint64_t v23 = (*(uint64_t (**)(uint64_t))(v41 + 88))(a4);
    if (v23)
    {
      unint64_t v48 = 0;
      uint64_t v45 = 0;
      unint64_t v46 = 0;
      int v47 = 0;
      uint64_t v44 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v44, v23);
      ++v47;
      uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v41 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v41 + 120))())
      {
        do
        {
          uint64_t v25 = (*(uint64_t (**)(uint64_t))(v41 + 128))(v24);
          uint64_t v26 = (*(uint64_t (**)(uint64_t))(v41 + 136))(v24);
          v49[0].n128_u64[0] = v25;
          v49[0].n128_u64[1] = v26;
          __n128 v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v44, v49);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v41 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v41 + 144))(v24, v18);
      unint64_t v28 = 126 - 2 * __clz(v46);
      if (v46) {
        uint64_t v29 = v28;
      }
      else {
        uint64_t v29 = 0;
      }
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(v48, &v48[2 * v46], v29, 1);
      if (v46)
      {
        char v30 = v48;
        uint64_t v31 = &v48[2 * v46];
        do
        {
          uint64_t v32 = *v30;
          uint64_t v33 = v30[1];
          v30 += 2;
          *(unsigned char *)std::__itoa::__base_10_u32[abi:nn180100](v49, *v32) = 0;
          v20(a1, v49, 0, v33, v43, v42, 0);
        }
        while (v30 != v31);
      }
      if (v44)
      {
        if (v48) {
          (*(void (**)(void))(*(void *)v44 + 40))();
        }
      }
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v34 = re::TypeInfo::name((re::TypeInfo *)v43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v35, v36, v37, v38, v39, v34[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v44),
        re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45),
        v43[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v43))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)&v45);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v44);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v45);
  re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v43);
  if (v19)
  {
    int v20 = (void (*)(uint64_t, __n128 *, void, unsigned __int8 *, unsigned char *, unsigned char *, void))v19;
    BOOL v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    unint64_t v23 = (*(uint64_t (**)(uint64_t))(v41 + 88))(a4);
    if (v23)
    {
      unint64_t v48 = 0;
      uint64_t v45 = 0;
      unint64_t v46 = 0;
      int v47 = 0;
      uint64_t v44 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v44, v23);
      ++v47;
      uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v41 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v41 + 120))())
      {
        do
        {
          uint64_t v25 = (*(uint64_t (**)(uint64_t))(v41 + 128))(v24);
          uint64_t v26 = (*(uint64_t (**)(uint64_t))(v41 + 136))(v24);
          v49[0].n128_u64[0] = v25;
          v49[0].n128_u64[1] = v26;
          __n128 v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v44, v49);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v41 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v41 + 144))(v24, v18);
      unint64_t v28 = 126 - 2 * __clz(v46);
      if (v46) {
        uint64_t v29 = v28;
      }
      else {
        uint64_t v29 = 0;
      }
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(v48, &v48[2 * v46], v29, 1);
      if (v46)
      {
        char v30 = v48;
        uint64_t v31 = &v48[2 * v46];
        do
        {
          uint64_t v32 = *v30;
          uint64_t v33 = v30[1];
          v30 += 2;
          *(unsigned char *)std::__itoa::__base_10_u32[abi:nn180100](v49, *v32) = 0;
          v20(a1, v49, 0, v33, v43, v42, 0);
        }
        while (v30 != v31);
      }
      if (v44)
      {
        if (v48) {
          (*(void (**)(void))(*(void *)v44 + 40))();
        }
      }
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v34 = re::TypeInfo::name((re::TypeInfo *)v43);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v35, v36, v37, v38, v39, v34[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  v55[0] = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v49),
        re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50),
        v48[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v48))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v50);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v48);
  if (v19)
  {
    int v20 = (void (*)(uint64_t, __n128 *, void, uint64_t, unsigned char *, unsigned char *, void))v19;
    BOOL v21 = (_anonymous_namespace_ *)(a1 + 24);
    BOOL v22 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    BOOL result = 0;
    if (!v22) {
      return result;
    }
    unint64_t v24 = (*(uint64_t (**)(uint64_t))(v46 + 88))(a4);
    if (v24)
    {
      uint64_t v53 = 0;
      uint64_t v50 = 0;
      unint64_t v51 = 0;
      int v52 = 0;
      uint64_t v49 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v49, v24);
      ++v52;
      uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v46 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v46 + 120))())
      {
        do
        {
          uint64_t v26 = (*(uint64_t (**)(uint64_t))(v46 + 128))(v25);
          uint64_t v27 = (*(uint64_t (**)(uint64_t))(v46 + 136))(v25);
          v54[0].n128_u64[0] = v26;
          v54[0].n128_u64[1] = v27;
          __n128 v28 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v49, v54);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v46 + 120))(v25, v28) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v46 + 144))(v25, v18);
      unint64_t v29 = 126 - 2 * __clz(v51);
      if (v51) {
        uint64_t v30 = v29;
      }
      else {
        uint64_t v30 = 0;
      }
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(v53, (__n128 *)&v53[v51], v30, 1);
      if (v51)
      {
        uint64_t v31 = v53;
        uint64_t v32 = &v53[v51];
        do
        {
          unint64_t v33 = **(void **)v31;
          if ((v33 & 0x8000000000000000) != 0)
          {
            v54[0].n128_u8[0] = 45;
            unint64_t v33 = -(uint64_t)v33;
            uint64_t v34 = (__n128 *)((char *)v54[0].n128_u64 + 1);
          }
          else
          {
            uint64_t v34 = v54;
          }
          uint64_t v35 = *((void *)v31 + 1);
          if ((char *)v55 - (char *)v34 > 19
            || (unsigned int v36 = (1233 * (64 - __clz(v33 | 1))) >> 12,
                int64_t v37 = v36 - (std::__itoa::__pow10_64[v36] > v33) + 1,
                uint64_t v38 = v55,
                (char *)v55 - (char *)v34 >= v37))
          {
            uint64_t v38 = std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v34, v33);
          }
          *(unsigned char *)uint64_t v38 = 0;
          v20(a1, v54, 0, v35, v48, v47, 0);
          ++v31;
        }
        while (v31 != v32);
      }
      if (v49)
      {
        if (v53) {
          (*(void (**)(void))(*(void *)v49 + 40))();
        }
      }
      BOOL v21 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v21);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v39 = re::TypeInfo::name((re::TypeInfo *)v48);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v40, v41, v42, v43, v44, v39[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  v55[0] = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v49),
        re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50),
        v48[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v48))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v50);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v48);
  if (v19)
  {
    int v20 = (void (*)(uint64_t, __n128 *, void, uint64_t, unsigned char *, unsigned char *, void))v19;
    BOOL v21 = (_anonymous_namespace_ *)(a1 + 24);
    BOOL v22 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    BOOL result = 0;
    if (!v22) {
      return result;
    }
    unint64_t v24 = (*(uint64_t (**)(uint64_t))(v46 + 88))(a4);
    if (v24)
    {
      uint64_t v53 = 0;
      uint64_t v50 = 0;
      unint64_t v51 = 0;
      int v52 = 0;
      uint64_t v49 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v49, v24);
      ++v52;
      uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v46 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v46 + 120))())
      {
        do
        {
          uint64_t v26 = (*(uint64_t (**)(uint64_t))(v46 + 128))(v25);
          uint64_t v27 = (*(uint64_t (**)(uint64_t))(v46 + 136))(v25);
          v54[0].n128_u64[0] = v26;
          v54[0].n128_u64[1] = v27;
          __n128 v28 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v49, v54);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v46 + 120))(v25, v28) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v46 + 144))(v25, v18);
      unint64_t v29 = 126 - 2 * __clz(v51);
      if (v51) {
        uint64_t v30 = v29;
      }
      else {
        uint64_t v30 = 0;
      }
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(v53, (__n128 *)&v53[v51], v30, 1);
      if (v51)
      {
        uint64_t v31 = v53;
        uint64_t v32 = &v53[v51];
        do
        {
          unsigned int v33 = **(_DWORD **)v31;
          if ((v33 & 0x80000000) != 0)
          {
            v54[0].n128_u8[0] = 45;
            unsigned int v33 = -v33;
            uint64_t v34 = (__n128 *)((char *)v54[0].n128_u64 + 1);
          }
          else
          {
            uint64_t v34 = v54;
          }
          uint64_t v35 = *((void *)v31 + 1);
          if ((char *)v55 - (char *)v34 > 9
            || (unsigned int v36 = (1233 * (32 - __clz(v33 | 1))) >> 12,
                int64_t v37 = (((__PAIR64__(v36, v33) - std::__itoa::__pow10_32[v36]) >> 32) + 1),
                uint64_t v38 = v55,
                (char *)v55 - (char *)v34 >= v37))
          {
            uint64_t v38 = std::__itoa::__base_10_u32[abi:nn180100](v34, v33);
          }
          *(unsigned char *)uint64_t v38 = 0;
          v20(a1, v54, 0, v35, v48, v47, 0);
          ++v31;
        }
        while (v31 != v32);
      }
      if (v49)
      {
        if (v53) {
          (*(void (**)(void))(*(void *)v49 + 40))();
        }
      }
      BOOL v21 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v21);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v39 = re::TypeInfo::name((re::TypeInfo *)v48);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v40, v41, v42, v43, v44, v39[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  v55[0] = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v49),
        re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50),
        v48[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v48))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v50);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v48);
  if (v19)
  {
    int v20 = (void (*)(uint64_t, __n128 *, void, __int16 *, unsigned char *, unsigned char *, void))v19;
    BOOL v21 = (_anonymous_namespace_ *)(a1 + 24);
    BOOL v22 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
    BOOL result = 0;
    if (!v22) {
      return result;
    }
    unint64_t v24 = (*(uint64_t (**)(uint64_t))(v46 + 88))(a4);
    if (v24)
    {
      uint64_t v53 = 0;
      uint64_t v50 = 0;
      unint64_t v51 = 0;
      int v52 = 0;
      uint64_t v49 = v18;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v49, v24);
      ++v52;
      uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v46 + 112))(a4, v18);
      if ((*(unsigned int (**)(void))(v46 + 120))())
      {
        do
        {
          uint64_t v26 = (*(uint64_t (**)(uint64_t))(v46 + 128))(v25);
          uint64_t v27 = (*(uint64_t (**)(uint64_t))(v46 + 136))(v25);
          v54[0].n128_u64[0] = v26;
          v54[0].n128_u64[1] = v27;
          __n128 v28 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v49, v54);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v46 + 120))(v25, v28) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v46 + 144))(v25, v18);
      unint64_t v29 = 126 - 2 * __clz(v51);
      if (v51) {
        uint64_t v30 = v29;
      }
      else {
        uint64_t v30 = 0;
      }
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(v53, &v53[2 * v51], v30, 1);
      if (v51)
      {
        uint64_t v31 = v53;
        uint64_t v32 = &v53[2 * v51];
        do
        {
          unsigned int v33 = **v31;
          if ((v33 & 0x80000000) != 0)
          {
            v54[0].n128_u8[0] = 45;
            unsigned int v33 = -v33;
            uint64_t v34 = (__n128 *)((char *)v54[0].n128_u64 + 1);
          }
          else
          {
            uint64_t v34 = v54;
          }
          uint64_t v35 = v31[1];
          if ((char *)v55 - (char *)v34 > 9
            || (unsigned int v36 = (1233 * (32 - __clz(v33 | 1))) >> 12,
                int64_t v37 = (((__PAIR64__(v36, v33) - std::__itoa::__pow10_32[v36]) >> 32) + 1),
                uint64_t v38 = v55,
                (char *)v55 - (char *)v34 >= v37))
          {
            uint64_t v38 = std::__itoa::__base_10_u32[abi:nn180100](v34, v33);
          }
          *(unsigned char *)uint64_t v38 = 0;
          v20(a1, v54, 0, v35, v48, v47, 0);
          v31 += 2;
        }
        while (v31 != v32);
      }
      if (v49)
      {
        if (v53) {
          (*(void (**)(void))(*(void *)v49 + 40))();
        }
      }
      BOOL v21 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v21);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v39 = re::TypeInfo::name((re::TypeInfo *)v48);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v40, v41, v42, v43, v44, v39[1]);
  return 0;
}

BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, re *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  uint64_t v14 = *(void **)a5;
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v15 = (uint64_t *)*((void *)a6 + 2);
    uint64_t v17 = *v15;
    if ((unsigned __int16)v16 != (unsigned __int16)*v15) {
      goto LABEL_10;
    }
    BOOL v19 = WORD1(v16) == WORD1(v17);
    uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
    BOOL v19 = v19 && v18 == 0;
    if (!v19) {
      goto LABEL_10;
    }
LABEL_14:
    if (!a7)
    {
      uint64_t v22 = *(void *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v49);
      re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v49);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v50);
      re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)a5);
      uint64_t v23 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v48);
      if (!v23)
      {
        uint64_t v38 = re::TypeInfo::name((re::TypeInfo *)v48);
        re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v39, v40, v41, v42, v43, v38[1]);
        return 0;
      }
      unint64_t v24 = (void (*)(uint64_t, uint64_t, void, uint64_t, unsigned char *, unsigned char *, void))v23;
      BOOL v25 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
      BOOL result = 0;
      if (!v25) {
        return result;
      }
      unint64_t v27 = (*(uint64_t (**)(uint64_t))(v46 + 88))(a4);
      if (v27)
      {
        uint64_t v53 = 0;
        uint64_t v50 = 0;
        unint64_t v51 = 0;
        int v52 = 0;
        uint64_t v49 = v22;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v49, v27);
        ++v52;
        uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t))(v46 + 112))(a4, v22);
        if ((*(unsigned int (**)(void))(v46 + 120))())
        {
          do
          {
            uint64_t v29 = (*(uint64_t (**)(uint64_t))(v46 + 128))(v28);
            uint64_t v30 = (*(uint64_t (**)(uint64_t))(v46 + 136))(v28);
            v44.n128_u64[0] = v29;
            v44.n128_u64[1] = v30;
            __n128 v31 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v49, &v44);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v46 + 120))(v28, v31) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v46 + 144))(v28, v22);
        unint64_t v32 = 126 - 2 * __clz(v51);
        if (v51) {
          uint64_t v33 = v32;
        }
        else {
          uint64_t v33 = 0;
        }
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(v53, &v53[2 * v51], v33, 1);
        if (v51)
        {
          uint64_t v34 = v53;
          uint64_t v35 = &v53[2 * v51];
          do
          {
            uint64_t v36 = *v34;
            if (*(unsigned char *)(*v34 + 8)) {
              uint64_t v37 = *(void *)(v36 + 16);
            }
            else {
              uint64_t v37 = v36 + 9;
            }
            v24(a1, v37, 0, v34[1], v48, v47, 0);
            v34 += 2;
          }
          while (v34 != v35);
        }
        if (v49)
        {
          if (v53) {
            (*(void (**)(void))(*(void *)v49 + 40))();
          }
        }
      }
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    return *(unsigned char *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_14;
  }
  uint64_t v14 = *(void **)a6;
  uint64_t v15 = (uint64_t *)*((void *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v14, v15[9], &v49);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
  int v20 = re::TypeInfo::name((re::TypeInfo *)v48);
  if ((unint64_t)*v20 >> 1 == 0x22C6ED80D0CLL)
  {
    BOOL v21 = (char *)v20[1];
    if (v21 == "StringID" || !strcmp(v21, "StringID")) {
      goto LABEL_14;
    }
  }
  re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, re *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  uint64_t v14 = *(void **)a5;
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v15 = (uint64_t *)*((void *)a6 + 2);
    uint64_t v17 = *v15;
    if ((unsigned __int16)v16 != (unsigned __int16)*v15) {
      goto LABEL_10;
    }
    BOOL v19 = WORD1(v16) == WORD1(v17);
    uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
    BOOL v19 = v19 && v18 == 0;
    if (!v19) {
      goto LABEL_10;
    }
LABEL_14:
    if (!a7)
    {
      uint64_t v22 = *(void *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v49);
      re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v49);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v50);
      re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)a5);
      uint64_t v23 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v48);
      if (!v23)
      {
        uint64_t v38 = re::TypeInfo::name((re::TypeInfo *)v48);
        re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v39, v40, v41, v42, v43, v38[1]);
        return 0;
      }
      unint64_t v24 = (void (*)(uint64_t, void, void, uint64_t, unsigned char *, unsigned char *, void))v23;
      BOOL v25 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, (uint64_t)a3, 0);
      BOOL result = 0;
      if (!v25) {
        return result;
      }
      unint64_t v27 = (*(uint64_t (**)(uint64_t))(v46 + 88))(a4);
      if (v27)
      {
        uint64_t v53 = 0;
        uint64_t v50 = 0;
        unint64_t v51 = 0;
        int v52 = 0;
        uint64_t v49 = v22;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v49, v27);
        ++v52;
        uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t))(v46 + 112))(a4, v22);
        if ((*(unsigned int (**)(void))(v46 + 120))())
        {
          do
          {
            uint64_t v29 = (*(uint64_t (**)(uint64_t))(v46 + 128))(v28);
            uint64_t v30 = (*(uint64_t (**)(uint64_t))(v46 + 136))(v28);
            v44.n128_u64[0] = v29;
            v44.n128_u64[1] = v30;
            __n128 v31 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v49, &v44);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v46 + 120))(v28, v31) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v46 + 144))(v28, v22);
        unint64_t v32 = 126 - 2 * __clz(v51);
        if (v51) {
          uint64_t v33 = v32;
        }
        else {
          uint64_t v33 = 0;
        }
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>((unint64_t)v53, (__n128 *)&v53[2 * v51], v33, 1);
        if (v51)
        {
          uint64_t v34 = v53;
          uint64_t v35 = &v53[2 * v51];
          do
          {
            uint64_t v37 = *v34;
            uint64_t v36 = v34[1];
            v34 += 2;
            v24(a1, *(void *)(v37 + 8), 0, v36, v48, v47, 0);
          }
          while (v34 != v35);
        }
        if (v49)
        {
          if (v53) {
            (*(void (**)(void))(*(void *)v49 + 40))();
          }
        }
      }
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    return *(unsigned char *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_14;
  }
  uint64_t v14 = *(void **)a6;
  uint64_t v15 = (uint64_t *)*((void *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v14, v15[9], &v49);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v50);
  int v20 = re::TypeInfo::name((re::TypeInfo *)v48);
  if ((unint64_t)*v20 >> 1 == 0x134375A94D9F7110)
  {
    BOOL v21 = (char *)v20[1];
    if (v21 == "DynamicString" || !strcmp(v21, "DynamicString")) {
      goto LABEL_14;
    }
  }
  re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(uint64_t a1, const char *a2, uint64_t *a3)
{
  uint64_t v13 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v13);
    }
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(*(void *)(a1 + 168));
    uint64_t v6 = *a3;
    LOBYTE(v8) = 6;
    DWORD1(v8) = 0;
    *((void *)&v8 + 1) = v13;
    uint64_t v9 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v10 = v6;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v8);
  }
  return v3 == 0;
}

double re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(uint64_t a1, int a2)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(*(void *)(a1 + 168));
    LOBYTE(v5[0]) = 7;
    DWORD1(v5[0]) = a2 | 0x20;
    *((void *)&v5[0] + 1) = "entry";
    v5[1] = xmmword_23436C460;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, v5);
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == 2)
    {
      uint64_t v2 = (uint64_t *)*((void *)result + 21);
      v2[4] -= 16;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndObject(v2);
      double result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 7);
      uint64_t v3 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      ++*(void *)(v3 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if (v6) {
        uint64_t v4 = *(unsigned char **)&v7[7];
      }
      else {
        uint64_t v4 = v7;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary entry \"%s\". Expected 2 objects (key+value). Actual number of objects: %lld.", (re::DynamicString *)v8, v4, *(void *)(*((void *)v1 + 16) + 48 * *((void *)v1 + 14) - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v8);
      if (*(void *)&v8[0])
      {
        if (BYTE8(v8[0])) {
          (*(void (**)(void))(**(void **)&v8[0] + 40))();
        }
        memset(v8, 0, sizeof(v8));
      }
      double result = v5;
      if (v5)
      {
        if (v6) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v5 + 40))();
        }
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionary(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == *(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 24))
    {
      uint64_t v2 = (uint64_t *)*((void *)result + 21);
      v2[4] -= 16;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndArray(v2);
      double result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 6);
      uint64_t v3 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      ++*(void *)(v3 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v6);
      if (v7) {
        uint64_t v4 = *(unsigned char **)&v8[7];
      }
      else {
        uint64_t v4 = v8;
      }
      uint64_t v5 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)v9, v4, *(void *)(v5 - 24), *(void *)(v5 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v9);
      if (*(void *)&v9[0])
      {
        if (BYTE8(v9[0])) {
          (*(void (**)(void))(**(void **)&v9[0] + 40))();
        }
        memset(v9, 0, sizeof(v9));
      }
      double result = v6;
      if (v6)
      {
        if (v7) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v6 + 40))();
        }
      }
    }
  }
  return result;
}

void std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(char *a1, char *a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  unint64_t v3 = 126 - 2 * __clz((a2 - a1) >> 4);
  uint64_t v5 = a3;
  if (a2 == a1) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = v3;
  }
  std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(a1, a2, &v5, v4, 1);
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(uint64_t a1, const char *a2, uint64_t a3, int a4)
{
  uint64_t v9 = a2;
  int v4 = *(unsigned __int8 *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 40))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v9);
    }
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(*(void *)(a1 + 168));
    LOBYTE(v8[0]) = 2;
    DWORD1(v8[0]) = a4 | 0x20;
    *((void *)&v8[0] + 1) = v9;
    memset(&v8[1], 0, 32);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, v8);
  }
  return v4 == 0;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = (uint64_t *)*((void *)result + 21);
    v2[4] -= 16;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndObject(v2);
    double result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 2);
    uint64_t v3 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
    ++*(void *)(v3 - 16);
  }
  return result;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(uint64_t a1)
{
  rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix((char *)a1);
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(a1 + 40) - v2 <= 15)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Level>(a1 + 8, 1);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  *(void *)(a1 + 32) = v2 + 16;
  *(void *)uint64_t v2 = 0;
  *(unsigned char *)(v2 + 8) = 0;
  return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteStartObject((uint64_t *)a1);
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteStartObject(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(unsigned char **)(*a1 + 24);
  if ((uint64_t)(*(void *)(*a1 + 32) - (void)v2) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, 1);
    uint64_t v2 = *(unsigned char **)(v1 + 24);
  }
  *(void *)(v1 + 24) = v2 + 1;
  *uint64_t v2 = 123;
  return 1;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(long long *a1, unint64_t **a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = (unint64_t)a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = (long long *)v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v38 = *(a2 - 2);
                uint64_t v37 = (long long *)(a2 - 2);
                if (*v38 < **(void **)v10)
                {
                  long long v87 = *(_OWORD *)v10;
                  *(_OWORD *)unint64_t v10 = *v37;
                  *uint64_t v37 = v87;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v10, (unint64_t **)(v10 + 16), a2 - 2);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v10, (unint64_t **)(v10 + 16), (unint64_t **)(v10 + 32), (_OWORD *)a2 - 1);
                break;
              case 5uLL:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v10, (unint64_t **)(v10 + 16), (unint64_t **)(v10 + 32), (__n128 *)(v10 + 48), (__n128 *)a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            uint64_t v39 = (unint64_t **)(v10 + 16);
            BOOL v41 = (unint64_t **)v10 == a2 || v39 == a2;
            if (a4)
            {
              if (!v41)
              {
                uint64_t v42 = 0;
                unint64_t v43 = v10;
                do
                {
                  __n128 v44 = v39;
                  uint64_t v45 = *(unint64_t **)(v43 + 16);
                  if (*v45 < **(void **)v43)
                  {
                    uint64_t v46 = *(void *)(v43 + 24);
                    uint64_t v47 = v42;
                    while (1)
                    {
                      *(_OWORD *)(v10 + v47 + 16) = *(_OWORD *)(v10 + v47);
                      if (!v47) {
                        break;
                      }
                      unint64_t v48 = **(void **)(v10 + v47 - 16);
                      v47 -= 16;
                      if (*v45 >= v48)
                      {
                        uint64_t v49 = (void *)(v10 + v47 + 16);
                        goto LABEL_79;
                      }
                    }
                    uint64_t v49 = (void *)v10;
LABEL_79:
                    *uint64_t v49 = v45;
                    v49[1] = v46;
                  }
                  uint64_t v39 = v44 + 2;
                  v42 += 16;
                  unint64_t v43 = (unint64_t)v44;
                }
                while (v44 + 2 != a2);
              }
            }
            else if (!v41)
            {
              do
              {
                uint64_t v79 = v39;
                v80 = (unint64_t *)*((void *)a1 + 2);
                if (*v80 < **(void **)a1)
                {
                  uint64_t v81 = (unint64_t *)*((void *)a1 + 3);
                  v82 = v79;
                  do
                  {
                    *(_OWORD *)v82 = *((_OWORD *)v82 - 1);
                    BOOL v83 = *(v82 - 4);
                    v82 -= 2;
                  }
                  while (*v80 < *v83);
                  *v82 = v80;
                  v82[1] = v81;
                }
                uint64_t v39 = v79 + 2;
                a1 = (long long *)v79;
              }
              while (v79 + 2 != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((unint64_t **)v10 != a2)
            {
              int64_t v50 = (v12 - 2) >> 1;
              int64_t v51 = v50;
              do
              {
                int64_t v52 = v51;
                if (v50 >= v51)
                {
                  uint64_t v53 = (2 * v51) | 1;
                  uint64_t v54 = (unint64_t **)(v10 + 16 * v53);
                  if (2 * v52 + 2 < (uint64_t)v12)
                  {
                    unint64_t v55 = **v54;
                    unint64_t v57 = *v54[2];
                    BOOL v56 = v55 >= v57;
                    if (v55 > v57) {
                      unint64_t v57 = **v54;
                    }
                    if (!v56)
                    {
                      v54 += 2;
                      uint64_t v53 = 2 * v52 + 2;
                    }
                  }
                  else
                  {
                    unint64_t v57 = **v54;
                  }
                  __int16 v58 = (unint64_t **)(v10 + 16 * v52);
                  int v59 = *v58;
                  if (v57 >= **v58)
                  {
                    uint64_t v60 = v58[1];
                    do
                    {
                      uint64_t v61 = v58;
                      __int16 v58 = v54;
                      *(_OWORD *)uint64_t v61 = *(_OWORD *)v54;
                      if (v50 < v53) {
                        break;
                      }
                      uint64_t v62 = (2 * v53) | 1;
                      uint64_t v54 = (unint64_t **)(v10 + 16 * v62);
                      uint64_t v53 = 2 * v53 + 2;
                      if (v53 < (uint64_t)v12)
                      {
                        unint64_t v65 = **v54;
                        unint64_t v63 = *v54[2];
                        BOOL v64 = v65 >= v63;
                        if (v65 <= v63) {
                          unint64_t v65 = *v54[2];
                        }
                        if (v64) {
                          uint64_t v53 = v62;
                        }
                        else {
                          v54 += 2;
                        }
                      }
                      else
                      {
                        unint64_t v65 = **v54;
                        uint64_t v53 = v62;
                      }
                    }
                    while (v65 >= *v59);
                    *__int16 v58 = v59;
                    v58[1] = v60;
                  }
                }
                int64_t v51 = v52 - 1;
              }
              while (v52);
              uint64_t v66 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v67 = 0;
                long long v88 = *(_OWORD *)v10;
                v68 = (_OWORD *)v10;
                do
                {
                  uint64_t v69 = (uint64_t)&v68[v67 + 1];
                  uint64_t v70 = (2 * v67) | 1;
                  uint64_t v71 = 2 * v67 + 2;
                  if (v71 < v66 && **(void **)v69 < **(void **)(v69 + 16))
                  {
                    v69 += 16;
                    uint64_t v70 = v71;
                  }
                  _OWORD *v68 = *(_OWORD *)v69;
                  v68 = (_OWORD *)v69;
                  uint64_t v67 = v70;
                }
                while (v70 <= (uint64_t)((unint64_t)(v66 - 2) >> 1));
                a2 -= 2;
                if ((unint64_t **)v69 == a2)
                {
                  *(_OWORD *)uint64_t v69 = v88;
                }
                else
                {
                  *(_OWORD *)uint64_t v69 = *(_OWORD *)a2;
                  *(_OWORD *)a2 = v88;
                  uint64_t v72 = v69 - v10 + 16;
                  if (v72 >= 17)
                  {
                    unint64_t v73 = (((unint64_t)v72 >> 4) - 2) >> 1;
                    char v74 = (_OWORD *)(v10 + 16 * v73);
                    uint64_t v75 = *(void **)v69;
                    if (**(void **)v74 < **(void **)v69)
                    {
                      uint64_t v76 = *(void *)(v69 + 8);
                      do
                      {
                        uint64_t v77 = (_OWORD *)v69;
                        uint64_t v69 = (uint64_t)v74;
                        *uint64_t v77 = *v74;
                        if (!v73) {
                          break;
                        }
                        unint64_t v73 = (v73 - 1) >> 1;
                        char v74 = (_OWORD *)(v10 + 16 * v73);
                      }
                      while (**(void **)v74 < *v75);
                      *(void *)uint64_t v69 = v75;
                      *(void *)(v69 + 8) = v76;
                    }
                  }
                }
              }
              while (v66-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (unint64_t **)(v10 + 16 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(a1, (unint64_t **)&a1[v12 >> 1], a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(a1 + 1, v14 - 2, a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(a1 + 2, (unint64_t **)&a1[v13 + 1], a2 - 6);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v14 - 1, v14, (unint64_t **)&a1[v13 + 1]);
            long long v84 = *a1;
            *a1 = *(_OWORD *)v14;
            *(_OWORD *)uint64_t v14 = v84;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(&a1[v12 >> 1], (unint64_t **)a1, a2 - 2);
          }
          --a3;
          uint64_t v15 = *(unint64_t **)a1;
          unint64_t v16 = **(void **)a1;
          if ((a4 & 1) != 0 || **((void **)a1 - 2) < v16) {
            break;
          }
          if (v16 >= **(a2 - 2))
          {
            uint64_t v30 = (unint64_t **)(a1 + 1);
            do
            {
              unint64_t v10 = (unint64_t)v30;
              if (v30 >= a2) {
                break;
              }
              v30 += 2;
            }
            while (v16 >= **(void **)v10);
          }
          else
          {
            unint64_t v10 = (unint64_t)a1;
            do
            {
              uint64_t v29 = *(unint64_t **)(v10 + 16);
              v10 += 16;
            }
            while (v16 >= *v29);
          }
          __n128 v31 = a2;
          if (v10 < (unint64_t)a2)
          {
            __n128 v31 = a2;
            do
              unint64_t v32 = (unint64_t *)*((void *)v31-- - 2);
            while (v16 < *v32);
          }
          uint64_t v33 = (void *)*((void *)a1 + 1);
          while (v10 < (unint64_t)v31)
          {
            long long v86 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v31;
            *__n128 v31 = v86;
            unint64_t v34 = *v15;
            do
            {
              uint64_t v35 = *(unint64_t **)(v10 + 16);
              v10 += 16;
            }
            while (v34 >= *v35);
            do
              uint64_t v36 = (unint64_t *)*((void *)v31-- - 2);
            while (v34 < *v36);
          }
          BOOL v4 = v10 - 16 >= (unint64_t)a1;
          BOOL v5 = v10 - 16 == (void)a1;
          if ((long long *)(v10 - 16) != a1) {
            *a1 = *(_OWORD *)(v10 - 16);
          }
          a4 = 0;
          *(void *)(v10 - 16) = v15;
          *(void *)(v10 - 8) = v33;
        }
        uint64_t v17 = 0;
        uint64_t v18 = (void *)*((void *)a1 + 1);
        do
          unint64_t v19 = **(void **)&a1[++v17];
        while (v19 < v16);
        int v20 = (unint64_t **)&a1[v17];
        BOOL v21 = a2;
        if (v17 == 1)
        {
          BOOL v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            uint64_t v23 = *(v21 - 2);
            v21 -= 2;
          }
          while (*v23 >= v16);
        }
        else
        {
          do
          {
            uint64_t v22 = *(v21 - 2);
            v21 -= 2;
          }
          while (*v22 >= v16);
        }
        unint64_t v10 = (unint64_t)&a1[v17];
        if (v20 < v21)
        {
          unint64_t v24 = (long long *)v21;
          do
          {
            long long v85 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v24;
            *unint64_t v24 = v85;
            unint64_t v25 = *v15;
            do
            {
              uint64_t v26 = *(unint64_t **)(v10 + 16);
              v10 += 16;
            }
            while (*v26 < v25);
            do
              unint64_t v27 = (unint64_t *)*((void *)v24-- - 2);
            while (*v27 >= v25);
          }
          while (v10 < (unint64_t)v24);
        }
        if ((long long *)(v10 - 16) != a1) {
          *a1 = *(_OWORD *)(v10 - 16);
        }
        *(void *)(v10 - 16) = v15;
        *(void *)(v10 - 8) = v18;
        if (v20 >= v21) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(a1, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((uint64_t)a1, (unint64_t **)(v10 - 16));
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(v10, a2))
      {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = (unint64_t **)(v10 - 16);
    if (!v28) {
      continue;
    }
    break;
  }
}

long long *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(long long *result, unint64_t **a2, unint64_t **a3)
{
  unint64_t v3 = **a2;
  unint64_t v4 = **a3;
  if (v3 >= **(void **)result)
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (**a2 < **(void **)result)
      {
        long long v7 = *result;
        *double result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *result;
      *double result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**a3 >= **a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      long long v5 = *result;
      *double result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(uint64_t a1, unint64_t **a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = (long long *)(a2 - 2);
      if (**(a2 - 2) < **(void **)a1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *long long v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)a1, (unint64_t **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      long long v8 = (unint64_t **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32));
      uint64_t v9 = (unint64_t **)(a1 + 48);
      if ((unint64_t **)(a1 + 48) == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unint64_t v12 = *v9;
    if (**v9 < **v8)
    {
      unint64_t v13 = v9[1];
      uint64_t v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        unint64_t v15 = **(void **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          unint64_t v16 = (unint64_t **)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      unint64_t v16 = (unint64_t **)a1;
LABEL_12:
      *unint64_t v16 = v12;
      v16[1] = v13;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    long long v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(long long *a1, unint64_t **a2, unint64_t **a3, _OWORD *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(a1, a2, a3);
  if (**(void **)a4 < **a3)
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (**a3 < **a2)
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (**a2 < **(void **)a1)
      {
        __n128 result = (__n128)*a1;
        *a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(long long *a1, unint64_t **a2, unint64_t **a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(void *)a5->n128_u64[0] < *(void *)a4->n128_u64[0])
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(void *)a4->n128_u64[0] < **a3)
    {
      __n128 result = *(__n128 *)a3;
      *(__n128 *)a3 = *a4;
      *a4 = result;
      if (**a3 < **a2)
      {
        __n128 result = *(__n128 *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(__n128 *)a3 = result;
        if (**a2 < **(void **)a1)
        {
          __n128 result = (__n128)*a1;
          *a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

_WORD *std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](_WORD *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  if (HIDWORD(a2))
  {
    if (a2 > 0x2540BE3FFLL)
    {
      a1 = std::__itoa::__base_10_u32[abi:nn180100](a1, a2 / 0x2540BE400);
      v2 %= 0x2540BE400uLL;
    }
    return std::__itoa::__append10[abi:nn180100]<unsigned long long>(a1, v2);
  }
  else
  {
    return std::__itoa::__base_10_u32[abi:nn180100](a1, a2);
  }
}

_WORD *std::__itoa::__base_10_u32[abi:nn180100](_WORD *a1, unsigned int a2)
{
  if (a2 >= 0xF4240)
  {
    if (a2 >= 0x5F5E100)
    {
      if (a2 > 0x3B9AC9FF)
      {
        return std::__itoa::__append10[abi:nn180100]<unsigned int>(a1, a2);
      }
      else
      {
        *(unsigned char *)a1 = a2 / 0x5F5E100 + 48;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240];
        unsigned int v7 = a2 % 0x5F5E100 % 0xF4240;
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v7 / 0x2710uLL];
        v7 %= 0x2710u;
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[(unsigned __int16)v7 / 0x64u];
        *(_WORD *)((char *)a1 + 7) = std::__itoa::__digits_base_10[(unsigned __int16)v7 % 0x64u];
        return (_WORD *)((char *)a1 + 9);
      }
    }
    else
    {
      unsigned int v3 = a2 / 0xF4240;
      if (a2 > 0x98967F)
      {
        *a1 = std::__itoa::__digits_base_10[v3];
        a1[1] = std::__itoa::__digits_base_10[a2 % 0xF4240 / 0x2710uLL];
        unsigned int v9 = a2 % 0xF4240 % 0x2710;
        a1[2] = std::__itoa::__digits_base_10[(unsigned __int16)v9 / 0x64u];
        a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v9 % 0x64u];
        return a1 + 4;
      }
      else
      {
        *(unsigned char *)a1 = v3 + 48;
        unint64_t v4 = (429497 * (unint64_t)(a2 % 0xF4240)) >> 32;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[v4];
        unsigned __int16 v5 = a2 % 0xF4240 - 10000 * v4;
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v5 / 0x64u];
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[v5 % 0x64u];
        return (_WORD *)((char *)a1 + 7);
      }
    }
  }
  else if (a2 >> 4 > 0x270)
  {
    unsigned int v6 = a2 / 0x2710;
    if (a2 >> 5 > 0xC34)
    {
      *a1 = std::__itoa::__digits_base_10[v6];
      unsigned __int16 v10 = a2 % 0x2710;
      a1[1] = std::__itoa::__digits_base_10[v10 / 0x64u];
      a1[2] = std::__itoa::__digits_base_10[v10 % 0x64u];
      return a1 + 3;
    }
    else
    {
      *(unsigned char *)a1 = v6 + 48;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[(5243 * (a2 % 0x2710)) >> 19];
      *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[(unsigned __int16)(a2 % 0x2710
                                                                                  - 100
                                                                                  * ((unsigned __int16)((5243 * (a2 % 0x2710)) >> 16) >> 3))];
      return (_WORD *)((char *)a1 + 5);
    }
  }
  else if (a2 > 0x63)
  {
    unsigned int v8 = (unsigned __int16)a2 / 0x64u;
    if (a2 > 0x3E7)
    {
      *a1 = std::__itoa::__digits_base_10[v8];
      a1[1] = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      return a1 + 2;
    }
    else
    {
      *(unsigned char *)a1 = v8 + 48;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      return (_WORD *)((char *)a1 + 3);
    }
  }
  else if (a2 > 9)
  {
    *a1 = std::__itoa::__digits_base_10[a2];
    return a1 + 1;
  }
  else
  {
    *(unsigned char *)a1 = a2 + 48;
    return (_WORD *)((char *)a1 + 1);
  }
}

_WORD *std::__itoa::__append10[abi:nn180100]<unsigned long long>(_WORD *a1, unint64_t a2)
{
  *a1 = std::__itoa::__digits_base_10[(a2 / 0x5F5E100)];
  unsigned int v2 = a2 % 0x5F5E100;
  a1[1] = std::__itoa::__digits_base_10[v2 / 0xF4240uLL];
  v2 %= 0xF4240u;
  a1[2] = std::__itoa::__digits_base_10[v2 / 0x2710uLL];
  v2 %= 0x2710u;
  a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v2 / 0x64u];
  a1[4] = std::__itoa::__digits_base_10[(unsigned __int16)v2 % 0x64u];
  return a1 + 5;
}

_WORD *std::__itoa::__append10[abi:nn180100]<unsigned int>(_WORD *a1, unsigned int a2)
{
  *a1 = std::__itoa::__digits_base_10[a2 / 0x5F5E100uLL];
  a1[1] = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240uLL];
  unsigned int v2 = a2 % 0x5F5E100 % 0xF4240;
  a1[2] = std::__itoa::__digits_base_10[v2 / 0x2710uLL];
  v2 %= 0x2710u;
  a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v2 / 0x64u];
  a1[4] = std::__itoa::__digits_base_10[(unsigned __int16)v2 % 0x64u];
  return a1 + 5;
}

uint64_t rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndObject(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = *(unsigned char **)(*a1 + 24);
  if ((uint64_t)(*(void *)(*a1 + 32) - (void)v2) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, 1);
    unsigned int v2 = *(unsigned char **)(v1 + 24);
  }
  *(void *)(v1 + 24) = v2 + 1;
  *unsigned int v2 = 125;
  return 1;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(long long *a1, unsigned int **a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = (unint64_t)a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = (long long *)v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v38 = *(a2 - 2);
                uint64_t v37 = (long long *)(a2 - 2);
                if (*v38 < **(_DWORD **)v10)
                {
                  long long v87 = *(_OWORD *)v10;
                  *(_OWORD *)unint64_t v10 = *v37;
                  *uint64_t v37 = v87;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v10, (unsigned int **)(v10 + 16), a2 - 2);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v10, (unsigned int **)(v10 + 16), (unsigned int **)(v10 + 32), (_OWORD *)a2 - 1);
                break;
              case 5uLL:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v10, (unsigned int **)(v10 + 16), (unsigned int **)(v10 + 32), (__n128 *)(v10 + 48), (__n128 *)a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            uint64_t v39 = (unsigned int **)(v10 + 16);
            BOOL v41 = (unsigned int **)v10 == a2 || v39 == a2;
            if (a4)
            {
              if (!v41)
              {
                uint64_t v42 = 0;
                unint64_t v43 = v10;
                do
                {
                  __n128 v44 = v39;
                  uint64_t v45 = *(unsigned int **)(v43 + 16);
                  if (*v45 < **(_DWORD **)v43)
                  {
                    uint64_t v46 = *(void *)(v43 + 24);
                    uint64_t v47 = v42;
                    while (1)
                    {
                      *(_OWORD *)(v10 + v47 + 16) = *(_OWORD *)(v10 + v47);
                      if (!v47) {
                        break;
                      }
                      unsigned int v48 = **(_DWORD **)(v10 + v47 - 16);
                      v47 -= 16;
                      if (*v45 >= v48)
                      {
                        uint64_t v49 = (void *)(v10 + v47 + 16);
                        goto LABEL_79;
                      }
                    }
                    uint64_t v49 = (void *)v10;
LABEL_79:
                    *uint64_t v49 = v45;
                    v49[1] = v46;
                  }
                  uint64_t v39 = v44 + 2;
                  v42 += 16;
                  unint64_t v43 = (unint64_t)v44;
                }
                while (v44 + 2 != a2);
              }
            }
            else if (!v41)
            {
              do
              {
                uint64_t v79 = v39;
                v80 = (unsigned int *)*((void *)a1 + 2);
                if (*v80 < **(_DWORD **)a1)
                {
                  uint64_t v81 = (unsigned int *)*((void *)a1 + 3);
                  v82 = v79;
                  do
                  {
                    *(_OWORD *)v82 = *((_OWORD *)v82 - 1);
                    BOOL v83 = *(v82 - 4);
                    v82 -= 2;
                  }
                  while (*v80 < *v83);
                  *v82 = v80;
                  v82[1] = v81;
                }
                uint64_t v39 = v79 + 2;
                a1 = (long long *)v79;
              }
              while (v79 + 2 != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((unsigned int **)v10 != a2)
            {
              int64_t v50 = (v12 - 2) >> 1;
              int64_t v51 = v50;
              do
              {
                int64_t v52 = v51;
                if (v50 >= v51)
                {
                  uint64_t v53 = (2 * v51) | 1;
                  uint64_t v54 = (unsigned int **)(v10 + 16 * v53);
                  if (2 * v52 + 2 < (uint64_t)v12)
                  {
                    unsigned int v55 = **v54;
                    unsigned int v57 = *v54[2];
                    BOOL v56 = v55 >= v57;
                    if (v55 > v57) {
                      unsigned int v57 = **v54;
                    }
                    if (!v56)
                    {
                      v54 += 2;
                      uint64_t v53 = 2 * v52 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v57 = **v54;
                  }
                  __int16 v58 = (unsigned int **)(v10 + 16 * v52);
                  int v59 = *v58;
                  if (v57 >= **v58)
                  {
                    uint64_t v60 = v58[1];
                    do
                    {
                      uint64_t v61 = v58;
                      __int16 v58 = v54;
                      *(_OWORD *)uint64_t v61 = *(_OWORD *)v54;
                      if (v50 < v53) {
                        break;
                      }
                      uint64_t v62 = (2 * v53) | 1;
                      uint64_t v54 = (unsigned int **)(v10 + 16 * v62);
                      uint64_t v53 = 2 * v53 + 2;
                      if (v53 < (uint64_t)v12)
                      {
                        unsigned int v65 = **v54;
                        unsigned int v63 = *v54[2];
                        BOOL v64 = v65 >= v63;
                        if (v65 <= v63) {
                          unsigned int v65 = *v54[2];
                        }
                        if (v64) {
                          uint64_t v53 = v62;
                        }
                        else {
                          v54 += 2;
                        }
                      }
                      else
                      {
                        unsigned int v65 = **v54;
                        uint64_t v53 = v62;
                      }
                    }
                    while (v65 >= *v59);
                    *__int16 v58 = v59;
                    v58[1] = v60;
                  }
                }
                int64_t v51 = v52 - 1;
              }
              while (v52);
              uint64_t v66 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v67 = 0;
                long long v88 = *(_OWORD *)v10;
                v68 = (_OWORD *)v10;
                do
                {
                  uint64_t v69 = (uint64_t)&v68[v67 + 1];
                  uint64_t v70 = (2 * v67) | 1;
                  uint64_t v71 = 2 * v67 + 2;
                  if (v71 < v66 && **(_DWORD **)v69 < **(_DWORD **)(v69 + 16))
                  {
                    v69 += 16;
                    uint64_t v70 = v71;
                  }
                  _OWORD *v68 = *(_OWORD *)v69;
                  v68 = (_OWORD *)v69;
                  uint64_t v67 = v70;
                }
                while (v70 <= (uint64_t)((unint64_t)(v66 - 2) >> 1));
                a2 -= 2;
                if ((unsigned int **)v69 == a2)
                {
                  *(_OWORD *)uint64_t v69 = v88;
                }
                else
                {
                  *(_OWORD *)uint64_t v69 = *(_OWORD *)a2;
                  *(_OWORD *)a2 = v88;
                  uint64_t v72 = v69 - v10 + 16;
                  if (v72 >= 17)
                  {
                    unint64_t v73 = (((unint64_t)v72 >> 4) - 2) >> 1;
                    char v74 = (_OWORD *)(v10 + 16 * v73);
                    uint64_t v75 = *(_DWORD **)v69;
                    if (**(_DWORD **)v74 < **(_DWORD **)v69)
                    {
                      uint64_t v76 = *(void *)(v69 + 8);
                      do
                      {
                        uint64_t v77 = (_OWORD *)v69;
                        uint64_t v69 = (uint64_t)v74;
                        *uint64_t v77 = *v74;
                        if (!v73) {
                          break;
                        }
                        unint64_t v73 = (v73 - 1) >> 1;
                        char v74 = (_OWORD *)(v10 + 16 * v73);
                      }
                      while (**(_DWORD **)v74 < *v75);
                      *(void *)uint64_t v69 = v75;
                      *(void *)(v69 + 8) = v76;
                    }
                  }
                }
              }
              while (v66-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (unsigned int **)(v10 + 16 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(a1, (unsigned int **)&a1[v12 >> 1], a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(a1 + 1, v14 - 2, a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(a1 + 2, (unsigned int **)&a1[v13 + 1], a2 - 6);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v14 - 1, v14, (unsigned int **)&a1[v13 + 1]);
            long long v84 = *a1;
            *a1 = *(_OWORD *)v14;
            *(_OWORD *)uint64_t v14 = v84;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(&a1[v12 >> 1], (unsigned int **)a1, a2 - 2);
          }
          --a3;
          unint64_t v15 = *(unsigned int **)a1;
          unsigned int v16 = **(_DWORD **)a1;
          if ((a4 & 1) != 0 || **((_DWORD **)a1 - 2) < v16) {
            break;
          }
          if (v16 >= **(a2 - 2))
          {
            uint64_t v30 = (unsigned int **)(a1 + 1);
            do
            {
              unint64_t v10 = (unint64_t)v30;
              if (v30 >= a2) {
                break;
              }
              v30 += 2;
            }
            while (v16 >= **(_DWORD **)v10);
          }
          else
          {
            unint64_t v10 = (unint64_t)a1;
            do
            {
              uint64_t v29 = *(unsigned int **)(v10 + 16);
              v10 += 16;
            }
            while (v16 >= *v29);
          }
          __n128 v31 = a2;
          if (v10 < (unint64_t)a2)
          {
            __n128 v31 = a2;
            do
              unint64_t v32 = (unsigned int *)*((void *)v31-- - 2);
            while (v16 < *v32);
          }
          uint64_t v33 = (_DWORD *)*((void *)a1 + 1);
          while (v10 < (unint64_t)v31)
          {
            long long v86 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v31;
            *__n128 v31 = v86;
            unsigned int v34 = *v15;
            do
            {
              uint64_t v35 = *(unsigned int **)(v10 + 16);
              v10 += 16;
            }
            while (v34 >= *v35);
            do
              uint64_t v36 = (unsigned int *)*((void *)v31-- - 2);
            while (v34 < *v36);
          }
          BOOL v4 = v10 - 16 >= (unint64_t)a1;
          BOOL v5 = v10 - 16 == (void)a1;
          if ((long long *)(v10 - 16) != a1) {
            *a1 = *(_OWORD *)(v10 - 16);
          }
          a4 = 0;
          *(void *)(v10 - 16) = v15;
          *(void *)(v10 - 8) = v33;
        }
        uint64_t v17 = 0;
        uint64_t v18 = (_DWORD *)*((void *)a1 + 1);
        do
          unsigned int v19 = **(_DWORD **)&a1[++v17];
        while (v19 < v16);
        int v20 = (unsigned int **)&a1[v17];
        BOOL v21 = a2;
        if (v17 == 1)
        {
          BOOL v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            uint64_t v23 = *(v21 - 2);
            v21 -= 2;
          }
          while (*v23 >= v16);
        }
        else
        {
          do
          {
            uint64_t v22 = *(v21 - 2);
            v21 -= 2;
          }
          while (*v22 >= v16);
        }
        unint64_t v10 = (unint64_t)&a1[v17];
        if (v20 < v21)
        {
          unint64_t v24 = (long long *)v21;
          do
          {
            long long v85 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v24;
            *unint64_t v24 = v85;
            unsigned int v25 = *v15;
            do
            {
              uint64_t v26 = *(unsigned int **)(v10 + 16);
              v10 += 16;
            }
            while (*v26 < v25);
            do
              unint64_t v27 = (unsigned int *)*((void *)v24-- - 2);
            while (*v27 >= v25);
          }
          while (v10 < (unint64_t)v24);
        }
        if ((long long *)(v10 - 16) != a1) {
          *a1 = *(_OWORD *)(v10 - 16);
        }
        *(void *)(v10 - 16) = v15;
        *(void *)(v10 - 8) = v18;
        if (v20 >= v21) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(a1, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((uint64_t)a1, (unsigned int **)(v10 - 16));
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(v10, a2))
      {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = (unsigned int **)(v10 - 16);
    if (!v28) {
      continue;
    }
    break;
  }
}

long long *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(long long *result, unsigned int **a2, unsigned int **a3)
{
  unsigned int v3 = **a2;
  unsigned int v4 = **a3;
  if (v3 >= **(_DWORD **)result)
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (**a2 < **(_DWORD **)result)
      {
        long long v7 = *result;
        *__n128 result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *result;
      *__n128 result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**a3 >= **a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      long long v5 = *result;
      *__n128 result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(uint64_t a1, unsigned int **a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = (long long *)(a2 - 2);
      if (**(a2 - 2) < **(_DWORD **)a1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *long long v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)a1, (unsigned int **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      long long v8 = (unsigned int **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32));
      unsigned int v9 = (unsigned int **)(a1 + 48);
      if ((unsigned int **)(a1 + 48) == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unint64_t v12 = *v9;
    if (**v9 < **v8)
    {
      unint64_t v13 = v9[1];
      uint64_t v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        unsigned int v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          unsigned int v16 = (unsigned int **)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      unsigned int v16 = (unsigned int **)a1;
LABEL_12:
      *unsigned int v16 = v12;
      v16[1] = v13;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    long long v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(long long *a1, unsigned int **a2, unsigned int **a3, _OWORD *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(a1, a2, a3);
  if (**(_DWORD **)a4 < **a3)
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (**a3 < **a2)
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (**a2 < **(_DWORD **)a1)
      {
        __n128 result = (__n128)*a1;
        *a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(long long *a1, unsigned int **a2, unsigned int **a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(_DWORD *)a5->n128_u64[0] < *(_DWORD *)a4->n128_u64[0])
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(_DWORD *)a4->n128_u64[0] < **a3)
    {
      __n128 result = *(__n128 *)a3;
      *(__n128 *)a3 = *a4;
      *a4 = result;
      if (**a3 < **a2)
      {
        __n128 result = *(__n128 *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(__n128 *)a3 = result;
        if (**a2 < **(_DWORD **)a1)
        {
          __n128 result = (__n128)*a1;
          *a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(unsigned __int16 **a1, unsigned __int16 **a2, uint64_t a3, char a4)
{
  while (2)
  {
    uint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = ((char *)a2 - (char *)v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v38 = *(a2 - 2);
                uint64_t v37 = a2 - 2;
                if (*v38 < **v10)
                {
                  long long v88 = *(_OWORD *)v10;
                  *(_OWORD *)uint64_t v10 = *(_OWORD *)v37;
                  *(_OWORD *)uint64_t v37 = v88;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v10, v10 + 2, (_OWORD *)a2 - 1);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v10, v10 + 2, (__n128 *)v10 + 2, (__n128 *)a2 - 1);
                break;
              case 5uLL:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v10, v10 + 2, (__n128 *)v10 + 2, (__n128 *)v10 + 3, (__n128 *)a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            uint64_t v39 = v10 + 2;
            BOOL v41 = v10 == a2 || v39 == a2;
            if (a4)
            {
              if (!v41)
              {
                uint64_t v42 = 0;
                unint64_t v43 = v10;
                do
                {
                  __n128 v44 = v39;
                  uint64_t v45 = v43[2];
                  if (*v45 < **v43)
                  {
                    uint64_t v46 = v43[3];
                    uint64_t v47 = v42;
                    while (1)
                    {
                      *(_OWORD *)((char *)v10 + v47 + 16) = *(_OWORD *)((char *)v10 + v47);
                      if (!v47) {
                        break;
                      }
                      unsigned int v48 = **(unsigned __int16 **)((char *)v10 + v47 - 16);
                      v47 -= 16;
                      if (*v45 >= v48)
                      {
                        uint64_t v49 = (unsigned __int16 **)((char *)v10 + v47 + 16);
                        goto LABEL_79;
                      }
                    }
                    uint64_t v49 = v10;
LABEL_79:
                    *uint64_t v49 = v45;
                    v49[1] = v46;
                  }
                  uint64_t v39 = v44 + 2;
                  v42 += 16;
                  unint64_t v43 = v44;
                }
                while (v44 + 2 != a2);
              }
            }
            else if (!v41)
            {
              do
              {
                v80 = v39;
                uint64_t v81 = a1[2];
                if (*v81 < **a1)
                {
                  v82 = a1[3];
                  BOOL v83 = v80;
                  do
                  {
                    *(_OWORD *)BOOL v83 = *((_OWORD *)v83 - 1);
                    long long v84 = *(v83 - 4);
                    v83 -= 2;
                  }
                  while (*v81 < *v84);
                  *BOOL v83 = v81;
                  v83[1] = v82;
                }
                uint64_t v39 = v80 + 2;
                a1 = v80;
              }
              while (v80 + 2 != a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v50 = (v12 - 2) >> 1;
              int64_t v51 = v50;
              do
              {
                int64_t v52 = v51;
                if (v50 >= v51)
                {
                  uint64_t v53 = (2 * v51) | 1;
                  uint64_t v54 = &v10[2 * v53];
                  if (2 * v52 + 2 < (uint64_t)v12)
                  {
                    unsigned int v55 = **v54;
                    unsigned int v57 = *v54[2];
                    BOOL v56 = v55 >= v57;
                    if (v55 > v57) {
                      unsigned int v57 = **v54;
                    }
                    if (!v56)
                    {
                      v54 += 2;
                      uint64_t v53 = 2 * v52 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v57 = **v54;
                  }
                  __int16 v58 = &v10[2 * v52];
                  int v59 = *v58;
                  if (v57 >= **v58)
                  {
                    uint64_t v60 = v58[1];
                    do
                    {
                      uint64_t v61 = v58;
                      __int16 v58 = v54;
                      *(_OWORD *)uint64_t v61 = *(_OWORD *)v54;
                      if (v50 < v53) {
                        break;
                      }
                      uint64_t v62 = (2 * v53) | 1;
                      uint64_t v54 = &v10[2 * v62];
                      uint64_t v53 = 2 * v53 + 2;
                      if (v53 < (uint64_t)v12)
                      {
                        unsigned int v63 = **v54;
                        unsigned int v64 = *v54[2];
                        BOOL v65 = v63 >= v64;
                        unsigned int v66 = v63 <= v64 ? *v54[2] : **v54;
                        if (v65) {
                          uint64_t v53 = v62;
                        }
                        else {
                          v54 += 2;
                        }
                      }
                      else
                      {
                        unsigned int v66 = **v54;
                        uint64_t v53 = v62;
                      }
                    }
                    while (v66 >= *v59);
                    *__int16 v58 = v59;
                    v58[1] = v60;
                  }
                }
                int64_t v51 = v52 - 1;
              }
              while (v52);
              uint64_t v67 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v68 = 0;
                long long v89 = *(_OWORD *)v10;
                uint64_t v69 = v10;
                do
                {
                  uint64_t v70 = &v69[2 * v68 + 2];
                  uint64_t v71 = (2 * v68) | 1;
                  uint64_t v72 = 2 * v68 + 2;
                  if (v72 < v67 && **v70 < *v70[2])
                  {
                    v70 += 2;
                    uint64_t v71 = v72;
                  }
                  *(_OWORD *)uint64_t v69 = *(_OWORD *)v70;
                  uint64_t v69 = v70;
                  uint64_t v68 = v71;
                }
                while (v71 <= (uint64_t)((unint64_t)(v67 - 2) >> 1));
                a2 -= 2;
                if (v70 == a2)
                {
                  *(_OWORD *)uint64_t v70 = v89;
                }
                else
                {
                  *(_OWORD *)uint64_t v70 = *(_OWORD *)a2;
                  *(_OWORD *)a2 = v89;
                  uint64_t v73 = (char *)v70 - (char *)v10 + 16;
                  if (v73 >= 17)
                  {
                    unint64_t v74 = (((unint64_t)v73 >> 4) - 2) >> 1;
                    uint64_t v75 = &v10[2 * v74];
                    uint64_t v76 = *v70;
                    if (**v75 < **v70)
                    {
                      uint64_t v77 = v70[1];
                      do
                      {
                        uint64_t v78 = v70;
                        uint64_t v70 = v75;
                        *(_OWORD *)uint64_t v78 = *(_OWORD *)v75;
                        if (!v74) {
                          break;
                        }
                        unint64_t v74 = (v74 - 1) >> 1;
                        uint64_t v75 = &v10[2 * v74];
                      }
                      while (**v75 < *v76);
                      *uint64_t v70 = v76;
                      v70[1] = v77;
                    }
                  }
                }
              }
              while (v67-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = &v10[2 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, &a1[2 * (v12 >> 1)], (_OWORD *)a2 - 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1 + 2, v14 - 2, (_OWORD *)a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1 + 4, &a1[2 * v13 + 2], (_OWORD *)a2 - 3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v14 - 2, v14, &a1[2 * v13 + 2]);
            long long v85 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *(_OWORD *)v14;
            *(_OWORD *)uint64_t v14 = v85;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(&a1[2 * (v12 >> 1)], a1, (_OWORD *)a2 - 1);
          }
          --a3;
          unsigned int v15 = *a1;
          unsigned int v16 = **a1;
          if ((a4 & 1) != 0 || **(a1 - 2) < v16) {
            break;
          }
          if (v16 >= **(a2 - 2))
          {
            uint64_t v30 = a1 + 2;
            do
            {
              uint64_t v10 = v30;
              if (v30 >= a2) {
                break;
              }
              v30 += 2;
            }
            while (v16 >= **v10);
          }
          else
          {
            uint64_t v10 = a1;
            do
            {
              uint64_t v29 = v10[2];
              v10 += 2;
            }
            while (v16 >= *v29);
          }
          __n128 v31 = a2;
          if (v10 < a2)
          {
            __n128 v31 = a2;
            do
            {
              unint64_t v32 = *(v31 - 2);
              v31 -= 2;
            }
            while (v16 < *v32);
          }
          uint64_t v33 = a1[1];
          while (v10 < v31)
          {
            long long v87 = *(_OWORD *)v10;
            *(_OWORD *)uint64_t v10 = *(_OWORD *)v31;
            *(_OWORD *)__n128 v31 = v87;
            unsigned int v34 = *v15;
            do
            {
              uint64_t v35 = v10[2];
              v10 += 2;
            }
            while (v34 >= *v35);
            do
            {
              uint64_t v36 = *(v31 - 2);
              v31 -= 2;
            }
            while (v34 < *v36);
          }
          BOOL v4 = v10 - 2 >= a1;
          BOOL v5 = v10 - 2 == a1;
          if (v10 - 2 != a1) {
            *(_OWORD *)a1 = *((_OWORD *)v10 - 1);
          }
          a4 = 0;
          *(v10 - 2) = v15;
          *(v10 - 1) = v33;
        }
        uint64_t v17 = 0;
        uint64_t v18 = a1[1];
        do
        {
          unsigned int v19 = *a1[v17 + 2];
          v17 += 2;
        }
        while (v19 < v16);
        int v20 = &a1[v17];
        BOOL v21 = a2;
        if (v17 == 2)
        {
          BOOL v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            uint64_t v23 = *(v21 - 2);
            v21 -= 2;
          }
          while (*v23 >= v16);
        }
        else
        {
          do
          {
            uint64_t v22 = *(v21 - 2);
            v21 -= 2;
          }
          while (*v22 >= v16);
        }
        uint64_t v10 = &a1[v17];
        if (v20 < v21)
        {
          unint64_t v24 = v21;
          do
          {
            long long v86 = *(_OWORD *)v10;
            *(_OWORD *)uint64_t v10 = *(_OWORD *)v24;
            *(_OWORD *)unint64_t v24 = v86;
            unsigned int v25 = *v15;
            do
            {
              uint64_t v26 = v10[2];
              v10 += 2;
            }
            while (*v26 < v25);
            do
            {
              unint64_t v27 = *(v24 - 2);
              v24 -= 2;
            }
            while (*v27 >= v25);
          }
          while (v10 < v24);
        }
        if (v10 - 2 != a1) {
          *(_OWORD *)a1 = *((_OWORD *)v10 - 1);
        }
        *(v10 - 2) = v15;
        *(v10 - 1) = v18;
        if (v20 >= v21) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(a1, v10 - 2, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, v10 - 2);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v10, a2))
      {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = v10 - 2;
    if (!v28) {
      continue;
    }
    break;
  }
}

unsigned __int16 **std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **result, unsigned __int16 **a2, _OWORD *a3)
{
  unsigned int v3 = **a2;
  unsigned int v4 = **(unsigned __int16 **)a3;
  if (v3 >= **result)
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
      *a3 = v6;
      if (**a2 < **result)
      {
        long long v7 = *(_OWORD *)result;
        *(_OWORD *)__n128 result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *(_OWORD *)result;
      *(_OWORD *)__n128 result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**(unsigned __int16 **)a3 >= **a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
    }
    else
    {
      long long v5 = *(_OWORD *)result;
      *(_OWORD *)__n128 result = *a3;
    }
    *a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **a1, unsigned __int16 **a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)long long v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      long long v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      unsigned int v9 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unint64_t v12 = *v9;
    if (**v9 < **v8)
    {
      unint64_t v13 = v9[1];
      uint64_t v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        unsigned int v15 = **(unsigned __int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          unsigned int v16 = (unsigned __int16 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      unsigned int v16 = a1;
LABEL_12:
      *unsigned int v16 = v12;
      v16[1] = v13;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    long long v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **a1, unsigned __int16 **a2, __n128 *a3, __n128 *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a2, a3);
  if (*(unsigned __int16 *)a4->n128_u64[0] < *(unsigned __int16 *)a3->n128_u64[0])
  {
    __n128 result = *a3;
    *a3 = *a4;
    *a4 = result;
    if (*(unsigned __int16 *)a3->n128_u64[0] < **a2)
    {
      __n128 result = *(__n128 *)a2;
      *(__n128 *)a2 = *a3;
      *a3 = result;
      if (**a2 < **a1)
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **a1, unsigned __int16 **a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(unsigned __int16 *)a5->n128_u64[0] < *(unsigned __int16 *)a4->n128_u64[0])
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(unsigned __int16 *)a4->n128_u64[0] < *(unsigned __int16 *)a3->n128_u64[0])
    {
      __n128 result = *a3;
      *a3 = *a4;
      *a4 = result;
      if (*(unsigned __int16 *)a3->n128_u64[0] < **a2)
      {
        __n128 result = *(__n128 *)a2;
        *(__n128 *)a2 = *a3;
        *a3 = result;
        if (**a2 < **a1)
        {
          __n128 result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(unsigned __int8 **a1, unsigned __int8 **a2, uint64_t a3, char a4)
{
  while (2)
  {
    uint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = ((char *)a2 - (char *)v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v38 = *(a2 - 2);
                uint64_t v37 = a2 - 2;
                if (*v38 < **v10)
                {
                  long long v88 = *(_OWORD *)v10;
                  *(_OWORD *)uint64_t v10 = *(_OWORD *)v37;
                  *(_OWORD *)uint64_t v37 = v88;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v10, v10 + 2, (_OWORD *)a2 - 1);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v10, v10 + 2, (__n128 *)v10 + 2, (__n128 *)a2 - 1);
                break;
              case 5uLL:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v10, v10 + 2, (__n128 *)v10 + 2, (__n128 *)v10 + 3, (__n128 *)a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            uint64_t v39 = v10 + 2;
            BOOL v41 = v10 == a2 || v39 == a2;
            if (a4)
            {
              if (!v41)
              {
                uint64_t v42 = 0;
                unint64_t v43 = v10;
                do
                {
                  __n128 v44 = v39;
                  uint64_t v45 = v43[2];
                  if (*v45 < **v43)
                  {
                    uint64_t v46 = v43[3];
                    uint64_t v47 = v42;
                    while (1)
                    {
                      *(_OWORD *)((char *)v10 + v47 + 16) = *(_OWORD *)((char *)v10 + v47);
                      if (!v47) {
                        break;
                      }
                      unsigned int v48 = **(unsigned __int8 **)((char *)v10 + v47 - 16);
                      v47 -= 16;
                      if (*v45 >= v48)
                      {
                        uint64_t v49 = (unsigned __int8 **)((char *)v10 + v47 + 16);
                        goto LABEL_79;
                      }
                    }
                    uint64_t v49 = v10;
LABEL_79:
                    *uint64_t v49 = v45;
                    v49[1] = v46;
                  }
                  uint64_t v39 = v44 + 2;
                  v42 += 16;
                  unint64_t v43 = v44;
                }
                while (v44 + 2 != a2);
              }
            }
            else if (!v41)
            {
              do
              {
                v80 = v39;
                uint64_t v81 = a1[2];
                if (*v81 < **a1)
                {
                  v82 = a1[3];
                  BOOL v83 = v80;
                  do
                  {
                    *(_OWORD *)BOOL v83 = *((_OWORD *)v83 - 1);
                    long long v84 = *(v83 - 4);
                    v83 -= 2;
                  }
                  while (*v81 < *v84);
                  *BOOL v83 = v81;
                  v83[1] = v82;
                }
                uint64_t v39 = v80 + 2;
                a1 = v80;
              }
              while (v80 + 2 != a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v50 = (v12 - 2) >> 1;
              int64_t v51 = v50;
              do
              {
                int64_t v52 = v51;
                if (v50 >= v51)
                {
                  uint64_t v53 = (2 * v51) | 1;
                  uint64_t v54 = &v10[2 * v53];
                  if (2 * v52 + 2 < (uint64_t)v12)
                  {
                    unsigned int v55 = **v54;
                    unsigned int v57 = *v54[2];
                    BOOL v56 = v55 >= v57;
                    if (v55 > v57) {
                      unsigned int v57 = **v54;
                    }
                    if (!v56)
                    {
                      v54 += 2;
                      uint64_t v53 = 2 * v52 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v57 = **v54;
                  }
                  __int16 v58 = &v10[2 * v52];
                  int v59 = *v58;
                  if (v57 >= **v58)
                  {
                    uint64_t v60 = v58[1];
                    do
                    {
                      uint64_t v61 = v58;
                      __int16 v58 = v54;
                      *(_OWORD *)uint64_t v61 = *(_OWORD *)v54;
                      if (v50 < v53) {
                        break;
                      }
                      uint64_t v62 = (2 * v53) | 1;
                      uint64_t v54 = &v10[2 * v62];
                      uint64_t v53 = 2 * v53 + 2;
                      if (v53 < (uint64_t)v12)
                      {
                        unsigned int v63 = **v54;
                        unsigned int v64 = *v54[2];
                        BOOL v65 = v63 >= v64;
                        unsigned int v66 = v63 <= v64 ? *v54[2] : **v54;
                        if (v65) {
                          uint64_t v53 = v62;
                        }
                        else {
                          v54 += 2;
                        }
                      }
                      else
                      {
                        unsigned int v66 = **v54;
                        uint64_t v53 = v62;
                      }
                    }
                    while (v66 >= *v59);
                    *__int16 v58 = v59;
                    v58[1] = v60;
                  }
                }
                int64_t v51 = v52 - 1;
              }
              while (v52);
              uint64_t v67 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v68 = 0;
                long long v89 = *(_OWORD *)v10;
                uint64_t v69 = v10;
                do
                {
                  uint64_t v70 = &v69[2 * v68 + 2];
                  uint64_t v71 = (2 * v68) | 1;
                  uint64_t v72 = 2 * v68 + 2;
                  if (v72 < v67 && **v70 < *v70[2])
                  {
                    v70 += 2;
                    uint64_t v71 = v72;
                  }
                  *(_OWORD *)uint64_t v69 = *(_OWORD *)v70;
                  uint64_t v69 = v70;
                  uint64_t v68 = v71;
                }
                while (v71 <= (uint64_t)((unint64_t)(v67 - 2) >> 1));
                a2 -= 2;
                if (v70 == a2)
                {
                  *(_OWORD *)uint64_t v70 = v89;
                }
                else
                {
                  *(_OWORD *)uint64_t v70 = *(_OWORD *)a2;
                  *(_OWORD *)a2 = v89;
                  uint64_t v73 = (char *)v70 - (char *)v10 + 16;
                  if (v73 >= 17)
                  {
                    unint64_t v74 = (((unint64_t)v73 >> 4) - 2) >> 1;
                    uint64_t v75 = &v10[2 * v74];
                    uint64_t v76 = *v70;
                    if (**v75 < **v70)
                    {
                      uint64_t v77 = v70[1];
                      do
                      {
                        uint64_t v78 = v70;
                        uint64_t v70 = v75;
                        *(_OWORD *)uint64_t v78 = *(_OWORD *)v75;
                        if (!v74) {
                          break;
                        }
                        unint64_t v74 = (v74 - 1) >> 1;
                        uint64_t v75 = &v10[2 * v74];
                      }
                      while (**v75 < *v76);
                      *uint64_t v70 = v76;
                      v70[1] = v77;
                    }
                  }
                }
              }
              while (v67-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = &v10[2 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, &a1[2 * (v12 >> 1)], (_OWORD *)a2 - 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1 + 2, v14 - 2, (_OWORD *)a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1 + 4, &a1[2 * v13 + 2], (_OWORD *)a2 - 3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v14 - 2, v14, &a1[2 * v13 + 2]);
            long long v85 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *(_OWORD *)v14;
            *(_OWORD *)uint64_t v14 = v85;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(&a1[2 * (v12 >> 1)], a1, (_OWORD *)a2 - 1);
          }
          --a3;
          unsigned int v15 = *a1;
          unsigned int v16 = **a1;
          if ((a4 & 1) != 0 || **(a1 - 2) < v16) {
            break;
          }
          if (v16 >= **(a2 - 2))
          {
            uint64_t v30 = a1 + 2;
            do
            {
              uint64_t v10 = v30;
              if (v30 >= a2) {
                break;
              }
              v30 += 2;
            }
            while (v16 >= **v10);
          }
          else
          {
            uint64_t v10 = a1;
            do
            {
              uint64_t v29 = v10[2];
              v10 += 2;
            }
            while (v16 >= *v29);
          }
          __n128 v31 = a2;
          if (v10 < a2)
          {
            __n128 v31 = a2;
            do
            {
              unint64_t v32 = *(v31 - 2);
              v31 -= 2;
            }
            while (v16 < *v32);
          }
          uint64_t v33 = a1[1];
          while (v10 < v31)
          {
            long long v87 = *(_OWORD *)v10;
            *(_OWORD *)uint64_t v10 = *(_OWORD *)v31;
            *(_OWORD *)__n128 v31 = v87;
            unsigned int v34 = *v15;
            do
            {
              uint64_t v35 = v10[2];
              v10 += 2;
            }
            while (v34 >= *v35);
            do
            {
              uint64_t v36 = *(v31 - 2);
              v31 -= 2;
            }
            while (v34 < *v36);
          }
          BOOL v4 = v10 - 2 >= a1;
          BOOL v5 = v10 - 2 == a1;
          if (v10 - 2 != a1) {
            *(_OWORD *)a1 = *((_OWORD *)v10 - 1);
          }
          a4 = 0;
          *(v10 - 2) = v15;
          *(v10 - 1) = v33;
        }
        uint64_t v17 = 0;
        uint64_t v18 = a1[1];
        do
        {
          unsigned int v19 = *a1[v17 + 2];
          v17 += 2;
        }
        while (v19 < v16);
        int v20 = &a1[v17];
        BOOL v21 = a2;
        if (v17 == 2)
        {
          BOOL v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            uint64_t v23 = *(v21 - 2);
            v21 -= 2;
          }
          while (*v23 >= v16);
        }
        else
        {
          do
          {
            uint64_t v22 = *(v21 - 2);
            v21 -= 2;
          }
          while (*v22 >= v16);
        }
        uint64_t v10 = &a1[v17];
        if (v20 < v21)
        {
          unint64_t v24 = v21;
          do
          {
            long long v86 = *(_OWORD *)v10;
            *(_OWORD *)uint64_t v10 = *(_OWORD *)v24;
            *(_OWORD *)unint64_t v24 = v86;
            unsigned int v25 = *v15;
            do
            {
              uint64_t v26 = v10[2];
              v10 += 2;
            }
            while (*v26 < v25);
            do
            {
              unint64_t v27 = *(v24 - 2);
              v24 -= 2;
            }
            while (*v27 >= v25);
          }
          while (v10 < v24);
        }
        if (v10 - 2 != a1) {
          *(_OWORD *)a1 = *((_OWORD *)v10 - 1);
        }
        *(v10 - 2) = v15;
        *(v10 - 1) = v18;
        if (v20 >= v21) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(a1, v10 - 2, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, v10 - 2);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v10, a2))
      {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = v10 - 2;
    if (!v28) {
      continue;
    }
    break;
  }
}

unsigned __int8 **std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **result, unsigned __int8 **a2, _OWORD *a3)
{
  unsigned int v3 = **a2;
  unsigned int v4 = **(unsigned __int8 **)a3;
  if (v3 >= **result)
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
      *a3 = v6;
      if (**a2 < **result)
      {
        long long v7 = *(_OWORD *)result;
        *(_OWORD *)__n128 result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *(_OWORD *)result;
      *(_OWORD *)__n128 result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**(unsigned __int8 **)a3 >= **a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
    }
    else
    {
      long long v5 = *(_OWORD *)result;
      *(_OWORD *)__n128 result = *a3;
    }
    *a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **a1, unsigned __int8 **a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)long long v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      long long v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      unsigned int v9 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unint64_t v12 = *v9;
    if (**v9 < **v8)
    {
      unint64_t v13 = v9[1];
      uint64_t v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        unsigned int v15 = **(unsigned __int8 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          unsigned int v16 = (unsigned __int8 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      unsigned int v16 = a1;
LABEL_12:
      *unsigned int v16 = v12;
      v16[1] = v13;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    long long v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **a1, unsigned __int8 **a2, __n128 *a3, __n128 *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a2, a3);
  if (*(unsigned __int8 *)a4->n128_u64[0] < *(unsigned __int8 *)a3->n128_u64[0])
  {
    __n128 result = *a3;
    *a3 = *a4;
    *a4 = result;
    if (*(unsigned __int8 *)a3->n128_u64[0] < **a2)
    {
      __n128 result = *(__n128 *)a2;
      *(__n128 *)a2 = *a3;
      *a3 = result;
      if (**a2 < **a1)
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **a1, unsigned __int8 **a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(unsigned __int8 *)a5->n128_u64[0] < *(unsigned __int8 *)a4->n128_u64[0])
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(unsigned __int8 *)a4->n128_u64[0] < *(unsigned __int8 *)a3->n128_u64[0])
    {
      __n128 result = *a3;
      *a3 = *a4;
      *a4 = result;
      if (*(unsigned __int8 *)a3->n128_u64[0] < **a2)
      {
        __n128 result = *(__n128 *)a2;
        *(__n128 *)a2 = *a3;
        *a3 = result;
        if (**a2 < **a1)
        {
          __n128 result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(long long *a1, __n128 *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = (unint64_t)a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = (long long *)v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v38 = (void *)a2[-1].n128_u64[0];
                uint64_t v37 = (long long *)&a2[-1];
                if (*v38 < **(void **)v10)
                {
                  long long v86 = *(_OWORD *)v10;
                  *(_OWORD *)unint64_t v10 = *v37;
                  *uint64_t v37 = v86;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v10, (uint64_t **)(v10 + 16), (uint64_t **)&a2[-1]);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v10, (uint64_t **)(v10 + 16), (uint64_t **)(v10 + 32), (__n128 *)a2[-1].n128_u64);
                break;
              case 5uLL:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v10, (uint64_t **)(v10 + 16), (uint64_t **)(v10 + 32), (__n128 *)(v10 + 48), a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            uint64_t v39 = (__n128 *)(v10 + 16);
            BOOL v41 = (__n128 *)v10 == a2 || v39 == a2;
            if (a4)
            {
              if (!v41)
              {
                uint64_t v42 = 0;
                unint64_t v43 = v10;
                do
                {
                  __n128 v44 = v39;
                  uint64_t v45 = *(void **)(v43 + 16);
                  if (*v45 < **(void **)v43)
                  {
                    uint64_t v46 = *(void *)(v43 + 24);
                    uint64_t v47 = v42;
                    while (1)
                    {
                      *(_OWORD *)(v10 + v47 + 16) = *(_OWORD *)(v10 + v47);
                      if (!v47) {
                        break;
                      }
                      uint64_t v48 = **(void **)(v10 + v47 - 16);
                      v47 -= 16;
                      if (*v45 >= v48)
                      {
                        uint64_t v49 = (void *)(v10 + v47 + 16);
                        goto LABEL_79;
                      }
                    }
                    uint64_t v49 = (void *)v10;
LABEL_79:
                    *uint64_t v49 = v45;
                    v49[1] = v46;
                  }
                  uint64_t v39 = v44 + 1;
                  v42 += 16;
                  unint64_t v43 = (unint64_t)v44;
                }
                while (&v44[1] != a2);
              }
            }
            else if (!v41)
            {
              do
              {
                uint64_t v78 = v39;
                uint64_t v79 = (void *)*((void *)a1 + 2);
                if (*v79 < **(void **)a1)
                {
                  v80 = (void *)*((void *)a1 + 3);
                  uint64_t v81 = v78;
                  do
                  {
                    *uint64_t v81 = v81[-1];
                    v82 = (void *)v81[-2].n128_u64[0];
                    --v81;
                  }
                  while (*v79 < *v82);
                  v81->n128_u64[0] = (unint64_t)v79;
                  v81->n128_u64[1] = (unint64_t)v80;
                }
                uint64_t v39 = v78 + 1;
                a1 = (long long *)v78;
              }
              while (&v78[1] != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((__n128 *)v10 != a2)
            {
              int64_t v50 = (v12 - 2) >> 1;
              int64_t v51 = v50;
              do
              {
                int64_t v52 = v51;
                if (v50 >= v51)
                {
                  uint64_t v53 = (2 * v51) | 1;
                  uint64_t v54 = (uint64_t **)(v10 + 16 * v53);
                  if (2 * v52 + 2 < (uint64_t)v12)
                  {
                    uint64_t v55 = **v54;
                    uint64_t v57 = *v54[2];
                    BOOL v56 = v55 < v57;
                    if (v55 > v57) {
                      uint64_t v57 = **v54;
                    }
                    if (v56)
                    {
                      v54 += 2;
                      uint64_t v53 = 2 * v52 + 2;
                    }
                  }
                  else
                  {
                    uint64_t v57 = **v54;
                  }
                  __int16 v58 = (uint64_t **)(v10 + 16 * v52);
                  int v59 = *v58;
                  if (v57 >= **v58)
                  {
                    uint64_t v60 = v58[1];
                    do
                    {
                      uint64_t v61 = v58;
                      __int16 v58 = v54;
                      *(_OWORD *)uint64_t v61 = *(_OWORD *)v54;
                      if (v50 < v53) {
                        break;
                      }
                      uint64_t v62 = (2 * v53) | 1;
                      uint64_t v54 = (uint64_t **)(v10 + 16 * v62);
                      uint64_t v53 = 2 * v53 + 2;
                      if (v53 < (uint64_t)v12)
                      {
                        uint64_t v65 = **v54;
                        uint64_t v63 = *v54[2];
                        BOOL v64 = v65 < v63;
                        if (v65 <= v63) {
                          uint64_t v65 = *v54[2];
                        }
                        if (v64) {
                          v54 += 2;
                        }
                        else {
                          uint64_t v53 = v62;
                        }
                      }
                      else
                      {
                        uint64_t v65 = **v54;
                        uint64_t v53 = v62;
                      }
                    }
                    while (v65 >= *v59);
                    *__int16 v58 = v59;
                    v58[1] = v60;
                  }
                }
                int64_t v51 = v52 - 1;
              }
              while (v52);
              uint64_t v66 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v67 = 0;
                long long v87 = *(_OWORD *)v10;
                uint64_t v68 = (_OWORD *)v10;
                do
                {
                  uint64_t v69 = (uint64_t)&v68[v67 + 1];
                  uint64_t v70 = (2 * v67) | 1;
                  uint64_t v71 = 2 * v67 + 2;
                  if (v71 < v66 && **(void **)v69 < **(void **)(v69 + 16))
                  {
                    v69 += 16;
                    uint64_t v70 = v71;
                  }
                  _OWORD *v68 = *(_OWORD *)v69;
                  uint64_t v68 = (_OWORD *)v69;
                  uint64_t v67 = v70;
                }
                while (v70 <= (uint64_t)((unint64_t)(v66 - 2) >> 1));
                if ((__n128 *)v69 == --a2)
                {
                  *(_OWORD *)uint64_t v69 = v87;
                }
                else
                {
                  *(__n128 *)uint64_t v69 = *a2;
                  *a2 = (__n128)v87;
                  uint64_t v72 = v69 - v10 + 16;
                  if (v72 >= 17)
                  {
                    unint64_t v73 = (((unint64_t)v72 >> 4) - 2) >> 1;
                    unint64_t v74 = (_OWORD *)(v10 + 16 * v73);
                    uint64_t v75 = *(void **)v69;
                    if (**(void **)v74 < **(void **)v69)
                    {
                      uint64_t v76 = *(void *)(v69 + 8);
                      do
                      {
                        uint64_t v77 = (_OWORD *)v69;
                        uint64_t v69 = (uint64_t)v74;
                        *uint64_t v77 = *v74;
                        if (!v73) {
                          break;
                        }
                        unint64_t v73 = (v73 - 1) >> 1;
                        unint64_t v74 = (_OWORD *)(v10 + 16 * v73);
                      }
                      while (**(void **)v74 < *v75);
                      *(void *)uint64_t v69 = v75;
                      *(void *)(v69 + 8) = v76;
                    }
                  }
                }
                BOOL v56 = v66-- <= 2;
              }
              while (!v56);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (uint64_t **)(v10 + 16 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(a1, (uint64_t **)&a1[v12 >> 1], (uint64_t **)&a2[-1]);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(a1 + 1, v14 - 2, (uint64_t **)&a2[-2]);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(a1 + 2, (uint64_t **)&a1[v13 + 1], (uint64_t **)&a2[-3]);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v14 - 1, v14, (uint64_t **)&a1[v13 + 1]);
            long long v83 = *a1;
            *a1 = *(_OWORD *)v14;
            *(_OWORD *)uint64_t v14 = v83;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(&a1[v12 >> 1], (uint64_t **)a1, (uint64_t **)&a2[-1]);
          }
          --a3;
          unsigned int v15 = *(uint64_t **)a1;
          uint64_t v16 = **(void **)a1;
          if ((a4 & 1) != 0 || **((void **)a1 - 2) < v16) {
            break;
          }
          if (v16 >= *(void *)a2[-1].n128_u64[0])
          {
            uint64_t v30 = (void **)(a1 + 1);
            do
            {
              unint64_t v10 = (unint64_t)v30;
              if (v30 >= (void **)a2) {
                break;
              }
              v30 += 2;
            }
            while (v16 >= **(void **)v10);
          }
          else
          {
            unint64_t v10 = (unint64_t)a1;
            do
            {
              uint64_t v29 = *(void **)(v10 + 16);
              v10 += 16;
            }
            while (v16 >= *v29);
          }
          __n128 v31 = (long long *)a2;
          if (v10 < (unint64_t)a2)
          {
            __n128 v31 = (long long *)a2;
            do
              unint64_t v32 = (void *)*((void *)v31-- - 2);
            while (v16 < *v32);
          }
          uint64_t v33 = (void *)*((void *)a1 + 1);
          while (v10 < (unint64_t)v31)
          {
            long long v85 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v31;
            *__n128 v31 = v85;
            uint64_t v34 = *v15;
            do
            {
              uint64_t v35 = *(void **)(v10 + 16);
              v10 += 16;
            }
            while (v34 >= *v35);
            do
              uint64_t v36 = (void *)*((void *)v31-- - 2);
            while (v34 < *v36);
          }
          BOOL v4 = v10 - 16 >= (unint64_t)a1;
          BOOL v5 = v10 - 16 == (void)a1;
          if ((long long *)(v10 - 16) != a1) {
            *a1 = *(_OWORD *)(v10 - 16);
          }
          a4 = 0;
          *(void *)(v10 - 16) = v15;
          *(void *)(v10 - 8) = v33;
        }
        uint64_t v17 = 0;
        uint64_t v18 = (void *)*((void *)a1 + 1);
        do
          uint64_t v19 = **(void **)&a1[++v17];
        while (v19 < v16);
        int v20 = &a1[v17];
        BOOL v21 = a2;
        if (v17 == 1)
        {
          BOOL v21 = a2;
          do
          {
            if (v20 >= (long long *)v21) {
              break;
            }
            uint64_t v23 = (void *)v21[-1].n128_u64[0];
            --v21;
          }
          while (*v23 >= v16);
        }
        else
        {
          do
          {
            uint64_t v22 = (void *)v21[-1].n128_u64[0];
            --v21;
          }
          while (*v22 >= v16);
        }
        unint64_t v10 = (unint64_t)&a1[v17];
        if (v20 < (long long *)v21)
        {
          unint64_t v24 = (long long *)v21;
          do
          {
            long long v84 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v24;
            *unint64_t v24 = v84;
            uint64_t v25 = *v15;
            do
            {
              uint64_t v26 = *(void **)(v10 + 16);
              v10 += 16;
            }
            while (*v26 < v25);
            do
              unint64_t v27 = (void *)*((void *)v24-- - 2);
            while (*v27 >= v25);
          }
          while (v10 < (unint64_t)v24);
        }
        if ((long long *)(v10 - 16) != a1) {
          *a1 = *(_OWORD *)(v10 - 16);
        }
        *(void *)(v10 - 16) = v15;
        *(void *)(v10 - 8) = v18;
        if (v20 >= (long long *)v21) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(a1, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((uint64_t)a1, v10 - 16);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = (__n128 *)(v10 - 16);
    if (!v28) {
      continue;
    }
    break;
  }
}

long long *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(long long *result, uint64_t **a2, uint64_t **a3)
{
  uint64_t v3 = **a2;
  uint64_t v4 = **a3;
  if (v3 >= **(void **)result)
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (**a2 < **(void **)result)
      {
        long long v7 = *result;
        *__n128 result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *result;
      *__n128 result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**a3 >= **a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      long long v5 = *result;
      *__n128 result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = (long long *)(a2 - 16);
      if (**(void **)(a2 - 16) < **(void **)a1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *long long v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      long long v8 = (void **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32));
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unint64_t v12 = *(void **)v9;
    if (**(void **)v9 < **v8)
    {
      uint64_t v13 = *(void *)(v9 + 8);
      uint64_t v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        uint64_t v15 = **(void **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          uint64_t v16 = (void *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      uint64_t v16 = (void *)a1;
LABEL_12:
      *uint64_t v16 = v12;
      v16[1] = v13;
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }
    long long v8 = (void **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(long long *a1, uint64_t **a2, uint64_t **a3, _OWORD *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(a1, a2, a3);
  if (**(void **)a4 < **a3)
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (**a3 < **a2)
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (**a2 < **(void **)a1)
      {
        __n128 result = (__n128)*a1;
        *a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(long long *a1, uint64_t **a2, uint64_t **a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(void *)a5->n128_u64[0] < *(void *)a4->n128_u64[0])
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(void *)a4->n128_u64[0] < **a3)
    {
      __n128 result = *(__n128 *)a3;
      *(__n128 *)a3 = *a4;
      *a4 = result;
      if (**a3 < **a2)
      {
        __n128 result = *(__n128 *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(__n128 *)a3 = result;
        if (**a2 < **(void **)a1)
        {
          __n128 result = (__n128)*a1;
          *a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(long long *a1, __n128 *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = (unint64_t)a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = (long long *)v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v38 = (_DWORD *)a2[-1].n128_u64[0];
                uint64_t v37 = (long long *)&a2[-1];
                if (*v38 < **(_DWORD **)v10)
                {
                  long long v86 = *(_OWORD *)v10;
                  *(_OWORD *)unint64_t v10 = *v37;
                  *uint64_t v37 = v86;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v10, (int **)(v10 + 16), (int **)&a2[-1]);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v10, (int **)(v10 + 16), (int **)(v10 + 32), (__n128 *)a2[-1].n128_u64);
                break;
              case 5uLL:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v10, (int **)(v10 + 16), (int **)(v10 + 32), (__n128 *)(v10 + 48), a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            uint64_t v39 = (__n128 *)(v10 + 16);
            BOOL v41 = (__n128 *)v10 == a2 || v39 == a2;
            if (a4)
            {
              if (!v41)
              {
                uint64_t v42 = 0;
                unint64_t v43 = v10;
                do
                {
                  __n128 v44 = v39;
                  uint64_t v45 = *(_DWORD **)(v43 + 16);
                  if (*v45 < **(_DWORD **)v43)
                  {
                    uint64_t v46 = *(void *)(v43 + 24);
                    uint64_t v47 = v42;
                    while (1)
                    {
                      *(_OWORD *)(v10 + v47 + 16) = *(_OWORD *)(v10 + v47);
                      if (!v47) {
                        break;
                      }
                      int v48 = **(_DWORD **)(v10 + v47 - 16);
                      v47 -= 16;
                      if (*v45 >= v48)
                      {
                        uint64_t v49 = (void *)(v10 + v47 + 16);
                        goto LABEL_79;
                      }
                    }
                    uint64_t v49 = (void *)v10;
LABEL_79:
                    *uint64_t v49 = v45;
                    v49[1] = v46;
                  }
                  uint64_t v39 = v44 + 1;
                  v42 += 16;
                  unint64_t v43 = (unint64_t)v44;
                }
                while (&v44[1] != a2);
              }
            }
            else if (!v41)
            {
              do
              {
                uint64_t v78 = v39;
                uint64_t v79 = (_DWORD *)*((void *)a1 + 2);
                if (*v79 < **(_DWORD **)a1)
                {
                  v80 = (_DWORD *)*((void *)a1 + 3);
                  uint64_t v81 = v78;
                  do
                  {
                    *uint64_t v81 = v81[-1];
                    v82 = (_DWORD *)v81[-2].n128_u64[0];
                    --v81;
                  }
                  while (*v79 < *v82);
                  v81->n128_u64[0] = (unint64_t)v79;
                  v81->n128_u64[1] = (unint64_t)v80;
                }
                uint64_t v39 = v78 + 1;
                a1 = (long long *)v78;
              }
              while (&v78[1] != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((__n128 *)v10 != a2)
            {
              int64_t v50 = (v12 - 2) >> 1;
              int64_t v51 = v50;
              do
              {
                int64_t v52 = v51;
                if (v50 >= v51)
                {
                  uint64_t v53 = (2 * v51) | 1;
                  uint64_t v54 = (int **)(v10 + 16 * v53);
                  if (2 * v52 + 2 < (uint64_t)v12)
                  {
                    int v55 = **v54;
                    int v57 = *v54[2];
                    BOOL v56 = v55 < v57;
                    if (v55 > v57) {
                      int v57 = **v54;
                    }
                    if (v56)
                    {
                      v54 += 2;
                      uint64_t v53 = 2 * v52 + 2;
                    }
                  }
                  else
                  {
                    int v57 = **v54;
                  }
                  __int16 v58 = (int **)(v10 + 16 * v52);
                  int v59 = *v58;
                  if (v57 >= **v58)
                  {
                    uint64_t v60 = v58[1];
                    do
                    {
                      uint64_t v61 = v58;
                      __int16 v58 = v54;
                      *(_OWORD *)uint64_t v61 = *(_OWORD *)v54;
                      if (v50 < v53) {
                        break;
                      }
                      uint64_t v62 = (2 * v53) | 1;
                      uint64_t v54 = (int **)(v10 + 16 * v62);
                      uint64_t v53 = 2 * v53 + 2;
                      if (v53 < (uint64_t)v12)
                      {
                        int v65 = **v54;
                        int v63 = *v54[2];
                        BOOL v64 = v65 < v63;
                        if (v65 <= v63) {
                          int v65 = *v54[2];
                        }
                        if (v64) {
                          v54 += 2;
                        }
                        else {
                          uint64_t v53 = v62;
                        }
                      }
                      else
                      {
                        int v65 = **v54;
                        uint64_t v53 = v62;
                      }
                    }
                    while (v65 >= *v59);
                    *__int16 v58 = v59;
                    v58[1] = v60;
                  }
                }
                int64_t v51 = v52 - 1;
              }
              while (v52);
              uint64_t v66 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v67 = 0;
                long long v87 = *(_OWORD *)v10;
                uint64_t v68 = (_OWORD *)v10;
                do
                {
                  uint64_t v69 = (uint64_t)&v68[v67 + 1];
                  uint64_t v70 = (2 * v67) | 1;
                  uint64_t v71 = 2 * v67 + 2;
                  if (v71 < v66 && **(_DWORD **)v69 < **(_DWORD **)(v69 + 16))
                  {
                    v69 += 16;
                    uint64_t v70 = v71;
                  }
                  _OWORD *v68 = *(_OWORD *)v69;
                  uint64_t v68 = (_OWORD *)v69;
                  uint64_t v67 = v70;
                }
                while (v70 <= (uint64_t)((unint64_t)(v66 - 2) >> 1));
                if ((__n128 *)v69 == --a2)
                {
                  *(_OWORD *)uint64_t v69 = v87;
                }
                else
                {
                  *(__n128 *)uint64_t v69 = *a2;
                  *a2 = (__n128)v87;
                  uint64_t v72 = v69 - v10 + 16;
                  if (v72 >= 17)
                  {
                    unint64_t v73 = (((unint64_t)v72 >> 4) - 2) >> 1;
                    unint64_t v74 = (_OWORD *)(v10 + 16 * v73);
                    uint64_t v75 = *(_DWORD **)v69;
                    if (**(_DWORD **)v74 < **(_DWORD **)v69)
                    {
                      uint64_t v76 = *(void *)(v69 + 8);
                      do
                      {
                        uint64_t v77 = (_OWORD *)v69;
                        uint64_t v69 = (uint64_t)v74;
                        *uint64_t v77 = *v74;
                        if (!v73) {
                          break;
                        }
                        unint64_t v73 = (v73 - 1) >> 1;
                        unint64_t v74 = (_OWORD *)(v10 + 16 * v73);
                      }
                      while (**(_DWORD **)v74 < *v75);
                      *(void *)uint64_t v69 = v75;
                      *(void *)(v69 + 8) = v76;
                    }
                  }
                }
                BOOL v56 = v66-- <= 2;
              }
              while (!v56);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (int **)(v10 + 16 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(a1, (int **)&a1[v12 >> 1], (int **)&a2[-1]);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(a1 + 1, v14 - 2, (int **)&a2[-2]);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(a1 + 2, (int **)&a1[v13 + 1], (int **)&a2[-3]);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v14 - 1, v14, (int **)&a1[v13 + 1]);
            long long v83 = *a1;
            *a1 = *(_OWORD *)v14;
            *(_OWORD *)uint64_t v14 = v83;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(&a1[v12 >> 1], (int **)a1, (int **)&a2[-1]);
          }
          --a3;
          uint64_t v15 = *(int **)a1;
          int v16 = **(_DWORD **)a1;
          if ((a4 & 1) != 0 || **((_DWORD **)a1 - 2) < v16) {
            break;
          }
          if (v16 >= *(_DWORD *)a2[-1].n128_u64[0])
          {
            uint64_t v30 = (_DWORD **)(a1 + 1);
            do
            {
              unint64_t v10 = (unint64_t)v30;
              if (v30 >= (_DWORD **)a2) {
                break;
              }
              v30 += 2;
            }
            while (v16 >= **(_DWORD **)v10);
          }
          else
          {
            unint64_t v10 = (unint64_t)a1;
            do
            {
              uint64_t v29 = *(_DWORD **)(v10 + 16);
              v10 += 16;
            }
            while (v16 >= *v29);
          }
          __n128 v31 = (long long *)a2;
          if (v10 < (unint64_t)a2)
          {
            __n128 v31 = (long long *)a2;
            do
              unint64_t v32 = (_DWORD *)*((void *)v31-- - 2);
            while (v16 < *v32);
          }
          uint64_t v33 = (_DWORD *)*((void *)a1 + 1);
          while (v10 < (unint64_t)v31)
          {
            long long v85 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v31;
            *__n128 v31 = v85;
            int v34 = *v15;
            do
            {
              uint64_t v35 = *(_DWORD **)(v10 + 16);
              v10 += 16;
            }
            while (v34 >= *v35);
            do
              uint64_t v36 = (_DWORD *)*((void *)v31-- - 2);
            while (v34 < *v36);
          }
          BOOL v4 = v10 - 16 >= (unint64_t)a1;
          BOOL v5 = v10 - 16 == (void)a1;
          if ((long long *)(v10 - 16) != a1) {
            *a1 = *(_OWORD *)(v10 - 16);
          }
          a4 = 0;
          *(void *)(v10 - 16) = v15;
          *(void *)(v10 - 8) = v33;
        }
        uint64_t v17 = 0;
        uint64_t v18 = (_DWORD *)*((void *)a1 + 1);
        do
          int v19 = **(_DWORD **)&a1[++v17];
        while (v19 < v16);
        int v20 = &a1[v17];
        BOOL v21 = a2;
        if (v17 == 1)
        {
          BOOL v21 = a2;
          do
          {
            if (v20 >= (long long *)v21) {
              break;
            }
            uint64_t v23 = (_DWORD *)v21[-1].n128_u64[0];
            --v21;
          }
          while (*v23 >= v16);
        }
        else
        {
          do
          {
            uint64_t v22 = (_DWORD *)v21[-1].n128_u64[0];
            --v21;
          }
          while (*v22 >= v16);
        }
        unint64_t v10 = (unint64_t)&a1[v17];
        if (v20 < (long long *)v21)
        {
          unint64_t v24 = (long long *)v21;
          do
          {
            long long v84 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v24;
            *unint64_t v24 = v84;
            int v25 = *v15;
            do
            {
              uint64_t v26 = *(_DWORD **)(v10 + 16);
              v10 += 16;
            }
            while (*v26 < v25);
            do
              unint64_t v27 = (_DWORD *)*((void *)v24-- - 2);
            while (*v27 >= v25);
          }
          while (v10 < (unint64_t)v24);
        }
        if ((long long *)(v10 - 16) != a1) {
          *a1 = *(_OWORD *)(v10 - 16);
        }
        *(void *)(v10 - 16) = v15;
        *(void *)(v10 - 8) = v18;
        if (v20 >= (long long *)v21) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(a1, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((uint64_t)a1, v10 - 16);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = (__n128 *)(v10 - 16);
    if (!v28) {
      continue;
    }
    break;
  }
}

long long *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(long long *result, int **a2, int **a3)
{
  int v3 = **a2;
  int v4 = **a3;
  if (v3 >= **(_DWORD **)result)
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (**a2 < **(_DWORD **)result)
      {
        long long v7 = *result;
        *__n128 result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *result;
      *__n128 result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**a3 >= **a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      long long v5 = *result;
      *__n128 result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = (long long *)(a2 - 16);
      if (**(_DWORD **)(a2 - 16) < **(_DWORD **)a1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *long long v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)a1, (int **)(a1 + 16), (int **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      long long v8 = (_DWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)a1, (int **)(a1 + 16), (int **)(a1 + 32));
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unint64_t v12 = *(_DWORD **)v9;
    if (**(_DWORD **)v9 < **v8)
    {
      uint64_t v13 = *(void *)(v9 + 8);
      uint64_t v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        int v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          int v16 = (void *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      int v16 = (void *)a1;
LABEL_12:
      *int v16 = v12;
      v16[1] = v13;
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }
    long long v8 = (_DWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(long long *a1, int **a2, int **a3, _OWORD *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(a1, a2, a3);
  if (**(_DWORD **)a4 < **a3)
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (**a3 < **a2)
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (**a2 < **(_DWORD **)a1)
      {
        __n128 result = (__n128)*a1;
        *a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(long long *a1, int **a2, int **a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(_DWORD *)a5->n128_u64[0] < *(_DWORD *)a4->n128_u64[0])
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(_DWORD *)a4->n128_u64[0] < **a3)
    {
      __n128 result = *(__n128 *)a3;
      *(__n128 *)a3 = *a4;
      *a4 = result;
      if (**a3 < **a2)
      {
        __n128 result = *(__n128 *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(__n128 *)a3 = result;
        if (**a2 < **(_DWORD **)a1)
        {
          __n128 result = (__n128)*a1;
          *a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(__int16 **a1, __int16 **a2, uint64_t a3, char a4)
{
  while (2)
  {
    uint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = ((char *)a2 - (char *)v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v38 = *(a2 - 2);
                uint64_t v37 = a2 - 2;
                if (*v38 < **v10)
                {
                  long long v86 = *(_OWORD *)v10;
                  *(_OWORD *)uint64_t v10 = *(_OWORD *)v37;
                  *(_OWORD *)uint64_t v37 = v86;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v10, v10 + 2, (_OWORD *)a2 - 1);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v10, v10 + 2, (__n128 *)v10 + 2, (__n128 *)a2 - 1);
                break;
              case 5uLL:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v10, v10 + 2, (__n128 *)v10 + 2, (__n128 *)v10 + 3, (__n128 *)a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            uint64_t v39 = v10 + 2;
            BOOL v41 = v10 == a2 || v39 == a2;
            if (a4)
            {
              if (!v41)
              {
                uint64_t v42 = 0;
                unint64_t v43 = v10;
                do
                {
                  __n128 v44 = v39;
                  uint64_t v45 = v43[2];
                  if (*v45 < **v43)
                  {
                    uint64_t v46 = v43[3];
                    uint64_t v47 = v42;
                    while (1)
                    {
                      *(_OWORD *)((char *)v10 + v47 + 16) = *(_OWORD *)((char *)v10 + v47);
                      if (!v47) {
                        break;
                      }
                      int v48 = **(__int16 **)((char *)v10 + v47 - 16);
                      v47 -= 16;
                      if (*v45 >= v48)
                      {
                        uint64_t v49 = (__int16 **)((char *)v10 + v47 + 16);
                        goto LABEL_79;
                      }
                    }
                    uint64_t v49 = v10;
LABEL_79:
                    *uint64_t v49 = v45;
                    v49[1] = v46;
                  }
                  uint64_t v39 = v44 + 2;
                  v42 += 16;
                  unint64_t v43 = v44;
                }
                while (v44 + 2 != a2);
              }
            }
            else if (!v41)
            {
              do
              {
                uint64_t v78 = v39;
                uint64_t v79 = a1[2];
                if (*v79 < **a1)
                {
                  v80 = a1[3];
                  uint64_t v81 = v78;
                  do
                  {
                    *(_OWORD *)uint64_t v81 = *((_OWORD *)v81 - 1);
                    v82 = *(v81 - 4);
                    v81 -= 2;
                  }
                  while (*v79 < *v82);
                  *uint64_t v81 = v79;
                  v81[1] = v80;
                }
                uint64_t v39 = v78 + 2;
                a1 = v78;
              }
              while (v78 + 2 != a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v50 = (v12 - 2) >> 1;
              int64_t v51 = v50;
              do
              {
                int64_t v52 = v51;
                if (v50 >= v51)
                {
                  uint64_t v53 = (2 * v51) | 1;
                  uint64_t v54 = &v10[2 * v53];
                  if (2 * v52 + 2 < (uint64_t)v12)
                  {
                    int v55 = **v54;
                    int v57 = *v54[2];
                    BOOL v56 = v55 < v57;
                    if (v55 > v57) {
                      LOWORD(v57) = **v54;
                    }
                    if (v56)
                    {
                      v54 += 2;
                      uint64_t v53 = 2 * v52 + 2;
                    }
                  }
                  else
                  {
                    LOWORD(v57) = **v54;
                  }
                  __int16 v58 = &v10[2 * v52];
                  int v59 = *v58;
                  if (**v58 <= (__int16)v57)
                  {
                    uint64_t v60 = v58[1];
                    do
                    {
                      uint64_t v61 = v58;
                      __int16 v58 = v54;
                      *(_OWORD *)uint64_t v61 = *(_OWORD *)v54;
                      if (v50 < v53) {
                        break;
                      }
                      uint64_t v62 = (2 * v53) | 1;
                      uint64_t v54 = &v10[2 * v62];
                      uint64_t v53 = 2 * v53 + 2;
                      if (v53 < (uint64_t)v12)
                      {
                        int v65 = **v54;
                        int v63 = *v54[2];
                        BOOL v64 = v65 < v63;
                        if (v65 <= v63) {
                          LOWORD(v65) = *v54[2];
                        }
                        if (v64) {
                          v54 += 2;
                        }
                        else {
                          uint64_t v53 = v62;
                        }
                      }
                      else
                      {
                        LOWORD(v65) = **v54;
                        uint64_t v53 = v62;
                      }
                    }
                    while (*v59 <= (__int16)v65);
                    *__int16 v58 = v59;
                    v58[1] = v60;
                  }
                }
                int64_t v51 = v52 - 1;
              }
              while (v52);
              uint64_t v66 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v67 = 0;
                long long v87 = *(_OWORD *)v10;
                uint64_t v68 = v10;
                do
                {
                  uint64_t v69 = &v68[2 * v67 + 2];
                  uint64_t v70 = (2 * v67) | 1;
                  uint64_t v71 = 2 * v67 + 2;
                  if (v71 < v66 && **v69 < *v69[2])
                  {
                    v69 += 2;
                    uint64_t v70 = v71;
                  }
                  *(_OWORD *)uint64_t v68 = *(_OWORD *)v69;
                  uint64_t v68 = v69;
                  uint64_t v67 = v70;
                }
                while (v70 <= (uint64_t)((unint64_t)(v66 - 2) >> 1));
                a2 -= 2;
                if (v69 == a2)
                {
                  *(_OWORD *)uint64_t v69 = v87;
                }
                else
                {
                  *(_OWORD *)uint64_t v69 = *(_OWORD *)a2;
                  *(_OWORD *)a2 = v87;
                  uint64_t v72 = (char *)v69 - (char *)v10 + 16;
                  if (v72 >= 17)
                  {
                    unint64_t v73 = (((unint64_t)v72 >> 4) - 2) >> 1;
                    unint64_t v74 = &v10[2 * v73];
                    uint64_t v75 = *v69;
                    if (**v74 < **v69)
                    {
                      uint64_t v76 = v69[1];
                      do
                      {
                        uint64_t v77 = v69;
                        uint64_t v69 = v74;
                        *(_OWORD *)uint64_t v77 = *(_OWORD *)v74;
                        if (!v73) {
                          break;
                        }
                        unint64_t v73 = (v73 - 1) >> 1;
                        unint64_t v74 = &v10[2 * v73];
                      }
                      while (**v74 < *v75);
                      *uint64_t v69 = v75;
                      v69[1] = v76;
                    }
                  }
                }
                BOOL v56 = v66-- <= 2;
              }
              while (!v56);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = &v10[2 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, &a1[2 * (v12 >> 1)], (_OWORD *)a2 - 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1 + 2, v14 - 2, (_OWORD *)a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1 + 4, &a1[2 * v13 + 2], (_OWORD *)a2 - 3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v14 - 2, v14, &a1[2 * v13 + 2]);
            long long v83 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *(_OWORD *)v14;
            *(_OWORD *)uint64_t v14 = v83;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(&a1[2 * (v12 >> 1)], a1, (_OWORD *)a2 - 1);
          }
          --a3;
          int v15 = *a1;
          int v16 = **a1;
          if ((a4 & 1) != 0 || **(a1 - 2) < v16) {
            break;
          }
          if (v16 >= **(a2 - 2))
          {
            uint64_t v30 = a1 + 2;
            do
            {
              uint64_t v10 = v30;
              if (v30 >= a2) {
                break;
              }
              v30 += 2;
            }
            while (v16 >= **v10);
          }
          else
          {
            uint64_t v10 = a1;
            do
            {
              uint64_t v29 = v10[2];
              v10 += 2;
            }
            while (v16 >= *v29);
          }
          __n128 v31 = a2;
          if (v10 < a2)
          {
            __n128 v31 = a2;
            do
            {
              unint64_t v32 = *(v31 - 2);
              v31 -= 2;
            }
            while (v16 < *v32);
          }
          uint64_t v33 = a1[1];
          while (v10 < v31)
          {
            long long v85 = *(_OWORD *)v10;
            *(_OWORD *)uint64_t v10 = *(_OWORD *)v31;
            *(_OWORD *)__n128 v31 = v85;
            int v34 = *v15;
            do
            {
              uint64_t v35 = v10[2];
              v10 += 2;
            }
            while (v34 >= *v35);
            do
            {
              uint64_t v36 = *(v31 - 2);
              v31 -= 2;
            }
            while (v34 < *v36);
          }
          BOOL v4 = v10 - 2 >= a1;
          BOOL v5 = v10 - 2 == a1;
          if (v10 - 2 != a1) {
            *(_OWORD *)a1 = *((_OWORD *)v10 - 1);
          }
          a4 = 0;
          *(v10 - 2) = v15;
          *(v10 - 1) = v33;
        }
        uint64_t v17 = 0;
        uint64_t v18 = a1[1];
        do
        {
          int v19 = *a1[v17 + 2];
          v17 += 2;
        }
        while (v19 < v16);
        int v20 = &a1[v17];
        BOOL v21 = a2;
        if (v17 == 2)
        {
          BOOL v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            uint64_t v23 = *(v21 - 2);
            v21 -= 2;
          }
          while (*v23 >= v16);
        }
        else
        {
          do
          {
            uint64_t v22 = *(v21 - 2);
            v21 -= 2;
          }
          while (*v22 >= v16);
        }
        uint64_t v10 = &a1[v17];
        if (v20 < v21)
        {
          unint64_t v24 = v21;
          do
          {
            long long v84 = *(_OWORD *)v10;
            *(_OWORD *)uint64_t v10 = *(_OWORD *)v24;
            *(_OWORD *)unint64_t v24 = v84;
            int v25 = *v15;
            do
            {
              uint64_t v26 = v10[2];
              v10 += 2;
            }
            while (*v26 < v25);
            do
            {
              unint64_t v27 = *(v24 - 2);
              v24 -= 2;
            }
            while (*v27 >= v25);
          }
          while (v10 < v24);
        }
        if (v10 - 2 != a1) {
          *(_OWORD *)a1 = *((_OWORD *)v10 - 1);
        }
        *(v10 - 2) = v15;
        *(v10 - 1) = v18;
        if (v20 >= v21) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(a1, v10 - 2, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, v10 - 2);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v10, a2))
      {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = v10 - 2;
    if (!v28) {
      continue;
    }
    break;
  }
}

__int16 **std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **result, __int16 **a2, _OWORD *a3)
{
  int v3 = **a2;
  int v4 = **(__int16 **)a3;
  if (v3 >= **result)
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
      *a3 = v6;
      if (**a2 < **result)
      {
        long long v7 = *(_OWORD *)result;
        *(_OWORD *)__n128 result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *(_OWORD *)result;
      *(_OWORD *)__n128 result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**(__int16 **)a3 >= **a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *a3;
    }
    else
    {
      long long v5 = *(_OWORD *)result;
      *(_OWORD *)__n128 result = *a3;
    }
    *a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **a1, __int16 **a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)long long v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      long long v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      uint64_t v9 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unint64_t v12 = *v9;
    if (**v9 < **v8)
    {
      unint64_t v13 = v9[1];
      uint64_t v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        int v15 = **(__int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          int v16 = (__int16 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      int v16 = a1;
LABEL_12:
      *int v16 = v12;
      v16[1] = v13;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    long long v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **a1, __int16 **a2, __n128 *a3, __n128 *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a2, a3);
  if (*(__int16 *)a4->n128_u64[0] < *(__int16 *)a3->n128_u64[0])
  {
    __n128 result = *a3;
    *a3 = *a4;
    *a4 = result;
    if (*(__int16 *)a3->n128_u64[0] < **a2)
    {
      __n128 result = *(__n128 *)a2;
      *(__n128 *)a2 = *a3;
      *a3 = result;
      if (**a2 < **a1)
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **a1, __int16 **a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(__int16 *)a5->n128_u64[0] < *(__int16 *)a4->n128_u64[0])
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(__int16 *)a4->n128_u64[0] < *(__int16 *)a3->n128_u64[0])
    {
      __n128 result = *a3;
      *a3 = *a4;
      *a4 = result;
      if (*(__int16 *)a3->n128_u64[0] < **a2)
      {
        __n128 result = *(__n128 *)a2;
        *(__n128 *)a2 = *a3;
        *a3 = result;
        if (**a2 < **a1)
        {
          __n128 result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
  while (2)
  {
    uint64_t v9 = a2 - 2;
    v95 = a2 - 4;
    v96 = a2;
    v93 = a2 - 6;
    uint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          int v11 = v96;
          uint64_t v12 = (char *)v96 - (char *)v10;
          uint64_t v13 = ((char *)v96 - (char *)v10) >> 4;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0:
              case 1:
                return;
              case 2:
                uint64_t v35 = v96 - 2;
                if (re::DynamicString::operator<(*(v96 - 2), *v10))
                {
                  long long v100 = *(_OWORD *)v10;
                  *(_OWORD *)uint64_t v10 = *(_OWORD *)v35;
                  *(_OWORD *)uint64_t v35 = v100;
                }
                break;
              case 3:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v10, v10 + 2, v9);
                break;
              case 4:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v10, v10 + 2, v10 + 4, v9);
                break;
              case 5:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v10, v10 + 2, v10 + 4, v10 + 6, v9);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v12 <= 383)
          {
            uint64_t v36 = v10 + 2;
            BOOL v38 = v10 == v96 || v36 == v96;
            if (a4)
            {
              if (!v38)
              {
                uint64_t v39 = 0;
                uint64_t v40 = v10;
                do
                {
                  BOOL v41 = v36;
                  uint64_t v42 = v40[2];
                  if (re::DynamicString::operator<(v42, *v40))
                  {
                    uint64_t v43 = v40[3];
                    uint64_t v44 = v39;
                    while (1)
                    {
                      uint64_t v45 = (char *)v10 + v44;
                      *(_OWORD *)((char *)v10 + v44 + 16) = *(_OWORD *)((char *)v10 + v44);
                      if (!v44) {
                        break;
                      }
                      v44 -= 16;
                      if ((re::DynamicString::operator<(v42, *((void *)v45 - 2)) & 1) == 0)
                      {
                        uint64_t v46 = (uint64_t *)((char *)v10 + v44 + 16);
                        goto LABEL_77;
                      }
                    }
                    uint64_t v46 = v10;
LABEL_77:
                    *uint64_t v46 = v42;
                    v46[1] = v43;
                  }
                  uint64_t v36 = v41 + 2;
                  v39 += 16;
                  uint64_t v40 = v41;
                }
                while (v41 + 2 != v96);
              }
            }
            else if (!v38)
            {
              do
              {
                long long v85 = v36;
                uint64_t v86 = a1[2];
                if (re::DynamicString::operator<(v86, *a1))
                {
                  uint64_t v87 = a1[3];
                  long long v88 = v85;
                  do
                  {
                    long long v89 = v88 - 2;
                    *(_OWORD *)long long v88 = *((_OWORD *)v88 - 1);
                    char v90 = re::DynamicString::operator<(v86, *(v88 - 4));
                    long long v88 = v89;
                  }
                  while ((v90 & 1) != 0);
                  *long long v89 = v86;
                  v89[1] = v87;
                }
                uint64_t v36 = v85 + 2;
                a1 = v85;
              }
              while (v85 + 2 != v96);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != v96)
            {
              unint64_t v91 = (char *)v96 - (char *)v10;
              int64_t v47 = (unint64_t)(v13 - 2) >> 1;
              int64_t v48 = v47;
              do
              {
                int64_t v49 = v48;
                if (v47 >= v48)
                {
                  uint64_t v50 = (2 * v48) | 1;
                  int64_t v51 = &a1[2 * v50];
                  uint64_t v52 = 2 * v48 + 2;
                  if (v52 < v13)
                  {
                    uint64_t v53 = *v51;
                    int64_t v54 = v48;
                    uint64_t v55 = v51[2];
                    int v56 = re::DynamicString::operator<(*v51, v55);
                    BOOL v57 = v56 == 0;
                    if (v56) {
                      uint64_t v58 = v55;
                    }
                    else {
                      uint64_t v58 = v53;
                    }
                    int64_t v49 = v54;
                    int64_t v47 = (unint64_t)(v13 - 2) >> 1;
                    if (!v57)
                    {
                      v51 += 2;
                      uint64_t v50 = v52;
                    }
                  }
                  else
                  {
                    uint64_t v58 = *v51;
                  }
                  int v59 = &a1[2 * v49];
                  uint64_t v60 = *v59;
                  if ((re::DynamicString::operator<(v58, *v59) & 1) == 0)
                  {
                    uint64_t v92 = v59[1];
                    int64_t v94 = v49;
                    do
                    {
                      uint64_t v61 = v59;
                      int v59 = v51;
                      *(_OWORD *)uint64_t v61 = *(_OWORD *)v51;
                      if (v47 < v50) {
                        break;
                      }
                      uint64_t v62 = (2 * v50) | 1;
                      int64_t v51 = &a1[2 * v62];
                      uint64_t v63 = 2 * v50 + 2;
                      if (v63 < v13)
                      {
                        uint64_t v64 = *v51;
                        uint64_t v65 = v51[2];
                        int v66 = re::DynamicString::operator<(*v51, v65);
                        BOOL v67 = v66 == 0;
                        if (v66) {
                          uint64_t v68 = v65;
                        }
                        else {
                          uint64_t v68 = v64;
                        }
                        if (!v67) {
                          v51 += 2;
                        }
                        int64_t v47 = (unint64_t)(v13 - 2) >> 1;
                        uint64_t v50 = v67 ? v62 : v63;
                      }
                      else
                      {
                        uint64_t v68 = *v51;
                        uint64_t v50 = (2 * v50) | 1;
                      }
                    }
                    while (!re::DynamicString::operator<(v68, v60));
                    int64_t v49 = v94;
                    *int v59 = v60;
                    v59[1] = v92;
                  }
                }
                int64_t v48 = v49 - 1;
              }
              while (v49);
              uint64_t v69 = v91 >> 4;
              uint64_t v70 = v96;
              do
              {
                uint64_t v71 = 0;
                long long v101 = *(_OWORD *)a1;
                uint64_t v72 = v69 - 2;
                if (v69 < 2) {
                  uint64_t v72 = v69 - 1;
                }
                uint64_t v73 = v72 >> 1;
                unint64_t v74 = a1;
                do
                {
                  uint64_t v75 = &v74[2 * v71 + 2];
                  uint64_t v76 = (2 * v71) | 1;
                  uint64_t v77 = 2 * v71 + 2;
                  if (v77 < v69 && re::DynamicString::operator<(*v75, v74[2 * v71 + 4]))
                  {
                    v75 += 2;
                    uint64_t v76 = v77;
                  }
                  *(_OWORD *)unint64_t v74 = *(_OWORD *)v75;
                  unint64_t v74 = v75;
                  uint64_t v71 = v76;
                }
                while (v76 <= v73);
                v70 -= 2;
                if (v75 == v70)
                {
                  *(_OWORD *)uint64_t v75 = v101;
                }
                else
                {
                  *(_OWORD *)uint64_t v75 = *(_OWORD *)v70;
                  *(_OWORD *)uint64_t v70 = v101;
                  uint64_t v78 = (char *)v75 - (char *)a1 + 16;
                  if (v78 >= 17)
                  {
                    unint64_t v79 = (((unint64_t)v78 >> 4) - 2) >> 1;
                    v80 = &a1[2 * v79];
                    uint64_t v81 = *v75;
                    if (re::DynamicString::operator<(*v80, *v75))
                    {
                      uint64_t v82 = v75[1];
                      do
                      {
                        long long v83 = v75;
                        uint64_t v75 = v80;
                        *(_OWORD *)long long v83 = *(_OWORD *)v80;
                        if (!v79) {
                          break;
                        }
                        unint64_t v79 = (v79 - 1) >> 1;
                        v80 = &a1[2 * v79];
                      }
                      while ((re::DynamicString::operator<(*v80, v81) & 1) != 0);
                      *uint64_t v75 = v81;
                      v75[1] = v82;
                    }
                  }
                }
              }
              while (v69-- > 2);
            }
            return;
          }
          unint64_t v14 = (unint64_t)v13 >> 1;
          int v15 = &v10[2 * ((unint64_t)v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v15, v10, v9);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v10, v15, v9);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v10 + 2, v15 - 2, v95);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v10 + 4, &v10[2 * v14 + 2], v93);
            int v11 = v96;
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v15 - 2, v15, &v10[2 * v14 + 2]);
            long long v97 = *(_OWORD *)v10;
            *(_OWORD *)uint64_t v10 = *(_OWORD *)v15;
            *(_OWORD *)int v15 = v97;
          }
          --a3;
          uint64_t v16 = *v10;
          if (a4 & 1) != 0 || (re::DynamicString::operator<(*(v10 - 2), *v10)) {
            break;
          }
          uint64_t v28 = v10[1];
          if (re::DynamicString::operator<(v16, *v9))
          {
            do
            {
              uint64_t v29 = v10[2];
              v10 += 2;
            }
            while ((re::DynamicString::operator<(v16, v29) & 1) == 0);
          }
          else
          {
            uint64_t v30 = v10 + 2;
            do
            {
              uint64_t v10 = v30;
              if (v30 >= v96) {
                break;
              }
              v30 += 2;
            }
            while (!re::DynamicString::operator<(v16, *v10));
          }
          __n128 v31 = v96;
          if (v10 < v96)
          {
            __n128 v31 = v96;
            do
            {
              uint64_t v32 = *(v31 - 2);
              v31 -= 2;
            }
            while ((re::DynamicString::operator<(v16, v32) & 1) != 0);
          }
          while (v10 < v31)
          {
            long long v99 = *(_OWORD *)v10;
            *(_OWORD *)uint64_t v10 = *(_OWORD *)v31;
            *(_OWORD *)__n128 v31 = v99;
            do
            {
              uint64_t v33 = v10[2];
              v10 += 2;
            }
            while (!re::DynamicString::operator<(v16, v33));
            do
            {
              uint64_t v34 = *(v31 - 2);
              v31 -= 2;
            }
            while ((re::DynamicString::operator<(v16, v34) & 1) != 0);
          }
          BOOL v4 = v10 - 2 >= a1;
          BOOL v5 = v10 - 2 == a1;
          if (v10 - 2 != a1) {
            *(_OWORD *)a1 = *((_OWORD *)v10 - 1);
          }
          a4 = 0;
          *(v10 - 2) = v16;
          *(v10 - 1) = v28;
        }
        uint64_t v17 = 0;
        uint64_t v18 = a1[1];
        do
        {
          char v19 = re::DynamicString::operator<(a1[v17 + 2], v16);
          v17 += 2;
        }
        while ((v19 & 1) != 0);
        int v20 = &a1[v17];
        BOOL v21 = v11;
        if (v17 == 2)
        {
          BOOL v21 = v11;
          do
          {
            if (v20 >= v21) {
              break;
            }
            uint64_t v23 = *(v21 - 2);
            v21 -= 2;
          }
          while ((re::DynamicString::operator<(v23, v16) & 1) == 0);
        }
        else
        {
          do
          {
            uint64_t v22 = *(v21 - 2);
            v21 -= 2;
          }
          while (!re::DynamicString::operator<(v22, v16));
        }
        uint64_t v10 = &a1[v17];
        if (v20 < v21)
        {
          unint64_t v24 = v21;
          do
          {
            long long v98 = *(_OWORD *)v10;
            *(_OWORD *)uint64_t v10 = *(_OWORD *)v24;
            *(_OWORD *)unint64_t v24 = v98;
            do
            {
              uint64_t v25 = v10[2];
              v10 += 2;
            }
            while ((re::DynamicString::operator<(v25, v16) & 1) != 0);
            do
            {
              uint64_t v26 = *(v24 - 2);
              v24 -= 2;
            }
            while (!re::DynamicString::operator<(v26, v16));
          }
          while (v10 < v24);
        }
        if (v10 - 2 != a1) {
          *(_OWORD *)a1 = *((_OWORD *)v10 - 1);
        }
        *(v10 - 2) = v16;
        *(v10 - 1) = v18;
        if (v20 >= v21) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(a1, v10 - 2, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v27 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, v10 - 2);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v10, v96))
      {
        break;
      }
      if (!v27) {
        goto LABEL_30;
      }
    }
    a2 = v10 - 2;
    if (!v27) {
      continue;
    }
    break;
  }
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = *a2;
  char v7 = re::DynamicString::operator<(*a2, *a1);
  uint64_t result = re::DynamicString::operator<(*a3, v6);
  if (v7)
  {
    if (result)
    {
      long long v9 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a3;
    }
    else
    {
      long long v12 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v12;
      uint64_t result = re::DynamicString::operator<(*a3, *a2);
      if (!result) {
        return result;
      }
      long long v9 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v9;
  }
  else if (result)
  {
    long long v10 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v10;
    uint64_t result = re::DynamicString::operator<(*a2, *a1);
    if (result)
    {
      long long v11 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v11;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = a2 - 2;
      if (re::DynamicString::operator<(*(a2 - 2), *a1))
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)uint64_t v6 = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      long long v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4);
      long long v9 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v9;
    if (re::DynamicString::operator<(*v9, *v8))
    {
      uint64_t v13 = v9[1];
      uint64_t v14 = v10;
      while (1)
      {
        int v15 = (char *)a1 + v14;
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        v14 -= 16;
        if ((re::DynamicString::operator<(v12, *((void *)v15 + 2)) & 1) == 0)
        {
          uint64_t v16 = (uint64_t *)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      uint64_t v16 = a1;
LABEL_12:
      *uint64_t v16 = v12;
      v16[1] = v13;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    long long v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a2, a3);
  if (re::DynamicString::operator<(*a4, *a3))
  {
    long long v9 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)a4 = v9;
    if (re::DynamicString::operator<(*a3, *a2))
    {
      long long v10 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v10;
      if (re::DynamicString::operator<(*a2, *a1))
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a2, a3, a4);
  if (re::DynamicString::operator<(*a5, *a4))
  {
    long long v11 = *(_OWORD *)a4;
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)a5 = v11;
    if (re::DynamicString::operator<(*a4, *a3))
    {
      long long v12 = *(_OWORD *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)a4 = v12;
      if (re::DynamicString::operator<(*a3, *a2))
      {
        long long v13 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)a3 = v13;
        if (re::DynamicString::operator<(*a2, *a1))
        {
          __n128 result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>(unint64_t a1, __n128 *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                BOOL v38 = (void *)a2[-1].n128_u64[0];
                uint64_t v37 = (long long *)&a2[-1];
                if (*v38 >> 1 < **(void **)v10 >> 1)
                {
                  long long v87 = *(_OWORD *)v10;
                  *(_OWORD *)unint64_t v10 = *v37;
                  *uint64_t v37 = v87;
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)v10, (void **)(v10 + 16), &a2[-1]);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)v10, (__n128 *)(v10 + 16), (__n128 *)(v10 + 32), a2 - 1);
                break;
              case 5uLL:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)v10, (__n128 *)(v10 + 16), (__n128 *)(v10 + 32), (__n128 *)(v10 + 48), a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            uint64_t v39 = (__n128 *)(v10 + 16);
            BOOL v41 = (__n128 *)v10 == a2 || v39 == a2;
            if (a4)
            {
              if (!v41)
              {
                uint64_t v42 = 0;
                unint64_t v43 = v10;
                do
                {
                  uint64_t v44 = v39;
                  uint64_t v45 = *(void **)(v43 + 16);
                  if (*v45 >> 1 < **(void **)v43 >> 1)
                  {
                    uint64_t v46 = *(void *)(v43 + 24);
                    uint64_t v47 = v42;
                    while (1)
                    {
                      *(_OWORD *)(v10 + v47 + 16) = *(_OWORD *)(v10 + v47);
                      if (!v47) {
                        break;
                      }
                      unint64_t v48 = **(void **)(v10 + v47 - 16);
                      v47 -= 16;
                      if (*v45 >> 1 >= v48 >> 1)
                      {
                        int64_t v49 = (void *)(v10 + v47 + 16);
                        goto LABEL_79;
                      }
                    }
                    int64_t v49 = (void *)v10;
LABEL_79:
                    *int64_t v49 = v45;
                    v49[1] = v46;
                  }
                  uint64_t v39 = v44 + 1;
                  v42 += 16;
                  unint64_t v43 = (unint64_t)v44;
                }
                while (&v44[1] != a2);
              }
            }
            else if (!v41)
            {
              do
              {
                unint64_t v79 = (unint64_t)v39;
                v80 = *(void **)(a1 + 16);
                if (*v80 >> 1 < **(void **)a1 >> 1)
                {
                  uint64_t v81 = *(void *)(a1 + 24);
                  unint64_t v82 = v79;
                  do
                  {
                    *(_OWORD *)unint64_t v82 = *(_OWORD *)(v82 - 16);
                    long long v83 = *(void **)(v82 - 32);
                    v82 -= 16;
                  }
                  while (*v80 >> 1 < *v83 >> 1);
                  *(void *)unint64_t v82 = v80;
                  *(void *)(v82 + 8) = v81;
                }
                uint64_t v39 = (__n128 *)(v79 + 16);
                a1 = v79;
              }
              while ((__n128 *)(v79 + 16) != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((__n128 *)v10 != a2)
            {
              int64_t v50 = (v12 - 2) >> 1;
              int64_t v51 = v50;
              do
              {
                int64_t v52 = v51;
                if (v50 >= v51)
                {
                  uint64_t v53 = (2 * v51) | 1;
                  int64_t v54 = (unint64_t **)(v10 + 16 * v53);
                  if (2 * v52 + 2 < (uint64_t)v12)
                  {
                    unint64_t v55 = **v54 >> 1;
                    unint64_t v57 = *v54[2];
                    BOOL v56 = v55 >= v57 >> 1;
                    if (v55 < v57 >> 1) {
                      v54 += 2;
                    }
                    else {
                      unint64_t v57 = **v54;
                    }
                    if (!v56) {
                      uint64_t v53 = 2 * v52 + 2;
                    }
                  }
                  else
                  {
                    unint64_t v57 = **v54;
                  }
                  uint64_t v58 = (unint64_t **)(v10 + 16 * v52);
                  int v59 = *v58;
                  if (v57 >> 1 >= **v58 >> 1)
                  {
                    uint64_t v60 = v58[1];
                    do
                    {
                      uint64_t v61 = v58;
                      uint64_t v58 = v54;
                      *(_OWORD *)uint64_t v61 = *(_OWORD *)v54;
                      if (v50 < v53) {
                        break;
                      }
                      uint64_t v62 = (2 * v53) | 1;
                      int64_t v54 = (unint64_t **)(v10 + 16 * v62);
                      uint64_t v53 = 2 * v53 + 2;
                      if (v53 < (uint64_t)v12)
                      {
                        unint64_t v63 = **v54;
                        if (v63 >> 1 >= *v54[2] >> 1)
                        {
                          uint64_t v53 = v62;
                        }
                        else
                        {
                          unint64_t v63 = *v54[2];
                          v54 += 2;
                        }
                      }
                      else
                      {
                        unint64_t v63 = **v54;
                        uint64_t v53 = v62;
                      }
                    }
                    while (v63 >> 1 >= *v59 >> 1);
                    *uint64_t v58 = v59;
                    v58[1] = v60;
                  }
                }
                int64_t v51 = v52 - 1;
              }
              while (v52);
              uint64_t v64 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v65 = 0;
                long long v88 = *(_OWORD *)v10;
                uint64_t v66 = v64 - 2;
                if (v64 < 2) {
                  uint64_t v66 = v64 - 1;
                }
                uint64_t v67 = v66 >> 1;
                uint64_t v68 = (_OWORD *)v10;
                do
                {
                  uint64_t v69 = (uint64_t)&v68[v65 + 1];
                  uint64_t v70 = (2 * v65) | 1;
                  uint64_t v71 = 2 * v65 + 2;
                  if (v71 < v64 && **(void **)v69 >> 1 < **(void **)(v69 + 16) >> 1)
                  {
                    v69 += 16;
                    uint64_t v70 = v71;
                  }
                  _OWORD *v68 = *(_OWORD *)v69;
                  uint64_t v68 = (_OWORD *)v69;
                  uint64_t v65 = v70;
                }
                while (v70 <= v67);
                if ((__n128 *)v69 == --a2)
                {
                  *(_OWORD *)uint64_t v69 = v88;
                }
                else
                {
                  *(__n128 *)uint64_t v69 = *a2;
                  *a2 = (__n128)v88;
                  uint64_t v72 = v69 - v10 + 16;
                  if (v72 >= 17)
                  {
                    unint64_t v73 = (((unint64_t)v72 >> 4) - 2) >> 1;
                    unint64_t v74 = (_OWORD *)(v10 + 16 * v73);
                    uint64_t v75 = *(void **)v69;
                    if (**(void **)v74 >> 1 < **(void **)v69 >> 1)
                    {
                      uint64_t v76 = *(void *)(v69 + 8);
                      do
                      {
                        uint64_t v77 = (_OWORD *)v69;
                        uint64_t v69 = (uint64_t)v74;
                        *uint64_t v77 = *v74;
                        if (!v73) {
                          break;
                        }
                        unint64_t v73 = (v73 - 1) >> 1;
                        unint64_t v74 = (_OWORD *)(v10 + 16 * v73);
                      }
                      while (**(void **)v74 >> 1 < *v75 >> 1);
                      *(void *)uint64_t v69 = v75;
                      *(void *)(v69 + 8) = v76;
                    }
                  }
                }
              }
              while (v64-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (long long *)(v10 + 16 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)a1, (void **)(a1 + 16 * (v12 >> 1)), &a2[-1]);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)(a1 + 16), (void **)v14 - 2, &a2[-2]);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)(a1 + 32), (void **)(a1 + 16 + 16 * v13), &a2[-3]);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(v14 - 1, (void **)v14, (void **)(a1 + 16 + 16 * v13));
            long long v84 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *v14;
            long long *v14 = v84;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)(a1 + 16 * (v12 >> 1)), (void **)a1, &a2[-1]);
          }
          --a3;
          int v15 = *(void **)a1;
          unint64_t v16 = **(void **)a1 >> 1;
          if ((a4 & 1) != 0 || v16 > **(void **)(a1 - 16) >> 1) {
            break;
          }
          if (v16 >= *(void *)a2[-1].n128_u64[0] >> 1)
          {
            unint64_t v30 = a1 + 16;
            do
            {
              unint64_t v10 = v30;
              if (v30 >= (unint64_t)a2) {
                break;
              }
              v30 += 16;
            }
            while (v16 >= **(void **)v10 >> 1);
          }
          else
          {
            unint64_t v10 = a1;
            do
            {
              uint64_t v29 = *(void **)(v10 + 16);
              v10 += 16;
            }
            while (v16 >= *v29 >> 1);
          }
          __n128 v31 = (long long *)a2;
          if (v10 < (unint64_t)a2)
          {
            __n128 v31 = (long long *)a2;
            do
              uint64_t v32 = (void *)*((void *)v31-- - 2);
            while (v16 < *v32 >> 1);
          }
          uint64_t v33 = *(void *)(a1 + 8);
          while (v10 < (unint64_t)v31)
          {
            long long v86 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v31;
            *__n128 v31 = v86;
            unint64_t v34 = *v15 >> 1;
            do
            {
              uint64_t v35 = *(void **)(v10 + 16);
              v10 += 16;
            }
            while (v34 >= *v35 >> 1);
            do
              uint64_t v36 = (void *)*((void *)v31-- - 2);
            while (v34 < *v36 >> 1);
          }
          BOOL v4 = v10 - 16 >= a1;
          BOOL v5 = v10 - 16 == a1;
          if (v10 - 16 != a1) {
            *(_OWORD *)a1 = *(_OWORD *)(v10 - 16);
          }
          a4 = 0;
          *(void *)(v10 - 16) = v15;
          *(void *)(v10 - 8) = v33;
        }
        uint64_t v17 = 0;
        uint64_t v18 = *(void *)(a1 + 8);
        do
        {
          unint64_t v19 = **(void **)(a1 + v17 + 16);
          v17 += 16;
        }
        while (v16 > v19 >> 1);
        unint64_t v20 = a1 + v17;
        BOOL v21 = (long long *)a2;
        if (v17 == 16)
        {
          BOOL v21 = (long long *)a2;
          do
          {
            if (v20 >= (unint64_t)v21) {
              break;
            }
            uint64_t v23 = (void *)*((void *)v21-- - 2);
          }
          while (v16 <= *v23 >> 1);
        }
        else
        {
          do
            uint64_t v22 = (void *)*((void *)v21-- - 2);
          while (v16 <= *v22 >> 1);
        }
        unint64_t v10 = a1 + v17;
        if (v20 < (unint64_t)v21)
        {
          unint64_t v24 = v21;
          do
          {
            long long v85 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v24;
            *unint64_t v24 = v85;
            unint64_t v25 = *v15 >> 1;
            do
            {
              uint64_t v26 = *(void **)(v10 + 16);
              v10 += 16;
            }
            while (v25 > *v26 >> 1);
            do
              BOOL v27 = (void *)*((void *)v24-- - 2);
            while (v25 <= *v27 >> 1);
          }
          while (v10 < (unint64_t)v24);
        }
        if (v10 - 16 != a1) {
          *(_OWORD *)a1 = *(_OWORD *)(v10 - 16);
        }
        *(void *)(v10 - 16) = v15;
        *(void *)(v10 - 8) = v18;
        if (v20 >= (unint64_t)v21) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>(a1, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(a1, v10 - 16);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = (__n128 *)(v10 - 16);
    if (!v28) {
      continue;
    }
    break;
  }
}

long long *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(long long *result, void **a2, void **a3)
{
  unint64_t v3 = **a2 >> 1;
  unint64_t v4 = **a3 >> 1;
  if (v3 >= **(void **)result >> 1)
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (**a2 >> 1 < **(void **)result >> 1)
      {
        long long v7 = *result;
        *__n128 result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *result;
      *__n128 result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (**a3 >> 1 >= **a2 >> 1) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      long long v5 = *result;
      *__n128 result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = (long long *)(a2 - 16);
      if (**(void **)(a2 - 16) >> 1 < **(void **)a1 >> 1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *long long v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)a1, (void **)(a1 + 16), (void **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      long long v8 = (void **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)a1, (void **)(a1 + 16), (void **)(a1 + 32));
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unint64_t v12 = *(void **)v9;
    if (**(void **)v9 >> 1 < **v8 >> 1)
    {
      uint64_t v13 = *(void *)(v9 + 8);
      uint64_t v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        unint64_t v15 = **(void **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >> 1 >= v15 >> 1)
        {
          unint64_t v16 = (void *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      unint64_t v16 = (void *)a1;
LABEL_12:
      *unint64_t v16 = v12;
      v16[1] = v13;
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }
    long long v8 = (void **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(long long *a1, __n128 *a2, __n128 *a3, __n128 *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(a1, a2, a3);
  if (*(void *)a4->n128_u64[0] >> 1 < *(void *)a3->n128_u64[0] >> 1)
  {
    __n128 result = *a3;
    *a3 = *a4;
    *a4 = result;
    if (*(void *)a3->n128_u64[0] >> 1 < *(void *)a2->n128_u64[0] >> 1)
    {
      __n128 result = *a2;
      *a2 = *a3;
      *a3 = result;
      if (*(void *)a2->n128_u64[0] >> 1 < **(void **)a1 >> 1)
      {
        __n128 result = (__n128)*a1;
        *a1 = (__int128)*a2;
        *a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(long long *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(a1, a2, a3, a4).n128_u64[0];
  if (*(void *)a5->n128_u64[0] >> 1 < *(void *)a4->n128_u64[0] >> 1)
  {
    __n128 result = *a4;
    *a4 = *a5;
    *a5 = result;
    if (*(void *)a4->n128_u64[0] >> 1 < *(void *)a3->n128_u64[0] >> 1)
    {
      __n128 result = *a3;
      *a3 = *a4;
      *a4 = result;
      if (*(void *)a3->n128_u64[0] >> 1 < *(void *)a2->n128_u64[0] >> 1)
      {
        __n128 result = *a2;
        *a2 = *a3;
        *a3 = result;
        if (*(void *)a2->n128_u64[0] >> 1 < **(void **)a1 >> 1)
        {
          __n128 result = (__n128)*a1;
          *a1 = (__int128)*a2;
          *a2 = result;
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(char *a1, char *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  while (2)
  {
    long long v86 = a2 - 32;
    long long v88 = a2 - 16;
    long long v84 = a2 - 48;
    unint64_t v12 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v12;
          uint64_t v13 = a2 - v12;
          uint64_t v14 = (a2 - v12) >> 4;
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0:
              case 1:
                return;
              case 2:
                uint64_t v38 = *((void *)a2 - 2);
                uint64_t v37 = a2 - 16;
                if ((*a3)(v38, *(void *)a1))
                {
                  long long v99 = *(_OWORD *)a1;
                  *(_OWORD *)a1 = *(_OWORD *)v37;
                  *(_OWORD *)uint64_t v37 = v99;
                }
                break;
              case 3:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, v88, a3);
                break;
              case 4:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, v88, a3);
                break;
              case 5:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, (void *)a1 + 6, v88, a3);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v13 <= 383)
          {
            uint64_t v39 = a1 + 16;
            BOOL v41 = a1 == a2 || v39 == a2;
            if (a5)
            {
              if (!v41)
              {
                uint64_t v42 = 0;
                unint64_t v43 = a1;
                do
                {
                  uint64_t v44 = *((void *)v43 + 2);
                  uint64_t v45 = *(void *)v43;
                  unint64_t v43 = v39;
                  if ((*a3)(v44, v45))
                  {
                    long long v93 = *(_OWORD *)v43;
                    uint64_t v46 = *(void *)v43;
                    uint64_t v47 = v42;
                    while (1)
                    {
                      *(_OWORD *)&a1[v47 + 16] = *(_OWORD *)&a1[v47];
                      if (!v47) {
                        break;
                      }
                      char v48 = (*a3)(v46, *(void *)&a1[v47 - 16]);
                      v47 -= 16;
                      if ((v48 & 1) == 0)
                      {
                        int64_t v49 = &a1[v47 + 16];
                        goto LABEL_78;
                      }
                    }
                    int64_t v49 = a1;
LABEL_78:
                    *(_OWORD *)int64_t v49 = v93;
                  }
                  uint64_t v39 = v43 + 16;
                  v42 += 16;
                }
                while (v43 + 16 != a2);
              }
            }
            else if (!v41)
            {
              do
              {
                uint64_t v78 = *((void *)a1 + 2);
                uint64_t v79 = *(void *)a1;
                a1 = v39;
                if ((*a3)(v78, v79))
                {
                  long long v95 = *(_OWORD *)a1;
                  uint64_t v80 = *(void *)a1;
                  uint64_t v81 = a1;
                  do
                  {
                    unint64_t v82 = v81 - 16;
                    *(_OWORD *)uint64_t v81 = *((_OWORD *)v81 - 1);
                    char v83 = (*a3)(v80, *((void *)v81 - 4));
                    uint64_t v81 = v82;
                  }
                  while ((v83 & 1) != 0);
                  *(_OWORD *)unint64_t v82 = v95;
                }
                uint64_t v39 = a1 + 16;
              }
              while (a1 + 16 != a2);
            }
            return;
          }
          if (!a4)
          {
            if (a1 != a2)
            {
              unint64_t v85 = v13;
              long long v87 = a2;
              int64_t v50 = (unint64_t)(v14 - 2) >> 1;
              int64_t v51 = v50;
              do
              {
                int64_t v52 = v51;
                if (v50 >= v51)
                {
                  uint64_t v53 = (2 * v51) | 1;
                  int64_t v54 = &a1[16 * v53];
                  if (2 * v51 + 2 < v14 && (*a3)(*(void *)v54, *((void *)v54 + 2)))
                  {
                    v54 += 16;
                    uint64_t v53 = 2 * v52 + 2;
                  }
                  unint64_t v55 = &a1[16 * v52];
                  if (((*a3)(*(void *)v54, *(void *)v55) & 1) == 0)
                  {
                    int64_t v94 = v52;
                    long long v89 = *(_OWORD *)v55;
                    uint64_t v56 = *(void *)v55;
                    do
                    {
                      unint64_t v57 = v55;
                      unint64_t v55 = v54;
                      *(_OWORD *)unint64_t v57 = *(_OWORD *)v54;
                      if (v50 < v53) {
                        break;
                      }
                      uint64_t v58 = (2 * v53) | 1;
                      int64_t v54 = &a1[16 * v58];
                      uint64_t v59 = 2 * v53 + 2;
                      if (v59 < v14 && (*a3)(*(void *)v54, *((void *)v54 + 2)))
                      {
                        v54 += 16;
                        uint64_t v58 = v59;
                      }
                      uint64_t v53 = v58;
                    }
                    while (!(*a3)(*(void *)v54, v56));
                    *(_OWORD *)unint64_t v55 = v89;
                    int64_t v52 = v94;
                  }
                }
                int64_t v51 = v52 - 1;
              }
              while (v52);
              uint64_t v60 = v87;
              uint64_t v61 = v85 >> 4;
              do
              {
                uint64_t v62 = 0;
                long long v100 = *(_OWORD *)a1;
                uint64_t v63 = v61 - 2;
                if (v61 < 2) {
                  uint64_t v63 = v61 - 1;
                }
                uint64_t v64 = v63 >> 1;
                uint64_t v65 = a1;
                do
                {
                  uint64_t v66 = (uint64_t *)&v65[16 * v62 + 16];
                  uint64_t v67 = (2 * v62) | 1;
                  uint64_t v68 = 2 * v62 + 2;
                  if (v68 < v61 && (*a3)(*v66, *(void *)&v65[16 * v62 + 32]))
                  {
                    v66 += 2;
                    uint64_t v67 = v68;
                  }
                  *(_OWORD *)uint64_t v65 = *(_OWORD *)v66;
                  uint64_t v65 = (char *)v66;
                  uint64_t v62 = v67;
                }
                while (v67 <= v64);
                uint64_t v69 = (uint64_t *)(v60 - 16);
                if (v66 == v69)
                {
                  uint64_t v70 = v69;
                  *(_OWORD *)uint64_t v66 = v100;
                  uint64_t v72 = v61 - 1;
                }
                else
                {
                  *(_OWORD *)uint64_t v66 = *(_OWORD *)v69;
                  uint64_t v70 = v69;
                  *(_OWORD *)uint64_t v69 = v100;
                  uint64_t v71 = (char *)v66 - a1 + 16;
                  uint64_t v72 = v61 - 1;
                  if (v71 >= 17)
                  {
                    unint64_t v73 = (((unint64_t)v71 >> 4) - 2) >> 1;
                    unint64_t v74 = &a1[16 * v73];
                    if ((*a3)(*(void *)v74, *v66))
                    {
                      long long v90 = *(_OWORD *)v66;
                      uint64_t v75 = *v66;
                      do
                      {
                        uint64_t v76 = v66;
                        uint64_t v66 = (uint64_t *)v74;
                        *(_OWORD *)uint64_t v76 = *(_OWORD *)v74;
                        if (!v73) {
                          break;
                        }
                        unint64_t v73 = (v73 - 1) >> 1;
                        unint64_t v74 = &a1[16 * v73];
                      }
                      while (((*a3)(*(void *)v74, v75) & 1) != 0);
                      *(_OWORD *)uint64_t v66 = v90;
                    }
                  }
                }
                BOOL v77 = v61 <= 2;
                uint64_t v61 = v72;
                uint64_t v60 = (char *)v70;
              }
              while (!v77);
            }
            return;
          }
          unint64_t v15 = (unint64_t)v14 >> 1;
          unint64_t v16 = &a1[16 * ((unint64_t)v14 >> 1)];
          if ((unint64_t)v13 < 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v16, a1, v88, a3);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, v16, v88, a3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((void *)a1 + 2, (void *)v16 - 2, v86, a3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((void *)a1 + 4, &a1[16 * v15 + 16], v84, a3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((void *)v16 - 2, v16, &a1[16 * v15 + 16], a3);
            long long v96 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *(_OWORD *)v16;
            *(_OWORD *)unint64_t v16 = v96;
          }
          --a4;
          if (a5 & 1) != 0 || ((*a3)(*((void *)a1 - 2), *(void *)a1)) {
            break;
          }
          long long v92 = *(_OWORD *)a1;
          uint64_t v29 = *(void *)a1;
          if ((*a3)(*(void *)a1, *(void *)v88))
          {
            unint64_t v12 = a1;
            do
            {
              uint64_t v30 = *((void *)v12 + 2);
              v12 += 16;
            }
            while (((*a3)(v29, v30) & 1) == 0);
          }
          else
          {
            __n128 v31 = a1 + 16;
            do
            {
              unint64_t v12 = v31;
              if (v31 >= a2) {
                break;
              }
              v31 += 16;
            }
            while (!(*a3)(v29, *(void *)v12));
          }
          uint64_t v32 = a2;
          if (v12 < a2)
          {
            uint64_t v32 = a2;
            do
            {
              uint64_t v33 = *((void *)v32 - 2);
              v32 -= 16;
            }
            while (((*a3)(v29, v33) & 1) != 0);
          }
          while (v12 < v32)
          {
            long long v98 = *(_OWORD *)v12;
            *(_OWORD *)unint64_t v12 = *(_OWORD *)v32;
            *(_OWORD *)uint64_t v32 = v98;
            do
            {
              uint64_t v34 = *((void *)v12 + 2);
              v12 += 16;
            }
            while (!(*a3)(v29, v34));
            do
            {
              uint64_t v35 = *((void *)v32 - 2);
              v32 -= 16;
            }
            while (((*a3)(v29, v35) & 1) != 0);
          }
          uint64_t v36 = v12 - 16;
          BOOL v5 = v12 - 16 >= a1;
          BOOL v6 = v12 - 16 == a1;
          if (v12 - 16 != a1) {
            *(_OWORD *)a1 = *(_OWORD *)v36;
          }
          a5 = 0;
          *(_OWORD *)uint64_t v36 = v92;
        }
        uint64_t v17 = 0;
        long long v91 = *(_OWORD *)a1;
        uint64_t v18 = *(void *)a1;
        do
        {
          char v19 = (*a3)(*(void *)&a1[v17 + 16], v18);
          v17 += 16;
        }
        while ((v19 & 1) != 0);
        unint64_t v20 = &a1[v17];
        BOOL v21 = a2;
        if (v17 == 16)
        {
          do
          {
            if (v20 >= a2) {
              break;
            }
            uint64_t v23 = *((void *)a2 - 2);
            a2 -= 16;
          }
          while (((*a3)(v23, v18) & 1) == 0);
        }
        else
        {
          do
          {
            uint64_t v22 = *((void *)a2 - 2);
            a2 -= 16;
          }
          while (!(*a3)(v22, v18));
        }
        unint64_t v12 = &a1[v17];
        if (v20 < a2)
        {
          unint64_t v24 = a2;
          do
          {
            long long v97 = *(_OWORD *)v12;
            *(_OWORD *)unint64_t v12 = *(_OWORD *)v24;
            *(_OWORD *)unint64_t v24 = v97;
            do
            {
              uint64_t v25 = *((void *)v12 + 2);
              v12 += 16;
            }
            while (((*a3)(v25, v18) & 1) != 0);
            do
            {
              uint64_t v26 = *((void *)v24 - 2);
              v24 -= 16;
            }
            while (!(*a3)(v26, v18));
          }
          while (v12 < v24);
        }
        BOOL v27 = v12 - 16;
        if (v12 - 16 != a1) {
          *(_OWORD *)a1 = *(_OWORD *)v27;
        }
        *(_OWORD *)BOOL v27 = v91;
        BOOL v5 = v20 >= a2;
        a2 = v21;
        if (v5) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(a1, v12 - 16, a3, a4, a5 & 1);
        a5 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, v12 - 16, a3);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, v21, a3))
      {
        break;
      }
      if (!v28) {
        goto LABEL_30;
      }
    }
    a2 = v12 - 16;
    if (!v28) {
      continue;
    }
    break;
  }
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(void *a1, void *a2, void *a3, uint64_t (**a4)(void, void))
{
  char v8 = (*a4)(*a2, *a1);
  uint64_t result = (*a4)(*a3, *a2);
  if (v8)
  {
    if (result)
    {
      long long v10 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a3;
    }
    else
    {
      long long v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v13;
      uint64_t result = (*a4)(*a3, *a2);
      if (!result) {
        return result;
      }
      long long v10 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v10;
  }
  else if (result)
  {
    long long v11 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v11;
    uint64_t result = (*a4)(*a2, *a1);
    if (result)
    {
      long long v12 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v12;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(char *a1, char *a2, uint64_t (**a3)(uint64_t, void))
{
  uint64_t v6 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      char v8 = a2 - 16;
      if ((*a3)(*((void *)a2 - 2), *(void *)a1))
      {
        long long v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)char v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, (void *)a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, (void *)a1 + 6, (void *)a2 - 2, a3);
      return 1;
    default:
      long long v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, a3);
      long long v11 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(*(void *)v11, *(void *)v10))
    {
      long long v18 = *(_OWORD *)v11;
      uint64_t v14 = *(void *)v11;
      uint64_t v15 = v12;
      while (1)
      {
        *(_OWORD *)&a1[v15 + 48] = *(_OWORD *)&a1[v15 + 32];
        if (v15 == -32) {
          break;
        }
        char v16 = (*a3)(v14, *(void *)&a1[v15 + 16]);
        v15 -= 16;
        if ((v16 & 1) == 0)
        {
          uint64_t v17 = &a1[v15 + 48];
          goto LABEL_12;
        }
      }
      uint64_t v17 = a1;
LABEL_12:
      *(_OWORD *)uint64_t v17 = v18;
      if (++v13 == 8) {
        return v11 + 16 == a2;
      }
    }
    long long v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(void *a1, void *a2, void *a3, void *a4, uint64_t (**a5)(void, void))
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, a2, a3, a5);
  if ((*a5)(*a4, *a3))
  {
    long long v11 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)a4 = v11;
    if ((*a5)(*a3, *a2))
    {
      long long v12 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v12;
      if ((*a5)(*a2, *a1))
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(void *a1, void *a2, void *a3, void *a4, void *a5, uint64_t (**a6)(void, void))
{
  __n128 v12 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, a2, a3, a4, a6);
  if (((unsigned int (*)(void, void, __n128))*a6)(*a5, *a4, v12))
  {
    long long v14 = *(_OWORD *)a4;
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)a5 = v14;
    if ((*a6)(*a4, *a3))
    {
      long long v15 = *(_OWORD *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)a4 = v15;
      if ((*a6)(*a3, *a2))
      {
        long long v16 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)a3 = v16;
        if ((*a6)(*a2, *a1))
        {
          __n128 result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  long long v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (char v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    uint64_t v27 = 0;
    BOOL v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, &v27, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    if (v27) {
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_29;
  }
  unint64_t v23 = *(void *)(a4 + 8);
  if (v23) {
    uint64_t v24 = v23 >> 1;
  }
  else {
    uint64_t v24 = v23 >> 1;
  }
  uint64_t v27 = v24;
  BOOL v25 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, &v27, 0);
  BOOL result = 0;
  if (v25)
  {
    if (v27)
    {
      if (*(unsigned char *)(a4 + 8)) {
        uint64_t v26 = *(void *)(a4 + 16);
      }
      else {
        uint64_t v26 = a4 + 9;
      }
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v26, 0);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_29:
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString(v22);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::internal::serializeObjectWithOneMember<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(unsigned char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)v29, *a5, a5[2]);
  re::TypeMemberCollection::operator[](v14, 0, (uint64_t)&v27);
  uint64_t v15 = a4 + *(unsigned int *)(v28 + 24);
  re::TypeRegistry::typeInfo(v27, *(void *)v28, v29);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v30);
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*a5 == *a6)
  {
    uint64_t v18 = *(void *)a5[2];
    uint64_t v19 = a6[2];
    uint64_t v20 = *(void *)v19;
    if ((unsigned __int16)v18 != (unsigned __int16)*(void *)v19) {
      goto LABEL_14;
    }
    BOOL v22 = WORD1(v18) == WORD1(v20);
    uint64_t v21 = (v20 ^ v18) & 0xFFFFFF00000000;
    BOOL v22 = v22 && v21 == 0;
    if (!v22) {
      goto LABEL_14;
    }
LABEL_4:
    if (!a1[64]) {
      return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v26, a7);
    }
    return 0;
  }
  if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, v16)) {
    goto LABEL_4;
  }
  uint64_t v19 = a6[2];
LABEL_14:
  if (*(_DWORD *)(v19 + 88) != 1)
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
    return 0;
  }
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v23, *a6, v19);
  re::TypeMemberCollection::operator[](v23, 0, (uint64_t)v24);
  re::TypeRegistry::typeInfo(v24[0], *v24[2], v29);
  re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v30);
  if (a1[64]) {
    return 0;
  }
  return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v25, a7);
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(unsigned char *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v19);
  if (v19[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v16, (uint64_t)&v20);
    if (*(_DWORD *)(v17 + 88) || (re::TypeRegistry::typeInfo(v16[0], *(void *)(v17 + 72), v21), v21[0])) {
      re::internal::serializeMembersWithoutVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, v16, a4);
    }
  }
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v16, *a3, a3[2]);
  if (v18)
  {
    for (unint64_t i = 0; i < v18; ++i)
    {
      if (a1[64]) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v16, i, (uint64_t)&v14);
      if (*(unsigned char *)(v15 + 28))
      {
        uint64_t v10 = *(void *)(v15 + 16);
        if (strlen((const char *)v10) >= 3 && *(unsigned char *)v10 == 109) {
          v10 += 2 * (*(unsigned char *)(v10 + 1) == 95);
        }
        uint64_t v11 = *(unsigned int *)(v15 + 32);
        uint64_t v12 = *(unsigned int *)(v15 + 24);
        re::TypeRegistry::typeInfo(v14, *(void *)v15, v21);
        uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v22);
        if (!a1[64]) {
          uint64_t result = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v10, v11, a2 + v12, v13, v13, a4);
        }
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v49);
  re::TypeRegistry::typeInfo((void *)*a4, *(void *)(a4[2] + 72), v45);
  if (v45[0])
  {
    if (!v49[0])
    {
      uint64_t v11 = re::TypeInfo::name((re::TypeInfo *)&v46)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (v50 == v46)
    {
      uint64_t v18 = *v52;
      uint64_t v19 = *v48;
      if ((unsigned __int16)*v52 == (unsigned __int16)*v48)
      {
        BOOL v21 = WORD1(v18) == WORD1(v19);
        uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        BOOL v21 = v21 && v20 == 0;
        if (v21) {
          goto LABEL_5;
        }
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v50, (const re::TypeInfo *)&v46, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((unsigned char *)a1, a2, &v50, a5);
      goto LABEL_15;
    }
    if (v51 == v47)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, &v50, &v46, a5);
    }
    else
    {
      uint64_t v22 = re::TypeInfo::name((re::TypeInfo *)&v50)[1];
      re::TypeInfo::name((re::TypeInfo *)&v46);
      re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v44, *a3, a3[2]);
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v42, *a4, a4[2]);
  if (v43)
  {
    for (unint64_t i = 0; i < v43; ++i)
    {
      if (*(unsigned char *)(a1 + 64)) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[](v42, i, (uint64_t)v40);
      if (*(unsigned char *)(v41 + 28))
      {
        uint64_t v29 = *(void *)(v41 + 16);
        if (strlen((const char *)v29) >= 3 && *(unsigned char *)v29 == 109) {
          v29 += 2 * (*(unsigned char *)(v29 + 1) == 95);
        }
        uint64_t v30 = *(unsigned int *)(v41 + 32);
        __n128 v31 = *(re **)(*a4 + 856);
        if (!v31
          || (__n128 v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v40),
              v31 == -1))
        {
          uint64_t v33 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
          {
            uint64_t v34 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            uint64_t v54 = v34;
            __int16 v55 = 2080;
            uint64_t v56 = v29;
            _os_log_impl(&dword_233120000, v33, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          uint64_t v35 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(v40[0], *(void *)v41, buf);
          re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v54 + 4);
          uint64_t result = re::internal::translateType(v35, (const re::TypeRegistry *)v38, (uint64_t)buf);
          if (!*(unsigned char *)(a1 + 64)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint8_t *, uint8_t *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
          }
        }
        else
        {
          re::TypeMemberCollection::operator[](v44, (int)v31, (uint64_t)v38);
          uint64_t v32 = *(unsigned int *)(v39 + 24);
          re::TypeRegistry::typeInfo(v38[0], *(void *)v39, buf);
          re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v54 + 4);
          re::TypeRegistry::typeInfo(v40[0], *(void *)v41, buf);
          uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v36, (uint64_t)&v54 + 4);
          if (!*(unsigned char *)(a1 + 64)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, a2 + v32, v37, v36, a5);
          }
        }
      }
    }
  }
  return result;
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::Serializer(uint64_t a1, const StringID *a2, int a3)
{
  *(void *)a1 = &unk_26E6CBDA0;
  re::StringID::StringID((re::StringID *)(a1 + 8), a2);
  re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::Encoder(a1 + 24, a3);
  *(void *)(a1 + 248) = 0;
  *(_WORD *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 228) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_DWORD *)(a1 + 320) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(void *)(a1 + 324) = 0x7FFFFFFFLL;
  return a1;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(void *a1)
{
  *a1 = &unk_26E6CBD38;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 59));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 54));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 43);
  return re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)a1);
}

void re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(void *a1)
{
  *a1 = &unk_26E6CBD38;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 59));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 54));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 43);
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)a1);
  JUMPOUT(0x237DBCBD0);
}

void re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(void *)a1 + 80))(a1, a5);
  if (v14)
  {
    return v14(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    uint64_t v16 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
    return 0;
  }
}

uint64_t (*re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(re::Allocator **a1, char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a2 == *(void *)(a1 + 272)
    && (LODWORD(v4) = **(void **)(a2 + 16),
        HIDWORD(v4) = -1,
        (uint64_t v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, &v4)) != 0))
  {
    return *(uint64_t (**)(re::Allocator **, char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
}

uint64_t re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::Encoder(uint64_t result, int a2)
{
  *(void *)(result + 128) = 0;
  *(void *)(result + 104) = 0;
  *(void *)(result + 112) = 0;
  *(void *)(result + 96) = 0;
  *(_DWORD *)(result + 120) = 0;
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(unsigned char *)(result + 40) = 0;
  *(_DWORD *)(result + 136) = a2;
  *(unsigned char *)(result + 140) = 0;
  *(void *)(result + 152) = 1024;
  unsigned int v2 = &off_268773000;
  {
    uint64_t v8 = result;
    unsigned int v2 = &off_268773000;
    int v6 = v4;
    uint64_t result = v8;
    if (v6)
    {
      re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v5, (uint64_t)v9);
      uint64_t v7 = v10;
      if (!v9[0]) {
        uint64_t v7 = 0;
      }
      re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::Encoder(int)::s_maxSerializationDepth = v7;
      unsigned int v2 = &off_268773000;
      uint64_t result = v8;
    }
  }
  uint64_t v3 = v2[92];
  if (v3) {
    *(void *)(result + 152) = v3;
  }
  return result;
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  *(void *)a1 = &unk_26E6CBDA0;
  uint64_t v2 = a1 + 216;
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::deinit((void *)a1);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 288));
  re::DynamicArray<unsigned long>::deinit(v2);
  re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::~Encoder((unsigned char *)(a1 + 24));
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

void re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::deinit(void *a1)
{
  if (a1[34])
  {
    (*(void (**)(void *))(*a1 + 40))(a1);
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 36));
    a1[34] = 0;
  }
}

unsigned char *re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::~Encoder(unsigned char *a1)
{
  if (a1[40]) {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 64));
  }
  return a1;
}

_anonymous_namespace_ *re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::close(_anonymous_namespace_ *result)
{
  if (*(void *)result)
  {
    uint64_t v1 = result;
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::doClose(result);
    if (!*((unsigned char *)v1 + 40)) {
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 0);
    }
    uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::deinit((uint64_t)v1 + 96);
    if (*((int *)v1 + 4) >= 1)
    {
      uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)v1 + 24))();
      *((void *)v1 + 1) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *(void *)uint64_t v1 = 0;
    *((void *)v1 + 3) = 0;
    *((void *)v1 + 4) = 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::doClose(void *a1)
{
  uint64_t v2 = a1[23];
  if (v2)
  {
    uint64_t v3 = a1[3];
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy(a1[23]);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 40))(v3, v2);
  }
  a1[23] = 0;
  uint64_t v4 = a1[22];
  if (v4)
  {
    uint64_t v5 = a1[3];
    rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::~GenericDocument((void *)a1[22]);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 40))(v5, v4);
    a1[22] = 0;
  }
  return re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 24));
}

void *rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::~GenericDocument(void *a1)
{
  if (a1[4])
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Destroy((uint64_t)a1);
  rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy((uint64_t)(a1 + 5));
  return a1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Destroy(uint64_t result)
{
  if (*(void *)(result + 32))
  {
    rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::~MemoryPoolAllocator(*(void *)(result + 32));
    uint64_t v1 = *(uint64_t (**)(void))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                             + 40);
    return v1();
  }
  return result;
}

uint64_t rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::~MemoryPoolAllocator(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    unint64_t v3 = *(void *)(v2 + 16);
    if (v3 < 2)
    {
      rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Clear(a1);
      uint64_t v4 = *(void *)(a1 + 16);
      uint64_t v5 = *(void *)(v4 + 8);
      if (*(unsigned char *)(v4 + 24)) {
        (*(void (**)(void *))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
      }
                                       + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
      if (v5) {
        (*(void (**)(void *, uint64_t))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
      }
                                                + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, v5);
    }
    else
    {
      *(void *)(v2 + 16) = v3 - 1;
    }
  }
  return a1;
}

uint64_t rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Clear(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 16);
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 16);
  if (v3)
  {
    uint64_t v4 = result;
    do
    {
      uint64_t *v1 = v3;
      uint64_t result = (*(uint64_t (**)(void *))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                 + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
      uint64_t v1 = *(uint64_t **)(v4 + 16);
      uint64_t v2 = *v1;
      uint64_t v3 = *(void *)(*v1 + 16);
    }
    while (v3);
  }
  *(void *)(v2 + 8) = 0;
  return result;
}

uint64_t re::serializeType<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Allocator **a1, char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (this == (re::TypeInfo *)a6) {
    goto LABEL_19;
  }
  if (*(void *)this != *(void *)a6)
  {
    if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, a3)) {
      goto LABEL_19;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      uint64_t v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
      if (v19) {
        int v20 = *(_DWORD *)(v19 + 16);
      }
      else {
        int v20 = -1;
      }
      uint64_t v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
      if (v21) {
        int v22 = *(_DWORD *)(v21 + 16);
      }
      else {
        int v22 = -1;
      }
      if (v20 == v22) {
        goto LABEL_19;
      }
      uint64_t v24 = re::TypeInfo::name(this);
      uint64_t v25 = re::TypeInfo::name((re::TypeInfo *)a6);
      if (re::StringID::operator==(v24, v25))
      {
        uint64_t v26 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
        if (v26) {
          int v27 = *(_DWORD *)(v26 + 16);
        }
        else {
          int v27 = -1;
        }
        re::TypeInfo::atVersion(this, v27, v58);
        if (v58[0])
        {
          if (a7) {
            Instance = 0;
          }
          else {
            Instance = re::TypeInfo::createInstance((re::TypeInfo *)v59, a1[6], a1[33]);
          }
          if (*((unsigned char *)a1 + 64)
            || ((*((void (**)(re::Allocator **, char *, const re::TypeInfo *, void **, unsigned char *, uint64_t, uint64_t))*a1
                 + 9))(a1, a2, a3, Instance, v59, a6, a7), *((unsigned char *)a1 + 64)))
          {
            if (Instance) {
              re::TypeInfo::releaseInstance((re::TypeInfo *)v59, Instance, a1[6], a1[33]);
            }
          }
          else
          {
            if (a7) {
              return 1;
            }
            re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v59);
            re::internal::upgradeObject(Instance, v53, a4, (uint64_t **)this, a1[6], a1[33], v54);
            if (v54[0]) {
              return 1;
            }
            if (v56) {
              LOBYTE(v51) = v57[7];
            }
            else {
              char v51 = v57;
            }
            re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "%s", v46, v47, v48, v49, v50, (char)v51);
            if (!v54[0] && v55 && (v56 & 1) != 0) {
              (*(void (**)(void))(*(void *)v55 + 40))();
            }
          }
        }
        else
        {
          uint64_t v35 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
          re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Unknown serialized type \"%s\" version %u. No matching runtime type found.", v41, v42, v43, v44, v45, v35);
        }
      }
      else
      {
        uint64_t v33 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
        re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
        re::TypeInfo::name(this);
        re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Type name changed: Serialized type \"%s\" version %u, runtime type \"%s\" version %u.", v36, v37, v38, v39, v40, v33);
      }
    }
    else
    {
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>((uint64_t)a1, a2, this, (re::TypeInfo *)a6);
    }
    return 0;
  }
  uint64_t v15 = **((void **)this + 2);
  uint64_t v16 = **(void **)(a6 + 16);
  if ((unsigned __int16)v15 != (unsigned __int16)v16) {
    goto LABEL_10;
  }
  BOOL v18 = WORD1(v15) == WORD1(v16);
  uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
  BOOL v18 = v18 && v17 == 0;
  if (!v18) {
    goto LABEL_10;
  }
LABEL_19:
  switch(*((unsigned char *)this + 12))
  {
    case 1:
      uint64_t result = (uint64_t)re::serializeBasic<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, (unsigned int *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 2:
      uint64_t result = re::serializeEnum<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, a4, (uint64_t)this, a6, a7);
      break;
    case 3:
      uint64_t result = re::serializeOptional<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 4:
      uint64_t result = (uint64_t)re::serializeArray<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 5:
      uint64_t result = re::serializeList<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 6:
      uint64_t result = re::serializeDictionary<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 7:
      uint64_t result = (uint64_t)re::serializeUnion<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a3, (char *)a4, this, (re::TypeInfo *)a6, a7);
      break;
    case 8:
      uint64_t result = re::serializeObject<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, (uint64_t)a3, a4, this, a6, a7);
      break;
    case 9:
      uint64_t v52 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Pointer type (\"%s\") needs to be handled explicitly by the serializer.", v28, v29, v30, v31, v32, v52);
      return 0;
    default:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, a2, "Invalid type category. Value = %d", (uint64_t)a4, (uint64_t)this, a6, a7, a8, *((unsigned char *)this + 12));
      return 0;
  }
  return result;
}

unsigned int *re::serializeBasic<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned int *a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  if (this != a6)
  {
    if (*(void *)this != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3)) {
        goto LABEL_4;
      }
LABEL_21:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, this, a6);
      return 0;
    }
    uint64_t v18 = **((void **)this + 2);
    uint64_t v19 = **((void **)a6 + 2);
    if ((unsigned __int16)v18 != (unsigned __int16)v19) {
      goto LABEL_21;
    }
    BOOL v21 = WORD1(v18) == WORD1(v19);
    uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
    BOOL v21 = v21 && v20 == 0;
    if (!v21) {
      goto LABEL_21;
    }
  }
LABEL_4:
  uint64_t v14 = re::TypeInfo::name(this);
  unint64_t v15 = (unint64_t)*v14 >> 1;
  if (v15 > 0xCA3DEFB5)
  {
    if ((unint64_t)*v14 >> 1 > 0x18E6A9A092)
    {
      if ((unint64_t)*v14 >> 1 <= 0x303EE8780EDLL)
      {
        if (v15 == 0x18E6A9A093)
        {
          return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint8");
        }
        else
        {
          if (v15 != 0x303EE86A734) {
            goto LABEL_72;
          }
          return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint16");
        }
      }
      if (v15 == 0x303EE8780EELL)
      {
        return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint32");
      }
      if (v15 != 0x303EE88E58DLL) {
        goto LABEL_72;
      }
    }
    else
    {
      if ((unint64_t)*v14 >> 1 > 0x16749DFF02)
      {
        if (v15 == 0x16749DFF03)
        {
LABEL_54:
          return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int32");
        }
        uint64_t v22 = 0x16749F63A2;
LABEL_40:
        if (v15 == v22)
        {
          return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, (uint64_t)a3, (unint64_t *)a4, a7, (uint64_t)"int64");
        }
LABEL_72:
        uint64_t v23 = re::TypeInfo::name(this);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Unsupported basic type \"%s\".", v24, v25, v26, v27, v28, v23[1]);
        return 0;
      }
      if (v15 != 3393056694)
      {
        uint64_t v17 = 0x16749D2549;
LABEL_26:
        if (v15 != v17) {
          goto LABEL_72;
        }
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int16");
      }
    }
    return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint64");
  }
  if ((unint64_t)*v14 >> 1 > 0x5D0225B)
  {
    if ((unint64_t)*v14 >> 1 > 0xB0F77BD0)
    {
      if (v15 == 2969009105)
      {
        return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (uint64_t)a3, (double *)a4, a7, (uint64_t)"double");
      }
      else
      {
        if (v15 != 3111160798) {
          goto LABEL_72;
        }
        return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int8");
      }
    }
    if (v15 == 97526364)
    {
      return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (uint64_t)a3, (float *)a4, a7, (uint64_t)"float");
    }
    uint64_t v17 = 109413500;
    goto LABEL_26;
  }
  if ((unint64_t)*v14 >> 1 <= 0x2E9355)
  {
    if (v15 != 104431)
    {
      if (v15 == 3029738)
      {
        return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, (uint64_t)a3, (BOOL *)a4, a7);
      }
      goto LABEL_72;
    }
    goto LABEL_54;
  }
  if (v15 != 3052374)
  {
    uint64_t v22 = 3327612;
    goto LABEL_40;
  }
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)a3, a4, a7);
}

BOOL re::serializeEnum<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, void *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **(void **)(a5 + 16);
      uint64_t v15 = **(void **)(a6 + 16);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_12;
        }
      }
    }
    else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
    {
      goto LABEL_12;
    }
    if (*(unsigned __int8 *)(a5 + 12) != *(unsigned __int8 *)(a6 + 12)
      || (uint64_t v18 = re::TypeInfo::name((re::TypeInfo *)a5),
          uint64_t v19 = re::TypeInfo::name((re::TypeInfo *)a6),
          !re::StringID::operator==(v18, v19)))
    {
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
      return 0;
    }
  }
LABEL_12:
  return re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a3, a4, (re *)a5, (const re::TypeInfo *)a6, a7);
}

BOOL re::serializeOptional<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v25[0] = 0;
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, v25, 0);
    if (v25[0])
    {
      uint64_t v18 = *(re::internal **)(a1 + 272);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v27);
      re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
      re::internal::translateType(v18, (const re::TypeRegistry *)v26, (uint64_t)v27);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, char *, void, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, 0, 0, v27, v27, 1);
      }
    }
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)&v28);
    re::TypeInfo::TypeInfo((uint64_t)v27, (uint64_t)a5);
    BOOL v24 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4) != 0;
    double v20 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v24, 0);
    if (v24)
    {
      Instance = re::TypeInfo::createInstance((re::TypeInfo *)v26, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
      (*(void (**)(uint64_t, void **))(v29 + 88))(a4, Instance);
      re::TypeInfo::releaseInstance((re::TypeInfo *)v26, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
    }
    else
    {
      (*(void (**)(uint64_t, void, double))(v29 + 88))(a4, 0, v20);
    }
    if (v24)
    {
      uint64_t v23 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, char *, void, uint64_t, unsigned char *, unsigned char *, void))(*(void *)a1 + 72))(a1, a2, 0, v23, v26, v25, 0);
      }
    }
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::SeekableInputStream>::endOptional(v19);
  return *(unsigned char *)(a1 + 64) == 0;
}

unsigned int *re::serializeArray<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Allocator **a1, char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned char *)a6 + 12) != 4) {
    goto LABEL_48;
  }
  uint64_t v18 = (void *)*((void *)a5 + 2);
  uint64_t v19 = (void *)*((void *)a6 + 2);
  int v20 = *((_DWORD *)v19 + 21) & 0xFFFFFF;
  if ((*((_DWORD *)v18 + 21) & 0xFFFFFF) != 0)
  {
    if (v20) {
      goto LABEL_13;
    }
LABEL_48:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>((uint64_t)a1, a2, a5, a6);
    return 0;
  }
  if (v20 || *((_DWORD *)v18 + 22) != *((_DWORD *)v19 + 22)) {
    goto LABEL_48;
  }
LABEL_13:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v71);
    re::TypeInfo::TypeInfo((uint64_t)v68, (uint64_t)v72);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v71);
    re::TypeInfo::TypeInfo((uint64_t)v66, (uint64_t)v72);
    re::TypeInfo::TypeInfo((uint64_t)v64, (uint64_t)a5);
    uint64_t v28 = (*((uint64_t (**)(re::Allocator **, unsigned char *))*a1 + 10))(a1, v68);
    if (!v28)
    {
      uint64_t v45 = (re::TypeInfo *)v68;
      goto LABEL_28;
    }
    uint64_t v29 = (void (*)(re::Allocator **, void, void, uint64_t, unsigned char *, unsigned char *, void))v28;
    uint64_t v30 = re::ArrayAccessor::size((re::ArrayAccessor *)v64, a4);
    uint64_t v63 = (const re::TypeInfo *)v30;
    int v31 = *(_DWORD *)(*((void *)a5 + 2) + 84) & 0xFFFFFF;
    if (v31) {
      int v32 = 8;
    }
    else {
      int v32 = 4;
    }
    uint64_t result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((_anonymous_namespace_ *)(a1 + 3), a2, (uint64_t)a3, &v63, v32);
    if (!result) {
      return result;
    }
    uint64_t v39 = v63;
    if ((const re::TypeInfo *)v30 != v63)
    {
      if ((*(_DWORD *)(v65 + 84) & 0xFFFFFF) == 0)
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, 0, "Invalid array size. Expected size = %zu, actual size = %zu", v34, v35, v36, v37, v38, v30);
        return 0;
      }
      re::TypeRegistry::typeInfo(v64[0], *(void *)(v65 + 72), &v71);
      re::TypeInfo::TypeInfo((uint64_t)v69, (uint64_t)v72);
      if (!is_mul_ok(*(unsigned int *)(v70 + 8), (unint64_t)v39))
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, 0, "Size overflow during deserialization. Element size = %zu, count = %zu", v40, v41, v42, v43, v44, *(_DWORD *)(v70 + 8));
        return 0;
      }
      re::ArrayAccessor::reset((re::ArrayAccessor *)v64, (void **)a4, a1[6], v39);
      uint64_t v30 = (uint64_t)v63;
    }
    if (v31) {
      BOOL v56 = v30 == 0;
    }
    else {
      BOOL v56 = 1;
    }
    char v57 = v56;
    if (!v56)
    {
      uint64_t v58 = *(void *)a4;
      v62[0] = 0;
      v62[1] = 0xFFFFFFFFLL;
      (*((void (**)(re::Allocator **, uint64_t, void *))*a1 + 2))(a1, v58, v62);
      uint64_t v30 = (uint64_t)v63;
    }
    if (v30)
    {
      unint64_t v59 = 0;
      do
      {
        uint64_t v60 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)v64, a4, v59);
        v29(a1, 0, 0, v60, v68, v66, 0);
        ++v59;
      }
      while (v59 < (unint64_t)v63);
    }
    if ((v57 & 1) == 0) {
      (*((void (**)(re::Allocator **))*a1 + 3))(a1);
    }
    uint64_t v55 = (_anonymous_namespace_ *)(a1 + 3);
    goto LABEL_66;
  }
  BOOL v21 = a1[34];
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v71);
  re::TypeInfo::TypeInfo((uint64_t)v68, (uint64_t)v72);
  re::internal::translateType(v21, (const re::TypeRegistry *)v68, (uint64_t)v69);
  uint64_t v22 = (*((uint64_t (**)(re::Allocator **, unsigned char *))*a1 + 10))(a1, v69);
  if (!v22)
  {
    uint64_t v45 = (re::TypeInfo *)v69;
LABEL_28:
    uint64_t v61 = re::TypeInfo::name(v45)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v46, v47, v48, v49, v50, v61);
    return 0;
  }
  uint64_t v23 = (void (*)(re::Allocator **, void, void, void, unsigned char *, unsigned char *, uint64_t))v22;
  BOOL v24 = (void *)*((void *)a6 + 2);
  int v25 = *((_DWORD *)v24 + 21) & 0xFFFFFF;
  if (v25)
  {
    unint64_t v26 = 0;
    int v27 = 8;
  }
  else
  {
    unint64_t v26 = *((int *)v24 + 22);
    int v27 = 4;
  }
  unint64_t v71 = v26;
  uint64_t result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((_anonymous_namespace_ *)(a1 + 3), a2, (uint64_t)a3, &v71, v27);
  if (result)
  {
    unint64_t v51 = v71;
    if (v25) {
      BOOL v52 = v71 == 0;
    }
    else {
      BOOL v52 = 1;
    }
    char v53 = v52;
    if (!v52)
    {
      v67[0] = 0;
      v67[1] = 0xFFFFFFFFLL;
      (*((void (**)(re::Allocator **, void, void *))*a1 + 2))(a1, 0, v67);
      unint64_t v51 = v71;
    }
    if (v51)
    {
      unint64_t v54 = 0;
      do
      {
        v23(a1, 0, 0, 0, v69, v69, 1);
        ++v54;
      }
      while (v54 < v71);
    }
    if ((v53 & 1) == 0) {
      (*((void (**)(re::Allocator **))*a1 + 3))(a1);
    }
    uint64_t v55 = (_anonymous_namespace_ *)(a1 + 3);
LABEL_66:
    re::EncoderBinary<re::SeekableInputStream>::endArray(v55);
    return (unsigned int *)(*((unsigned char *)a1 + 64) == 0);
  }
  return result;
}

BOOL re::serializeList<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    uint64_t v18 = *(re::internal **)(a1 + 272);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v60);
    re::TypeInfo::TypeInfo((uint64_t)v57, (uint64_t)v61);
    re::internal::translateType(v18, (const re::TypeRegistry *)v57, (uint64_t)v58);
    uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v58);
    if (v19)
    {
      int v20 = (void (*)(uint64_t, void, void, void, unsigned char *, unsigned char *, uint64_t))v19;
      unint64_t v60 = 0;
      BOOL v21 = (_anonymous_namespace_ *)(a1 + 24);
      unsigned int v22 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v60, 0);
      BOOL result = 0;
      if (!v22) {
        return result;
      }
      if (v60)
      {
        for (unint64_t i = 0; i < v60; ++i)
          v20(a1, 0, 0, 0, v58, v58, 1);
      }
      goto LABEL_34;
    }
    uint64_t v36 = (re::TypeInfo *)v58;
    goto LABEL_26;
  }
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v60);
  re::TypeInfo::TypeInfo((uint64_t)v57, (uint64_t)v61);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v60);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v61);
  re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)a5);
  uint64_t v25 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v57);
  if (!v25)
  {
    uint64_t v36 = (re::TypeInfo *)v57;
LABEL_26:
    uint64_t v51 = re::TypeInfo::name(v36)[1];
    uint64_t v35 = "Failed to resolve serialize function for type \"%s\"";
    goto LABEL_27;
  }
  unint64_t v26 = (void (*)(uint64_t, void, void, uint64_t, unsigned char *, unsigned char *, void))v25;
  uint64_t v27 = (*(uint64_t (**)(uint64_t))(v55 + 80))(a4);
  unint64_t v53 = v27;
  BOOL v21 = (_anonymous_namespace_ *)(a1 + 24);
  unsigned int v28 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v53, 0);
  BOOL result = 0;
  if (!v28) {
    return result;
  }
  unint64_t v29 = v53;
  if (v27 != v53)
  {
    re::TypeRegistry::typeInfo(v54[0], *(void *)(v55 + 72), &v60);
    re::TypeInfo::TypeInfo((uint64_t)v58, (uint64_t)v61);
    if (!is_mul_ok(*(unsigned int *)(v59 + 8), v29))
    {
      LODWORD(v51) = *(_DWORD *)(v59 + 8);
      uint64_t v35 = "Size overflow during deserialization. Element size = %zu, count = %zu";
LABEL_27:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, v35, v30, v31, v32, v33, v34, v51);
      return 0;
    }
    uint64_t v37 = *(void *)(a1 + 48);
    uint64_t v38 = *(void (**)(uint64_t, unint64_t *, uint64_t, unint64_t))(v55 + 88);
    re::TypeInfo::TypeInfo((uint64_t)&v60, (uint64_t)v54);
    v38(a4, &v60, v37, v29);
  }
  if (*(void *)(v55 + 96))
  {
    if (v53)
    {
      for (unint64_t j = 0; j < v53; ++j)
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, unint64_t))(v55 + 96))(a4, j);
        v26(a1, 0, 0, v40, v57, v56, 0);
      }
    }
  }
  else
  {
    uint64_t v41 = *(uint64_t (**)(uint64_t, void))(v55 + 104);
    if (!v41 || !*(void *)(v55 + 112) || !*(void *)(v55 + 120))
    {
      uint64_t v45 = (re::TypeInfo *)re::TypeInfo::TypeInfo((uint64_t)&v60, (uint64_t)v54);
      uint64_t v52 = re::TypeInfo::name(v45)[1];
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "List type \"%s\" does not provide an indexer or iterator.", v46, v47, v48, v49, v50, v52);
      return 0;
    }
    uint64_t v42 = v41(a4, *(void *)(a1 + 56));
    uint64_t v43 = (*(uint64_t (**)(void))(v55 + 112))();
    if (v43)
    {
      uint64_t v44 = v43;
      do
      {
        v26(a1, 0, 0, v44, v57, v56, 0);
        uint64_t v44 = (*(uint64_t (**)(uint64_t))(v55 + 112))(v42);
      }
      while (v44);
    }
    (*(void (**)(uint64_t, void))(v55 + 120))(v42, *(void *)(a1 + 56));
  }
LABEL_34:
  re::EncoderBinary<re::SeekableInputStream>::endArray(v21);
  return *(unsigned char *)(a1 + 64) == 0;
}

uint64_t re::serializeDictionary<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, re *a5, const re::TypeInfo *a6, uint64_t a7)
{
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v75);
  re::TypeInfo::TypeInfo((uint64_t)v73, (uint64_t)v76);
  uint64_t v15 = re::TypeInfo::name((re::TypeInfo *)v73);
  int v16 = v74;
  if (v74 != 1)
  {
LABEL_10:
    if (v16 == 8)
    {
      unint64_t v21 = (unint64_t)*v15 >> 1;
      if (v21 == 0x22C6ED80D0CLL)
      {
        unint64_t v26 = (char *)v15[1];
        uint64_t v19 = re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
        if (v26 == "StringID") {
          return ((uint64_t (*)(uint64_t, char *, uint64_t, uint64_t, re *, const re::TypeInfo *, uint64_t))v19)(a1, a2, a3, a4, a5, a6, a7);
        }
        int v27 = strcmp(v26, "StringID");
        uint64_t v19 = re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
        if (!v27) {
          return ((uint64_t (*)(uint64_t, char *, uint64_t, uint64_t, re *, const re::TypeInfo *, uint64_t))v19)(a1, a2, a3, a4, a5, a6, a7);
        }
      }
      else if (v21 == 0x134375A94D9F7110)
      {
        unsigned int v22 = (char *)v15[1];
        uint64_t v19 = re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
        if (v22 == "DynamicString") {
          return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
        }
        int v23 = strcmp(v22, "DynamicString");
        uint64_t v19 = re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
        if (!v23) {
          return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
        }
      }
    }
LABEL_22:
    if (a5 != a6)
    {
      if (*(void *)a5 == *(void *)a6)
      {
        uint64_t v28 = **((void **)a5 + 2);
        uint64_t v29 = **((void **)a6 + 2);
        if ((unsigned __int16)v28 == (unsigned __int16)v29)
        {
          BOOL v31 = WORD1(v28) == WORD1(v29);
          uint64_t v30 = (v29 ^ v28) & 0xFFFFFF00000000;
          BOOL v31 = v31 && v30 == 0;
          if (v31) {
            goto LABEL_32;
          }
        }
      }
      else if (re::areSameTranslatedVersion(a5, a6, v14))
      {
        goto LABEL_32;
      }
      if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
      {
        re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
        return 0;
      }
    }
LABEL_32:
    if (a7)
    {
      uint64_t v32 = *(re::internal **)(a1 + 272);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v75);
      re::TypeInfo::TypeInfo((uint64_t)v72, (uint64_t)v76);
      re::internal::translateType(v32, (const re::TypeRegistry *)v72, (uint64_t)v73);
      uint64_t v33 = *(re::internal **)(a1 + 272);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v75);
      re::TypeInfo::TypeInfo((uint64_t)v71, (uint64_t)v76);
      re::internal::translateType(v33, (const re::TypeRegistry *)v71, (uint64_t)v72);
      uint64_t v34 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v73);
      if (v34)
      {
        uint64_t v35 = (void (*)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t))v34;
        uint64_t v36 = (*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 80))(a1, v72);
        if (v36)
        {
          uint64_t v37 = (void (*)(uint64_t, const char *, void, void, void *, void *, uint64_t))v36;
          unint64_t v75 = 0;
          uint64_t v38 = (_anonymous_namespace_ *)(a1 + 24);
          unsigned int v39 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary((_anonymous_namespace_ *)(a1 + 24), a2, a3, &v75, 0);
          uint64_t result = 0;
          if (!v39) {
            return result;
          }
          if (v75)
          {
            for (unint64_t i = 0; i < v75; ++i)
            {
              re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 1);
              v35(a1, "key", 0, 0, v73, v73, 1);
              v37(a1, "value", 0, 0, v72, v72, 1);
              re::EncoderBinary<re::SeekableInputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
            }
          }
          goto LABEL_49;
        }
        goto LABEL_52;
      }
LABEL_50:
      unint64_t v53 = (re::TypeInfo *)v73;
LABEL_53:
      unint64_t v54 = re::TypeInfo::name(v53);
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v55, v56, v57, v58, v59, v54[1]);
      return 0;
    }
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v75);
    re::TypeInfo::TypeInfo((uint64_t)v73, (uint64_t)v76);
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v75);
    re::TypeInfo::TypeInfo((uint64_t)v72, (uint64_t)v76);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v75);
    re::TypeInfo::TypeInfo((uint64_t)v71, (uint64_t)v76);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v75);
    re::TypeInfo::TypeInfo((uint64_t)v70, (uint64_t)v76);
    re::TypeInfo::TypeInfo((uint64_t)v68, (uint64_t)a5);
    uint64_t v42 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v73);
    if (!v42) {
      goto LABEL_50;
    }
    uint64_t v43 = (void (*)(uint64_t, const char *, void, void **, unsigned char *, unsigned char *, void))v42;
    uint64_t v44 = (*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 80))(a1, v72);
    if (!v44)
    {
LABEL_52:
      unint64_t v53 = (re::TypeInfo *)v72;
      goto LABEL_53;
    }
    uint64_t v45 = (void (*)(uint64_t, const char *, void, uint64_t, void *, unsigned char *, void))v44;
    unint64_t v67 = (*(uint64_t (**)(uint64_t))(v69 + 88))(a4);
    uint64_t v38 = (_anonymous_namespace_ *)(a1 + 24);
    unsigned int v46 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary((_anonymous_namespace_ *)(a1 + 24), a2, a3, &v67, 0);
    uint64_t result = 0;
    if (!v46) {
      return result;
    }
    uint64_t v47 = *(void *)(a1 + 48);
    uint64_t v48 = *(void (**)(uint64_t, unint64_t *, uint64_t))(v69 + 96);
    re::TypeInfo::TypeInfo((uint64_t)&v75, (uint64_t)v68);
    v48(a4, &v75, v47);
    if (!v67)
    {
LABEL_49:
      re::EncoderBinary<re::SeekableInputStream>::endDictionary(v38);
      return *(unsigned char *)(a1 + 64) == 0;
    }
    Instance = re::TypeInfo::createInstance((re::TypeInfo *)v73, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
    if (!v67)
    {
LABEL_48:
      re::TypeInfo::releaseInstance((re::TypeInfo *)v73, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
      goto LABEL_49;
    }
    uint64_t v50 = 0;
    while (1)
    {
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 0);
      v43(a1, "key", 0, Instance, v73, v71, 0);
      uint64_t v51 = *(re::Allocator **)(a1 + 48);
      if (*(unsigned char *)(a1 + 64)) {
        break;
      }
      uint64_t v52 = (*(uint64_t (**)(uint64_t, unsigned char *, re::Allocator *, void **))(v69 + 104))(a4, v68, v51, Instance);
      v45(a1, "value", 0, v52, v72, v70, 0);
      re::EncoderBinary<re::SeekableInputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
      if (++v50 >= v67) {
        goto LABEL_48;
      }
    }
    re::TypeInfo::releaseInstance((re::TypeInfo *)v73, Instance, v51, *(void **)(a1 + 264));
    return 0;
  }
  if (!re::TypeInfo::isInteger((re::TypeInfo *)v73))
  {
    int v16 = v74;
    goto LABEL_10;
  }
  unint64_t v17 = (unint64_t)*v15 >> 1;
  if (v17 > 0x303EE8780EDLL)
  {
    if (v17 == 0x303EE8780EELL)
    {
      uint64_t v61 = (char *)v15[1];
      uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>;
      if (v61 == "uint32_t") {
        return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
      }
      int v62 = strcmp(v61, "uint32_t");
      uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>;
      if (!v62) {
        return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
      }
      goto LABEL_61;
    }
    if (v17 != 0x303EE88E58DLL)
    {
LABEL_61:
      unint64_t v75 = 0x18E6A9A093;
      v76[0] = "uint8_t";
      BOOL v63 = re::StringID::operator==(v15, &v75);
      uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>;
      if (v63) {
        return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
      }
      unint64_t v75 = 0x16749F63A2;
      v76[0] = "int64_t";
      if (re::StringID::operator==(v15, &v75)) {
        return ((uint64_t (*)(uint64_t, char *, uint64_t, uint64_t, re *, const re::TypeInfo *, uint64_t))re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>)(a1, a2, a3, a4, a5, a6, a7);
      }
      v72[0] = 3327612;
      v72[1] = "long";
      BOOL v64 = re::StringID::operator==(v15, v72);
      uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>;
      if (v64) {
        return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
      }
      unint64_t v75 = 104431;
      v76[0] = "int";
      BOOL v65 = re::StringID::operator==(v15, &v75);
      uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>;
      if (v65) {
        return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
      }
      unint64_t v75 = 109413500;
      v76[0] = "short";
      BOOL v66 = re::StringID::operator==(v15, &v75);
      uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>;
      if (v66) {
        return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
      }
      goto LABEL_22;
    }
    BOOL v24 = (char *)v15[1];
    uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
    if (v24 != "uint64_t")
    {
      uint64_t v25 = "uint64_t";
      goto LABEL_57;
    }
  }
  else
  {
    if (v17 != 3393056694)
    {
      if (v17 == 0x303EE86A734)
      {
        uint64_t v18 = (char *)v15[1];
        uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>;
        if (v18 == "uint16_t") {
          return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
        }
        int v20 = strcmp(v18, "uint16_t");
        uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>;
        if (!v20) {
          return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
        }
      }
      goto LABEL_61;
    }
    BOOL v24 = (char *)v15[1];
    uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
    if (v24 != "size_t")
    {
      uint64_t v25 = "size_t";
LABEL_57:
      int v60 = strcmp(v24, v25);
      uint64_t v19 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
      if (!v60) {
        return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
      }
      goto LABEL_61;
    }
  }
  return ((uint64_t (*)(void, void, void, void, void, void, void))v19)(a1, a2, a3, a4, a5, a6, a7);
}

unsigned int *re::serializeUnion<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v15 = **((void **)a5 + 2);
    uint64_t v16 = **((void **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      BOOL v18 = WORD1(v15) == WORD1(v16);
      uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      BOOL v18 = v18 && v17 == 0;
      if (v18) {
        goto LABEL_4;
      }
    }
LABEL_19:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_19;
  }
LABEL_4:
  uint64_t result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 16);
  if (a7)
  {
    if (!result) {
      return result;
    }
    v19[0] = 0;
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, "tag", 0, v19, 0, (uint64_t)"uint64");
    if (v19[0] < *(unsigned int *)(*((void *)a6 + 2) + 88))
    {
      re::TypeInfo::unionMember(a6, v19[0], (uint64_t)v21);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, "value", 0, 0, v21, v21, 1);
      }
    }
  }
  else
  {
    if (!result) {
      return result;
    }
    re::TypeInfo::TypeInfo((uint64_t)v21, (uint64_t)a5);
    unint64_t Tag = re::UnionAccessor::readTag((re::UnionAccessor *)v21, a4);
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, "tag", 0, &Tag, 0, (uint64_t)"uint64");
    re::UnionAccessor::reset((re::UnionAccessor *)v21, a4, (const re::TypeInfo *)Tag, *(re::Allocator **)(a1 + 48));
    if (Tag < *(unsigned int *)(*((void *)a5 + 2) + 88))
    {
      re::TypeInfo::unionMember(a5, Tag, (uint64_t)v19);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, char *, unint64_t *, unint64_t *, void))(*(void *)a1 + 72))(a1, "value", 0, a4, v19, v19, 0);
      }
    }
  }
  re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
  return (unsigned int *)(*(unsigned char *)(a1 + 64) == 0);
}

uint64_t re::serializeObject<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, uint64_t a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  if (a7)
  {
    if (*(unsigned char *)(*((void *)this + 2) + 49))
    {
      uint64_t v25 = *(re::TypeRegistry **)(a1 + 272);
      v68[0] = 0x2686EB529B3EE220;
      v68[1] = "DynamicString";
      re::TypeRegistry::typeInfo(v25, (const re::StringID *)v68, v61);
      re::TypeInfo::TypeInfo((uint64_t)v66, (uint64_t)&v62);
      re::StringID::destroyString((re::StringID *)v68);
      unint64_t v26 = (re *)v66;
      int v27 = (const re::TypeInfo *)v66;
      uint64_t v28 = a1;
      uint64_t v29 = a2;
      uint64_t v30 = (const re::TypeInfo *)a3;
    }
    else
    {
      uint64_t v14 = re::TypeInfo::name(this);
      if ((unint64_t)*v14 >> 1 != 0x134375A94D9F7110) {
        goto LABEL_6;
      }
      uint64_t v15 = (const char *)v14[1];
      if (v15 != "DynamicString")
      {
        if (strcmp(v15, "DynamicString")) {
          goto LABEL_6;
        }
      }
      uint64_t v28 = a1;
      uint64_t v29 = a2;
      uint64_t v30 = (const re::TypeInfo *)a3;
      unint64_t v26 = this;
      int v27 = this;
    }
    re::serializeDynamicString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(v28, v29, v30, 0, v26, v27, 1);
    return *(unsigned char *)(a1 + 64) == 0;
  }
LABEL_6:
  if ((*(unsigned char *)(*((void *)this + 2) + 48) & 4) != 0)
  {
    return re::internal::serializeObjectWithOneMember<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((unsigned char *)a1, a2, a3, (uint64_t)a4, (uint64_t *)this, (uint64_t *)a6, a7);
  }
  else
  {
    unsigned int v16 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, a3, 0);
    uint64_t result = 0;
    if (!v16) {
      return result;
    }
    uint64_t v18 = *(void *)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
    if (v18
      && *(_WORD *)(v18 + 22) == 3
      && *(_DWORD *)v18
      && (uint64_t v19 = *(void *)(v18 + 8), (*(_WORD *)(v19 + 46) & 0x40) != 0)
      && ((*(_WORD *)(v19 + 22) & 0x1000) != 0 ? (int v20 = *(const char **)(v18 + 8)) : (int v20 = *(const char **)(v19 + 8)),
          !strcmp(v20, "@version")))
    {
      int v21 = *(_DWORD *)(v19 + 24);
    }
    else
    {
      int v21 = 1;
    }
    uint64_t v22 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
    if (v22) {
      int v24 = *(_DWORD *)(v22 + 16);
    }
    else {
      int v24 = -1;
    }
    if (v21 == v24)
    {
      if (this != (re::TypeInfo *)a6)
      {
        if (*(void *)this == *(void *)a6)
        {
          uint64_t v39 = **((void **)this + 2);
          uint64_t v40 = **(void **)(a6 + 16);
          if ((unsigned __int16)v39 == (unsigned __int16)v40
            && WORD1(v39) == WORD1(v40)
            && ((v40 ^ v39) & 0xFFFFFF00000000) == 0)
          {
            goto LABEL_30;
          }
        }
        else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v23))
        {
          goto LABEL_30;
        }
        if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
        {
          re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, (uint64_t)a4, (uint64_t *)this, (uint64_t *)a6, a7);
        }
        else
        {
          uint64_t v41 = re::TypeInfo::name(this)[1];
          re::TypeInfo::name((re::TypeInfo *)a6);
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v42, v43, v44, v45, v46, v41);
        }
        goto LABEL_43;
      }
LABEL_30:
      re::internal::serializeMembersWithoutVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((unsigned char *)a1, (uint64_t)a4, (uint64_t *)this, a7);
LABEL_43:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(unsigned char *)(a1 + 64) == 0;
    }
    if (*(void *)this != *(void *)a6
      || (uint64_t v31 = **((void **)this + 2), v32 = **(void **)(a6 + 16), (unsigned __int16)v31 != (unsigned __int16)v32)
      || WORD1(v31) != WORD1(v32)
      || ((v32 ^ v31) & 0xFFFFFF00000000) != 0)
    {
      uint64_t v33 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type \"%s\" version %u expected in JSON. Actual version found in JSON: %u", v34, v35, v36, v37, v38, v33);
      return 0;
    }
    re::TypeInfo::atVersion(this, v21, v66);
    if (!v66[0])
    {
      uint64_t v59 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Unknown serialized type \"%s\" version %u. No matching runtime type found.", v48, v49, v50, v51, v52, v59);
      return 0;
    }
    if (a7) {
      Instance = 0;
    }
    else {
      Instance = re::TypeInfo::createInstance((re::TypeInfo *)v67, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
    }
    re::internal::serializeMembersWithoutVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((unsigned char *)a1, (uint64_t)Instance, v67, a7);
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    if (*(unsigned char *)(a1 + 64))
    {
      if (Instance) {
        re::TypeInfo::releaseInstance((re::TypeInfo *)v67, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
      }
      return 0;
    }
    if ((a7 & 1) == 0)
    {
      re::TypeInfo::TypeInfo((uint64_t)v60, (uint64_t)v67);
      re::internal::upgradeObject(Instance, v60, a4, (uint64_t **)this, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264), v61);
      if (!v61[0])
      {
        if (v64) {
          LOBYTE(v58) = v65[7];
        }
        else {
          uint64_t v58 = v65;
        }
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "%s", v53, v54, v55, v56, v57, (char)v58);
        if (!v61[0] && v63 && (v64 & 1) != 0) {
          (*(void (**)(void))(*(void *)v63 + 40))();
        }
      }
    }
    return 1;
  }
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(uint64_t a1, char *a2, uint64_t a3, BOOL *a4, char a5)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    int v10 = *(unsigned __int16 *)(result + 22);
    if ((v10 & 8) != 0)
    {
      BOOL v13 = v10 == 10;
    }
    else
    {
      if ((v10 & 0x400) == 0
        || !*(unsigned char *)(a1 + 233)
        || ((v10 & 0x1000) != 0 ? (uint64_t v11 = (const char *)result) : (uint64_t v11 = *(const char **)(result + 8)),
            (uint64_t v12 = (re *)strcasecmp(v11, "true"), v13 = v12 == 0, v12)
         && (uint64_t v12 = (re *)strcasecmp(v11, "false"), v12)))
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, (uint64_t)"BOOL");
        return 0;
      }
      uint64_t v15 = *re::foundationSerializationLogObjects(v12);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 136315138;
        uint64_t v17 = v11;
        _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as BOOLean in Bool/String Compatibility Mode", (uint8_t *)&v16, 0xCu);
      }
    }
    if (a5)
    {
      if ((a5 & 2) != 0) {
        return 1;
      }
    }
    else
    {
      *a4 = v13;
      if ((a5 & 2) != 0) {
        return 1;
      }
    }
    uint64_t v14 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v14 - 16);
    return 1;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(uint64_t a1, char *a2, uint64_t a3, unsigned char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*((_WORD *)result + 11) & 0x400) == 0)
    {
      int v10 = (*((_WORD *)result + 11) & 0x1000) != 0 ? 21 - *((char *)result + 21) : *result;
      if (v10 == 1)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, (uint64_t)"char");
        return 0;
      }
    }
    if ((a5 & 1) == 0)
    {
      if ((*((_WORD *)result + 11) & 0x1000) != 0) {
        uint64_t v11 = result;
      }
      else {
        uint64_t v11 = (unsigned char *)*((void *)result + 1);
      }
      *a4 = *v11;
    }
    if ((a5 & 2) == 0)
    {
      uint64_t v12 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
      ++*(void *)(v12 - 16);
    }
    return (unsigned int *)1;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(_anonymous_namespace_ *a1, char *__s, _DWORD *a3)
{
  uint64_t v4 = *((void *)a1 + 16);
  uint64_t v5 = *((void *)a1 + 14) - 1;
  int v6 = *(unsigned __int8 *)(v4 + 48 * v5);
  if (!*(unsigned char *)(v4 + 48 * v5)) {
    return (unsigned int *)*((void *)a1 + 22);
  }
  uint64_t v8 = v4 + 48 * v5;
  uint64_t Member = *(void *)(v8 + 40);
  if (!Member) {
    return 0;
  }
  switch(v6)
  {
    case 7:
LABEL_6:
      uint64_t Member = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::findMember((int)a1, *(unsigned int **)(v8 + 40), __s);
      break;
    case 5:
      uint64_t v12 = *(void *)(v4 + 48 * v5 + 32);
      if (*(_DWORD *)Member > v12)
      {
        uint64_t Member = *(void *)(Member + 8) + 24 * v12;
        break;
      }
      return 0;
    case 2:
      goto LABEL_6;
  }
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::evaluateConditional(a1, __s, (unsigned int *)Member, a3);
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType(_anonymous_namespace_ *a1, const char *a2, uint64_t a3)
{
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v7);
  if (v8) {
    uint64_t v5 = *(unsigned char **)&v9[7];
  }
  else {
    uint64_t v5 = v9;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Expected type: \"%s\"", (re::DynamicString *)v10, v5, a3);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v10);
  if (*(void *)&v10[0])
  {
    if (BYTE8(v10[0])) {
      (*(void (**)(void))(**(void **)&v10[0] + 40))();
    }
    memset(v10, 0, sizeof(v10));
  }
  uint64_t result = v7;
  if (v7)
  {
    if (v8) {
      return (*(uint64_t (**)(void))(*(void *)v7 + 40))();
    }
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::findMember(int a1, unsigned int *a2, char *__s)
{
  size_t v5 = strlen(__s);
  uint64_t v6 = *a2;
  if (v6)
  {
    size_t v7 = v5;
    uint64_t v8 = *((void *)a2 + 1);
    size_t v9 = v5 - 1;
    uint64_t v10 = v8 + 24;
    do
    {
      if ((*(_WORD *)(v10 - 2) & 0x1000) != 0) {
        uint64_t v11 = (char *)(v10 - 24);
      }
      else {
        uint64_t v11 = *(char **)(v10 - 16);
      }
      if ((*(_WORD *)(v10 - 2) & 0x1000) != 0) {
        int v12 = 21 - *(char *)(v10 - 3);
      }
      else {
        int v12 = *(_DWORD *)(v10 - 24);
      }
      if (v7 == v12 && !strncmp(__s + 1, v11 + 1, v9))
      {
        if (!v7)
        {
          re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
          uint64_t result = _os_crash();
          __break(1u);
          return result;
        }
        __darwin_ct_rune_t v14 = __toupper(*__s);
        if (v14 == __toupper(*v11)) {
          return v10;
        }
        uint64_t v8 = *((void *)a2 + 1);
        uint64_t v6 = *a2;
      }
      uint64_t v15 = v10 + 24;
      v10 += 48;
    }
    while (v15 != v8 + 48 * v6);
  }
  return 0;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::evaluateConditional(_anonymous_namespace_ *a1, const char *a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v4 = a3;
  if (a3)
  {
    if (*((_WORD *)a3 + 11) == 4)
    {
      uint64_t v5 = *a3;
      if (v5 >= 2)
      {
        uint64_t v6 = *((void *)a3 + 1);
        if ((*(_WORD *)(v6 + 22) & 0x400) != 0)
        {
          uint64_t v10 = (*(_WORD *)(v6 + 22) & 0x1000) != 0 ? (const char *)*((void *)a3 + 1) : *(const char **)(v6 + 8);
          if (!strcmp(v10, "@cond"))
          {
            uint64_t v12 = v5 - 1;
            uint64_t v13 = (v5 - 1) - 1;
            __darwin_ct_rune_t v14 = (_WORD *)(v6 + 46);
            while (1)
            {
              if (*v14 != 4) {
                goto LABEL_17;
              }
              if (*(_DWORD *)(v14 - 11) < 2u) {
                goto LABEL_17;
              }
              uint64_t v15 = *(int **)(v14 - 7);
              if ((*((_WORD *)v15 + 11) & 0x20) == 0) {
                goto LABEL_17;
              }
              int v16 = *v15;
              if (!v13 || *((_DWORD *)a1 + 34) <= v16) {
                break;
              }
              --v13;
              v14 += 12;
              if (!--v12)
              {
                re::internal::assertLog((re::internal *)4, v11, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "evaluateConditional", 1447);
                _os_crash();
                __break(1u);
LABEL_17:
                re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v19);
                if (v20) {
                  uint64_t v17 = *(unsigned char **)&v21[7];
                }
                else {
                  uint64_t v17 = v21;
                }
                re::DynamicString::format((re::DynamicString *)"Failed to read version conditional \"%s\". Invalid condition.", (re::DynamicString *)v22, v17);
                re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v22);
                if (*(void *)&v22[0])
                {
                  if (BYTE8(v22[0])) {
                    (*(void (**)(void))(**(void **)&v22[0] + 40))();
                  }
                  memset(v22, 0, sizeof(v22));
                }
                if (v19 && (v20 & 1) != 0) {
                  (*(void (**)(void))(*(void *)v19 + 40))();
                }
                return 0;
              }
            }
            if (a4)
            {
              *a4 = v16;
              uint64_t v15 = *(int **)(v14 - 7);
            }
            return (unsigned int *)(v15 + 6);
          }
        }
      }
    }
  }
  return v4;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(uint64_t a1, char *a2, uint64_t a3, unsigned char *a4, char a5, uint64_t a6)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*((_WORD *)result + 11) & 0x20) != 0)
    {
      int v14 = *result;
      if (v14 != (char)v14)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorValueOutOfTypeRange((_anonymous_namespace_ *)a1, a2, a6);
        return 0;
      }
LABEL_14:
      if ((a5 & 1) == 0) {
        *a4 = v14;
      }
      if ((a5 & 2) == 0)
      {
        uint64_t v15 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
        ++*(void *)(v15 - 16);
      }
      return (unsigned int *)1;
    }
    if ((*((_WORD *)result + 11) & 0x400) == 0 || !*(unsigned char *)(a1 + 232)) {
      goto LABEL_43;
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0) {
      uint64_t v12 = (unsigned __int8 *)result;
    }
    else {
      uint64_t v12 = (unsigned __int8 *)*((void *)result + 1);
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0) {
      unsigned int v13 = 21 - *((char *)result + 21);
    }
    else {
      unsigned int v13 = *result;
    }
    int v16 = &v12[v13];
    if (v13) {
      BOOL v17 = *v12 == 45;
    }
    else {
      BOOL v17 = 0;
    }
    BOOL v18 = v17;
    if (v13 == (unint64_t)v17) {
      goto LABEL_38;
    }
    unint64_t v19 = v13 - (unint64_t)v17;
    char v20 = &v12[v17];
    while (*v20 == 48)
    {
      ++v20;
      if (!--v19) {
        goto LABEL_38;
      }
    }
    if (!v19)
    {
LABEL_38:
      char v20 = &v12[v13];
    }
    else if (*v20 - 48 < 0xA)
    {
      char v20 = std::__itoa::__traits<unsigned char>::__read[abi:nn180100](v20, v16, buf, &v23);
      if (v20 != v16 && *v20 - 48 <= 9 || *(_DWORD *)buf > 0xFFu || 255 - *(_DWORD *)buf < v23) {
        goto LABEL_43;
      }
      unsigned int v21 = v23 + *(_DWORD *)buf;
      if (!v18)
      {
        if ((v21 & 0x80) != 0) {
          goto LABEL_43;
        }
        LOBYTE(v14) = v23 + buf[0];
        goto LABEL_42;
      }
      if ((v23 + buf[0]) > 0x80u) {
        goto LABEL_43;
      }
LABEL_41:
      int v14 = -v21;
LABEL_42:
      if (v16 != v20) {
        goto LABEL_43;
      }
      uint64_t v22 = *re::foundationSerializationLogObjects((re *)v20);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        uint64_t v25 = v12;
        _os_log_impl(&dword_233120000, v22, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
      }
      goto LABEL_14;
    }
    if (v20 == &v12[v17])
    {
LABEL_43:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    unsigned int v21 = 0;
    LOBYTE(v14) = 0;
    if (!v17) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorValueOutOfTypeRange(_anonymous_namespace_ *a1, const char *a2, uint64_t a3)
{
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v7);
  if (v8) {
    uint64_t v5 = *(unsigned char **)&v9[7];
  }
  else {
    uint64_t v5 = v9;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Value out of \"%s\" type range.", (re::DynamicString *)v10, v5, a3);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v10);
  if (*(void *)&v10[0])
  {
    if (BYTE8(v10[0])) {
      (*(void (**)(void))(**(void **)&v10[0] + 40))();
    }
    memset(v10, 0, sizeof(v10));
  }
  uint64_t result = v7;
  if (v7)
  {
    if (v8) {
      return (*(uint64_t (**)(void))(*(void *)v7 + 40))();
    }
  }
  return result;
}

unsigned __int8 *std::__itoa::__traits<unsigned char>::__read[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v4 = 2;
  do
  {
    int v5 = *a1;
    if ((v5 - 58) < 0xFFFFFFF6) {
      break;
    }
    ++a1;
    v12[v4] = v5 - 48;
    if (v4-- == 0) {
      break;
    }
  }
  while (a1 != a2);
  int v7 = v4 + 1;
  uint64_t v8 = (v4 + 1) << 32;
  int v9 = v12[v7];
  if (v7 <= 0) {
    v9 += 10 * v12[v7 + 1];
  }
  *a3 = v9;
  unint64_t v10 = v12[2] * (unint64_t)*(unsigned int *)((char *)&std::__itoa::__pow10_32 + ((0x200000000 - v8) >> 30));
  *a4 = v10;
  return &a1[-((v10 & 0xFFFFFFFF00000000) != 0)];
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, char a5, uint64_t a6)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*((_WORD *)result + 11) & 0x20) != 0)
    {
      int v14 = *result;
      if (v14 != (__int16)v14)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorValueOutOfTypeRange((_anonymous_namespace_ *)a1, a2, a6);
        return 0;
      }
LABEL_14:
      if ((a5 & 1) == 0) {
        *a4 = v14;
      }
      if ((a5 & 2) == 0)
      {
        uint64_t v15 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
        ++*(void *)(v15 - 16);
      }
      return (unsigned int *)1;
    }
    if ((*((_WORD *)result + 11) & 0x400) == 0 || !*(unsigned char *)(a1 + 232)) {
      goto LABEL_43;
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0) {
      uint64_t v12 = (unsigned __int8 *)result;
    }
    else {
      uint64_t v12 = (unsigned __int8 *)*((void *)result + 1);
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0) {
      unsigned int v13 = 21 - *((char *)result + 21);
    }
    else {
      unsigned int v13 = *result;
    }
    int v16 = &v12[v13];
    if (v13) {
      BOOL v17 = *v12 == 45;
    }
    else {
      BOOL v17 = 0;
    }
    BOOL v18 = v17;
    if (v13 == (unint64_t)v17) {
      goto LABEL_38;
    }
    unint64_t v19 = v13 - (unint64_t)v17;
    char v20 = &v12[v17];
    while (*v20 == 48)
    {
      ++v20;
      if (!--v19) {
        goto LABEL_38;
      }
    }
    if (!v19)
    {
LABEL_38:
      char v20 = &v12[v13];
    }
    else if (*v20 - 48 < 0xA)
    {
      char v20 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v20, v16, buf, &v23);
      if (v20 != v16 && *v20 - 48 <= 9 || *(_WORD *)&buf[2] || 0xFFFF - *(_DWORD *)buf < v23) {
        goto LABEL_43;
      }
      unsigned int v21 = v23 + *(_DWORD *)buf;
      if (!v18)
      {
        if ((v21 & 0x8000) != 0) {
          goto LABEL_43;
        }
        LOWORD(v14) = v23 + *(_WORD *)buf;
        goto LABEL_42;
      }
      if ((unsigned __int16)(v23 + *(_WORD *)buf) > 0x8000u) {
        goto LABEL_43;
      }
LABEL_41:
      int v14 = -v21;
LABEL_42:
      if (v16 != v20) {
        goto LABEL_43;
      }
      uint64_t v22 = *re::foundationSerializationLogObjects((re *)v20);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        uint64_t v25 = v12;
        _os_log_impl(&dword_233120000, v22, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
      }
      goto LABEL_14;
    }
    if (v20 == &v12[v17])
    {
LABEL_43:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    unsigned int v21 = 0;
    LOWORD(v14) = 0;
    if (!v17) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  return result;
}

unsigned __int8 *std::__itoa::__traits<unsigned short>::__read[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v4 = 4;
  do
  {
    int v5 = *a1;
    if ((v5 - 58) < 0xFFFFFFF6) {
      break;
    }
    ++a1;
    v15[v4] = v5 - 48;
    if (v4-- == 0) {
      break;
    }
  }
  while (a1 != a2);
  int v7 = v4 + 1;
  uint64_t v8 = (v4 + 1) << 32;
  int v9 = v15[v7];
  if (v7 <= 2)
  {
    uint64_t v10 = v7;
    uint64_t v11 = &dword_23437115C;
    do
    {
      int v12 = *v11++;
      v9 += v12 * v15[++v10];
    }
    while (v10 != 3);
  }
  *a3 = v9;
  unint64_t v13 = v16 * (unint64_t)*(unsigned int *)((char *)&std::__itoa::__pow10_32 + ((0x400000000 - v8) >> 30));
  *a4 = v13;
  return &a1[-((v13 & 0xFFFFFFFF00000000) != 0)];
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(uint64_t a1, char *a2, uint64_t a3, unsigned int *a4, char a5, uint64_t a6)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*(_WORD *)(result + 22) & 0x20) != 0)
    {
      unsigned int v14 = *(_DWORD *)result;
      goto LABEL_14;
    }
    if ((*(_WORD *)(result + 22) & 0x400) == 0 || !*(unsigned char *)(a1 + 232)) {
      goto LABEL_42;
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      int v12 = (unsigned __int8 *)result;
    }
    else {
      int v12 = *(unsigned __int8 **)(result + 8);
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      unsigned int v13 = 21 - *(char *)(result + 21);
    }
    else {
      unsigned int v13 = *(_DWORD *)result;
    }
    unsigned int v16 = &v12[v13];
    if (v13) {
      BOOL v17 = *v12 == 45;
    }
    else {
      BOOL v17 = 0;
    }
    BOOL v18 = v17;
    if (v13 == (unint64_t)v17) {
      goto LABEL_37;
    }
    unint64_t v19 = v13 - (unint64_t)v17;
    char v20 = &v12[v17];
    while (*v20 == 48)
    {
      ++v20;
      if (!--v19) {
        goto LABEL_37;
      }
    }
    if (!v19)
    {
LABEL_37:
      char v20 = &v12[v13];
    }
    else if (*v20 - 48 < 0xA)
    {
      char v20 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v20, v16, buf, &v22);
      if (v20 != v16 && *v20 - 48 <= 9 || __CFADD__(*(_DWORD *)buf, v22)) {
        goto LABEL_42;
      }
      unsigned int v14 = *(_DWORD *)buf + v22;
      if (!v18)
      {
        if ((v14 & 0x80000000) != 0) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }
      if (v14 > 0x80000000) {
        goto LABEL_42;
      }
LABEL_40:
      unsigned int v14 = -v14;
LABEL_41:
      if (v16 != v20) {
        goto LABEL_42;
      }
      unsigned int v21 = *re::foundationSerializationLogObjects((re *)v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        int v24 = v12;
        _os_log_impl(&dword_233120000, v21, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
      }
LABEL_14:
      if (a5)
      {
        if ((a5 & 2) != 0) {
          return 1;
        }
      }
      else
      {
        *a4 = v14;
        if ((a5 & 2) != 0) {
          return 1;
        }
      }
      uint64_t v15 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
      ++*(void *)(v15 - 16);
      return 1;
    }
    if (v20 == &v12[v17])
    {
LABEL_42:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    unsigned int v14 = 0;
    if (!v17) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  return result;
}

unsigned __int8 *std::__itoa::__traits<unsigned int>::__read[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v4 = 9;
  do
  {
    int v5 = *a1;
    if ((v5 - 58) < 0xFFFFFFF6) {
      break;
    }
    ++a1;
    v15[v4] = v5 - 48;
    if (v4-- == 0) {
      break;
    }
  }
  while (a1 != a2);
  int v7 = v4 + 1;
  uint64_t v8 = (v4 + 1) << 32;
  int v9 = v15[v7];
  if (v7 <= 7)
  {
    uint64_t v10 = v7;
    uint64_t v11 = &dword_23437115C;
    do
    {
      int v12 = *v11++;
      v9 += v12 * v15[++v10];
    }
    while (v10 != 8);
  }
  *a3 = v9;
  unint64_t v13 = v15[9] * (unint64_t)*(unsigned int *)((char *)&std::__itoa::__pow10_32 + ((0x900000000 - v8) >> 30));
  *a4 = v13;
  return &a1[-((v13 & 0xFFFFFFFF00000000) != 0)];
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(uint64_t a1, char *a2, uint64_t a3, unint64_t *a4, char a5, uint64_t a6)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*(_WORD *)(result + 22) & 0x80) != 0)
    {
      unint64_t v14 = *(void *)result;
      goto LABEL_14;
    }
    if ((*(_WORD *)(result + 22) & 0x400) == 0 || !*(unsigned char *)(a1 + 232)) {
      goto LABEL_42;
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      int v12 = (unsigned __int8 *)result;
    }
    else {
      int v12 = *(unsigned __int8 **)(result + 8);
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      unsigned int v13 = 21 - *(char *)(result + 21);
    }
    else {
      unsigned int v13 = *(_DWORD *)result;
    }
    uint64_t v16 = &v12[v13];
    if (v13) {
      BOOL v17 = *v12 == 45;
    }
    else {
      BOOL v17 = 0;
    }
    BOOL v18 = v17;
    if (v13 == (unint64_t)v17) {
      goto LABEL_37;
    }
    unint64_t v19 = v13 - (unint64_t)v17;
    char v20 = &v12[v17];
    while (*v20 == 48)
    {
      ++v20;
      if (!--v19) {
        goto LABEL_37;
      }
    }
    if (!v19)
    {
LABEL_37:
      char v20 = &v12[v13];
    }
    else if (*v20 - 48 < 0xA)
    {
      char v20 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v20, v16, buf, &v22);
      if (v20 != v16 && *v20 - 48 <= 9 || __CFADD__(*(void *)buf, v22)) {
        goto LABEL_42;
      }
      unint64_t v14 = *(void *)buf + v22;
      if (!v18)
      {
        if ((v14 & 0x8000000000000000) != 0) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }
      if (v14 > 0x8000000000000000) {
        goto LABEL_42;
      }
LABEL_40:
      unint64_t v14 = -(uint64_t)v14;
LABEL_41:
      if (v16 != v20) {
        goto LABEL_42;
      }
      unsigned int v21 = *re::foundationSerializationLogObjects((re *)v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl(&dword_233120000, v21, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
      }
LABEL_14:
      if (a5)
      {
        if ((a5 & 2) != 0) {
          return 1;
        }
      }
      else
      {
        *a4 = v14;
        if ((a5 & 2) != 0) {
          return 1;
        }
      }
      uint64_t v15 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
      ++*(void *)(v15 - 16);
      return 1;
    }
    if (v20 == &v12[v17])
    {
LABEL_42:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    unint64_t v14 = 0;
    if (!v17) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  return result;
}

unsigned __int8 *std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2, void *a3, void *a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v4 = 19;
  do
  {
    int v5 = *a1;
    if ((v5 - 58) < 0xFFFFFFF6) {
      break;
    }
    ++a1;
    v16[v4] = (v5 - 48);
    if (v4-- == 0) {
      break;
    }
  }
  while (a1 != a2);
  int v7 = v4 + 1;
  uint64_t v8 = (v4 + 1) << 32;
  uint64_t v9 = v16[v7];
  if (v7 <= 17)
  {
    uint64_t v10 = v7;
    uint64_t v11 = &qword_234370FF8;
    do
    {
      uint64_t v12 = *v11++;
      v9 += v12 * v16[++v10];
    }
    while (v10 != 18);
  }
  *a3 = v9;
  unint64_t v13 = *(void *)((char *)&std::__itoa::__pow10_64 + ((0x1300000000 - v8) >> 29));
  BOOL v14 = !is_mul_ok(v17, v13);
  *a4 = v17 * v13;
  return &a1[-v14];
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(uint64_t a1, char *a2, uint64_t a3, unsigned char *a4, char a5, uint64_t a6)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*((_WORD *)result + 11) & 0x40) != 0)
    {
      int v14 = *result;
      if (*result > 0xFF)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorValueOutOfTypeRange((_anonymous_namespace_ *)a1, a2, a6);
        return 0;
      }
LABEL_14:
      if ((a5 & 1) == 0) {
        *a4 = v14;
      }
      if ((a5 & 2) == 0)
      {
        uint64_t v15 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
        ++*(void *)(v15 - 16);
      }
      return (unsigned int *)1;
    }
    if ((*((_WORD *)result + 11) & 0x400) == 0 || !*(unsigned char *)(a1 + 232)) {
      goto LABEL_36;
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0) {
      uint64_t v12 = (unsigned __int8 *)result;
    }
    else {
      uint64_t v12 = (unsigned __int8 *)*((void *)result + 1);
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0) {
      LODWORD(v13) = 21 - *((char *)result + 21);
    }
    else {
      LODWORD(v13) = *result;
    }
    uint64_t v16 = &v12[v13];
    if (v13)
    {
      uint64_t v13 = v13;
      unint64_t v17 = v12;
      while (*v17 == 48)
      {
        ++v17;
        if (!--v13) {
          goto LABEL_32;
        }
      }
      if (*v17 - 48 < 0xA)
      {
        unint64_t v17 = std::__itoa::__traits<unsigned char>::__read[abi:nn180100](v17, v16, buf, &v19);
        if (v17 != v16 && *v17 - 48 <= 9 || *(_DWORD *)buf > 0xFFu || 255 - *(_DWORD *)buf < v19) {
          goto LABEL_36;
        }
        LOBYTE(v14) = v19 + buf[0];
LABEL_35:
        if (v16 != v17) {
          goto LABEL_36;
        }
        uint64_t v18 = *re::foundationSerializationLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          unsigned int v21 = v12;
          _os_log_impl(&dword_233120000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
        }
        goto LABEL_14;
      }
    }
    else
    {
LABEL_32:
      unint64_t v17 = v16;
    }
    if (v17 == v12)
    {
LABEL_36:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    LOBYTE(v14) = 0;
    goto LABEL_35;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, char a5, uint64_t a6)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*((_WORD *)result + 11) & 0x40) != 0)
    {
      int v14 = *result;
      if (HIWORD(*result))
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorValueOutOfTypeRange((_anonymous_namespace_ *)a1, a2, a6);
        return 0;
      }
LABEL_14:
      if ((a5 & 1) == 0) {
        *a4 = v14;
      }
      if ((a5 & 2) == 0)
      {
        uint64_t v15 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
        ++*(void *)(v15 - 16);
      }
      return (unsigned int *)1;
    }
    if ((*((_WORD *)result + 11) & 0x400) == 0 || !*(unsigned char *)(a1 + 232)) {
      goto LABEL_36;
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0) {
      uint64_t v12 = (unsigned __int8 *)result;
    }
    else {
      uint64_t v12 = (unsigned __int8 *)*((void *)result + 1);
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0) {
      LODWORD(v13) = 21 - *((char *)result + 21);
    }
    else {
      LODWORD(v13) = *result;
    }
    uint64_t v16 = &v12[v13];
    if (v13)
    {
      uint64_t v13 = v13;
      unint64_t v17 = v12;
      while (*v17 == 48)
      {
        ++v17;
        if (!--v13) {
          goto LABEL_32;
        }
      }
      if (*v17 - 48 < 0xA)
      {
        unint64_t v17 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v17, v16, buf, &v19);
        if (v17 != v16 && *v17 - 48 <= 9 || *(_WORD *)&buf[2] || 0xFFFF - *(_DWORD *)buf < v19) {
          goto LABEL_36;
        }
        LOWORD(v14) = v19 + *(_WORD *)buf;
LABEL_35:
        if (v16 != v17) {
          goto LABEL_36;
        }
        uint64_t v18 = *re::foundationSerializationLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          unsigned int v21 = v12;
          _os_log_impl(&dword_233120000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
        }
        goto LABEL_14;
      }
    }
    else
    {
LABEL_32:
      unint64_t v17 = v16;
    }
    if (v17 == v12)
    {
LABEL_36:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    LOWORD(v14) = 0;
    goto LABEL_35;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(uint64_t a1, char *a2, uint64_t a3, _DWORD *a4, char a5, uint64_t a6)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*(_WORD *)(result + 22) & 0x40) != 0)
    {
      int v14 = *(_DWORD *)result;
      goto LABEL_14;
    }
    if ((*(_WORD *)(result + 22) & 0x400) == 0 || !*(unsigned char *)(a1 + 232)) {
      goto LABEL_35;
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      uint64_t v12 = (unsigned __int8 *)result;
    }
    else {
      uint64_t v12 = *(unsigned __int8 **)(result + 8);
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      LODWORD(v13) = 21 - *(char *)(result + 21);
    }
    else {
      LODWORD(v13) = *(_DWORD *)result;
    }
    uint64_t v16 = &v12[v13];
    if (v13)
    {
      uint64_t v13 = v13;
      unint64_t v17 = v12;
      while (*v17 == 48)
      {
        ++v17;
        if (!--v13) {
          goto LABEL_31;
        }
      }
      if (*v17 - 48 < 0xA)
      {
        unint64_t v17 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v17, v16, buf, &v19);
        if (v17 != v16 && *v17 - 48 <= 9 || __CFADD__(*(_DWORD *)buf, v19)) {
          goto LABEL_35;
        }
        int v14 = *(_DWORD *)buf + v19;
LABEL_34:
        if (v16 != v17) {
          goto LABEL_35;
        }
        uint64_t v18 = *re::foundationSerializationLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          unsigned int v21 = v12;
          _os_log_impl(&dword_233120000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
        }
LABEL_14:
        if (a5)
        {
          if ((a5 & 2) != 0) {
            return 1;
          }
        }
        else
        {
          *a4 = v14;
          if ((a5 & 2) != 0) {
            return 1;
          }
        }
        uint64_t v15 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
        ++*(void *)(v15 - 16);
        return 1;
      }
    }
    else
    {
LABEL_31:
      unint64_t v17 = v16;
    }
    if (v17 == v12)
    {
LABEL_35:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    int v14 = 0;
    goto LABEL_34;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(uint64_t a1, char *a2, uint64_t a3, void *a4, char a5, uint64_t a6)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    if ((*(_WORD *)(result + 22) & 0x100) != 0)
    {
      uint64_t v14 = *(void *)result;
      goto LABEL_14;
    }
    if ((*(_WORD *)(result + 22) & 0x400) == 0 || !*(unsigned char *)(a1 + 232)) {
      goto LABEL_35;
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      uint64_t v12 = (unsigned __int8 *)result;
    }
    else {
      uint64_t v12 = *(unsigned __int8 **)(result + 8);
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      LODWORD(v13) = 21 - *(char *)(result + 21);
    }
    else {
      LODWORD(v13) = *(_DWORD *)result;
    }
    uint64_t v16 = &v12[v13];
    if (v13)
    {
      uint64_t v13 = v13;
      unint64_t v17 = v12;
      while (*v17 == 48)
      {
        ++v17;
        if (!--v13) {
          goto LABEL_31;
        }
      }
      if (*v17 - 48 < 0xA)
      {
        unint64_t v17 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v17, v16, buf, &v19);
        if (v17 != v16 && *v17 - 48 <= 9 || __CFADD__(*(void *)buf, v19)) {
          goto LABEL_35;
        }
        uint64_t v14 = *(void *)buf + v19;
LABEL_34:
        if (v16 != v17) {
          goto LABEL_35;
        }
        uint64_t v18 = *re::foundationSerializationLogObjects((re *)v17);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)&uint8_t buf[4] = v12;
          _os_log_impl(&dword_233120000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", buf, 0xCu);
        }
LABEL_14:
        if (a5)
        {
          if ((a5 & 2) != 0) {
            return 1;
          }
        }
        else
        {
          *a4 = v14;
          if ((a5 & 2) != 0) {
            return 1;
          }
        }
        uint64_t v15 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
        ++*(void *)(v15 - 16);
        return 1;
      }
    }
    else
    {
LABEL_31:
      unint64_t v17 = v16;
    }
    if (v17 == v12)
    {
LABEL_35:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    uint64_t v14 = 0;
    goto LABEL_34;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(uint64_t a1, char *a2, uint64_t a3, float *a4, char a5, uint64_t a6)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    __int16 v13 = *(_WORD *)(result + 22);
    if ((v13 & 0x400) == 0)
    {
      if ((v13 & 0x10) != 0)
      {
        float Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble((_WORD *)result, v12);
        if (a5) {
          goto LABEL_8;
        }
LABEL_37:
        *a4 = Double;
        if ((a5 & 2) != 0) {
          return 1;
        }
        goto LABEL_9;
      }
LABEL_39:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      uint64_t v16 = (const char *)result;
    }
    else {
      uint64_t v16 = *(const char **)(result + 8);
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      unsigned int v17 = 21 - *(char *)(result + 21);
    }
    else {
      unsigned int v17 = *(_DWORD *)result;
    }
    if (v17 == 9)
    {
      if (strcasecmp(v16, "-Infinity")) {
        goto LABEL_25;
      }
      *(float *)&int v18 = -INFINITY;
    }
    else
    {
      if (v17 != 8)
      {
        if (v17 == 3 && !strcasecmp(v16, "NaN"))
        {
          *(float *)&int v18 = NAN;
          goto LABEL_41;
        }
LABEL_25:
        if (!*(unsigned char *)(a1 + 232)) {
          goto LABEL_39;
        }
        *(void *)unsigned int v23 = 0;
        float v20 = strtof(v16, (char **)v23);
        BOOL v21 = *(const char **)v23 != &v16[v17] || v20 == INFINITY;
        float Double = v21 ? INFINITY : v20;
        if (Double == INFINITY) {
          goto LABEL_39;
        }
        uint64_t v22 = *re::foundationSerializationLogObjects(v19);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unsigned int v23 = 136315138;
          *(void *)&v23[4] = v16;
          _os_log_impl(&dword_233120000, v22, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", v23, 0xCu);
          if ((a5 & 1) == 0) {
            goto LABEL_37;
          }
        }
        else if ((a5 & 1) == 0)
        {
          goto LABEL_37;
        }
LABEL_8:
        if ((a5 & 2) != 0) {
          return 1;
        }
LABEL_9:
        uint64_t v15 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
        ++*(void *)(v15 - 16);
        return 1;
      }
      if (strcasecmp(v16, "Infinity")) {
        goto LABEL_25;
      }
      *(float *)&int v18 = INFINITY;
    }
LABEL_41:
    float Double = *(float *)&v18;
    if ((a5 & 1) == 0) {
      goto LABEL_37;
    }
    goto LABEL_8;
  }
  return result;
}

double rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(_WORD *a1, double a2)
{
  __int16 v2 = a1[11];
  if ((v2 & 0x200) != 0) {
    return *(double *)a1;
  }
  if ((v2 & 0x20) != 0) {
    return (double)*(int *)a1;
  }
  if ((v2 & 0x40) != 0)
  {
    LODWORD(a2) = *(_DWORD *)a1;
    return (double)*(unint64_t *)&a2;
  }
  else
  {
    uint64_t v3 = *(void *)a1;
    if ((v2 & 0x80) != 0) {
      return (double)v3;
    }
    else {
      return (double)(unint64_t)v3;
    }
  }
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(uint64_t a1, char *a2, uint64_t a3, double *a4, char a5, uint64_t a6)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t result = (uint64_t)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, a2, 0);
  if (result)
  {
    __int16 v13 = *(_WORD *)(result + 22);
    if ((v13 & 0x400) == 0)
    {
      if ((v13 & 0x10) != 0)
      {
        double Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble((_WORD *)result, v12);
        if (a5) {
          goto LABEL_8;
        }
LABEL_37:
        *a4 = Double;
        if ((a5 & 2) != 0) {
          return 1;
        }
        goto LABEL_9;
      }
LABEL_39:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, a2, a6);
      return 0;
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      uint64_t v16 = (const char *)result;
    }
    else {
      uint64_t v16 = *(const char **)(result + 8);
    }
    if ((*(_WORD *)(result + 22) & 0x1000) != 0) {
      unsigned int v17 = 21 - *(char *)(result + 21);
    }
    else {
      unsigned int v17 = *(_DWORD *)result;
    }
    if (v17 == 9)
    {
      if (strcasecmp(v16, "-Infinity")) {
        goto LABEL_25;
      }
      *(double *)&unint64_t v18 = -INFINITY;
    }
    else
    {
      if (v17 != 8)
      {
        if (v17 == 3 && !strcasecmp(v16, "NaN"))
        {
          *(double *)&unint64_t v18 = NAN;
          goto LABEL_41;
        }
LABEL_25:
        if (!*(unsigned char *)(a1 + 232)) {
          goto LABEL_39;
        }
        *(void *)unsigned int v23 = 0;
        float v20 = strtod(v16, (char **)v23);
        BOOL v21 = *(const char **)v23 != &v16[v17] || v20 == INFINITY;
        double Double = v21 ? INFINITY : v20;
        if (Double == INFINITY) {
          goto LABEL_39;
        }
        uint64_t v22 = *re::foundationSerializationLogObjects(v19);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unsigned int v23 = 136315138;
          *(void *)&v23[4] = v16;
          _os_log_impl(&dword_233120000, v22, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", v23, 0xCu);
          if ((a5 & 1) == 0) {
            goto LABEL_37;
          }
        }
        else if ((a5 & 1) == 0)
        {
          goto LABEL_37;
        }
LABEL_8:
        if ((a5 & 2) != 0) {
          return 1;
        }
LABEL_9:
        uint64_t v15 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
        ++*(void *)(v15 - 16);
        return 1;
      }
      if (strcasecmp(v16, "Infinity")) {
        goto LABEL_25;
      }
      *(double *)&unint64_t v18 = INFINITY;
    }
LABEL_41:
    double Double = *(double *)&v18;
    if ((a5 & 1) == 0) {
      goto LABEL_37;
    }
    goto LABEL_8;
  }
  return result;
}

BOOL re::internal::serializeEnumAsString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, void *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_10;
  }
  if (*(void *)a5 != *(void *)a6)
  {
    BOOL v14 = re::areSameTranslatedVersion(a5, a6, a3);
    goto LABEL_11;
  }
  uint64_t v15 = **((void **)a5 + 2);
  uint64_t v16 = **((void **)a6 + 2);
  if ((unsigned __int16)v15 == (unsigned __int16)v16
    && ((v18 = WORD1(v15) == WORD1(v16), uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000, v18) ? (v18 = v17 == 0) : (v18 = 0), v18))
  {
LABEL_10:
    BOOL v14 = 1;
  }
  else
  {
    BOOL v14 = 0;
  }
LABEL_11:
  if (!a7)
  {
    unint64_t v49 = 0;
    if (!re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v49, 0))return 0; {
    if (!v49)
    }
    {
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to read enum constant. String is empty.", v21, v22, v23, v24, v25, v47);
      return 0;
    }
    if (v49 >= 0x401)
    {
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to read enum constant. String is too long. Length: %zu", v21, v22, v23, v24, v25, v49);
      return 0;
    }
    uint64_t v26 = (char *)(*(uint64_t (**)(void, unint64_t, void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56), v49 + 1, 0);
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v26, 0);
    v26[v49] = 0;
    if (*(unsigned char *)(a1 + 64))
    {
LABEL_24:
      (*(void (**)(void, char *))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v26);
      return 0;
    }
    uint64_t v28 = *v26;
    if (*v26)
    {
      char v29 = v26[1];
      if (v29)
      {
        uint64_t v30 = (unsigned __int8 *)(v26 + 2);
        do
        {
          uint64_t v28 = 31 * v28 + v29;
          int v31 = *v30++;
          char v29 = v31;
        }
        while (v31);
      }
    }
    *(void *)buf = 2 * v28;
    *(void *)&buf[8] = v26;
    unsigned int EnumConstantIndex = re::internal::getEnumConstantIndex(a6, (const re::TypeInfo *)buf, v27);
    re::StringID::destroyString((re::StringID *)buf);
    if ((EnumConstantIndex & 0x80000000) != 0)
    {
      uint64_t v37 = *re::foundationSerializationLogObjects(v33);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
      {
        uint64_t v38 = re::TypeInfo::name(a6)[1];
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = v26;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v38;
        _os_log_impl(&dword_233120000, v37, OS_LOG_TYPE_INFO, "String \"%s\" is not a valid enum constant of type \"%s\" - skipping.", buf, 0x16u);
      }
      uint64_t v39 = 0;
    }
    else if (v14)
    {
      *(void *)buf = re::TypeInfo::enumConstants(a5);
      *(void *)&buf[8] = v34;
      unint64_t v35 = EnumConstantIndex - v34;
      if (EnumConstantIndex >= v34)
      {
        v48[0] = re::TypeInfo::renamedEnumConstants(a5);
        v48[1] = v46;
        uint64_t v36 = re::Slice<re::EnumConstant>::operator[](v48, v35);
      }
      else
      {
        uint64_t v36 = re::Slice<re::EnumConstant>::operator[](buf, EnumConstantIndex);
      }
      uint64_t v39 = (const void *)v36;
    }
    else
    {
      uint64_t v40 = *(re::internal::TypeTranslationTable **)(*(void *)a6 + 856);
      if (!v40
        || (uint64_t v39 = (const void *)re::internal::TypeTranslationTable::translateSerializedEnum(v40, a6, EnumConstantIndex, a5)) == 0)
      {
        re::TypeInfo::name(a5);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Serialized enum constant \"%s\" does not exist in runtime type \"%s\".", v41, v42, v43, v44, v45, (char)v26);
        goto LABEL_24;
      }
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    (*(void (**)(void, char *))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v26);
    if (v39) {
      memcpy(a4, v39, *(unsigned int *)(*((void *)a5 + 2) + 8));
    }
    return *(unsigned char *)(a1 + 64) == 0;
  }
  *(void *)buf = 0;
  unsigned int v19 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)buf, 0);
  BOOL result = 0;
  if (v19)
  {
    if (*(void *)buf) {
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(_anonymous_namespace_ *a1, char *a2, uint64_t a3, uint64_t *a4, int a5)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)a1 + 40)) {
    return 0;
  }
  BOOL result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
  if (result)
  {
    uint64_t v11 = result;
    __int16 v12 = *((_WORD *)result + 11);
    if ((v12 & 0x400) != 0)
    {
      if ((*((_WORD *)result + 11) & 0x1000) != 0) {
        LODWORD(v15) = 21 - *((char *)result + 21);
      }
      else {
        LODWORD(v15) = *result;
      }
      uint64_t v15 = v15;
    }
    else if ((v12 & 0x10) != 0 {
           && *((unsigned char *)a1 + 232)
    }
           && (Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(result, v10), (int v14 = snprintf(__str, 0x40uLL, "%g", Double)) != 0))
    {
      uint64_t v15 = v14;
    }
    else
    {
      if (!*((unsigned char *)a1 + 233) || (int v16 = *((unsigned __int16 *)v11 + 11), (v16 & 8) == 0))
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType(a1, a2, (uint64_t)"string");
        return 0;
      }
      BOOL v17 = v16 == 10;
      uint64_t v15 = 4;
      if (!v17) {
        uint64_t v15 = 5;
      }
    }
    *a4 = v15;
    LOBYTE(v18) = 8;
    DWORD1(v18) = a5;
    *((void *)&v18 + 1) = a2;
    uint64_t v19 = 0;
    uint64_t v20 = v15;
    uint64_t v21 = 0;
    uint64_t v22 = v11;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v18);
    return (unsigned int *)1;
  }
  return result;
}

void re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(uint64_t a1, char *a2, char a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 40)) {
    return;
  }
  uint64_t v6 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
  size_t v7 = *(unsigned int *)(v6 - 24);
  uint64_t v8 = *(char **)(v6 - 40);
  JSONValue = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue((_anonymous_namespace_ *)a1, v8, 0);
  if (JSONValue)
  {
    uint64_t v11 = JSONValue;
    int v12 = *((unsigned __int16 *)JSONValue + 11);
    if ((v12 & 0x400) != 0)
    {
      if ((a3 & 1) == 0)
      {
        if ((v12 & 0x1000) != 0) {
          uint64_t v20 = (const char *)JSONValue;
        }
        else {
          uint64_t v20 = (const char *)*((void *)JSONValue + 1);
        }
        strncpy(a2, v20, v7);
      }
      goto LABEL_38;
    }
    if (*(unsigned char *)(a1 + 232))
    {
      if ((a3 & 1) == 0 && (v12 & 0x10) != 0)
      {
        double Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(JSONValue, v10);
        int v14 = snprintf(__str, 0x40uLL, "%g", Double);
        if (v14 >= v7) {
          size_t v15 = v7;
        }
        else {
          size_t v15 = v14;
        }
        int v16 = (re *)memcpy(a2, __str, v15);
        BOOL v17 = *re::foundationSerializationLogObjects(v16);
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_38;
        }
        int v25 = 136315138;
        uint64_t v26 = __str;
        long long v18 = "Reading JSON number as string \"%s\" in Number/String Compatibility Mode";
        uint64_t v19 = (char *)&v25;
        goto LABEL_33;
      }
      if ((v12 & 0x10) != 0) {
        goto LABEL_38;
      }
    }
    if (*(unsigned char *)(a1 + 233))
    {
      if ((a3 & 1) == 0 && (v12 & 8) != 0)
      {
        if (v12 == 10) {
          uint64_t v21 = "true";
        }
        else {
          uint64_t v21 = "false";
        }
        uint64_t v22 = strncpy(a2, v21, v7);
        BOOL v17 = *re::foundationSerializationLogObjects((re *)v22);
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_38;
        }
        if (*((_WORD *)v11 + 11) == 10) {
          uint64_t v23 = "true";
        }
        else {
          uint64_t v23 = "false";
        }
        *(_DWORD *)__str = 136315138;
        uint64_t v28 = v23;
        long long v18 = "Reading JSON BOOL as string \"%s\" in Bool/String Compatibility Mode";
        uint64_t v19 = __str;
LABEL_33:
        _os_log_impl(&dword_233120000, v17, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)v19, 0xCu);
        goto LABEL_38;
      }
      if ((v12 & 8) != 0)
      {
LABEL_38:
        if ((a3 & 2) == 0)
        {
          uint64_t v24 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
          *(void *)(v24 - 16) += v7;
        }
        return;
      }
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, v8, (uint64_t)"string");
  }
  else
  {
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorKeyNotFound((_anonymous_namespace_ *)a1, v8);
  }
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorKeyNotFound(_anonymous_namespace_ *a1, const char *a2)
{
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v5);
  if (v6) {
    uint64_t v3 = *(unsigned char **)&v7[7];
  }
  else {
    uint64_t v3 = v7;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Key not found.", (re::DynamicString *)v8, v3);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v8);
  if (*(void *)&v8[0])
  {
    if (BYTE8(v8[0])) {
      (*(void (**)(void))(**(void **)&v8[0] + 40))();
    }
    memset(v8, 0, sizeof(v8));
  }
  uint64_t result = v5;
  if (v5)
  {
    if (v6) {
      return (*(uint64_t (**)(void))(*(void *)v5 + 40))();
    }
  }
  return result;
}

double re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(_anonymous_namespace_ *a1, char *a2, uint64_t a3, unsigned char *a4, int a5)
{
  if (!*((unsigned char *)a1 + 40))
  {
    JSONValue = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
    if (JSONValue) {
      BOOL v10 = *((_WORD *)JSONValue + 11) != 0;
    }
    else {
      BOOL v10 = 0;
    }
    *a4 = v10;
    LOBYTE(v12) = 3;
    DWORD1(v12) = a5;
    *((void *)&v12 + 1) = a2;
    uint64_t v13 = 0;
    BOOL v14 = v10;
    uint64_t v15 = 0;
    int v16 = JSONValue;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v12);
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(_anonymous_namespace_ *a1, char *a2, uint64_t a3, void *a4, int a5)
{
  if (*((unsigned char *)a1 + 40)) {
    return 0;
  }
  double result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
  if (result)
  {
    if (*((_WORD *)result + 11) == 4)
    {
      uint64_t v10 = *result;
      *a4 = v10;
      LOBYTE(v11) = 5;
      DWORD1(v11) = a5;
      *((void *)&v11 + 1) = a2;
      uint64_t v12 = 0;
      uint64_t v13 = v10;
      uint64_t v14 = 0;
      uint64_t v15 = result;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v11);
      return (unsigned int *)1;
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType(a1, a2, (uint64_t)"array");
    return 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v51),
        re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52),
        v49[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v49))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v52);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v49);
  if (!v19)
  {
    uint64_t v44 = re::TypeInfo::name((re::TypeInfo *)v49)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v39, v40, v41, v42, v43, v44);
    return 0;
  }
  uint64_t v20 = (void (*)(uint64_t, uint64_t, void, uint64_t, unsigned char *, unsigned char *, void))v19;
  uint64_t v21 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v47 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v51, (uint64_t)v46);
  v21(a4, &v51, v18);
  unsigned int v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  BOOL result = 0;
  if (v27)
  {
    uint64_t v29 = *(unsigned int **)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      uint64_t v30 = *((void *)v29 + 1);
      while (1)
      {
        if ((*(_WORD *)(v30 + 22) & 0x1000) != 0) {
          uint64_t v31 = v30;
        }
        else {
          uint64_t v31 = *(void *)(v30 + 8);
        }
        if ((*(_WORD *)(v30 + 22) & 0x1000) != 0) {
          unsigned int v32 = 21 - *(char *)(v30 + 21);
        }
        else {
          unsigned int v32 = *(_DWORD *)v30;
        }
        uint64_t v45 = 0;
        if (!v32) {
          goto LABEL_42;
        }
        uint64_t v33 = 0;
        unint64_t v34 = (unsigned __int8 *)(v31 + v32);
        while (*(unsigned char *)(v31 + v33) == 48)
        {
          if (v32 == ++v33) {
            goto LABEL_42;
          }
        }
        if (v32 == v33) {
          goto LABEL_42;
        }
        unint64_t v35 = (unsigned __int8 *)(v31 + v33);
        if (*(unsigned __int8 *)(v31 + v33) - 48 > 9) {
          goto LABEL_41;
        }
        unint64_t v35 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v35, v34, &v51, &v50);
        if (v35 == v34) {
          break;
        }
        if (*v35 - 48 > 9)
        {
          uint64_t v37 = v50;
          uint64_t v36 = v51;
          if (!__CFADD__(v51, v50)) {
            goto LABEL_40;
          }
        }
        while (*v35 - 48 <= 9)
        {
          if (++v35 == v34)
          {
            unint64_t v35 = v34;
            break;
          }
        }
LABEL_41:
        if (v34 != v35)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, v31);
          return 0;
        }
LABEL_42:
        uint64_t v38 = (*(uint64_t (**)(uint64_t, unsigned char *, void, uint64_t *))(v47 + 104))(a4, v46, *(void *)(a1 + 48), &v45);
        v20(a1, v31, 0, v38, v49, v48, 0);
        v30 += 48;
        if (v30 == *((void *)v29 + 1) + 48 * *v29) {
          goto LABEL_43;
        }
      }
      uint64_t v37 = v50;
      uint64_t v36 = v51;
      if (__CFADD__(v51, v50)) {
        goto LABEL_42;
      }
LABEL_40:
      uint64_t v45 = v36 + v37;
      goto LABEL_41;
    }
LABEL_43:
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v51),
        re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52),
        v49[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v49))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v52);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v49);
  if (!v19)
  {
    uint64_t v44 = re::TypeInfo::name((re::TypeInfo *)v49)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v39, v40, v41, v42, v43, v44);
    return 0;
  }
  uint64_t v20 = (void (*)(uint64_t, uint64_t, void, uint64_t, unsigned char *, unsigned char *, void))v19;
  uint64_t v21 = *(void (**)(uint64_t, int *, uint64_t))(v47 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v51, (uint64_t)v46);
  v21(a4, &v51, v18);
  unsigned int v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  BOOL result = 0;
  if (v27)
  {
    uint64_t v29 = *(unsigned int **)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      uint64_t v30 = *((void *)v29 + 1);
      while (1)
      {
        if ((*(_WORD *)(v30 + 22) & 0x1000) != 0) {
          uint64_t v31 = v30;
        }
        else {
          uint64_t v31 = *(void *)(v30 + 8);
        }
        if ((*(_WORD *)(v30 + 22) & 0x1000) != 0) {
          unsigned int v32 = 21 - *(char *)(v30 + 21);
        }
        else {
          unsigned int v32 = *(_DWORD *)v30;
        }
        int v45 = 0;
        if (!v32) {
          goto LABEL_42;
        }
        uint64_t v33 = 0;
        unint64_t v34 = (unsigned __int8 *)(v31 + v32);
        while (*(unsigned char *)(v31 + v33) == 48)
        {
          if (v32 == ++v33) {
            goto LABEL_42;
          }
        }
        if (v32 == v33) {
          goto LABEL_42;
        }
        unint64_t v35 = (unsigned __int8 *)(v31 + v33);
        if (*(unsigned __int8 *)(v31 + v33) - 48 > 9) {
          goto LABEL_41;
        }
        unint64_t v35 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v35, v34, &v51, &v50);
        if (v35 == v34) {
          break;
        }
        if (*v35 - 48 > 9)
        {
          int v37 = v50;
          int v36 = v51;
          if (!__CFADD__(v51, v50)) {
            goto LABEL_40;
          }
        }
        while (*v35 - 48 <= 9)
        {
          if (++v35 == v34)
          {
            unint64_t v35 = v34;
            break;
          }
        }
LABEL_41:
        if (v34 != v35)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, v31);
          return 0;
        }
LABEL_42:
        uint64_t v38 = (*(uint64_t (**)(uint64_t, unsigned char *, void, int *))(v47 + 104))(a4, v46, *(void *)(a1 + 48), &v45);
        v20(a1, v31, 0, v38, v49, v48, 0);
        v30 += 48;
        if (v30 == *((void *)v29 + 1) + 48 * *v29) {
          goto LABEL_43;
        }
      }
      int v37 = v50;
      int v36 = v51;
      if (__CFADD__(v51, v50)) {
        goto LABEL_42;
      }
LABEL_40:
      int v45 = v36 + v37;
      goto LABEL_41;
    }
LABEL_43:
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v49),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v50),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v50);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v50);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v47);
  if (!v19)
  {
    uint64_t v42 = re::TypeInfo::name((re::TypeInfo *)v47)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v37, v38, v39, v40, v41, v42);
    return 0;
  }
  uint64_t v20 = (void (*)(uint64_t, uint64_t, void, uint64_t, unsigned char *, unsigned char *, void))v19;
  uint64_t v21 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v45 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v49, (uint64_t)v44);
  v21(a4, &v49, v18);
  unsigned int v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  BOOL result = 0;
  if (v27)
  {
    uint64_t v29 = *(unsigned int **)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      for (uint64_t i = *((void *)v29 + 1); i != *((void *)v29 + 1) + 48 * *v29; i += 48)
      {
        if ((*(_WORD *)(i + 22) & 0x1000) != 0) {
          uint64_t v31 = i;
        }
        else {
          uint64_t v31 = *(void *)(i + 8);
        }
        if ((*(_WORD *)(i + 22) & 0x1000) != 0) {
          unsigned int v32 = 21 - *(char *)(i + 21);
        }
        else {
          unsigned int v32 = *(_DWORD *)i;
        }
        __int16 v43 = 0;
        if (!v32) {
          goto LABEL_42;
        }
        uint64_t v33 = 0;
        unint64_t v34 = (unsigned __int8 *)(v31 + v32);
        while (*(unsigned char *)(v31 + v33) == 48)
        {
          if (v32 == ++v33) {
            goto LABEL_42;
          }
        }
        if (v32 == v33) {
          goto LABEL_42;
        }
        unint64_t v35 = (unsigned __int8 *)(v31 + v33);
        if (*(unsigned __int8 *)(v31 + v33) - 48 <= 9)
        {
          unint64_t v35 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v35, v34, &v49, &v48);
          if (v35 == v34 || *v35 - 48 > 9)
          {
            if (HIWORD(v49) || 0xFFFF - v49 < v48)
            {
              if (v35 != v34) {
                goto LABEL_37;
              }
              goto LABEL_42;
            }
            __int16 v43 = v48 + v49;
          }
          else
          {
LABEL_37:
            while (*v35 - 48 <= 9)
            {
              if (++v35 == v34)
              {
                unint64_t v35 = v34;
                break;
              }
            }
          }
        }
        if (v34 != v35)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, v31);
          return 0;
        }
LABEL_42:
        uint64_t v36 = (*(uint64_t (**)(uint64_t, unsigned char *, void, __int16 *))(v45 + 104))(a4, v44, *(void *)(a1 + 48), &v43);
        v20(a1, v31, 0, v36, v47, v46, 0);
      }
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v49),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v50),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v50);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v49);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v50);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v47);
  if (!v19)
  {
    uint64_t v42 = re::TypeInfo::name((re::TypeInfo *)v47)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v37, v38, v39, v40, v41, v42);
    return 0;
  }
  uint64_t v20 = (void (*)(uint64_t, uint64_t, void, uint64_t, unsigned char *, unsigned char *, void))v19;
  uint64_t v21 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v45 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v49, (uint64_t)v44);
  v21(a4, &v49, v18);
  unsigned int v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  BOOL result = 0;
  if (v27)
  {
    uint64_t v29 = *(unsigned int **)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      for (uint64_t i = *((void *)v29 + 1); i != *((void *)v29 + 1) + 48 * *v29; i += 48)
      {
        if ((*(_WORD *)(i + 22) & 0x1000) != 0) {
          uint64_t v31 = i;
        }
        else {
          uint64_t v31 = *(void *)(i + 8);
        }
        if ((*(_WORD *)(i + 22) & 0x1000) != 0) {
          unsigned int v32 = 21 - *(char *)(i + 21);
        }
        else {
          unsigned int v32 = *(_DWORD *)i;
        }
        char v43 = 0;
        if (!v32) {
          goto LABEL_42;
        }
        uint64_t v33 = 0;
        unint64_t v34 = (unsigned __int8 *)(v31 + v32);
        while (*(unsigned char *)(v31 + v33) == 48)
        {
          if (v32 == ++v33) {
            goto LABEL_42;
          }
        }
        if (v32 == v33) {
          goto LABEL_42;
        }
        unint64_t v35 = (unsigned __int8 *)(v31 + v33);
        if (*(unsigned __int8 *)(v31 + v33) - 48 <= 9)
        {
          unint64_t v35 = std::__itoa::__traits<unsigned char>::__read[abi:nn180100](v35, v34, &v49, &v48);
          if (v35 == v34 || *v35 - 48 > 9)
          {
            if (v49 > 0xFF || 255 - v49 < v48)
            {
              if (v35 != v34) {
                goto LABEL_37;
              }
              goto LABEL_42;
            }
            char v43 = v48 + v49;
          }
          else
          {
LABEL_37:
            while (*v35 - 48 <= 9)
            {
              if (++v35 == v34)
              {
                unint64_t v35 = v34;
                break;
              }
            }
          }
        }
        if (v34 != v35)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, v31);
          return 0;
        }
LABEL_42:
        uint64_t v36 = (*(uint64_t (**)(uint64_t, unsigned char *, void, char *))(v45 + 104))(a4, v44, *(void *)(a1 + 48), &v43);
        v20(a1, v31, 0, v36, v47, v46, 0);
      }
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v56),
        re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v57),
        v54[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v54))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v57);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v57);
  re::TypeInfo::TypeInfo((uint64_t)v51, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v54);
  if (!v19)
  {
    uint64_t v49 = re::TypeInfo::name((re::TypeInfo *)v54)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v44, v45, v46, v47, v48, v49);
    return 0;
  }
  uint64_t v20 = (void (*)(uint64_t, unsigned __int8 *, void, uint64_t, unsigned char *, unsigned char *, void))v19;
  uint64_t v21 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v52 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v56, (uint64_t)v51);
  v21(a4, &v56, v18);
  unsigned int v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  BOOL result = 0;
  if (v27)
  {
    uint64_t v29 = *(unsigned int **)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      uint64_t v30 = *((void *)v29 + 1);
      while (1)
      {
        uint64_t v31 = (*(_WORD *)(v30 + 22) & 0x1000) != 0 ? (unsigned __int8 *)v30 : *(unsigned __int8 **)(v30 + 8);
        unsigned int v32 = (*(_WORD *)(v30 + 22) & 0x1000) != 0 ? 21 - *(char *)(v30 + 21) : *(_DWORD *)v30;
        unint64_t v50 = 0;
        unsigned int v33 = v32 && *v31 == 45;
        uint64_t v34 = v32;
        unint64_t v35 = &v31[v32];
        char v36 = v33;
        uint64_t v37 = &v31[v33];
        if (v34 == v33) {
          break;
        }
        uint64_t v38 = v34 - v33;
        uint64_t v39 = v37;
        while (*v39 == 48)
        {
          ++v39;
          if (!--v38) {
            goto LABEL_42;
          }
        }
        if (!v38) {
          break;
        }
        if (*v39 - 48 >= 0xA) {
          goto LABEL_43;
        }
        uint64_t v39 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v39, v35, &v56, &v55);
        if (v39 == v35)
        {
          uint64_t v41 = v55;
          uint64_t v40 = v56;
          if (__CFADD__(v56, v55))
          {
LABEL_53:
            uint64_t v39 = v35;
            goto LABEL_48;
          }
        }
        else if (*v39 - 48 <= 9 || (v41 = v55, uint64_t v40 = v56, __CFADD__(v56, v55)))
        {
          while (*v39 - 48 <= 9)
          {
            if (++v39 == v35) {
              goto LABEL_53;
            }
          }
          goto LABEL_48;
        }
        unint64_t v42 = v40 + v41;
        if (v36)
        {
          if (v42 <= 0x8000000000000000) {
            goto LABEL_45;
          }
        }
        else if ((v42 & 0x8000000000000000) == 0)
        {
          goto LABEL_46;
        }
LABEL_48:
        if (v35 != v39)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, (char)v31);
          return 0;
        }
        uint64_t v43 = (*(uint64_t (**)(uint64_t, unsigned char *, void, unint64_t *))(v52 + 104))(a4, v51, *(void *)(a1 + 48), &v50);
        v20(a1, v31, 0, v43, v54, v53, 0);
        v30 += 48;
        if (v30 == *((void *)v29 + 1) + 48 * *v29) {
          goto LABEL_62;
        }
      }
LABEL_42:
      uint64_t v39 = v35;
LABEL_43:
      if (v39 != v37)
      {
        unint64_t v42 = 0;
        if (v36) {
LABEL_45:
        }
          unint64_t v42 = -(uint64_t)v42;
LABEL_46:
        unint64_t v50 = v42;
        goto LABEL_48;
      }
      uint64_t v39 = v31;
      goto LABEL_48;
    }
LABEL_62:
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v56),
        re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v57),
        v54[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v54))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(void *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v57);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v57);
  re::TypeInfo::TypeInfo((uint64_t)v51, (uint64_t)a5);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v54);
  if (!v19)
  {
    uint64_t v49 = re::TypeInfo::name((re::TypeInfo *)v54)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v44, v45, v46, v47, v48, v49);
    return 0;
  }
  uint64_t v20 = (void (*)(uint64_t, unsigned __int8 *, void, uint64_t, unsigned char *, unsigned char *, void))v19;
  uint64_t v21 = *(void (**)(uint64_t, int *, uint64_t))(v52 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v56, (uint64_t)v51);
  v21(a4, &v56, v18);
  unsigned int v27 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  BOOL result = 0;
  if (v27)
  {
    uint64_t v29 = *(unsigned int **)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
    if (v29 && *v29)
    {
      uint64_t v30 = *((void *)v29 + 1);
      while (1)
      {
        uint64_t v31 = (*(_WORD *)(v30 + 22) & 0x1000) != 0 ? (unsigned __int8 *)v30 : *(unsigned __int8 **)(v30 + 8);
        unsigned int v32 = (*(_WORD *)(v30 + 22) & 0x1000) != 0 ? 21 - *(char *)(v30 + 21) : *(_DWORD *)v30;
        unsigned int v50 = 0;
        unsigned int v33 = v32 && *v31 == 45;
        uint64_t v34 = v32;
        unint64_t v35 = &v31[v32];
        char v36 = v33;
        uint64_t v37 = &v31[v33];
        if (v34 == v33) {
          break;
        }
        uint64_t v38 = v34 - v33;
        uint64_t v39 = v37;
        while (*v39 == 48)
        {
          ++v39;
          if (!--v38) {
            goto LABEL_42;
          }
        }
        if (!v38) {
          break;
        }
        if (*v39 - 48 >= 0xA) {
          goto LABEL_43;
        }
        uint64_t v39 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v39, v35, &v56, &v55);
        if (v39 == v35)
        {
          int v41 = v55;
          int v40 = v56;
          if (__CFADD__(v56, v55))
          {
LABEL_53:
            uint64_t v39 = v35;
            goto LABEL_48;
          }
        }
        else if (*v39 - 48 <= 9 || (v41 = v55, int v40 = v56, __CFADD__(v56, v55)))
        {
          while (*v39 - 48 <= 9)
          {
            if (++v39 == v35) {
              goto LABEL_53;
            }
          }
          goto LABEL_48;
        }
        unsigned int v42 = v40 + v41;
        if (v36)
        {
          if (v42 <= 0x80000000) {
            goto LABEL_45;
          }
        }
        else if ((v42 & 0x80000000) == 0)
        {
          goto LABEL_46;
        }
LABEL_48:
        if (v35 != v39)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v22, v23, v24, v25, v26, (char)v31);
          return 0;
        }
        uint64_t v43 = (*(uint64_t (**)(uint64_t, unsigned char *, void, unsigned int *))(v52 + 104))(a4, v51, *(void *)(a1 + 48), &v50);
        v20(a1, v31, 0, v43, v54, v53, 0);
        v30 += 48;
        if (v30 == *((void *)v29 + 1) + 48 * *v29) {
          goto LABEL_62;
        }
      }
LABEL_42:
      uint64_t v39 = v35;
LABEL_43:
      if (v39 != v37)
      {
        unsigned int v42 = 0;
        if (v36) {
LABEL_45:
        }
          unsigned int v42 = -v42;
LABEL_46:
        unsigned int v50 = v42;
        goto LABEL_48;
      }
      uint64_t v39 = v31;
      goto LABEL_48;
    }
LABEL_62:
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v55),
        re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56),
        v53[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v53))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_13:
  if (a7) {
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v19 = *(void *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
  re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)a5);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v53);
  if (!v20)
  {
    uint64_t v48 = re::TypeInfo::name((re::TypeInfo *)v53)[1];
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v43, v44, v45, v46, v47, v48);
    return 0;
  }
  uint64_t v21 = (void (*)(uint64_t, unsigned __int8 *, void, uint64_t, unsigned char *, unsigned char *, void))v20;
  uint64_t v22 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v51 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v55, (uint64_t)v50);
  v22(a4, &v55, v19);
  unsigned int v28 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
  BOOL result = 0;
  if (v28)
  {
    uint64_t v29 = *(unsigned int **)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
    if (!v29 || !*v29)
    {
LABEL_62:
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(unsigned char *)(a1 + 64) == 0;
    }
    uint64_t v30 = (unsigned __int8 *)*((void *)v29 + 1);
    while (1)
    {
      if ((*((_WORD *)v30 + 11) & 0x1000) != 0) {
        uint64_t v31 = v30;
      }
      else {
        uint64_t v31 = (unsigned __int8 *)*((void *)v30 + 1);
      }
      if ((*((_WORD *)v30 + 11) & 0x1000) != 0) {
        unsigned int v32 = 21 - (char)v30[21];
      }
      else {
        unsigned int v32 = *(_DWORD *)v30;
      }
      __int16 v49 = 0;
      if (v32) {
        unsigned int v33 = *v31 == 45;
      }
      else {
        unsigned int v33 = 0;
      }
      uint64_t v34 = v32;
      unint64_t v35 = &v31[v32];
      char v36 = v33;
      uint64_t v37 = &v31[v33];
      if (v34 == v33) {
        goto LABEL_44;
      }
      uint64_t v38 = v34 - v33;
      uint64_t v39 = v37;
      while (*v39 == 48)
      {
        ++v39;
        if (!--v38) {
          goto LABEL_44;
        }
      }
      if (!v38)
      {
LABEL_44:
        uint64_t v39 = v35;
LABEL_45:
        if (v39 == v37)
        {
          uint64_t v39 = v31;
          goto LABEL_52;
        }
        __int16 v40 = 0;
        __int16 v41 = 0;
        if (v36)
        {
LABEL_47:
          __int16 v49 = -v40;
          goto LABEL_52;
        }
LABEL_51:
        __int16 v49 = v41;
        goto LABEL_52;
      }
      if (*v39 - 48 >= 0xA) {
        goto LABEL_45;
      }
      uint64_t v39 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v39, v35, &v55, &v54);
      if (v39 != v35 && *v39 - 48 <= 9) {
        goto LABEL_56;
      }
      if (HIWORD(v55) || 0xFFFF - v55 < v54) {
        break;
      }
      __int16 v40 = v54 + v55;
      if ((v36 & 1) == 0)
      {
        if ((((_WORD)v54 + (_WORD)v55) & 0x8000) != 0) {
          goto LABEL_52;
        }
        __int16 v41 = v54 + v55;
        goto LABEL_51;
      }
      if ((unsigned __int16)(v54 + v55) <= 0x8000u) {
        goto LABEL_47;
      }
LABEL_52:
      if (v35 != v39)
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to deserialize dictionary. Could not convert \"%s\" to expected integer type.", v23, v24, v25, v26, v27, (char)v31);
        return 0;
      }
      uint64_t v42 = (*(uint64_t (**)(uint64_t, unsigned char *, void, __int16 *))(v51 + 104))(a4, v50, *(void *)(a1 + 48), &v49);
      v21(a1, v31, 0, v42, v53, v52, 0);
      v30 += 48;
      if (v30 == (unsigned __int8 *)(*((void *)v29 + 1) + 48 * *v29)) {
        goto LABEL_62;
      }
    }
    while (1)
    {
      if (v39 == v35)
      {
        uint64_t v39 = v35;
        goto LABEL_52;
      }
LABEL_56:
      if (*v39 - 48 > 9) {
        goto LABEL_52;
      }
      ++v39;
    }
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, re *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  uint64_t v14 = *(void **)a5;
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v15 = (uint64_t *)*((void *)a6 + 2);
    uint64_t v17 = *v15;
    if ((unsigned __int16)v16 != (unsigned __int16)*v15) {
      goto LABEL_10;
    }
    BOOL v19 = WORD1(v16) == WORD1(v17);
    uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
    BOOL v19 = v19 && v18 == 0;
    if (!v19) {
      goto LABEL_10;
    }
LABEL_14:
    if (!a7)
    {
      uint64_t v23 = *(void *)(a1 + 48);
      uint64_t v22 = *(void *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v46);
      re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)v47);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v46);
      re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)v47);
      re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)a5);
      uint64_t v24 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v45);
      if (!v24)
      {
        char v36 = re::TypeInfo::name((re::TypeInfo *)v45);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v37, v38, v39, v40, v41, v36[1]);
        return 0;
      }
      uint64_t v25 = (void (*)(uint64_t, const char *, void, uint64_t, unsigned char *, unsigned char *, void))v24;
      unsigned int v26 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
      BOOL result = 0;
      if (!v26) {
        return result;
      }
      unsigned int v28 = *(void (**)(uint64_t, const char **, uint64_t))(v43 + 96);
      re::TypeInfo::TypeInfo((uint64_t)&v46, (uint64_t)v42);
      v28(a4, &v46, v23);
      uint64_t v29 = (re::DynamicString *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22 + 32))(v22, 32, 8);
      *((void *)v29 + 2) = 0;
      *((void *)v29 + 3) = 0;
      *(void *)uint64_t v29 = v23;
      *((void *)v29 + 1) = 0;
      re::DynamicString::setCapacity(v29, 0);
      uint64_t v30 = *(unsigned int **)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
      if (v30 && *v30)
      {
        uint64_t v31 = *((void *)v30 + 1);
        do
        {
          if ((*(_WORD *)(v31 + 22) & 0x1000) != 0) {
            unsigned int v32 = (const char *)v31;
          }
          else {
            unsigned int v32 = *(const char **)(v31 + 8);
          }
          size_t v33 = strlen(v32);
          uint64_t v46 = v32;
          v47[0] = v33;
          re::DynamicString::operator=(v29, (uint64_t)&v46);
          uint64_t v34 = (*(uint64_t (**)(uint64_t, unsigned char *, void, re::DynamicString *))(v43 + 104))(a4, v42, *(void *)(a1 + 48), v29);
          v25(a1, v32, 0, v34, v45, v44, 0);
          v31 += 48;
        }
        while (v31 != *((void *)v30 + 1) + 48 * *v30);
      }
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      double v35 = re::DynamicString::deinit(v29);
      (*(void (**)(uint64_t, re::DynamicString *, double))(*(void *)v22 + 40))(v22, v29, v35);
    }
    return *(unsigned char *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_14;
  }
  uint64_t v14 = *(void **)a6;
  uint64_t v15 = (uint64_t *)*((void *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v14, v15[9], &v46);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)v47);
  uint64_t v20 = re::TypeInfo::name((re::TypeInfo *)v45);
  if ((unint64_t)*v20 >> 1 == 0x22C6ED80D0CLL)
  {
    uint64_t v21 = (char *)v20[1];
    if (v21 == "StringID" || !strcmp(v21, "StringID")) {
      goto LABEL_14;
    }
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, re *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  uint64_t v14 = *(void **)a5;
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v15 = (uint64_t *)*((void *)a6 + 2);
    uint64_t v17 = *v15;
    if ((unsigned __int16)v16 != (unsigned __int16)*v15) {
      goto LABEL_10;
    }
    BOOL v19 = WORD1(v16) == WORD1(v17);
    uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
    BOOL v19 = v19 && v18 == 0;
    if (!v19) {
      goto LABEL_10;
    }
LABEL_14:
    if (!a7)
    {
      uint64_t v22 = *(void *)(a1 + 48);
      re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v51);
      re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)v52);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v51);
      re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)a5);
      uint64_t v23 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v50);
      if (!v23)
      {
        uint64_t v37 = re::TypeInfo::name((re::TypeInfo *)v50);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v38, v39, v40, v41, v42, v37[1]);
        return 0;
      }
      uint64_t v24 = (uint64_t (*)(uint64_t, const char *, void, uint64_t, unsigned char *, unsigned char *, void))v23;
      unsigned int v25 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, 0);
      BOOL result = 0;
      if (!v25) {
        return result;
      }
      uint64_t v27 = *(uint64_t (**)(uint64_t, unint64_t *, uint64_t))(v48 + 96);
      re::TypeInfo::TypeInfo((uint64_t)&v51, (uint64_t)v47);
      unsigned int v28 = (_anonymous_namespace_ *)v27(a4, &v51, v22);
      uint64_t v45 = 0;
      uint64_t v46 = "";
      uint64_t v29 = *(unsigned int **)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
      if (v29 && *v29)
      {
        uint64_t v30 = *((void *)v29 + 1);
        do
        {
          if ((*(_WORD *)(v30 + 22) & 0x1000) != 0) {
            uint64_t v31 = (const char *)v30;
          }
          else {
            uint64_t v31 = *(const char **)(v30 + 8);
          }
          uint64_t v43 = 0;
          uint64_t v44 = "";
          uint64_t v32 = v43;
          size_t v33 = v44;
          uint64_t v43 = 0;
          uint64_t v44 = "";
          char v34 = v45;
          double v35 = v46;
          uint64_t v45 = v32;
          uint64_t v46 = v33;
          unint64_t v51 = v32 & 0xFFFFFFFFFFFFFFFELL | v34 & 1;
          v52[0] = v35;
          re::StringID::destroyString((re::StringID *)&v51);
          re::StringID::destroyString((re::StringID *)&v43);
          uint64_t v36 = (*(uint64_t (**)(uint64_t, unsigned char *, void, uint64_t *))(v48 + 104))(a4, v47, *(void *)(a1 + 48), &v45);
          unsigned int v28 = (_anonymous_namespace_ *)v24(a1, v31, 0, v36, v50, v49, 0);
          v30 += 48;
        }
        while (v30 != *((void *)v29 + 1) + 48 * *v29);
      }
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
      re::StringID::destroyString((re::StringID *)&v45);
    }
    return *(unsigned char *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_14;
  }
  uint64_t v14 = *(void **)a6;
  uint64_t v15 = (uint64_t *)*((void *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v14, v15[9], &v51);
  re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)v52);
  uint64_t v20 = re::TypeInfo::name((re::TypeInfo *)v50);
  if ((unint64_t)*v20 >> 1 == 0x134375A94D9F7110)
  {
    uint64_t v21 = (char *)v20[1];
    if (v21 == "DynamicString" || !strcmp(v21, "DynamicString")) {
      goto LABEL_14;
    }
  }
  re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
  return 0;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(_anonymous_namespace_ *a1, char *a2, uint64_t a3, void *a4, int a5)
{
  if (*((unsigned char *)a1 + 40)) {
    return 0;
  }
  BOOL result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
  if (result)
  {
    if (*((_WORD *)result + 11) == 4)
    {
      uint64_t v10 = *result;
      *a4 = v10;
      LOBYTE(v11) = 6;
      DWORD1(v11) = a5;
      *((void *)&v11 + 1) = a2;
      uint64_t v12 = 0;
      uint64_t v13 = v10;
      uint64_t v14 = 0;
      uint64_t v15 = result;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v11);
      return (unsigned int *)1;
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType(a1, a2, (uint64_t)"dictionary");
    return 0;
  }
  return result;
}

void re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 40)) {
    return;
  }
  uint64_t v3 = *(void *)(a1 + 128);
  uint64_t v4 = *(void *)(a1 + 112) - 1;
  uint64_t v5 = *(void *)(v3 + 48 * v4 + 40);
  if (!v5) {
    goto LABEL_6;
  }
  uint64_t v6 = *(void *)(v3 + 48 * v4 + 32);
  if (*(_DWORD *)v5 > v6)
  {
    uint64_t v5 = *(void *)(v5 + 8) + 24 * v6;
LABEL_6:
    if (*(_WORD *)(v5 + 22) == 3)
    {
      LOBYTE(v8[0]) = 7;
      DWORD1(v8[0]) = a2;
      *((void *)&v8[0] + 1) = "entry";
      v8[1] = xmmword_23436C460;
      uint64_t v9 = 0;
      uint64_t v10 = v5;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, v8);
    }
    else
    {
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType((_anonymous_namespace_ *)a1, "entry", (uint64_t)"object");
    }
    return;
  }
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)a1, "entry", (re::DynamicString *)&v11);
  if (v12) {
    size_t v7 = *(unsigned char **)&v13[7];
  }
  else {
    size_t v7 = v13;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Index out of range.", (re::DynamicString *)v14, v7);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1, (uint64_t)v14);
  if (*(void *)&v14[0])
  {
    if (BYTE8(v14[0])) {
      (*(void (**)(void))(**(void **)&v14[0] + 40))();
    }
    memset(v14, 0, sizeof(v14));
  }
  if (v11 && (v12 & 1) != 0) {
    (*(void (**)(void))(*(void *)v11 + 40))();
  }
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(_anonymous_namespace_ *a1, char *a2, uint64_t a3, int a4)
{
  if (*((unsigned char *)a1 + 40)) {
    return 0;
  }
  BOOL result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
  if (result)
  {
    if (*((_WORD *)result + 11) == 3)
    {
      LOBYTE(v8) = 2;
      DWORD1(v8) = a4;
      *((void *)&v8 + 1) = a2;
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      char v12 = result;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v8);
      return (unsigned int *)1;
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::setErrorWrongType(a1, a2, (uint64_t)"object");
    return 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    BOOL result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 2);
    uint64_t v2 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
    ++*(void *)(v2 - 16);
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, void *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (BOOL v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v35 = 0;
    unsigned int v20 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v35, 0);
    BOOL result = 0;
    if (!v20) {
      return result;
    }
    if (v35) {
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  unint64_t v23 = a4[1];
  if (v23) {
    unint64_t v24 = v23 >> 1;
  }
  else {
    unint64_t v24 = v23 >> 1;
  }
  unint64_t v35 = v24;
  unsigned int v25 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v35, 0);
  BOOL result = 0;
  if (v25)
  {
    unint64_t v26 = v35;
    if (v26 <= (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))())
    {
      if (!*a4)
      {
        size_t v33 = v35 + 1;
        *a4 = *(void *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v33);
      }
      re::DynamicString::resize(a4, v35, 0);
      if (v35)
      {
        if (a4[1]) {
          char v34 = (char *)a4[2];
        }
        else {
          char v34 = (char *)a4 + 9;
        }
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v34, 0);
      }
      uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString(v22);
      return *(unsigned char *)(a1 + 64) == 0;
    }
    char v27 = v35;
    (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v28, v29, v30, v31, v32, v27);
    return 0;
  }
  return result;
}

uint64_t re::internal::serializeObjectWithOneMember<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(unsigned char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)v29, *a5, a5[2]);
  re::TypeMemberCollection::operator[](v14, 0, (uint64_t)&v27);
  uint64_t v15 = a4 + *(unsigned int *)(v28 + 24);
  re::TypeRegistry::typeInfo(v27, *(void *)v28, v29);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v30);
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*a5 == *a6)
  {
    uint64_t v18 = *(void *)a5[2];
    uint64_t v19 = a6[2];
    uint64_t v20 = *(void *)v19;
    if ((unsigned __int16)v18 != (unsigned __int16)*(void *)v19) {
      goto LABEL_14;
    }
    BOOL v22 = WORD1(v18) == WORD1(v20);
    uint64_t v21 = (v20 ^ v18) & 0xFFFFFF00000000;
    BOOL v22 = v22 && v21 == 0;
    if (!v22) {
      goto LABEL_14;
    }
LABEL_4:
    if (!a1[64]) {
      return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v26, a7);
    }
    return 0;
  }
  if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, v16)) {
    goto LABEL_4;
  }
  uint64_t v19 = a6[2];
LABEL_14:
  if (*(_DWORD *)(v19 + 88) != 1)
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
    return 0;
  }
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v23, *a6, v19);
  re::TypeMemberCollection::operator[](v23, 0, (uint64_t)v24);
  re::TypeRegistry::typeInfo(v24[0], *v24[2], v29);
  re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v30);
  if (a1[64]) {
    return 0;
  }
  return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v25, a7);
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(unsigned char *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v21);
  if (v21[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)&v22);
    if (*(_DWORD *)(v19 + 88) || (re::TypeRegistry::typeInfo(v18[0], *(void *)(v19 + 72), v23), v23[0])) {
      re::internal::serializeMembersWithoutVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, v18, a4);
    }
  }
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v18, *a3, a3[2]);
  if (v20)
  {
    for (unint64_t i = 0; i < v20; ++i)
    {
      if (a1[64]) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v18, i, (uint64_t)&v16);
      if (*(unsigned char *)(v17 + 28))
      {
        uint64_t v10 = *(void *)(v17 + 16);
        if (strlen((const char *)v10) >= 3 && *(unsigned char *)v10 == 109) {
          v10 += 2 * (*(unsigned char *)(v10 + 1) == 95);
        }
        uint64_t v11 = *(unsigned int *)(v17 + 32);
        uint64_t v12 = a2 + *(unsigned int *)(v17 + 24);
        re::TypeRegistry::typeInfo(v16, *(void *)v17, v23);
        re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v24);
        if (a1[64]
          || (uint64_t result = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v10, v11, v12, v15, v15, a4), (result & 1) == 0))
        {
          uint64_t result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a3);
          if (v13)
          {
            uint64_t v14 = (_DWORD *)(result + 16);
            while (i != *v14)
            {
              v14 += 6;
              if (!--v13) {
                goto LABEL_21;
              }
            }
            if (!a1[64]) {
              uint64_t result = (*(uint64_t (**)(unsigned char *, void, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, *((void *)v14 - 1), v11, v12, v15, v15, a4);
            }
          }
        }
      }
LABEL_21:
      ;
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v52);
  re::TypeRegistry::typeInfo((void *)*a4, *(void *)(a4[2] + 72), v48);
  if (v48[0])
  {
    if (!v52[0])
    {
      uint64_t v11 = re::TypeInfo::name((re::TypeInfo *)&v49)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (v53 == v49)
    {
      uint64_t v18 = *v55;
      uint64_t v19 = *v51;
      if ((unsigned __int16)*v55 == (unsigned __int16)*v51)
      {
        BOOL v21 = WORD1(v18) == WORD1(v19);
        uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        BOOL v21 = v21 && v20 == 0;
        if (v21) {
          goto LABEL_5;
        }
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v53, (const re::TypeInfo *)&v49, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((unsigned char *)a1, a2, &v53, a5);
      goto LABEL_15;
    }
    if (v54 == v50)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, &v53, &v49, a5);
    }
    else
    {
      uint64_t v22 = re::TypeInfo::name((re::TypeInfo *)&v53)[1];
      re::TypeInfo::name((re::TypeInfo *)&v49);
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v47, *a3, a3[2]);
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v45, *a4, a4[2]);
  if (v46)
  {
    for (unint64_t i = 0; i < v46; ++i)
    {
      if (*(unsigned char *)(a1 + 64)) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[](v45, i, (uint64_t)v43);
      if (*(unsigned char *)(v44 + 28))
      {
        uint64_t v29 = *(void *)(v44 + 16);
        if (strlen((const char *)v29) >= 3 && *(unsigned char *)v29 == 109) {
          v29 += 2 * (*(unsigned char *)(v29 + 1) == 95);
        }
        uint64_t v30 = *(unsigned int *)(v44 + 32);
        uint64_t v31 = *(re **)(*a4 + 856);
        if (!v31
          || (uint64_t v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v43),
              v31 == -1))
        {
          unint64_t v35 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            uint64_t v36 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            uint64_t v57 = v36;
            __int16 v58 = 2080;
            uint64_t v59 = v29;
            _os_log_impl(&dword_233120000, v35, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          uint64_t v37 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(v43[0], *(void *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v57 + 4);
          uint64_t result = re::internal::translateType(v37, (const re::TypeRegistry *)v41, (uint64_t)buf);
          if (!*(unsigned char *)(a1 + 64)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint8_t *, uint8_t *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
          }
        }
        else
        {
          re::TypeMemberCollection::operator[](v47, (int)v31, (uint64_t)v41);
          uint64_t v32 = a2 + *(unsigned int *)(v42 + 24);
          re::TypeRegistry::typeInfo(v41[0], *(void *)v42, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
          re::TypeRegistry::typeInfo(v43[0], *(void *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
          if (*(unsigned char *)(a1 + 64)
            || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, v32, v40, v39, a5), (result & 1) == 0))
          {
            uint64_t result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a4);
            if (v33)
            {
              char v34 = (_DWORD *)(result + 16);
              while (i != *v34)
              {
                v34 += 6;
                if (!--v33) {
                  goto LABEL_35;
                }
              }
              uint64_t v38 = *((void *)v34 - 1);
              re::TypeRegistry::typeInfo(v41[0], *(void *)v42, buf);
              re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
              re::TypeRegistry::typeInfo(v43[0], *(void *)v44, buf);
              uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
              if (!*(unsigned char *)(a1 + 64)) {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v38, v30, v32, v40, v39, a5);
              }
            }
          }
        }
      }
LABEL_35:
      ;
    }
  }
  return result;
}

uint64_t re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::open(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 192);
  if (*(_DWORD *)(v8 + 24) != *(_DWORD *)(a1 + 200))
  {
    re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::deinit((void *)a1);
    re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::init(a1, v8);
  }
  v9.n128_f64[0] = re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::open(a1 + 24, a2, 0, 0xFFFFFFFFLL, a3, a4);
  uint64_t v10 = *(uint64_t (**)(uint64_t, __n128))(*(void *)a1 + 48);
  return v10(a1, v9);
}

double re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::open(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  if (!a5)
  {
  }
  *(void *)(a1 + 24) = a5;
  if (!a6)
  {
  }
  *(void *)(a1 + 32) = a6;
  v13[0] = 0;
  re::Optional<re::DetailedError>::operator=(a1 + 40, v13);
  if (v13[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(void))(*(void *)v14 + 40))();
  }
  *(void *)(a1 + 96) = *(void *)(a1 + 24);
  uint64_t v8 = a1 + 96;
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity((void *)v8, 0x40uLL);
  ++*(_DWORD *)(v8 + 24);
  v10[0] = 0;
  long long v11 = 0u;
  memset(v12, 0, sizeof(v12));
  *(void *)&double result = re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::add((_anonymous_namespace_ *)v8, (uint64_t)v10).n128_u64[0];
  return result;
}

unsigned char *re::Optional<re::TypeInfo>::operator=(unsigned char *a1, unsigned __int8 *a2)
{
  int v3 = *a1;
  int v4 = *a2;
  if (*a1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    if (*a1) {
      BOOL v6 = v4 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      *a1 = 0;
    }
    else
    {
      uint64_t v7 = (uint64_t)(a1 + 8);
      if (v3) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = v4 == 0;
      }
      if (v8)
      {
        re::TypeInfo::operator=(v7, (uint64_t)(a2 + 8));
      }
      else
      {
        *a1 = 1;
        re::TypeInfo::TypeInfo(v7, (uint64_t)(a2 + 8));
      }
    }
  }
  return a1;
}

uint64_t re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::init(void *a1, uint64_t a2)
{
  a1[24] = a2;
  uint64_t v3 = (uint64_t)(a1 + 26);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(v3);
  (*(void (**)(void *))(*a1 + 64))(a1);
  uint64_t v4 = a1[24];
  BOOL v5 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v4 + 200, a1 + 1);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    uint64_t v7 = *v5;
    uint64_t v8 = a1[24];
    v14[0] = v4;
    v14[1] = v7;
    re::TypeRegistry::attributesByAttributeType(v8, (uint64_t)v14, (uint64_t)&v15);
    if (v16)
    {
      uint64_t v9 = 48 * v16;
      uint64_t v10 = (uint64_t *)(v17 + 40);
      do
      {
        long long v13 = *(_OWORD *)(v10 - 3);
        uint64_t v11 = *v10;
        v10 += 6;
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc((uint64_t)a1, (uint64_t)&v13, v11);
        v9 -= 48;
      }
      while (v9);
    }
    if (v15 && v17) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
  }
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
  *((_DWORD *)a1 + 50) = *(_DWORD *)(a1[24] + 24);
  return result;
}

void std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26E6CBE08;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6CBE08;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::operator()(uint64_t result, re::TypeRegistry **a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    re::TypeRegistry::~TypeRegistry(*a2);
    uint64_t v4 = *(uint64_t (**)(uint64_t, re::TypeRegistry *))(*(void *)v3 + 40);
    return v4(v3, v2);
  }
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1},std::allocator<std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>> re::toUniquePtr<re::TypeRegistry>(re::TypeRegistry*,re::Allocator *)::{lambda(re::TypeRegistry*)#1}>,void ()(re::TypeRegistry*)>::target_type()
{
}

void *std::__function::__value_func<void ()(re::TypeRegistry *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::function<void ()(re::TypeRegistry *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v4);
  }
  uint64_t v3 = std::__throw_bad_function_call[abi:nn180100]();
  return std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>>::~unique_ptr[abi:nn180100](v3);
}

uint64_t *std::unique_ptr<re::TypeRegistry,std::function<void ()(re::TypeRegistry*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::function<void ()(re::TypeRegistry *)>::operator()(a1[4], v2);
  }
  std::__function::__value_func<void ()(re::TypeRegistry *)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 208);
  uint64_t v5 = a1 + 208;
  LODWORD(v6) = v7;
  unint64_t v8 = *(void *)(a2 + 8) | 0xFFFFFFFF00000000;
  if (v7)
  {
    unint64_t v6 = v8 % *(unsigned int *)(a1 + 232);
    uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 216) + 4 * v6);
    if (v9 != 0x7FFFFFFF)
    {
      uint64_t v15 = *(void *)(a1 + 224);
      if (*(void *)(v15 + 24 * v9 + 4) == v8)
      {
LABEL_12:
        *(void *)(v15 + 24 * v9 + 16) = a3;
        goto LABEL_13;
      }
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v15 + 24 * v9) & 0x7FFFFFFF;
        if (v9 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v15 + 24 * v9 + 4) == v8) {
          goto LABEL_12;
        }
      }
    }
  }
  uint64_t v10 = *(unsigned int *)(a1 + 244);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 240);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 232))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(v5, 2 * *(_DWORD *)(a1 + 236));
      LODWORD(v6) = v8 % *(unsigned int *)(a1 + 232);
      int v11 = *(_DWORD *)(a1 + 240);
    }
    *(_DWORD *)(a1 + 240) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 224);
    int v13 = *(_DWORD *)(v12 + 24 * v10);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 224);
    int v13 = *(_DWORD *)(v12 + 24 * v10);
    *(_DWORD *)(a1 + 244) = v13 & 0x7FFFFFFF;
  }
  uint64_t v14 = 24 * v10;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 224) + v14) = *(_DWORD *)(*(void *)(a1 + 224) + 24 * v10) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 216) + 4 * v6);
  *(void *)(*(void *)(a1 + 224) + 24 * v10 + 4) = v8;
  *(void *)(*(void *)(a1 + 224) + 24 * v10 + 16) = a3;
  *(_DWORD *)(*(void *)(a1 + 216) + 4 * v6) = v10;
  ++*(_DWORD *)(a1 + 236);
LABEL_13:
  ++*(_DWORD *)(a1 + 248);
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(void *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v22, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v22;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)uint64_t v22 = v5;
      *(void *)&unsigned char v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        do
        {
          if ((*(_DWORD *)v6 & 0x80000000) != 0)
          {
            unint64_t v13 = *(void *)(v6 + 4);
            unint64_t v14 = *(unsigned int *)(a1 + 24);
            unint64_t v15 = v13 % v14;
            uint64_t v16 = *(unsigned int *)(a1 + 36);
            if (v16 == 0x7FFFFFFF)
            {
              uint64_t v16 = *(unsigned int *)(a1 + 32);
              int v17 = v16;
              if (v16 == v14)
              {
                re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, (2 * v11));
                unint64_t v15 = v13 % *(unsigned int *)(a1 + 24);
                int v17 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v17 + 1;
              uint64_t v18 = *(void *)(a1 + 16);
              int v19 = *(_DWORD *)(v18 + 24 * v16);
            }
            else
            {
              uint64_t v18 = *(void *)(a1 + 16);
              int v19 = *(_DWORD *)(v18 + 24 * v16);
              *(_DWORD *)(a1 + 36) = v19 & 0x7FFFFFFF;
            }
            uint64_t v20 = 24 * v16;
            *(_DWORD *)(v18 + v20) = v19 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + v20) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v16) & 0x80000000 | *(_DWORD *)(v12 + 4 * v15);
            *(void *)(*(void *)(a1 + 16) + 24 * v16 + 4) = *(void *)(v6 + 4);
            *(void *)(*(void *)(a1 + 16) + 24 * v16 + 16) = *(void *)(v6 + 16);
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v15) = v16;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v6 += 24;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2) {
      signed int v21 = a2;
    }
    else {
      signed int v21 = 3;
    }
  }
}

uint64_t re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::open(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 208);
  if (*(_DWORD *)(v8 + 24) != *(_DWORD *)(a1 + 216))
  {
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::deinit((void *)a1);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::init(a1, v8);
  }
  v9.n128_f64[0] = re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::open(a1 + 24, a2, 0, 0xFFFFFFFFLL, a3, a4);
  uint64_t v10 = *(uint64_t (**)(uint64_t, __n128))(*(void *)a1 + 48);
  return v10(a1, v9);
}

uint64_t re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 208) = a2;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 224);
  re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFuncs((void *)a1);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  *(_DWORD *)(a1 + 216) = *(_DWORD *)(*(void *)(a1 + 208) + 24);
  return result;
}

uint64_t re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::open(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 208);
  if (*(_DWORD *)(v8 + 24) != *(_DWORD *)(a1 + 216))
  {
    re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::deinit((void *)a1);
    re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::init(a1, v8);
  }
  v9.n128_f64[0] = re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::open(a1 + 24, a2, 0, 0xFFFFFFFFLL, a3, a4);
  uint64_t v10 = *(uint64_t (**)(uint64_t, __n128))(*(void *)a1 + 48);
  return v10(a1, v9);
}

uint64_t *re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFuncs(void *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 28);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
  (*(void (**)(void *))(*a1 + 64))(a1);
  uint64_t v3 = a1[26];
  uint64_t result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3) {
    BOOL v5 = result == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = *result;
    uint64_t v7 = a1[26];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      uint64_t v8 = (uint64_t *)(v15 + 40);
      uint64_t v9 = 48 * v14;
      do
      {
        uint64_t v10 = *(v8 - 2);
        uint64_t v11 = *v8;
        v8 += 6;
        uint64_t v17 = v11;
        unint64_t v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    uint64_t result = v13;
    if (v13)
    {
      if (v15) {
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  if (!*(void *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  unint64_t v7 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v7);
  if (v8 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  while (*(void *)(v9 + 24 * v8 + 4) != v6)
  {
    uint64_t v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v10 = 3 * v8;
  *(void *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  uint64_t v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v13) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&unsigned __int8 v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(void *)(*(void *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10 + 4), *(void *)&v13[16] + v10 + 4, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::init(void *a1, uint64_t a2)
{
  a1[34] = a2;
  uint64_t v3 = (uint64_t)(a1 + 36);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 36));
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(v3);
  (*(void (**)(void *))(*a1 + 64))(a1);
  uint64_t v4 = a1[34];
  long long v5 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v4 + 200, a1 + 1);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    uint64_t v7 = *v5;
    uint64_t v8 = a1[34];
    v14[0] = v4;
    v14[1] = v7;
    re::TypeRegistry::attributesByAttributeType(v8, (uint64_t)v14, (uint64_t)&v15);
    if (v16)
    {
      uint64_t v9 = 48 * v16;
      uint64_t v10 = (uint64_t *)(v17 + 40);
      do
      {
        long long v13 = *(_OWORD *)(v10 - 3);
        uint64_t v11 = *v10;
        v10 += 6;
        re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc((uint64_t)a1, (uint64_t)&v13, v11);
        v9 -= 48;
      }
      while (v9);
    }
    if (v15 && v17) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
  }
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
  *((_DWORD *)a1 + 70) = *(_DWORD *)(a1[34] + 24);
  return result;
}

void re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = *(void *)(a2 + 8) | 0xFFFFFFFF00000000;
  unint64_t v6 = *(void *)(a1 + 288);
  if (v6)
  {
    unint64_t v6 = v5 % *(unsigned int *)(a1 + 312);
    uint64_t v7 = *(unsigned int *)(*(void *)(a1 + 296) + 4 * v6);
    if (v7 != 0x7FFFFFFF)
    {
      uint64_t v13 = *(void *)(a1 + 304);
      if (*(void *)(v13 + 24 * v7 + 4) == v5)
      {
LABEL_12:
        *(void *)(v13 + 24 * v7 + 16) = a3;
        goto LABEL_13;
      }
      while (1)
      {
        LODWORD(v7) = *(_DWORD *)(v13 + 24 * v7) & 0x7FFFFFFF;
        if (v7 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v13 + 24 * v7 + 4) == v5) {
          goto LABEL_12;
        }
      }
    }
  }
  uint64_t v8 = *(unsigned int *)(a1 + 324);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 320);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 312))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1 + 288, 2 * *(_DWORD *)(a1 + 316));
      LODWORD(v6) = v5 % *(unsigned int *)(a1 + 312);
      int v9 = *(_DWORD *)(a1 + 320);
    }
    *(_DWORD *)(a1 + 320) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 304);
    int v11 = *(_DWORD *)(v10 + 24 * v8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 304);
    int v11 = *(_DWORD *)(v10 + 24 * v8);
    *(_DWORD *)(a1 + 324) = v11 & 0x7FFFFFFF;
  }
  uint64_t v12 = 24 * v8;
  *(_DWORD *)(v10 + v12) = v11 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 304) + v12) = *(_DWORD *)(*(void *)(a1 + 304) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 296) + 4 * v6);
  *(void *)(*(void *)(a1 + 304) + 24 * v8 + 4) = v5;
  *(void *)(*(void *)(a1 + 304) + 24 * v8 + 16) = a3;
  *(_DWORD *)(*(void *)(a1 + 296) + 4 * v6) = v8;
  ++*(_DWORD *)(a1 + 316);
LABEL_13:
  ++*(_DWORD *)(a1 + 328);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 272) = a2;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 288);
  re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs((void *)a1);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  *(_DWORD *)(a1 + 280) = *(_DWORD *)(*(void *)(a1 + 272) + 24);
  return result;
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::open(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 272);
  if (*(_DWORD *)(v8 + 24) != *(_DWORD *)(a1 + 280))
  {
    re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::deinit((void *)a1);
    re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::init(a1, v8);
  }
  re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::open(a1 + 24, a2, 0, 0xFFFFFFFFLL, a3, a4);
  int v9 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 48);
  return v9(a1);
}

uint64_t *re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs(void *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 36);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 36));
  (*(void (**)(void *))(*a1 + 64))(a1);
  uint64_t v3 = a1[34];
  uint64_t result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3) {
    BOOL v5 = result == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = *result;
    uint64_t v7 = a1[34];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      uint64_t v8 = (uint64_t *)(v15 + 40);
      uint64_t v9 = 48 * v14;
      do
      {
        uint64_t v10 = *(v8 - 2);
        uint64_t v11 = *v8;
        v8 += 6;
        uint64_t v17 = v11;
        unint64_t v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    uint64_t result = v13;
    if (v13)
    {
      if (v15) {
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  if (!*(void *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  unint64_t v7 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v7);
  if (v8 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  while (*(void *)(v9 + 24 * v8 + 4) != v6)
  {
    uint64_t v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v10 = 3 * v8;
  *(void *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  uint64_t v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v13) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&unsigned __int8 v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(void *)(*(void *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10 + 4), *(void *)&v13[16] + v10 + 4, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::Encoder<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::SeekableInputStream>::open(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  if (!a5)
  {
  }
  *(void *)(a1 + 24) = a5;
  if (!a6)
  {
  }
  *(void *)(a1 + 32) = a6;
  v12[0] = 0;
  re::Optional<re::DetailedError>::operator=(a1 + 40, v12);
  if (v12[0] && v13 && (v14 & 1) != 0) {
    (*(void (**)(void))(*(void *)v13 + 40))();
  }
  *(void *)(a1 + 96) = *(void *)(a1 + 24);
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity((void *)(a1 + 96), 0x40uLL);
  ++*(_DWORD *)(a1 + 120);
  v9[0] = 0;
  long long v10 = 0u;
  memset(v11, 0, sizeof(v11));
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::add((_anonymous_namespace_ *)(a1 + 96), (uint64_t)v9);
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::doOpen(a1);
}

uint64_t re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::doOpen(uint64_t a1)
{
  if (!re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance)
  {
  }
  *(void *)(a1 + 192) = *(void *)(a1 + 32);
  re::DynamicArray<char>::setCapacity((void *)(a1 + 192), 0);
  ++*(_DWORD *)(a1 + 216);
  uint64_t v2 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 32))(*(void *)(a1 + 24), 72, 8);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(void *)(v2 + 32) = 0;
  *(void *)(v2 + 40) = 256;
  *(_DWORD *)(v2 + 48) = 0;
  *(void *)(v2 + 56) = 0;
  *(_DWORD *)(v2 + 64) = 2;
  *(void *)(a1 + 184) = v2;
  uint64_t v3 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 32))(*(void *)(a1 + 24), 104, 8);
  uint64_t v4 = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::GenericDocument(v3, 0, 1024, 0);
  *(void *)(a1 + 176) = v4;
  v10[0] = *(void *)a1;
  v10[1] = 0;
  int v11 = 0;
  unint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::ParseStream<440u,rapidjson::UTF8<char>,re::internal::RapidJSONInputStream>(v4, v10);
  uint64_t v6 = *(void *)(result + 88);
  if (v6)
  {
    unsigned int v7 = v6 > 0x11
       ? "Unknown error."
       : *(char **)((char *)off_264BE2440 + (((v6 << 32) - 0x100000000) >> 29));
    re::DynamicString::format((re::DynamicString *)"Failed to deserialize JSON: %s (Offset %zu)", (re::DynamicString *)&v8, v7, *(void *)(result + 96));
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1, (uint64_t)&v8);
    uint64_t result = v8;
    if (v8)
    {
      if (v9) {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)v8 + 40))();
      }
    }
  }
  if (v12 < v11) {
    return (*(uint64_t (**)(void, void))(*(void *)v10[0] + 24))(v10[0], (v11 - v12));
  }
  return result;
}

BOOL rapidjson::ParseResult::IsError(rapidjson::ParseResult *this)
{
  return *(_DWORD *)this != 0;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::GenericDocument(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = a4;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 80) = a3;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  if (!a2)
  {
    long long v5 = (void *)(*(uint64_t (**)(void *, uint64_t, void))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                      + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 24, 0);
    v5[1] = 0;
    _OWORD v5[2] = 0;
    *long long v5 = 0;
    uint64_t v6 = rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::MemoryPoolAllocator(v5, 0x10000, 0);
    *(void *)(a1 + 24) = v6;
    *(void *)(a1 + 32) = v6;
  }
  return a1;
}

void *rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::MemoryPoolAllocator(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  uint64_t v5 = a3;
  if (!a3) {
    uint64_t v5 = (*(uint64_t (**)(void *, uint64_t))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
  }
                                                    + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 1);
  a1[1] = v5;
  uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, void))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                          + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 56, 0);
  uint64_t v7 = 0;
  a1[2] = v6;
  if (!a3) {
    uint64_t v7 = a1[1];
  }
  *(void *)(v6 + 32) = 0;
  *(void *)uint64_t v6 = v6 + 32;
  *(void *)(v6 + 8) = v7;
  *(void *)(v6 + 40) = 0;
  *(void *)(v6 + 48) = 0;
  *(unsigned char *)(v6 + 24) = 1;
  *(void *)(v6 + 16) = 1;
  return a1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::ParseStream<440u,rapidjson::UTF8<char>,re::internal::RapidJSONInputStream>(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 40);
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v16 = 256;
  int v17 = 0;
  uint64_t v18 = 0;
  int v19 = 2;
  uint64_t v4 = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::Parse<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>((uint64_t)&v13, a2, a1);
  *(void *)(a1 + 88) = v4;
  *(void *)(a1 + 96) = v5;
  if (v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = rapidjson::ParseResult::IsError;
  }
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 64);
    uint64_t v8 = (long long *)(v7 - 24);
    *(void *)(a1 + 64) = v7 - 24;
    if (v7 - 24 != a1)
    {
      __int16 v9 = *(_WORD *)(v7 - 2);
      *(_WORD *)(v7 - 2) = 0;
      long long v10 = *v8;
      int v11 = *(_DWORD *)(v7 - 8);
      *(_WORD *)(a1 + 20) = *((_WORD *)v8 + 10);
      *(_DWORD *)(a1 + 16) = v11;
      *(_OWORD *)a1 = v10;
      *(_WORD *)(a1 + 22) = v9;
    }
  }
  *(void *)(a1 + 64) = *(void *)(a1 + 56);
  rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::ShrinkToFit(v3);
  rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Destroy((uint64_t)&v13);
  return a1;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::Parse<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, void *a2, uint64_t a3)
{
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
  if (!*(_DWORD *)(a1 + 48))
  {
    if (re::internal::RapidJSONInputStream::next<false>(a2))
    {
      rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseValue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
    }
    else
    {
      uint64_t v7 = a2[4];
      *(_DWORD *)(a1 + 48) = 1;
      *(void *)(a1 + 56) = v7;
    }
  }
  uint64_t result = *(void *)(a1 + 48);
  *(void *)(a1 + 24) = *(void *)(a1 + 16);
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(uint64_t a1, void *a2)
{
  for (unint64_t i = a2; ; unint64_t i = a2)
  {
    rapidjson::SkipWhitespace<re::internal::RapidJSONInputStream>(i);
    uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
    if (result != 47) {
      break;
    }
    re::internal::RapidJSONInputStream::next<true>(a2);
    if (re::internal::RapidJSONInputStream::next<false>(a2) == 42)
    {
      re::internal::RapidJSONInputStream::next<true>(a2);
      while (1)
      {
        uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
        if (!result) {
          break;
        }
        int v6 = re::internal::RapidJSONInputStream::next<false>(a2);
        re::internal::RapidJSONInputStream::next<true>(a2);
        if (v6 == 42 && re::internal::RapidJSONInputStream::next<false>(a2) == 47)
        {
          re::internal::RapidJSONInputStream::next<true>(a2);
          goto LABEL_9;
        }
      }
LABEL_15:
      uint64_t v7 = a2[4];
      *(_DWORD *)(a1 + 48) = 17;
      *(void *)(a1 + 56) = v7;
      return result;
    }
    uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
    if (result != 47) {
      goto LABEL_15;
    }
    re::internal::RapidJSONInputStream::next<true>(a2);
    while (re::internal::RapidJSONInputStream::next<false>(a2)
         && re::internal::RapidJSONInputStream::next<true>(a2) != 10)
      ;
LABEL_9:
    ;
  }
  return result;
}

void rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseValue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, void *a2, uint64_t a3)
{
  int v6 = re::internal::RapidJSONInputStream::next<false>(a2);
  if (v6 > 109)
  {
    switch(v6)
    {
      case '{':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseObject<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        break;
      case 't':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseTrue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        break;
      case 'n':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseNull<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        break;
      default:
LABEL_26:
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseNumber<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        return;
    }
  }
  else
  {
    switch(v6)
    {
      case '""':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseString<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        break;
      case '[':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseArray<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        break;
      case 'f':
        rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseFalse<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
        return;
      default:
        goto LABEL_26;
    }
  }
}

uint64_t rapidjson::SkipWhitespace<re::internal::RapidJSONInputStream>(void *a1)
{
  while (1)
  {
    uint64_t result = re::internal::RapidJSONInputStream::next<false>(a1);
    if (result > 0x20 || ((1 << result) & 0x100002600) == 0) {
      break;
    }
    re::internal::RapidJSONInputStream::next<true>(a1);
  }
  return result;
}

uint64_t re::internal::RapidJSONInputStream::next<true>(void *a1)
{
  uint64_t v3 = (int *)(a1 + 2);
  int v2 = *((_DWORD *)a1 + 4);
  uint64_t v4 = a1 + 1;
  while (1)
  {
    unint64_t v5 = a1[3];
    if (v5 < v2)
    {
      char v6 = *(unsigned char *)(a1[1] + v5);
      uint64_t v7 = a1[4] + 1;
      a1[3] = v5 + 1;
      a1[4] = v7;
      return v6;
    }
    if (!(*(unsigned int (**)(void, void *, int *))(*(void *)*a1 + 16))(*a1, v4, v3)) {
      break;
    }
    int v2 = *v3;
    if (*v3 >= 1)
    {
      a1[3] = 1;
      return *(char *)a1[1];
    }
  }
  return 0;
}

uint64_t re::internal::RapidJSONInputStream::next<false>(void *a1)
{
  uint64_t v3 = (int *)(a1 + 2);
  int v2 = *((_DWORD *)a1 + 4);
  uint64_t v4 = a1 + 1;
  while (1)
  {
    unint64_t v5 = a1[3];
    if (v5 < v2)
    {
      char v6 = (char *)(*v4 + v5);
      return *v6;
    }
    if (!(*(unsigned int (**)(void, void *, int *))(*(void *)*a1 + 16))(*a1, v4, v3)) {
      break;
    }
    int v2 = *v3;
    if (*v3 >= 1)
    {
      a1[3] = 0;
      char v6 = (char *)a1[1];
      return *v6;
    }
  }
  return 0;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseNull<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, void *a2, uint64_t a3)
{
  re::internal::RapidJSONInputStream::next<true>(a2);
  uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
  if (result == 117
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2),
        result == 108)
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2),
        result == 108))
  {
    uint64_t result = re::internal::RapidJSONInputStream::next<true>(a2);
    uint64_t v7 = *(void **)(a3 + 64);
    if ((uint64_t)(*(void *)(a3 + 72) - (void)v7) <= 23)
    {
      uint64_t result = (uint64_t)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a3 + 40, 1);
      uint64_t v7 = *(void **)(a3 + 64);
    }
    *(void *)(a3 + 64) = v7 + 3;
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
  }
  else
  {
    uint64_t v8 = a2[4];
    *(_DWORD *)(a1 + 48) = 3;
    *(void *)(a1 + 56) = v8;
  }
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseTrue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, void *a2, uint64_t a3)
{
  re::internal::RapidJSONInputStream::next<true>(a2);
  uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
  if (result == 114
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2),
        result == 117)
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2),
        result == 101))
  {
    uint64_t result = re::internal::RapidJSONInputStream::next<true>(a2);
    uint64_t v7 = *(void *)(a3 + 64);
    if (*(void *)(a3 + 72) - v7 <= 23)
    {
      uint64_t result = (uint64_t)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a3 + 40, 1);
      uint64_t v7 = *(void *)(a3 + 64);
    }
    *(void *)(a3 + 64) = v7 + 24;
    *(void *)(v7 + 8) = 0;
    *(void *)(v7 + 16) = 0;
    *(void *)uint64_t v7 = 0;
    *(_WORD *)(v7 + 22) = 10;
  }
  else
  {
    uint64_t v8 = a2[4];
    *(_DWORD *)(a1 + 48) = 3;
    *(void *)(a1 + 56) = v8;
  }
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseFalse<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, void *a2, uint64_t a3)
{
  re::internal::RapidJSONInputStream::next<true>(a2);
  uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
  if (result == 97
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2),
        result == 108)
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2),
        result == 115)
    && (re::internal::RapidJSONInputStream::next<true>(a2),
        uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2),
        result == 101))
  {
    uint64_t result = re::internal::RapidJSONInputStream::next<true>(a2);
    uint64_t v7 = *(void *)(a3 + 64);
    if (*(void *)(a3 + 72) - v7 <= 23)
    {
      uint64_t result = (uint64_t)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a3 + 40, 1);
      uint64_t v7 = *(void *)(a3 + 64);
    }
    *(void *)(a3 + 64) = v7 + 24;
    *(void *)(v7 + 8) = 0;
    *(void *)(v7 + 16) = 0;
    *(void *)uint64_t v7 = 0;
    *(_WORD *)(v7 + 22) = 9;
  }
  else
  {
    uint64_t v8 = a2[4];
    *(_DWORD *)(a1 + 48) = 3;
    *(void *)(a1 + 56) = v8;
  }
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseString<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, void *a2, uint64_t a3)
{
  re::internal::RapidJSONInputStream::next<true>(a2);
  uint64_t v24 = a1;
  int v25 = 0;
  while (1)
  {
    while (1)
    {
      uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
      if (result != 92)
      {
        if (result == 34)
        {
          uint64_t result = re::internal::RapidJSONInputStream::next<true>(a2);
          uint64_t v16 = v24;
          int v17 = *(unsigned char **)(v24 + 24);
          if ((uint64_t)(*(void *)(v24 + 32) - (void)v17) <= 0)
          {
            uint64_t result = (uint64_t)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v24, 1);
            int v17 = *(unsigned char **)(v16 + 24);
          }
          *(void *)(v16 + 24) = v17 + 1;
          *int v17 = 0;
          int v18 = v25;
          unsigned int v19 = ++v25;
          if (*(_DWORD *)(a1 + 48)) {
            return result;
          }
          uint64_t v20 = (void *)(*(void *)(v24 + 24) - v19);
          *(void *)(v24 + 24) = v20;
          uint64_t result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::String(a3, v20, v18, 1);
          if (result) {
            return result;
          }
          uint64_t v21 = a2[4];
          int v22 = 16;
        }
        else
        {
          if (result > 0x1F)
          {
            char v7 = re::internal::RapidJSONInputStream::next<true>(a2);
            uint64_t v8 = v24;
            __int16 v9 = *(unsigned char **)(v24 + 24);
            if ((uint64_t)(*(void *)(v24 + 32) - (void)v9) <= 0)
            {
              rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v24, 1);
              __int16 v9 = *(unsigned char **)(v8 + 24);
            }
            *(void *)(v8 + 24) = v9 + 1;
            *__int16 v9 = v7;
            goto LABEL_8;
          }
          uint64_t v21 = a2[4];
          if (result) {
            int v22 = 12;
          }
          else {
            int v22 = 11;
          }
        }
        *(_DWORD *)(a1 + 48) = v22;
        *(void *)(a1 + 56) = v21;
        return result;
      }
      uint64_t v10 = a2[4];
      re::internal::RapidJSONInputStream::next<true>(a2);
      uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
      char v11 = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseStringToStream<440u,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONInputStream,rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::StackStream<char>>(re::internal::RapidJSONInputStream &,rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::StackStream<char> &)::escape[result];
      if (!v11) {
        break;
      }
      re::internal::RapidJSONInputStream::next<true>(a2);
      uint64_t v12 = v24;
      uint64_t v13 = *(unsigned char **)(v24 + 24);
      if ((uint64_t)(*(void *)(v24 + 32) - (void)v13) <= 0)
      {
        rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v24, 1);
        uint64_t v13 = *(unsigned char **)(v12 + 24);
      }
      *(void *)(v12 + 24) = v13 + 1;
      *uint64_t v13 = v11;
LABEL_8:
      ++v25;
    }
    if (result != 117)
    {
      int v23 = 10;
      goto LABEL_34;
    }
    re::internal::RapidJSONInputStream::next<true>(a2);
    uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseHex4<re::internal::RapidJSONInputStream>(a1, a2, v10);
    if (*(_DWORD *)(a1 + 48)) {
      return result;
    }
    unsigned int v14 = result;
    if (result >> 11 == 27) {
      break;
    }
LABEL_16:
    rapidjson::UTF8<char>::Encode<rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::StackStream<char>>(&v24, v14);
  }
  if (result >> 10 <= 0x36)
  {
    int v15 = result;
    uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
    if (result == 92)
    {
      re::internal::RapidJSONInputStream::next<true>(a2);
      uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
      if (result == 117)
      {
        re::internal::RapidJSONInputStream::next<true>(a2);
        uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseHex4<re::internal::RapidJSONInputStream>(a1, a2, v10);
        if (*(_DWORD *)(a1 + 48)) {
          return result;
        }
        if ((result - 57344) > 0xFFFFFBFF)
        {
          unsigned int v14 = ((result - 56320) | ((v15 << 10) - 56623104)) + 0x10000;
          goto LABEL_16;
        }
      }
    }
  }
  int v23 = 9;
LABEL_34:
  *(_DWORD *)(a1 + 48) = v23;
  *(void *)(a1 + 56) = v10;
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseObject<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, void *a2, uint64_t a3)
{
  re::internal::RapidJSONInputStream::next<true>(a2);
  uint64_t result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::StartObject(a3);
  if (result)
  {
    uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
    if (*(_DWORD *)(a1 + 48)) {
      return result;
    }
    if (re::internal::RapidJSONInputStream::next<false>(a2) == 125)
    {
      uint64_t result = re::internal::RapidJSONInputStream::next<true>(a2);
      uint64_t v7 = *(void *)(a3 + 64);
      *(_WORD *)(v7 - 2) = 3;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      return result;
    }
    unsigned int v8 = 0;
    while (1)
    {
      uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
      if (result != 34)
      {
        uint64_t v9 = a2[4];
        int v10 = 4;
        goto LABEL_25;
      }
      uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseString<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
      if (*(_DWORD *)(a1 + 48)) {
        return result;
      }
      uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
      if (*(_DWORD *)(a1 + 48)) {
        return result;
      }
      uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
      if (result != 58)
      {
        uint64_t v9 = a2[4];
        int v10 = 5;
        goto LABEL_25;
      }
      re::internal::RapidJSONInputStream::next<true>(a2);
      uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
      if (*(_DWORD *)(a1 + 48)) {
        return result;
      }
      uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseValue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
      if (*(_DWORD *)(a1 + 48)) {
        return result;
      }
      uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
      if (*(_DWORD *)(a1 + 48)) {
        return result;
      }
      uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
      if (result != 44) {
        break;
      }
      re::internal::RapidJSONInputStream::next<true>(a2);
      uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
      if (*(_DWORD *)(a1 + 48)) {
        return result;
      }
      ++v8;
      if (re::internal::RapidJSONInputStream::next<false>(a2) == 125)
      {
        uint64_t result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndObject(a3, v8);
        if ((result & 1) == 0) {
          goto LABEL_23;
        }
        return re::internal::RapidJSONInputStream::next<true>(a2);
      }
    }
    if (result != 125)
    {
      uint64_t v9 = a2[4];
      int v10 = 6;
      goto LABEL_25;
    }
    re::internal::RapidJSONInputStream::next<true>(a2);
    uint64_t result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndObject(a3, v8 + 1);
    if (result) {
      return result;
    }
  }
LABEL_23:
  uint64_t v9 = a2[4];
  int v10 = 16;
LABEL_25:
  *(_DWORD *)(a1 + 48) = v10;
  *(void *)(a1 + 56) = v9;
  return result;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseArray<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, void *a2, uint64_t a3)
{
  re::internal::RapidJSONInputStream::next<true>(a2);
  uint64_t result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::StartArray(a3);
  if (result)
  {
    uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
    if (!*(_DWORD *)(a1 + 48))
    {
      if (re::internal::RapidJSONInputStream::next<false>(a2) == 93)
      {
        uint64_t result = re::internal::RapidJSONInputStream::next<true>(a2);
        uint64_t v7 = *(void *)(a3 + 64);
        *(_WORD *)(v7 - 2) = 4;
        *(void *)(v7 - 24) = 0;
        *(void *)(v7 - 16) = 0;
      }
      else
      {
        unsigned int v8 = 0;
        while (1)
        {
          uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseValue<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(a1, a2, a3);
          if (*(_DWORD *)(a1 + 48)) {
            break;
          }
          uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
          if (*(_DWORD *)(a1 + 48)) {
            break;
          }
          if (re::internal::RapidJSONInputStream::next<false>(a2) != 44)
          {
            uint64_t result = re::internal::RapidJSONInputStream::next<false>(a2);
            if (result != 93)
            {
              uint64_t v9 = a2[4];
              int v10 = 7;
              goto LABEL_19;
            }
            re::internal::RapidJSONInputStream::next<true>(a2);
            uint64_t result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndArray(a3, v8 + 1);
            if (result) {
              return result;
            }
            goto LABEL_18;
          }
          re::internal::RapidJSONInputStream::next<true>(a2);
          uint64_t result = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::SkipWhitespaceAndComments<440u,re::internal::RapidJSONInputStream>(a1, a2);
          if (*(_DWORD *)(a1 + 48)) {
            return result;
          }
          ++v8;
          if (re::internal::RapidJSONInputStream::next<false>(a2) == 93)
          {
            uint64_t result = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndArray(a3, v8);
            if ((result & 1) == 0) {
              goto LABEL_18;
            }
            return re::internal::RapidJSONInputStream::next<true>(a2);
          }
        }
      }
    }
  }
  else
  {
LABEL_18:
    uint64_t v9 = a2[4];
    int v10 = 16;
LABEL_19:
    *(_DWORD *)(a1 + 48) = v10;
    *(void *)(a1 + 56) = v9;
  }
  return result;
}

void rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseNumber<440u,re::internal::RapidJSONInputStream,rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>>(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v61 = a2;
  uint64_t v62 = a1;
  int v63 = 0;
  char v6 = a2 + 4;
  uint64_t v7 = a2[4];
  int v8 = re::internal::RapidJSONInputStream::next<false>(a2);
  if (v8 == 45) {
    re::internal::RapidJSONInputStream::next<true>(v4);
  }
  int v9 = re::internal::RapidJSONInputStream::next<false>(v4);
  int v10 = re::internal::RapidJSONInputStream::next<false>(v4);
  char v11 = v10;
  uint64_t v58 = v7;
  uint64_t v59 = a1;
  uint64_t v57 = a3;
  int v60 = v8;
  if (v9 == 48)
  {
    uint64_t v40 = *(unsigned char **)(a1 + 24);
    if ((uint64_t)(*(void *)(a1 + 32) - (void)v40) <= 0)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(a1, 1);
      uint64_t v40 = *(unsigned char **)(a1 + 24);
    }
    *(void *)(a1 + 24) = v40 + 1;
    *uint64_t v40 = v11;
    int v14 = ++v63;
    uint64_t v4 = v61;
    re::internal::RapidJSONInputStream::next<true>(v61);
    int v23 = 0;
    int v18 = 0;
    unint64_t v24 = 0;
    int v25 = 0;
    unsigned int v15 = 0;
    int v26 = 0;
    double v17 = 0.0;
  }
  else
  {
    if (v10 >= 49 && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
    {
      char v12 = re::internal::RapidJSONInputStream::next<false>(v4);
      uint64_t v13 = *(unsigned char **)(a1 + 24);
      if ((uint64_t)(*(void *)(a1 + 32) - (void)v13) <= 0)
      {
        rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(a1, 1);
        uint64_t v13 = *(unsigned char **)(a1 + 24);
      }
      *(void *)(a1 + 24) = v13 + 1;
      *uint64_t v13 = v12;
      int v14 = ++v63;
      uint64_t v4 = v61;
      unsigned int v15 = re::internal::RapidJSONInputStream::next<true>(v61) - 48;
      int v16 = re::internal::RapidJSONInputStream::next<false>(v61);
      double v17 = 0.0;
      if (v8 == 45)
      {
        if (v16 >= 48)
        {
          int v18 = 0;
          while ((int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
          {
            if (v15 > 0xCCCCCCB)
            {
              if (v15 != 214748364) {
                goto LABEL_35;
              }
              if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 56)
              {
                unsigned int v15 = 214748364;
                goto LABEL_35;
              }
            }
            char v19 = re::internal::RapidJSONInputStream::next<false>(v4);
            uint64_t v20 = *(unsigned char **)(v62 + 24);
            if ((uint64_t)(*(void *)(v62 + 32) - (void)v20) <= 0)
            {
              rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
              uint64_t v20 = *(unsigned char **)(v62 + 24);
            }
            *(void *)(v62 + 24) = v20 + 1;
            *uint64_t v20 = v19;
            int v14 = ++v63;
            uint64_t v4 = v61;
            unsigned int v15 = 10 * v15 + re::internal::RapidJSONInputStream::next<true>(v61) - 48;
            ++v18;
            if ((int)re::internal::RapidJSONInputStream::next<false>(v61) <= 47) {
              break;
            }
          }
LABEL_31:
          int v23 = 0;
LABEL_32:
          unint64_t v24 = 0;
          int v25 = 0;
          int v26 = 0;
          goto LABEL_67;
        }
      }
      else if (v16 >= 48)
      {
        int v18 = 0;
        while ((int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
        {
          if (v15 > 0x19999998)
          {
            if (v15 != 429496729) {
              goto LABEL_35;
            }
            if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 53)
            {
              unsigned int v15 = 429496729;
LABEL_35:
              unint64_t v24 = v15;
              int v27 = re::internal::RapidJSONInputStream::next<false>(v4);
              double v17 = 0.0;
              if (v8 == 45)
              {
                if (v27 >= 48)
                {
                  while ((int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
                  {
                    if (v24 > 0xCCCCCCCCCCCCCCBLL)
                    {
                      if (v24 != 0xCCCCCCCCCCCCCCCLL) {
                        goto LABEL_59;
                      }
                      if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 56)
                      {
                        unint64_t v24 = 0xCCCCCCCCCCCCCCCLL;
                        goto LABEL_59;
                      }
                    }
                    char v28 = re::internal::RapidJSONInputStream::next<false>(v4);
                    uint64_t v29 = *(unsigned char **)(v62 + 24);
                    if ((uint64_t)(*(void *)(v62 + 32) - (void)v29) <= 0)
                    {
                      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
                      uint64_t v29 = *(unsigned char **)(v62 + 24);
                    }
                    *(void *)(v62 + 24) = v29 + 1;
                    *uint64_t v29 = v28;
                    int v14 = ++v63;
                    uint64_t v4 = v61;
                    unint64_t v24 = re::internal::RapidJSONInputStream::next<true>(v61) - 48 + 10 * v24;
                    ++v18;
                    if ((int)re::internal::RapidJSONInputStream::next<false>(v61) <= 47) {
                      break;
                    }
                  }
                }
              }
              else if (v27 >= 48)
              {
                while ((int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
                {
                  if (v24 > 0x1999999999999998)
                  {
                    if (v24 != 0x1999999999999999) {
                      goto LABEL_59;
                    }
                    if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 53)
                    {
                      unint64_t v24 = 0x1999999999999999;
LABEL_59:
                      double v17 = (double)v24;
                      if ((int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48
                        && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
                      {
                        do
                        {
                          char v32 = re::internal::RapidJSONInputStream::next<false>(v4);
                          uint64_t v33 = *(unsigned char **)(v62 + 24);
                          if ((uint64_t)(*(void *)(v62 + 32) - (void)v33) <= 0)
                          {
                            rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
                            uint64_t v33 = *(unsigned char **)(v62 + 24);
                          }
                          *(void *)(v62 + 24) = v33 + 1;
                          *uint64_t v33 = v32;
                          int v14 = ++v63;
                          uint64_t v4 = v61;
                          double v17 = (double)(int)(re::internal::RapidJSONInputStream::next<true>(v61) - 48) + v17 * 10.0;
                        }
                        while ((int)re::internal::RapidJSONInputStream::next<false>(v61) > 47
                             && (int)re::internal::RapidJSONInputStream::next<false>(v61) <= 57);
                      }
                      int v25 = 0;
                      int v23 = 1;
                      goto LABEL_66;
                    }
                  }
                  char v30 = re::internal::RapidJSONInputStream::next<false>(v4);
                  uint64_t v31 = *(unsigned char **)(v62 + 24);
                  if ((uint64_t)(*(void *)(v62 + 32) - (void)v31) <= 0)
                  {
                    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
                    uint64_t v31 = *(unsigned char **)(v62 + 24);
                  }
                  *(void *)(v62 + 24) = v31 + 1;
                  *uint64_t v31 = v30;
                  int v14 = ++v63;
                  uint64_t v4 = v61;
                  unint64_t v24 = re::internal::RapidJSONInputStream::next<true>(v61) - 48 + 10 * v24;
                  ++v18;
                  if ((int)re::internal::RapidJSONInputStream::next<false>(v61) <= 47) {
                    break;
                  }
                }
              }
              int v23 = 0;
              int v25 = 0;
LABEL_66:
              int v26 = 1;
              goto LABEL_67;
            }
          }
          char v21 = re::internal::RapidJSONInputStream::next<false>(v4);
          int v22 = *(unsigned char **)(v62 + 24);
          if ((uint64_t)(*(void *)(v62 + 32) - (void)v22) <= 0)
          {
            rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
            int v22 = *(unsigned char **)(v62 + 24);
          }
          *(void *)(v62 + 24) = v22 + 1;
          unsigned char *v22 = v21;
          int v14 = ++v63;
          uint64_t v4 = v61;
          unsigned int v15 = 10 * v15 + re::internal::RapidJSONInputStream::next<true>(v61) - 48;
          ++v18;
          if ((int)re::internal::RapidJSONInputStream::next<false>(v61) <= 47) {
            goto LABEL_31;
          }
        }
        goto LABEL_31;
      }
      int v23 = 0;
      int v18 = 0;
      goto LABEL_32;
    }
    if (re::internal::RapidJSONInputStream::next<false>(v4) != 73
      && re::internal::RapidJSONInputStream::next<false>(v4) != 78)
    {
      goto LABEL_154;
    }
    if (re::internal::RapidJSONInputStream::next<false>(v4) == 78)
    {
      re::internal::RapidJSONInputStream::next<true>(v4);
      if (re::internal::RapidJSONInputStream::next<false>(v4) != 97) {
        goto LABEL_154;
      }
      re::internal::RapidJSONInputStream::next<true>(v4);
      if (re::internal::RapidJSONInputStream::next<false>(v4) != 78) {
        goto LABEL_154;
      }
      re::internal::RapidJSONInputStream::next<true>(v4);
      int v14 = 0;
      int v23 = 0;
      int v18 = 0;
      unint64_t v24 = 0;
      unsigned int v15 = 0;
      int v26 = 0;
      int v25 = 1;
      double v17 = NAN;
    }
    else
    {
      if (re::internal::RapidJSONInputStream::next<false>(v4) != 73) {
        goto LABEL_154;
      }
      re::internal::RapidJSONInputStream::next<true>(v4);
      if (re::internal::RapidJSONInputStream::next<false>(v4) != 110) {
        goto LABEL_154;
      }
      re::internal::RapidJSONInputStream::next<true>(v4);
      if (re::internal::RapidJSONInputStream::next<false>(v4) != 102) {
        goto LABEL_154;
      }
      re::internal::RapidJSONInputStream::next<true>(v4);
      if (v8 == 45) {
        double v17 = -INFINITY;
      }
      else {
        double v17 = INFINITY;
      }
      if (re::internal::RapidJSONInputStream::next<false>(v4) == 105)
      {
        if (re::internal::RapidJSONInputStream::next<false>(v4) != 105) {
          goto LABEL_154;
        }
        re::internal::RapidJSONInputStream::next<true>(v4);
        if (re::internal::RapidJSONInputStream::next<false>(v4) != 110) {
          goto LABEL_154;
        }
        re::internal::RapidJSONInputStream::next<true>(v4);
        if (re::internal::RapidJSONInputStream::next<false>(v4) != 105) {
          goto LABEL_154;
        }
        re::internal::RapidJSONInputStream::next<true>(v4);
        if (re::internal::RapidJSONInputStream::next<false>(v4) != 116) {
          goto LABEL_154;
        }
        re::internal::RapidJSONInputStream::next<true>(v4);
        if (re::internal::RapidJSONInputStream::next<false>(v4) != 121) {
          goto LABEL_154;
        }
        re::internal::RapidJSONInputStream::next<true>(v4);
      }
      int v14 = 0;
      int v23 = 0;
      int v18 = 0;
      unint64_t v24 = 0;
      unsigned int v15 = 0;
      int v26 = 0;
      int v25 = 1;
    }
  }
LABEL_67:
  if (re::internal::RapidJSONInputStream::next<false>(v4) != 46)
  {
    int v34 = 0;
    int v35 = v14;
    goto LABEL_115;
  }
  re::internal::RapidJSONInputStream::next<true>(v4);
  if (v25)
  {
LABEL_153:
    char v6 = v4 + 4;
LABEL_154:
    int v39 = 3;
    goto LABEL_156;
  }
  if ((int)re::internal::RapidJSONInputStream::next<false>(v4) < 48
    || (int)re::internal::RapidJSONInputStream::next<false>(v4) >= 58)
  {
    char v6 = v4 + 4;
    int v39 = 14;
    goto LABEL_156;
  }
  if (v23)
  {
    int v34 = 0;
    int v35 = v14;
    goto LABEL_102;
  }
  if (!v26) {
    unint64_t v24 = v15;
  }
  if ((int)re::internal::RapidJSONInputStream::next<false>(v4) < 48)
  {
    int v34 = 0;
  }
  else
  {
    int v34 = 0;
    if ((int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57 && !(v24 >> 53))
    {
      int v36 = -1;
      do
      {
        int v34 = v36;
        char v37 = re::internal::RapidJSONInputStream::next<false>(v4);
        uint64_t v38 = *(unsigned char **)(v62 + 24);
        if ((uint64_t)(*(void *)(v62 + 32) - (void)v38) <= 0)
        {
          rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
          uint64_t v38 = *(unsigned char **)(v62 + 24);
        }
        *(void *)(v62 + 24) = v38 + 1;
        *uint64_t v38 = v37;
        int v35 = ++v63;
        uint64_t v4 = v61;
        unint64_t v24 = re::internal::RapidJSONInputStream::next<true>(v61) - 48 + 10 * v24;
        if (v24) {
          ++v18;
        }
        if ((int)re::internal::RapidJSONInputStream::next<false>(v61) <= 47) {
          break;
        }
        if ((int)re::internal::RapidJSONInputStream::next<false>(v61) > 57) {
          break;
        }
        int v36 = v34 - 1;
      }
      while (!(v24 >> 53));
      goto LABEL_101;
    }
  }
  int v35 = v14;
LABEL_101:
  double v17 = (double)v24;
LABEL_102:
  if ((int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48
    && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
  {
    do
    {
      char v41 = re::internal::RapidJSONInputStream::next<false>(v4);
      uint64_t v42 = *(unsigned char **)(v62 + 24);
      uint64_t v43 = *(void *)(v62 + 32) - (void)v42;
      if (v18 > 16)
      {
        if (v43 <= 0)
        {
          rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
          uint64_t v42 = *(unsigned char **)(v62 + 24);
        }
        *(void *)(v62 + 24) = v42 + 1;
        *uint64_t v42 = v41;
        int v35 = ++v63;
        uint64_t v4 = v61;
        re::internal::RapidJSONInputStream::next<true>(v61);
      }
      else
      {
        if (v43 <= 0)
        {
          rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v62, 1);
          uint64_t v42 = *(unsigned char **)(v62 + 24);
        }
        *(void *)(v62 + 24) = v42 + 1;
        *uint64_t v42 = v41;
        int v35 = ++v63;
        uint64_t v4 = v61;
        double v17 = (double)(int)(re::internal::RapidJSONInputStream::next<true>(v61) - 48) + v17 * 10.0;
        --v34;
        if (v17 > 0.0) {
          ++v18;
        }
      }
    }
    while ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 47
         && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57);
  }
  int v23 = 1;
LABEL_115:
  if (re::internal::RapidJSONInputStream::next<false>(v4) == 101
    || re::internal::RapidJSONInputStream::next<false>(v4) == 69)
  {
    re::internal::RapidJSONInputStream::next<true>(v4);
    if (!v25)
    {
      unint64_t v44 = v15;
      if (v26) {
        unint64_t v44 = v24;
      }
      if (!v23) {
        double v17 = (double)v44;
      }
      int v45 = re::internal::RapidJSONInputStream::next<false>(v4);
      BOOL v46 = v45 != 43;
      if (v45 == 43 || (int v56 = re::internal::RapidJSONInputStream::next<false>(v4), v56 == 45)) {
        re::internal::RapidJSONInputStream::next<true>(v4);
      }
      else {
        BOOL v46 = 0;
      }
      int v47 = v60;
      if ((int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48
        && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
      {
        int v48 = re::internal::RapidJSONInputStream::next<true>(v4) - 48;
        if (v46)
        {
          if ((int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48)
          {
            do
            {
              if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 57) {
                break;
              }
              int v48 = re::internal::RapidJSONInputStream::next<true>(v4) + 10 * v48 - 48;
              if (v48 > (v34 + 2147483639) / 10 && (int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48)
              {
                do
                {
                  if ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 57) {
                    break;
                  }
                  re::internal::RapidJSONInputStream::next<true>(v4);
                }
                while ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 47);
              }
            }
            while ((int)re::internal::RapidJSONInputStream::next<false>(v4) > 47);
          }
        }
        else
        {
          while ((int)re::internal::RapidJSONInputStream::next<false>(v4) >= 48
               && (int)re::internal::RapidJSONInputStream::next<false>(v4) <= 57)
          {
            int v48 = re::internal::RapidJSONInputStream::next<true>(v4) + 10 * v48 - 48;
            if (v48 > 308 - v34) {
              goto LABEL_145;
            }
          }
        }
        if (v46) {
          int v49 = -v48;
        }
        else {
          int v49 = v48;
        }
        char v50 = (char *)rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::NumberStream<re::internal::RapidJSONInputStream,char,true,false>::Pop((uint64_t)&v61);
        goto LABEL_144;
      }
      char v6 = v4 + 4;
      int v39 = 15;
LABEL_156:
      uint64_t v53 = *v6;
      uint64_t v52 = v59;
      goto LABEL_147;
    }
    goto LABEL_153;
  }
  uint64_t v55 = rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::NumberStream<re::internal::RapidJSONInputStream,char,true,false>::Pop((uint64_t)&v61);
  if (v23)
  {
    char v50 = (char *)v55;
    int v49 = 0;
    int v47 = v60;
LABEL_144:
    double v51 = rapidjson::internal::StrtodFullPrecision<char>(v49 + v34, v50, v35, v14, v49, v17);
    if (v51 > 1.79769313e308)
    {
LABEL_145:
      int v39 = 13;
LABEL_146:
      uint64_t v53 = v58;
      uint64_t v52 = v59;
LABEL_147:
      *(_DWORD *)(v52 + 48) = v39;
      *(void *)(v52 + 56) = v53;
      return;
    }
    if (v47 == 45) {
      double v51 = -v51;
    }
    uint64_t v54 = v57;
LABEL_151:
    if (rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Double(v54, v51))return; {
LABEL_181:
    }
    int v39 = 16;
    goto LABEL_146;
  }
  if (v25)
  {
    uint64_t v54 = v57;
    double v51 = v17;
    goto LABEL_151;
  }
  if (v26)
  {
    if (v60 == 45)
    {
      if ((rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Int64(v57, -(uint64_t)v24) & 1) == 0)goto LABEL_181; {
    }
      }
    else if ((rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Uint64(v57, v24) & 1) == 0)
    {
      goto LABEL_181;
    }
  }
  else if (v60 == 45)
  {
    if ((rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Int(v57, -v15) & 1) == 0)goto LABEL_181; {
  }
    }
  else if ((rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Uint(v57, v15) & 1) == 0)
  {
    goto LABEL_181;
  }
}

char *rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 16);
  if (v4)
  {
    size_t v5 = *(void *)(a1 + 32) - (void)v4;
    unint64_t v6 = v5 + ((v5 + 1) >> 1);
    uint64_t v7 = *(re::internal::RapidJSONAllocator **)a1;
  }
  else
  {
    uint64_t v7 = *(re::internal::RapidJSONAllocator **)a1;
    if (*(void *)a1)
    {
      uint64_t v4 = 0;
    }
    else
    {
      uint64_t v7 = (re::internal::RapidJSONAllocator *)(*(uint64_t (**)(void *, uint64_t, void))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                                                  + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 1, 0);
      *(void *)a1 = v7;
      *(void *)(a1 + 8) = v7;
      uint64_t v4 = *(void **)(a1 + 16);
    }
    unint64_t v6 = *(void *)(a1 + 40);
    size_t v5 = *(void *)(a1 + 32) - (void)v4;
  }
  uint64_t v8 = *(void *)(a1 + 24) - (void)v4;
  if (v6 <= v8 + 24 * a2) {
    size_t v9 = v8 + 24 * a2;
  }
  else {
    size_t v9 = v6;
  }
  uint64_t result = (char *)re::internal::RapidJSONAllocator::Realloc(v7, v4, v5, v9);
  *(void *)(a1 + 16) = result;
  *(void *)(a1 + 24) = &result[v8];
  *(void *)(a1 + 32) = &result[v9];
  return result;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::String(uint64_t a1, void *a2, int a3, int a4)
{
  uint64_t v8 = a1 + 64;
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(v8 + 8) - v7;
  if (a4)
  {
    if (v9 <= 23)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
      uint64_t v7 = *(void *)(a1 + 64);
    }
    *(void *)(a1 + 64) = v7 + 24;
    uint64_t v10 = *(void *)(a1 + 24);
    *(void *)uint64_t v7 = 0;
    *(void *)(v7 + 8) = 0;
    *(void *)(v7 + 16) = 0;
    char v11 = &rapidjson::GenericStringRef<char>::emptyString;
    if (a2) {
      char v11 = a2;
    }
    int v14 = v11;
    int v15 = a3;
    rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::SetStringRaw((_WORD *)v7, (uint64_t)&v14, v10);
  }
  else
  {
    if (v9 <= 23)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
      uint64_t v7 = *(void *)(a1 + 64);
    }
    *(void *)(a1 + 64) = v7 + 24;
    *(void *)(v7 + 16) = 0;
    char v12 = &rapidjson::GenericStringRef<char>::emptyString;
    *(_WORD *)(v7 + 22) = 1029;
    if (a2) {
      char v12 = a2;
    }
    *(void *)uint64_t v7 = 0;
    *(void *)(v7 + 8) = v12;
    *(_DWORD *)uint64_t v7 = a3;
  }
  return 1;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::ParseHex4<re::internal::RapidJSONInputStream>(uint64_t a1, void *a2, uint64_t a3)
{
  LODWORD(v6) = 0;
  int v7 = 4;
  while (1)
  {
    int v8 = re::internal::RapidJSONInputStream::next<false>(a2);
    if ((v8 - 48) >= 0xA) {
      break;
    }
    int v9 = -48;
LABEL_8:
    uint64_t v6 = (v8 + 16 * v6 + v9);
    re::internal::RapidJSONInputStream::next<true>(a2);
    if (!--v7) {
      return v6;
    }
  }
  if ((v8 - 65) < 6)
  {
    int v9 = -55;
    goto LABEL_8;
  }
  if ((v8 - 97) < 6)
  {
    int v9 = -87;
    goto LABEL_8;
  }
  uint64_t v6 = 0;
  *(_DWORD *)(a1 + 48) = 8;
  *(void *)(a1 + 56) = a3;
  return v6;
}

uint64_t *rapidjson::UTF8<char>::Encode<rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::StackStream<char>>(uint64_t *result, unsigned int a2)
{
  uint64_t v3 = result;
  if (a2 <= 0x7F)
  {
    uint64_t v4 = *result;
    size_t v5 = *(unsigned char **)(*result + 24);
    if ((uint64_t)(*(void *)(*result + 32) - (void)v5) <= 0)
    {
      uint64_t result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*result, 1);
      size_t v5 = *(unsigned char **)(v4 + 24);
    }
    *(void *)(v4 + 24) = v5 + 1;
    *size_t v5 = a2;
    uint64_t v6 = v3 + 1;
    goto LABEL_27;
  }
  if (a2 <= 0x7FF)
  {
    unsigned int v7 = (a2 >> 6) | 0xFFFFFFC0;
    uint64_t v8 = *result;
    int v9 = *(unsigned char **)(*result + 24);
    if ((uint64_t)(*(void *)(*result + 32) - (void)v9) <= 0)
    {
      uint64_t result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*result, 1);
      int v9 = *(unsigned char **)(v8 + 24);
    }
    *(void *)(v8 + 24) = v9 + 1;
    *int v9 = v7;
    uint64_t v6 = v3 + 1;
    ++*((_DWORD *)v3 + 2);
LABEL_24:
    uint64_t v27 = *v3;
    char v28 = *(unsigned char **)(v27 + 24);
    if ((uint64_t)(*(void *)(v27 + 32) - (void)v28) <= 0)
    {
      uint64_t result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v27, 1);
      char v28 = *(unsigned char **)(v27 + 24);
    }
    *(void *)(v27 + 24) = v28 + 1;
    *char v28 = a2 & 0x3F | 0x80;
    goto LABEL_27;
  }
  uint64_t v10 = *result;
  char v11 = *(unsigned char **)(*result + 24);
  uint64_t v12 = *(void *)(*result + 32) - (void)v11;
  if (HIWORD(a2))
  {
    unsigned int v20 = (a2 >> 18) | 0xFFFFFFF0;
    if (v12 <= 0)
    {
      uint64_t result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*result, 1);
      char v11 = *(unsigned char **)(v10 + 24);
    }
    *(void *)(v10 + 24) = v11 + 1;
    *char v11 = v20;
    uint64_t v6 = v3 + 1;
    ++*((_DWORD *)v3 + 2);
    unsigned int v21 = (a2 >> 12) & 0x3F | 0xFFFFFF80;
    uint64_t v22 = *v3;
    int v23 = *(unsigned char **)(*v3 + 24);
    if ((uint64_t)(*(void *)(*v3 + 32) - (void)v23) <= 0)
    {
      uint64_t result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*v3, 1);
      unsigned int v21 = (a2 >> 12) & 0x3F | 0xFFFFFF80;
      int v23 = *(unsigned char **)(v22 + 24);
    }
    *(void *)(v22 + 24) = v23 + 1;
    *int v23 = v21;
    ++*((_DWORD *)v3 + 2);
    unsigned int v24 = (a2 >> 6) & 0x3F | 0xFFFFFF80;
    uint64_t v25 = *v3;
    int v26 = *(unsigned char **)(*v3 + 24);
    if ((uint64_t)(*(void *)(*v3 + 32) - (void)v26) <= 0)
    {
      uint64_t result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*v3, 1);
      unsigned int v24 = (a2 >> 6) & 0x3F | 0xFFFFFF80;
      int v26 = *(unsigned char **)(v25 + 24);
    }
    *(void *)(v25 + 24) = v26 + 1;
    *int v26 = v24;
    ++*((_DWORD *)v3 + 2);
    goto LABEL_24;
  }
  unsigned int v13 = (a2 >> 12) | 0xFFFFFFE0;
  if (v12 <= 0)
  {
    uint64_t result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*result, 1);
    char v11 = *(unsigned char **)(v10 + 24);
  }
  *(void *)(v10 + 24) = v11 + 1;
  *char v11 = v13;
  uint64_t v6 = v3 + 1;
  ++*((_DWORD *)v3 + 2);
  unsigned int v14 = (a2 >> 6) & 0x3F | 0xFFFFFF80;
  uint64_t v15 = *v3;
  int v16 = *(unsigned char **)(*v3 + 24);
  if ((uint64_t)(*(void *)(*v3 + 32) - (void)v16) <= 0)
  {
    uint64_t result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*v3, 1);
    unsigned int v14 = (a2 >> 6) & 0x3F | 0xFFFFFF80;
    int v16 = *(unsigned char **)(v15 + 24);
  }
  *(void *)(v15 + 24) = v16 + 1;
  *int v16 = v14;
  ++*((_DWORD *)v3 + 2);
  char v17 = a2 & 0x3F | 0x80;
  uint64_t v18 = *v3;
  char v19 = *(unsigned char **)(v18 + 24);
  if ((uint64_t)(*(void *)(v18 + 32) - (void)v19) <= 0)
  {
    uint64_t result = (uint64_t *)rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v18, 1);
    char v17 = a2 & 0x3F | 0x80;
    char v19 = *(unsigned char **)(v18 + 24);
  }
  *(void *)(v18 + 24) = v19 + 1;
  *char v19 = v17;
LABEL_27:
  ++*v6;
  return result;
}

void *rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::SetStringRaw(_WORD *__dst, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = __dst;
  if (*(_DWORD *)(a2 + 8) > 0x15u)
  {
    __dst[11] = 3077;
    *(_DWORD *)uint64_t __dst = *(_DWORD *)(a2 + 8);
    uint64_t v5 = rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Malloc(a3, (*(_DWORD *)(a2 + 8) + 1));
    v4[1] = v5;
    uint64_t v4 = (void *)v5;
  }
  else
  {
    __dst[11] = 7173;
    *((unsigned char *)__dst + 21) = 21 - *(unsigned char *)(a2 + 8);
  }
  uint64_t result = memcpy(v4, *(const void **)a2, *(unsigned int *)(a2 + 8));
  *((unsigned char *)v4 + *(unsigned int *)(a2 + 8)) = 0;
  return result;
}

uint64_t rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Malloc(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  unint64_t v3 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v4 = **(void ***)(a1 + 16);
  uint64_t v5 = v4[1];
  uint64_t v6 = v5 + v3;
  if (v5 + v3 <= *v4)
  {
LABEL_3:
    uint64_t result = (uint64_t)v4 + v5 + 24;
    v4[1] = v6;
    return result;
  }
  if (*(void *)a1 <= v3) {
    unint64_t v8 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  else {
    unint64_t v8 = *(void *)a1;
  }
  if (rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::AddChunk(a1, v8))
  {
    uint64_t v4 = **(void ***)(a1 + 16);
    uint64_t v5 = v4[1];
    uint64_t v6 = v5 + v3;
    goto LABEL_3;
  }
  return 0;
}

BOOL rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::AddChunk(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 8))
  {
    uint64_t v4 = (*(uint64_t (**)(void *, uint64_t, void))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                            + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, 1, 0);
    *(void *)(a1 + 8) = v4;
    *(void *)(*(void *)(a1 + 16) + 8) = v4;
  }
  uint64_t v5 = (void *)(*(uint64_t (**)(void *, uint64_t, void))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
                                                                    + 32))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance, a2 + 24, 0);
  if (v5)
  {
    *uint64_t v5 = a2;
    v5[1] = 0;
    uint64_t v6 = *(void **)(a1 + 16);
    _OWORD v5[2] = *v6;
    *uint64_t v6 = v5;
  }
  return v5 != 0;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::StartObject(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (*(void *)(a1 + 72) - v2 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    uint64_t v2 = *(void *)(a1 + 64);
  }
  *(void *)(a1 + 64) = v2 + 24;
  *(void *)(v2 + 8) = 0;
  *(void *)(v2 + 16) = 0;
  *(void *)uint64_t v2 = 0;
  *(_WORD *)(v2 + 22) = 3;
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndObject(uint64_t a1, unsigned int a2)
{
  unint64_t v3 = (_WORD *)(*(void *)(a1 + 64) - 48 * a2);
  *(void *)(a1 + 64) = v3;
  uint64_t v4 = *(void *)(a1 + 24);
  *(v3 - 1) = 3;
  if (a2)
  {
    uint64_t v5 = 48 * a2;
    uint64_t v6 = (void *)rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Malloc(v4, v5);
    *((void *)v3 - 2) = v6;
    memcpy(v6, v3, v5);
  }
  else
  {
    *((void *)v3 - 2) = 0;
  }
  *((_DWORD *)v3 - 6) = a2;
  *((_DWORD *)v3 - 5) = a2;
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::StartArray(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (*(void *)(a1 + 72) - v2 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    uint64_t v2 = *(void *)(a1 + 64);
  }
  *(void *)(a1 + 64) = v2 + 24;
  *(void *)(v2 + 8) = 0;
  *(void *)(v2 + 16) = 0;
  *(void *)uint64_t v2 = 0;
  *(_WORD *)(v2 + 22) = 4;
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::EndArray(uint64_t a1, unsigned int a2)
{
  unint64_t v3 = (_WORD *)(*(void *)(a1 + 64) - 24 * a2);
  *(void *)(a1 + 64) = v3;
  uint64_t v4 = *(void *)(a1 + 24);
  *(v3 - 1) = 4;
  if (a2)
  {
    uint64_t v5 = 24 * a2;
    uint64_t v6 = (void *)rapidjson::MemoryPoolAllocator<re::internal::RapidJSONAllocator>::Malloc(v4, v5);
    *((void *)v3 - 2) = v6;
    memcpy(v6, v3, v5);
  }
  else
  {
    *((void *)v3 - 2) = 0;
  }
  *((_DWORD *)v3 - 6) = a2;
  *((_DWORD *)v3 - 5) = a2;
  return 1;
}

uint64_t rapidjson::GenericReader<rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>::NumberStream<re::internal::RapidJSONInputStream,char,true,false>::Pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(unsigned char **)(v2 + 24);
  if ((uint64_t)(*(void *)(v2 + 32) - (void)v3) <= 0)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*(void *)(a1 + 8), 1);
    unint64_t v3 = *(unsigned char **)(v2 + 24);
  }
  *(void *)(v2 + 24) = v3 + 1;
  *unint64_t v3 = 0;
  uint64_t v4 = (*(_DWORD *)(a1 + 16) + 1);
  *(_DWORD *)(a1 + 16) = v4;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t result = *(void *)(v5 + 24) - v4;
  *(void *)(v5 + 24) = result;
  return result;
}

double rapidjson::internal::StrtodFullPrecision<char>(unsigned int a1, char *a2, int a3, int a4, int a5, double a6)
{
  double v20 = 0.0;
  if (a1 - 23 >= 0xF)
  {
    if (a6 <= 9.00719925e15 && a1 + 22 < 0x2D)
    {
      if ((a1 & 0x80000000) != 0) {
        return a6 / rapidjson::internal::Pow10(int)::e[-a1];
      }
      return a6 * rapidjson::internal::Pow10(int)::e[a1];
    }
  }
  else
  {
    a6 = rapidjson::internal::Pow10(int)::e[a1 - 22] * a6;
    if (a6 <= 9.00719925e15)
    {
      a1 = 22;
      return a6 * rapidjson::internal::Pow10(int)::e[a1];
    }
  }
  int v8 = a4 - a3 + a5;
  int v9 = a3 - 1;
  if (a3 < 1)
  {
    if (!a3) {
      return 0.0;
    }
  }
  else
  {
    uint64_t v10 = a3;
    int v11 = a3 + 1;
    while (*a2 == 48)
    {
      ++a2;
      --v9;
      --v10;
      if (--v11 <= 1) {
        return 0.0;
      }
    }
    while (a2[v9] == 48)
    {
      --v10;
      ++v8;
      --v9;
      if ((unint64_t)(v10 + 1) <= 1) {
        return 0.0;
      }
    }
    a3 = v10;
  }
  int v12 = a3 - 768;
  if (a3 >= 768) {
    unint64_t v13 = 768;
  }
  else {
    unint64_t v13 = a3;
  }
  if (a3 <= 768) {
    int v12 = 0;
  }
  unsigned int v14 = (const rapidjson::internal::BigInteger *)(v12 + v8);
  double v7 = 0.0;
  if ((int)v14 + (int)v13 >= -323)
  {
    if ((int)v14 + (int)v13 <= 309)
    {
      BOOL v15 = rapidjson::internal::StrtodDiyFp<char>((uint64_t)a2, v13, (int)v14, (unint64_t *)&v20);
      double v7 = v20;
      if (!v15)
      {
        rapidjson::internal::BigInteger::BigInteger<char>(v21, a2, v13);
        int v16 = rapidjson::internal::CheckWithinHalfULP((rapidjson::internal *)v21, v7, v14);
        *(void *)&double v17 = *(void *)&v7 + 1;
        if (LOBYTE(v7)) {
          *(void *)&double v18 = *(void *)&v7 + 1;
        }
        else {
          double v18 = v7;
        }
        if (!v16) {
          double v17 = v18;
        }
        if (v16 >= 0) {
          return v17;
        }
      }
    }
    else
    {
      return INFINITY;
    }
  }
  return v7;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Double(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (*(void *)(a1 + 72) - v4 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    uint64_t v4 = *(void *)(a1 + 64);
  }
  *(void *)(a1 + 64) = v4 + 24;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(double *)uint64_t v4 = a2;
  *(_WORD *)(v4 + 22) = 534;
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Int64(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (*(void *)(a1 + 72) - v4 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    uint64_t v4 = *(void *)(a1 + 64);
  }
  *(void *)(a1 + 64) = v4 + 24;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = a2;
  *(_WORD *)(v4 + 22) = 150;
  if ((a2 & 0x8000000000000000) != 0)
  {
    if (a2 >= 0xFFFFFFFF80000000)
    {
      __int16 v6 = 182;
      goto LABEL_11;
    }
  }
  else
  {
    if (HIDWORD(a2)) {
      __int16 v5 = 406;
    }
    else {
      __int16 v5 = 470;
    }
    *(_WORD *)(v4 + 22) = v5;
    if (!(a2 >> 31))
    {
      __int16 v6 = v5 | 0x20;
LABEL_11:
      *(_WORD *)(v4 + 22) = v6;
    }
  }
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Uint64(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (*(void *)(a1 + 72) - v4 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    uint64_t v4 = *(void *)(a1 + 64);
  }
  *(void *)(a1 + 64) = v4 + 24;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = a2;
  if (a2 < 0) {
    __int16 v5 = 278;
  }
  else {
    __int16 v5 = 406;
  }
  *(_WORD *)(v4 + 22) = v5;
  if (!HIDWORD(a2))
  {
    *(_WORD *)(v4 + 22) = v5 | 0x40;
    if (!((unint64_t)a2 >> 31)) {
      *(_WORD *)(v4 + 22) = v5 | 0x60;
    }
  }
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Int(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (*(void *)(a1 + 72) - v4 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    uint64_t v4 = *(void *)(a1 + 64);
  }
  *(void *)(a1 + 64) = v4 + 24;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = a2;
  if (a2 < 0) {
    __int16 v5 = 182;
  }
  else {
    __int16 v5 = 502;
  }
  *(_WORD *)(v4 + 22) = v5;
  return 1;
}

uint64_t rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::Uint(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (*(void *)(a1 + 72) - v4 <= 23)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>>(a1 + 40, 1);
    uint64_t v4 = *(void *)(a1 + 64);
  }
  *(void *)(a1 + 64) = v4 + 24;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = 0;
  *(void *)uint64_t v4 = a2;
  if (a2 < 0) {
    __int16 v5 = 470;
  }
  else {
    __int16 v5 = 502;
  }
  *(_WORD *)(v4 + 22) = v5;
  return 1;
}

BOOL rapidjson::internal::StrtodDiyFp<char>(uint64_t a1, int a2, int a3, unint64_t *a4)
{
  if (a2 < 1)
  {
    LODWORD(v6) = 0;
    unint64_t v7 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    while (1)
    {
      int v8 = *(char *)(a1 + v6);
      if (v7 == 0x1999999999999999 && v8 > 53) {
        break;
      }
      unint64_t v7 = (v8 - 48) + 10 * v7;
      if (++v6 >= (unint64_t)a2 || v7 > 0x1999999999999999) {
        goto LABEL_10;
      }
    }
    unint64_t v7 = 0x1999999999999999;
  }
LABEL_10:
  if (a2 > (int)v6 && *(char *)(a1 + v6) > 52) {
    ++v7;
  }
  int v9 = a2 - v6;
  int v10 = __clz(v7);
  unint64_t v44 = v7 << v10;
  int v45 = -v10;
  uint64_t v11 = (4 * (v9 != 0)) << v10;
  int v12 = v9 + a3;
  unsigned int v13 = (v9 + a3 + 348) >> 3;
  unsigned int v14 = ((v9 + a3 + 348) & 0xFFFFFFF8) - 348;
  uint64_t v15 = rapidjson::internal::GetCachedPowerByIndex(unsigned long)::kCachedPowers_F[v13];
  uint64_t v16 = rapidjson::internal::GetCachedPowerByIndex(unsigned long)::kCachedPowers_E[v13];
  v43[0] = v15;
  v43[1] = v16;
  int v17 = v12 - v14;
  if (v12 != v14)
  {
    {
      rapidjson::internal::StrtodDiyFp<char>(char const*,int,int,double *)::kPow10[0] = 0xA000000000000000;
      dword_2687732F8 = -60;
      qword_268773300 = 0xC800000000000000;
      dword_268773308 = -57;
      qword_268773310 = 0xFA00000000000000;
      dword_268773318 = -54;
      qword_268773320 = 0x9C40000000000000;
      dword_268773328 = -50;
      qword_268773330 = 0xC350000000000000;
      dword_268773338 = -47;
      qword_268773340 = 0xF424000000000000;
      dword_268773348 = -44;
      qword_268773350 = 0x9896800000000000;
      dword_268773358 = -40;
    }
    unint64_t v44 = rapidjson::internal::DiyFp::operator*(&v44, &rapidjson::internal::StrtodDiyFp<char>(char const*,int,int,double *)::kPow10[2 * v17 - 2]);
    int v45 = v18;
    if (v17 + a2 > 19) {
      v11 += 4;
    }
  }
  unint64_t v19 = rapidjson::internal::DiyFp::operator*(&v44, v43);
  uint64_t v21 = 8;
  if (v11) {
    uint64_t v21 = 9;
  }
  int v22 = __clz(v19);
  unint64_t v23 = v19 << v22;
  int v24 = v20 - v22;
  uint64_t v25 = (v21 + v11) << v22;
  int v26 = v20 - v22 + 1138;
  if (v24 < -1137) {
    int v26 = 0;
  }
  if (v24 > -1086) {
    int v26 = 53;
  }
  int v27 = 64 - v26;
  unint64_t v28 = v23 >> (4 - v26);
  uint64_t v29 = (v25 >> (4 - v26)) + 9;
  BOOL v30 = v26 <= 3;
  if (v26 <= 3) {
    int v31 = 4 - v26 + v24;
  }
  else {
    int v31 = v24;
  }
  if (v30) {
    unint64_t v23 = v28;
  }
  if (v30)
  {
    int v32 = 60;
  }
  else
  {
    LODWORD(v29) = v25;
    int v32 = v27;
  }
  unint64_t v33 = v23 >> v32;
  int v34 = v32 + v31;
  unint64_t v35 = 8 * (v23 & ~(-1 << v32));
  uint64_t v36 = 8 << (v32 - 1);
  unint64_t v37 = v36 + v29;
  if (v35 >= v37 && (++v33 & 0x20000000000000) != 0)
  {
    v33 >>= 1;
    ++v34;
  }
  if (v34 >= -1074)
  {
    if (v34 <= 971)
    {
      BOOL v39 = (v33 & 0x10000000000000) == 0 && v34 == -1074;
      unint64_t v40 = (unint64_t)(v34 + 1075) << 52;
      if (v39) {
        unint64_t v40 = 0;
      }
      unint64_t v38 = v40 & 0xFFF0000000000000 | v33 & 0xFFFFFFFFFFFFFLL;
    }
    else
    {
      unint64_t v38 = 0x7FF0000000000000;
    }
  }
  else
  {
    unint64_t v38 = 0;
  }
  *a4 = v38;
  return v36 - (unint64_t)v29 >= v35 || v35 >= v37;
}

uint64_t rapidjson::internal::CheckWithinHalfULP(rapidjson::internal *this, double a2, const rapidjson::internal::BigInteger *a3)
{
  unint64_t v3 = (void *)MEMORY[0x270FA5388](this);
  BOOL v6 = (v5 & 0x7FF0000000000000) != 0;
  if ((v5 & 0xFFFFFFFFFFFFFLL) == 0) {
    BOOL v6 = 1;
  }
  int v7 = ((v5 >> 52) & 0x7FF) - 1075;
  if (v6) {
    uint64_t v8 = v5 & 0xFFFFFFFFFFFFFLL | 0x10000000000000;
  }
  else {
    uint64_t v8 = v5 & 0xFFFFFFFFFFFFFLL;
  }
  if (!v6) {
    int v7 = -1074;
  }
  int v9 = v7 - 1;
  unsigned int v10 = v4 & ~(v4 >> 31);
  if (v4 < 0) {
    unsigned int v11 = -v4;
  }
  else {
    unsigned int v11 = 0;
  }
  BOOL v12 = v7 <= 0;
  if (v7 < 0) {
    int v13 = v7;
  }
  else {
    int v13 = 0;
  }
  unsigned int v14 = (v7 & ~(v7 >> 31)) + v11;
  if (v12) {
    int v15 = v9;
  }
  else {
    int v15 = 0;
  }
  if (v12) {
    int v9 = 0;
  }
  signed int v16 = v10 - (v13 + v15);
  signed int v17 = v14 - v15;
  signed int v18 = v11 - v13 + v9;
  if (v16 >= v17) {
    signed int v19 = v17;
  }
  else {
    signed int v19 = v10 - (v13 + v15);
  }
  if (v19 >= v18) {
    signed int v19 = v18;
  }
  unint64_t v20 = (v16 - v19);
  unint64_t v21 = (v17 - v19);
  unint64_t v22 = (v18 - v19);
  uint64_t v37 = v3[416];
  memcpy(v36, v3, 8 * v37);
  unint64_t v23 = rapidjson::internal::BigInteger::MultiplyPow5((rapidjson::internal::BigInteger *)v36, v10);
  rapidjson::internal::BigInteger::operator<<=(v23, v20);
  v35[416] = 1;
  v35[0] = v8;
  int v24 = rapidjson::internal::BigInteger::MultiplyPow5((rapidjson::internal::BigInteger *)v35, v11);
  rapidjson::internal::BigInteger::operator<<=(v24, v21);
  unint64_t v34 = 1;
  v33[0] = 1;
  uint64_t v25 = rapidjson::internal::BigInteger::MultiplyPow5((rapidjson::internal::BigInteger *)v33, v11);
  rapidjson::internal::BigInteger::operator<<=(v25, v22);
  unint64_t v32 = 1;
  v31[0] = 0;
  rapidjson::internal::BigInteger::Difference((uint64_t)v36, (uint64_t)v35, (uint64_t)v31);
  unint64_t v26 = v32;
  BOOL v27 = v32 >= v34;
  if (v32 == v34)
  {
    while (v26)
    {
      unint64_t v28 = v31[v26 - 1];
      unint64_t v29 = v33[--v26];
      BOOL v27 = v28 >= v29;
      if (v28 != v29) {
        goto LABEL_28;
      }
    }
    return 0;
  }
  else
  {
LABEL_28:
    if (v27) {
      return 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
}

unint64_t *rapidjson::internal::BigInteger::BigInteger<char>(unint64_t *a1, char *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  int v4 = a2;
  a1[416] = 1;
  *a1 = 0;
  if (a3 < 0x13)
  {
    uint64_t v9 = 0;
    if (!a3) {
      return a1;
    }
LABEL_7:
    rapidjson::internal::BigInteger::AppendDecimal64<char>(a1, &v4[v9], &v4[v9 + v3]);
    return a1;
  }
  uint64_t v6 = 0;
  do
  {
    int v7 = a2 + 19;
    rapidjson::internal::BigInteger::AppendDecimal64<char>(a1, a2, a2 + 19);
    v6 -= 19;
    uint64_t v8 = v3 + v6;
    a2 = v7;
  }
  while (v3 + v6 > 0x12);
  uint64_t v9 = -v6;
  v3 += v6;
  if (v8) {
    goto LABEL_7;
  }
  return a1;
}

unint64_t *rapidjson::internal::BigInteger::AppendDecimal64<char>(unint64_t *result, char *a2, char *a3)
{
  if (a2 == a3)
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    int v4 = a2;
    do
    {
      int v5 = *v4++;
      uint64_t v3 = (v5 - 48) + 10 * v3;
    }
    while (v4 != a3);
  }
  if (result[416] == 1 && !*result)
  {
    *uint64_t result = v3;
    result[416] = 1;
  }
  else
  {
    unsigned int v6 = a3 - a2;
    unint64_t v7 = v6;
    uint64_t v8 = rapidjson::internal::BigInteger::MultiplyPow5((rapidjson::internal::BigInteger *)result, v6);
    uint64_t v9 = rapidjson::internal::BigInteger::operator<<=(v8, v7);
    return rapidjson::internal::BigInteger::operator+=(v9, v3);
  }
  return result;
}

rapidjson::internal::BigInteger *rapidjson::internal::BigInteger::MultiplyPow5(rapidjson::internal::BigInteger *this, unsigned int a2)
{
  if (a2)
  {
    unsigned int v3 = a2;
    if (a2 >= 0x1B)
    {
      do
      {
        rapidjson::internal::BigInteger::operator*=((unint64_t *)this, 0x6765C793FA10079DuLL);
        v3 -= 27;
      }
      while (v3 > 0x1A);
    }
    if (v3 >= 0xD)
    {
      do
      {
        rapidjson::internal::BigInteger::operator*=((unint64_t *)this, 0x48C27395u);
        v3 -= 13;
      }
      while (v3 > 0xC);
    }
    if (v3) {
      rapidjson::internal::BigInteger::operator*=((unint64_t *)this, rapidjson::internal::BigInteger::MultiplyPow5::kPow5[v3 - 1]);
    }
  }
  return this;
}

void *rapidjson::internal::BigInteger::operator<<=(void *__src, unint64_t a2)
{
  uint64_t v3 = __src[416];
  if (v3 == 1)
  {
    BOOL v4 = *__src == 0;
    if (!a2) {
      return __src;
    }
  }
  else
  {
    BOOL v4 = 0;
    if (!a2) {
      return __src;
    }
  }
  if (!v4)
  {
    unint64_t v5 = a2 >> 6;
    char v6 = a2 & 0x3F;
    if ((a2 & 0x3F) != 0)
    {
      __src[v3] = 0;
      if (v3)
      {
        uint64_t v7 = v3;
        do
        {
          __src[v5 + v7] = (__src[v7] << v6) | (__src[v7 - 1] >> 1 >> (v6 ^ 0x3Fu));
          --v7;
        }
        while (v7);
      }
      __src[v5] = *__src << v6;
      uint64_t v8 = v3 + v5;
      __src[416] = v8;
      if (!__src[v8]) {
        goto LABEL_14;
      }
      unint64_t v9 = v8 + 1;
    }
    else
    {
      memmove(&__src[v5], __src, 8 * v3);
      unint64_t v9 = __src[416] + v5;
    }
    __src[416] = v9;
LABEL_14:
    bzero(__src, 8 * v5);
  }
  return __src;
}

unint64_t *rapidjson::internal::BigInteger::operator+=(unint64_t *result, uint64_t a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = *result + a2;
  *uint64_t result = v3;
  unint64_t v4 = result[416];
  if (v4 == 1)
  {
LABEL_5:
    if (result[v4 - 1] < v2)
    {
      result[416] = v4 + 1;
      result[v4] = 1;
    }
  }
  else
  {
    unint64_t v5 = result + 1;
    unint64_t v6 = v4 - 1;
    while (v3 < v2)
    {
      unint64_t v2 = *v5;
      unint64_t v3 = *v5 + 1;
      *v5++ = v3;
      if (!--v6) {
        goto LABEL_5;
      }
    }
  }
  return result;
}

unint64_t *rapidjson::internal::BigInteger::operator*=(unint64_t *result, unint64_t a2)
{
  if (a2 != 1)
  {
    if (!a2)
    {
      *uint64_t result = 0;
LABEL_4:
      result[416] = 1;
      return result;
    }
    unint64_t v2 = result[416];
    if (v2)
    {
      if (v2 == 1 && *result == 1)
      {
        *uint64_t result = a2;
        goto LABEL_4;
      }
      unint64_t v3 = 0;
      unsigned int v4 = a2;
      unint64_t v5 = HIDWORD(a2);
      unint64_t v6 = result;
      unint64_t v7 = result[416];
      do
      {
        unsigned int v8 = *v6;
        unint64_t v9 = HIDWORD(*v6);
        unint64_t v10 = v8 * (unint64_t)v4;
        unint64_t v11 = v9 * (unint64_t)v4;
        unint64_t v12 = v9 * (unint64_t)v5;
        unint64_t v13 = v8 * (unint64_t)v5 + v11 + HIDWORD(v10);
        unint64_t v14 = v12 + 0x100000000;
        if (v13 >= v11) {
          unint64_t v14 = v12;
        }
        unint64_t v15 = v14 + HIDWORD(v13);
        unint64_t v16 = v3 + v10 + (v13 << 32);
        if (v16 >= v3) {
          unint64_t v3 = v15;
        }
        else {
          unint64_t v3 = v15 + 1;
        }
        *v6++ = v16;
        --v7;
      }
      while (v7);
      if (v3)
      {
        result[416] = v2 + 1;
        result[v2] = v3;
      }
    }
  }
  return result;
}

unint64_t *rapidjson::internal::BigInteger::operator*=(unint64_t *result, unsigned int a2)
{
  if (a2 != 1)
  {
    if (!a2)
    {
      *uint64_t result = 0;
LABEL_4:
      result[416] = 1;
      return result;
    }
    unint64_t v2 = result[416];
    if (v2)
    {
      if (v2 == 1 && *result == 1)
      {
        *uint64_t result = a2;
        goto LABEL_4;
      }
      unint64_t v3 = 0;
      unsigned int v4 = result;
      unint64_t v5 = result[416];
      do
      {
        unint64_t v6 = v3 + *v4 * (unint64_t)a2;
        unint64_t v7 = HIDWORD(v6) + HIDWORD(*v4) * a2;
        *v4++ = v6 | ((unint64_t)v7 << 32);
        unint64_t v3 = HIDWORD(v7);
        --v5;
      }
      while (v5);
      if (v3)
      {
        result[416] = v2 + 1;
        result[v2] = v3;
      }
    }
  }
  return result;
}

uint64_t rapidjson::internal::BigInteger::Difference(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a1 + 3328);
  unint64_t v4 = *(void *)(a2 + 3328);
  BOOL v5 = v3 >= v4;
  if (v3 == v4)
  {
    uint64_t v6 = *(void *)(a1 + 3328);
    while (v6)
    {
      uint64_t v7 = a1 + 8 * v6;
      uint64_t v8 = a2 + 8 * v6--;
      unint64_t v9 = *(void *)(v7 - 8);
      unint64_t v10 = *(void *)(v8 - 8);
      BOOL v5 = v9 >= v10;
      if (v9 != v10) {
        goto LABEL_5;
      }
    }
LABEL_9:
    uint64_t v11 = a1;
    a1 = a2;
    if (!v3) {
      return v6;
    }
    goto LABEL_10;
  }
LABEL_5:
  if (v5)
  {
    uint64_t v6 = 0;
    goto LABEL_9;
  }
  uint64_t v6 = 1;
  unint64_t v3 = *(void *)(a2 + 3328);
  uint64_t v11 = a2;
  if (!v3) {
    return v6;
  }
LABEL_10:
  unint64_t v12 = 0;
  uint64_t v13 = 0;
  do
  {
    unint64_t v14 = *(void *)(v11 + 8 * v12);
    unint64_t v15 = v14 + v13;
    if (v12 < *(void *)(a1 + 3328)) {
      v15 -= *(void *)(a1 + 8 * v12);
    }
    if (v15 <= v14) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = -1;
    }
    *(void *)(a3 + 8 * v12++) = v15;
    if (v15)
    {
      *(void *)(a3 + 3328) = v12;
      unint64_t v3 = *(void *)(v11 + 3328);
    }
  }
  while (v12 < v3);
  return v6;
}

void *rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::ShrinkToFit(void *result)
{
  unint64_t v2 = (unsigned char *)result[2];
  uint64_t v1 = (unsigned char *)result[3];
  unint64_t v3 = result + 2;
  size_t v4 = v1 - v2;
  if (v1 == v2)
  {
    if (v1) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*(void *)re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance
    }
                                                           + 40))(re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance);
    *unint64_t v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
  }
  else
  {
    BOOL v5 = result;
    uint64_t result = re::internal::RapidJSONAllocator::Realloc((re::internal::RapidJSONAllocator *)*result, v2, result[4] - (void)v2, v4);
    _OWORD v5[2] = result;
    v5[3] = (char *)result + v4;
    v5[4] = (char *)result + v4;
  }
  return result;
}

void re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 192);
  uint64_t v6 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = *v6;
    v9[0] = v5;
    v9[1] = v8;
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::registerSerializeFunc(a1, (uint64_t)v9, a3);
  }
}

uint64_t re::serializeBool<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **((void **)a5 + 2);
      uint64_t v15 = **((void **)a6 + 2);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<BOOL>(a1 + 24, a2, a4, a7);
}

uint64_t re::serializeChar<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **((void **)a5 + 2);
      uint64_t v15 = **((void **)a6 + 2);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<char>(a1 + 24, a2, a4, a7);
}

uint64_t re::serializeI8<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **((void **)a5 + 2);
      uint64_t v15 = **((void **)a6 + 2);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<signed char>(a1 + 24, a2, a4, a7);
}

uint64_t re::serializeI16<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **((void **)a5 + 2);
      uint64_t v15 = **((void **)a6 + 2);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<short>(a1 + 24, a2, a4, a7);
}

uint64_t re::serializeI32<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **((void **)a5 + 2);
      uint64_t v15 = **((void **)a6 + 2);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<int>(a1 + 24, a2, a4, a7);
}

uint64_t re::serializeI64<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **((void **)a5 + 2);
      uint64_t v15 = **((void **)a6 + 2);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<long long>(a1 + 24, a2, a4, a7);
}

uint64_t re::serializeU8<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint8", a7);
}

uint64_t re::serializeU16<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **((void **)a5 + 2);
      uint64_t v15 = **((void **)a6 + 2);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned short>(a1 + 24, a2, a4, a7);
}

uint64_t re::serializeU32<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint32", a7);
}

uint64_t re::serializeU64<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **((void **)a5 + 2);
      uint64_t v15 = **((void **)a6 + 2);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned long long>(a1 + 24, a2, a4, a7);
}

uint64_t re::serializeFloat<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"float", a7);
}

uint64_t re::serializeDouble<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::SeekableInputStream>::serializeValue<double>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"double", a7);
}

BOOL re::serializeCString<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_22:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v23 = **((void **)a5 + 2);
    uint64_t v24 = **((void **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24) {
      goto LABEL_22;
    }
    BOOL v26 = WORD1(v23) == WORD1(v24);
    uint64_t v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    BOOL v26 = v26 && v25 == 0;
    if (!v26) {
      goto LABEL_22;
    }
  }
LABEL_4:
  if (a7)
  {
    int v48 = 0;
    BOOL v19 = re::EncoderBinary<re::SeekableInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
    BOOL result = 0;
    if (!v19) {
      return result;
    }
    if (!v48) {
      goto LABEL_12;
    }
    if (v48 != 1)
    {
      size_t v47 = 0;
      if (re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v47, 0))
      {
        if (v47) {
          re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
        }
        re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
LABEL_12:
      re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      goto LABEL_47;
    }
    goto LABEL_16;
  }
  int v48 = 2 * (*a4 != 0);
  BOOL v21 = re::EncoderBinary<re::SeekableInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
  BOOL result = 0;
  if (!v21) {
    return result;
  }
  int v22 = v48;
  if (v48)
  {
    if (v48 == 1)
    {
LABEL_16:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, v46);
      return 0;
    }
  }
  else
  {
    if (!*a4) {
      goto LABEL_44;
    }
    (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
    *a4 = 0;
    int v22 = v48;
  }
  if (v22 == 2)
  {
    size_t v27 = *a4 ? strlen(*a4) : 0;
    size_t v47 = v27;
    if (re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v47, 0))
    {
      unint64_t v28 = (char *)*a4;
      unint64_t v29 = v47;
      if (!*a4 || v47 != v27)
      {
        if (v28)
        {
          (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
          *a4 = 0;
          unint64_t v29 = v47;
        }
        unint64_t v30 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
        char v36 = v47;
        if (v29 > v30)
        {
          (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v37, v38, v39, v40, v41, v36);
          return 0;
        }
        uint64_t v42 = v47 == -1;
        uint64_t v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, v47);
          return 0;
        }
        unint64_t v28 = (char *)(*(uint64_t (**)(void, size_t, void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v47 + 1, 0);
        *a4 = v28;
        size_t v27 = v47;
      }
      if (v27)
      {
        re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, v28, 0);
        unint64_t v28 = (char *)*a4;
        size_t v44 = v47;
      }
      else
      {
        size_t v44 = 0;
      }
      v28[v44] = 0;
      re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    }
  }
LABEL_44:
  re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  int v45 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(unsigned char *)(a1 + 64)) {
    return v45 == 0;
  }
  (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  int v45 = *(unsigned __int8 *)(a1 + 64);
  return v45 == 0;
}

BOOL re::serializeStringID<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (BOOL v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v47 = 0;
    BOOL v20 = re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v47, 0);
    BOOL result = 0;
    if (!v20) {
      return result;
    }
    if (v47) {
      re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    }
    goto LABEL_26;
  }
  unint64_t v46 = 0;
  if (re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v46, 0))
  {
    unint64_t v22 = v46;
    if (v46)
    {
      unint64_t v23 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
      char v29 = v46;
      if (v22 > v23)
      {
        (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v30, v31, v32, v33, v34, v29);
        return 0;
      }
      uint64_t v36 = v46 == -1;
      uint64_t v37 = v36 << 63 >> 63;
      if (v37 != v36 || v37 < 0)
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v24, v25, v26, v27, v28, v46);
        return 0;
      }
      uint64_t v38 = (char *)(*(uint64_t (**)(void, unint64_t, void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56), v46 + 1, 0);
      uint64_t v39 = (_anonymous_namespace_ *)re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, v38, 0);
      v38[v46] = 0;
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v40 = v44;
      uint64_t v41 = v45;
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v42 = *a4;
      uint64_t v43 = a4[1];
      *a4 = v40;
      a4[1] = (uint64_t)v41;
      unint64_t v47 = v40 & 0xFFFFFFFFFFFFFFFELL | v42 & 1;
      uint64_t v48 = v43;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
      (*(void (**)(void, char *))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v38);
    }
    else
    {
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v35 = a4[1];
      unint64_t v47 = *a4 & 1;
      uint64_t v48 = v35;
      *a4 = 0;
      a4[1] = (uint64_t)"";
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
    }
LABEL_26:
    re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v27 = **((void **)a5 + 2);
    uint64_t v28 = **((void **)a6 + 2);
    if ((unsigned __int16)v27 == (unsigned __int16)v28)
    {
      BOOL v30 = WORD1(v27) == WORD1(v28);
      uint64_t v29 = (v28 ^ v27) & 0xFFFFFF00000000;
      BOOL v30 = v30 && v29 == 0;
      if (v30) {
        goto LABEL_4;
      }
    }
LABEL_32:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_32;
  }
LABEL_4:
  if (a7)
  {
    uint64_t v31 = 0;
    BOOL v14 = re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v31, 0);
    BOOL result = 0;
    if (!v14) {
      return result;
    }
    if (v31) {
      re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    }
    re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
  }
  else
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v31 = *(void *)a5;
    uint64_t v32 = v16;
    LODWORD(v33) = -1;
    *(void *)buf = 0x258C98EAAF29A10ALL;
    *(void *)&buf[8] = "CallbackSerializerAttribute";
    BOOL v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v31, buf);
    re::StringID::destroyString((re::StringID *)buf);
    uint64_t v18 = *v17;
    uint64_t v19 = *(void *)(a1 + 184);
    unint64_t v35 = 0;
    BOOL result = re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v35, 0);
    if (!result) {
      return result;
    }
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v31 = v20;
    uint64_t v32 = 0;
    re::DynamicString::setCapacity(&v31, 0);
    if (v35)
    {
      re::DynamicString::resize(&v31, v35, 0);
      if (v32) {
        BOOL v21 = v33;
      }
      else {
        BOOL v21 = (char *)&v32 + 1;
      }
      re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, v21, 0);
    }
    re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    unint64_t v22 = (char *)&v32 + 1;
    if (v32) {
      unint64_t v23 = v33;
    }
    else {
      unint64_t v23 = (char *)&v32 + 1;
    }
    uint64_t v24 = (re *)(*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, char *))(v18 + 80))(*(void *)(a1 + 48), v19, v18, a4, v23);
    if ((v24 & 1) == 0)
    {
      uint64_t v25 = *re::foundationSerializationLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        if (v32) {
          unint64_t v22 = v33;
        }
        uint64_t v26 = re::TypeInfo::name(a5)[1];
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v22;
        __int16 v37 = 2080;
        uint64_t v38 = v26;
        _os_log_impl(&dword_233120000, v25, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);
      }
    }
    if (v31 && (v32 & 1) != 0) {
      (*(void (**)(void))(*(void *)v31 + 40))();
    }
  }
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::EncoderBinary<re::SeekableInputStream>::beginPointer(_anonymous_namespace_ *a1, const char *a2, uint64_t a3, int *a4, int a5)
{
  if (*((unsigned char *)a1 + 40)) {
    return 0;
  }
  char v22 = 78;
  re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned char>((uint64_t)a1, a2, 0, &v22, (uint64_t)"uint8", 2);
  switch(v22)
  {
    case 'I':
      int v10 = 2;
      break;
    case 'N':
      int v10 = 0;
      uint64_t v11 = 0;
      goto LABEL_10;
    case 'R':
      int v10 = 1;
      break;
    default:
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, 0, (re::DynamicString *)&v18);
      if (v19) {
        unint64_t v12 = *(unsigned char **)&v20[7];
      }
      else {
        unint64_t v12 = v20;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". Invalid tag.", (re::DynamicString *)v21, v12);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v21);
      if (*(void *)&v21[0])
      {
        if (BYTE8(v21[0])) {
          (*(void (**)(void))(**(void **)&v21[0] + 40))();
        }
        memset(v21, 0, sizeof(v21));
      }
      if (v18)
      {
        if (v19) {
          (*(void (**)(void))(*(void *)v18 + 40))();
        }
      }
      return 0;
  }
  uint64_t v11 = 1;
LABEL_10:
  *a4 = v10;
  LOBYTE(v13) = 9;
  DWORD1(v13) = a5;
  *((void *)&v13 + 1) = a2;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = v11;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v13);
  return *((unsigned char *)a1 + 40) == 0;
}

_anonymous_namespace_ *re::EncoderBinary<re::SeekableInputStream>::endPointer(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = (uint64_t)result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == *(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 24))
    {
      BOOL result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(result, 9);
      uint64_t v2 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      ++*(void *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v4);
      if (v5) {
        unint64_t v3 = *(unsigned char **)&v6[7];
      }
      else {
        unint64_t v3 = v6;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". No value was provided.", (re::DynamicString *)v7, v3);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v7);
      if (*(void *)&v7[0])
      {
        if (BYTE8(v7[0])) {
          (*(void (**)(void))(**(void **)&v7[0] + 40))();
        }
        memset(v7, 0, sizeof(v7));
      }
      BOOL result = v4;
      if (v4)
      {
        if (v5) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v4 + 40))();
        }
      }
    }
  }
  return result;
}

BOOL re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::serializeCString(uint64_t a1, const char *a2, const re::TypeInfo *a3, char **a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_15:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 != (unsigned __int16)v15) {
      goto LABEL_15;
    }
    BOOL v17 = WORD1(v14) == WORD1(v15);
    uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
    BOOL v17 = v17 && v16 == 0;
    if (!v17) {
      goto LABEL_15;
    }
  }
LABEL_4:
  int v50 = 0;
  if (re::EncoderBinary<re::SeekableInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v50, 0))
  {
    if (v50 == 1)
    {
      unsigned int v49 = 0;
      if (!*(unsigned char *)(a1 + 64))
      {
        re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, "ID", 0, (char *)&v49, (uint64_t)"Reference ID", 0);
        if (!*(unsigned char *)(a1 + 64))
        {
          if (*(void *)(a1 + 328) <= (unint64_t)v49)
          {
            re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid reference ID for shared object: %u", v19, v20, v21, v22, v23, v49);
          }
          else
          {
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v49, (uint64_t)&v45);
            if (v45 == *(void **)a5)
            {
              uint64_t v24 = **((void **)a5 + 2);
              if (v46 == (unsigned __int16)v24 && v47 == WORD1(v24) && ((v48 ^ HIDWORD(v24)) & 0xFFFFFF) == 0)
              {
                if ((a7 & 1) == 0)
                {
                  if (*a4)
                  {
                    uint64_t v42 = *a4;
                    if (v42 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v49))
                    {
                      (*(void (**)(void, char *))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), *a4);
                      *a4 = 0;
                    }
                  }
                  *a4 = (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v49);
                  re::internal::SharedObjectGraph::addReference((void *)(a1 + 256), v49);
                }
                goto LABEL_37;
              }
            }
            uint64_t v25 = *(_anonymous_namespace_ **)(a1 + 192);
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v49, (uint64_t)&v45);
            uint64_t v43 = *((void *)re::TypeRegistry::typeName(v25, &v45) + 1);
            re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid reference ID for shared object. Expected type \"char *\". Actual type \"%s\".", v26, v27, v28, v29, v30, v43);
          }
        }
      }
    }
    else
    {
      if (!v50)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
            *a4 = 0;
          }
        }
LABEL_37:
        re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        return *(unsigned char *)(a1 + 64) == 0;
      }
      if ((a7 & 1) == 0 && *a4)
      {
        (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
        *a4 = 0;
      }
      int v45 = 0;
      if (re::EncoderBinary<re::SeekableInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v45, 0))
      {
        uint64_t v36 = v45 == (void *)-1;
        uint64_t v37 = v36 << 63 >> 63;
        if (v37 == v36 && (v37 & 0x8000000000000000) == 0)
        {
          uint64_t v38 = (char *)(*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), (uint64_t)v45 + 1, 0);
          uint64_t v39 = (uint64_t)v38;
          if ((a7 & 1) == 0) {
            *a4 = v38;
          }
          uint64_t v40 = v45;
          if (v45)
          {
            re::EncoderBinary<re::SeekableInputStream>::serializeString(a1 + 24, v38, 0);
            uint64_t v40 = v45;
          }
          *((unsigned char *)v40 + v39) = 0;
          re::EncoderBinary<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
          uint64_t v41 = **((void **)a5 + 2);
          *(void *)&long long v44 = *(void *)a5;
          *((void *)&v44 + 1) = v41;
          re::internal::SharedObjectGraph::addObject(a1 + 256, v39, &v44);
          goto LABEL_37;
        }
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, (char)v45);
      }
    }
  }
  return 0;
}

BOOL re::SerializerV1<re::EncoderBinary<re::SeekableInputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  BOOL isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6) {
    goto LABEL_4;
  }
  if (*(void *)this == *(void *)a6)
  {
    uint64_t v26 = **((void **)this + 2);
    uint64_t v27 = **((void **)a6 + 2);
    if ((unsigned __int16)v26 == (unsigned __int16)v27)
    {
      BOOL v29 = WORD1(v26) == WORD1(v27);
      uint64_t v28 = (v27 ^ v26) & 0xFFFFFF00000000;
      BOOL v29 = v29 && v28 == 0;
      if (v29) {
        goto LABEL_4;
      }
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    int v16 = 0;
    goto LABEL_5;
  }
  if (*((unsigned char *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (uint64_t v30 = re::TypeInfo::name(this), v31 = re::TypeInfo::name(a6), !re::StringID::operator==(v30, v31))))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, this, a6);
    return 0;
  }
  int v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &buf);
  re::TypeInfo::TypeInfo((uint64_t)v70, (uint64_t)&buf + 8);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &buf);
  re::TypeInfo::TypeInfo((uint64_t)v69, (uint64_t)&buf + 8);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    BOOL v17 = *v71;
    v68[0] = (re *)v70[0];
    v68[1] = v17;
    if (v70[0]) {
      goto LABEL_8;
    }
LABEL_15:
    uint64_t v61 = re::TypeInfo::name(this)[1];
    uint64_t v23 = "Failed to get actual type of polymorphic object. Type \"%s\".";
    uint64_t v24 = a1;
    uint64_t v25 = a2;
LABEL_16:
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v24, v25, v23, v18, v19, v20, v21, v22, v61);
    return 0;
  }
  re::internal::actualType(a4, (void **)this, v68);
  if (!v68[0]) {
    goto LABEL_15;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v68, &buf);
  re::TypeInfo::TypeInfo((uint64_t)v66, (uint64_t)&buf + 8);
  int v65 = 0;
  if (re::EncoderBinary<re::SeekableInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, a3, &v65, 0))
  {
    if (v65 != 1)
    {
      if (!v65)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v66, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
            *a4 = 0;
          }
        }
        goto LABEL_64;
      }
      if (isPointerToPolymorphicType)
      {
        if (*(unsigned char *)(a1 + 64)) {
          goto LABEL_64;
        }
        LOBYTE(buf) = 1;
        DWORD1(buf) = 0;
        *((void *)&buf + 1) = a2;
        long long v79 = 0u;
        long long v80 = 0u;
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)(a1 + 24), &buf);
        uint64_t v77 = 0;
        if ((re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned long long>(a1 + 24, "customClassID", (char *)&v77, 0) & 1) == 0)goto LABEL_64; {
        re::TypeInfo::typeIDForCustomClassID((re::TypeInfo *)v69, v77, v76);
        }
        if (v76[0])
        {
          if ((a7 & 1) == 0 && *a4)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v66, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
            *a4 = 0;
          }
          re::TypeRegistry::typeInfo(v69[0], v76, &buf);
          uint64_t v37 = (re::TypeInfo *)re::TypeInfo::TypeInfo((uint64_t)v75, (uint64_t)&buf + 8);
          if (v16)
          {
            uint64_t v38 = *(re::TypeRegistry **)(a1 + 192);
          }
          else
          {
            uint64_t v38 = *(re::TypeRegistry **)(a1 + 192);
            if (*(re::TypeRegistry **)this == v38)
            {
              re::TypeInfo::operator=((uint64_t)v66, (uint64_t)v75);
              uint64_t v54 = v76[0];
              uint64_t v55 = v76[1];
              goto LABEL_79;
            }
          }
          uint64_t v52 = re::TypeInfo::name(v37);
          uint64_t v53 = re::TypeRegistry::typeInfo(v38, (const re::StringID *)v52, &buf);
          if (!(_BYTE)buf || !*(unsigned char *)(*((void *)&v79 + 1) + 120))
          {
            int v56 = *re::foundationSerializationLogObjects((re *)v53);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v57 = re::TypeInfo::name((re::TypeInfo *)v75)[1];
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v57;
              _os_log_impl(&dword_233120000, v56, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", (uint8_t *)&buf, 0xCu);
            }
            v74[0] = 0;
            v74[1] = 0xFFFFFFFFLL;
            (*(void (**)(uint64_t, void, void *))(*(void *)a1 + 16))(a1, 0, v74);
            if (!*(unsigned char *)(a1 + 64)) {
              (*(void (**)(uint64_t, const char *, uint64_t, void, re **, re **, uint64_t))(*(void *)a1 + 72))(a1, "object", 10, 0, v75, v75, 1);
            }
            goto LABEL_83;
          }
          re::TypeInfo::operator=((uint64_t)v66, (uint64_t)&buf + 8);
          uint64_t v54 = (re *)v66[0];
          uint64_t v55 = *(re **)v67;
LABEL_79:
          Instance = re::TypeInfo::createInstance((re::TypeInfo *)v66, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
          uint64_t v59 = Instance;
          if ((a7 & 1) == 0)
          {
            *a4 = (char *)Instance;
            v73[0] = v54;
            v73[1] = v55;
            re::internal::setActualType(a4, (re **)this, v73);
          }
          v72[0] = v54;
          v72[1] = v55;
          (*(void (**)(uint64_t, void **, void *))(*(void *)a1 + 16))(a1, v59, v72);
          if (!*(unsigned char *)(a1 + 64)) {
            (*(void (**)(uint64_t, const char *, uint64_t, void **, void *, re **, BOOL))(*(void *)a1 + 72))(a1, "object", 10, v59, v66, v75, v59 == 0);
          }
LABEL_83:
          (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
          re::EncoderBinary<re::SeekableInputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
          goto LABEL_64;
        }
        unsigned __int16 v46 = re::TypeInfo::name((re::TypeInfo *)v69);
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Unknown polymorphic \"%s\" type. Custom class ID = %llu", v47, v48, v49, v50, v51, v46[1]);
LABEL_64:
        re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        return *(unsigned char *)(a1 + 64) == 0;
      }
      if (!a7)
      {
        uint64_t v41 = *a4;
        if (!*a4) {
          uint64_t v41 = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v70, *(re::Allocator **)(a1 + 48), 0);
        }
        uint64_t v42 = 0;
        *a4 = v41;
        goto LABEL_60;
      }
      uint64_t v39 = *(re::TypeRegistry **)(a1 + 192);
      if ((re::TypeRegistry *)v70[0] != v39)
      {
        uint64_t v40 = re::TypeInfo::name((re::TypeInfo *)v70);
        re::TypeRegistry::typeInfo(v39, (const re::StringID *)v40, &buf);
        if (!(_BYTE)buf)
        {
          uint64_t v41 = 0;
          uint64_t v42 = 1;
          goto LABEL_60;
        }
        re::TypeInfo::operator=((uint64_t)v70, (uint64_t)&buf + 8);
      }
      uint64_t v41 = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v70, *(re::Allocator **)(a1 + 48), 0);
      uint64_t v42 = 0;
LABEL_60:
      uint64_t v43 = *v71;
      *(void *)&long long v62 = v70[0];
      *((void *)&v62 + 1) = v43;
      re::internal::SharedObjectGraph::beginObject((void *)(a1 + 256), (uint64_t)v41, &v62);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, char *, void *, re **, uint64_t))(*(void *)a1 + 72))(a1, a2, 0, v41, v70, v69, v42);
      }
      if (*(unsigned char *)(a1 + 256))
      {
        --*(void *)(a1 + 408);
        ++*(_DWORD *)(a1 + 416);
      }
      goto LABEL_64;
    }
    LODWORD(v76[0]) = 0;
    if (!*(unsigned char *)(a1 + 64))
    {
      re::EncoderBinary<re::SeekableInputStream>::serializeValue<unsigned int>(a1 + 24, "ID", 0, (char *)v76, (uint64_t)"Reference ID", 0);
      if (!*(unsigned char *)(a1 + 64))
      {
        if (*(void *)(a1 + 328) > (unint64_t)LODWORD(v76[0]))
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v76[0], (uint64_t)v64);
          if (!re::internal::areCompatible((re **)this, (uint64_t)v64))
          {
            uint64_t v44 = re::TypeInfo::name((re::TypeInfo *)v70)[1];
            int v45 = *(_anonymous_namespace_ **)(a1 + 192);
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v76[0], (uint64_t)&buf);
            LOBYTE(v61) = v44;
            re::TypeRegistry::typeName(v45, &buf);
            uint64_t v23 = "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".";
            goto LABEL_68;
          }
          if (a7) {
            goto LABEL_64;
          }
          if (*a4)
          {
            uint64_t v33 = *a4;
            if (v33 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v76[0]))
            {
              re::TypeInfo::releaseInstance((re::TypeInfo *)v66, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
              *a4 = 0;
            }
          }
          uint64_t v34 = re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v76[0]);
          uint64_t v35 = (char **)v34;
          *a4 = (char *)v34;
          if ((*(unsigned char *)(v67 + 49) & 2) != 0)
          {
            int v60 = *(void (**)(uint64_t))(v67 + 32);
            if (v60) {
              v60(v34);
            }
            re::internal::SharedObjectGraph::addReference((void *)(a1 + 256), v76[0]);
          }
          else
          {
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v76[0], (uint64_t)v75);
            if (!v75[0])
            {
              LOBYTE(v61) = v76[0];
              uint64_t v23 = "TypeID for shared object at index %d is invalid.";
              goto LABEL_68;
            }
            re::TypeRegistry::typeInfo(v75[0], v75, &buf);
            if (!(_BYTE)buf)
            {
              LOBYTE(v61) = v76[0];
              uint64_t v23 = "No TypeInfo found for shared object at index %d.";
              goto LABEL_68;
            }
            uint64_t v36 = re::TypeInfo::createInstance((re::TypeInfo *)((char *)&buf + 8), *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
            *a4 = (char *)v36;
            if ((re::TypeInfo::copy((re::TypeInfo *)((char *)&buf + 8), v36, v35, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184)) & 1) == 0)
            {
              uint64_t v61 = re::TypeInfo::name((re::TypeInfo *)((char *)&buf + 8))[1];
              uint64_t v23 = "Failed to copy non-shareable object of type '%s'.";
LABEL_68:
              uint64_t v24 = a1;
              uint64_t v25 = 0;
              goto LABEL_16;
            }
          }
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v76[0], (uint64_t)v63);
          re::TypeInfo::setActualTypeForPointer((void **)this, (uint64_t)a4, v63);
          goto LABEL_64;
        }
        LOBYTE(v61) = v76[0];
        uint64_t v23 = "Invalid reference ID for shared object: %u";
        goto LABEL_68;
      }
    }
  }
  return 0;
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::deserializeSharedObjects(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!*(unsigned char *)(result + 64))
  {
    uint64_t v9 = result;
    uint64_t v10 = result + 24;
    BOOL result = re::EncoderOPACK<re::SeekableInputStream>::beginObject(result + 24, "@shared", 20, 0);
    if (result)
    {
      uint64_t v16 = *(void *)(v9 + 56);
      long long v98 = 0;
      uint64_t v99 = 0;
      uint64_t v96 = v16;
      uint64_t v97 = 0;
      re::DynamicString::setCapacity(&v96, 8uLL);
      uint64_t v17 = v9 + 400;
      LODWORD(v90) = 0;
      uint64_t v18 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(v9 + 400, (unsigned int *)&v90);
      if (v18) {
        *((void *)&v95 + 1) = **(void **)(v18 + 24);
      }
      else {
        *((void *)&v95 + 1) = 0xFFFFFFFFLL;
      }
      if (*(void *)(v9 + 376))
      {
        uint64_t v77 = v10;
        uint64_t v19 = 0;
        unint64_t v20 = 0;
        LODWORD(v21) = *(_DWORD *)(v9 + 428) - 1;
        uint64_t v22 = (char *)&v97 + 1;
        do
        {
          uint64_t v23 = (long long *)(*(void *)(v9 + 392) + v19);
          long long v90 = *v23;
          re::TypeInfo::TypeInfo((uint64_t)v91, (uint64_t)(v23 + 1));
          re::TypeInfo::TypeInfo((uint64_t)v93, (uint64_t)(v23 + 3));
          __int16 v94 = *((_WORD *)v23 + 40);
          if ((v90 & 0x80000000) != 0)
          {
            re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, 0, "Invalid referenceID %u.", v24, v25, v26, v27, v28, v90);
            goto LABEL_71;
          }
          re::TypeRegistry::typeInfo((void *)v91[0], *(void *)(v92 + 72), &v80);
          re::TypeInfo::TypeInfo((uint64_t)v89, (uint64_t)&v81);
          re::TypeRegistry::typeInfo(v93[0], v93[2][9], &v80);
          re::TypeInfo::TypeInfo((uint64_t)&v85, (uint64_t)&v81);
          if ((int)v90 > (int)v21)
          {
            re::DynamicString::assignf((re::DynamicString *)&v96, "%u", v90);
            uint64_t v21 = v90;
            if ((_BYTE)v94)
            {
              if (v97) {
                BOOL v29 = v98;
              }
              else {
                BOOL v29 = v22;
              }
              if (!re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::SeekableInputStream>,false>(v9, v29, v90, *((void ***)&v90 + 1), v91, (re::TypeInfo *)v89, (re::TypeInfo *)&v85, HIBYTE(v94), 0))goto LABEL_64; {
            }
              }
            else
            {
              uint64_t v35 = v22;
              uint64_t v36 = **((void **)&v90 + 1);
              if (!**((void **)&v90 + 1))
              {
                Instance = re::TypeInfo::createInstance((re::TypeInfo *)v89, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                **((void **)&v90 + 1) = Instance;
                uint64_t v36 = **((void **)&v90 + 1);
              }
              char v38 = v97;
              uint64_t v39 = v98;
              re::TypeRegistry::typeInfo((void *)v91[0], *(void *)(v92 + 72), &v80);
              re::TypeInfo::TypeInfo((uint64_t)v84, (uint64_t)&v81);
              if (*(unsigned char *)(v9 + 64)) {
                goto LABEL_69;
              }
              if (v38) {
                uint64_t v40 = v39;
              }
              else {
                uint64_t v40 = v35;
              }
              uint64_t v22 = v35;
              char v41 = (*(uint64_t (**)(uint64_t, const char *, uint64_t, uint64_t, _DWORD *, uint64_t *, void))(*(void *)v9 + 72))(v9, v40, v21, v36, v84, &v85, 0);
              uint64_t v17 = v9 + 400;
              if ((v41 & 1) == 0)
              {
LABEL_64:
                if (!*(unsigned char *)(v9 + 64))
                {
                  if (v97) {
                    char v64 = v98;
                  }
                  else {
                    char v64 = v22;
                  }
                  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, v64, "Failed to deserialize shared object (reference ID = %d).", v30, v31, v32, v33, v34, v21);
                }
LABEL_69:
                if (**((void **)&v90 + 1))
                {
                  re::TypeInfo::releaseInstance((re::TypeInfo *)v89, **((void ***)&v90 + 1), *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                  **((void **)&v90 + 1) = 0;
                }
                goto LABEL_71;
              }
            }
            uint64_t v42 = **((void **)&v90 + 1);
            v84[0] = v21;
            uint64_t v80 = v42;
            re::TypeInfo::TypeInfo((uint64_t)&v81, (uint64_t)v89);
            re::TypeInfo::TypeInfo((uint64_t)v83, (uint64_t)&v85);
            v83[16] = v94;
            re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew(v17, v84, (uint64_t)&v80);
          }
          ++v20;
          unint64_t v43 = *(void *)(v9 + 376);
          v19 += 88;
        }
        while (v43 > v20);
        *(void *)&long long v95 = 0;
        *((void *)&v95 + 1) = 0xFFFFFFFFLL;
        uint64_t v10 = v77;
        if (v43)
        {
          uint64_t v44 = 0;
          uint64_t v45 = *(void *)(v9 + 392);
          uint64_t v46 = 88 * v43;
          int v47 = -1;
          do
          {
            re::TypeRegistry::typeInfo(*(void **)(v45 + 16), *(void *)(*(void *)(v45 + 32) + 72), &v90);
            re::TypeInfo::TypeInfo((uint64_t)&v80, (uint64_t)&v90 + 8);
            re::TypeRegistry::typeInfo(*(void **)(v45 + 48), *(void *)(*(void *)(v45 + 64) + 72), &v90);
            re::TypeInfo::TypeInfo((uint64_t)v89, (uint64_t)&v90 + 8);
            int v48 = *(_DWORD *)v45;
            if (*(_DWORD *)v45 == v47)
            {
              long long v79 = v95;
              if (!re::internal::areCompatible((re **)(v45 + 16), (uint64_t)&v79))
              {
                uint64_t v65 = re::TypeInfo::name((re::TypeInfo *)&v80)[1];
                re::TypeRegistry::typeName(*(_anonymous_namespace_ **)(v9 + 208), &v95);
                re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, 0, "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".", v66, v67, v68, v69, v70, v65);
                goto LABEL_71;
              }
              uint64_t v49 = **(char ****)(v45 + 8);
              if (v49) {
                BOOL v50 = v49 == v44;
              }
              else {
                BOOL v50 = 1;
              }
              if (!v50) {
                re::TypeInfo::releaseInstance((re::TypeInfo *)&v80, v49, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
              }
              re::TypeInfo::TypeInfo((uint64_t)&v90, (uint64_t)&v80);
              if (*(unsigned char *)(v45 + 80))
              {
                if (!(void)v95)
                {
                  uint64_t v76 = re::TypeInfo::name((re::TypeInfo *)&v80)[1];
                  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, 0, "Invalid reference. Polymorphic type \"%s\" has invalid actual type.", v71, v72, v73, v74, v75, v76);
                  goto LABEL_71;
                }
                LODWORD(v85) = v47;
                uint64_t v51 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(v17, (unsigned int *)&v85);
                if (!v51)
                {
                  re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, 0, "Invalid reference. No such object %z", v52, v53, v54, v55, v56, v47);
                  goto LABEL_71;
                }
                re::TypeInfo::operator=((uint64_t)&v90, v51 + 8);
              }
              uint64_t v57 = *(char ***)(v45 + 8);
              if ((*((unsigned char *)v82 + 49) & 2) != 0)
              {
                *uint64_t v57 = (char *)v44;
                uint64_t v61 = (void (*)(char **))v82[4];
                if (v61) {
                  v61(v44);
                }
                if (*(unsigned char *)(v45 + 80))
                {
                  uint64_t v62 = *(void *)(v45 + 8);
                  int v63 = *(re **)v91[0];
                  v78[0] = (re *)v90;
                  v78[1] = v63;
                  re::TypeInfo::setActualTypeForPointer((void **)(v45 + 16), v62, v78);
                }
              }
              else
              {
                if (*v57)
                {
                  if (*(unsigned char *)(v45 + 80))
                  {
                    re::TypeInfo::getActualTypeFromPointer((uint64_t)&v80, *v57, &v85);
                    if (v85 != (void)v90
                      || (uint64_t v58 = *(void *)v91[0], v86 != (unsigned __int16)*(void *)v91[0])
                      || v87 != WORD1(v58)
                      || ((v88 ^ HIDWORD(v58)) & 0xFFFFFF) != 0)
                    {
                      re::TypeInfo::releaseInstance((re::TypeInfo *)&v80, **(void ***)(v45 + 8), *(re::Allocator **)(v9 + 48), 0);
                    }
                  }
                }
                uint64_t v59 = **(void ****)(v45 + 8);
                if (!v59)
                {
                  **(void **)(v45 + 8) = re::TypeInfo::createInstance((re::TypeInfo *)&v90, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                  uint64_t v59 = **(void ****)(v45 + 8);
                }
                re::TypeInfo::copy((re::TypeInfo *)&v90, v59, v44, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
              }
            }
            else if (v48 > v47)
            {
              uint64_t v44 = **(char ****)(v45 + 8);
              uint64_t v60 = *v82;
              *(void *)&long long v95 = v80;
              *((void *)&v95 + 1) = v60;
              int v47 = v48;
            }
            v45 += 88;
            v46 -= 88;
          }
          while (v46);
        }
      }
      re::EncoderOPACK<re::SeekableInputStream>::endObject(v10);
LABEL_71:
      BOOL result = v96;
      if (v96)
      {
        if (v97) {
          return (*(uint64_t (**)(void))(*(void *)v96 + 40))();
        }
      }
    }
    else if (!*(unsigned char *)(v9 + 64) && *(void *)(v9 + 376))
    {
      return re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v9, "@shared", "Failed to deserialize shared objects. Entry not found.", v11, v12, v13, v14, v15, a9);
    }
  }
  return result;
}

BOOL re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::SeekableInputStream>,false>(uint64_t a1, const char *a2, uint64_t a3, void **a4, re **a5, re::TypeInfo *a6, re::TypeInfo *a7, int a8, char a9)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  uint64_t v15 = a1 + 24;
  int v16 = re::EncoderOPACK<re::SeekableInputStream>::beginObject(a1 + 24, a2, 0, 0);
  BOOL result = 0;
  if (v16)
  {
    uint64_t v44 = 0;
    if ((re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(v15, "customClassID", 1, (char *)&v44, 0) & 1) == 0)return 0; {
    re::TypeInfo::typeIDForCustomClassID(a7, v44, v43);
    }
    if (v43[0])
    {
      if ((a9 & 1) == 0 && *a4)
      {
        re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
        *a4 = 0;
      }
      re::TypeRegistry::typeInfo(*(re **)a7, v43, buf);
      re::TypeInfo::TypeInfo((uint64_t)&v39, (uint64_t)&v46 + 4);
      if (a8)
      {
        uint64_t v18 = *(re::TypeRegistry **)(a1 + 208);
      }
      else
      {
        uint64_t v18 = *(re::TypeRegistry **)(a1 + 208);
        if (*a5 == v18)
        {
          re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&v39);
          uint64_t v27 = v43[0];
          uint64_t v28 = v43[1];
          if (a9)
          {
LABEL_30:
            Instance = 0;
            goto LABEL_37;
          }
LABEL_36:
          Instance = re::TypeInfo::createInstance(a6, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
          *a4 = Instance;
          v35[0] = v27;
          v35[1] = v28;
          re::internal::setActualType(a4, a5, v35);
LABEL_37:
          v34[0] = v27;
          v34[1] = v28;
          (*(void (**)(uint64_t, void **, void *))(*(void *)a1 + 16))(a1, Instance, v34);
          if (!*(unsigned char *)(a1 + 64)) {
            (*(void (**)(uint64_t, const char *, uint64_t, void **, re::TypeInfo *, uint64_t **, BOOL))(*(void *)a1 + 72))(a1, "object", 10, Instance, a6, &v39, Instance == 0);
          }
LABEL_39:
          (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
          re::EncoderOPACK<re::SeekableInputStream>::endObject(v15);
          return *(unsigned char *)(a1 + 64) == 0;
        }
      }
      uint64_t v25 = re::TypeInfo::name((re::TypeInfo *)&v39);
      uint64_t v26 = re::TypeRegistry::typeInfo(v18, (const re::StringID *)v25, buf);
      if (!buf[0] || !*(unsigned char *)(*(void *)&v48[10] + 120))
      {
        uint64_t v30 = *re::foundationSerializationLogObjects((re *)v26);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v31 = re::TypeInfo::name((re::TypeInfo *)&v39)[1];
          *(_DWORD *)long long buf = 136315138;
          uint64_t v46 = v31;
          _os_log_impl(&dword_233120000, v30, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", buf, 0xCu);
        }
        v36[0] = 0;
        v36[1] = 0xFFFFFFFFLL;
        (*(void (**)(uint64_t, void, void *))(*(void *)a1 + 16))(a1, 0, v36);
        if (!*(unsigned char *)(a1 + 64)) {
          (*(void (**)(uint64_t, const char *, uint64_t, void, uint64_t **, uint64_t **, uint64_t))(*(void *)a1 + 72))(a1, "object", 10, 0, &v39, &v39, 1);
        }
        goto LABEL_39;
      }
      re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&v46 + 4);
      uint64_t v27 = *(re **)a6;
      uint64_t v28 = (re *)**((void **)a6 + 2);
      if (a9) {
        goto LABEL_30;
      }
      goto LABEL_36;
    }
    if ((a9 & 1) == 0 && *a4)
    {
      re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
      *a4 = 0;
    }
    uint64_t v19 = re::TypeInfo::name(a7);
    if ((unint64_t)*v19 >> 1 == 0x36D724013CDDLL)
    {
      unint64_t v20 = (char *)v19[1];
      if (v20 == "Component" || (uint64_t v19 = (uint64_t *)strcmp(v20, "Component"), !v19))
      {
        uint64_t v19 = (uint64_t *)re::EncoderOPACK<re::SeekableInputStream>::checkForString(v15, 10);
        if (v19)
        {
          uint64_t v40 = 0;
          char v41 = 0;
          uint64_t v42 = 0;
          re::DynamicString::setCapacity(&v39, 0);
          uint64_t v21 = *(re::TypeRegistry **)(a1 + 208);
          v37[0] = 0x2686EB529B3EE220;
          v37[1] = "DynamicString";
          re::TypeRegistry::typeInfo(v21, (const re::StringID *)v37, buf);
          re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v46 + 4);
          re::StringID::destroyString((re::StringID *)v37);
          BOOL v22 = re::serializeDynamicString<re::EncoderOPACK<re::SeekableInputStream>>(a1, "object", (const re::TypeInfo *)0xA, &v39, (re *)v38, (const re::TypeInfo *)v38, 0);
          if (v22)
          {
            uint64_t v23 = *re::foundationSerializationLogObjects((re *)v22);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              if (v40) {
                uint64_t v24 = v41;
              }
              else {
                uint64_t v24 = (char *)&v40 + 1;
              }
              *(_DWORD *)long long buf = 134218498;
              uint64_t v46 = v44;
              __int16 v47 = 1040;
              *(_DWORD *)int v48 = 256;
              *(_WORD *)&v48[4] = 2080;
              *(void *)&v48[6] = v24;
              _os_log_impl(&dword_233120000, v23, OS_LOG_TYPE_DEFAULT, "Skipping unknown Component %llu. String data: %.256s", buf, 0x1Cu);
            }
            if (v39 && (v40 & 1) != 0) {
              (*(void (**)(void))(*v39 + 40))();
            }
LABEL_45:
            re::EncoderOPACK<re::SeekableInputStream>::endObject(v15);
            return 1;
          }
          uint64_t v19 = v39;
          if (v39 && (v40 & 1) != 0) {
            uint64_t v19 = (uint64_t *)(*(uint64_t (**)(void))(*v39 + 40))();
          }
        }
      }
    }
    uint64_t v32 = *re::foundationSerializationLogObjects((re *)v19);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = re::TypeInfo::name(a7)[1];
      *(_DWORD *)long long buf = 136315394;
      uint64_t v46 = v33;
      __int16 v47 = 2048;
      *(void *)int v48 = v44;
      _os_log_impl(&dword_233120000, v32, OS_LOG_TYPE_DEFAULT, "Skipping unknown polymorphic \"%s\" type. Custom class ID = %llu", buf, 0x16u);
    }
    goto LABEL_45;
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  unint64_t v8 = v7 ^ (v7 >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 96 * v13;
    return v12 + 16;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(_DWORD *)(v11 + 96 * v10 + 12) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 96 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 96 * v10;
  return v12 + 16;
}

BOOL re::EncoderOPACK<re::SeekableInputStream>::checkForString(uint64_t a1, char a2)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  unsigned __int8 __dst = 0;
  uint64_t v5 = *(void *)(a1 + 168);
  if (v5)
  {
    uint64_t v6 = v5 - 1;
    int v7 = *(unsigned __int8 *)(a1 + v5 - 1 + 160);
    unsigned __int8 __dst = v7;
    *(void *)(a1 + 168) = v6;
  }
  else
  {
    if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL))
    {
      re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, "check", (uint64_t)"Key");
      return 0;
    }
    int v7 = __dst;
  }
  if (v7 != (a2 + 8))
  {
    unint64_t v10 = *(void *)(a1 + 168);
    if (v10 <= 7)
    {
      BOOL result = 0;
      *(void *)(a1 + 168) = v10 + 1;
      *(unsigned char *)(a1 + v10 + 160) = v7;
      return result;
    }
    return 0;
  }
  unsigned __int8 v13 = 0;
  unint64_t v8 = *(void *)(a1 + 168);
  if (!*(unsigned char *)(a1 + 40))
  {
    if (v8)
    {
      unint64_t v11 = v8 - 1;
      int v12 = *(unsigned __int8 *)(a1 + v11 + 160);
      *(void *)(a1 + 168) = v11;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&v13, 1uLL))
      {
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, "check", (uint64_t)"String");
        unint64_t v8 = *(void *)(a1 + 168);
        goto LABEL_10;
      }
      int v12 = v13;
      unint64_t v11 = *(void *)(a1 + 168);
    }
    BOOL result = (v12 - 64) < 0x30;
    if (v11 <= 7)
    {
      *(void *)(a1 + 168) = v11 + 1;
      *(unsigned char *)(a1 + v11 + 160) = v12;
      unint64_t v8 = *(void *)(a1 + 168);
      if (v8 <= 7) {
        goto LABEL_11;
      }
    }
    return result;
  }
LABEL_10:
  BOOL result = 0;
  if (v8 < 8)
  {
LABEL_11:
    unsigned __int8 v9 = __dst;
    *(void *)(a1 + 168) = v8 + 1;
    *(unsigned char *)(a1 + v8 + 160) = v9;
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 96 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 96 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 96 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 96 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 96 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 96 * v10) = a3;
  *(_DWORD *)(*(void *)(a1 + 16) + 96 * v10 + 12) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + 96 * v10;
  *(void *)(v14 + 16) = *(void *)a5;
  re::TypeInfo::TypeInfo(v14 + 24, a5 + 8);
  re::TypeInfo::TypeInfo(v14 + 56, a5 + 40);
  *(_WORD *)(v14 + 88) = *(_WORD *)(a5 + 72);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&unsigned __int8 v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 12, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 96;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t *re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::registerSerializeFunc(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 208);
  BOOL result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5) {
    BOOL v7 = result == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = *result;
    uint64_t v10 = a3;
    unint64_t v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 224, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeBool(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeChar<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeI8<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeI16<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<short>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeI32<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, int *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeI64<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeU8<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeU16<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeU32<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, int *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeU64<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeFloat<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeFloat(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeDouble<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::SeekableInputStream>::serializeDouble(a1 + 24, a2, v9, a4, a7);
}

BOOL re::serializeCString<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_22:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v23 = **((void **)a5 + 2);
    uint64_t v24 = **((void **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24) {
      goto LABEL_22;
    }
    BOOL v26 = WORD1(v23) == WORD1(v24);
    uint64_t v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    BOOL v26 = v26 && v25 == 0;
    if (!v26) {
      goto LABEL_22;
    }
  }
LABEL_4:
  if (a7)
  {
    int v48 = 0;
    int v19 = re::EncoderOPACK<re::SeekableInputStream>::beginPointer(a1 + 24, a2, v9, &v48, 0);
    BOOL result = 0;
    if (!v19) {
      return result;
    }
    if (!v48) {
      goto LABEL_12;
    }
    if (v48 != 1)
    {
      size_t v47 = 0;
      if (re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, 0, (uint64_t *)&v47, 0))
      {
        if (v47) {
          re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
        }
        re::EncoderOPACK<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
LABEL_12:
      re::EncoderOPACK<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      goto LABEL_47;
    }
    goto LABEL_16;
  }
  int v48 = 2 * (*a4 != 0);
  int v21 = re::EncoderOPACK<re::SeekableInputStream>::beginPointer(a1 + 24, a2, v9, &v48, 0);
  BOOL result = 0;
  if (!v21) {
    return result;
  }
  int v22 = v48;
  if (v48)
  {
    if (v48 == 1)
    {
LABEL_16:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, v46);
      return 0;
    }
  }
  else
  {
    if (!*a4) {
      goto LABEL_44;
    }
    (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
    *a4 = 0;
    int v22 = v48;
  }
  if (v22 == 2)
  {
    size_t v27 = *a4 ? strlen(*a4) : 0;
    size_t v47 = v27;
    if (re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, 0, (uint64_t *)&v47, 0))
    {
      uint64_t v28 = (char *)*a4;
      unint64_t v29 = v47;
      if (!*a4 || v47 != v27)
      {
        if (v28)
        {
          (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
          *a4 = 0;
          unint64_t v29 = v47;
        }
        unint64_t v30 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
        char v36 = v47;
        if (v29 > v30)
        {
          (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v37, v38, v39, v40, v41, v36);
          return 0;
        }
        uint64_t v42 = v47 == -1;
        uint64_t v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, v47);
          return 0;
        }
        uint64_t v28 = (char *)(*(uint64_t (**)(void, size_t, void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v47 + 1, 0);
        *a4 = v28;
        size_t v27 = v47;
      }
      if (v27)
      {
        re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, v28, 0);
        uint64_t v28 = (char *)*a4;
        uint64_t v44 = v47;
      }
      else
      {
        uint64_t v44 = 0;
      }
      v28[v44] = 0;
      re::EncoderOPACK<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    }
  }
LABEL_44:
  re::EncoderOPACK<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  int v45 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(unsigned char *)(a1 + 64)) {
    return v45 == 0;
  }
  (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  int v45 = *(unsigned __int8 *)(a1 + 64);
  return v45 == 0;
}

BOOL re::serializeStringID<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (int v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v47 = 0;
    int v20 = re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v47, 0);
    BOOL result = 0;
    if (!v20) {
      return result;
    }
    if (v47) {
      re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    }
    goto LABEL_26;
  }
  unint64_t v46 = 0;
  if (re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v46, 0))
  {
    unint64_t v22 = v46;
    if (v46)
    {
      unint64_t v23 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
      char v29 = v46;
      if (v22 > v23)
      {
        (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v30, v31, v32, v33, v34, v29);
        return 0;
      }
      uint64_t v36 = v46 == -1;
      uint64_t v37 = v36 << 63 >> 63;
      if (v37 != v36 || v37 < 0)
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v24, v25, v26, v27, v28, v46);
        return 0;
      }
      uint64_t v38 = (char *)(*(uint64_t (**)(void, unint64_t, void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56), v46 + 1, 0);
      uint64_t v39 = (_anonymous_namespace_ *)re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, v38, 0);
      v38[v46] = 0;
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v40 = v44;
      uint64_t v41 = v45;
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v42 = *a4;
      uint64_t v43 = a4[1];
      *a4 = v40;
      a4[1] = (uint64_t)v41;
      unint64_t v47 = v40 & 0xFFFFFFFFFFFFFFFELL | v42 & 1;
      uint64_t v48 = v43;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
      (*(void (**)(void, char *))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v38);
    }
    else
    {
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v35 = a4[1];
      unint64_t v47 = *a4 & 1;
      uint64_t v48 = v35;
      *a4 = 0;
      a4[1] = (uint64_t)"";
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
    }
LABEL_26:
    re::EncoderOPACK<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return 0;
}

uint64_t re::serializeIntrospectionCallbackSerializer<re::EncoderOPACK<re::SeekableInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  int v10 = (int)a3;
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v27 = **((void **)a5 + 2);
    uint64_t v28 = **((void **)a6 + 2);
    if ((unsigned __int16)v27 == (unsigned __int16)v28)
    {
      BOOL v30 = WORD1(v27) == WORD1(v28);
      uint64_t v29 = (v28 ^ v27) & 0xFFFFFF00000000;
      BOOL v30 = v30 && v29 == 0;
      if (v30) {
        goto LABEL_4;
      }
    }
LABEL_32:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_32;
  }
LABEL_4:
  if (a7)
  {
    uint64_t v31 = 0;
    int v14 = re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v10, &v31, 0);
    uint64_t result = 0;
    if (!v14) {
      return result;
    }
    if (v31) {
      re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, 0, 1);
    }
    re::EncoderOPACK<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
  }
  else
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v31 = *(void *)a5;
    uint64_t v32 = v16;
    LODWORD(v33) = -1;
    *(void *)long long buf = 0x258C98EAAF29A10ALL;
    *(void *)&buf[8] = "CallbackSerializerAttribute";
    BOOL v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v31, buf);
    re::StringID::destroyString((re::StringID *)buf);
    uint64_t v18 = *v17;
    uint64_t v19 = *(void *)(a1 + 200);
    unint64_t v35 = 0;
    uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::beginString(a1 + 24, a2, v10, (uint64_t *)&v35, 0);
    if (!result) {
      return result;
    }
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v31 = v20;
    uint64_t v32 = 0;
    re::DynamicString::setCapacity(&v31, 0);
    if (v35)
    {
      re::DynamicString::resize(&v31, v35, 0);
      if (v32) {
        int v21 = v33;
      }
      else {
        int v21 = (char *)&v32 + 1;
      }
      re::EncoderOPACK<re::SeekableInputStream>::serializeString(a1 + 24, v21, 0);
    }
    re::EncoderOPACK<re::SeekableInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    unint64_t v22 = (char *)&v32 + 1;
    if (v32) {
      unint64_t v23 = v33;
    }
    else {
      unint64_t v23 = (char *)&v32 + 1;
    }
    uint64_t v24 = (re *)(*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, char *))(v18 + 80))(*(void *)(a1 + 48), v19, v18, a4, v23);
    if ((v24 & 1) == 0)
    {
      uint64_t v25 = *re::foundationSerializationLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        if (v32) {
          unint64_t v22 = v33;
        }
        uint64_t v26 = re::TypeInfo::name(a5)[1];
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v22;
        __int16 v37 = 2080;
        uint64_t v38 = v26;
        _os_log_impl(&dword_233120000, v25, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);
      }
    }
    if (v31 && (v32 & 1) != 0) {
      (*(void (**)(void))(*(void *)v31 + 40))();
    }
  }
  return *(unsigned char *)(a1 + 64) == 0;
}

uint64_t re::EncoderOPACK<re::SeekableInputStream>::beginPointer(uint64_t a1, const char *a2, int a3, int *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v22 = 0;
  uint64_t result = re::EncoderOPACK<re::SeekableInputStream>::advance(a1, a2, a3, &v22, 0);
  if (result)
  {
    unsigned __int8 __dst = 0;
    if (*(unsigned char *)(a1 + 40))
    {
LABEL_5:
      BOOL v10 = *a4 != 0;
      LOBYTE(v16) = 9;
      DWORD1(v16) = a5;
      *((void *)&v16 + 1) = a2;
      uint64_t v17 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      BOOL v18 = v10;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v16);
      *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v22;
      return *(unsigned char *)(a1 + 40) == 0;
    }
    uint64_t v11 = *(void *)(a1 + 168);
    if (v11)
    {
      uint64_t v12 = v11 - 1;
      int v13 = *(unsigned __int8 *)(a1 + v11 - 1 + 160);
      unsigned __int8 __dst = v13;
      *(void *)(a1 + 168) = v12;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Optional");
        goto LABEL_5;
      }
      int v13 = __dst;
    }
    if (v13 == 4)
    {
      *a4 = 0;
    }
    else
    {
      if ((v13 - 7) > 0x2C) {
        int v14 = 2;
      }
      else {
        int v14 = 1;
      }
      *a4 = v14;
      unint64_t v15 = *(void *)(a1 + 168);
      if (v15 <= 7)
      {
        *(void *)(a1 + 168) = v15 + 1;
        *(unsigned char *)(a1 + v15 + 160) = v13;
      }
    }
    goto LABEL_5;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::SeekableInputStream>::endPointer(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::SeekableInputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderBinary<re::SeekableInputStream>,re::SeekableInputStream>::popState(v1, 9);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v8);
      if (v9) {
        BOOL v7 = *(unsigned char **)&v10[7];
      }
      else {
        BOOL v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". No value was provided.", (re::DynamicString *)v11, v7);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      uint64_t result = v8;
      if (v8 && (v9 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v8 + 40))();
      }
    }
  }
  return result;
}

BOOL re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, uint64_t a7)
{
  BOOL isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6) {
    goto LABEL_4;
  }
  if (*(void *)this == *(void *)a6)
  {
    uint64_t v24 = **((void **)this + 2);
    uint64_t v25 = **((void **)a6 + 2);
    if ((unsigned __int16)v24 == (unsigned __int16)v25)
    {
      BOOL v27 = WORD1(v24) == WORD1(v25);
      uint64_t v26 = (v25 ^ v24) & 0xFFFFFF00000000;
      BOOL v27 = v27 && v26 == 0;
      if (v27) {
        goto LABEL_4;
      }
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    int v16 = 0;
    goto LABEL_5;
  }
  if (*((unsigned char *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (uint64_t v28 = re::TypeInfo::name(this), v29 = re::TypeInfo::name(a6), !re::StringID::operator==(v28, v29))))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, this, a6);
    return 0;
  }
  int v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v40);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)&v41);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v40);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v41);
  if (isPointerToPolymorphicType && (a7 & 1) == 0)
  {
    re::internal::actualType(a4, (void **)this, v47);
    if (v47[0]) {
      goto LABEL_8;
    }
LABEL_15:
    BOOL v18 = re::TypeInfo::name(this);
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Failed to get actual type of polymorphic object. Type \"%s\".", v19, v20, v21, v22, v23, v18[1]);
    return 0;
  }
  uint64_t v17 = *(re **)v49[2];
  v47[0] = (re *)v49[0];
  v47[1] = v17;
  if (!v49[0]) {
    goto LABEL_15;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v47, &v40);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v41);
  int v45 = 0;
  if (!re::EncoderOPACK<re::SeekableInputStream>::beginPointer(a1 + 24, a2, a3, &v45, 0)) {
    return 0;
  }
  if (v45 == 1)
  {
    unsigned int v44 = 0;
    if (!*(unsigned char *)(a1 + 64))
    {
      re::EncoderOPACK<re::SeekableInputStream>::readIntegerAs<unsigned int>((_anonymous_namespace_ *)(a1 + 24), "ID", &v44);
      uint64_t v31 = *(void *)(a1 + 152);
      uint64_t v32 = *(void *)(a1 + 136) - 1;
      if (*(unsigned char *)(v31 + 48 * v32) != 2) {
        ++*(void *)(v31 + 48 * v32 + 32);
      }
      if (!*(unsigned char *)(a1 + 64))
      {
        if ((a7 & 1) == 0)
        {
          unsigned int v40 = v44;
          uint64_t v41 = a4;
          re::TypeInfo::TypeInfo((uint64_t)&v42, (uint64_t)this);
          re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)a6);
          unsigned char v43[32] = isPointerToPolymorphicType;
          v43[33] = v16;
          unint64_t v33 = *(void *)(a1 + 376);
          if (v33)
          {
            uint64_t v34 = *(_DWORD **)(a1 + 392);
            do
            {
              unint64_t v35 = v33 >> 1;
              uint64_t v36 = &v34[22 * (v33 >> 1)];
              unsigned int v38 = *v36;
              __int16 v37 = v36 + 22;
              v33 += ~(v33 >> 1);
              if (v40 < v38) {
                unint64_t v33 = v35;
              }
              else {
                uint64_t v34 = v37;
              }
            }
            while (v33);
          }
          else
          {
            uint64_t v34 = *(_DWORD **)(a1 + 392);
          }
          re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::insert((_anonymous_namespace_ *)(a1 + 360), 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v34 - *(void *)(a1 + 392)) >> 3), (uint64_t)&v40);
        }
        goto LABEL_50;
      }
    }
    return 0;
  }
  if (v45)
  {
    if (isPointerToPolymorphicType)
    {
      re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::SeekableInputStream>,false>(a1, a2, a3, (void **)a4, (re **)this, (re::TypeInfo *)v46, (re::TypeInfo *)v48, v16, a7);
    }
    else
    {
      if (a7)
      {
        Instance = 0;
      }
      else
      {
        Instance = *a4;
        if (!*a4)
        {
          Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v49, *(re::Allocator **)(a1 + 48), 0);
          *a4 = Instance;
        }
      }
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, char *, void *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, 0, Instance, v49, v48, a7);
      }
    }
  }
  else if ((a7 & 1) == 0)
  {
    if (*a4)
    {
      re::TypeInfo::releaseInstance((re::TypeInfo *)v46, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
      *a4 = 0;
    }
  }
LABEL_50:
  re::EncoderOPACK<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  return *(unsigned char *)(a1 + 64) == 0;
}

void re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 272);
  uint64_t v6 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = *v6;
    v9[0] = v5;
    v9[1] = v8;
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, (uint64_t)v9, a3);
  }
}

BOOL re::serializeBool<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v19 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v13 = (unsigned __int8 *)&v19;
  }
  else {
    int v13 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, v13);
}

BOOL re::serializeChar<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v19 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v13 = &v19;
  }
  else {
    int v13 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)v13);
}

BOOL re::serializeI8<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v19 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v13 = &v19;
  }
  else {
    int v13 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, v13);
}

BOOL re::serializeI16<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  __int16 v19 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v13 = &v19;
  }
  else {
    int v13 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, v13);
}

BOOL re::serializeI32<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned int *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v19 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v13 = (unsigned int *)&v19;
  }
  else {
    int v13 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, v13);
}

BOOL re::serializeI64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v19 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v13 = (unint64_t *)&v19;
  }
  else {
    int v13 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, v13);
}

BOOL re::serializeU8<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v19 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v13 = (unsigned __int8 *)&v19;
  }
  else {
    int v13 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, v13);
}

BOOL re::serializeU16<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int16 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  __int16 v19 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v13 = (unsigned __int16 *)&v19;
  }
  else {
    int v13 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, v13);
}

BOOL re::serializeU32<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned int *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v14 = (unsigned int *)&v20;
  }
  else {
    int v14 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, (uint64_t)a3, v14, a7);
}

BOOL re::serializeU64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, rapidjson::internal **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v19 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v13 = (rapidjson::internal **)&v19;
  }
  else {
    int v13 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, v13);
}

BOOL re::serializeFloat<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, float *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v14 = (float *)&v20;
  }
  else {
    int v14 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (uint64_t)a3, v14, a7);
}

BOOL re::serializeDouble<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, double *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    int v14 = (double *)&v20;
  }
  else {
    int v14 = a4;
  }
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (uint64_t)a3, v14, a7);
}

uint64_t re::serializeCString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v18 = **((void **)a5 + 2);
    uint64_t v19 = **((void **)a6 + 2);
    if ((unsigned __int16)v18 == (unsigned __int16)v19)
    {
      BOOL v21 = WORD1(v18) == WORD1(v19);
      uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
      BOOL v21 = v21 && v20 == 0;
      if (v21) {
        goto LABEL_4;
      }
    }
LABEL_22:
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_22;
  }
LABEL_4:
  if (a7)
  {
    LODWORD(v22) = 0;
    int v13 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, (int *)&v22);
    uint64_t result = 0;
    if (!v13) {
      return result;
    }
    uint64_t v15 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    uint64_t v16 = *a4;
    int v23 = 2 * (*a4 != 0);
    uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v23);
    if (!result) {
      return result;
    }
    if (v16)
    {
      uint64_t v17 = (const char *)*a4;
      if (*a4) {
        uint64_t v17 = (const char *)strlen(v17);
      }
      uint64_t v22 = v17;
      if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, 0, (uint64_t *)&v22, 0))
      {
        if (v22) {
          re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, *a4, 0);
        }
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    uint64_t v15 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::SeekableInputStream>::endPointer(v15);
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::serializeStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (uint64_t v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    size_t v23 = 0;
    BOOL v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v23, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    if (v23) {
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    size_t v23 = strlen(*(const char **)(a4 + 8));
    BOOL result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, (uint64_t *)&v23, 0);
    if (!result) {
      return result;
    }
    if (v23) {
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, *(void *)(a4 + 8), 0);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString(v22);
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_28:
      re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v23 = **((void **)a5 + 2);
    uint64_t v24 = **((void **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24) {
      goto LABEL_28;
    }
    BOOL v26 = WORD1(v23) == WORD1(v24);
    uint64_t v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    BOOL v26 = v26 && v25 == 0;
    if (!v26) {
      goto LABEL_28;
    }
  }
LABEL_4:
  if (!a7)
  {
    unint64_t v16 = **((void **)a5 + 2);
    uint64_t v32 = *(void *)a5;
    unint64_t v33 = v16;
    LODWORD(v34) = -1;
    v36[0] = 0x258C98EAAF29A10ALL;
    v36[1] = (uint64_t)"CallbackSerializerAttribute";
    BOOL v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v32, v36);
    re::StringID::destroyString((re::StringID *)v36);
    uint64_t v18 = *v17;
    uint64_t v19 = *(void *)(a1 + 264);
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v32 = v20;
    unint64_t v33 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    if ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v18 + 72))(v19, v18, a4, &v32))
    {
      if (v33) {
        uint64_t v21 = v33 >> 1;
      }
      else {
        uint64_t v21 = v33 >> 1;
      }
      v36[0] = v21;
      if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, v36, 0))
      {
        if (v36[0])
        {
          if (v33) {
            uint64_t v22 = v34;
          }
          else {
            uint64_t v22 = (char *)&v33 + 1;
          }
          re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, (uint64_t)v22, 0);
        }
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
        if (v32 && (v33 & 1) != 0) {
          (*(void (**)(void))(*(void *)v32 + 40))();
        }
        return *(unsigned char *)(a1 + 64) == 0;
      }
    }
    else
    {
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Failed to write string for \"%s\" (type %s) using serialization callback.", v27, v28, v29, v30, v31, (char)a2);
    }
    if (v32 && (v33 & 1) != 0) {
      (*(void (**)(void))(*(void *)v32 + 40))();
    }
    return 0;
  }
  uint64_t v32 = 0;
  BOOL v14 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t)a3, &v32, 0);
  BOOL result = 0;
  if (v14)
  {
    if (v32) {
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(uint64_t a1, const char *a2, int *a3)
{
  BOOL v14 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 40);
  if (*(unsigned char *)(a1 + 40)) {
    return v3 == 0;
  }
  if ((*(unsigned char *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 44) & 0x20) != 0) {
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v14);
  }
  int v6 = *a3;
  if ((*a3 - 1) < 2)
  {
LABEL_7:
    LOBYTE(v9) = 9;
    DWORD1(v9) = 0;
    *((void *)&v9 + 1) = v14;
    uint64_t v10 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    BOOL v11 = v6 != 0;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v9);
    return v3 == 0;
  }
  if (!v6)
  {
    BOOL v7 = *(char **)(a1 + 168);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v7);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull((uint64_t *)v7);
    int v6 = *a3;
    goto LABEL_7;
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Unexpected PointerEncoding.", "!\"Unreachable code\"", "beginPointer", 1054);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString(unsigned char *a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_14:
      re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, a2, a5, a6);
      return 0;
    }
    uint64_t v15 = **((void **)a5 + 2);
    uint64_t v16 = **((void **)a6 + 2);
    if ((unsigned __int16)v15 != (unsigned __int16)v16) {
      goto LABEL_14;
    }
    BOOL v18 = WORD1(v15) == WORD1(v16);
    uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    BOOL v18 = v18 && v17 == 0;
    if (!v18) {
      goto LABEL_14;
    }
  }
LABEL_4:
  if (!*a4)
  {
    LODWORD(v24) = 0;
    uint64_t v13 = (_anonymous_namespace_ *)(a1 + 24);
    int v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, (int *)&v24);
    uint64_t result = 0;
    if (!v21) {
      return result;
    }
    goto LABEL_22;
  }
  if (!a1[336]
    || (uint64_t v24 = *a4,
        (BOOL v11 = (int *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(a1 + 344), (uint64_t *)&v24)) == 0))
  {
    int v23 = 2;
    if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, &v23))
    {
      uint64_t v24 = (const char *)strlen(*a4);
      uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 24), a2, 0, (uint64_t *)&v24, 0);
      if (!result) {
        return result;
      }
      if (v24) {
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString((uint64_t)(a1 + 24), (uint64_t)*a4, 0);
      }
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
      re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      uint64_t v19 = *a4;
      uint64_t v20 = **((void **)a5 + 2);
      *(void *)&long long v22 = *(void *)a5;
      *((void *)&v22 + 1) = v20;
      re::internal::SharedObjectGraph::addObject((uint64_t)(a1 + 336), (uint64_t)v19, &v22);
      return a1[64] == 0;
    }
    return 0;
  }
  int v12 = *v11;
  int v23 = 1;
  LODWORD(v24) = v12;
  uint64_t v13 = (_anonymous_namespace_ *)(a1 + 24);
  uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, &v23);
  if (!result) {
    return result;
  }
  re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((uint64_t)(a1 + 24), (unsigned int *)&v24);
LABEL_22:
  re::EncoderBinary<re::SeekableInputStream>::endPointer(v13);
  return a1[64] == 0;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  BOOL isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6) {
    goto LABEL_4;
  }
  if (*(void *)this == *(void *)a6)
  {
    uint64_t v29 = **((void **)this + 2);
    uint64_t v30 = **((void **)a6 + 2);
    if ((unsigned __int16)v29 == (unsigned __int16)v30)
    {
      BOOL v32 = WORD1(v29) == WORD1(v30);
      uint64_t v31 = (v30 ^ v29) & 0xFFFFFF00000000;
      BOOL v32 = v32 && v31 == 0;
      if (v32) {
        goto LABEL_4;
      }
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    int v16 = 0;
    goto LABEL_5;
  }
  if (*((unsigned char *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (unint64_t v33 = re::TypeInfo::name(this), v34 = re::TypeInfo::name(a6), !re::StringID::operator==(v33, v34))))
  {
    re::internal::setTypeMismatchError<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, this, a6);
    return 0;
  }
  int v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)v52);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v51);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v52);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    uint64_t v21 = *(void *)v50[2];
    *(void *)&long long v48 = v50[0];
    *((void *)&v48 + 1) = v21;
    if (v50[0]) {
      goto LABEL_8;
    }
    goto LABEL_15;
  }
  re::internal::actualType(a4, (void **)this, &v48);
  if (!(void)v48)
  {
LABEL_15:
    long long v22 = re::TypeInfo::name(this);
    re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "Failed to get actual type of polymorphic object. Type \"%s\".", v23, v24, v25, v26, v27, v22[1]);
    return 0;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, (re **)&v48, &v51);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v52);
  if ((a7 & 1) != 0 || (uint64_t v17 = *a4) == 0)
  {
    LODWORD(v51) = 0;
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
    int v28 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, (int *)&v51);
    uint64_t result = 0;
    if (v28) {
      goto LABEL_17;
    }
    return result;
  }
  if (!*(unsigned char *)(a1 + 336))
  {
LABEL_33:
    long long v46 = v48;
    re::internal::SharedObjectGraph::beginObject((void *)(a1 + 336), (uint64_t)v17, &v46);
    int v45 = 2;
    uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v45);
    if (!result) {
      return result;
    }
    if (!isPointerToPolymorphicType)
    {
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, char *, void *, void *, void))(*(void *)a1 + 72))(a1, a2, 0, *a4, v50, v49, 0);
      }
      goto LABEL_45;
    }
    uint64_t v35 = *a4;
    re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v47);
    if (v16)
    {
      uint64_t v36 = (re::TypeRegistry *)v49[0];
      __int16 v37 = re::TypeInfo::name((re::TypeInfo *)v47);
      re::TypeRegistry::typeInfo(v36, (const re::StringID *)v37, &v51);
      if (!(_BYTE)v51)
      {
        uint64_t v39 = re::TypeInfo::name((re::TypeInfo *)v47);
        re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::setError(a1, a2, "No matching type found for polymorphic type \"%s\" to serialize.", v40, v41, v42, v43, v44, v39[1]);
LABEL_45:
        re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        if (*(unsigned char *)(a1 + 336))
        {
          --*(void *)(a1 + 488);
          ++*(_DWORD *)(a1 + 496);
        }
        return *(unsigned char *)(a1 + 64) == 0;
      }
      re::TypeInfo::operator=((uint64_t)v53, (uint64_t)v52);
    }
    if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, a3, 0))
    {
      unsigned int v38 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)v53);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, uint64_t, void, char *, unsigned char *, int *, void))(*(void *)a1 + 72))(a1, v38[1], 0, v35, v47, v53, 0);
      }
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    goto LABEL_45;
  }
  uint64_t v51 = *a4;
  BOOL v18 = (_DWORD *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 344, (uint64_t *)&v51);
  if (!v18)
  {
    uint64_t v17 = *a4;
    goto LABEL_33;
  }
  LODWORD(v51) = *v18;
  v53[0] = 1;
  uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, v53);
  if (result)
  {
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(a1 + 24, (unsigned int *)&v51);
LABEL_17:
    re::EncoderBinary<re::SeekableInputStream>::endPointer(v19);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(uint64_t result, unsigned int *a2)
{
  if (!*(unsigned char *)(result + 40))
  {
    int v3 = (_anonymous_namespace_ *)result;
    uint64_t result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(result, 0, 0, 0);
    if (result)
    {
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>((uint64_t)v3, "@ref", 0, a2, 0);
      return (uint64_t)re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v3);
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 272);
  uint64_t result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5) {
    BOOL v7 = result == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = *result;
    uint64_t v10 = a3;
    unint64_t v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 288, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, BOOL *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, (uint64_t)a3, a4, a7);
}

unsigned int *re::serializeChar<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)a3, a4, a7);
}

unsigned int *re::serializeI8<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int8");
}

unsigned int *re::serializeI16<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _WORD *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int16");
}

uint64_t re::serializeI32<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned int *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int32");
}

uint64_t re::serializeI64<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unint64_t *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"int64");
}

unsigned int *re::serializeU8<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint8");
}

unsigned int *re::serializeU16<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _WORD *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint16");
}

uint64_t re::serializeU32<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _DWORD *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint32");
}

uint64_t re::serializeU64<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, void *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"uint64");
}

uint64_t re::serializeFloat<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, float *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"float");
}

uint64_t re::serializeDouble<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, double *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (uint64_t)a3, a4, a7, (uint64_t)"double");
}

BOOL re::serializeCString<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_22:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v23 = **((void **)a5 + 2);
    uint64_t v24 = **((void **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24) {
      goto LABEL_22;
    }
    BOOL v26 = WORD1(v23) == WORD1(v24);
    uint64_t v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    BOOL v26 = v26 && v25 == 0;
    if (!v26) {
      goto LABEL_22;
    }
  }
LABEL_4:
  if (a7)
  {
    int v48 = 0;
    unsigned int v19 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
    BOOL result = 0;
    if (!v19) {
      return result;
    }
    if (!v48) {
      goto LABEL_12;
    }
    if (v48 != 1)
    {
      size_t v47 = 0;
      if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (uint64_t *)&v47, 0))
      {
        if (v47) {
          re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
        }
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
LABEL_12:
      re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      goto LABEL_47;
    }
    goto LABEL_16;
  }
  int v48 = 2 * (*a4 != 0);
  unsigned int v21 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
  BOOL result = 0;
  if (!v21) {
    return result;
  }
  int v22 = v48;
  if (v48)
  {
    if (v48 == 1)
    {
LABEL_16:
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, v46);
      return 0;
    }
  }
  else
  {
    if (!*a4) {
      goto LABEL_44;
    }
    (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
    *a4 = 0;
    int v22 = v48;
  }
  if (v22 == 2)
  {
    size_t v27 = *a4 ? strlen(*a4) : 0;
    size_t v47 = v27;
    if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (uint64_t *)&v47, 0))
    {
      int v28 = (char *)*a4;
      unint64_t v29 = v47;
      if (!*a4 || v47 != v27)
      {
        if (v28)
        {
          (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
          *a4 = 0;
          unint64_t v29 = v47;
        }
        unint64_t v30 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
        char v36 = v47;
        if (v29 > v30)
        {
          (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v37, v38, v39, v40, v41, v36);
          return 0;
        }
        uint64_t v42 = v47 == -1;
        uint64_t v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, v47);
          return 0;
        }
        int v28 = (char *)(*(uint64_t (**)(void, size_t, void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v47 + 1, 0);
        *a4 = v28;
        size_t v27 = v47;
      }
      if (v27)
      {
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v28, 0);
        int v28 = (char *)*a4;
        uint64_t v44 = v47;
      }
      else
      {
        uint64_t v44 = 0;
      }
      v28[v44] = 0;
      re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    }
  }
LABEL_44:
  re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  int v45 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(unsigned char *)(a1 + 64)) {
    return v45 == 0;
  }
  (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  int v45 = *(unsigned __int8 *)(a1 + 64);
  return v45 == 0;
}

BOOL re::serializeStringID<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (unsigned int v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v47 = 0;
    unsigned int v20 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v47, 0);
    BOOL result = 0;
    if (!v20) {
      return result;
    }
    if (v47) {
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    }
    goto LABEL_26;
  }
  unint64_t v46 = 0;
  if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v46, 0))
  {
    unint64_t v22 = v46;
    if (v46)
    {
      unint64_t v23 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
      char v29 = v46;
      if (v22 > v23)
      {
        (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v30, v31, v32, v33, v34, v29);
        return 0;
      }
      uint64_t v36 = v46 == -1;
      uint64_t v37 = v36 << 63 >> 63;
      if (v37 != v36 || v37 < 0)
      {
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v24, v25, v26, v27, v28, v46);
        return 0;
      }
      uint64_t v38 = (char *)(*(uint64_t (**)(void, unint64_t, void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56), v46 + 1, 0);
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v38, 0);
      v38[v46] = 0;
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v40 = v44;
      uint64_t v41 = v45;
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v42 = *a4;
      uint64_t v43 = a4[1];
      *a4 = v40;
      a4[1] = (uint64_t)v41;
      unint64_t v47 = v40 & 0xFFFFFFFFFFFFFFFELL | v42 & 1;
      uint64_t v48 = v43;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
      (*(void (**)(void, char *))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v38);
    }
    else
    {
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v35 = a4[1];
      unint64_t v47 = *a4 & 1;
      uint64_t v48 = v35;
      *a4 = 0;
      a4[1] = (uint64_t)"";
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
    }
LABEL_26:
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return 0;
}

unsigned int *re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v27 = **((void **)a5 + 2);
    uint64_t v28 = **((void **)a6 + 2);
    if ((unsigned __int16)v27 == (unsigned __int16)v28)
    {
      BOOL v30 = WORD1(v27) == WORD1(v28);
      uint64_t v29 = (v28 ^ v27) & 0xFFFFFF00000000;
      BOOL v30 = v30 && v29 == 0;
      if (v30) {
        goto LABEL_4;
      }
    }
LABEL_32:
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_32;
  }
LABEL_4:
  if (a7)
  {
    uint64_t v31 = 0;
    unsigned int v14 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v31, 0);
    BOOL result = 0;
    if (!v14) {
      return result;
    }
    if (v31) {
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, 0, 1);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
  }
  else
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v31 = *(void *)a5;
    uint64_t v32 = v16;
    LODWORD(v33) = -1;
    *(void *)long long buf = 0x258C98EAAF29A10ALL;
    *(void *)&buf[8] = "CallbackSerializerAttribute";
    BOOL v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v31, buf);
    re::StringID::destroyString((re::StringID *)buf);
    uint64_t v18 = *v17;
    uint64_t v19 = *(void *)(a1 + 264);
    unint64_t v35 = 0;
    BOOL result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (uint64_t *)&v35, 0);
    if (!result) {
      return result;
    }
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v31 = v20;
    uint64_t v32 = 0;
    re::DynamicString::setCapacity(&v31, 0);
    if (v35)
    {
      re::DynamicString::resize(&v31, v35, 0);
      if (v32) {
        unsigned int v21 = v33;
      }
      else {
        unsigned int v21 = (char *)&v32 + 1;
      }
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v21, 0);
    }
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
    unint64_t v22 = (char *)&v32 + 1;
    if (v32) {
      unint64_t v23 = v33;
    }
    else {
      unint64_t v23 = (char *)&v32 + 1;
    }
    uint64_t v24 = (re *)(*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, char *))(v18 + 80))(*(void *)(a1 + 48), v19, v18, a4, v23);
    if ((v24 & 1) == 0)
    {
      uint64_t v25 = *re::foundationSerializationLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        if (v32) {
          unint64_t v22 = v33;
        }
        uint64_t v26 = re::TypeInfo::name(a5)[1];
        *(_DWORD *)long long buf = 136315650;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v22;
        __int16 v37 = 2080;
        uint64_t v38 = v26;
        _os_log_impl(&dword_233120000, v25, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);
      }
    }
    if (v31 && (v32 & 1) != 0) {
      (*(void (**)(void))(*(void *)v31 + 40))();
    }
  }
  return (unsigned int *)(*(unsigned char *)(a1 + 64) == 0);
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(_anonymous_namespace_ *a1, char *a2, uint64_t a3, int *a4, int a5)
{
  if (*((unsigned char *)a1 + 40)) {
    return 0;
  }
  BOOL result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::readJSONValue(a1, a2, 0);
  if (result)
  {
    uint64_t v10 = result;
    int v11 = *((unsigned __int16 *)result + 11);
    if (*((_WORD *)result + 11))
    {
      if (v11 != 3
        || (int *)(*((void *)result + 1) + 48 * *result) == rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::FindMember(result, "@ref"))
      {
        int v11 = 2;
        uint64_t v12 = 1;
      }
      else
      {
        uint64_t v12 = 1;
        int v11 = 1;
      }
    }
    else
    {
      uint64_t v12 = *((unsigned __int16 *)result + 11);
    }
    *a4 = v11;
    LOBYTE(v13) = 9;
    DWORD1(v13) = a5;
    *((void *)&v13 + 1) = a2;
    uint64_t v14 = 0;
    uint64_t v15 = v12;
    uint64_t v16 = 0;
    BOOL v17 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v13);
    return (unsigned int *)1;
  }
  return result;
}

int *rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::FindMember(unsigned int *a1, char *__s)
{
  v5[3] = *MEMORY[0x263EF8340];
  v5[1] = __s;
  _OWORD v5[2] = 0x405000000000000;
  v5[0] = strlen(__s);
  int v3 = (int *)*((void *)a1 + 1);
  if (*a1)
  {
    do
    {
      if (rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::StringEqual<re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>((unsigned int *)v5, v3))
      {
        break;
      }
      v3 += 12;
    }
    while (v3 != (int *)(*((void *)a1 + 1) + 48 * *a1));
  }
  return v3;
}

BOOL rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::StringEqual<re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>(unsigned int *a1, int *a2)
{
  if ((*((_WORD *)a1 + 11) & 0x1000) != 0) {
    unsigned int v2 = 21 - *((char *)a1 + 21);
  }
  else {
    unsigned int v2 = *a1;
  }
  int v3 = 21 - *((char *)a2 + 21);
  if ((*((_WORD *)a2 + 11) & 0x1000) == 0) {
    int v3 = *a2;
  }
  if (v2 != v3) {
    return 0;
  }
  if ((*((_WORD *)a1 + 11) & 0x1000) == 0) {
    a1 = (unsigned int *)*((void *)a1 + 1);
  }
  if ((*((_WORD *)a2 + 11) & 0x1000) == 0) {
    a2 = (int *)*((void *)a2 + 1);
  }
  return a1 == (unsigned int *)a2 || memcmp(a1, a2, v2) == 0;
}

BOOL re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString(uint64_t a1, char *a2, const re::TypeInfo *a3, char **a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_15:
      re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 != (unsigned __int16)v15) {
      goto LABEL_15;
    }
    BOOL v17 = WORD1(v14) == WORD1(v15);
    uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
    BOOL v17 = v17 && v16 == 0;
    if (!v17) {
      goto LABEL_15;
    }
  }
LABEL_4:
  int v50 = 0;
  if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v50, 0))
  {
    if (v50 == 1)
    {
      unsigned int v49 = 0;
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((unsigned int *)(a1 + 24), &v49, 0);
      if (!*(unsigned char *)(a1 + 64))
      {
        if (*(void *)(a1 + 408) <= (unint64_t)v49)
        {
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid reference ID for shared object: %u", v19, v20, v21, v22, v23, v49);
        }
        else
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v49, (uint64_t)&v45);
          if (v45 == *(void **)a5)
          {
            uint64_t v24 = **((void **)a5 + 2);
            if (v46 == (unsigned __int16)v24 && v47 == WORD1(v24) && ((v48 ^ HIDWORD(v24)) & 0xFFFFFF) == 0)
            {
              if ((a7 & 1) == 0)
              {
                if (*a4)
                {
                  uint64_t v42 = *a4;
                  if (v42 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v49))
                  {
                    (*(void (**)(void, char *))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), *a4);
                    *a4 = 0;
                  }
                }
                *a4 = (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v49);
                re::internal::SharedObjectGraph::addReference((void *)(a1 + 336), v49);
              }
              goto LABEL_36;
            }
          }
          uint64_t v25 = *(_anonymous_namespace_ **)(a1 + 272);
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v49, (uint64_t)&v45);
          uint64_t v43 = *((void *)re::TypeRegistry::typeName(v25, &v45) + 1);
          re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid reference ID for shared object. Expected type \"char *\". Actual type \"%s\".", v26, v27, v28, v29, v30, v43);
        }
      }
    }
    else
    {
      if (!v50)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
            *a4 = 0;
          }
        }
LABEL_36:
        re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        return *(unsigned char *)(a1 + 64) == 0;
      }
      if ((a7 & 1) == 0 && *a4)
      {
        (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
        *a4 = 0;
      }
      int v45 = 0;
      if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (uint64_t *)&v45, 0))
      {
        uint64_t v36 = v45 == (void *)-1;
        uint64_t v37 = v36 << 63 >> 63;
        if (v37 == v36 && (v37 & 0x8000000000000000) == 0)
        {
          uint64_t v38 = (char *)(*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), (uint64_t)v45 + 1, 0);
          uint64_t v39 = (uint64_t)v38;
          if ((a7 & 1) == 0) {
            *a4 = v38;
          }
          uint64_t v40 = (uint64_t)v45;
          if (v45)
          {
            re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v38, 0);
            uint64_t v40 = (uint64_t)v45;
          }
          *(unsigned char *)(v39 + v40) = 0;
          re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endString((_anonymous_namespace_ *)(a1 + 24));
          uint64_t v41 = **((void **)a5 + 2);
          *(void *)&long long v44 = *(void *)a5;
          *((void *)&v44 + 1) = v41;
          re::internal::SharedObjectGraph::addObject(a1 + 336, v39, &v44);
          goto LABEL_36;
        }
        re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, (char)v45);
      }
    }
  }
  return 0;
}

BOOL re::SerializerV1<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer(uint64_t a1, char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  BOOL isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6) {
    goto LABEL_4;
  }
  if (*(void *)this == *(void *)a6)
  {
    uint64_t v26 = **((void **)this + 2);
    uint64_t v27 = **((void **)a6 + 2);
    if ((unsigned __int16)v26 == (unsigned __int16)v27)
    {
      BOOL v29 = WORD1(v26) == WORD1(v27);
      uint64_t v28 = (v27 ^ v26) & 0xFFFFFF00000000;
      BOOL v29 = v29 && v28 == 0;
      if (v29) {
        goto LABEL_4;
      }
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    int v16 = 0;
    goto LABEL_5;
  }
  if (*((unsigned char *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (uint64_t v30 = re::TypeInfo::name(this), v31 = re::TypeInfo::name(a6), !re::StringID::operator==(v30, v31))))
  {
    re::internal::setTypeMismatchError<re::EncoderBinary<re::SeekableInputStream>>(a1, a2, this, a6);
    return 0;
  }
  int v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v58);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v59);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v58);
  re::TypeInfo::TypeInfo((uint64_t)v55, (uint64_t)v59);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    BOOL v17 = *v57;
    v54[0] = (re *)v56[0];
    v54[1] = v17;
    if (v56[0]) {
      goto LABEL_8;
    }
LABEL_15:
    uint64_t v45 = re::TypeInfo::name(this)[1];
    uint64_t v23 = "Failed to get actual type of polymorphic object. Type \"%s\".";
    uint64_t v24 = a1;
    uint64_t v25 = a2;
LABEL_16:
    re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(v24, v25, v23, v18, v19, v20, v21, v22, v45);
    return 0;
  }
  re::internal::actualType(a4, (void **)this, v54);
  if (!v54[0]) {
    goto LABEL_15;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v54, &v58);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v59);
  int v51 = 0;
  if (re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, a3, &v51, 0))
  {
    if (v51 != 1)
    {
      if (!v51)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v52, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            *a4 = 0;
          }
        }
        goto LABEL_56;
      }
      if (isPointerToPolymorphicType)
      {
        re::internal::deserializePolymorphicObject<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,true>(a1, a2, a3, (void **)a4, (re **)this, (re::TypeInfo *)v52, (re::TypeInfo *)v55, v16, a7);
        goto LABEL_56;
      }
      if (!a7)
      {
        Instance = *a4;
        if (!*a4) {
          Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v56, *(re::Allocator **)(a1 + 48), 0);
        }
        uint64_t v40 = 0;
        *a4 = Instance;
        goto LABEL_52;
      }
      uint64_t v37 = *(re::TypeRegistry **)(a1 + 272);
      if ((re::TypeRegistry *)v56[0] != v37)
      {
        uint64_t v38 = re::TypeInfo::name((re::TypeInfo *)v56);
        re::TypeRegistry::typeInfo(v37, (const re::StringID *)v38, &v58);
        if (!(_BYTE)v58)
        {
          Instance = 0;
          uint64_t v40 = 1;
          goto LABEL_52;
        }
        re::TypeInfo::operator=((uint64_t)v56, (uint64_t)v59);
      }
      Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v56, *(re::Allocator **)(a1 + 48), 0);
      uint64_t v40 = 0;
LABEL_52:
      uint64_t v41 = *v57;
      *(void *)&long long v46 = v56[0];
      *((void *)&v46 + 1) = v41;
      re::internal::SharedObjectGraph::beginObject((void *)(a1 + 336), (uint64_t)Instance, &v46);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, char *, void, char *, void *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, 0, Instance, v56, v55, v40);
      }
      if (*(unsigned char *)(a1 + 336))
      {
        --*(void *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
      goto LABEL_56;
    }
    unsigned int v50 = 0;
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((unsigned int *)(a1 + 24), &v50, 0);
    if (!*(unsigned char *)(a1 + 64))
    {
      if (*(void *)(a1 + 408) > (unint64_t)v50)
      {
        re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v50, (uint64_t)v49);
        if (!re::internal::areCompatible((re **)this, (uint64_t)v49))
        {
          uint64_t v42 = re::TypeInfo::name((re::TypeInfo *)v56)[1];
          uint64_t v43 = *(_anonymous_namespace_ **)(a1 + 272);
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v50, (uint64_t)&v58);
          LOBYTE(v45) = v42;
          re::TypeRegistry::typeName(v43, &v58);
          uint64_t v23 = "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".";
          goto LABEL_59;
        }
        if (a7)
        {
LABEL_56:
          re::EncoderBinary<re::SeekableInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
          return *(unsigned char *)(a1 + 64) == 0;
        }
        if (*a4)
        {
          uint64_t v33 = *a4;
          if (v33 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v50))
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v52, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            *a4 = 0;
          }
        }
        uint64_t v34 = re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v50);
        uint64_t v35 = (char **)v34;
        *a4 = (char *)v34;
        if ((*(unsigned char *)(v53 + 49) & 2) != 0)
        {
          long long v44 = *(void (**)(uint64_t))(v53 + 32);
          if (v44) {
            v44(v34);
          }
          re::internal::SharedObjectGraph::addReference((void *)(a1 + 336), v50);
        }
        else
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v50, (uint64_t)v48);
          if (!v48[0])
          {
            LOBYTE(v45) = v50;
            uint64_t v23 = "TypeID for shared object at index %d is invalid.";
            goto LABEL_59;
          }
          re::TypeRegistry::typeInfo(v48[0], v48, &v58);
          if (!(_BYTE)v58)
          {
            LOBYTE(v45) = v50;
            uint64_t v23 = "No TypeInfo found for shared object at index %d.";
            goto LABEL_59;
          }
          uint64_t v36 = re::TypeInfo::createInstance((re::TypeInfo *)v59, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          *a4 = (char *)v36;
          if ((re::TypeInfo::copy((re::TypeInfo *)v59, v36, v35, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264)) & 1) == 0)
          {
            uint64_t v45 = re::TypeInfo::name((re::TypeInfo *)v59)[1];
            uint64_t v23 = "Failed to copy non-shareable object of type '%s'.";
LABEL_59:
            uint64_t v24 = a1;
            uint64_t v25 = 0;
            goto LABEL_16;
          }
        }
        re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v50, (uint64_t)v47);
        re::TypeInfo::setActualTypeForPointer((void **)this, (uint64_t)a4, v47);
        goto LABEL_56;
      }
      LOBYTE(v45) = v50;
      uint64_t v23 = "Invalid reference ID for shared object: %u";
      goto LABEL_59;
    }
  }
  return 0;
}

unsigned int *re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(unsigned int *result, _DWORD *a2, int a3)
{
  if (!*((unsigned char *)result + 40))
  {
    char v3 = a3;
    uint64_t v5 = (_anonymous_namespace_ *)result;
    BOOL result = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)result, 0, 0, a3);
    if (result)
    {
      re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>((uint64_t)v5, "@ref", 0, a2, v3, (uint64_t)"uint32");
      return (unsigned int *)re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v5);
    }
  }
  return result;
}

BOOL re::internal::deserializePolymorphicObject<re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,true>(uint64_t a1, char *a2, uint64_t a3, void **a4, re **a5, re::TypeInfo *a6, re::TypeInfo *a7, int a8, char a9)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  uint64_t v15 = (_anonymous_namespace_ *)(a1 + 24);
  unsigned int v21 = re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((_anonymous_namespace_ *)(a1 + 24), a2, 0, 0);
  BOOL result = 0;
  if (v21)
  {
    uint64_t v23 = *(void *)(*(void *)(a1 + 152) + 48 * *(void *)(a1 + 136) - 8);
    if (!*(_DWORD *)v23)
    {
      re::Serializer<re::EncoderBinary<re::SeekableInputStream>>::setError(a1, 0, "Invalid object. Name of polymorphic type expected.", v16, v17, v18, v19, v20, v49);
      return 0;
    }
    uint64_t v24 = *(char **)(v23 + 8);
    if ((*((_WORD *)v24 + 11) & 0x1000) != 0) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = (char *)*((void *)v24 + 1);
    }
    unsigned int v50 = a5;
    if (v25)
    {
      uint64_t v26 = *v25;
      if (*v25)
      {
        char v27 = v25[1];
        if (v27)
        {
          uint64_t v28 = (unsigned __int8 *)(v25 + 2);
          do
          {
            uint64_t v26 = 31 * v26 + v27;
            int v29 = *v28++;
            char v27 = v29;
          }
          while (v29);
        }
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    uint64_t v30 = 2 * v26;
    v57[0] = 2 * v26;
    v57[1] = v25;
    int v31 = *(_DWORD *)(*((void *)a7 + 2) + 80);
    uint64_t v32 = (v31 - 1);
    if (v31 != 1)
    {
      uint64_t v33 = 0;
      while (1)
      {
        re::TypeInfo::derivedClass(a7, v33, (uint64_t)buf);
        uint64_t v34 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)buf);
        if ((*v34 ^ (unint64_t)v30) <= 1)
        {
          uint64_t v35 = (const char *)v34[1];
          if (v35 == v25 || !strcmp(v35, v25)) {
            break;
          }
        }
        if (v32 == ++v33) {
          goto LABEL_22;
        }
      }
      uint64_t v36 = *v59;
      uint64_t v55 = *(re **)buf;
      uint64_t v56 = v36;
      if (*(void *)buf)
      {
LABEL_26:
        if ((a9 & 1) == 0 && *a4)
        {
          re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          *a4 = 0;
        }
        re::TypeRegistry::typeInfo(*(re **)a7, &v55, buf);
        re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)&buf[8]);
        if (a8)
        {
          uint64_t v39 = *(re::TypeRegistry **)(a1 + 272);
        }
        else
        {
          uint64_t v39 = *(re::TypeRegistry **)(a1 + 272);
          if (*v50 == v39)
          {
            re::TypeInfo::operator=((uint64_t)a6, (uint64_t)v54);
            uint64_t v43 = v55;
            long long v44 = v56;
            goto LABEL_45;
          }
        }
        uint64_t v41 = re::TypeInfo::name((re::TypeInfo *)v54);
        uint64_t v42 = re::TypeRegistry::typeInfo(v39, (const re::StringID *)v41, buf);
        if (!buf[0])
        {
          uint64_t v45 = *re::foundationSerializationLogObjects((re *)v42);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v46 = re::TypeInfo::name((re::TypeInfo *)v54)[1];
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v46;
            _os_log_impl(&dword_233120000, v45, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", buf, 0xCu);
          }
          v53[0] = 0;
          v53[1] = 0xFFFFFFFFLL;
          (*(void (**)(uint64_t, void, void *))(*(void *)a1 + 16))(a1, 0, v53);
          if (!*(unsigned char *)(a1 + 64)) {
            (*(void (**)(uint64_t, char *, void, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v25, 0, 0, v54, v54, 1);
          }
          goto LABEL_49;
        }
        re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&buf[8]);
        uint64_t v43 = *(re **)a6;
        long long v44 = (re *)**((void **)a6 + 2);
LABEL_45:
        Instance = re::TypeInfo::createInstance(a6, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
        int v48 = Instance;
        if ((a9 & 1) == 0)
        {
          *a4 = Instance;
          v52[0] = v43;
          v52[1] = v44;
          re::internal::setActualType(a4, v50, v52);
        }
        v51[0] = v43;
        v51[1] = v44;
        (*(void (**)(uint64_t, void **, void *))(*(void *)a1 + 16))(a1, v48, v51);
        if (!*(unsigned char *)(a1 + 64)) {
          (*(void (**)(uint64_t, char *, void, void **, re::TypeInfo *, unsigned char *, BOOL))(*(void *)a1 + 72))(a1, v25, 0, v48, a6, v54, v48 == 0);
        }
LABEL_49:
        (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
        re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v15);
        re::StringID::destroyString((re::StringID *)v57);
        return *(unsigned char *)(a1 + 64) == 0;
      }
    }
LABEL_22:
    uint64_t v37 = re::TypeInfo::polymorphicObjectName(a7);
    if ((*v37 ^ (unint64_t)v30) <= 1)
    {
      uint64_t v37 = (uint64_t *)v37[1];
      if (v37 == (uint64_t *)v25 || (uint64_t v37 = (uint64_t *)strcmp((const char *)v37, v25), !v37))
      {
        uint64_t v38 = (re *)**((void **)a7 + 2);
        uint64_t v55 = *(re **)a7;
        uint64_t v56 = v38;
        if (v55) {
          goto LABEL_26;
        }
      }
    }
    uint64_t v40 = *re::foundationSerializationLogObjects((re *)v37);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v25;
      _os_log_error_impl(&dword_233120000, v40, OS_LOG_TYPE_ERROR, "Skipping unknown polymorphic type. Type name = \"%s\"", buf, 0xCu);
    }
    if ((a9 & 1) == 0 && *a4)
    {
      re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
      *a4 = 0;
    }
    re::EncoderRapidJSON<re::SeekableInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v15);
    re::StringID::destroyString((re::StringID *)v57);
    return 1;
  }
  return result;
}

void re::introspect_RealityFileSpecifierType(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF75F30, memory_order_acquire) & 1) == 0)
  {
    uint64_t v24 = (re *)__cxa_guard_acquire(&qword_26AF75F30);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      uint64_t v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)uint64_t v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "None";
      qword_26AF75F68 = (uint64_t)v26;
      char v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "Url";
      qword_26AF75F70 = (uint64_t)v28;
      int v29 = re::introspectionAllocator(v28);
      uint64_t v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "BundleID";
      qword_26AF75F78 = (uint64_t)v30;
      int v31 = re::introspectionAllocator(v30);
      uint64_t v32 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *((void *)v32 + 1) = 3;
      *((void *)v32 + 2) = "MemoryID";
      qword_26AF75F80 = (uint64_t)v32;
      uint64_t v33 = re::introspectionAllocator(v32);
      uint64_t v34 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 24, 8);
      *(_DWORD *)uint64_t v34 = 1;
      *(void *)(v34 + 8) = 4;
      *(void *)(v34 + 16) = "NameAlias";
      qword_26AF75F88 = v34;
      __cxa_guard_release(&qword_26AF75F30);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF75F38, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF75F38))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF75F90, "RealityFileSpecifierType", 1, 1, 1, 1);
    qword_26AF75F90 = (uint64_t)&unk_26E715E00;
    qword_26AF75FD0 = (uint64_t)&re::introspect_RealityFileSpecifierType(BOOL)::enumTable;
    dword_26AF75FA0 = 9;
    __cxa_guard_release(&qword_26AF75F38);
  }
  if ((_MergedGlobals_50 & 1) == 0)
  {
    _MergedGlobals_50 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF75F90, a2);
    uint64_t v36 = 0x63FC8598F9F42358;
    uint64_t v37 = "RealityFileSpecifierType";
    v40[0] = 0x31CD534126;
    v40[1] = "uint8_t";
    unsigned int v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v40);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v40);
      uint64_t v4 = (unsigned int *)qword_26AF75FD0;
      v39[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v40, &v36, 1, 1, (uint64_t)v39);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            unint64_t v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v38.var0 = 2 * v10;
            v38.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v40, v14, &v38);
            re::StringID::destroyString((re::StringID *)&v38);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              uint64_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    uint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v38.var0 = 2 * v18;
              v38.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v40, v22, &v38);
              re::StringID::destroyString((re::StringID *)&v38);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v40, v23);
      xmmword_26AF75FB0 = (__int128)v38;
      re::StringID::destroyString((re::StringID *)&v36);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v40);
      re::internal::assertLog((re::internal *)5, v35, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RealityFileSpecifierType", v36, v37);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_RealityFileDescriptor(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF75F40, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF75F40))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF75FD8, "RealityFileDescriptor");
    __cxa_guard_release(&qword_26AF75F40);
  }
  return &unk_26AF75FD8;
}

void re::initInfo_RealityFileDescriptor(re *this, re::IntrospectionBase *a2)
{
  v17[0] = 0x6D3EFC1FD26478B6;
  v17[1] = "RealityFileDescriptor";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF75F48, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF75F48);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::introspect_RealityFileSpecifierType(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "realityFileSpecifierType";
      *(void *)(v7 + 16) = &qword_26AF75F90;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF75F50 = v7;
      uint64_t v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::IntrospectionInfo<re::DynamicString>::get(1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "realityFileSpecifier";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF75F58 = v11;
      uint64_t v12 = re::introspectionAllocator((re *)v11);
      uint64_t v14 = re::IntrospectionInfo<re::DynamicString>::get(1, v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 72, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = "realityFileSpecifier2";
      *(void *)(v15 + 16) = v14;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0x2800000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(void *)(v15 + 48) = 0;
      *(void *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_26AF75F60 = v15;
      __cxa_guard_release(&qword_26AF75F48);
    }
  }
  *((void *)this + 2) = 0x4800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF75F50;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RealityFileDescriptor>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RealityFileDescriptor>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RealityFileDescriptor>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RealityFileDescriptor>;
  re::IntrospectionRegistry::add(this, v3);
  long long v16 = v18;
}

void *re::internal::defaultConstruct<re::RealityFileDescriptor>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 8) = 0u;
  uint64_t v4 = (void *)(a3 + 8);
  uint64_t v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v4, 0);
  *(_OWORD *)(a3 + 40) = 0u;
  uint64_t v6 = a3 + 40;
  *(_OWORD *)(v6 + 16) = 0u;
  return re::DynamicString::setCapacity((void *)v6, 0);
}

double re::internal::defaultDestruct<re::RealityFileDescriptor>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicString::deinit((re::DynamicString *)(a3 + 40));
  return re::DynamicString::deinit((re::DynamicString *)(a3 + 8));
}

void *re::internal::defaultConstructV2<re::RealityFileDescriptor>(uint64_t a1)
{
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  unsigned int v2 = (void *)(a1 + 8);
  uint64_t v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v2, 0);
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v4 = a1 + 40;
  *(_OWORD *)(v4 + 16) = 0u;
  return re::DynamicString::setCapacity((void *)v4, 0);
}

double re::internal::defaultDestructV2<re::RealityFileDescriptor>(uint64_t a1)
{
  re::DynamicString::deinit((re::DynamicString *)(a1 + 40));
  return re::DynamicString::deinit((re::DynamicString *)(a1 + 8));
}

uint64_t re::introspect_RealityFileDescriptor(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RealityFileDescriptor", (uint64_t (*)(re::internal *))re::allocInfo_RealityFileDescriptor, (re::IntrospectionBase *(*)(void))re::initInfo_RealityFileDescriptor, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RealityFileDescriptor>, this);
}

BOOL re::RealityFileDescriptor::hasURL(unsigned __int8 *a1, BOOL a2)
{
  int v2 = *a1;
  if (v2 == 4)
  {
    BOOL v3 = a2;
    if (a2)
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v5, (const re::DynamicString *)(a1 + 8));
      re::NamedFileRegistry::tryGetFilePathFor((os_unfair_lock_s *)v3, (uint64_t)&v5, v7);
      BOOL v3 = v7[0] != 0;
      if (v7[0] && (void)v8)
      {
        if (BYTE8(v8)) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
        long long v8 = 0u;
        long long v9 = 0u;
      }
      if (v5 && (v6 & 1) != 0) {
        (*(void (**)(void))(*(void *)v5 + 40))();
      }
    }
  }
  else
  {
    return v2 == 2 || v2 == 1;
  }
  return v3;
}

void re::RealityFileDescriptor::getURL(uint64_t a1@<X0>, os_unfair_lock_s *a2@<X1>, os_unfair_lock_s *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  switch(*(unsigned char *)a1)
  {
    case 1:
      re::DynamicString::DynamicString((re::DynamicString *)&v43, (const re::DynamicString *)(a1 + 8));
      *(unsigned char *)a4 = 1;
      uint64_t v7 = *(void *)&v43.st_rdev;
      *(void *)(a4 + 8) = *(void *)&v43.st_dev;
      *(void *)(a4 + 32) = v7;
      *(_OWORD *)(a4 + 16) = *(_OWORD *)&v43.st_ino;
      return;
    case 2:
      if (*(unsigned char *)(a1 + 16)) {
        long long v9 = *(re::Bundle **)(a1 + 24);
      }
      else {
        long long v9 = (re::Bundle *)(a1 + 17);
      }
      if ((*(unsigned char *)(a1 + 48) & 1) == 0)
      {
        uint64_t v11 = (const char *)(a1 + 49);
        if (a3) {
          goto LABEL_17;
        }
LABEL_32:
        long long v18 = *re::assetsLogObjects((re *)a1);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          v43.st_dev = 136315138;
          *(void *)&v43.st_mode = v9;
          _os_log_impl(&dword_233120000, v18, OS_LOG_TYPE_DEFAULT, "BundleFilePathRegistry not used to get URL, using fallback for %s", (uint8_t *)&v43, 0xCu);
        }
        re::Bundle::findWithBundleID(v9, &v43);
        uint64_t v19 = *(void *)&v43.st_dev;
        uint64_t v42 = *(void **)&v43.st_dev;
        *(void *)&v43.st_dev = 0;

        if (v19) {
          goto LABEL_22;
        }
LABEL_35:
        re::DynamicString::format((re::DynamicString *)"Failed to find bundle with bundle ID %s.", (re::DynamicString *)&v43, v9);
        uint64_t v17 = 0;
        long long v20 = *(_OWORD *)&v43.st_dev;
        uint64_t v21 = *(void *)&v43.st_uid;
        uint64_t v22 = *(void *)&v43.st_rdev;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + 8) = v20;
        *(void *)(a4 + 24) = v21;
        *(void *)(a4 + 32) = v22;
        goto LABEL_36;
      }
      uint64_t v11 = *(const char **)(a1 + 56);
      if (!a3) {
        goto LABEL_32;
      }
LABEL_17:
      re::BundleFilePathRegistry::findWithBundleID(a3, (uint64_t)v41, (id *)&v43);
      uint64_t v12 = *(void *)&v43.st_dev;
      uint64_t v42 = *(void **)&v43.st_dev;
      *(void *)&v43.st_dev = 0;

      if (*(void *)&v41[0])
      {
        if (BYTE8(v41[0])) {
          (*(void (**)(void))(**(void **)&v41[0] + 40))();
        }
        memset(v41, 0, sizeof(v41));
      }
      if (!v12) {
        goto LABEL_35;
      }
LABEL_22:
      re::Bundle::findFile((re::Bundle *)&v42, v11, (re::DynamicString *)v39);
      if (v39[8]) {
        int v13 = *(const char **)&v39[16];
      }
      else {
        int v13 = &v39[9];
      }
      if (stat(v13, &v43))
      {
        re::DynamicString::format((re::DynamicString *)"Could not find a reality file named %s in bundle with ID %s.", (re::DynamicString *)&v43, v11, v9);
        long long v14 = *(_OWORD *)&v43.st_dev;
        uint64_t v15 = *(void *)&v43.st_uid;
        uint64_t v16 = *(void *)&v43.st_rdev;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + 8) = v14;
        *(void *)(a4 + 24) = v15;
        *(void *)(a4 + 32) = v16;
      }
      else
      {
        if (v39[8]) {
          char v27 = *(re **)&v39[16];
        }
        else {
          char v27 = (re *)&v39[9];
        }
        re::fileURLWithPath(v27, (re::DynamicString *)&v43);
        if (v43.st_ino) {
          __darwin_ino64_t v28 = v43.st_ino >> 1;
        }
        else {
          __darwin_ino64_t v28 = LOBYTE(v43.st_ino) >> 1;
        }
        if (v28)
        {
          re::DynamicString::DynamicString((re::DynamicString *)v37, (const re::DynamicString *)&v43);
          *(unsigned char *)a4 = 1;
          *(void *)(a4 + 8) = *(void *)v37;
          *(void *)(a4 + 32) = v38;
          *(_OWORD *)(a4 + 16) = *(_OWORD *)&v37[8];
        }
        else
        {
          if (v39[8]) {
            uint64_t v32 = *(unsigned char **)&v39[16];
          }
          else {
            uint64_t v32 = &v39[9];
          }
          re::DynamicString::format((re::DynamicString *)"Failed to create a file URL from path %s.", (re::DynamicString *)v37, v32);
          long long v33 = *(_OWORD *)v37;
          uint64_t v34 = *(void *)&v37[16];
          uint64_t v35 = v38;
          *(unsigned char *)a4 = 0;
          *(_OWORD *)(a4 + 8) = v33;
          *(void *)(a4 + 24) = v34;
          *(void *)(a4 + 32) = v35;
        }
        if (*(void *)&v43.st_dev && (v43.st_ino & 1) != 0) {
          (*(void (**)(void))(**(void **)&v43.st_dev + 40))();
        }
      }
      if (*(void *)v39)
      {
        if (v39[8]) {
          (*(void (**)(void))(**(void **)v39 + 40))();
        }
      }
      uint64_t v17 = v42;
LABEL_36:

      return;
    case 3:
      char v6 = "This RealityFileDescriptor cannot produce a file URL.";
      goto LABEL_38;
    case 4:
      if (a2)
      {
        re::DynamicString::DynamicString((re::DynamicString *)v36, (const re::DynamicString *)(a1 + 8));
        re::NamedFileRegistry::tryGetFilePathFor(a2, (uint64_t)v36, &v43);
        if (*(void *)&v36[0])
        {
          if (BYTE8(v36[0])) {
            (*(void (**)(void))(**(void **)&v36[0] + 40))();
          }
          memset(v36, 0, sizeof(v36));
        }
        if (LOBYTE(v43.st_dev))
        {
          re::DynamicString::DynamicString((re::DynamicString *)v39, (const re::DynamicString *)&v43.st_ino);
          *(unsigned char *)a4 = 1;
          *(void *)(a4 + 8) = *(void *)v39;
          *(void *)(a4 + 32) = v40;
          *(_OWORD *)(a4 + 16) = *(_OWORD *)&v39[8];
        }
        else
        {
          if (*(unsigned char *)(a1 + 16)) {
            uint64_t v26 = *(void *)(a1 + 24);
          }
          else {
            uint64_t v26 = a1 + 17;
          }
          re::DynamicString::format((re::DynamicString *)"No file registered for alias '%s'", (re::DynamicString *)v39, v26);
          long long v29 = *(_OWORD *)v39;
          uint64_t v30 = *(void *)&v39[16];
          uint64_t v31 = v40;
          *(unsigned char *)a4 = 0;
          *(_OWORD *)(a4 + 8) = v29;
          *(void *)(a4 + 24) = v30;
          *(void *)(a4 + 32) = v31;
        }
        if (LOBYTE(v43.st_dev) && v43.st_ino && (v43.st_uid & 1) != 0) {
          (*(void (**)(void))(*(void *)v43.st_ino + 40))();
        }
      }
      else
      {
        char v6 = "This RealityFileDescriptor requires a valid NamedFileRegistry to get a file URL.";
LABEL_38:
        long long v23 = *(_OWORD *)&v43.st_dev;
        uint64_t v24 = *(void *)&v43.st_uid;
        uint64_t v25 = *(void *)&v43.st_rdev;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + 8) = v23;
        *(void *)(a4 + 24) = v24;
        *(void *)(a4 + 32) = v25;
      }
      return;
    default:
      char v6 = "kNone is an invalid RealityFileSpecifierType.";
      goto LABEL_38;
  }
}

uint64_t re::RealityFileDescriptor::getMemoryFileID@<X0>(re::RealityFileDescriptor *this@<X0>, uint64_t a2@<X8>)
{
  switch(*(unsigned char *)this)
  {
    case 1:
    case 2:
    case 4:
      BOOL v3 = "This RealityFileDescriptor cannot produce a MemoryFileID.";
      goto LABEL_6;
    case 3:
      uint64_t v12 = 0;
      if (*((unsigned char *)this + 16)) {
        uint64_t v5 = (const char *)*((void *)this + 3);
      }
      else {
        uint64_t v5 = (char *)this + 17;
      }
      uint64_t result = sscanf(v5, "%llu", &v12);
      if (result == 1)
      {
        uint64_t v10 = v12;
        *(unsigned char *)a2 = 1;
        *(void *)(a2 + 8) = v10;
      }
      else
      {
        if (*((unsigned char *)this + 16)) {
          uint64_t v11 = (char *)*((void *)this + 3);
        }
        else {
          uint64_t v11 = (char *)this + 17;
        }
        uint64_t result = re::DynamicString::format((re::DynamicString *)"Failed to parse MemoryFileID from string: %s", (re::DynamicString *)&v13, v11);
LABEL_7:
        long long v7 = v13;
        uint64_t v8 = v14;
        uint64_t v9 = v15;
        *(unsigned char *)a2 = 0;
        *(_OWORD *)(a2 + 8) = v7;
        *(void *)(a2 + 24) = v8;
        *(void *)(a2 + 32) = v9;
      }
      return result;
    default:
      BOOL v3 = "kNone is an invalid RealityFileSpecifierType.";
LABEL_6:
      goto LABEL_7;
  }
}

void *re::RealityFileDescriptor::makeWithURL@<X0>(re::RealityFileDescriptor *this@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 1;
  uint64_t v4 = re::DynamicString::DynamicString((re::DynamicString *)(a2 + 8), this);
  *(_OWORD *)(a2 + 40) = 0u;
  uint64_t v5 = a2 + 40;
  *(_OWORD *)(v5 + 16) = 0u;
  return re::DynamicString::setCapacity((void *)v5, 0);
}

void *re::RealityFileDescriptor::makeWithMemoryFileID@<X0>(re::RealityFileDescriptor *this@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 3;
  BOOL v3 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)(a2 + 8), this);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  return re::DynamicString::setCapacity((void *)(a2 + 40), 0);
}

void *re::RealityFileDescriptor::makeWithNameAlias@<X0>(const re::DynamicString *a1@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 4;
  BOOL v3 = re::DynamicString::DynamicString((re::DynamicString *)(a2 + 8), a1);
  *(_OWORD *)(a2 + 40) = 0u;
  uint64_t v4 = a2 + 40;
  *(_OWORD *)(v4 + 16) = 0u;
  return re::DynamicString::setCapacity((void *)v4, 0);
}

double re::RealityFileDescriptor::transform@<D0>(re::RealityFileDescriptor *this@<X0>, const re::SourceLoadDescriptorTransform *a2@<X1>, uint64_t a3@<X8>)
{
  switch(*(unsigned char *)this)
  {
    case 1:
      if (!re::DynamicString::operator==((uint64_t)this + 8, (uint64_t)a2 + 24)) {
        goto LABEL_2;
      }
      char v6 = re::DynamicString::DynamicString((re::DynamicString *)&v8, (const re::SourceLoadDescriptorTransform *)((char *)a2 + 56));
      memset(v11, 0, sizeof(v11));
      re::DynamicString::setCapacity(v11, 0);
      *(unsigned char *)a3 = 1;
      *(unsigned char *)(a3 + 8) = 1;
      *(void *)(a3 + 16) = v8;
      *(_OWORD *)(a3 + 24) = v9;
      uint64_t v7 = *(void *)&v11[0];
      *(void *)(a3 + 40) = v10;
      *(void *)(a3 + 48) = v7;
      *(void *)(a3 + 72) = *((void *)&v11[1] + 1);
      double result = *((double *)v11 + 1);
      *(_OWORD *)(a3 + 56) = *(_OWORD *)((char *)v11 + 8);
      break;
    case 2:
    case 3:
    case 4:
LABEL_2:
      *(unsigned char *)a3 = 0;
      break;
    default:
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "transform", 183);
      _os_crash();
      __break(1u);
      JUMPOUT(0x2333A8E44);
  }
  return result;
}

void *zip_write_file_header(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  char v6 = *(void **)a1;
  (*(void (**)(void, uint64_t, void))(*(void *)a1 + 8))(**(void **)a1, *(void *)(a1 + 32) + 30, 0);
  if (*(char *)(a1 + 31) < 0)
  {
    unint64_t v8 = *(void *)(a1 + 16);
    if (v8 >= 0x10000) {
      return 0;
    }
    uint64_t v7 = *(void *)(a1 + 8);
  }
  else
  {
    uint64_t v7 = a1 + 8;
    unint64_t v8 = *(unsigned __int8 *)(a1 + 31);
  }
  uint64_t v9 = ((uint64_t (*)(void, uint64_t, unint64_t))v6[3])(*v6, v7, v8);
  v6[14] += v9;
  if (v9 != v8) {
    return 0;
  }
  if ((a3 & 1) == 0)
  {
    uint64_t v10 = 0;
    if ((a3 & 2) == 0) {
      goto LABEL_13;
    }
    goto LABEL_11;
  }
  *(_OWORD *)uint64_t v26 = *(_OWORD *)(a1 + 40);
  if (!write_extra_field(v6, 1, (uint64_t)v26, 0x10uLL)) {
    return 0;
  }
  uint64_t v10 = 20;
  if ((a3 & 2) != 0)
  {
LABEL_11:
    if (!write_extra_field(v6, 65534, a1 + 60, 0x20uLL)) {
      return 0;
    }
    v10 += 36;
  }
LABEL_13:
  uint64_t v11 = *(void *)(a1 + 32);
  unint64_t v12 = v8 + 30;
  unint64_t v13 = v10 + v11 + v8 + 30;
  if (!(v13 % a2)) {
    goto LABEL_22;
  }
  uint64_t v14 = (v13 + a2 + 3) & -a2;
  if (((v13 + a2 - 1) & -a2) >= v13 + 4) {
    uint64_t v14 = (v13 + a2 - 1) & -a2;
  }
  unint64_t v15 = v14 - v13;
  size_t v16 = v14 - v13 - 4;
  if (v14 - v13 != 4)
  {
    double result = malloc_type_malloc(v14 - v13 - 4, 0x5B51575uLL);
    if (!result) {
      return result;
    }
    long long v18 = result;
    bzero(result, v16);
    BOOL v19 = write_extra_field(v6, 0xFFFF, (uint64_t)v18, v16);
    free(v18);
    if (!v19) {
      return 0;
    }
    goto LABEL_21;
  }
  *(_DWORD *)uint64_t v26 = 0xFFFF;
  uint64_t v20 = ((uint64_t (*)(void, unsigned char *, uint64_t))v6[3])(*v6, v26, 4);
  v6[14] += v20;
  if (v20 != 4) {
    return 0;
  }
LABEL_21:
  v10 += v15;
  uint64_t v11 = *(void *)(a1 + 32);
LABEL_22:
  *(_DWORD *)uint64_t v26 = 67324752;
  if (a3) {
    unsigned __int16 v21 = 45;
  }
  else {
    unsigned __int16 v21 = 20;
  }
  *(_DWORD *)&v26[4] = v21;
  *(_WORD *)&v26[8] = *(_WORD *)(a1 + 92);
  *(_DWORD *)&v26[10] = *(_DWORD *)(a1 + 94);
  *(_DWORD *)&v26[14] = *(_DWORD *)(a1 + 56);
  __int16 v28 = v8;
  __int16 v29 = v10;
  int8x16_t v22 = *(int8x16_t *)(a1 + 40);
  v23.i64[0] = 0xFFFFFFFFLL;
  v23.i64[1] = 0xFFFFFFFFLL;
  int8x16_t v24 = (int8x16_t)vcgtq_u64(v23, (uint64x2_t)v22);
  int32x2_t v27 = vrev64_s32(vmovn_s64((int64x2_t)vornq_s8(vandq_s8(v22, v24), v24)));
  ((void (*)(void, uint64_t, void))v6[1])(*v6, v11, 0);
  uint64_t v25 = ((uint64_t (*)(void, unsigned char *, uint64_t))v6[3])(*v6, v26, 30);
  v6[14] += v25;
  if (v25 != 30) {
    return 0;
  }
  ((void (*)(void, unint64_t, void))v6[1])(*v6, *(void *)(a1 + 32) + v10 + v12, 0);
  if (v10 + v8 >= 0x10000) {
    return 0;
  }
  else {
    return (void *)(v10 + v12);
  }
}

BOOL write_extra_field(void *a1, __int16 a2, uint64_t a3, unint64_t a4)
{
  if (a4 >> 16) {
    return 0;
  }
  uint64_t v13 = v4;
  uint64_t v14 = v5;
  v12[0] = a2;
  v12[1] = a4;
  uint64_t v10 = ((uint64_t (*)(void, _WORD *, uint64_t))a1[3])(*a1, v12, 4);
  a1[14] += v10;
  BOOL result = 0;
  if (v10 == 4)
  {
    if (!a4) {
      return 1;
    }
    uint64_t v11 = ((uint64_t (*)(void, uint64_t, unint64_t))a1[3])(*a1, a3, a4);
    a1[14] += v11;
    if (v11 == a4) {
      return 1;
    }
  }
  return result;
}

void ___ZN2re33assetsHighFrequencyLoggingEnabledEv_block_invoke(uint64_t a1, const char *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  re::Defaults::BOOLValue((re::Defaults *)"enableAssetsHFLogs", a2, (char *)v5);
  if (LOBYTE(v5[0])) {
    unsigned __int8 v3 = BYTE1(v5[0]);
  }
  else {
    unsigned __int8 v3 = 0;
  }
  re::assetsLogObjects(v2);
  uint64_t v4 = re::assetsLogObjects(void)::logObjects;
  if (os_log_type_enabled((os_log_t)re::assetsLogObjects(void)::logObjects, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = v3;
    _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "enableAssetsHFLogs=%d.", (uint8_t *)v5, 8u);
  }
  re::assetsHighFrequencyLoggingEnabled(void)::shouldLog = v3;
}

uint64_t *re::assetsLogObjects(re *this)
{
  {
    re::assetsLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Assets");
  }
  return &re::assetsLogObjects(void)::logObjects;
}

void *re::allocInfo_NetworkSendBlockingAssetLoadRequestService(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_51, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_51))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76058, "NetworkSendBlockingAssetLoadRequestService");
    __cxa_guard_release(&_MergedGlobals_51);
  }
  return &unk_26AF76058;
}

void re::initInfo_NetworkSendBlockingAssetLoadRequestService(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x1AFAAC597CC96262;
  v5[1] = "NetworkSendBlockingAssetLoadRequestService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 8) = &re::initInfo_NetworkSendBlockingAssetLoadRequestService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_NetworkSendBlockingAssetLoadRequestService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"NetworkSendBlockingAssetLoadRequestService", (uint64_t (*)(re::internal *))re::allocInfo_NetworkSendBlockingAssetLoadRequestService, (re::IntrospectionBase *(*)(void))re::initInfo_NetworkSendBlockingAssetLoadRequestService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NetworkSendBlockingAssetLoadRequestService>, this);
}

re::AssetHandle *re::AssetHandle::AssetHandle(re::AssetHandle *this, re::internal::AssetEntry *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = 0;
  re::internal::AssetEntry::makeAssetReference(a2, &v5);
  uint64_t v3 = *(void *)this;
  *(void *)this = v5;
  if (v3) {

  }
  return this;
}

uint64_t *re::AssetHandle::AssetHandle(uint64_t *a1, re::internal::AssetEntry *this)
{
  *a1 = 0;
  a1[1] = (uint64_t)this;
  a1[2] = 0;
  if (this)
  {
    re::internal::AssetEntry::makeAssetReference(this, &v5);
    uint64_t v3 = *a1;
    *a1 = (uint64_t)v5;
    if (v3) {
  }
    }
  return a1;
}

void re::AssetHandle::~AssetHandle(re::AssetHandle *this)
{
  int v2 = (uint64_t *)*((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = *v2;
    double v4 = re::DynamicString::deinit(*((re::DynamicString **)this + 2));
    (*(void (**)(uint64_t, uint64_t *, double))(*(void *)v3 + 40))(v3, v2, v4);
    *((void *)this + 2) = 0;
  }
  *((void *)this + 1) = 0;
  if (*(void *)this)
  {

    *(void *)this = 0;
  }
}

uint64_t re::AssetHandle::operator=(uint64_t a1, uint64_t *a2)
{
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)a1, *a2);
  *(void *)(a1 + 8) = a2[1];
  uint64_t v4 = a2[2];
  if (v4)
  {
    if (*(unsigned char *)(v4 + 8)) {
      uint64_t v5 = *(re::AssetPath **)(v4 + 16);
    }
    else {
      uint64_t v5 = (re::AssetPath *)(v4 + 9);
    }
    re::AssetHandle::setSerializationString((re::DynamicString *)a1, v5, *(re::Allocator **)v4);
  }
  else
  {
    long long v6 = *(uint64_t **)(a1 + 16);
    if (v6)
    {
      uint64_t v7 = *v6;
      double v8 = re::DynamicString::deinit(*(re::DynamicString **)(a1 + 16));
      (*(void (**)(uint64_t, uint64_t *, double))(*(void *)v7 + 40))(v7, v6, v8);
      *(void *)(a1 + 16) = 0;
    }
  }
  return a1;
}

re::DynamicString *re::AssetHandle::setSerializationString(re::DynamicString *this, re::AssetPath *a2, re::Allocator *a3)
{
  uint64_t v3 = this;
  uint64_t v4 = (uint64_t *)*((void *)this + 2);
  if (*(unsigned char *)a2)
  {
    if (!v4)
    {
      uint64_t v7 = (void *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 32, 8);
      _OWORD v7[2] = 0;
      v7[3] = 0;
      *uint64_t v7 = a3;
      v7[1] = 0;
      re::DynamicString::setCapacity(v7, 0);
      *((void *)v3 + 2) = v7;
    }
    v11[0] = re::AssetPath::fixLegacyPath(a2, (const char *)a2);
    v11[1] = v8;
    return re::DynamicString::operator=(*((re::DynamicString **)v3 + 2), (uint64_t)v11);
  }
  else if (v4)
  {
    uint64_t v9 = *v4;
    double v10 = re::DynamicString::deinit(*((re::DynamicString **)this + 2));
    this = (re::DynamicString *)(*(uint64_t (**)(uint64_t, uint64_t *, double))(*(void *)v9 + 40))(v9, v4, v10);
    *((void *)v3 + 2) = 0;
  }
  return this;
}

re::AssetHandle *re::AssetHandle::AssetHandle(re::AssetHandle *this, const re::AssetHandle *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)this, *(void *)a2);
  *((void *)this + 1) = *((void *)a2 + 1);
  uint64_t v4 = *((void *)a2 + 2);
  if (v4)
  {
    if (*(unsigned char *)(v4 + 8)) {
      uint64_t v5 = *(re::AssetPath **)(v4 + 16);
    }
    else {
      uint64_t v5 = (re::AssetPath *)(v4 + 9);
    }
    re::AssetHandle::setSerializationString(this, v5, *(re::Allocator **)v4);
  }
  else
  {
    long long v6 = (uint64_t *)*((void *)this + 2);
    if (v6)
    {
      uint64_t v7 = *v6;
      double v8 = re::DynamicString::deinit(*((re::DynamicString **)this + 2));
      (*(void (**)(uint64_t, uint64_t *, double))(*(void *)v7 + 40))(v7, v6, v8);
      *((void *)this + 2) = 0;
    }
  }
  return this;
}

re::AssetManager *re::AssetHandle::isAnyDependencyMutated@<X0>(re::AssetManager *this@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = (const re::internal::AssetEntry *)*((void *)this + 1);
  if (v3 && (this = (re::AssetManager *)*((void *)v3 + 3)) != 0)
  {
    re::AssetManager::findDependencies(this, v3, (uint64_t)v7);
    if (v8)
    {
      uint64_t v4 = v9 + 8;
      uint64_t v5 = 24 * v8;
      while (!*(unsigned char *)(*(void *)v4 + 256))
      {
        v4 += 24;
        v5 -= 24;
        if (!v5) {
          goto LABEL_7;
        }
      }
      char v6 = 1;
    }
    else
    {
LABEL_7:
      char v6 = 0;
    }
    *a2 = 1;
    a2[1] = v6;
    return (re::AssetManager *)re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v7);
  }
  else
  {
    *a2 = 0;
  }
  return this;
}

void re::AssetHandle::loadNow(uint64_t a1, int a2)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v8 = *re::assetsLogObjects(0);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return;
    }
    LOWORD(v30) = 0;
    uint64_t v9 = "load failed: can't load empty asset handle.";
    double v10 = v8;
    uint32_t v11 = 2;
    goto LABEL_24;
  }
  if (!*(void *)(a1 + 24))
  {
    unint64_t v12 = *re::assetsLogObjects((re *)a1);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      return;
    }
    if (*(unsigned char *)(a1 + 168)) {
      uint64_t v13 = *(void *)(a1 + 176);
    }
    else {
      uint64_t v13 = a1 + 169;
    }
    int v30 = 136315138;
    uint64_t v31 = v13;
    uint64_t v9 = "load failed: asset isn't in an asset manager '%s'";
    double v10 = v12;
    uint32_t v11 = 12;
LABEL_24:
    _os_log_error_impl(&dword_233120000, v10, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v30, v11);
    return;
  }
  unsigned int v3 = atomic_load((unsigned int *)(a1 + 704));
  if (v3 == 2) {
    return;
  }
  if (v3 == 3)
  {
    uint64_t v4 = (os_unfair_lock_s *)(a1 + 384);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 384));
    char v6 = *re::assetsLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      if (*(unsigned char *)(a1 + 168)) {
        uint64_t v7 = *(void *)(a1 + 176);
      }
      else {
        uint64_t v7 = a1 + 169;
      }
      uint64_t v22 = *(void *)(a1 + 728);
      uint64_t v23 = *(void *)(v22 + 224);
      int8x16_t v24 = *(const char **)(v22 + 232);
      uint64_t v25 = (const char *)(v22 + 225);
      if (v23) {
        uint64_t v25 = v24;
      }
      int v30 = 136315394;
      uint64_t v31 = v7;
      __int16 v32 = 2080;
      long long v33 = v25;
      uint64_t v26 = "load failed: asset loading already has failed '%s' (%s)";
LABEL_32:
      int32x2_t v27 = v6;
      uint32_t v28 = 22;
LABEL_39:
      _os_log_error_impl(&dword_233120000, v27, OS_LOG_TYPE_ERROR, v26, (uint8_t *)&v30, v28);
    }
LABEL_16:
    os_unfair_lock_unlock(v4);
    return;
  }
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 384));
  if (*(unsigned char *)(a1 + 417) || *(_DWORD *)(a1 + 120) == 4)
  {
    size_t v16 = *re::assetsLogObjects(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      if (*(unsigned char *)(a1 + 168)) {
        uint64_t v21 = *(void *)(a1 + 176);
      }
      else {
        uint64_t v21 = a1 + 169;
      }
      int v30 = 136315138;
      uint64_t v31 = v21;
      uint64_t v26 = "loadNow doesn't work on network loaded assets. Use AssetLoadRequest instead. For '%s'";
      int32x2_t v27 = v16;
      uint32_t v28 = 12;
      goto LABEL_39;
    }
    goto LABEL_16;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 384));
  re::AssetManager::loadNow(*(re::AssetManager **)(a1 + 24), (re::internal::AssetEntry *)a1, a2);
  unsigned int v17 = atomic_load((unsigned int *)(a1 + 704));
  if (v17 != 2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 384));
    uint64_t v19 = *(void *)(a1 + 728);
    if (*(unsigned char *)(v19 + 208))
    {
      if (*(unsigned char *)(v19 + 224)) {
        uint64_t v20 = *(const char **)(v19 + 232);
      }
      else {
        uint64_t v20 = (const char *)(v19 + 225);
      }
    }
    else
    {
      uint64_t v20 = "unknown reason";
    }
    char v6 = *re::assetsLogObjects(v18);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      goto LABEL_16;
    }
    if (*(unsigned char *)(a1 + 168)) {
      uint64_t v29 = *(void *)(a1 + 176);
    }
    else {
      uint64_t v29 = a1 + 169;
    }
    int v30 = 136315394;
    uint64_t v31 = v29;
    __int16 v32 = 2080;
    long long v33 = v20;
    uint64_t v26 = "load failed: couldn't load '%s' (%s)";
    goto LABEL_32;
  }
}

void re::AssetHandle::loadAsync(re::AssetHandle *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    int v2 = *(unsigned __int8 **)(v1 + 24);
    if (v2)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v1 + 384));
      re::AssetManager::loadAssetAsync_entryStateLocked(v2, (re::internal::AssetEntry *)v1, 0);
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 384));
    }
    else
    {
      uint64_t v4 = *re::assetsLogObjects(this);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        uint64_t v5 = *((void *)this + 1);
        if (*(unsigned char *)(v5 + 168)) {
          uint64_t v6 = *(void *)(v5 + 176);
        }
        else {
          uint64_t v6 = v5 + 169;
        }
        int v7 = 136315138;
        uint64_t v8 = v6;
        _os_log_error_impl(&dword_233120000, v4, OS_LOG_TYPE_ERROR, "Can't load asset that isn't in an asset manager '%s'", (uint8_t *)&v7, 0xCu);
      }
    }
  }
}

void re::AssetHandle::internalForceUnloadAsync(re::AssetHandle *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    uint64_t v3 = *(void *)(v1 + 24);
    if (v3)
    {
      re::AssetManager::unloadAssetAsync(v3, v1, 1);
    }
    else
    {
      uint64_t v4 = *re::assetsLogObjects(0);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        uint64_t v5 = *((void *)this + 1);
        if (*(unsigned char *)(v5 + 168)) {
          uint64_t v6 = *(void *)(v5 + 176);
        }
        else {
          uint64_t v6 = v5 + 169;
        }
        int v7 = 136315138;
        uint64_t v8 = v6;
        _os_log_error_impl(&dword_233120000, v4, OS_LOG_TYPE_ERROR, "Can't unload asset that isn't in an asset manager '%s'", (uint8_t *)&v7, 0xCu);
      }
    }
  }
}

void re::AssetHandle::loadFailedErrorCode(re::AssetHandle *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *((void *)this + 1);
  if (v3 && (unsigned int v4 = atomic_load((unsigned int *)(v3 + 704)), v4 == 3))
  {
    uint64_t v6 = (os_unfair_lock_s *)(*((void *)this + 1) + 384);
    os_unfair_lock_lock(v6);
    uint64_t v7 = *(void *)(*((void *)this + 1) + 728);
    int v8 = *(unsigned __int8 *)(v7 + 196);
    *(unsigned char *)a2 = v8;
    if (v8) {
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v7 + 200);
    }
    os_unfair_lock_unlock(v6);
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
}

void re::AssetHandle::loadFailedMessage(re::AssetHandle *this@<X0>, re::DynamicString *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 1);
  if (v3 && (unsigned int v4 = atomic_load((unsigned int *)(v3 + 704)), v4 == 3))
  {
    uint64_t v6 = (os_unfair_lock_s *)(*((void *)this + 1) + 384);
    os_unfair_lock_lock(v6);
    uint64_t v7 = *(void *)(*((void *)this + 1) + 728);
    if (*(unsigned char *)(v7 + 208)) {
      uint64_t v9 = (const re::DynamicString *)(v7 + 216);
    }
    else {
      uint64_t v9 = (const re::DynamicString *)&v10;
    }
    re::DynamicString::DynamicString(a2, v9);
    if (v10)
    {
      if (v11) {
        (*(void (**)(void))(*(void *)v10 + 40))();
      }
    }
    os_unfair_lock_unlock(v6);
  }
  else
  {
  }
}

void *re::AssetHandle::legacy_assetPath(re::AssetHandle *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    return (void *)(v1 + 32);
  }
  {
    byte_26879E390 = 0;
    *(void *)algn_26879E388 = "assetPathNull allocator";
  }
  {
  }
}

void re::AssetHandle::getLegacyAppPath(re::AssetHandle *this@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 1);
  if (!v3) {
    goto LABEL_14;
  }
  unsigned int v4 = *(os_unfair_lock_s **)(v3 + 24);
  if (!v4) {
    goto LABEL_14;
  }
  int v6 = *((_DWORD *)re::AssetHandle::assetInfo(this) + 22);
  if (v6 == 1)
  {
    uint64_t v10 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(this);
    uint64_t v11 = *((void *)v10 + 1);
    v18[1] = 0;
    uint64_t v19 = 0;
    uint64_t v17 = v11;
    v18[0] = 0;
    re::DynamicString::setCapacity(&v17, 0);
    re::AssetPath::fullAssetPath(v10, (re::DynamicString *)&v17);
    if (re::AssetPath::pathIsAppBased((uint64_t)&v17))
    {
      *a2 = 1;
      re::DynamicString::DynamicString((re::DynamicString *)(a2 + 8), (const re::DynamicString *)&v17);
    }
    else
    {
      *a2 = 0;
    }
    if (v17 && (v18[0] & 1) != 0) {
      (*(void (**)(void))(*(void *)v17 + 40))();
    }
    return;
  }
  if (v6 != 8)
  {
LABEL_14:
    *a2 = 0;
    return;
  }
  re::AssetManager::lookupLoadDescriptors(v4, this, &v17);
  if (!v19)
  {
LABEL_12:
    if ((_BYTE)v17) {
      re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v18);
    }
    goto LABEL_14;
  }
  uint64_t v7 = v20;
  uint64_t v8 = 144 * v19;
  while (1)
  {
    uint64_t v9 = (*(void *)(v7 + 8) & 1) != 0 ? *(const char **)(v7 + 16) : (const char *)(v7 + 9);
    if (!strcmp(v9, "AssetPath")) {
      break;
    }
    v7 += 144;
    v8 -= 144;
    if (!v8) {
      goto LABEL_12;
    }
  }
  *(void *)&double v13 = re::AssetManager::convertToAssetPath((uint64_t)v4, v7, (uint64_t)v14).n128_u64[0];
  if (v14[0])
  {
    if (re::AssetPath::pathIsAppBased((uint64_t)&v15))
    {
      *a2 = 1;
      re::DynamicString::DynamicString((re::DynamicString *)(a2 + 8), (const re::DynamicString *)&v15);
    }
    else
    {
      *a2 = 0;
    }
    if (v15 && (v16 & 1) != 0) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    if ((_BYTE)v17) {
      re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v18);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v12, v13, "assertion failure: '%s' (%s:line %i) Converting loadDescriptor to asset path failed.", "result.isOk()", "getLegacyAppPath", 435);
    _os_crash();
    __break(1u);
  }
}

void *re::AssetHandle::assetInfo(re::AssetHandle *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    return (void *)(v1 + 32);
  }
  {
    byte_26879E408 = 0;
    unk_26879E400 = "assetInformationNull allocator";
  }
  {
  }
}

void re::AssetHandle::getDescription(re::AssetHandle *this@<X0>, char a2@<W1>, re::DynamicString *a3@<X8>)
{
  unsigned int v4 = (const re::internal::AssetEntry *)*((void *)this + 1);
  if (v4)
  {
    int v6 = (os_unfair_lock_s *)*((void *)v4 + 3);
    os_unfair_lock_lock(v6 + 16);
    re::AssetManager::getDescription_assetTablesLocked((re::AssetManager *)v6, v4, a2, (uint64_t)a3);
    os_unfair_lock_unlock(v6 + 16);
  }
  else
  {
  }
}

uint64_t re::AssetPathMapping::lookupString(re::AssetPathMapping *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  if (!*((void *)a3 + 1)) {
    return 0;
  }
  uint64_t result = re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::tryGet((uint64_t)this, (uint64_t)a3);
  if (result)
  {
    re::DynamicString::operator=(a2, (re::DynamicString *)result);
    return 1;
  }
  return result;
}

uint64_t re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    uint64_t v3 = *(void *)(v2 + 664);
  }
  else {
    uint64_t v3 = 0;
  }
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v4 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v3 ^ (v4 >> 31) ^ v4) % *(unsigned int *)(a1 + 24)));
  if (v5 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  if (*(void *)(v7 + 72 * v5 + 24) != v2)
  {
    while (1)
    {
      LODWORD(v5) = *(_DWORD *)(v7 + 72 * v5 + 8) & 0x7FFFFFFF;
      if (v5 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v7 + 72 * v5 + 24) == v2) {
        return v7 + 72 * v5 + 40;
      }
    }
    return 0;
  }
  return v7 + 72 * v5 + 40;
}

uint64_t re::AssetHandle::introspectionSerialize(uint64_t a1, uint64_t a2, re::DynamicString *a3, re::AssetSerializationScheme *a4)
{
  if (a1)
  {
    unint64_t v4 = *(uint64_t (**)(void))(**(void **)a1 + 16);
    return v4();
  }
  else
  {
    v7[0] = 0;
    uint64_t v6 = re::AssetSerializationScheme::commonCodingKey(a4, a3, (const re::AssetHandle *)0xD, v7);
    re::Optional<re::AssetPath>::~Optional(v7);
    return v6;
  }
}

uint64_t re::AssetHandle::introspectionDeserialize(re::Allocator *a1, void *a2, int a3, re::DynamicString *a4, char *__s1)
{
  if (*__s1)
  {
    uint64_t v6 = __s1;
    if (!strncmp(__s1, "framework:", 0xAuLL))
    {
      std::string::basic_string[abi:nn180100]<0>(&__str, v6);
      std::string::basic_string[abi:nn180100]<0>(&__p, "/");
      if (v30[23] < 0)
      {
        std::string::__init_copy_ctor_external(&v38, *(const std::string::value_type **)v30, *((void *)v30 + 1));
      }
      else
      {
        long long v10 = *(_OWORD *)v30;
        v38.__r_.__value_.__r.__words[2] = *((void *)v30 + 2);
        *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v10;
      }
      v37.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
      if (SHIBYTE(v35) < 0) {
        operator delete(__p);
      }
      std::string::basic_string[abi:nn180100]<0>(&__p, ":");
      if (v30[47] < 0) {
        std::string::__init_copy_ctor_external(&v37, *((const std::string::value_type **)v30 + 3), *((void *)v30 + 4));
      }
      else {
        std::string v37 = *(std::string *)(v30 + 1);
      }
      uint64_t v40 = &v30;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v40);
      if (SHIBYTE(v35) < 0) {
        operator delete(__p);
      }
      int v12 = SHIBYTE(v37.__r_.__value_.__r.__words[2]);
      double v13 = (void *)v37.__r_.__value_.__r.__words[0];
      if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v14 = &v37;
      }
      else {
        uint64_t v14 = (std::string *)v37.__r_.__value_.__r.__words[0];
      }
      if (re::isEngineFrameworkIdentifier((re *)v14, v11))
      {
        int64_t v15 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_str = &__str;
        }
        else {
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v17 = &v38;
        }
        else {
          uint64_t v17 = (std::string *)v38.__r_.__value_.__r.__words[0];
        }
        if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int64_t size = HIBYTE(v38.__r_.__value_.__r.__words[2]);
        }
        else {
          int64_t size = v38.__r_.__value_.__l.__size_;
        }
        if (size)
        {
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            int64_t v15 = __str.__r_.__value_.__l.__size_;
          }
          uint64_t v19 = (char *)p_str + v15;
          if (v15 >= size)
          {
            int v26 = v17->__r_.__value_.__s.__data_[0];
            int32x2_t v27 = p_str;
            do
            {
              int64_t v28 = v15 - size;
              if (v28 == -1) {
                break;
              }
              uint64_t v29 = (char *)memchr(v27, v26, v28 + 1);
              if (!v29) {
                break;
              }
              uint64_t v20 = v29;
              if (!memcmp(v29, v17, size)) {
                goto LABEL_36;
              }
              int32x2_t v27 = (std::string *)(v20 + 1);
              int64_t v15 = v19 - (v20 + 1);
            }
            while (v15 >= size);
          }
          uint64_t v20 = v19;
LABEL_36:
          if (v20 == v19) {
            std::string::size_type v21 = -1;
          }
          else {
            std::string::size_type v21 = v20 - (char *)p_str;
          }
        }
        else
        {
          std::string::size_type v21 = 0;
        }
        uint64_t v22 = std::string::replace(&__str, v21, size + 1, "engine:");
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v23 = &__str;
        }
        else {
          uint64_t v23 = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        LOBYTE(v30) = 1;
        uint64_t v6 = v35;
        v32[1] = v35;
        v32[2] = v36;
        char v24 = v34;
        uint64_t v31 = __p;
        v32[0] = v34;
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v37.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v38.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        if ((v24 & 1) == 0) {
          uint64_t v6 = (char *)v32 + 1;
        }
        if (a2) {
          goto LABEL_4;
        }
        goto LABEL_58;
      }
      if (v12 < 0) {
        operator delete(v13);
      }
      if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v38.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }
    LOBYTE(v30) = 0;
    if (a2)
    {
LABEL_4:
      uint64_t v9 = (*(uint64_t (**)(void, re::DynamicString *, char *, re::Allocator *))(*(void *)*a2 + 24))(*a2, a4, v6, a1);
LABEL_59:
      if (_BYTE)v30 && v31 && (v32[0]) {
        (*(void (**)(void))(*(void *)v31 + 40))();
      }
      return v9;
    }
LABEL_58:
    re::AssetHandle::setSerializationString(a4, (re::AssetPath *)v6, a1);
    uint64_t v9 = 1;
    goto LABEL_59;
  }
  if (*(void *)a4)
  {

    *(void *)a4 = 0;
  }
  *((void *)a4 + 1) = 0;
  return 1;
}

uint64_t re::AssetHandle::introspectionDeepCopy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  re::AssetHandle::operator=(a5, a4);
  return 1;
}

uint64_t re::AssetHandle::hasAssetHandle(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v23 = 0x190DE9534BBF230;
  char v24 = "AssetHandle";
  uint64_t v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v23);
  if (v3)
  {
    uint64_t v4 = *v3;
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  re::StringID::destroyString((re::StringID *)&v23);
  uint64_t v5 = (uint64_t *)a1[2];
  if (*a1 == v2)
  {
    uint64_t v6 = *v5;
    if ((unsigned __int16)*v5 == (unsigned __int16)v4)
    {
      BOOL v8 = WORD1(v6) == WORD1(v4);
      uint64_t v7 = (v6 ^ v4) & 0xFFFFFF00000000;
      BOOL v8 = v8 && v7 == 0;
      if (v8) {
        return 1;
      }
    }
  }
  int v9 = *((unsigned __int8 *)a1 + 12);
  if (v9 == 5)
  {
    re::TypeRegistry::typeInfo((void *)*a1, v5[9], &v23);
    re::TypeInfo::TypeInfo((uint64_t)v19, (uint64_t)&v24);
    uint64_t v10 = re::TypeInfo::TypeInfo((uint64_t)v22, (uint64_t)v19);
    if (re::AssetHandle::hasAssetHandle(v10)) {
      return 1;
    }
    int v9 = *((unsigned __int8 *)a1 + 12);
  }
  if (v9 == 6)
  {
    re::TypeRegistry::typeInfo((void *)*a1, *(void *)(a1[2] + 80), &v23);
    re::TypeInfo::TypeInfo((uint64_t)v19, (uint64_t)&v24);
    re::TypeInfo::TypeInfo((uint64_t)v21, (uint64_t)v19);
    if (re::AssetHandle::hasAssetHandle(v21)) {
      return 1;
    }
    int v9 = *((unsigned __int8 *)a1 + 12);
  }
  if (v9 == 8)
  {
    re::TypeMemberCollection::TypeMemberCollection((uint64_t)v19, *a1, a1[2]);
    uint64_t v12 = v20;
    if (v20)
    {
      unint64_t v13 = 0;
      while (1)
      {
        re::TypeMemberCollection::operator[](v19, v13, (uint64_t)v18);
        re::TypeRegistry::typeInfo(v18[0], *v18[2], &v23);
        re::TypeInfo::TypeInfo((uint64_t)v17, (uint64_t)&v24);
        if (re::AssetHandle::hasAssetHandle(v17)) {
          break;
        }
        if (v12 == ++v13) {
          return 0;
        }
      }
      return 1;
    }
    uint64_t v14 = *(const char **)a1[2];
    uint64_t v23 = *a1;
    char v24 = v14;
    int v25 = -1;
    v18[0] = (void *)0x258C98EAAF29A10ALL;
    v18[1] = "CallbackSerializerAttribute";
    int64_t v15 = (uint64_t *)re::TypeAttributeCollection::operator[](&v23, v18);
    re::StringID::destroyString((re::StringID *)v18);
    if (v15)
    {
      uint64_t v16 = *v15;
      if (*v15)
      {
        if (*(void *)(v16 + 96) && *(void *)(v16 + 104)) {
          return 1;
        }
      }
    }
  }
  return 0;
}

uint64_t re::AssetHandle::assetWithType(re::AssetHandle *this, const re::AssetType *a2, int a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t result = *((void *)this + 1);
  if (result)
  {
    if (a3)
    {
      unsigned int v6 = atomic_load((unsigned int *)(result + 704));
      if (v6 != 2) {
        return 0;
      }
    }
    else
    {
      re::AssetHandle::loadNow(result, 0);
    }
    hasAssetPointer = (re *)re::internal::AssetEntry::hasAssetPointer(*((re::internal::AssetEntry **)this + 1));
    if ((hasAssetPointer & 1) == 0)
    {
      BOOL v8 = *re::assetsLogObjects(hasAssetPointer);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *((void *)this + 1);
        if (*(unsigned char *)(v9 + 168)) {
          uint64_t v10 = *(void *)(v9 + 176);
        }
        else {
          uint64_t v10 = v9 + 169;
        }
        uint64_t v11 = *(void *)a2;
        int v12 = 136315394;
        uint64_t v13 = v10;
        __int16 v14 = 2080;
        uint64_t v15 = v11;
        _os_log_impl(&dword_233120000, v8, OS_LOG_TYPE_DEFAULT, "Asset %s with type %s has no asset pointer.", (uint8_t *)&v12, 0x16u);
      }
    }
    return re::internal::AssetEntry::assetPointer(*((re::internal::AssetEntry **)this + 1));
  }
  return result;
}

uint64_t re::AssetHandle::assetWithTypeRaw(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    return 0;
  }
  if (!*(void *)(v4 + 712))
  {
    if (a3)
    {
      unsigned int v6 = (os_unfair_lock_s *)(v4 + 384);
      os_unfair_lock_lock((os_unfair_lock_t)(v4 + 384));
      uint64_t v7 = re::internal::AssetEntry::assetPointer(*(re::internal::AssetEntry **)(a1 + 8));
      if (v7)
      {
LABEL_10:
        os_unfair_lock_unlock(v6);
        return v7;
      }
      uint64_t v8 = *(void *)(*(void *)(a1 + 8) + 720);
      if (v8)
      {
        uint64_t v7 = *(void *)(v8 + 24);
        goto LABEL_10;
      }
      os_unfair_lock_unlock(v6);
    }
    return 0;
  }
  return re::internal::AssetEntry::assetPointer((re::internal::AssetEntry *)v4);
}

void re::AssetHandle::internalCloneAssetFromSharedAsset(re::AssetHandle *this)
{
  if ((int)[(id)(*(void *)(*((void *)this + 1) + 712) + 8) retainCount] >= 2)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2)
    {
      if (*(void *)(v2 + 24))
      {
        uint64_t v3 = (os_unfair_lock_s *)(v2 + 384);
        os_unfair_lock_lock((os_unfair_lock_t)(v2 + 384));
        uint64_t v4 = (re::internal::AssetEntry *)*((void *)this + 1);
        uint64_t v5 = (re::AssetLoader *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)(*((void *)v4 + 3) + 1040), *((void *)v4 + 33));
        unsigned int v6 = (void *)re::internal::AssetEntry::assetPointer(v4);
        uint64_t v7 = (re::internal::SharedAssetPointer *)re::AssetLoader::cloneAsset(v5, v6);
        re::internal::SharedAssetPointer::makeSharedAssetPointer(v7, &v8);
        re::internal::AssetEntry::LoadState::setAssetPointer_locked((__uint64_t)v4 + 704, (uint64_t *)&v8);
        if (v8) {

        }
        re::AssetHandle::internalRegisterAsset(this);
        os_unfair_lock_unlock(v3);
      }
    }
  }
}

uint64_t re::AssetHandle::internalRegisterAsset(re::AssetHandle *this)
{
  uint64_t v2 = (re::internal::AssetEntry *)*((void *)this + 1);
  uint64_t v3 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)(*((void *)v2 + 3) + 1040), *((void *)v2 + 33));
  uint64_t v4 = re::internal::AssetEntry::assetPointer(v2);
  uint64_t v5 = re::AssetHandle::assetInfo(this);
  unsigned int v6 = *(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 80);
  return v6(v3, v4, v5);
}

uint64_t re::AssetHandle::internalUnregisterAsset(re::AssetHandle *this)
{
  uint64_t v2 = (re::internal::AssetEntry *)*((void *)this + 1);
  uint64_t v3 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)(*((void *)v2 + 3) + 1040), *((void *)v2 + 33));
  uint64_t v4 = re::internal::AssetEntry::assetPointer(v2);
  uint64_t v5 = re::AssetHandle::assetInfo(this);
  unsigned int v6 = *(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 88);
  return v6(v3, v4, v5);
}

uint64_t re::AssetHandle::setNetworkSharingMode(uint64_t a1, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(*(void *)(a1 + 8) + 384);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(_DWORD *)(v6 + 420);
  BOOL v8 = v7 == a2;
  if (v7 == a2)
  {
LABEL_5:
    os_unfair_lock_unlock(v4);
    return v8;
  }
  if (v7)
  {
    uint64_t v9 = *re::assetsLogObjects(v5);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_error_impl(&dword_233120000, v9, OS_LOG_TYPE_ERROR, "setNetworkSharingMode: re-enabling network sharing is not supported.", v15, 2u);
    }
    goto LABEL_5;
  }
  *(_DWORD *)(v6 + 420) = a2;
  os_unfair_lock_unlock(v4);
  uint64_t v11 = *(void *)(a1 + 8);
  uint64_t v12 = *(void *)(v11 + 24);
  if (*(void *)(v12 + 1144))
  {
    uint64_t v13 = *(void *)(v11 + 112);
    if (v13 == -1) {
      uint64_t v14 = 0;
    }
    else {
      uint64_t v14 = v13;
    }
    re::NetworkActionQueue::queueSyncActionRestrictAssetShareMode(v12 + 704, v14, a2);
  }
  return 1;
}

void re::AssetHandle::payloadDidChangeIfPossible(re::AssetHandle *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!*(unsigned char *)(v1 + 312))
  {
    if (*((_DWORD *)re::AssetHandle::assetInfo(this) + 22) != 8) {
      return;
    }
    uint64_t v1 = *((void *)this + 1);
  }
  uint64_t v3 = *(re::AssetManager **)(v1 + 24);
  re::AssetManager::assetPayloadDidChange(v3, (re::internal::AssetEntry *)v1);
}

BOOL re::AssetHandle::isMemoryAssetWithNetworkingSyncingEnabled(re::AssetHandle *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!*(unsigned char *)(v1 + 312)) {
    return 0;
  }
  uint64_t v2 = (os_unfair_lock_s *)(v1 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 384));
  int v3 = *(_DWORD *)(v1 + 420);
  os_unfair_lock_unlock(v2);
  return v3 == 0;
}

re::DynamicString *re::AssetHandle::serializationString@<X0>(re::AssetHandle *this@<X0>, re::DynamicString *a2@<X8>)
{
  int v3 = (const re::DynamicString *)*((void *)this + 2);
  if (v3)
  {
    return re::DynamicString::DynamicString(a2, v3);
  }
  else
  {
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    return (re::DynamicString *)re::DynamicString::setCapacity(a2, 0);
  }
}

double re::AssetHandle::setOrClearMetadataString(re::AssetHandle *this, const char *a2, const char *a3)
{
  uint64_t v6 = (os_unfair_lock_s *)*((void *)this + 1);
  v8[0] = 0;
  v8[1] = "";
  os_unfair_lock_lock(v6 + 96);
  re::internal::AssetEntry::setOrClearMetadata_stateLocked((re::internal::AssetEntry *)v6, (const re::StringID *)v8, a3);
  os_unfair_lock_unlock(v6 + 96);
  re::StringID::destroyString((re::StringID *)v8);
  return re::internal::AssetEntry::updateMetadata(*((re::internal::AssetEntry **)this + 1), 0);
}

void re::AssetHandle::composedMetadata(re::AssetHandle *this@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)(a2 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *(void *)(*(void *)(v4 + 24) + 1144);
  if (v5 && (unint64_t)(*(void *)(v4 + 112) + 1) >= 2)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 72))(v5);
    uint64_t v4 = *((void *)this + 1);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 384));
  uint64_t v6 = *(unsigned int *)(v4 + 456);
  lock = (os_unfair_lock_s *)(v4 + 384);
  uint64_t v7 = 0;
  if (v6)
  {
    BOOL v8 = (int *)(*(void *)(v4 + 440) + 8);
    while (1)
    {
      int v9 = *v8;
      v8 += 22;
      if (v9 < 0) {
        break;
      }
      if (v6 == ++v7)
      {
        LODWORD(v7) = *(_DWORD *)(v4 + 456);
        break;
      }
    }
  }
  if (v6 != v7)
  {
    uint64_t v10 = v7;
    uint64_t v11 = *(void *)(v4 + 440);
    uint64_t v26 = v4;
    int v28 = *(_DWORD *)(v4 + 456);
    while (1)
    {
      uint64_t v12 = v11 + 88 * v10;
      re::StringID::StringID((re::StringID *)&v29, (const re::DynamicString *)(v12 + 16));
      if (*(unsigned char *)(v12 + 48)) {
        break;
      }
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(a2, &v29);
LABEL_25:
      re::StringID::destroyString((re::StringID *)&v29);
      unsigned int v22 = *(_DWORD *)(v4 + 456);
      uint64_t v11 = *(void *)(v4 + 440);
      if (v22 <= (int)v7 + 1) {
        unsigned int v22 = v7 + 1;
      }
      while (1)
      {
        uint64_t v10 = (v7 + 1);
        if (v22 - 1 == v7) {
          break;
        }
        LODWORD(v7) = v7 + 1;
        unsigned int v23 = v10;
        if ((*(_DWORD *)(v11 + 88 * v10 + 8) & 0x80000000) != 0) {
          goto LABEL_31;
        }
      }
      unsigned int v23 = v22;
LABEL_31:
      LODWORD(v7) = v23;
      if (v6 == v23) {
        goto LABEL_10;
      }
    }
    uint64_t v13 = (const re::DynamicString *)(v11 + 88 * v10 + 56);
    unint64_t v14 = *(void *)&v29.var0;
    unint64_t v15 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * ((*(void *)&v29.var0 >> 31) ^ (*(void *)&v29.var0 >> 1))) ^ ((0xBF58476D1CE4E5B9 * ((*(void *)&v29.var0 >> 31) ^ (*(void *)&v29.var0 >> 1))) >> 27));
    unint64_t v16 = v15 ^ (v15 >> 31);
    if (*(void *)a2)
    {
      unint64_t v17 = v16 % *(unsigned int *)(a2 + 24);
      uint64_t v18 = *(unsigned int *)(*(void *)(a2 + 8) + 4 * v17);
      if (v18 != 0x7FFFFFFF)
      {
        int32x2_t v27 = v13;
        uint64_t v19 = *(void *)(a2 + 16);
        var1 = v29.var1;
        while (1)
        {
          if ((*(void *)(v19 + 56 * v18 + 8) ^ v14) <= 1)
          {
            std::string::size_type v21 = *(const char **)(v19 + 56 * v18 + 16);
            if (v21 == var1 || !strcmp(v21, var1)) {
              break;
            }
          }
          uint64_t v18 = *(_DWORD *)(v19 + 56 * v18) & 0x7FFFFFFF;
          if (v18 == 0x7FFFFFFF)
          {
            uint64_t v4 = v26;
            uint64_t v13 = v27;
            goto LABEL_23;
          }
        }
        uint64_t v24 = 56 * v18;
        re::DynamicString::deinit((re::DynamicString *)(v19 + v24 + 24));
        re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a2 + 16) + v24 + 24), v27);
        ++*(_DWORD *)(a2 + 40);
        uint64_t v4 = v26;
        goto LABEL_24;
      }
    }
    else
    {
      LODWORD(v17) = 0;
    }
LABEL_23:
    re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DynamicString&>(a2, v17, v16, &v29, v13);
    ++*(_DWORD *)(a2 + 40);
LABEL_24:
    LODWORD(v6) = v28;
    goto LABEL_25;
  }
LABEL_10:
  os_unfair_lock_unlock(lock);
}

__CFDictionary *re::AssetHandle::copyComposedMetadataCFDR(re::AssetHandle *this)
{
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, 0);
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = *(void *)(*(void *)(v2 + 24) + 1144);
  if (v3 && (unint64_t)(*(void *)(v2 + 112) + 1) >= 2)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 80))(v3);
    uint64_t v2 = *((void *)this + 1);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 384));
  uint64_t v4 = *(unsigned int *)(v2 + 456);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (int *)(*(void *)(v2 + 440) + 8);
    while (1)
    {
      int v7 = *v6;
      v6 += 22;
      if (v7 < 0) {
        break;
      }
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(v2 + 456);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    uint64_t v8 = v5;
    uint64_t v9 = *(void *)(v2 + 440);
    do
    {
      uint64_t v10 = v9 + 88 * v8;
      if (*(unsigned char *)(v10 + 24)) {
        uint64_t v11 = *(const char **)(v9 + 88 * v8 + 32);
      }
      else {
        uint64_t v11 = (const char *)(v9 + 88 * v8 + 25);
      }
      uint64_t v12 = (unsigned char *)(v10 + 48);
      CFStringRef v13 = CFStringCreateWithCString(0, v11, 0x8000100u);
      if (*v12)
      {
        uint64_t v14 = v9 + 88 * v8;
        if (*(unsigned char *)(v14 + 64)) {
          unint64_t v15 = *(const char **)(v14 + 72);
        }
        else {
          unint64_t v15 = (const char *)(v14 + 65);
        }
        CFStringRef v16 = CFStringCreateWithCString(0, v15, 0x8000100u);
        if (CFDictionaryContainsKey(theDict, v13)) {
          CFDictionaryReplaceValue(theDict, v13, v16);
        }
        else {
          CFDictionaryAddValue(theDict, v13, v16);
        }
        CFRelease(v16);
      }
      else
      {
        CFDictionaryRemoveValue(theDict, v13);
      }
      CFRelease(v13);
      unsigned int v17 = *(_DWORD *)(v2 + 456);
      uint64_t v9 = *(void *)(v2 + 440);
      if (v17 <= (int)v5 + 1) {
        unsigned int v17 = v5 + 1;
      }
      while (1)
      {
        uint64_t v8 = (v5 + 1);
        if (v17 - 1 == v5) {
          break;
        }
        LODWORD(v5) = v5 + 1;
        unsigned int v18 = v8;
        if ((*(_DWORD *)(v9 + 88 * v8 + 8) & 0x80000000) != 0) {
          goto LABEL_30;
        }
      }
      unsigned int v18 = v17;
LABEL_30:
      LODWORD(v5) = v18;
    }
    while (v4 != v18);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 384));
  return theDict;
}

void re::AssetHandle::serializableAsset(re::AssetHandle *this@<X0>, void *a2@<X8>)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v3 = *((void *)this + 1);
  if (!v3 || !*(void *)(v3 + 24))
  {
LABEL_12:
    *a2 = 0;
    a2[4] = 0;
    return;
  }
  unsigned int v5 = atomic_load((unsigned int *)(v3 + 704));
  if (v5 != 2)
  {
    uint64_t v10 = *re::assetsLogObjects(this);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *((void *)this + 1);
      if (*(unsigned char *)(v11 + 168)) {
        uint64_t v12 = *(void *)(v11 + 176);
      }
      else {
        uint64_t v12 = v11 + 169;
      }
      int v13 = 136315138;
      uint64_t v14 = v12;
      _os_log_impl(&dword_233120000, v10, OS_LOG_TYPE_DEFAULT, "Cannot create serializableAsset for %s, as the asset is not loaded.", (uint8_t *)&v13, 0xCu);
    }
    goto LABEL_12;
  }
  uint64_t v6 = (re::internal::AssetEntry *)*((void *)this + 1);
  uint64_t v7 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)(*((void *)v6 + 3) + 1040), *((void *)v6 + 33));
  uint64_t v8 = re::internal::AssetEntry::assetPointer(v6);
  uint64_t v9 = *(void (**)(uint64_t, uint64_t))(*(void *)v7 + 256);
  v9(v7, v8);
}

re::DynamicString *re::AssetHandle::getOrBuildSerializationString@<X0>(re::AssetHandle *this@<X0>, re::DynamicString *a2@<X8>)
{
  uint64_t v3 = (const re::DynamicString *)*((void *)this + 2);
  if (v3)
  {
    return re::DynamicString::DynamicString(a2, v3);
  }
  else
  {
    unsigned int v5 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(this);
    uint64_t v6 = *((void *)v5 + 1);
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    *(void *)a2 = v6;
    *((void *)a2 + 1) = 0;
    re::DynamicString::setCapacity(a2, 0);
    return re::AssetPath::fullAssetPath(v5, a2);
  }
}

uint64_t *re::introspect_AssetHandle(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF760D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF760D8))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF760F8, "AssetHandle", 24, 8, 0, 0);
    qword_26AF760F8 = (uint64_t)&unk_26E715E40;
    qword_26AF76138 = (uint64_t)re::internal::defaultConstruct<re::AssetHandle>;
    qword_26AF76140 = (uint64_t)re::AssetHandle::introspectionSerialize;
    qword_26AF76148 = (uint64_t)re::AssetHandle::introspectionDeserialize;
    qword_26AF76158 = 0;
    unk_26AF76160 = 0;
    qword_26AF76150 = (uint64_t)re::AssetHandle::introspectionDeepCopy;
    dword_26AF76108 = 11;
    __cxa_guard_release(&qword_26AF760D8);
  }
  if (v2)
  {
    if (_MergedGlobals_52) {
      return &qword_26AF760F8;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    char v3 = _MergedGlobals_52;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if (v3) {
      return &qword_26AF760F8;
    }
    unsigned int v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (_MergedGlobals_52)
    {
LABEL_8:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &qword_26AF760F8;
    }
  }
  _MergedGlobals_52 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF760F8, a2);
  v9[0] = 0x190DE9534BBF230;
  v9[1] = "AssetHandle";
  unk_26AF76118 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0) {
    goto LABEL_8;
  }
  return &qword_26AF760F8;
}

void re::internal::defaultConstruct<re::AssetHandle>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
}

void *re::internal::defaultConstructV2<re::AssetHandle>(void *result)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

void *re::allocInfo_SharedAssetHandle(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF760E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF760E0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76168, "SharedAssetHandle");
    __cxa_guard_release(&qword_26AF760E0);
  }
  return &unk_26AF76168;
}

void re::initInfo_SharedAssetHandle(re *this, re::IntrospectionBase *a2)
{
  v9[0] = 0x91C4B88E416096E6;
  v9[1] = "SharedAssetHandle";
  re::StringID::destroyString((re::StringID *)v9);
  *((_OWORD *)this + 2) = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF760F0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF760F0);
    if (v4)
    {
      unsigned int v5 = re::introspectionAllocator(v4);
      re::introspect_AssetHandle((re *)1, v6);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "assetHandle";
      *(void *)(v7 + 16) = &qword_26AF760F8;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0x1800000001;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF760E8 = v7;
      __cxa_guard_release(&qword_26AF760F0);
    }
  }
  *((void *)this + 2) = 0x3000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF760E8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::SharedAssetHandle>;
  *((void *)this + 10) = re::internal::defaultDestruct<re::SharedAssetHandle>;
  *((void *)this + 11) = re::internal::defaultRetain<re::SharedAssetHandle>(void)::{lambda(void *)#1}::__invoke;
  *((void *)this + 12) = re::internal::defaultRelease<re::SharedAssetHandle>(void)::{lambda(void *)#1}::__invoke;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::SharedAssetHandle>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::SharedAssetHandle>;
  re::IntrospectionRegistry::add(this, v3);
  long long v8 = v10;
}

void re::internal::defaultConstruct<re::SharedAssetHandle>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a3, 0);
  *(void *)(a3 + 24) = 0;
  *(void *)a3 = &unk_26E6CBEB8;
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 40) = 0;
}

uint64_t re::internal::defaultDestruct<re::SharedAssetHandle>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

void re::internal::defaultConstructV2<re::SharedAssetHandle>(uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_26E6CBEB8;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
}

uint64_t re::internal::defaultDestructV2<re::SharedAssetHandle>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_SharedAssetHandle(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"SharedAssetHandle", (uint64_t (*)(re::internal *))re::allocInfo_SharedAssetHandle, (re::IntrospectionBase *(*)(void))re::initInfo_SharedAssetHandle, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::SharedAssetHandle>, this);
}

void anonymous namespace'::splitString(char **a1, std::string *__str, char *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int64_t size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  if ((size & 0x80u) == 0) {
    uint64_t v7 = __str;
  }
  else {
    uint64_t v7 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  int v8 = a3[23];
  if (v8 >= 0) {
    uint64_t v9 = a3;
  }
  else {
    uint64_t v9 = *(char **)a3;
  }
  if (v8 >= 0) {
    int64_t v10 = a3[23];
  }
  else {
    int64_t v10 = *((void *)a3 + 1);
  }
  if (v10)
  {
    if ((size & 0x80u) != 0) {
      int64_t size = __str->__r_.__value_.__l.__size_;
    }
    if (size >= v10)
    {
      uint64_t v52 = (char *)v7 + size;
      int v53 = *v9;
      uint64_t v54 = v7;
      do
      {
        int64_t v55 = size - v10;
        if (v55 == -1) {
          break;
        }
        uint64_t v56 = (char *)memchr(v54, v53, v55 + 1);
        if (!v56) {
          break;
        }
        uint64_t v57 = v56;
        if (!memcmp(v56, v9, v10))
        {
          std::string::size_type v11 = 0;
          if (v57 != v52)
          {
            int64_t v20 = v57 - (char *)v7;
            if (v20 != -1) {
              goto LABEL_26;
            }
          }
          goto LABEL_15;
        }
        uint64_t v54 = (std::string *)(v57 + 1);
        int64_t size = v52 - (v57 + 1);
      }
      while (size >= v10);
    }
    std::string::size_type v11 = 0;
  }
  else
  {
    int64_t v20 = 0;
LABEL_26:
    std::string::size_type v11 = 0;
    std::string::size_type v21 = (std::allocator<std::string> *)(a1 + 2);
    do
    {
      std::string::basic_string(&v68, __str, v11, v20 - v11, (std::allocator<char> *)&v69);
      unint64_t v23 = (unint64_t)a1[1];
      unint64_t v22 = (unint64_t)a1[2];
      if (v23 >= v22)
      {
        unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - (void)*a1) >> 3);
        unint64_t v26 = v25 + 1;
        if (v25 + 1 > 0xAAAAAAAAAAAAAAALL) {
          goto LABEL_87;
        }
        unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - (void)*a1) >> 3);
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x555555555555555) {
          unint64_t v28 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v28 = v26;
        }
        v69.__end_cap_.__value_ = v21;
        if (v28) {
          StringID v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)v21, v28);
        }
        else {
          StringID v29 = 0;
        }
        int v30 = &v29[24 * v25];
        long long v31 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
        *((void *)v30 + 2) = *((void *)&v68.__r_.__value_.__l + 2);
        *(_OWORD *)int v30 = v31;
        memset(&v68, 0, sizeof(v68));
        long long v33 = *a1;
        unint64_t v32 = (unint64_t)a1[1];
        if ((char *)v32 == *a1)
        {
          int64x2_t v36 = vdupq_n_s64(v32);
          uint64_t v34 = &v29[24 * v25];
        }
        else
        {
          uint64_t v34 = &v29[24 * v25];
          do
          {
            long long v35 = *(_OWORD *)(v32 - 24);
            *((void *)v34 - 1) = *(void *)(v32 - 8);
            *(_OWORD *)(v34 - 24) = v35;
            v34 -= 24;
            *(void *)(v32 - 16) = 0;
            *(void *)(v32 - 8) = 0;
            *(void *)(v32 - 24) = 0;
            v32 -= 24;
          }
          while ((char *)v32 != v33);
          int64x2_t v36 = *(int64x2_t *)a1;
        }
        std::string v37 = v30 + 24;
        *a1 = v34;
        a1[1] = v30 + 24;
        *(int64x2_t *)&v69.__begin_ = v36;
        std::string v38 = (std::string *)a1[2];
        a1[2] = &v29[24 * v28];
        v69.__end_cap_.__value_ = v38;
        v69.__first_ = (std::__split_buffer<std::string>::pointer)v36.i64[0];
        std::__split_buffer<std::string>::~__split_buffer(&v69);
        int v39 = SHIBYTE(v68.__r_.__value_.__r.__words[2]);
        a1[1] = v37;
        if (v39 < 0) {
          operator delete(v68.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        long long v24 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
        *(void *)(v23 + 16) = *((void *)&v68.__r_.__value_.__l + 2);
        *(_OWORD *)unint64_t v23 = v24;
        a1[1] = (char *)(v23 + 24);
      }
      int v40 = a3[23];
      std::string::size_type v41 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
      if ((v41 & 0x80u) == 0) {
        uint64_t v42 = __str;
      }
      else {
        uint64_t v42 = (std::string *)__str->__r_.__value_.__r.__words[0];
      }
      if ((v41 & 0x80u) != 0) {
        std::string::size_type v41 = __str->__r_.__value_.__l.__size_;
      }
      int64_t v43 = v40 >= 0 ? a3[23] : *((void *)a3 + 1);
      std::string::size_type v11 = v43 + v20;
      uint64_t v44 = v40 >= 0 ? a3 : *(char **)a3;
      if (v41 < v11) {
        break;
      }
      v20 += v43;
      if (v43)
      {
        uint64_t v45 = (char *)v42 + v11;
        uint64_t v46 = (char *)v42 + v41;
        int64_t v47 = v41 - v11;
        if (v47 < v43) {
          break;
        }
        int v48 = *v44;
        while (1)
        {
          int64_t v49 = v47 - v43;
          if (v49 == -1) {
            goto LABEL_15;
          }
          unsigned int v50 = (char *)memchr(v45, v48, v49 + 1);
          if (!v50) {
            goto LABEL_15;
          }
          int v51 = v50;
          if (!memcmp(v50, v44, v43)) {
            break;
          }
          uint64_t v45 = v51 + 1;
          int64_t v47 = v46 - (v51 + 1);
          if (v47 < v43) {
            goto LABEL_15;
          }
        }
        if (v51 == v46) {
          break;
        }
        int64_t v20 = v51 - (char *)v42;
      }
      std::string::size_type v21 = (std::allocator<std::string> *)(a1 + 2);
    }
    while (v20 != -1);
  }
LABEL_15:
  std::string::basic_string(&v68, __str, v11, ~v11, (std::allocator<char> *)&v69);
  unint64_t v12 = (unint64_t)a1[2];
  unint64_t v13 = (unint64_t)a1[1];
  if (v13 >= v12)
  {
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)*a1) >> 3);
    unint64_t v16 = v15 + 1;
    if (v15 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_87:
    }
      abort();
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - (void)*a1) >> 3);
    if (2 * v17 > v16) {
      unint64_t v16 = 2 * v17;
    }
    if (v17 >= 0x555555555555555) {
      unint64_t v18 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v18 = v16;
    }
    v69.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
    if (v18) {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((uint64_t)(a1 + 2), v18);
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v58 = &v19[24 * v15];
    long long v59 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
    *((void *)v58 + 2) = *((void *)&v68.__r_.__value_.__l + 2);
    *(_OWORD *)uint64_t v58 = v59;
    memset(&v68, 0, sizeof(v68));
    uint64_t v61 = *a1;
    unint64_t v60 = (unint64_t)a1[1];
    if ((char *)v60 == *a1)
    {
      int64x2_t v64 = vdupq_n_s64(v60);
      uint64_t v62 = &v19[24 * v15];
    }
    else
    {
      uint64_t v62 = &v19[24 * v15];
      do
      {
        long long v63 = *(_OWORD *)(v60 - 24);
        *((void *)v62 - 1) = *(void *)(v60 - 8);
        *(_OWORD *)(v62 - 24) = v63;
        v62 -= 24;
        *(void *)(v60 - 16) = 0;
        *(void *)(v60 - 8) = 0;
        *(void *)(v60 - 24) = 0;
        v60 -= 24;
      }
      while ((char *)v60 != v61);
      int64x2_t v64 = *(int64x2_t *)a1;
    }
    uint64_t v65 = v58 + 24;
    *a1 = v62;
    a1[1] = v58 + 24;
    *(int64x2_t *)&v69.__begin_ = v64;
    uint64_t v66 = (std::string *)a1[2];
    a1[2] = &v19[24 * v18];
    v69.__end_cap_.__value_ = v66;
    v69.__first_ = (std::__split_buffer<std::string>::pointer)v64.i64[0];
    std::__split_buffer<std::string>::~__split_buffer(&v69);
    int v67 = SHIBYTE(v68.__r_.__value_.__r.__words[2]);
    a1[1] = v65;
    if (v67 < 0) {
      operator delete(v68.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    long long v14 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
    *(void *)(v13 + 16) = *((void *)&v68.__r_.__value_.__l + 2);
    *(_OWORD *)unint64_t v13 = v14;
    a1[1] = (char *)(v13 + 24);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(24 * a2);
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:nn180100](uint64_t a1, void **a2)
{
  int v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      unsigned int v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        unsigned int v5 = *(void ***)(a1 + 16);
      }
      int v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  int v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)v2);
    char v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::string>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void re::SharedAssetHandle::~SharedAssetHandle(re::SharedAssetHandle *this)
{
  *(void *)this = &unk_26E6CBEB8;
  re::AssetHandle::~AssetHandle((re::SharedAssetHandle *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6CBEB8;
  re::AssetHandle::~AssetHandle((re::SharedAssetHandle *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

id re::internal::defaultRetain<re::SharedAssetHandle>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::SharedAssetHandle>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
}

void *re::allocInfo_NamedFileAssetLoadDescriptorParameters(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_53, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_53))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76210, "NamedFileAssetLoadDescriptorParameters");
    __cxa_guard_release(&_MergedGlobals_53);
  }
  return &unk_26AF76210;
}

void re::initInfo_NamedFileAssetLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  v10[0] = 0xD31F5603CC4AAF34;
  v10[1] = "NamedFileAssetLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v10);
  *((_OWORD *)this + 2) = v11;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF761F0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF761F0);
    if (v4)
    {
      unsigned int v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::DynamicString>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "fileAliasName";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF761E8 = v8;
      __cxa_guard_release(&qword_26AF761F0);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF761E8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::NamedFileAssetLoadDescriptorParameters>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::NamedFileAssetLoadDescriptorParameters>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::NamedFileAssetLoadDescriptorParameters>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::NamedFileAssetLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  long long v9 = v11;
}

void *re::internal::defaultConstruct<re::NamedFileAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  return re::DynamicString::setCapacity((void *)a3, 0);
}

double re::internal::defaultDestruct<re::NamedFileAssetLoadDescriptorParameters>(int a1, int a2, re::DynamicString *this)
{
  return re::DynamicString::deinit(this);
}

void *re::internal::defaultConstructV2<re::NamedFileAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  return re::DynamicString::setCapacity(a1, 0);
}

_anonymous_namespace_ *re::NamedFileAssetProvider::NamedFileAssetProvider(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = &unk_26E6CBF00;
  *((void *)a1 + 5) = 0;
  *((void *)a1 + 6) = 0;
  *((void *)a1 + 4) = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76208, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76208))
  {
    qword_26AF76200 = re::internal::getOrCreateInfo((re::internal *)"NamedFileAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_NamedFileAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_NamedFileAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF761F8, 0);
    __cxa_guard_release(&qword_26AF76208);
  }
  re::NamedFileAssetProvider::s_loadDescriptorParametersIntrospect = qword_26AF76200;
  *((void *)a1 + 3) = a2;
  *((void *)a1 + 4) = a3;
  *((void *)a1 + 5) = a4;
  *((void *)a1 + 6) = a5;
  return a1;
}

void re::NamedFileAssetProvider::~NamedFileAssetProvider(re::NamedFileAssetProvider *this)
{
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::NamedFileAssetProvider::makeDescriptor@<X0>(_anonymous_namespace_ *a1@<X0>, re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  uint64_t v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a3, 0);
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  *(void *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_DWORD *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(void *)(a3 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a3 + 112), 0);
  unint64_t v12 = (uint64_t *)"NamedFileAsset";
  uint64_t v13 = 14;
  re::DynamicString::operator=((re::DynamicString *)a3, (uint64_t)&v12);
  uint64_t v7 = re::DynamicString::operator=((re::DynamicString *)(a3 + 112), a2);
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  re::DynamicString::setCapacity(&v12, 0);
  re::DynamicString::operator=((re::DynamicString *)&v12, a1);
  re::DynamicString::DynamicString((re::DynamicString *)v11, (const re::DynamicString *)&v12);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a3, (const re::IntrospectionBase *)re::NamedFileAssetProvider::s_loadDescriptorParametersIntrospect, (const re::IntrospectionBase **)v11, 0);
  if (*(void *)&v11[0])
  {
    if (BYTE8(v11[0])) {
      (*(void (**)(void))(**(void **)&v11[0] + 40))();
    }
    memset(v11, 0, sizeof(v11));
  }
  uint64_t result = (uint64_t)v12;
  if (v12)
  {
    if (v13) {
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(*v12 + 40))(v12, v14, v8, v9);
    }
  }
  return result;
}

re::DynamicString *re::NamedFileAssetProvider::load@<X0>(re::NamedFileAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  if (*((unsigned char *)a2 + 8)) {
    uint64_t v9 = (const char *)*((void *)a2 + 2);
  }
  else {
    uint64_t v9 = (char *)a2 + 9;
  }
  int64_t v10 = (_anonymous_namespace_ *)strcmp(v9, "NamedFileAsset");
  if (v10)
  {
    long long v12 = v29;
    uint64_t v13 = v30;
    uint64_t v14 = v31;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v12;
    *(void *)(a4 + 24) = v13;
    *(void *)(a4 + 32) = v14;
  }
  else
  {
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    uint64_t v15 = re::AssetLoadDescriptor::getIntrospectableData<re::NamedFileAssetLoadDescriptorParameters>(a2, &v32);
    if (v15)
    {
      unint64_t v16 = (os_unfair_lock_s *)*((void *)this + 3);
      re::DynamicString::DynamicString((re::DynamicString *)v28, (const re::DynamicString *)&v32);
      re::NamedFileRegistry::tryGetFilePathFor(v16, (uint64_t)v28, &v29);
      if (*(void *)&v28[0])
      {
        if (BYTE8(v28[0])) {
          (*(void (**)(void))(**(void **)&v28[0] + 40))();
        }
        memset(v28, 0, sizeof(v28));
      }
      if ((_BYTE)v29)
      {
        if (*((unsigned char *)a2 + 120)) {
          unint64_t v17 = (char *)*((void *)a2 + 16);
        }
        else {
          unint64_t v17 = (char *)a2 + 121;
        }
        re::loadCompiledOrSourceFile((char *)&v29 + 8, v17, (re::internal::AssetTypeRegistry **)this + 4, (uint64_t)a3, a4);
      }
      else
      {
        if (v33) {
          std::string::size_type v21 = v34;
        }
        else {
          std::string::size_type v21 = (char *)&v33 + 1;
        }
        re::DynamicString::format((re::DynamicString *)"No file found for FileAlias '%s'.", (re::DynamicString *)&v25, v21);
        long long v22 = v25;
        uint64_t v23 = v26;
        uint64_t v24 = v27;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + 8) = v22;
        *(void *)(a4 + 24) = v23;
        *(void *)(a4 + 32) = v24;
      }
      if (_BYTE)v29 && *((void *)&v29 + 1) && (v30) {
        (*(void (**)(void))(**((void **)&v29 + 1) + 40))();
      }
    }
    else
    {
      long long v18 = v29;
      uint64_t v19 = v30;
      uint64_t v20 = v31;
      *(unsigned char *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v18;
      *(void *)(a4 + 24) = v19;
      *(void *)(a4 + 32) = v20;
    }
    uint64_t result = v32;
    if (v32)
    {
      if (v33) {
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v32 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<re::NamedFileAssetLoadDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76208, memory_order_acquire) & 1) == 0)
  {
    unsigned int v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF76208);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF76200 = re::internal::getOrCreateInfo((re::internal *)"NamedFileAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_NamedFileAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_NamedFileAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF761F8, 0);
      __cxa_guard_release(&qword_26AF76208);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  char v3 = (re **)qword_26AF76200;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

__n128 re::NamedFileAssetProvider::resolveChild@<Q0>(re::NamedFileAssetProvider *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v9;
  uint64_t v7 = v10;
  uint64_t v8 = v11;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v7;
  *(void *)(a2 + 32) = v8;
  return result;
}

re::DynamicString *re::NamedFileAssetProvider::getDescription(re::NamedFileAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  re::DynamicString::setCapacity(&v6, 0);
  if (re::AssetLoadDescriptor::getIntrospectableData<re::NamedFileAssetLoadDescriptorParameters>(a2, &v6))
  {
    re::DynamicString::operator=(a3, (re::DynamicString *)&v6);
  }
  else
  {
    v10[0] = "mangled";
    v10[1] = 7;
    re::DynamicString::operator=(a3, (uint64_t)v10);
  }
  __n128 result = v6;
  if (v6)
  {
    if (v7) {
      return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v6 + 40))();
    }
  }
  return result;
}

const char *re::NamedFileAssetProvider::schemeName(re::NamedFileAssetProvider *this)
{
  return "NamedFileAsset";
}

id objectDecodeError(NSString *a1)
{
  v9[1] = *MEMORY[0x263EF8340];
  uint64_t v1 = (void *)MEMORY[0x263F087E8];
  uint64_t v2 = *MEMORY[0x263F07F70];
  uint64_t v8 = *MEMORY[0x263F07F80];
  v9[0] = a1;
  char v3 = NSDictionary;
  uint64_t v4 = a1;
  unsigned int v5 = [v3 dictionaryWithObjects:v9 forKeys:&v8 count:1];
  uint64_t v6 = [v1 errorWithDomain:v2 code:4864 userInfo:v5];

  return v6;
}

void re::SharedResourcePayload::clientObject(id *this@<X0>, void *a2@<X8>)
{
  id v3 = [*this clientObject];
  *a2 = v3;
}

void re::makeResourceSharingError(__CFString *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
}

void re::makeResourceSharingErrorWithDescription(__CFString *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
}

uint64_t re::BundleFilePathRegistry::registerBundleFilePath(os_unfair_lock_s *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  re::DynamicString::DynamicString((re::DynamicString *)v25, (const re::DynamicString *)a2);
  re::NamedFileRegistry::tryGetFilePathFor(a1, (uint64_t)v25, v26);
  uint64_t v6 = *(re **)&v25[0];
  if (*(void *)&v25[0])
  {
    if (BYTE8(v25[0])) {
      uint64_t v6 = (re *)(*(uint64_t (**)(void))(**(void **)&v25[0] + 40))();
    }
    memset(v25, 0, sizeof(v25));
  }
  if (!v26[0])
  {
    long long v18 = *re::assetsLogObjects(v6);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a2 + 8)) {
        uint64_t v19 = *(void *)(a2 + 16);
      }
      else {
        uint64_t v19 = a2 + 9;
      }
      if (*(unsigned char *)(a3 + 8)) {
        uint64_t v23 = *(void *)(a3 + 16);
      }
      else {
        uint64_t v23 = a3 + 9;
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v32 = v19;
      __int16 v33 = 2080;
      uint64_t v34 = v23;
      _os_log_impl(&dword_233120000, v18, OS_LOG_TYPE_DEFAULT, "BundleId '%s' manually registered for file '%s'", buf, 0x16u);
    }
    os_unfair_lock_lock(a1);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>((uint64_t)&a1[2], (re::DynamicString *)a2, (const re::DynamicString *)a3);
    os_unfair_lock_unlock(a1);
    goto LABEL_40;
  }
  if (v28) {
    uint64_t v7 = v30;
  }
  else {
    uint64_t v7 = v29;
  }
  uint64_t v8 = a3 + 9;
  if (*(void *)(a3 + 8)) {
    uint64_t v9 = *(const char **)(a3 + 16);
  }
  else {
    uint64_t v9 = (const char *)(a3 + 9);
  }
  uint64_t v10 = (re *)strcmp(v7, v9);
  int v11 = (int)v10;
  long long v12 = *re::assetsLogObjects(v10);
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (!v11)
  {
    if (v13)
    {
      if (*(unsigned char *)(a2 + 8)) {
        uint64_t v20 = *(void *)(a2 + 16);
      }
      else {
        uint64_t v20 = a2 + 9;
      }
      if (*(unsigned char *)(a3 + 8)) {
        uint64_t v8 = *(void *)(a3 + 16);
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v32 = v20;
      __int16 v33 = 2080;
      uint64_t v34 = v8;
      _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "BundleId '%s' already registered for file '%s'", buf, 0x16u);
    }
LABEL_40:
    uint64_t v22 = 1;
    goto LABEL_41;
  }
  if (v13)
  {
    uint64_t v16 = *(void *)(a2 + 8);
    if (v16) {
      uint64_t v17 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v17 = a2 + 9;
    }
    if (*(unsigned char *)(a3 + 8)) {
      uint64_t v8 = *(void *)(a3 + 16);
    }
    if (v16) {
      uint64_t v21 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v21 = a2 + 9;
    }
    *(_DWORD *)long long buf = 136315650;
    uint64_t v32 = v17;
    __int16 v33 = 2080;
    uint64_t v34 = v8;
    __int16 v35 = 2080;
    uint64_t v36 = v21;
    _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Failed to register '%s' bundle for file '%s'! BundleId '%s' already registered for different file.", buf, 0x20u);
  }
  uint64_t v22 = 0;
LABEL_41:
  if (v26[0] && v27 && (v28 & 1) != 0) {
    (*(void (**)(uint64_t, const char *, uint64_t, uint64_t))(*(void *)v27 + 40))(v27, v30, v14, v15);
  }
  return v22;
}

void re::BundleFilePathRegistry::findWithBundleID(os_unfair_lock_s *a1@<X0>, uint64_t a2@<X1>, id *a3@<X8>)
{
  re::DynamicString::DynamicString((re::DynamicString *)v12, (const re::DynamicString *)a2);
  re::NamedFileRegistry::tryGetFilePathFor(a1, (uint64_t)v12, v13);
  if (*(void *)&v12[0])
  {
    if (BYTE8(v12[0])) {
      (*(void (**)(void))(**(void **)&v12[0] + 40))();
    }
    memset(v12, 0, sizeof(v12));
  }
  if (v13[0])
  {
    if (v15) {
      uint64_t v6 = v17;
    }
    else {
      uint64_t v6 = (re::Bundle *)v16;
    }
    re::Bundle::findWithFilePath(v6, a3);
  }
  else
  {
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v9 = *(re::Bundle **)(a2 + 16);
    }
    else {
      uint64_t v9 = (re::Bundle *)(a2 + 9);
    }
    re::Bundle::findWithBundleID(v9, a3);
    if (*a3)
    {
      os_unfair_lock_lock(a1);
      re::Bundle::bundlePath(a3, (re::DynamicString *)&v18);
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&a1[2], (re::DynamicString *)a2, &v18);
      if (v18 && (v19 & 1) != 0) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v18 + 40))(v18, v20, v10, v11);
      }
      os_unfair_lock_unlock(a1);
    }
  }
  if (v13[0] && v14 && (v15 & 1) != 0) {
    (*(void (**)(uint64_t, re::Bundle *, uint64_t, uint64_t))(*(void *)v14 + 40))(v14, v17, v7, v8);
  }
}

__n128 re::AssetProvider::getAssetPathForRelease@<Q0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (*(void *)(a1 + 8)) {
    uint64_t v3 = *(void *)(a1 + 16);
  }
  else {
    uint64_t v3 = a1 + 9;
  }
  re::DynamicString::format((re::DynamicString *)"No asset path for AssetLoadDescriptor type '%s'", (re::DynamicString *)&v7, v3);
  __n128 result = v7;
  uint64_t v5 = v8;
  uint64_t v6 = v9;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v5;
  *(void *)(a2 + 32) = v6;
  return result;
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_4, 4 * v2);
    }
    if (*(_DWORD *)(a1 + 32))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(void *)(a1 + 16) + v3);
        ++v4;
        v3 += 56;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

BOOL re::AssetProviderRegistry::Tables::registerProvider(uint64_t a1, re::DynamicString *a2, uint64_t *a3)
{
  BOOL v6 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a1, (uint64_t)a2);
  if (!v6) {
    re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::AssetProvider>&>(a1, a2, a3);
  }
  return !v6;
}

uint64_t re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::AssetProvider>&>(uint64_t a1, re::DynamicString *a2, uint64_t *a3)
{
  unint64_t v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  unint64_t v7 = v6;
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v11 = re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<re::SharedPtr<re::AssetProvider>&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 56 * v11;
    return v12 + 48;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 56 * v9 + 16, (uint64_t)a2))
  {
    uint64_t v9 = *(_DWORD *)(v10 + 56 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v10 + 56 * v9;
  return v12 + 48;
}

BOOL re::AssetProviderRegistry::Tables::registerResolver(uint64_t a1, re::DynamicString *a2, uint64_t *a3)
{
  if (re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a1, (uint64_t)a2))
  {
    return 0;
  }
  re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::AssetProvider>&>(a1 + 48, a2, a3);
  uint64_t v7 = *a3;
  uint64_t v10 = v7;
  if (v7) {
    id v8 = (id)(v7 + 8);
  }
  BOOL v6 = re::AssetProviderRegistry::Tables::registerProvider(a1, a2, &v10);
  if (v10) {

  }
  return v6;
}

BOOL re::AssetProviderRegistry::registerAssetProvider(os_unfair_lock_s *a1, uint64_t *a2)
{
  unint64_t v4 = a1 + 16;
  os_unfair_lock_lock(a1 + 16);
  uint64_t v5 = (uint64_t)&a1[18];
  BOOL v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)*a2 + 32))();
  uint64_t v7 = *a2;
  uint64_t v11 = v7;
  if (v7) {
    id v8 = (id)(v7 + 8);
  }
  BOOL v9 = re::AssetProviderRegistry::Tables::registerProvider(v5, (re::DynamicString *)&v12, &v11);
  if (v11)
  {

    uint64_t v11 = 0;
  }
  if (v12 && (v13 & 1) != 0) {
    (*(void (**)(void))(*(void *)v12 + 40))();
  }
  os_unfair_lock_unlock(v4);
  return v9;
}

BOOL re::AssetProviderRegistry::registerAssetResolverForScheme(re::AssetProviderRegistry *this, const char *a2, const char *(*a3)(const char *, const char *, void *), uint64_t a4, char a5)
{
  uint64_t v16 = a3;
  uint64_t v17 = a2;
  uint64_t v15 = a4;
  char v14 = a5;
  re::make::shared::object<re::ExternalResolverAssetProvider,char const*&,void *&,char const* (*&)(char const*,char const*,void *),re::AssetLoadData &,BOOL &>((re *)&v17, &v15, (uint64_t *)&v16, (long long *)this, &v14, &v13);
  BOOL v6 = (os_unfair_lock_s *)((char *)this + 64);
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  uint64_t v7 = (char *)this + 72;
  id v8 = v17;
  uint64_t v18 = v13;
  if (v13) {
    id v10 = (id)(v13 + 8);
  }
  BOOL v11 = re::AssetProviderRegistry::Tables::registerResolver((uint64_t)v7, (re::DynamicString *)&v19, &v18);
  if (v18)
  {

    uint64_t v18 = 0;
  }
  if (v19 && (v20 & 1) != 0) {
    (*(void (**)(void))(*(void *)v19 + 40))();
  }
  os_unfair_lock_unlock(v6);
  if (v13) {

  }
  return v11;
}

uint64_t re::AssetProviderRegistry::tryGetProviderForScheme(os_unfair_lock_s *this, const char *a2)
{
  unint64_t v4 = this + 16;
  os_unfair_lock_lock(this + 16);
  BOOL v6 = (uint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&this[18], (uint64_t)&v9);
  if (v6) {
    uint64_t v7 = *v6;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v9 && (v10 & 1) != 0) {
    (*(void (**)(void))(*(void *)v9 + 40))();
  }
  os_unfair_lock_unlock(v4);
  return v7;
}

void *re::AssetProviderRegistry::tryGetRawProviderForScheme(os_unfair_lock_s *this, const char *a2)
{
  __n128 result = (void *)re::AssetProviderRegistry::tryGetProviderForScheme(this, a2);
  if (result)
  {
  }
  return result;
}

double re::AssetProviderRegistry::getPathFromResolver@<D0>(os_unfair_lock_s *this@<X0>, const re::DynamicString *a2@<X1>, const re::DynamicString *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  id v8 = this + 16;
  os_unfair_lock_lock(this + 16);
  uint64_t v9 = (uint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&this[30], (uint64_t)a2);
  if (!v9)
  {
    os_unfair_lock_unlock(v8);
LABEL_9:
    char v14 = *re::assetsLogObjects(v11);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      if (*((void *)a2 + 1)) {
        uint64_t v24 = (char *)*((void *)a2 + 2);
      }
      else {
        uint64_t v24 = (char *)a2 + 9;
      }
      *(_DWORD *)long long v25 = 136315138;
      *(void *)&v25[4] = v24;
      uint64_t v21 = "No resolver defined for %s";
      uint64_t v22 = v14;
      uint32_t v23 = 12;
      goto LABEL_27;
    }
LABEL_10:
    *(unsigned char *)a4 = 0;
    return result;
  }
  uint64_t v10 = *v9;
  os_unfair_lock_unlock(v8);
  if (!v10) {
    goto LABEL_9;
  }
  if (*((unsigned char *)a3 + 8)) {
    uint64_t v12 = (char *)*((void *)a3 + 2);
  }
  else {
    uint64_t v12 = (char *)a3 + 9;
  }
  if (*(unsigned char *)(v10 + 32)) {
    uint64_t v13 = *(void *)(v10 + 40);
  }
  else {
    uint64_t v13 = v10 + 33;
  }
  uint64_t v16 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, char *, void))(v10 + 56))(v13, v12, *(void *)(v10 + 64));
  if (!v16)
  {
    uint64_t v18 = *re::assetsLogObjects(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      if (*((void *)a2 + 1)) {
        uint64_t v19 = (char *)*((void *)a2 + 2);
      }
      else {
        uint64_t v19 = (char *)a2 + 9;
      }
      if (*((void *)a3 + 1)) {
        char v20 = (char *)*((void *)a3 + 2);
      }
      else {
        char v20 = (char *)a3 + 9;
      }
      *(_DWORD *)long long v25 = 136315394;
      *(void *)&v25[4] = v19;
      *(_WORD *)&void v25[12] = 2080;
      *(void *)&v25[14] = v20;
      uint64_t v21 = "Resolver %s did not return a final path for %s";
      uint64_t v22 = v18;
      uint32_t v23 = 22;
LABEL_27:
      _os_log_error_impl(&dword_233120000, v22, OS_LOG_TYPE_ERROR, v21, v25, v23);
      goto LABEL_10;
    }
    goto LABEL_10;
  }
  uint64_t v17 = (const char *)v16;
  *(unsigned char *)a4 = 1;
  *(void *)(a4 + 8) = *(void *)v25;
  *(void *)(a4 + 32) = v26;
  double result = *(double *)&v25[8];
  *(_OWORD *)(a4 + 16) = *(_OWORD *)&v25[8];
  return result;
}

uint64_t re::AssetProviderRegistry::deviceAssetPath@<X0>(os_unfair_lock_s *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a2 + 8)) {
    id v8 = *(const char **)(a2 + 16);
  }
  else {
    id v8 = (const char *)(a2 + 9);
  }
  uint64_t result = re::AssetProviderRegistry::tryGetProviderForScheme(a1, v8);
  if (result
    && (uint64_t v10 = result,
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)result + 96))(result, a2, a3),
        (result & 1) != 0))
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, void, os_unfair_lock_s *, uint64_t))(*(void *)v10 + 104))(&v11, v10, a2, *(void *)&a1->_os_unfair_lock_opaque, a1, a3);
    if ((_BYTE)v11)
    {
      *a4 = 1;
      re::DynamicString::DynamicString((re::DynamicString *)(a4 + 8), (const re::DynamicString *)&v12);
    }
    else
    {
      *a4 = 0;
    }
    uint64_t result = v12;
    if (v12)
    {
      if (v13) {
        return (*(uint64_t (**)(void))(*(void *)v12 + 40))();
      }
    }
  }
  else
  {
    *a4 = 0;
  }
  return result;
}

uint64_t *re::AssetProviderRegistry::makeDescriptorForResolver@<X0>(re::AssetProviderRegistry *this@<X0>, const re::DynamicString *a2@<X1>, const re::DynamicString *a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  uint64_t v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  re::DynamicString::operator=((re::DynamicString *)a4, this);
  uint64_t v10 = re::DynamicString::operator=((re::DynamicString *)(a4 + 112), a3);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  re::DynamicString::setCapacity(&v15, 0);
  re::DynamicString::operator=((re::DynamicString *)&v15, a2);
  re::DynamicString::DynamicString((re::DynamicString *)v14, (const re::DynamicString *)&v15);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)re::ExternalResolverAssetProvider::s_loadDescriptorParametersIntrospect, (const re::IntrospectionBase **)v14, 0);
  if (*(void *)&v14[0])
  {
    if (BYTE8(v14[0])) {
      (*(void (**)(void))(**(void **)&v14[0] + 40))();
    }
    memset(v14, 0, sizeof(v14));
  }
  uint64_t result = v15;
  if (v15)
  {
    if (v16) {
      return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(*v15 + 40))(v15, v17, v11, v12);
    }
  }
  return result;
}

re::DynamicString *re::loadCompiledOrSourceFile@<X0>(char *a1@<X0>, char *a2@<X1>, re::internal::AssetTypeRegistry **a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = re::internal::AssetTypeRegistry::assetTypeWithName(*a3, a2);
  if (v10)
  {
    v27[0] = 0;
    LocalCompiledOrSourceAsset = (_anonymous_namespace_ *)re::AssetUtilities::loadLocalCompiledOrSourceAsset(a1, (uint64_t)a3, v10, a4, (uint64_t)v27, 0, (uint64_t)&v28);
    if ((_BYTE)v28)
    {
      *(void *)&unsigned char v23[8] = 0;
      *(void *)&v23[16] = 0;
      uint64_t v24 = 0;
      re::DynamicString::setCapacity(v23, 0);
      BYTE8(v25) = 0;
      char v26 = 0;
      *(void *)&long long v25 = v29;
      char v20 = a2;
      *(void *)&long long v21 = strlen(a2);
      re::DynamicString::operator=((re::DynamicString *)v23, (uint64_t)&v20);
      re::DynamicString::DynamicString((re::DynamicString *)&v20, (const re::DynamicString *)v23);
      char v12 = v26;
      long long v13 = v25;
      *(unsigned char *)a5 = 1;
      *(void *)(a5 + 8) = v20;
      *(void *)(a5 + 32) = v22;
      *(_OWORD *)(a5 + 16) = v21;
      *(_OWORD *)(a5 + 40) = v13;
      *(unsigned char *)(a5 + 56) = v12;
      uint64_t result = *(re::DynamicString **)v23;
      if (*(void *)v23 && (v23[8] & 1) != 0) {
        uint64_t result = (re::DynamicString *)(*(uint64_t (**)(void))(**(void **)v23 + 40))();
      }
    }
    else
    {
      uint64_t result = re::DynamicString::DynamicString((re::DynamicString *)v23, (const re::DynamicString *)&v29);
      *(unsigned char *)a5 = 0;
      *(void *)(a5 + 8) = *(void *)v23;
      *(void *)(a5 + 32) = v24;
      *(_OWORD *)(a5 + 16) = *(_OWORD *)&v23[8];
    }
    if (!(_BYTE)v28)
    {
      uint64_t result = v29;
      if (v29)
      {
        if (v30)
        {
          uint64_t v19 = v31;
          return (re::DynamicString *)(*(uint64_t (**)(re::DynamicString *, uint64_t))(*(void *)result + 40))(result, v19);
        }
      }
    }
  }
  else
  {
    re::DynamicString::operator+((re::DynamicString *)&v20, (uint64_t)&v28, (re::DynamicString *)v23);
    long long v16 = *(_OWORD *)v23;
    memset(v23, 0, sizeof(v23));
    uint64_t v17 = *(void *)&v23[16];
    uint64_t v18 = v24;
    uint64_t v24 = 0;
    *(unsigned char *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v16;
    *(void *)(a5 + 24) = v17;
    *(void *)(a5 + 32) = v18;
    if (v28 && (v29 & 1) != 0) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v28 + 40))(v28, v30);
    }
    uint64_t result = (re::DynamicString *)v20;
    if (v20 && (v21 & 1) != 0)
    {
      uint64_t v19 = *((void *)&v21 + 1);
      return (re::DynamicString *)(*(uint64_t (**)(re::DynamicString *, uint64_t))(*(void *)result + 40))(result, v19);
    }
  }
  return result;
}

void re::AssetProvider::getPreloadableDependencies(uint64_t a1@<X8>)
{
  re::WrappedError::make((re::WrappedError *)@"REAssetProviderErrorDomain", (const __CFString *)1, (uint64_t)"This AssetProvider does not provide dependencies for AssetLoadDescriptors.", &v3);
  uint64_t v2 = v3;
  uint64_t v3 = 0;
  *(unsigned char *)a1 = 0;
  *(void *)(a1 + 8) = v2;
}

uint64_t re::AssetProvider::resolveChildPath@<X0>(re::AssetProvider *this@<X0>, re::PathBuffer *a2@<X1>, re::DynamicString *a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v24 = v26;
  uint64_t v25 = 488;
  v26[0] = 0;
  char v20 = v22;
  uint64_t v21 = 488;
  v22[0] = 0;
  uint64_t v9 = (re::PathBuffer *)re::path::dirname((re::path *)&v23, a2, v8);
  uint64_t v11 = (_anonymous_namespace_ *)re::path::join(&v19, v9, (const char *)this, v10);
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  *((void *)a3 + 3) = 0;
  re::DynamicString::setCapacity(a3, 0);
  long long v13 = (char *)v18[1];
  if ((v18[0] & 1) == 0) {
    long long v13 = (char *)v18 + 1;
  }
  uint64_t v14 = LOBYTE(v18[0]) >> 1;
  if (v18[0]) {
    uint64_t v14 = v18[0] >> 1;
  }
  v16[0] = v13;
  v16[1] = v14;
  re::AssetPath::standardizePath(v16, a3);
  uint64_t result = v17;
  if (v17 && (v18[0] & 1) != 0) {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)v17 + 40))();
  }
  if (v20 != v22) {
    uint64_t result = (*(uint64_t (**)(const char *))(*(void *)v19 + 40))(v19);
  }
  if (v24 != v26) {
    return (*(uint64_t (**)(uint64_t *))(*v23 + 40))(v23);
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<re::SharedPtr<re::AssetProvider>&>(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 56 * v9 + 8) = v12 | 0x80000000;
  uint64_t v13 = a2;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * v9) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v9 + 16), a4);
  uint64_t v14 = *a5;
  *(void *)(*(void *)(a1 + 16) + 56 * v9 + 48) = *a5;
  if (v14) {
    id v15 = (id)(v14 + 8);
  }
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v13) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(void *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v23, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v23;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)uint32_t v23 = v5;
      *(void *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&unsigned char v23[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        uint64_t v14 = (void *)(v6 + 48);
        do
        {
          if ((*(_DWORD *)(v14 - 5) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 6);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 56 * v18 + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 56 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 56 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 56 * v18 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 56 * v18) = v15;
            re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v18 + 16), (const re::DynamicString *)(v14 - 4));
            *(void *)(*(void *)(a1 + 16) + 56 * v18 + 48) = *v14;
            void *v14 = 0;
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 7;
        }
        while (v11 < v10);
      }
      re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2) {
      signed int v22 = a2;
    }
    else {
      signed int v22 = 3;
    }
  }
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    long long v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unsigned int v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_4, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::make::shared::object<re::ExternalResolverAssetProvider,char const*&,void *&,char const* (*&)(char const*,char const*,void *),re::AssetLoadData &,BOOL &>@<X0>(re *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, long long *a4@<X3>, char *a5@<X4>, uint64_t *a6@<X8>)
{
  int v12 = re::globalAllocators(a1);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12[2] + 32))(v12[2], 104, 8);
  uint64_t result = re::ExternalResolverAssetProvider::ExternalResolverAssetProvider(v13, *(const char **)a1, *a2, *a3, a4, *a5);
  *a6 = result;
  return result;
}

re::ExistingAssetInformation *re::ExistingAssetInformation::ExistingAssetInformation(re::ExistingAssetInformation *this, re::Allocator *a2)
{
  *(_DWORD *)this = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 1) = a2;
  unint64_t v4 = (re::ExistingAssetInformation *)((char *)this + 8);
  re::DynamicString::setCapacity((void *)this + 1, 0);
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 5) = a2;
  re::DynamicString::setCapacity((void *)this + 5, 0);
  *((void *)this + 9) = 0;
  re::DynamicString::DynamicString((re::ExistingAssetInformation *)((char *)this + 96), "(unset)", a2);
  long long v5 = re::ExistingAssetInformation::CachedLogName::CachedLogName((re::ExistingAssetInformation *)((char *)this + 128), a2);
  *((_DWORD *)this + 22) = 0;
  re::AssetPath::invalidAssetPath(v5, (uint64_t)&v8);
  *(_DWORD *)this = v8;
  re::DynamicString::operator=(v4, (re::DynamicString *)&v9);
  re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 40), (re::DynamicString *)&v11);
  uint64_t v6 = v11;
  *((void *)this + 9) = v13;
  if (v6)
  {
    if (BYTE8(v11)) {
      (*(void (**)(uint64_t, void))(*(void *)v6 + 40))(v6, v12);
    }
    long long v11 = 0u;
    long long v12 = 0u;
  }
  if (v9 && (v10 & 1) != 0) {
    (*(void (**)(void))(*(void *)v9 + 40))();
  }
  *((void *)this + 10) = -1;
  return this;
}

re::DynamicString *re::ExistingAssetInformation::setupFromPath(re::ExistingAssetInformation *this, const re::AssetPath *a2)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 8), (const re::AssetPath *)((char *)a2 + 8));
  re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 40), (const re::AssetPath *)((char *)a2 + 40));
  *((void *)this + 9) = *((void *)a2 + 9);
  *((_DWORD *)this + 22) = *(_DWORD *)a2;
  uint64_t v4 = *((void *)a2 + 1);
  long long v12 = 0;
  uint64_t v13 = 0;
  uint64_t v10 = v4;
  size_t v11 = 0;
  re::DynamicString::setCapacity(&v10, 0);
  re::AssetPath::fullAssetPath(a2, (re::DynamicString *)&v10);
  re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 96), (re::DynamicString *)&v10);
  if (v10 && (v11 & 1) != 0) {
    (*(void (**)(void))(*(void *)v10 + 40))();
  }
  if (re::AssetPath::getAssetId(a2, (unint64_t *)this + 10))
  {
    re::DynamicString::format((re::DynamicString *)"#%llu", (re::DynamicString *)&v10, *((void *)this + 10));
    if (v11) {
      long long v5 = v12;
    }
    else {
      long long v5 = (char *)&v11 + 1;
    }
    size_t v6 = strlen(v5);
    v14[0] = v5;
    v14[1] = v6;
    re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 160), (uint64_t)v14);
    re::ExistingAssetInformation::CachedLogName::updateLogName((re::ExistingAssetInformation *)((char *)this + 128));
    uint64_t result = (re::DynamicString *)v10;
    if (v10)
    {
      if (v11) {
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
      }
    }
  }
  else
  {
    *((void *)this + 10) = 0;
    if (*((unsigned char *)this + 104)) {
      int v8 = (const char *)*((void *)this + 14);
    }
    else {
      int v8 = (char *)this + 105;
    }
    size_t v9 = strlen(v8);
    uint64_t v10 = (uint64_t)v8;
    size_t v11 = v9;
    re::DynamicString::operator=((re::ExistingAssetInformation *)((char *)this + 160), (uint64_t)&v10);
    return re::ExistingAssetInformation::CachedLogName::updateLogName((re::ExistingAssetInformation *)((char *)this + 128));
  }
  return result;
}

re::DynamicString *re::ExistingAssetInformation::CachedLogName::setDescription(re::ExistingAssetInformation::CachedLogName *this, const char *__s)
{
  uint64_t v3 = (re::ExistingAssetInformation::CachedLogName *)((char *)this + 32);
  v5[0] = __s;
  v5[1] = strlen(__s);
  re::DynamicString::operator=(v3, (uint64_t)v5);
  return re::ExistingAssetInformation::CachedLogName::updateLogName(this);
}

re::ExistingAssetInformation::CachedLogName *re::ExistingAssetInformation::CachedLogName::CachedLogName(re::ExistingAssetInformation::CachedLogName *this, re::Allocator *a2)
{
  uint64_t v4 = re::DynamicString::DynamicString(this, "(unset)", a2);
  re::DynamicString::DynamicString((re::DynamicString *)((char *)v4 + 32), (const char *)&str_2_21, a2);
  re::DynamicString::DynamicString((re::ExistingAssetInformation::CachedLogName *)((char *)this + 64), (const char *)&str_2_21, a2);
  return this;
}

re::DynamicString *re::ExistingAssetInformation::CachedLogName::updateLogName(re::ExistingAssetInformation::CachedLogName *this)
{
  unint64_t v2 = *((void *)this + 9);
  unint64_t v3 = v2 >> 1;
  if ((v2 & 1) == 0) {
    unint64_t v3 = v2 >> 1;
  }
  if (v3)
  {
    if (v2) {
      uint64_t v4 = (char *)*((void *)this + 10);
    }
    else {
      uint64_t v4 = (char *)this + 73;
    }
    if (*((unsigned char *)this + 40)) {
      size_t v6 = (char *)*((void *)this + 6);
    }
    else {
      size_t v6 = (char *)this + 41;
    }
    re::DynamicString::format((re::DynamicString *)"%s (%s)", (re::DynamicString *)&v7, v4, v6);
    re::DynamicString::operator=(this, (re::DynamicString *)&v7);
    uint64_t result = (re::DynamicString *)v7;
    if (v7)
    {
      if (v8) {
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v7 + 40))();
      }
    }
  }
  else
  {
    return re::DynamicString::operator=(this, (re::ExistingAssetInformation::CachedLogName *)((char *)this + 32));
  }
  return result;
}

re::DynamicString *re::ExistingAssetInformation::CachedLogName::setDebugMetadata(re::ExistingAssetInformation::CachedLogName *this, const char *__s)
{
  unint64_t v3 = (re::ExistingAssetInformation::CachedLogName *)((char *)this + 64);
  v5[0] = __s;
  v5[1] = strlen(__s);
  re::DynamicString::operator=(v3, (uint64_t)v5);
  return re::ExistingAssetInformation::CachedLogName::updateLogName(this);
}

void *allocInfo_TubeDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_54, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_54))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76548, "TubeDescriptorParameters");
    __cxa_guard_release(&_MergedGlobals_54);
  }
  return &unk_26AF76548;
}

void initInfo_TubeDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0x87CFA6BB47133EFALL;
  v16[1] = "TubeDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76290, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF76290);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildTubeOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF76440 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x1400000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF76448 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x1500000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF76450 = v14;
      __cxa_guard_release(&qword_26AF76290);
    }
  }
  *((void *)a1 + 2) = 0x1800000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF76440;
  *((void *)a1 + 9) = re::internal::defaultConstruct<TubeDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<TubeDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<TubeDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<TubeDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

double re::internal::defaultConstruct<TubeDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = 65544;
  double result = 0.00000190734908;
  *(void *)(a3 + 4) = 0x3EC000003F800000;
  *(_DWORD *)(a3 + 12) = 1056964608;
  *(_WORD *)(a3 + 16) = 257;
  *(unsigned char *)(a3 + 18) = 0;
  return result;
}

double re::internal::defaultConstructV2<TubeDescriptorParameters>(uint64_t a1)
{
  *(_DWORD *)a1 = 65544;
  double result = 0.00000190734908;
  *(void *)(a1 + 4) = 0x3EC000003F800000;
  *(_DWORD *)(a1 + 12) = 1056964608;
  *(_WORD *)(a1 + 16) = 257;
  *(unsigned char *)(a1 + 18) = 0;
  return result;
}

void *allocInfo_PlaneDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF762A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF762A0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF765C0, "PlaneDescriptorParameters");
    __cxa_guard_release(&qword_26AF762A0);
  }
  return &unk_26AF765C0;
}

void initInfo_PlaneDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0xB6ACCE2E2A57B62ALL;
  v16[1] = "PlaneDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF762A8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF762A8);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildPlaneOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF76458 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x1C00000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF76460 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x1D00000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF76468 = v14;
      __cxa_guard_release(&qword_26AF762A8);
    }
  }
  *((void *)a1 + 2) = 0x2000000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF76458;
  *((void *)a1 + 9) = re::internal::defaultConstruct<PlaneDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<PlaneDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<PlaneDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<PlaneDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

double re::internal::defaultConstruct<PlaneDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = 65537;
  *(_WORD *)(a3 + 4) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(a3 + 8) = result;
  *(_DWORD *)(a3 + 16) = 0;
  *(_WORD *)(a3 + 20) = 257;
  *(_DWORD *)(a3 + 24) = 2;
  return result;
}

double re::internal::defaultConstructV2<PlaneDescriptorParameters>(uint64_t a1)
{
  *(_DWORD *)a1 = 65537;
  *(_WORD *)(a1 + 4) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(a1 + 8) = result;
  *(_DWORD *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 20) = 257;
  *(_DWORD *)(a1 + 24) = 2;
  return result;
}

void *allocInfo_CylinderDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF762B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF762B8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76638, "CylinderDescriptorParameters");
    __cxa_guard_release(&qword_26AF762B8);
  }
  return &unk_26AF76638;
}

void initInfo_CylinderDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0x9C4984D14682379ELL;
  v16[1] = "CylinderDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF762C0, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF762C0);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildCylinderOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF76470 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x1800000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF76478 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x1900000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF76480 = v14;
      __cxa_guard_release(&qword_26AF762C0);
    }
  }
  *((void *)a1 + 2) = 0x1C00000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF76470;
  *((void *)a1 + 9) = re::internal::defaultConstruct<CylinderDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<CylinderDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<CylinderDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<CylinderDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

double re::internal::defaultConstruct<CylinderDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = 65544;
  double result = 0.0000305175853;
  *(void *)(a3 + 4) = 0x3F0000003F800000;
  *(void *)(a3 + 12) = 0x10101013F000000;
  *(unsigned char *)(a3 + 20) = 0;
  return result;
}

double re::internal::defaultConstructV2<CylinderDescriptorParameters>(uint64_t a1)
{
  *(_DWORD *)a1 = 65544;
  double result = 0.0000305175853;
  *(void *)(a1 + 4) = 0x3F0000003F800000;
  *(void *)(a1 + 12) = 0x10101013F000000;
  *(unsigned char *)(a1 + 20) = 0;
  return result;
}

void *allocInfo_TetrahedronDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF762D0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF762D0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF766B0, "TetrahedronDescriptorParameters");
    __cxa_guard_release(&qword_26AF762D0);
  }
  return &unk_26AF766B0;
}

void initInfo_TetrahedronDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0xC1D636A90025346ALL;
  v16[1] = "TetrahedronDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF762D8, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF762D8);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildTetrahedronOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF76488 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0xC00000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF76490 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0xD00000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF76498 = v14;
      __cxa_guard_release(&qword_26AF762D8);
    }
  }
  *((void *)a1 + 2) = 0x1000000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF76488;
  *((void *)a1 + 9) = re::internal::defaultConstruct<TetrahedronDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<TetrahedronDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<TetrahedronDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<TetrahedronDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

void re::internal::defaultConstruct<TetrahedronDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)a3 = 1;
  *(_DWORD *)(a3 + 4) = 1065353216;
  *(_WORD *)(a3 + 8) = 257;
  *(unsigned char *)(a3 + 10) = 0;
}

uint64_t re::internal::defaultConstructV2<TetrahedronDescriptorParameters>(uint64_t result)
{
  *(_WORD *)double result = 1;
  *(_DWORD *)(result + 4) = 1065353216;
  *(_WORD *)(result + 8) = 257;
  *(unsigned char *)(result + 10) = 0;
  return result;
}

void *allocInfo_ConeDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF762E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF762E8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76728, "ConeDescriptorParameters");
    __cxa_guard_release(&qword_26AF762E8);
  }
  return &unk_26AF76728;
}

void initInfo_ConeDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0xA8553AB0F1149538;
  v16[1] = "ConeDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF762F0, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF762F0);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildConeOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF764A0 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x1000000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF764A8 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x1100000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF764B0 = v14;
      __cxa_guard_release(&qword_26AF762F0);
    }
  }
  *((void *)a1 + 2) = 0x1400000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF764A0;
  *((void *)a1 + 9) = re::internal::defaultConstruct<ConeDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<ConeDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<ConeDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<ConeDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

double re::internal::defaultConstruct<ConeDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = 65544;
  *(void *)(a3 + 4) = 0x3F0000003F800000;
  *(void *)&double result = 65793;
  *(_DWORD *)(a3 + 12) = 65793;
  return result;
}

double re::internal::defaultConstructV2<ConeDescriptorParameters>(uint64_t a1)
{
  *(_DWORD *)a1 = 65544;
  *(void *)(a1 + 4) = 0x3F0000003F800000;
  *(void *)&double result = 65793;
  *(_DWORD *)(a1 + 12) = 65793;
  return result;
}

void *allocInfo_SphereDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76300, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76300))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF767A0, "SphereDescriptorParameters");
    __cxa_guard_release(&qword_26AF76300);
  }
  return &unk_26AF767A0;
}

void initInfo_SphereDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0x62D795AD0F05048CLL;
  v16[1] = "SphereDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76308, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF76308);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildSphereOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF764B8 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0xC00000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF764C0 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0xD00000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF764C8 = v14;
      __cxa_guard_release(&qword_26AF76308);
    }
  }
  *((void *)a1 + 2) = 0x1000000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF764B8;
  *((void *)a1 + 9) = re::internal::defaultConstruct<SphereDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<SphereDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<SphereDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<SphereDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

void re::internal::defaultConstruct<SphereDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)a3 = 8;
  *(_DWORD *)(a3 + 4) = 1056964608;
  *(_WORD *)(a3 + 8) = 257;
  *(unsigned char *)(a3 + 10) = 0;
}

uint64_t re::internal::defaultConstructV2<SphereDescriptorParameters>(uint64_t result)
{
  *(_WORD *)double result = 8;
  *(_DWORD *)(result + 4) = 1056964608;
  *(_WORD *)(result + 8) = 257;
  *(unsigned char *)(result + 10) = 0;
  return result;
}

void *allocInfo_CapsuleDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76318, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76318))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76818, "CapsuleDescriptorParameters");
    __cxa_guard_release(&qword_26AF76318);
  }
  return &unk_26AF76818;
}

void initInfo_CapsuleDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0x6E24928FE34990CCLL;
  v16[1] = "CapsuleDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76320, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF76320);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildCapsuleOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF764D0 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x1400000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF764D8 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x1500000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF764E0 = v14;
      __cxa_guard_release(&qword_26AF76320);
    }
  }
  *((void *)a1 + 2) = 0x1800000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF764D0;
  *((void *)a1 + 9) = re::internal::defaultConstruct<CapsuleDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<CapsuleDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<CapsuleDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<CapsuleDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

double re::internal::defaultConstruct<CapsuleDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = 65544;
  *(_WORD *)(a3 + 4) = 4;
  double result = 2.00000047;
  *(void *)(a3 + 8) = 0x400000003F000000;
  *(_WORD *)(a3 + 16) = 257;
  *(unsigned char *)(a3 + 18) = 0;
  return result;
}

double re::internal::defaultConstructV2<CapsuleDescriptorParameters>(uint64_t a1)
{
  *(_DWORD *)a1 = 65544;
  *(_WORD *)(a1 + 4) = 4;
  double result = 2.00000047;
  *(void *)(a1 + 8) = 0x400000003F000000;
  *(_WORD *)(a1 + 16) = 257;
  *(unsigned char *)(a1 + 18) = 0;
  return result;
}

void *allocInfo_PyramidDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76330, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76330))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76890, "PyramidDescriptorParameters");
    __cxa_guard_release(&qword_26AF76330);
  }
  return &unk_26AF76890;
}

void initInfo_PyramidDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0xCF698AC4CB601812;
  v16[1] = "PyramidDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76338, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF76338);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildPyramidOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF764E8 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x1400000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF764F0 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x1500000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF764F8 = v14;
      __cxa_guard_release(&qword_26AF76338);
    }
  }
  *((void *)a1 + 2) = 0x1800000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF764E8;
  *((void *)a1 + 9) = re::internal::defaultConstruct<PyramidDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<PyramidDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<PyramidDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<PyramidDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

double re::internal::defaultConstruct<PyramidDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)a3 = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(a3 + 4) = result;
  *(_DWORD *)(a3 + 12) = 1065353216;
  *(_WORD *)(a3 + 16) = 257;
  *(unsigned char *)(a3 + 18) = 0;
  return result;
}

double re::internal::defaultConstructV2<PyramidDescriptorParameters>(uint64_t a1)
{
  *(_WORD *)a1 = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(a1 + 4) = result;
  *(_DWORD *)(a1 + 12) = 1065353216;
  *(_WORD *)(a1 + 16) = 257;
  *(unsigned char *)(a1 + 18) = 0;
  return result;
}

void *allocInfo_BoxDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76348, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76348))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76908, "BoxDescriptorParameters");
    __cxa_guard_release(&qword_26AF76348);
  }
  return &unk_26AF76908;
}

void initInfo_BoxDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0x6F2DEA5BDE93D208;
  v16[1] = "BoxDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76350, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF76350);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildBoxOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF76500 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x1C00000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF76508 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x1D00000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF76510 = v14;
      __cxa_guard_release(&qword_26AF76350);
    }
  }
  *((void *)a1 + 2) = 0x2000000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF76500;
  *((void *)a1 + 9) = re::internal::defaultConstruct<BoxDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<BoxDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<BoxDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<BoxDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

double re::internal::defaultConstruct<BoxDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0x1000100010001;
  double result = 0.0078125;
  *(_OWORD *)(a3 + 8) = xmmword_234371EE0;
  *(_WORD *)(a3 + 24) = 257;
  *(unsigned char *)(a3 + 26) = 0;
  return result;
}

double re::internal::defaultConstructV2<BoxDescriptorParameters>(uint64_t a1)
{
  *(void *)a1 = 0x1000100010001;
  double result = 0.0078125;
  *(_OWORD *)(a1 + 8) = xmmword_234371EE0;
  *(_WORD *)(a1 + 24) = 257;
  *(unsigned char *)(a1 + 26) = 0;
  return result;
}

void *allocInfo_BoxWithRoundedCornersDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76360, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76360))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76980, "BoxWithRoundedCornersDescriptorParameters");
    __cxa_guard_release(&qword_26AF76360);
  }
  return &unk_26AF76980;
}

void initInfo_BoxWithRoundedCornersDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0x67982B14680DB536;
  v16[1] = "BoxWithRoundedCornersDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76368, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF76368);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildBoxWithRoundedCornersOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF76518 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x2800000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF76520 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x2900000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF76528 = v14;
      __cxa_guard_release(&qword_26AF76368);
    }
  }
  *((void *)a1 + 2) = 0x2C00000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF76518;
  *((void *)a1 + 9) = re::internal::defaultConstruct<BoxWithRoundedCornersDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<BoxWithRoundedCornersDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<BoxWithRoundedCornersDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<BoxWithRoundedCornersDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

double re::internal::defaultConstruct<BoxWithRoundedCornersDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0x3000100010001;
  *(_WORD *)(a3 + 8) = 4;
  *(_OWORD *)(a3 + 12) = xmmword_234371EF0;
  *(_DWORD *)(a3 + 28) = 1065353216;
  *(void *)&double result = 16777473;
  *(_DWORD *)(a3 + 32) = 16777473;
  *(_WORD *)(a3 + 36) = 1;
  *(unsigned char *)(a3 + 38) = 0;
  return result;
}

double re::internal::defaultConstructV2<BoxWithRoundedCornersDescriptorParameters>(uint64_t a1)
{
  *(void *)a1 = 0x3000100010001;
  *(_WORD *)(a1 + 8) = 4;
  *(_OWORD *)(a1 + 12) = xmmword_234371EF0;
  *(_DWORD *)(a1 + 28) = 1065353216;
  *(void *)&double result = 16777473;
  *(_DWORD *)(a1 + 32) = 16777473;
  *(_WORD *)(a1 + 36) = 1;
  *(unsigned char *)(a1 + 38) = 0;
  return result;
}

void *allocInfo_ExtrudedTextDescriptorParameters(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76378, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76378))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF769F8, "ExtrudedTextDescriptorParameters");
    __cxa_guard_release(&qword_26AF76378);
  }
  return &unk_26AF769F8;
}

void initInfo_ExtrudedTextDescriptorParameters(re::IntrospectionBase *a1)
{
  v16[0] = 0x9AF53A68A747B84ALL;
  v16[1] = "ExtrudedTextDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v16);
  *((_OWORD *)a1 + 2) = v17;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76380, memory_order_acquire) & 1) == 0)
  {
    unint64_t v3 = (re *)__cxa_guard_acquire(&qword_26AF76380);
    if (v3)
    {
      uint64_t v4 = re::introspectionAllocator(v3);
      uint64_t v5 = re::introspect_GeomBuildExtrudedTextOptions((re::IntrospectionBase **)1);
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v4 + 32))(v4, 72, 8);
      *(_DWORD *)uint64_t v6 = 1;
      *(void *)(v6 + 8) = "options";
      *(void *)(v6 + 16) = v5;
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 1;
      *(_DWORD *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = 0;
      *(void *)(v6 + 56) = 0;
      *(_DWORD *)(v6 + 64) = 0;
      qword_26AF76530 = v6;
      uint64_t v7 = re::introspectionAllocator((re *)v6);
      size_t v9 = re::introspect_BOOL((re *)1, v8);
      uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "splitMeshes";
      *(void *)(v10 + 16) = v9;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x6800000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF76538 = v10;
      size_t v11 = re::introspectionAllocator((re *)v10);
      uint64_t v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "decimate";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x6900000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF76540 = v14;
      __cxa_guard_release(&qword_26AF76380);
    }
  }
  *((void *)a1 + 2) = 0x7000000008;
  *((_DWORD *)a1 + 6) = 8;
  *((_WORD *)a1 + 14) = 0;
  *((_DWORD *)a1 + 14) = 3;
  *((void *)a1 + 8) = &qword_26AF76530;
  *((void *)a1 + 9) = re::internal::defaultConstruct<ExtrudedTextDescriptorParameters>;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *((void *)a1 + 10) = re::internal::defaultDestruct<ExtrudedTextDescriptorParameters>;
  *((void *)a1 + 13) = re::internal::defaultConstructV2<ExtrudedTextDescriptorParameters>;
  *((void *)a1 + 14) = re::internal::defaultDestructV2<ExtrudedTextDescriptorParameters>;
  re::IntrospectionRegistry::add(a1, v2);
  long long v15 = v17;
}

double re::internal::defaultConstruct<ExtrudedTextDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = a3;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v3, 0);
  v3[2] = 0u;
  v3[3] = 0u;
  v3 += 2;
  re::DynamicString::setCapacity(v3, 0);
  __asm { FMOV            V0.2S, #1.0 }
  *((double *)v3 + 4) = result;
  *((unsigned char *)v3 + 40) = 5;
  *((void *)v3 + 6) = 0;
  *((void *)v3 + 7) = 0;
  *((unsigned char *)v3 + 64) = 0;
  *(_WORD *)((char *)v3 + 65) = 4;
  *(_DWORD *)((char *)v3 + 67) = 16843009;
  *((unsigned char *)v3 + 71) = 0;
  return result;
}

double re::internal::defaultDestruct<ExtrudedTextDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicString::deinit((re::DynamicString *)(a3 + 32));
  return re::DynamicString::deinit((re::DynamicString *)a3);
}

double re::internal::defaultConstructV2<ExtrudedTextDescriptorParameters>(_anonymous_namespace_ *a1)
{
  uint64_t v1 = a1;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  unint64_t v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v1, 0);
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  uint64_t v1 = (_anonymous_namespace_ *)((char *)v1 + 32);
  re::DynamicString::setCapacity(v1, 0);
  __asm { FMOV            V0.2S, #1.0 }
  *((double *)v1 + 4) = result;
  *((unsigned char *)v1 + 40) = 5;
  *((void *)v1 + 6) = 0;
  *((void *)v1 + 7) = 0;
  *((unsigned char *)v1 + 64) = 0;
  *(_WORD *)((char *)v1 + 65) = 4;
  *(_DWORD *)((char *)v1 + 67) = 16843009;
  *((unsigned char *)v1 + 71) = 0;
  return result;
}

double re::internal::defaultDestructV2<ExtrudedTextDescriptorParameters>(uint64_t a1)
{
  re::DynamicString::deinit((re::DynamicString *)(a1 + 32));
  return re::DynamicString::deinit((re::DynamicString *)a1);
}

uint64_t re::MeshPrimitiveProvider::makeAsset(re::MeshPrimitiveProvider *this, const re::GeomBuildExtrudedTextOptions *a2, char a3)
{
  v129[5] = *MEMORY[0x263EF8340];
  uint64_t v4 = (long long *)v107;
  uint64_t v57 = 0;
  long long v58 = 0uLL;
  int v59 = 0;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  int v62 = 0;
  int v65 = 0;
  memset(v66, 0, sizeof(v66));
  uint64_t v67 = 0x7FFFFFFFLL;
  int v55 = 0;
  memset(v54, 0, sizeof(v54));
  uint64_t v56 = 0x7FFFFFFFLL;
  *(void *)&long long v5 = 0x7F0000007FLL;
  *((void *)&v5 + 1) = 0x7F0000007FLL;
  int32x4_t v98 = vdupq_n_s32(0x7F800000u);
  long long v99 = v5;
  v97[0] = &unk_26E6CBFB8;
  long long v100 = v54;
  uint64_t v102 = 0;
  CFTypeRef cf = 0;
  __int16 v103 = 0;
  uint64_t v106 = 0;
  uint64_t v104 = 0;
  uint64_t v105 = 0;
  memset(v44, 0, sizeof(v44));
  int v45 = 0;
  uint64_t v53 = 0;
  memset(v46, 0, sizeof(v46));
  memset(v48, 0, sizeof(v48));
  int v47 = 0;
  int v49 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  int v52 = 0;
  int v34 = 16842752;
  char v35 = 1;
  int v36 = 0;
  char v37 = 0;
  int v40 = 16843008;
  char v41 = 0;
  long long v43 = 0u;
  memset(v42, 0, sizeof(v42));
  DWORD1(v43) = 0x7FFFFFFF;
  char v38 = a3;
  int v39 = 1065353216;
  if (*((unsigned char *)this + 103))
  {
    v73[0] = 0;
    unint64_t v71 = 0;
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    int v72 = 0;
    *(void *)&long long v116 = 0;
    *(void *)&long long v115 = 0;
    long long v114 = 0uLL;
    DWORD2(v115) = 0;
    re::buildExtrudedText((uint64_t)&v69, (uint64_t)&v114, (uint64_t)this, (uint64_t)v97);
    re::DynamicArray<re::GeomModelWithLods>::setCapacity(&v57, v71);
    re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)&v60 + 1, v115);
    if (v71)
    {
      uint64_t v6 = (re::GeomMesh *)v73[0];
      uint64_t v4 = &v120;
      unint64_t v7 = 736 * v71;
      while (1)
      {
        re::GeomModel::GeomModel((re::GeomModel *)&v84);
        re::DynamicArray<re::GeomMesh>::resize((uint64_t)&v86, 1uLL);
        LODWORD(v119[0]) = 0;
        re::DynamicArray<unsigned int>::resize(&v88[1], 1uLL, v119);
        if (!(void)v87) {
          break;
        }
        re::GeomMesh::operator=(v88[0], v6);
        re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)v119);
        re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)&v120, (uint64_t)&v84);
        v8.n128_f64[0] = re::DynamicArray<re::GeomModelWithLods>::add((_anonymous_namespace_ *)&v57, (uint64_t)v119);
        if ((void)v125)
        {
          if (*(void *)&v126[16]) {
            (*(void (**)(double))(*(void *)v125 + 40))(v8.n128_f64[0]);
          }
          *(void *)&v126[16] = 0;
          *(void *)double v126 = 0;
          long long v125 = 0uLL;
          ++*(_DWORD *)&v126[8];
        }
        if (*(void *)&v122[8])
        {
          if (v124) {
            (*(void (**)(__n128))(**(void **)&v122[8] + 40))(v8);
          }
          uint64_t v124 = 0;
          *(void *)&v122[16] = 0;
          *(void *)&long long v123 = 0;
          *(void *)&v122[8] = 0;
          ++DWORD2(v123);
        }
        re::DynamicArray<re::GeomModel>::deinit((uint64_t)&v120);
        if (v119[0] && (v119[1] & 1) != 0) {
          (*(void (**)(void))(*(void *)v119[0] + 40))();
        }
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)&v96);
        if (v94[32]) {
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v95);
        }
        if (v92) {
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v93);
        }
        if (v88[1])
        {
          if (v91) {
            (*(void (**)(void))(*(void *)v88[1] + 40))();
          }
          uint64_t v91 = 0;
          v88[2] = 0;
          uint64_t v89 = 0;
          v88[1] = 0;
          ++v90;
        }
        re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v86);
        if (void)v84 && (BYTE8(v84)) {
          (*(void (**)(void))(*(void *)v84 + 40))();
        }
        uint64_t v6 = (re::GeomMesh *)((char *)v6 + 736);
        v7 -= 736;
        if (!v7) {
          goto LABEL_28;
        }
      }
      uint64_t v68 = 0;
      unint64_t v16 = v107;
      long long v121 = 0u;
      *(_OWORD *)uint64_t v122 = 0u;
      long long v120 = 0u;
      memset(v119, 0, sizeof(v119));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v107 = 136315906;
      *(void *)&v107[4] = "operator[]";
      __int16 v108 = 1024;
      int v109 = 789;
      __int16 v110 = 2048;
      uint64_t v111 = 0;
      __int16 v112 = 2048;
      uint64_t v113 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_99:
      *(void *)uint64_t v107 = 0;
      long long v87 = 0u;
      *(_OWORD *)int v88 = 0u;
      long long v85 = 0u;
      long long v86 = 0u;
      long long v84 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v114) = 136315906;
      *(void *)((char *)v4 + 52) = "operator[]";
      WORD6(v114) = 1024;
      *(_DWORD *)((char *)v4 + 62) = 789;
      WORD1(v115) = 2048;
      *(void *)((char *)v4 + 68) = v16;
      WORD6(v115) = 2048;
      *(void *)((char *)v4 + 78) = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_100:
      re::internal::assertLog((re::internal *)4, v26, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      _os_crash();
      __break(1u);
LABEL_101:
      re::internal::assertLog((re::internal *)4, v26, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      _os_crash();
      __break(1u);
      goto LABEL_102;
    }
LABEL_28:
    if ((void)v115)
    {
      uint64_t v9 = 80 * v115;
      uint64_t v10 = (_DWORD *)(v116 + 64);
      do
      {
        LODWORD(v88[0]) = *v10;
        long long v11 = *((_OWORD *)v10 - 4);
        long long v12 = *((_OWORD *)v10 - 3);
        long long v13 = *((_OWORD *)v10 - 1);
        long long v86 = *((_OWORD *)v10 - 2);
        long long v87 = v13;
        long long v84 = v11;
        long long v85 = v12;
        re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)((char *)&v60 + 8), (uint64_t)&v84);
        v10 += 20;
        v9 -= 80;
      }
      while (v9);
    }
    re::makeMeshAssetDataFromGeomScene(&v57, (uint64_t)&v34, (uint64_t)&v84);
    if ((_BYTE)v84)
    {
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v44, (uint64_t)&v84 + 8);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v46 + 8, (uint64_t)&v87);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v48[8], (uint64_t)&v89);
      re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)&v50 + 8, (uint64_t)v94);
    }
    re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v84);
    if ((void)v114 && (void)v116) {
      (*(void (**)(void))(*(void *)v114 + 40))();
    }
    uint64_t v14 = &v69;
LABEL_48:
    int v19 = (re *)re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v14);
    goto LABEL_49;
  }
  if (a2)
  {
    *(void *)&long long v120 = 0;
    memset(v119, 0, 28);
    v73[0] = 0;
    unint64_t v71 = 0;
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    int v72 = 0;
    re::buildExtrudedText((_anonymous_namespace_ *)v119, (uint64_t)this, (uint64_t)v97);
    long long v15 = (unsigned char *)LODWORD(v119[2]);
    re::DynamicArray<float>::resize((uint64_t)&v69, LODWORD(v119[2]));
    unint64_t v16 = (unsigned char *)v71;
    if (v15)
    {
      long long v17 = 0;
      uint64_t v18 = v73[0];
      while (v16 != v17)
      {
        *(_DWORD *)(v18 + 4 * (void)v17) = v17;
        if (v15 == ++v17) {
          goto LABEL_42;
        }
      }
      goto LABEL_99;
    }
LABEL_42:
    re::makeMeshAssetDataWithGeomMeshArray((re::GeomMesh *)v120, v119[2], v73[0], (uint64_t)v16, 0, &v34, (uint64_t)&v84);
    if ((_BYTE)v84)
    {
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v44, (uint64_t)&v84 + 8);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v46 + 8, (uint64_t)&v87);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v48[8], (uint64_t)&v89);
      re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)&v50 + 8, (uint64_t)v94);
    }
    re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v84);
    if (v69 && v73[0]) {
      (*(void (**)(void))(*(void *)v69 + 40))();
    }
    uint64_t v14 = v119;
    goto LABEL_48;
  }
  re::GeomMesh::GeomMesh((re::GeomMesh *)&v84, 0);
  re::buildExtrudedText((re *)&v84, this, (const re::GeomBuildExtrudedTextOptions *)v97, v24);
  re::GeomModel::GeomModel((re::GeomModel *)v119);
  re::DynamicArray<re::GeomMesh>::add((uint64_t)&v120, (uint64_t)&v84);
  LODWORD(v69) = 0;
  re::DynamicArray<unsigned int>::resize(&v122[8], 1uLL, &v69);
  re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)&v69);
  re::DynamicString::operator=((re::DynamicString *)&v69, (re::DynamicString *)v119);
  re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)v73, (uint64_t)v119);
  re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v129);
  if (BYTE4(v127)) {
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v128);
  }
  if ((_BYTE)v125) {
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v125 + 8);
  }
  if (*(void *)&v122[8])
  {
    if (v124) {
      (*(void (**)(void))(**(void **)&v122[8] + 40))();
    }
    uint64_t v124 = 0;
    *(void *)&v122[16] = 0;
    *(void *)&long long v123 = 0;
    *(void *)&v122[8] = 0;
    ++DWORD2(v123);
  }
  re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v120);
  if (v119[0] && (v119[1] & 1) != 0) {
    (*(void (**)(void))(*(void *)v119[0] + 40))();
  }
  memset(v119, 0, 28);
  long long v120 = 0u;
  long long v121 = 0u;
  *(_DWORD *)uint64_t v122 = 0;
  *(_OWORD *)&v122[8] = 0u;
  long long v123 = 0u;
  LODWORD(v124) = 0;
  long long v125 = 0u;
  memset(v126, 0, sizeof(v126));
  uint64_t v127 = 0x7FFFFFFFLL;
  re::DynamicArray<re::GeomModelWithLods>::add((_anonymous_namespace_ *)v119, (uint64_t)&v69);
  long long v114 = xmmword_23435FD50;
  long long v115 = xmmword_23435FD60;
  long long v116 = xmmword_23435FD80;
  long long v117 = xmmword_23435FBB0;
  int v118 = 0;
  __n128 v25 = re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)((char *)&v120 + 8), (uint64_t)&v114);
  if (v79)
  {
    if (v83) {
      (*(void (**)(__n128))(*(void *)v79 + 40))(v25);
    }
    uint64_t v83 = 0;
    uint64_t v80 = 0;
    uint64_t v81 = 0;
    uint64_t v79 = 0;
    ++v82;
  }
  if (v74)
  {
    if (v78) {
      (*(void (**)(__n128))(*(void *)v74 + 40))(v25);
    }
    uint64_t v78 = 0;
    uint64_t v75 = 0;
    uint64_t v76 = 0;
    uint64_t v74 = 0;
    ++v77;
  }
  re::DynamicArray<re::GeomModel>::deinit((uint64_t)v73);
  if (v69 && (v70 & 1) != 0) {
    (*(void (**)(void))(*(void *)v69 + 40))();
  }
  uint64_t v27 = v57;
  if (v57 && v119[0] && v57 != v119[0]) {
    goto LABEL_100;
  }
  uint64_t v57 = v119[0];
  v119[0] = v27;
  long long v28 = v60;
  *(void *)&long long v60 = v120;
  *(void *)&long long v120 = v28;
  ++LODWORD(v119[3]);
  ++v59;
  long long v29 = v58;
  long long v58 = *(_OWORD *)&v119[1];
  *(_OWORD *)&v119[1] = v29;
  if (*((void *)&v60 + 1) && *((void *)&v120 + 1) && *((void *)&v60 + 1) != *((void *)&v120 + 1)) {
    goto LABEL_101;
  }
  *((void *)&v60 + 1) = *((void *)&v120 + 1);
  *((void *)&v120 + 1) = *((void *)&v28 + 1);
  long long v30 = v63;
  *(void *)&long long v63 = *(void *)&v122[8];
  *(void *)&v122[8] = v30;
  ++*(_DWORD *)v122;
  ++v62;
  long long v31 = v61;
  long long v61 = v121;
  long long v121 = v31;
  if (*((void *)&v63 + 1) && *(void *)&v122[16] && *((void *)&v63 + 1) != *(void *)&v122[16])
  {
LABEL_102:
    re::internal::assertLog((re::internal *)4, v26, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
    _os_crash();
    __break(1u);
  }
  *((void *)&v63 + 1) = *(void *)&v122[16];
  *(void *)&v122[16] = *((void *)&v30 + 1);
  long long v32 = v64;
  long long v64 = v123;
  long long v123 = v32;
  uint64_t v33 = *(void *)v66;
  *(void *)uint64_t v66 = v125;
  *(void *)&long long v125 = v33;
  LODWORD(v124) = v124 + 1;
  ++v65;
  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=((uint64_t)&v66[8], (uint64_t *)&v125 + 1);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v125 + 1);
  re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v122[16]);
  if (*((void *)&v120 + 1))
  {
    if (*(void *)&v122[8]) {
      (*(void (**)(void))(**((void **)&v120 + 1) + 40))();
    }
    *(void *)&v122[8] = 0;
    long long v121 = 0uLL;
    *((void *)&v120 + 1) = 0;
    ++*(_DWORD *)v122;
  }
  re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)v119);
  re::makeMeshAssetDataFromGeomScene(&v57, (uint64_t)&v34, (uint64_t)v119);
  if (LOBYTE(v119[0]))
  {
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v44, (uint64_t)&v119[1]);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v46 + 8, (uint64_t)&v121);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v48[8], (uint64_t)&v123);
    re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)&v50 + 8, (uint64_t)v126);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)v119);
  re::GeomMesh::~GeomMesh((re::GeomMesh *)&v84);
LABEL_49:
  uint64_t v20 = re::globalAllocators(v19);
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20[2] + 32))(v20[2], 960, 8);
  re::MeshAsset::MeshAsset(v21, (uint64_t)v44);
  double v22 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v42);
  if (*((void *)&v50 + 1))
  {
    if (v53) {
      (*(void (**)(double))(**((void **)&v50 + 1) + 40))(v22);
    }
    uint64_t v53 = 0;
    long long v51 = 0uLL;
    *((void *)&v50 + 1) = 0;
    ++v52;
  }
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v48[8]);
  re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)v46 + 8);
  re::DynamicArray<re::MeshAssetModel>::deinit(v44);
  v97[0] = &unk_26E6CBFB8;
  if (cf) {
    CFRelease(cf);
  }
  re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::deinit(v54);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v66[8]);
  re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v63 + 8);
  if (*((void *)&v60 + 1))
  {
    if ((void)v63) {
      (*(void (**)(void))(**((void **)&v60 + 1) + 40))();
    }
    *(void *)&long long v63 = 0;
    long long v61 = 0uLL;
    *((void *)&v60 + 1) = 0;
    ++v62;
  }
  re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)&v57);
  return v21;
}

void *re::DynamicArray<re::GeomModelWithLods>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    long long v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x98uLL))
        {
          uint64_t v2 = 152 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 152 * a2, 8);
          if (result)
          {
            uint64_t v7 = (uint64_t)result;
            if (!v5[1])
            {
LABEL_9:
              void v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            re::ObjectHelper::move<re::GeomModelWithLods>(v5[4], v5[4] + 152 * v5[2], v7);
            double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 152, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        double result = (void *)re::DynamicArray<re::GeomModelWithLods>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::DynamicArray<re::GeomMesh>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v7 = 736 * a2;
    unint64_t v8 = a2;
    do
    {
      re::GeomMesh::~GeomMesh((re::GeomMesh *)(*(void *)(a1 + 32) + v7));
      ++v8;
      v7 += 736;
    }
    while (v8 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::GeomMesh>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 736 * v4;
      do
      {
        re::GeomMesh::GeomMesh((re::GeomMesh *)(*(void *)(a1 + 32) + v6), 0);
        v6 += 736;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::DynamicArray<unsigned int>::resize(void *result, unint64_t a2, _DWORD *a3)
{
  unint64_t v4 = result;
  unint64_t v5 = result[2];
  if (v5 >= a2)
  {
    if (v5 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      double result = re::DynamicArray<int>::setCapacity(result, a2);
      unint64_t v5 = v4[2];
    }
    unint64_t v7 = a2 - v5;
    if (a2 > v5)
    {
      unint64_t v8 = (_DWORD *)(v4[4] + 4 * v5);
      do
      {
        *v8++ = *a3;
        --v7;
      }
      while (v7);
    }
  }
  v4[2] = a2;
  ++*((_DWORD *)v4 + 6);
  return result;
}

uint64_t re::DynamicArray<re::GeomModel>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::GeomModel>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 248 * v4;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(void *)(v5 + 24) = *(void *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v7 = *(void *)(a2 + 16);
  *(void *)(a2 + 24) = 0;
  uint64_t v9 = *(void *)(v5 + 8);
  uint64_t v8 = *(void *)(v5 + 16);
  *(void *)(v5 + 8) = v6;
  *(void *)(v5 + 16) = v7;
  *(void *)(a2 + 8) = v9;
  *(void *)(a2 + 16) = v8;
  *(void *)(v5 + 64) = 0;
  *(_DWORD *)(v5 + 56) = 0;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + 32) = 0;
  uint64_t v10 = *(void *)(a2 + 40);
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  *(void *)(v5 + 40) = v10;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v11 = *(void *)(v5 + 48);
  *(void *)(v5 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v11;
  uint64_t v12 = *(void *)(v5 + 64);
  *(void *)(v5 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v12;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(v5 + 56);
  *(void *)(v5 + 104) = 0;
  *(void *)(v5 + 80) = 0;
  *(void *)(v5 + 88) = 0;
  *(void *)(v5 + 72) = 0;
  *(_DWORD *)(v5 + 96) = 0;
  uint64_t v13 = *(void *)(a2 + 80);
  *(void *)(v5 + 72) = *(void *)(a2 + 72);
  *(void *)(v5 + 80) = v13;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  uint64_t v14 = *(void *)(v5 + 88);
  *(void *)(v5 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v14;
  uint64_t v15 = *(void *)(v5 + 104);
  *(void *)(v5 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v15;
  ++*(_DWORD *)(a2 + 96);
  ++*(_DWORD *)(v5 + 96);
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(v5 + 112, (unsigned __int8 *)(a2 + 112));
  uint64_t result = re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(v5 + 160, (unsigned __int8 *)(a2 + 160));
  *(void *)(v5 + 240) = 0;
  *(_DWORD *)(v5 + 232) = 0;
  *(void *)(v5 + 216) = 0;
  *(void *)(v5 + 224) = 0;
  *(void *)(v5 + 208) = 0;
  uint64_t v17 = *(void *)(a2 + 216);
  *(void *)(v5 + 208) = *(void *)(a2 + 208);
  *(void *)(v5 + 216) = v17;
  *(void *)(a2 + 208) = 0;
  *(void *)(a2 + 216) = 0;
  uint64_t v18 = *(void *)(v5 + 224);
  *(void *)(v5 + 224) = *(void *)(a2 + 224);
  *(void *)(a2 + 224) = v18;
  uint64_t v19 = *(void *)(v5 + 240);
  *(void *)(v5 + 240) = *(void *)(a2 + 240);
  *(void *)(a2 + 240) = v19;
  ++*(_DWORD *)(a2 + 232);
  ++*(_DWORD *)(v5 + 232);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

double re::DynamicArray<re::GeomModelWithLods>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::GeomModelWithLods>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 152 * v4;
  double result = 0.0;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(void *)(v5 + 24) = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v8 = *(void *)(a2 + 16);
  *(void *)(a2 + 24) = 0;
  uint64_t v10 = *(void *)(v5 + 8);
  uint64_t v9 = *(void *)(v5 + 16);
  *(void *)(v5 + 8) = v7;
  *(void *)(v5 + 16) = v8;
  *(void *)(a2 + 8) = v10;
  *(void *)(a2 + 16) = v9;
  *(void *)(v5 + 64) = 0;
  *(_DWORD *)(v5 + 56) = 0;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + 32) = 0;
  uint64_t v11 = *(void *)(a2 + 40);
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  *(void *)(v5 + 40) = v11;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v12 = *(void *)(v5 + 48);
  *(void *)(v5 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v12;
  uint64_t v13 = *(void *)(v5 + 64);
  *(void *)(v5 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v13;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(v5 + 56);
  *(void *)(v5 + 104) = 0;
  *(void *)(v5 + 80) = 0;
  *(void *)(v5 + 88) = 0;
  *(void *)(v5 + 72) = 0;
  *(_DWORD *)(v5 + 96) = 0;
  uint64_t v14 = *(void *)(a2 + 80);
  *(void *)(v5 + 72) = *(void *)(a2 + 72);
  *(void *)(v5 + 80) = v14;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  uint64_t v15 = *(void *)(v5 + 88);
  *(void *)(v5 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v15;
  uint64_t v16 = *(void *)(v5 + 104);
  *(void *)(v5 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v16;
  ++*(_DWORD *)(a2 + 96);
  ++*(_DWORD *)(v5 + 96);
  *(void *)(v5 + 144) = 0;
  *(void *)(v5 + 120) = 0;
  *(void *)(v5 + 128) = 0;
  *(void *)(v5 + 112) = 0;
  *(_DWORD *)(v5 + 136) = 0;
  uint64_t v17 = *(void *)(a2 + 120);
  *(void *)(v5 + 112) = *(void *)(a2 + 112);
  *(void *)(v5 + 120) = v17;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  uint64_t v18 = *(void *)(v5 + 128);
  *(void *)(v5 + 128) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = v18;
  uint64_t v19 = *(void *)(v5 + 144);
  *(void *)(v5 + 144) = *(void *)(a2 + 144);
  *(void *)(a2 + 144) = v19;
  ++*(_DWORD *)(a2 + 136);
  ++*(_DWORD *)(v5 + 136);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

__n128 re::DynamicArray<re::GeomInstance>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::GeomInstance>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 80 * v4;
  *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v7 = *(_OWORD *)(a2 + 32);
  long long v8 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v5 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v5 + 64) = v8;
  *(__n128 *)(v5 + 16) = result;
  *(_OWORD *)(v5 + 32) = v7;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::MeshPrimitiveProvider::init(re::MeshPrimitiveProvider *this, re::AssetProviderRegistry *a2, re::internal::AssetTypeRegistry *a3)
{
  uint64_t v5 = re::globalAllocators(this);
  uint64_t v6 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v6, 0);
  *uint64_t v6 = &unk_26E6CC0C8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76398, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76398))
  {
    qword_26AF76390 = re::internal::getOrCreateInfo((re::internal *)"TubeDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_TubeDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_TubeDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76298, 0);
    __cxa_guard_release(&qword_26AF76398);
  }
  qword_268773380 = qword_26AF76390;
  v6[3] = a2;
  v6[4] = &Tube::providerType;
  *uint64_t v6 = &unk_26E6CC008;
  int v47 = v6;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v47);

  int v47 = 0;
  long long v8 = re::globalAllocators(v7);
  uint64_t v9 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v9, 0);
  *uint64_t v9 = &unk_26E6CC218;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF763A8))
  {
    qword_26AF763A0 = re::internal::getOrCreateInfo((re::internal *)"PlaneDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_PlaneDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_PlaneDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF762B0, 0);
    __cxa_guard_release(&qword_26AF763A8);
  }
  qword_268773390 = qword_26AF763A0;
  v9[3] = a2;
  unsigned char v9[4] = &Plane::providerType;
  *uint64_t v9 = &unk_26E6CC158;
  uint64_t v46 = v9;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v46);

  uint64_t v46 = 0;
  uint64_t v11 = re::globalAllocators(v10);
  uint64_t v12 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11[2] + 32))(v11[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v12, 0);
  *uint64_t v12 = &unk_26E6CC368;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF763B8))
  {
    qword_26AF763B0 = re::internal::getOrCreateInfo((re::internal *)"CylinderDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_CylinderDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_CylinderDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF762C8, 0);
    __cxa_guard_release(&qword_26AF763B8);
  }
  qword_2687733A0 = qword_26AF763B0;
  _DWORD v12[3] = a2;
  v12[4] = &Cylinder::providerType;
  *uint64_t v12 = &unk_26E6CC2A8;
  int v45 = v12;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v45);

  int v45 = 0;
  uint64_t v14 = re::globalAllocators(v13);
  uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14[2] + 32))(v14[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v15, 0);
  *uint64_t v15 = &unk_26E6CC4B8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF763C8))
  {
    qword_26AF763C0 = re::internal::getOrCreateInfo((re::internal *)"TetrahedronDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_TetrahedronDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_TetrahedronDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF762E0, 0);
    __cxa_guard_release(&qword_26AF763C8);
  }
  qword_2687733B0 = qword_26AF763C0;
  v15[3] = a2;
  _DWORD v15[4] = &Tetrahedron::providerType;
  *uint64_t v15 = &unk_26E6CC3F8;
  uint64_t v44 = v15;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v44);

  uint64_t v44 = 0;
  uint64_t v17 = re::globalAllocators(v16);
  uint64_t v18 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17[2] + 32))(v17[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v18, 0);
  void *v18 = &unk_26E6CC608;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF763D8))
  {
    qword_26AF763D0 = re::internal::getOrCreateInfo((re::internal *)"ConeDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_ConeDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_ConeDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF762F8, 0);
    __cxa_guard_release(&qword_26AF763D8);
  }
  qword_2687733C0 = qword_26AF763D0;
  void v18[3] = a2;
  v18[4] = &Cone::providerType;
  void *v18 = &unk_26E6CC548;
  long long v43 = v18;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v43);

  long long v43 = 0;
  uint64_t v20 = re::globalAllocators(v19);
  uint64_t v21 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20[2] + 32))(v20[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v21, 0);
  *uint64_t v21 = &unk_26E6CC758;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF763E8))
  {
    qword_26AF763E0 = re::internal::getOrCreateInfo((re::internal *)"SphereDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_SphereDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_SphereDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76310, 0);
    __cxa_guard_release(&qword_26AF763E8);
  }
  qword_2687733D0 = qword_26AF763E0;
  long long v21[3] = a2;
  v21[4] = &Sphere::providerType;
  *uint64_t v21 = &unk_26E6CC698;
  uint64_t v42 = v21;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v42);

  uint64_t v42 = 0;
  uint32_t v23 = re::globalAllocators(v22);
  uint64_t v24 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v23[2] + 32))(v23[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v24, 0);
  *uint64_t v24 = &unk_26E6CC8A8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763F8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF763F8))
  {
    qword_26AF763F0 = re::internal::getOrCreateInfo((re::internal *)"CapsuleDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_CapsuleDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_CapsuleDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76328, 0);
    __cxa_guard_release(&qword_26AF763F8);
  }
  qword_2687733E0 = qword_26AF763F0;
  v24[3] = a2;
  v24[4] = &Capsule::providerType;
  *uint64_t v24 = &unk_26E6CC7E8;
  char v41 = v24;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v41);

  char v41 = 0;
  uint64_t v26 = re::globalAllocators(v25);
  uint64_t v27 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v26[2] + 32))(v26[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v27, 0);
  *uint64_t v27 = &unk_26E6CC9F8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76408, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76408))
  {
    qword_26AF76400 = re::internal::getOrCreateInfo((re::internal *)"PyramidDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_PyramidDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_PyramidDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76340, 0);
    __cxa_guard_release(&qword_26AF76408);
  }
  qword_2687733F0 = qword_26AF76400;
  v27[3] = a2;
  v27[4] = &Pyramid::providerType;
  *uint64_t v27 = &unk_26E6CC938;
  int v40 = v27;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v40);

  int v40 = 0;
  long long v29 = re::globalAllocators(v28);
  long long v30 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v29[2] + 32))(v29[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v30, 0);
  *long long v30 = &unk_26E6CCB48;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76418, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76418))
  {
    qword_26AF76410 = re::internal::getOrCreateInfo((re::internal *)"BoxDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_BoxDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_BoxDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76358, 0);
    __cxa_guard_release(&qword_26AF76418);
  }
  qword_268773400 = qword_26AF76410;
  v30[3] = a2;
  v30[4] = &Box::providerType;
  *long long v30 = &unk_26E6CCA88;
  int v39 = v30;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v39);

  int v39 = 0;
  long long v32 = re::globalAllocators(v31);
  uint64_t v33 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v32[2] + 32))(v32[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v33, 0);
  *uint64_t v33 = &unk_26E6CCC98;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76428, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76428))
  {
    qword_26AF76420 = re::internal::getOrCreateInfo((re::internal *)"BoxWithRoundedCornersDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_BoxWithRoundedCornersDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_BoxWithRoundedCornersDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76370, 0);
    __cxa_guard_release(&qword_26AF76428);
  }
  qword_268773410 = qword_26AF76420;
  v33[3] = a2;
  v33[4] = &BoxWithRoundedCorners::providerType;
  *uint64_t v33 = &unk_26E6CCBD8;
  char v38 = v33;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v38);

  char v38 = 0;
  char v35 = re::globalAllocators(v34);
  int v36 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35[2] + 32))(v35[2], 40, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v36, 0);
  *int v36 = &unk_26E6CCDE8;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76438, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76438))
  {
    qword_26AF76430 = re::internal::getOrCreateInfo((re::internal *)"ExtrudedTextDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_ExtrudedTextDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_ExtrudedTextDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76388, 0);
    __cxa_guard_release(&qword_26AF76438);
  }
  qword_268773420 = qword_26AF76430;
  v36[3] = a2;
  v36[4] = &ExtrudedText::providerType;
  *int v36 = &unk_26E6CCD28;
  char v37 = v36;
  re::AssetProviderRegistry::registerAssetProvider((os_unfair_lock_s *)this, (uint64_t *)&v37);
}

uint64_t re::MeshPrimitiveProvider::makeDescriptor@<X0>(uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  *(void *)&long long v16 = Tube::providerType;
  *((void *)&v16 + 1) = strlen(Tube::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  *(void *)&long long v16 = v10;
  *((void *)&v16 + 1) = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  int v12 = *(_DWORD *)(a1 + 12);
  __int16 v13 = *(_WORD *)(a1 + 16);
  char v14 = *(unsigned char *)(a1 + 18);
  LODWORD(v16) = *(_DWORD *)a1;
  *(void *)((char *)&v16 + 4) = *(void *)(a1 + 4);
  HIDWORD(v16) = v12;
  __int16 v17 = v13;
  char v18 = v14;
  char v19 = a2;
  char v20 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_268773380, (const re::IntrospectionBase **)&v16, 0);
}

{
  _anonymous_namespace_ *v8;
  re::MeshAsset *v9;
  const char *v10;
  size_t v11;
  int v12;
  int v13;
  int v14;
  size_t v15;
  const re::IntrospectionBase *v17;
  size_t v18;
  int v19;
  int v20;
  int v21;
  char v22;
  char v23;

  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  __int16 v17 = (const re::IntrospectionBase *)Plane::providerType;
  char v18 = strlen(Plane::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v17);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  __int16 v17 = (const re::IntrospectionBase *)v10;
  char v18 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v17);
  int v12 = *(_DWORD *)(a1 + 16);
  __int16 v13 = *(_DWORD *)(a1 + 20);
  char v14 = *(_DWORD *)(a1 + 24);
  uint64_t v15 = *(void *)(a1 + 8);
  __int16 v17 = *(const re::IntrospectionBase **)a1;
  char v18 = v15;
  char v19 = v12;
  char v20 = v13;
  uint64_t v21 = v14;
  double v22 = a2;
  uint32_t v23 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_268773390, &v17, 0);
}

{
  _anonymous_namespace_ *v8;
  re::MeshAsset *v9;
  const char *v10;
  size_t v11;
  int v12;
  int v13;
  char v14;
  long long v16;
  int v17;
  char v18;
  char v19;
  char v20;

  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  *(void *)&long long v16 = Cylinder::providerType;
  *((void *)&v16 + 1) = strlen(Cylinder::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  *(void *)&long long v16 = v10;
  *((void *)&v16 + 1) = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  int v12 = *(_DWORD *)(a1 + 12);
  __int16 v13 = *(_DWORD *)(a1 + 16);
  char v14 = *(unsigned char *)(a1 + 20);
  LODWORD(v16) = *(_DWORD *)a1;
  *(void *)((char *)&v16 + 4) = *(void *)(a1 + 4);
  HIDWORD(v16) = v12;
  __int16 v17 = v13;
  char v18 = v14;
  char v19 = a2;
  char v20 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2687733A0, (const re::IntrospectionBase **)&v16, 0);
}

{
  _anonymous_namespace_ *v8;
  re::MeshAsset *v9;
  const char *v10;
  size_t v11;
  __int16 v12;
  char v13;
  size_t v14;
  const re::IntrospectionBase *v16;
  size_t v17;
  __int16 v18;
  char v19;
  char v20;
  char v21;

  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  long long v16 = (const re::IntrospectionBase *)Capsule::providerType;
  __int16 v17 = strlen(Capsule::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  long long v16 = (const re::IntrospectionBase *)v10;
  __int16 v17 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  int v12 = *(_WORD *)(a1 + 16);
  __int16 v13 = *(unsigned char *)(a1 + 18);
  char v14 = *(void *)(a1 + 8);
  long long v16 = *(const re::IntrospectionBase **)a1;
  __int16 v17 = v14;
  char v18 = v12;
  char v19 = v13;
  char v20 = a2;
  uint64_t v21 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2687733E0, &v16, 0);
}

{
  _anonymous_namespace_ *v8;
  re::MeshAsset *v9;
  const char *v10;
  size_t v11;
  int v12;
  __int16 v13;
  char v14;
  long long v16;
  __int16 v17;
  char v18;
  char v19;
  char v20;

  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  *(void *)&long long v16 = Pyramid::providerType;
  *((void *)&v16 + 1) = strlen(Pyramid::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  *(void *)&long long v16 = v10;
  *((void *)&v16 + 1) = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  int v12 = *(_DWORD *)(a1 + 12);
  __int16 v13 = *(_WORD *)(a1 + 16);
  char v14 = *(unsigned char *)(a1 + 18);
  LODWORD(v16) = *(_DWORD *)a1;
  *(void *)((char *)&v16 + 4) = *(void *)(a1 + 4);
  HIDWORD(v16) = v12;
  __int16 v17 = v13;
  char v18 = v14;
  char v19 = a2;
  char v20 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2687733F0, (const re::IntrospectionBase **)&v16, 0);
}

{
  _anonymous_namespace_ *v8;
  re::MeshAsset *v9;
  const char *v10;
  size_t v11;
  __int16 v12;
  char v13;
  const re::IntrospectionBase *v15;
  long long v16;
  __int16 v17;
  char v18;
  char v19;
  char v20;

  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  uint64_t v15 = (const re::IntrospectionBase *)Box::providerType;
  *(void *)&long long v16 = strlen(Box::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v15);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  uint64_t v15 = (const re::IntrospectionBase *)v10;
  *(void *)&long long v16 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v15);
  int v12 = *(_WORD *)(a1 + 24);
  __int16 v13 = *(unsigned char *)(a1 + 26);
  uint64_t v15 = *(const re::IntrospectionBase **)a1;
  long long v16 = *(_OWORD *)(a1 + 8);
  __int16 v17 = v12;
  char v18 = v13;
  char v19 = a2;
  char v20 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_268773400, &v15, 0);
}

{
  _anonymous_namespace_ *v8;
  re::MeshAsset *v9;
  const char *v10;
  size_t v11;
  int v12;
  int v13;
  __int16 v14;
  char v15;
  const re::IntrospectionBase *v17;
  unsigned char v18[20];
  int v19;
  int v20;
  __int16 v21;
  char v22;
  char v23;
  char v24;

  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  __int16 v17 = (const re::IntrospectionBase *)BoxWithRoundedCorners::providerType;
  *(void *)char v18 = strlen(BoxWithRoundedCorners::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v17);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  __int16 v17 = (const re::IntrospectionBase *)v10;
  *(void *)char v18 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v17);
  int v12 = *(_DWORD *)(a1 + 8);
  __int16 v13 = *(_DWORD *)(a1 + 28);
  char v14 = *(_WORD *)(a1 + 36);
  uint64_t v15 = *(unsigned char *)(a1 + 38);
  __int16 v17 = *(const re::IntrospectionBase **)a1;
  *(_DWORD *)char v18 = v12;
  *(_OWORD *)&v18[4] = *(_OWORD *)(a1 + 12);
  char v19 = v13;
  char v20 = *(_DWORD *)(a1 + 32);
  uint64_t v21 = v14;
  double v22 = v15;
  uint32_t v23 = a2;
  uint64_t v24 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_268773410, &v17, 0);
}

uint64_t re::MeshPrimitiveProvider::makeDescriptor@<X0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  long long v16 = (const re::IntrospectionBase *)Tetrahedron::providerType;
  size_t v17 = strlen(Tetrahedron::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  long long v16 = (const re::IntrospectionBase *)v10;
  size_t v17 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  unint64_t v12 = *(unsigned __int16 *)(a1 + 8) | ((unint64_t)*(unsigned __int8 *)(a1 + 10) << 16);
  uint64_t v13 = 0x100000000;
  if (!a2) {
    uint64_t v13 = 0;
  }
  uint64_t v14 = 0x10000000000;
  if (!a3) {
    uint64_t v14 = 0;
  }
  long long v16 = *(const re::IntrospectionBase **)a1;
  size_t v17 = v14 | v13 | v12;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2687733B0, &v16, 0);
}

{
  _anonymous_namespace_ *v8;
  re::MeshAsset *v9;
  const char *v10;
  size_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const re::IntrospectionBase *v16;
  size_t v17;

  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  long long v16 = (const re::IntrospectionBase *)Sphere::providerType;
  size_t v17 = strlen(Sphere::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v16);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  long long v16 = (const re::IntrospectionBase *)v10;
  size_t v17 = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v16);
  unint64_t v12 = *(unsigned __int16 *)(a1 + 8) | ((unint64_t)*(unsigned __int8 *)(a1 + 10) << 16);
  uint64_t v13 = 0x100000000;
  if (!a2) {
    uint64_t v13 = 0;
  }
  uint64_t v14 = 0x10000000000;
  if (!a3) {
    uint64_t v14 = 0;
  }
  long long v16 = *(const re::IntrospectionBase **)a1;
  size_t v17 = v14 | v13 | v12;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2687733D0, &v16, 0);
}

uint64_t re::MeshPrimitiveProvider::makeDescriptor@<X0>(_anonymous_namespace_ *a1@<X0>, char a2@<W1>, char a3@<W2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  *(void *)&long long v13 = Cone::providerType;
  *((void *)&v13 + 1) = strlen(Cone::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v13);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  *(void *)&long long v13 = v10;
  *((void *)&v13 + 1) = v11;
  re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v13);
  long long v13 = *(_OWORD *)a1;
  char v14 = a2;
  char v15 = a3;
  return re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_2687733C0, (const re::IntrospectionBase **)&v13, 0);
}

uint64_t *re::MeshPrimitiveProvider::makeDescriptor@<X0>(re::MeshPrimitiveProvider *this@<X0>, const re::GeomBuildExtrudedTextOptions *a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  char v5 = (char)a2;
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 24) = 0;
  long long v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a4, 0);
  *(void *)(a4 + 32) = 0;
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(void *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(void *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a4 + 112), 0);
  uint64_t v33 = (uint64_t *)ExtrudedText::providerType;
  size_t v34 = strlen(ExtrudedText::providerType);
  uint64_t v9 = re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v33);
  uint64_t v10 = (const char *)*re::MeshAsset::assetType(v9);
  size_t v11 = strlen(v10);
  uint64_t v33 = (uint64_t *)v10;
  size_t v34 = v11;
  unint64_t v12 = re::DynamicString::operator=((re::DynamicString *)(a4 + 112), (uint64_t)&v33);
  size_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  long long v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v33, 0);
  *((void *)&v37 + 1) = 0;
  long long v38 = 0uLL;
  re::DynamicString::setCapacity(&v37, 0);
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)&long long v39 = _D0;
  BYTE8(v39) = 5;
  long long v40 = 0uLL;
  uint64_t v41 = 0x1010101000400;
  re::DynamicString::operator=((re::DynamicString *)&v33, this);
  re::DynamicString::operator=((re::DynamicString *)&v37, (re::MeshPrimitiveProvider *)((char *)this + 32));
  long long v19 = *((_OWORD *)this + 5);
  long long v39 = *((_OWORD *)this + 4);
  long long v40 = v19;
  uint64_t v41 = *((void *)this + 12);
  LOBYTE(v42) = v5;
  HIBYTE(v42) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)v27, (const re::DynamicString *)&v33);
  re::DynamicString::DynamicString((re::DynamicString *)v28, (const re::DynamicString *)&v37);
  long long v29 = v39;
  long long v30 = v40;
  uint64_t v31 = v41;
  __int16 v32 = v42;
  re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)qword_268773420, (const re::IntrospectionBase **)v27, 0);
  if (v28[0])
  {
    if (v28[1]) {
      (*(void (**)(void))(*(void *)v28[0] + 40))();
    }
    memset(v28, 0, sizeof(v28));
  }
  if (*(void *)&v27[0])
  {
    if (BYTE8(v27[0])) {
      (*(void (**)(void))(**(void **)&v27[0] + 40))();
    }
    memset(v27, 0, sizeof(v27));
  }
  if ((void)v37)
  {
    if (BYTE8(v37)) {
      (*(void (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v37 + 40))(v37, v38, v20, v21, v22, v23, v24, v25);
    }
    long long v37 = 0u;
    long long v38 = 0u;
  }
  __n128 result = v33;
  if (v33)
  {
    if (v34) {
      return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*v33 + 40))(v33, v35, v20, v21, v22, v23, v24, v25);
    }
  }
  return result;
}

void anonymous namespace'::BuildSupport::setFont(_anonymous_namespace_::BuildSupport *this, CFTypeRef cf, unint64_t a3)
{
  *((void *)this + 10) = cf;
  *((void *)this + 11) = a3;
  uint64_t v5 = *((unsigned __int16 *)this + 48);
  uint64_t v6 = ((a3 << 6) + (a3 >> 2) - 0x61C8864680B583E9 + v5) ^ a3;
  if (cf) {
    CFRetain(cf);
  }
  long long v7 = (const void *)*((void *)this + 7);
  *((_WORD *)this + 36) = v5;
  *((void *)this + 7) = cf;
  *((void *)this + 8) = v6;
  if (v7)
  {
    CFRelease(v7);
  }
}

void anonymous namespace'::BuildSupport::setGlyphIndex(_anonymous_namespace_::BuildSupport *this, uint64_t a2)
{
  __int16 v2 = a2;
  *((void *)this + 12) = a2;
  uint64_t v4 = *((void *)this + 10);
  uint64_t v5 = ((*((void *)this + 11) << 6) + (unsigned __int16)a2 + (*((void *)this + 11) >> 2) - 0x61C8864680B583E9) ^ *((void *)this + 11);
  if (v4) {
    CFRetain(*((CFTypeRef *)this + 10));
  }
  uint64_t v6 = (const void *)*((void *)this + 7);
  *((_WORD *)this + 36) = v2;
  *((void *)this + 7) = v4;
  *((void *)this + 8) = v5;
  if (v6)
  {
    CFRelease(v6);
  }
}

uint64_t anonymous namespace'::BuildSupport::cachedGlyph(_anonymous_namespace_::BuildSupport *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (!*(void *)v1) {
    return 0;
  }
  uint64_t v2 = *(unsigned int *)(*(void *)(v1 + 8) + 4
                                             * (*((void *)this + 8) % (unint64_t)*(unsigned int *)(v1 + 24)));
  if (v2 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v3 = (char *)this + 56;
  uint64_t v4 = *(void *)(v1 + 16);
  while (1)
  {
    BOOL v5 = re::internal::FontNameAndGlyphIndexCacheKey::operator==(v4 + 816 * v2 + 16, (uint64_t)v3);
    uint64_t v4 = *(void *)(v1 + 16);
    if (v5) {
      break;
    }
    uint64_t v2 = *(_DWORD *)(v4 + 816 * v2 + 8) & 0x7FFFFFFF;
    if (v2 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v4 + 816 * v2 + 48;
}

uint64_t anonymous namespace'::BuildSupport::storeGlyph(uint64_t a1, re::GeomMesh *a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  unint64_t v5 = *(void *)(a1 + 64);
  if (!*(void *)v4)
  {
    LODWORD(v6) = 0;
    goto LABEL_8;
  }
  unint64_t v6 = v5 % *(unsigned int *)(v4 + 24);
  uint64_t v7 = *(unsigned int *)(*(void *)(v4 + 8) + 4 * v6);
  if (v7 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v10 = *(_DWORD *)(v4 + 36);
    if (v10 == 0x7FFFFFFF)
    {
      unsigned int v10 = *(_DWORD *)(v4 + 32);
      unsigned int v11 = v10;
      if (v10 == *(_DWORD *)(v4 + 24))
      {
        re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::setCapacity(v4, 2 * *(_DWORD *)(v4 + 28));
        LODWORD(v6) = v5 % *(unsigned int *)(v4 + 24);
        unsigned int v11 = *(_DWORD *)(v4 + 32);
      }
      *(_DWORD *)(v4 + 32) = v11 + 1;
      uint64_t v12 = *(void *)(v4 + 16);
      int v13 = *(_DWORD *)(v12 + 816 * v10 + 8);
    }
    else
    {
      uint64_t v12 = *(void *)(v4 + 16);
      int v13 = *(_DWORD *)(v12 + 816 * v10 + 8);
      *(_DWORD *)(v4 + 36) = v13 & 0x7FFFFFFF;
    }
    uint64_t v14 = 816 * v10;
    *(_DWORD *)(v12 + v14 + 8) = v13 | 0x80000000;
    *(_DWORD *)(*(void *)(v4 + 16) + v14 + 8) = *(_DWORD *)(*(void *)(v4 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(v4 + 8) + 4 * v6);
    *(void *)(*(void *)(v4 + 16) + v14) = v5;
    uint64_t v15 = *(void *)(v4 + 16) + v14;
    long long v16 = *(const void **)(a1 + 56);
    uint64_t v17 = *(void *)(a1 + 64);
    *(void *)(v15 + 16) = v16;
    *(void *)(v15 + 24) = v17;
    *(_WORD *)(v15 + 32) = *(_WORD *)(a1 + 72);
    if (v16) {
      CFRetain(v16);
    }
    uint64_t v18 = *(void *)(v4 + 16) + 816 * v10;
    *(void *)(v18 + 48) = 0;
    v18 += 48;
    *(_DWORD *)(v18 + 8) = 0;
    bzero((void *)(v18 + 16), 0x2C8uLL);
    re::internal::GeomBaseMesh::GeomBaseMesh((re::internal::GeomBaseMesh *)(v18 + 16));
    *(void *)(v18 + 728) = 0;
    re::GeomMesh::copy(a2, (re::GeomMesh *)v18);
    long long v19 = *((_OWORD *)a2 + 47);
    *(_OWORD *)(v18 + 736) = *((_OWORD *)a2 + 46);
    *(_OWORD *)(v18 + 752) = v19;
    *(_DWORD *)(*(void *)(v4 + 8) + 4 * v6) = v10;
    ++*(_DWORD *)(v4 + 28);
    ++*(_DWORD *)(v4 + 40);
    uint64_t v20 = *(void *)(v4 + 16) + 816 * v10;
    return v20 + 48;
  }
  uint64_t v8 = *(void *)(v4 + 16);
  while (1)
  {
    BOOL v9 = re::internal::FontNameAndGlyphIndexCacheKey::operator==(v8 + 816 * v7 + 16, a1 + 56);
    uint64_t v8 = *(void *)(v4 + 16);
    if (v9) {
      break;
    }
    uint64_t v7 = *(_DWORD *)(v8 + 816 * v7 + 8) & 0x7FFFFFFF;
    if (v7 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v20 = v8 + 816 * v7;
  return v20 + 48;
}

__n128 anonymous namespace'::BuildSupport::finalBounds(_anonymous_namespace_::BuildSupport *this, const AABB *a2)
{
  __n128 result = *(__n128 *)&a2->var0.var0.var0.var0;
  long long v3 = *(_OWORD *)&a2->var1.var0.var1[1];
  *((_OWORD *)this + 1) = *(_OWORD *)&a2->var0.var0.var0.var0;
  *((_OWORD *)this + 2) = v3;
  return result;
}

void re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v26, 0, 36);
      *(void *)&v26[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::init((uint64_t)v26, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v26;
      unint64_t v6 = *(uint64_t **)(a1 + 16);
      long long v7 = *(_OWORD *)&v26[8];
      *(_OWORD *)uint64_t v26 = v5;
      *(void *)&v26[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v26[24];
      *(_OWORD *)&v26[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v26[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        do
        {
          if ((v6[1] & 0x80000000) != 0)
          {
            unint64_t v13 = *v6;
            unint64_t v14 = *(unsigned int *)(a1 + 24);
            unint64_t v15 = *v6 % v14;
            unsigned int v16 = *(_DWORD *)(a1 + 36);
            if (v16 == 0x7FFFFFFF)
            {
              unsigned int v16 = *(_DWORD *)(a1 + 32);
              unsigned int v17 = v16;
              if (v16 == v14)
              {
                re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v15 = v13 % *(unsigned int *)(a1 + 24);
                unsigned int v17 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v17 + 1;
              uint64_t v18 = *(void *)(a1 + 16);
              int v19 = *(_DWORD *)(v18 + 816 * v16 + 8);
            }
            else
            {
              uint64_t v18 = *(void *)(a1 + 16);
              int v19 = *(_DWORD *)(v18 + 816 * v16 + 8);
              *(_DWORD *)(a1 + 36) = v19 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v18 + 816 * v16 + 8) = v19 | 0x80000000;
            uint64_t v20 = *(void *)(a1 + 16) + 816 * v16;
            *(_DWORD *)(v20 + 8) = *(_DWORD *)(v20 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v15);
            *(void *)(*(void *)(a1 + 16) + 816 * v16) = v13;
            uint64_t v21 = *(void *)(a1 + 16) + 816 * v16;
            uint64_t v22 = (const void *)v6[2];
            *(void *)(v21 + 16) = v22;
            *(void *)(v21 + 24) = v6[3];
            *(_WORD *)(v21 + 32) = *((_WORD *)v6 + 16);
            if (v22) {
              CFRetain(v22);
            }
            uint64_t v23 = *(void *)(a1 + 16) + 816 * v16;
            re::GeomMesh::GeomMesh(v23 + 48, (uint64_t)(v6 + 6));
            long long v24 = *((_OWORD *)v6 + 50);
            *(_OWORD *)(v23 + 784) = *((_OWORD *)v6 + 49);
            *(_OWORD *)(v23 + 800) = v24;
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v15) = v16;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v6 += 102;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::deinit((uint64_t *)v26);
    }
  }
  else
  {
    if (a2) {
      signed int v25 = a2;
    }
    else {
      signed int v25 = 3;
    }
  }
}

void re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    long long v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unsigned int v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 816 * v10, 16);
  if (v12)
  {
    unint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

re::GeomModel *re::GeomModel::GeomModel(re::GeomModel *this)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 1) = 0;
  uint64_t v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(this, 1uLL);
  *((void *)this + 8) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 4) = 0;
  long long v3 = (_anonymous_namespace_ *)re::DynamicArray<re::GeomMesh>::setCapacity((void *)this + 4, 1uLL);
  ++*((_DWORD *)this + 14);
  *((void *)this + 13) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 9) = 0;
  re::DynamicArray<int>::setCapacity((void *)this + 9, 1uLL);
  ++*((_DWORD *)this + 24);
  *((unsigned char *)this + 112) = 0;
  *((unsigned char *)this + 160) = 0;
  *((void *)this + 30) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 28) = 0;
  *((void *)this + 26) = 0;
  *((_DWORD *)this + 58) = 0;
  return this;
}

void *re::DynamicArray<re::GeomMesh>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    long long v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::GeomMesh>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x2E0uLL))
        {
          uint64_t v2 = 736 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 736 * a2, 8);
          if (result)
          {
            long long v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 736, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      long long v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      unsigned int v8 = (re::GeomMesh *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 736 * v9;
        uint64_t v11 = (uint64_t)v7;
        do
        {
          re::GeomMesh::GeomMesh(v11, (uint64_t)v8);
          re::GeomMesh::~GeomMesh(v8);
          unsigned int v8 = (re::GeomMesh *)((char *)v8 + 736);
          v11 += 736;
          v10 -= 736;
        }
        while (v10);
        unsigned int v8 = (re::GeomMesh *)v5[4];
      }
      __n128 result = (void *)(*(uint64_t (**)(void, re::GeomMesh *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

re::GeomModelWithLods *re::GeomModelWithLods::GeomModelWithLods(re::GeomModelWithLods *this)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 1) = 0;
  uint64_t v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(this, 1uLL);
  *((void *)this + 8) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 4) = 0;
  uint64_t v3 = (_anonymous_namespace_ *)re::DynamicArray<re::GeomModel>::setCapacity((void *)this + 4, 1uLL);
  ++*((_DWORD *)this + 14);
  *((void *)this + 13) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 9) = 0;
  unint64_t v4 = (_anonymous_namespace_ *)re::DynamicArray<int>::setCapacity((void *)this + 9, 1uLL);
  ++*((_DWORD *)this + 24);
  *((void *)this + 18) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  *((void *)this + 14) = 0;
  re::DynamicArray<int>::setCapacity((void *)this + 14, 1uLL);
  ++*((_DWORD *)this + 34);
  return this;
}

void *re::DynamicArray<re::GeomModel>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    long long v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::GeomModel>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xF8uLL))
        {
          uint64_t v2 = 248 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 248 * a2, 8);
          if (result)
          {
            long long v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 248, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      long long v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 248 * v9;
        uint64_t v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::GeomModel>(v8, v11);
          v8 += 248;
          v11 += 248;
          v10 -= 248;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

double re::ObjectHelper::move<re::GeomModel>(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)a2 = *(void *)a1;
  *(void *)a1 = 0;
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 24) = 0;
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v6 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = v4;
  *(void *)(a2 + 16) = v5;
  *(void *)(a1 + 8) = v7;
  *(void *)(a1 + 16) = v6;
  *(void *)(a2 + 64) = 0;
  *(_DWORD *)(a2 + 56) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  uint64_t v8 = a1 + 32;
  uint64_t v9 = *(void *)(a1 + 40);
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  *(void *)(a2 + 40) = v9;
  *(void *)(a1 + 40) = 0;
  uint64_t v10 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = v10;
  uint64_t v11 = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = v11;
  ++*(_DWORD *)(a1 + 56);
  ++*(_DWORD *)(a2 + 56);
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 72) = 0;
  *(_DWORD *)(a2 + 96) = 0;
  uint64_t v12 = a1 + 72;
  uint64_t v13 = *(void *)(a1 + 80);
  *(void *)(a2 + 72) = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  *(void *)(a2 + 80) = v13;
  *(void *)(a1 + 80) = 0;
  uint64_t v14 = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = v14;
  uint64_t v15 = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = v15;
  ++*(_DWORD *)(a1 + 96);
  ++*(_DWORD *)(a2 + 96);
  unsigned int v16 = (unsigned char *)(a1 + 112);
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(a2 + 112, (unsigned __int8 *)(a1 + 112));
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(a2 + 160, (unsigned __int8 *)(a1 + 160));
  *(void *)(a2 + 240) = 0;
  *(_DWORD *)(a2 + 232) = 0;
  *(void *)(a2 + 216) = 0;
  *(void *)(a2 + 224) = 0;
  *(void *)(a2 + 208) = 0;
  uint64_t v17 = *(void *)(a1 + 216);
  *(void *)(a2 + 208) = *(void *)(a1 + 208);
  *(void *)(a2 + 216) = v17;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  uint64_t v18 = *(void *)(a2 + 224);
  *(void *)(a2 + 224) = *(void *)(a1 + 224);
  *(void *)(a1 + 224) = v18;
  uint64_t v19 = *(void *)(a2 + 240);
  *(void *)(a2 + 240) = *(void *)(a1 + 240);
  *(void *)(a1 + 240) = v19;
  ++*(_DWORD *)(a1 + 232);
  ++*(_DWORD *)(a2 + 232);
  re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit(a1 + 208);
  if (*(unsigned char *)(a1 + 160)) {
    re::DynamicArray<re::GeomIndexMap>::deinit(a1 + 168);
  }
  if (*v16) {
    re::DynamicArray<re::GeomIndexMap>::deinit(a1 + 120);
  }
  re::DynamicArray<unsigned long>::deinit(v12);
  re::DynamicArray<re::GeomMesh>::deinit(v8);
  return re::DynamicString::deinit((re::DynamicString *)a1);
}

uint64_t re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(uint64_t result, unsigned __int8 *a2)
{
  int v2 = *a2;
  *(unsigned char *)__n128 result = v2;
  if (v2)
  {
    *(void *)(result + 40) = 0;
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)(result + 8) = 0;
    *(_DWORD *)(result + 32) = 0;
    uint64_t v3 = *((void *)a2 + 2);
    *(void *)(result + 8) = *((void *)a2 + 1);
    *(void *)(result + 16) = v3;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    uint64_t v4 = *(void *)(result + 24);
    *(void *)(result + 24) = *((void *)a2 + 3);
    *((void *)a2 + 3) = v4;
    uint64_t v5 = *(void *)(result + 40);
    *(void *)(result + 40) = *((void *)a2 + 5);
    *((void *)a2 + 5) = v5;
    ++*((_DWORD *)a2 + 8);
    ++*(_DWORD *)(result + 32);
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomModel>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 0;
        uint64_t v6 = 248 * v4;
        do
        {
          uint64_t v7 = v3 + v5;
          re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit(v3 + v5 + 208);
          if (*(unsigned char *)(v3 + v5 + 160)) {
            re::DynamicArray<re::GeomIndexMap>::deinit(v7 + 168);
          }
          if (*(unsigned char *)(v7 + 112)) {
            re::DynamicArray<re::GeomIndexMap>::deinit(v3 + v5 + 120);
          }
          re::DynamicArray<unsigned long>::deinit(v3 + v5 + 72);
          re::DynamicArray<re::GeomMesh>::deinit(v3 + v5 + 32);
          re::DynamicString::deinit((re::DynamicString *)(v3 + v5));
          v5 += 248;
        }
        while (v6 != v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 48 * v4;
        do
        {
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v3);
          v3 += 6;
          v5 -= 48;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(uint64_t **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomIndexMap>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 80 * v4;
        uint64_t v6 = (_DWORD *)(v3 + 16);
        while (1)
        {
          int v7 = *((unsigned __int8 *)v6 - 4);
          if (v7 == 2)
          {
            re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)v6);
          }
          else if (v7 == 1)
          {
            re::DynamicArray<unsigned long>::deinit((uint64_t)v6);
          }
          else
          {
            if (*((unsigned char *)v6 - 4))
            {
              re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
              uint64_t result = _os_crash();
              __break(1u);
              return result;
            }
            *uint64_t v6 = 0;
          }
          v6 += 20;
          v5 -= 80;
          if (!v5)
          {
            uint64_t result = *(void *)a1;
            uint64_t v3 = *(void *)(a1 + 32);
            break;
          }
        }
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomMesh>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= *(void *)(a1 + 8))
  {
    re::DynamicArray<re::GeomMesh>::growCapacity((void *)a1, v4 + 1);
    unint64_t v4 = *(void *)(a1 + 16);
  }
  uint64_t result = re::GeomMesh::GeomMesh(*(void *)(a1 + 32) + 736 * v4, a2);
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void *re::DynamicArray<re::GeomMesh>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::GeomMesh>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::GeomMesh>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(void *)a1 || *(void *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomSkeleton>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 0;
        uint64_t v6 = 160 * v4;
        do
        {
          re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(v3 + v5 + 112));
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 88));
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 64));
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v3 + v5 + 40));
          re::FixedArray<re::StringID>::deinit((void *)(v3 + v5 + 16));
          re::StringID::destroyString((re::StringID *)(v3 + v5));
          v5 += 160;
        }
        while (v6 != v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomModelWithLods>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::DynamicString **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 152 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit((uint64_t)v3 + 112);
          re::DynamicArray<unsigned long>::deinit((uint64_t)v3 + 72);
          re::DynamicArray<re::GeomModel>::deinit((uint64_t)v3 + 32);
          re::DynamicString::deinit(v3);
          uint64_t v3 = (re::DynamicString *)((char *)v3 + 152);
          v5 -= 152;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::DynamicString **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::DynamicString *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetSkeleton>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 112 * v4;
        do
        {
          re::FixedArray<CoreIKTransform>::deinit(v3 + 11);
          re::FixedArray<CoreIKTransform>::deinit(v3 + 8);
          re::FixedArray<CoreIKTransform>::deinit(v3 + 5);
          re::FixedArray<re::StringID>::deinit(v3 + 2);
          re::StringID::destroyString((re::StringID *)v3);
          v3 += 14;
          v5 -= 112;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(uint64_t **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetInstance>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 96 * v4;
        do
        {
          re::StringID::destroyString(v3);
          uint64_t v3 = (re::StringID *)((char *)v3 + 96);
          v5 -= 96;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::StringID **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::MeshAssetModel>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    uint64_t result = (void *)result[4];
    if (result)
    {
      re::ObjectHelper::destroy<re::MeshAssetModel>((re::StringID *)result, (re::StringID *)&result[64 * v1[2]]);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[4]);
    }
    v1[4] = 0;
    v1[1] = 0;
    v1[2] = 0;
    void *v1 = 0;
    ++*((_DWORD *)v1 + 6);
  }
  return result;
}

void re::ObjectHelper::destroy<re::MeshAssetModel>(re::StringID *a1, re::StringID *a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = a1;
    do
    {
      re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit((uint64_t)v3 + 472);
      re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v3 + 432);
      re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit((uint64_t)v3 + 392);
      re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v3 + 352);
      re::DynamicArray<re::MeshAssetContactDeformerData>::deinit((uint64_t)v3 + 312);
      re::DynamicArray<unsigned long>::deinit((uint64_t)v3 + 272);
      re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)v3 + 232);
      re::DynamicArray<re::MeshAssetPart>::deinit((uint64_t)v3 + 192);
      re::DynamicArray<re::MeshAssetSkinningData>::deinit((uint64_t)v3 + 152);
      re::DynamicArray<re::MeshAssetBlendShapeData>::deinit((uint64_t)v3 + 112);
      re::StringID::destroyString(v3);
      uint64_t v3 = (re::StringID *)((char *)v3 + 512);
    }
    while (v3 != a2);
  }
}

uint64_t re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 112 * v4;
        do
        {
          re::FixedArray<CoreIKTransform>::deinit(v3 + 10);
          re::FixedArray<CoreIKTransform>::deinit(v3 + 7);
          re::FixedArray<CoreIKTransform>::deinit(v3 + 4);
          re::StringID::destroyString((re::StringID *)(v3 + 2));
          re::StringID::destroyString((re::StringID *)v3);
          v3 += 14;
          v5 -= 112;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(uint64_t **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetContactDeformerData>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 48 * v4;
        do
        {
          re::FixedArray<re::MeshAssetContactDeformerTarget>::deinit((void *)v3 + 2);
          re::StringID::destroyString(v3);
          uint64_t v3 = (re::StringID *)((char *)v3 + 48);
          v5 -= 48;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::StringID **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::FixedArray<re::MeshAssetContactDeformerTarget>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    uint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = 32 * v2;
      uint64_t v5 = (uint64_t *)(result[2] + 8);
      do
      {
        re::FixedArray<CoreIKTransform>::deinit(v5);
        v5 += 4;
        v4 -= 32;
      }
      while (v4);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetPart>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = v4 << 8;
        do
        {
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v3 + 200));
          re::StringID::destroyString((re::StringID *)(v3 + 72));
          re::DynamicArray<re::MeshAssetBuffer>::deinit(v3);
          v3 += 256;
          v5 -= 256;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetBuffer>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::DynamicString **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 80 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit((uint64_t)v3 + 32);
          re::DynamicString::deinit(v3);
          uint64_t v3 = (re::DynamicString *)((char *)v3 + 80);
          v5 -= 80;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::DynamicString **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::DynamicString *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetSkinningData>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 144 * v4;
        uint64_t v6 = (uint64_t *)(v3 + 56);
        do
        {
          re::FixedArray<CoreIKTransform>::deinit(v6);
          re::FixedArray<CoreIKTransform>::deinit(v6 - 3);
          re::FixedArray<CoreIKTransform>::deinit(v6 - 6);
          v6 += 18;
          v5 -= 144;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetBlendShapeData>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 56 * v4;
        do
        {
          re::FixedArray<re::BlendShapeDefinition>::deinit((void *)v3 + 2);
          re::StringID::destroyString(v3);
          uint64_t v3 = (re::StringID *)((char *)v3 + 56);
          v5 -= 56;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::StringID **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::FixedArray<re::BlendShapeDefinition>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    uint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = 0;
      uint64_t v5 = result[2];
      uint64_t v6 = 136 * v2;
      do
      {
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v5 + v4 + 112));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v5 + v4 + 88));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v5 + v4 + 64));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v5 + v4 + 40));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v5 + v4 + 16));
        re::StringID::destroyString((re::StringID *)(v5 + v4));
        v4 += 136;
      }
      while (v6 != v4);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomMesh>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::GeomMesh **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 736 * v4;
        do
        {
          re::GeomMesh::~GeomMesh(v3);
          uint64_t v3 = (re::GeomMesh *)((char *)v3 + 736);
          v5 -= 736;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::GeomMesh **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::GeomMesh *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::GeomModel>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::GeomModel>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::GeomModel>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::GeomModelWithLods>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::GeomModelWithLods>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::GeomModelWithLods>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::GeomInstance>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::RigSplineIKJoint>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::RigSplineIKJoint>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

double re::HashTable<re::internal::FontNameAndGlyphIndexCacheKey,re::GeomBuildExtrudedTextSupport::Glyph,re::Hash<re::internal::FontNameAndGlyphIndexCacheKey>,re::EqualTo<re::internal::FontNameAndGlyphIndexCacheKey>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2];
        uint64_t v7 = v6 + v4;
        int v8 = *(_DWORD *)(v6 + v4 + 8);
        if (v8 < 0)
        {
          *(_DWORD *)(v7 + 8) = v8 & 0x7FFFFFFF;
          uint64_t v9 = *(const void **)(v7 + 16);
          if (v9)
          {
            CFRelease(v9);
            *(void *)(v7 + 16) = 0;
          }
          re::GeomMesh::~GeomMesh((re::GeomMesh *)(v6 + v4 + 48));
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 816;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::ObjectHelper::move<re::GeomModelWithLods>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(_OWORD *)a3 = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      *(void *)(a3 + 24) = *(void *)(v5 + 24);
      uint64_t v6 = *(void *)(v5 + 8);
      *(void *)a3 = *(void *)v5;
      *(void *)uint64_t v5 = 0;
      uint64_t v7 = *(void *)(v5 + 16);
      *(void *)(v5 + 24) = 0;
      uint64_t v9 = *(void *)(a3 + 8);
      uint64_t v8 = *(void *)(a3 + 16);
      *(void *)(a3 + 8) = v6;
      *(void *)(a3 + 16) = v7;
      *(void *)(v5 + 8) = v9;
      *(void *)(v5 + 16) = v8;
      *(void *)(a3 + 64) = 0;
      *(_DWORD *)(a3 + 56) = 0;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      *(void *)(a3 + 32) = 0;
      uint64_t v10 = *(void *)(v5 + 40);
      *(void *)(a3 + 32) = *(void *)(v5 + 32);
      *(void *)(v5 + 32) = 0;
      *(void *)(a3 + 40) = v10;
      *(void *)(v5 + 40) = 0;
      uint64_t v11 = *(void *)(a3 + 48);
      *(void *)(a3 + 48) = *(void *)(v5 + 48);
      *(void *)(v5 + 48) = v11;
      uint64_t v12 = *(void *)(a3 + 64);
      *(void *)(a3 + 64) = *(void *)(v5 + 64);
      *(void *)(v5 + 64) = v12;
      ++*(_DWORD *)(v5 + 56);
      ++*(_DWORD *)(a3 + 56);
      *(void *)(a3 + 104) = 0;
      *(void *)(a3 + 80) = 0;
      *(void *)(a3 + 88) = 0;
      *(void *)(a3 + 72) = 0;
      *(_DWORD *)(a3 + 96) = 0;
      uint64_t v13 = *(void *)(v5 + 80);
      *(void *)(a3 + 72) = *(void *)(v5 + 72);
      *(void *)(v5 + 72) = 0;
      *(void *)(a3 + 80) = v13;
      *(void *)(v5 + 80) = 0;
      uint64_t v14 = *(void *)(a3 + 88);
      *(void *)(a3 + 88) = *(void *)(v5 + 88);
      *(void *)(v5 + 88) = v14;
      uint64_t v15 = *(void *)(a3 + 104);
      *(void *)(a3 + 104) = *(void *)(v5 + 104);
      *(void *)(v5 + 104) = v15;
      ++*(_DWORD *)(v5 + 96);
      ++*(_DWORD *)(a3 + 96);
      *(void *)(a3 + 144) = 0;
      *(void *)(a3 + 120) = 0;
      *(void *)(a3 + 128) = 0;
      *(void *)(a3 + 112) = 0;
      *(_DWORD *)(a3 + 136) = 0;
      uint64_t v16 = *(void *)(v5 + 120);
      *(void *)(a3 + 112) = *(void *)(v5 + 112);
      *(void *)(v5 + 112) = 0;
      *(void *)(a3 + 120) = v16;
      *(void *)(v5 + 120) = 0;
      uint64_t v17 = *(void *)(a3 + 128);
      *(void *)(a3 + 128) = *(void *)(v5 + 128);
      *(void *)(v5 + 128) = v17;
      uint64_t v18 = *(void *)(a3 + 144);
      *(void *)(a3 + 144) = *(void *)(v5 + 144);
      *(void *)(v5 + 144) = v18;
      ++*(_DWORD *)(v5 + 136);
      ++*(_DWORD *)(a3 + 136);
      re::DynamicArray<unsigned long>::deinit(v5 + 112);
      re::DynamicArray<unsigned long>::deinit(v5 + 72);
      re::DynamicArray<re::GeomModel>::deinit(v5 + 32);
      re::DynamicString::deinit((re::DynamicString *)v5);
      v5 += 152;
      a3 += 152;
    }
    while (v5 != a2);
  }
}

uint64_t re::Result<re::MeshAssetData,re::DetailedError>::~Result(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    re::DynamicArray<unsigned long>::deinit(a1 + 128);
    re::DynamicArray<re::MeshAssetSkeleton>::deinit(a1 + 88);
    re::DynamicArray<re::MeshAssetInstance>::deinit(a1 + 48);
    re::DynamicArray<re::MeshAssetModel>::deinit((void *)(a1 + 8));
  }
  else
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

void Tube::~Tube(Tube *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<TubeDescriptorParameters,re::GeomBuildTubeOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t anonymous namespace'::PrimitiveProvider<TubeDescriptorParameters,re::GeomBuildTubeOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    uint64_t v8 = *(const char **)(a2 + 16);
  }
  else {
    uint64_t v8 = (const char *)(a2 + 9);
  }
  uint64_t v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v11 = a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v60, v10, v11);
    goto LABEL_17;
  }
  uint64_t v54 = 0x3EC000003F800000;
  int v53 = 65544;
  int v55 = 1056964608;
  __int16 v56 = 257;
  char v57 = 0;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<TubeDescriptorParameters>((re::AssetLoadDescriptor *)a2, (re::DynamicString **)&v53);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    long long v18 = v60;
    long long v19 = v61;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  int v52 = 0;
  v49[1] = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  v49[0] = 0;
  int v51 = 0;
  v45[1] = 0;
  uint64_t v46 = 0;
  v45[0] = 0;
  int v47 = 0;
  if (v58)
  {
    re::buildTube((uint64_t)v49, (unsigned __int16 *)&v53);
    uint64_t v13 = v50;
    re::DynamicArray<float>::resize((uint64_t)v45, v50);
    if (v13)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v46;
      uint64_t v16 = v48;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14) {
          goto LABEL_21;
        }
      }
      *(void *)&long long v40 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v60 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v65 = 136315906;
      uint64_t v66 = "operator[]";
      uint64_t v67 = 0x800000003150400;
      *(void *)uint64_t v68 = v15;
      *(_WORD *)&v68[8] = 2048;
      *(void *)&v68[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      *(void *)&long long v40 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v60 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v65 = 136315906;
      uint64_t v66 = "operator[]";
      uint64_t v67 = 0x800000003150400;
      *(void *)uint64_t v68 = 0;
      *(_WORD *)&v68[8] = 2048;
      *(void *)&v68[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v49, 1uLL);
    LODWORD(v60) = 0;
    re::DynamicArray<unsigned int>::resize(v45, 1uLL, &v60);
    if (!v50) {
      goto LABEL_35;
    }
    re::buildTube((uint64_t)v52, (unsigned __int16 *)&v53);
  }
LABEL_21:
  int v65 = 16842752;
  LOBYTE(v66) = 1;
  *(_DWORD *)((char *)&v66 + 1) = 0;
  BYTE5(v66) = 0;
  v68[0] = 0;
  long long v70 = 0u;
  *(_OWORD *)&v68[4] = 0u;
  long long v69 = 0u;
  DWORD1(v70) = 0x7FFFFFFF;
  BYTE6(v66) = v59;
  uint64_t v67 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v52, v50, v48, v46, 0, &v65, (uint64_t)&v60);
  int v21 = v60;
  uint64_t v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  uint64_t v23 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22[2] + 32))(v22[2], 960, 8);
  long long v24 = v23;
  if (v21) {
    signed int v25 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v23, (uint64_t)&v60 + 8);
  }
  else {
    re::MeshAsset::MeshAsset(v23);
  }
  uint64_t v26 = a1[3];
  uint64_t v27 = re::MeshAsset::assetType(v25);
  long long v28 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v26, (unint64_t)v27);
  long long v29 = re::MeshAsset::assetType(v28);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v44, 2056, a3, (const char *)*v29);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v28 + 24))(v28, v24, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
    if (*(unsigned char *)(a2 + 120)) {
      uint64_t v31 = *(const char **)(a2 + 128);
    }
    else {
      uint64_t v31 = (const char *)(a2 + 121);
    }
    *(void *)&long long v43 = v24;
    BYTE8(v43) = 0;
    long long v36 = v40;
    uint64_t v37 = v41;
    uint64_t v38 = v42;
    *(unsigned char *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v43;
    *(unsigned char *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(void *)(a4 + 24) = v37;
    *(void *)(a4 + 32) = v38;
  }
  else
  {
    __int16 v32 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v24);
    long long v33 = v40;
    uint64_t v34 = v41;
    uint64_t v35 = v42;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(void *)(a4 + 24) = v34;
    *(void *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v60);
  double v39 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v68[4]);
  if (v45[0] && v48) {
    (*(void (**)(double))(*(void *)v45[0] + 40))(v39);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v49);
}

__n128 anonymous namespace'::PrimitiveProvider<TubeDescriptorParameters,re::GeomBuildTubeOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<TubeDescriptorParameters,re::GeomBuildTubeOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  int v14 = 65544;
  uint64_t v15 = 0x3EC000003F800000;
  int v16 = 1056964608;
  __int16 v17 = 257;
  char v18 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<TubeDescriptorParameters>(a2, (re::DynamicString **)&v14))
  {
    if (v19) {
      uint64_t v5 = " split";
    }
    else {
      uint64_t v5 = "";
    }
    if (v20) {
      __n128 v6 = "";
    }
    else {
      __n128 v6 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(void *)a1 + 120))(&v8, a1, &v14);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(void *)&v10[0])
    {
      if (BYTE8(v10[0])) {
        (*(void (**)(void))(**(void **)&v10[0] + 40))();
      }
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0) {
      (*(void (**)(void))(*(void *)v8 + 40))();
    }
    __n128 result = (re::DynamicString *)v11;
    if (v11)
    {
      if (v12) {
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(void *)v11 + 40))(v11, v13);
      }
    }
  }
  else
  {
    uint64_t v11 = "<mangled>";
    uint64_t v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Tube::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  uint64_t v2 = "";
  if (*((unsigned char *)a1 + 16)) {
    unint64_t v3 = "";
  }
  else {
    unint64_t v3 = " noUV";
  }
  if (*((unsigned char *)a1 + 17)) {
    uint64_t v4 = "";
  }
  else {
    uint64_t v4 = " noNorm";
  }
  if (*((unsigned char *)a1 + 18)) {
    uint64_t v2 = " merge";
  }
  return re::DynamicString::format((re::DynamicString *)"%f/%d; %f:%f/%d;%s%s%s",
           a2,
           *((float *)a1 + 1),
           a1[1],
           *((float *)a1 + 2),
           *((float *)a1 + 3),
           *a1,
           v3,
           v4,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<TubeDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76398, memory_order_acquire) & 1) == 0)
  {
    uint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF76398);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF76390 = re::internal::getOrCreateInfo((re::internal *)"TubeDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_TubeDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_TubeDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76298, 0);
      __cxa_guard_release(&qword_26AF76398);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF76390;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

re *re::internal::destroyPersistent<re::MeshAsset>(re *result, uint64_t a2, void (***a3)(void))
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    (**a3)(a3);
    uint64_t v5 = *(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void Plane::~Plane(Plane *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<PlaneDescriptorParameters,re::GeomBuildPlaneOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t anonymous namespace'::PrimitiveProvider<PlaneDescriptorParameters,re::GeomBuildPlaneOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v75 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    int v8 = *(const char **)(a2 + 16);
  }
  else {
    int v8 = (const char *)(a2 + 9);
  }
  char v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v11 = a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v64, v10, v11);
    goto LABEL_17;
  }
  v58[0].i32[0] = 65537;
  v58[0].i16[2] = 0;
  __asm { FMOV            V0.2S, #1.0 }
  v58[1] = _D0;
  int v59 = 0;
  __int16 v60 = 257;
  int v61 = 2;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<PlaneDescriptorParameters>((re::AssetLoadDescriptor *)a2, (re::DynamicString **)v58);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    long long v23 = v64;
    long long v24 = v65;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v23;
    *(_OWORD *)(a4 + 24) = v24;
    return result;
  }
  char v57 = 0;
  v54[1] = 0;
  uint64_t v55 = 0;
  uint64_t v53 = 0;
  v54[0] = 0;
  int v56 = 0;
  v50[1] = 0;
  uint64_t v51 = 0;
  v50[0] = 0;
  int v52 = 0;
  if (v62)
  {
    re::buildPlane((re::GeomMesh *)v54, v58);
    uint64_t v18 = v55;
    re::DynamicArray<float>::resize((uint64_t)v50, v55);
    if (v18)
    {
      uint64_t v19 = 0;
      uint64_t v20 = v51;
      uint64_t v21 = v53;
      while (v20 != v19)
      {
        *(_DWORD *)(v21 + 4 * v19) = v19;
        if (v18 == ++v19) {
          goto LABEL_21;
        }
      }
      *(void *)&long long v45 = 0;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v64 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v69 = 136315906;
      long long v70 = "operator[]";
      uint64_t v71 = 0x800000003150400;
      *(void *)int v72 = v20;
      *(_WORD *)&v72[8] = 2048;
      *(void *)&v72[10] = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      *(void *)&long long v45 = 0;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v64 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v69 = 136315906;
      long long v70 = "operator[]";
      uint64_t v71 = 0x800000003150400;
      *(void *)int v72 = 0;
      *(_WORD *)&v72[8] = 2048;
      *(void *)&v72[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v54, 1uLL);
    LODWORD(v64) = 0;
    re::DynamicArray<unsigned int>::resize(v50, 1uLL, &v64);
    if (!v55) {
      goto LABEL_35;
    }
    re::buildPlane(v57, v58);
  }
LABEL_21:
  int v69 = 16842752;
  LOBYTE(v70) = 1;
  *(_DWORD *)((char *)&v70 + 1) = 0;
  BYTE5(v70) = 0;
  v72[0] = 0;
  long long v74 = 0u;
  *(_OWORD *)&void v72[4] = 0u;
  long long v73 = 0u;
  DWORD1(v74) = 0x7FFFFFFF;
  BYTE6(v70) = v63;
  uint64_t v71 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v57, v55, v53, v51, 0, &v69, (uint64_t)&v64);
  int v26 = v64;
  uint64_t v27 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  long long v28 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v27[2] + 32))(v27[2], 960, 8);
  long long v29 = v28;
  if (v26) {
    long long v30 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v28, (uint64_t)&v64 + 8);
  }
  else {
    re::MeshAsset::MeshAsset(v28);
  }
  uint64_t v31 = a1[3];
  __int16 v32 = re::MeshAsset::assetType(v30);
  long long v33 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v31, (unint64_t)v32);
  uint64_t v34 = re::MeshAsset::assetType(v33);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v49, 2056, a3, (const char *)*v34);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v33 + 24))(v33, v29, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v49);
    if (*(unsigned char *)(a2 + 120)) {
      long long v36 = *(const char **)(a2 + 128);
    }
    else {
      long long v36 = (const char *)(a2 + 121);
    }
    *(void *)&long long v48 = v29;
    BYTE8(v48) = 0;
    long long v41 = v45;
    uint64_t v42 = v46;
    uint64_t v43 = v47;
    *(unsigned char *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v48;
    *(unsigned char *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v41;
    *(void *)(a4 + 24) = v42;
    *(void *)(a4 + 32) = v43;
  }
  else
  {
    uint64_t v37 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v29);
    long long v38 = v45;
    uint64_t v39 = v46;
    uint64_t v40 = v47;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v38;
    *(void *)(a4 + 24) = v39;
    *(void *)(a4 + 32) = v40;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v49);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v64);
  double v44 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v72[4]);
  if (v50[0] && v53) {
    (*(void (**)(double))(*(void *)v50[0] + 40))(v44);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v54);
}

__n128 anonymous namespace'::PrimitiveProvider<PlaneDescriptorParameters,re::GeomBuildPlaneOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<PlaneDescriptorParameters,re::GeomBuildPlaneOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  LODWORD(v18[0]) = 65537;
  WORD2(v18[0]) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  v18[1] = _D0;
  int v19 = 0;
  __int16 v20 = 257;
  int v21 = 2;
  if (re::AssetLoadDescriptor::getIntrospectableData<PlaneDescriptorParameters>(a2, v18))
  {
    if (v22) {
      uint64_t v10 = " split";
    }
    else {
      uint64_t v10 = "";
    }
    if (v23) {
      uint64_t v11 = "";
    }
    else {
      uint64_t v11 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v16, v10, v11);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, re::DynamicString **))(*(void *)a1 + 120))(&v13, a1, v18);
    re::DynamicString::operator+((re::DynamicString *)&v13, (uint64_t)&v16, (re::DynamicString *)v15);
    re::DynamicString::operator=(a3, (re::DynamicString *)v15);
    if (*(void *)&v15[0])
    {
      if (BYTE8(v15[0])) {
        (*(void (**)(void))(**(void **)&v15[0] + 40))();
      }
      memset(v15, 0, sizeof(v15));
    }
    if (v13 && (v14 & 1) != 0) {
      (*(void (**)(void))(*(void *)v13 + 40))();
    }
    __n128 result = (re::DynamicString *)v16;
    if (v16)
    {
      if (v17) {
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v16 + 40))();
      }
    }
  }
  else
  {
    int v16 = "<mangled>";
    uint64_t v17 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v16);
  }
  return result;
}

uint64_t Plane::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  uint64_t v2 = "";
  if (*((unsigned char *)a1 + 20)) {
    unint64_t v3 = "";
  }
  else {
    unint64_t v3 = " noUV";
  }
  if (!*((unsigned char *)a1 + 21)) {
    uint64_t v2 = " noNorm";
  }
  return re::DynamicString::format((re::DynamicString *)"%fx%f; %dx%d; r=%f/%d;%s%s",
           a2,
           *((float *)a1 + 2),
           *((float *)a1 + 3),
           *a1,
           a1[1],
           *((float *)a1 + 4),
           a1[2],
           v3,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<PlaneDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763A8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF763A8);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF763A0 = re::internal::getOrCreateInfo((re::internal *)"PlaneDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_PlaneDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_PlaneDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF762B0, 0);
      __cxa_guard_release(&qword_26AF763A8);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF763A0;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void Cylinder::~Cylinder(Cylinder *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<CylinderDescriptorParameters,re::GeomBuildCylinderOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t anonymous namespace'::PrimitiveProvider<CylinderDescriptorParameters,re::GeomBuildCylinderOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    int v8 = *(const char **)(a2 + 16);
  }
  else {
    int v8 = (const char *)(a2 + 9);
  }
  char v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v11 = a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v59, v10, v11);
    goto LABEL_17;
  }
  int v53 = 65544;
  uint64_t v54 = 0x3F0000003F800000;
  uint64_t v55 = 0x10101013F000000;
  char v56 = 0;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<CylinderDescriptorParameters>((re::AssetLoadDescriptor *)a2, (re::DynamicString **)&v53);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    long long v18 = v59;
    long long v19 = v60;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  int v52 = 0;
  v49[1] = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  v49[0] = 0;
  int v51 = 0;
  v45[1] = 0;
  uint64_t v46 = 0;
  v45[0] = 0;
  int v47 = 0;
  if (v57)
  {
    re::buildCylinder((uint64_t)v49, (unsigned __int16 *)&v53);
    uint64_t v13 = v50;
    re::DynamicArray<float>::resize((uint64_t)v45, v50);
    if (v13)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v46;
      uint64_t v16 = v48;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14) {
          goto LABEL_21;
        }
      }
      *(void *)&long long v40 = 0;
      long long v63 = 0u;
      long long v62 = 0u;
      long long v61 = 0u;
      long long v60 = 0u;
      long long v59 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v64 = 136315906;
      long long v65 = "operator[]";
      uint64_t v66 = 0x800000003150400;
      *(void *)long long v67 = v15;
      *(_WORD *)&v67[8] = 2048;
      *(void *)&v67[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      *(void *)&long long v40 = 0;
      long long v63 = 0u;
      long long v62 = 0u;
      long long v61 = 0u;
      long long v60 = 0u;
      long long v59 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v64 = 136315906;
      long long v65 = "operator[]";
      uint64_t v66 = 0x800000003150400;
      *(void *)long long v67 = 0;
      *(_WORD *)&v67[8] = 2048;
      *(void *)&v67[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v49, 1uLL);
    LODWORD(v59) = 0;
    re::DynamicArray<unsigned int>::resize(v45, 1uLL, &v59);
    if (!v50) {
      goto LABEL_35;
    }
    re::buildCylinder((uint64_t)v52, (unsigned __int16 *)&v53);
  }
LABEL_21:
  int v64 = 16842752;
  LOBYTE(v65) = 1;
  *(_DWORD *)((char *)&v65 + 1) = 0;
  BYTE5(v65) = 0;
  v67[0] = 0;
  long long v69 = 0u;
  *(_OWORD *)&uint64_t v67[4] = 0u;
  long long v68 = 0u;
  DWORD1(v69) = 0x7FFFFFFF;
  BYTE6(v65) = v58;
  uint64_t v66 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v52, v50, v48, v46, 0, &v64, (uint64_t)&v59);
  int v21 = v59;
  char v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  char v23 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22[2] + 32))(v22[2], 960, 8);
  long long v24 = v23;
  if (v21) {
    signed int v25 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v23, (uint64_t)&v59 + 8);
  }
  else {
    re::MeshAsset::MeshAsset(v23);
  }
  uint64_t v26 = a1[3];
  uint64_t v27 = re::MeshAsset::assetType(v25);
  long long v28 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v26, (unint64_t)v27);
  long long v29 = re::MeshAsset::assetType(v28);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v44, 2056, a3, (const char *)*v29);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v28 + 24))(v28, v24, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
    if (*(unsigned char *)(a2 + 120)) {
      uint64_t v31 = *(const char **)(a2 + 128);
    }
    else {
      uint64_t v31 = (const char *)(a2 + 121);
    }
    *(void *)&long long v43 = v24;
    BYTE8(v43) = 0;
    long long v36 = v40;
    uint64_t v37 = v41;
    uint64_t v38 = v42;
    *(unsigned char *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v43;
    *(unsigned char *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(void *)(a4 + 24) = v37;
    *(void *)(a4 + 32) = v38;
  }
  else
  {
    __int16 v32 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v24);
    long long v33 = v40;
    uint64_t v34 = v41;
    uint64_t v35 = v42;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(void *)(a4 + 24) = v34;
    *(void *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v59);
  double v39 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v67[4]);
  if (v45[0] && v48) {
    (*(void (**)(double))(*(void *)v45[0] + 40))(v39);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v49);
}

__n128 anonymous namespace'::PrimitiveProvider<CylinderDescriptorParameters,re::GeomBuildCylinderOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<CylinderDescriptorParameters,re::GeomBuildCylinderOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  int v13 = 65544;
  uint64_t v14 = 0x3F0000003F800000;
  uint64_t v15 = 0x10101013F000000;
  char v16 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<CylinderDescriptorParameters>(a2, (re::DynamicString **)&v13))
  {
    if (v17) {
      uint64_t v5 = " split";
    }
    else {
      uint64_t v5 = "";
    }
    if (v18) {
      __n128 v6 = "";
    }
    else {
      __n128 v6 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(void *)a1 + 120))(&v8, a1, &v13);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(void *)&v10[0])
    {
      if (BYTE8(v10[0])) {
        (*(void (**)(void))(**(void **)&v10[0] + 40))();
      }
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0) {
      (*(void (**)(void))(*(void *)v8 + 40))();
    }
    __n128 result = (re::DynamicString *)v11;
    if (v11)
    {
      if (v12) {
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v11 + 40))();
      }
    }
  }
  else
  {
    uint64_t v11 = "<mangled>";
    uint64_t v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Cylinder::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  uint64_t v2 = "";
  if (*((unsigned char *)a1 + 16)) {
    unint64_t v3 = " capTop";
  }
  else {
    unint64_t v3 = "";
  }
  uint64_t v4 = " capBottom";
  if (!*((unsigned char *)a1 + 16)) {
    uint64_t v4 = "";
  }
  if (*((unsigned char *)a1 + 18)) {
    uint64_t v5 = "";
  }
  else {
    uint64_t v5 = " noUV";
  }
  if (*((unsigned char *)a1 + 19)) {
    __n128 v6 = "";
  }
  else {
    __n128 v6 = " noNorm";
  }
  if (*((unsigned char *)a1 + 20)) {
    uint64_t v2 = " merge";
  }
  return re::DynamicString::format((re::DynamicString *)"%fx%f:%f; %dx%d;%s%s%s%s%s",
           a2,
           *((float *)a1 + 1),
           *((float *)a1 + 2),
           *((float *)a1 + 3),
           *a1,
           a1[1],
           v3,
           v4,
           v5,
           v6,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<CylinderDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763B8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF763B8);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF763B0 = re::internal::getOrCreateInfo((re::internal *)"CylinderDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_CylinderDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_CylinderDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF762C8, 0);
      __cxa_guard_release(&qword_26AF763B8);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF763B0;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void Tetrahedron::~Tetrahedron(Tetrahedron *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<TetrahedronDescriptorParameters,re::GeomBuildTetrahedronOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t anonymous namespace'::PrimitiveProvider<TetrahedronDescriptorParameters,re::GeomBuildTetrahedronOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    int v8 = *(const char **)(a2 + 16);
  }
  else {
    int v8 = (const char *)(a2 + 9);
  }
  char v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v11 = a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v58, v10, v11);
    goto LABEL_17;
  }
  LOWORD(v53) = 1;
  HIDWORD(v53) = 1065353216;
  __int16 v54 = 257;
  char v55 = 0;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<TetrahedronDescriptorParameters>((re::AssetLoadDescriptor *)a2, &v53);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    long long v18 = v58;
    long long v19 = v59;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  int v52 = 0;
  v49[1] = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  v49[0] = 0;
  int v51 = 0;
  v45[1] = 0;
  uint64_t v46 = 0;
  v45[0] = 0;
  int v47 = 0;
  if (v56)
  {
    re::buildTetrahedron((re::GeomMesh *)v49, (uint64_t *)&v53);
    uint64_t v13 = v50;
    re::DynamicArray<float>::resize((uint64_t)v45, v50);
    if (v13)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v46;
      uint64_t v16 = v48;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14) {
          goto LABEL_21;
        }
      }
      *(void *)&long long v40 = 0;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v58 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      int v64 = "operator[]";
      uint64_t v65 = 0x800000003150400;
      *(void *)uint64_t v66 = v15;
      *(_WORD *)&unsigned __int8 v66[8] = 2048;
      *(void *)&v66[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      *(void *)&long long v40 = 0;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v58 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      int v64 = "operator[]";
      uint64_t v65 = 0x800000003150400;
      *(void *)uint64_t v66 = 0;
      *(_WORD *)&unsigned __int8 v66[8] = 2048;
      *(void *)&v66[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v49, 1uLL);
    LODWORD(v58) = 0;
    re::DynamicArray<unsigned int>::resize(v45, 1uLL, &v58);
    if (!v50) {
      goto LABEL_35;
    }
    re::buildTetrahedron(v52, (unsigned __int16 *)&v53);
  }
LABEL_21:
  int v63 = 16842752;
  LOBYTE(v64) = 1;
  *(_DWORD *)((char *)&v64 + 1) = 0;
  BYTE5(v64) = 0;
  v66[0] = 0;
  long long v68 = 0u;
  *(_OWORD *)&v66[4] = 0u;
  long long v67 = 0u;
  DWORD1(v68) = 0x7FFFFFFF;
  BYTE6(v64) = v57;
  uint64_t v65 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v52, v50, v48, v46, 0, &v63, (uint64_t)&v58);
  int v21 = v58;
  char v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  char v23 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22[2] + 32))(v22[2], 960, 8);
  long long v24 = v23;
  if (v21) {
    signed int v25 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v23, (uint64_t)&v58 + 8);
  }
  else {
    re::MeshAsset::MeshAsset(v23);
  }
  uint64_t v26 = a1[3];
  uint64_t v27 = re::MeshAsset::assetType(v25);
  long long v28 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v26, (unint64_t)v27);
  long long v29 = re::MeshAsset::assetType(v28);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v44, 2056, a3, (const char *)*v29);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v28 + 24))(v28, v24, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
    if (*(unsigned char *)(a2 + 120)) {
      uint64_t v31 = *(const char **)(a2 + 128);
    }
    else {
      uint64_t v31 = (const char *)(a2 + 121);
    }
    *(void *)&long long v43 = v24;
    BYTE8(v43) = 0;
    long long v36 = v40;
    uint64_t v37 = v41;
    uint64_t v38 = v42;
    *(unsigned char *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v43;
    *(unsigned char *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(void *)(a4 + 24) = v37;
    *(void *)(a4 + 32) = v38;
  }
  else
  {
    __int16 v32 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v24);
    long long v33 = v40;
    uint64_t v34 = v41;
    uint64_t v35 = v42;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(void *)(a4 + 24) = v34;
    *(void *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v58);
  double v39 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v66[4]);
  if (v45[0] && v48) {
    (*(void (**)(double))(*(void *)v45[0] + 40))(v39);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v49);
}

__n128 anonymous namespace'::PrimitiveProvider<TetrahedronDescriptorParameters,re::GeomBuildTetrahedronOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<TetrahedronDescriptorParameters,re::GeomBuildTetrahedronOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  LOWORD(v14) = 1;
  HIDWORD(v14) = 1065353216;
  __int16 v15 = 257;
  char v16 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<TetrahedronDescriptorParameters>(a2, &v14))
  {
    if (v17) {
      uint64_t v5 = " split";
    }
    else {
      uint64_t v5 = "";
    }
    if (v18) {
      __n128 v6 = "";
    }
    else {
      __n128 v6 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, re::DynamicString **))(*(void *)a1 + 120))(&v8, a1, &v14);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(void *)&v10[0])
    {
      if (BYTE8(v10[0])) {
        (*(void (**)(void))(**(void **)&v10[0] + 40))();
      }
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0) {
      (*(void (**)(void))(*(void *)v8 + 40))();
    }
    __n128 result = (re::DynamicString *)v11;
    if (v11)
    {
      if (v12) {
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(void *)v11 + 40))(v11, v13);
      }
    }
  }
  else
  {
    uint64_t v11 = "<mangled>";
    uint64_t v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Tetrahedron::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  uint64_t v2 = "";
  if (*((unsigned char *)a1 + 8)) {
    unint64_t v3 = "";
  }
  else {
    unint64_t v3 = " noUV";
  }
  if (*((unsigned char *)a1 + 9)) {
    uint64_t v4 = "";
  }
  else {
    uint64_t v4 = " noNorm";
  }
  if (*((unsigned char *)a1 + 10)) {
    uint64_t v2 = " merge";
  }
  return re::DynamicString::format((re::DynamicString *)"%f/%d;%s%s%s", a2, *((float *)a1 + 1), *a1, v3, v4, v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<TetrahedronDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763C8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF763C8);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF763C0 = re::internal::getOrCreateInfo((re::internal *)"TetrahedronDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_TetrahedronDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_TetrahedronDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF762E0, 0);
      __cxa_guard_release(&qword_26AF763C8);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF763C0;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void Cone::~Cone(Cone *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<ConeDescriptorParameters,re::GeomBuildConeOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t anonymous namespace'::PrimitiveProvider<ConeDescriptorParameters,re::GeomBuildConeOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    int v8 = *(const char **)(a2 + 16);
  }
  else {
    int v8 = (const char *)(a2 + 9);
  }
  char v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v11 = a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v58, v10, v11);
    goto LABEL_17;
  }
  int v53 = 65544;
  uint64_t v54 = 0x3F0000003F800000;
  int v55 = 65793;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<ConeDescriptorParameters>((re::AssetLoadDescriptor *)a2, (re::DynamicString **)&v53);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    long long v18 = v58;
    long long v19 = v59;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  int v52 = 0;
  v49[1] = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  v49[0] = 0;
  int v51 = 0;
  v45[1] = 0;
  uint64_t v46 = 0;
  v45[0] = 0;
  int v47 = 0;
  if (v56)
  {
    re::buildCone((uint64_t)v49, (unsigned __int16 *)&v53);
    uint64_t v13 = v50;
    re::DynamicArray<float>::resize((uint64_t)v45, v50);
    if (v13)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v46;
      uint64_t v16 = v48;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14) {
          goto LABEL_21;
        }
      }
      *(void *)&long long v40 = 0;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v58 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      int v64 = "operator[]";
      uint64_t v65 = 0x800000003150400;
      *(void *)uint64_t v66 = v15;
      *(_WORD *)&unsigned __int8 v66[8] = 2048;
      *(void *)&v66[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      *(void *)&long long v40 = 0;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v58 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      int v64 = "operator[]";
      uint64_t v65 = 0x800000003150400;
      *(void *)uint64_t v66 = 0;
      *(_WORD *)&unsigned __int8 v66[8] = 2048;
      *(void *)&v66[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v49, 1uLL);
    LODWORD(v58) = 0;
    re::DynamicArray<unsigned int>::resize(v45, 1uLL, &v58);
    if (!v50) {
      goto LABEL_35;
    }
    re::buildCone((uint64_t)v52, (unsigned __int16 *)&v53);
  }
LABEL_21:
  int v63 = 16842752;
  LOBYTE(v64) = 1;
  *(_DWORD *)((char *)&v64 + 1) = 0;
  BYTE5(v64) = 0;
  v66[0] = 0;
  long long v68 = 0u;
  *(_OWORD *)&v66[4] = 0u;
  long long v67 = 0u;
  DWORD1(v68) = 0x7FFFFFFF;
  BYTE6(v64) = v57;
  uint64_t v65 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v52, v50, v48, v46, 0, &v63, (uint64_t)&v58);
  int v21 = v58;
  char v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  char v23 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22[2] + 32))(v22[2], 960, 8);
  long long v24 = v23;
  if (v21) {
    signed int v25 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v23, (uint64_t)&v58 + 8);
  }
  else {
    re::MeshAsset::MeshAsset(v23);
  }
  uint64_t v26 = a1[3];
  uint64_t v27 = re::MeshAsset::assetType(v25);
  long long v28 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v26, (unint64_t)v27);
  long long v29 = re::MeshAsset::assetType(v28);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v44, 2056, a3, (const char *)*v29);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v28 + 24))(v28, v24, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
    if (*(unsigned char *)(a2 + 120)) {
      uint64_t v31 = *(const char **)(a2 + 128);
    }
    else {
      uint64_t v31 = (const char *)(a2 + 121);
    }
    *(void *)&long long v43 = v24;
    BYTE8(v43) = 0;
    long long v36 = v40;
    uint64_t v37 = v41;
    uint64_t v38 = v42;
    *(unsigned char *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v43;
    *(unsigned char *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(void *)(a4 + 24) = v37;
    *(void *)(a4 + 32) = v38;
  }
  else
  {
    __int16 v32 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v24);
    long long v33 = v40;
    uint64_t v34 = v41;
    uint64_t v35 = v42;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(void *)(a4 + 24) = v34;
    *(void *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v58);
  double v39 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v66[4]);
  if (v45[0] && v48) {
    (*(void (**)(double))(*(void *)v45[0] + 40))(v39);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v49);
}

__n128 anonymous namespace'::PrimitiveProvider<ConeDescriptorParameters,re::GeomBuildConeOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<ConeDescriptorParameters,re::GeomBuildConeOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  int v14 = 65544;
  uint64_t v15 = 0x3F0000003F800000;
  int v16 = 65793;
  if (re::AssetLoadDescriptor::getIntrospectableData<ConeDescriptorParameters>(a2, (re::DynamicString **)&v14))
  {
    if (v17) {
      uint64_t v5 = " split";
    }
    else {
      uint64_t v5 = "";
    }
    if (v18) {
      __n128 v6 = "";
    }
    else {
      __n128 v6 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(void *)a1 + 120))(&v8, a1, &v14);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(void *)&v10[0])
    {
      if (BYTE8(v10[0])) {
        (*(void (**)(void))(**(void **)&v10[0] + 40))();
      }
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0) {
      (*(void (**)(void))(*(void *)v8 + 40))();
    }
    __n128 result = (re::DynamicString *)v11;
    if (v11)
    {
      if (v12) {
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(void *)v11 + 40))(v11, v13);
      }
    }
  }
  else
  {
    uint64_t v11 = "<mangled>";
    uint64_t v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Cone::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  uint64_t v2 = " cap";
  unint64_t v3 = "";
  if (!*((unsigned char *)a1 + 12)) {
    uint64_t v2 = "";
  }
  if (*((unsigned char *)a1 + 13)) {
    uint64_t v4 = "";
  }
  else {
    uint64_t v4 = " noUV";
  }
  if (*((unsigned char *)a1 + 14)) {
    uint64_t v5 = "";
  }
  else {
    uint64_t v5 = " noNorm";
  }
  if (*((unsigned char *)a1 + 15)) {
    unint64_t v3 = " merge";
  }
  return re::DynamicString::format((re::DynamicString *)"%f/%d; %f/%d;%s%s%s%s",
           a2,
           *((float *)a1 + 2),
           *a1,
           *((float *)a1 + 1),
           a1[1],
           v2,
           v4,
           v5,
           v3);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<ConeDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763D8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF763D8);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF763D0 = re::internal::getOrCreateInfo((re::internal *)"ConeDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_ConeDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_ConeDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF762F8, 0);
      __cxa_guard_release(&qword_26AF763D8);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF763D0;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void Sphere::~Sphere(Sphere *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<SphereDescriptorParameters,re::GeomBuildSphereOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t anonymous namespace'::PrimitiveProvider<SphereDescriptorParameters,re::GeomBuildSphereOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    int v8 = *(const char **)(a2 + 16);
  }
  else {
    int v8 = (const char *)(a2 + 9);
  }
  char v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v11 = a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v58, v10, v11);
    goto LABEL_17;
  }
  LOWORD(v53) = 8;
  HIDWORD(v53) = 1056964608;
  __int16 v54 = 257;
  char v55 = 0;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<SphereDescriptorParameters>((re::AssetLoadDescriptor *)a2, &v53);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    long long v18 = v58;
    long long v19 = v59;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  int v52 = 0;
  v49[1] = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  v49[0] = 0;
  int v51 = 0;
  v45[1] = 0;
  uint64_t v46 = 0;
  v45[0] = 0;
  int v47 = 0;
  if (v56)
  {
    re::buildSphere((re::GeomMesh *)v49, (unsigned __int16 *)&v53);
    uint64_t v13 = v50;
    re::DynamicArray<float>::resize((uint64_t)v45, v50);
    if (v13)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v46;
      uint64_t v16 = v48;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14) {
          goto LABEL_21;
        }
      }
      *(void *)&long long v40 = 0;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v58 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      int v64 = "operator[]";
      uint64_t v65 = 0x800000003150400;
      *(void *)uint64_t v66 = v15;
      *(_WORD *)&unsigned __int8 v66[8] = 2048;
      *(void *)&v66[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      *(void *)&long long v40 = 0;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v58 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      int v64 = "operator[]";
      uint64_t v65 = 0x800000003150400;
      *(void *)uint64_t v66 = 0;
      *(_WORD *)&unsigned __int8 v66[8] = 2048;
      *(void *)&v66[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v49, 1uLL);
    LODWORD(v58) = 0;
    re::DynamicArray<unsigned int>::resize(v45, 1uLL, &v58);
    if (!v50) {
      goto LABEL_35;
    }
    re::buildSphere((uint64_t)v52, (unsigned __int16 *)&v53);
  }
LABEL_21:
  int v63 = 16842752;
  LOBYTE(v64) = 1;
  *(_DWORD *)((char *)&v64 + 1) = 0;
  BYTE5(v64) = 0;
  v66[0] = 0;
  long long v68 = 0u;
  *(_OWORD *)&v66[4] = 0u;
  long long v67 = 0u;
  DWORD1(v68) = 0x7FFFFFFF;
  BYTE6(v64) = v57;
  uint64_t v65 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v52, v50, v48, v46, 0, &v63, (uint64_t)&v58);
  int v21 = v58;
  char v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  char v23 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22[2] + 32))(v22[2], 960, 8);
  long long v24 = v23;
  if (v21) {
    signed int v25 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v23, (uint64_t)&v58 + 8);
  }
  else {
    re::MeshAsset::MeshAsset(v23);
  }
  uint64_t v26 = a1[3];
  uint64_t v27 = re::MeshAsset::assetType(v25);
  long long v28 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v26, (unint64_t)v27);
  long long v29 = re::MeshAsset::assetType(v28);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v44, 2056, a3, (const char *)*v29);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v28 + 24))(v28, v24, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
    if (*(unsigned char *)(a2 + 120)) {
      uint64_t v31 = *(const char **)(a2 + 128);
    }
    else {
      uint64_t v31 = (const char *)(a2 + 121);
    }
    *(void *)&long long v43 = v24;
    BYTE8(v43) = 0;
    long long v36 = v40;
    uint64_t v37 = v41;
    uint64_t v38 = v42;
    *(unsigned char *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v43;
    *(unsigned char *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(void *)(a4 + 24) = v37;
    *(void *)(a4 + 32) = v38;
  }
  else
  {
    __int16 v32 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v24);
    long long v33 = v40;
    uint64_t v34 = v41;
    uint64_t v35 = v42;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(void *)(a4 + 24) = v34;
    *(void *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v58);
  double v39 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v66[4]);
  if (v45[0] && v48) {
    (*(void (**)(double))(*(void *)v45[0] + 40))(v39);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v49);
}

__n128 anonymous namespace'::PrimitiveProvider<SphereDescriptorParameters,re::GeomBuildSphereOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<SphereDescriptorParameters,re::GeomBuildSphereOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  LOWORD(v14) = 8;
  HIDWORD(v14) = 1056964608;
  __int16 v15 = 257;
  char v16 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<SphereDescriptorParameters>(a2, &v14))
  {
    if (v17) {
      uint64_t v5 = " split";
    }
    else {
      uint64_t v5 = "";
    }
    if (v18) {
      __n128 v6 = "";
    }
    else {
      __n128 v6 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, re::DynamicString **))(*(void *)a1 + 120))(&v8, a1, &v14);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(void *)&v10[0])
    {
      if (BYTE8(v10[0])) {
        (*(void (**)(void))(**(void **)&v10[0] + 40))();
      }
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0) {
      (*(void (**)(void))(*(void *)v8 + 40))();
    }
    __n128 result = (re::DynamicString *)v11;
    if (v11)
    {
      if (v12) {
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(void *)v11 + 40))(v11, v13);
      }
    }
  }
  else
  {
    uint64_t v11 = "<mangled>";
    uint64_t v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Sphere::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  uint64_t v2 = "";
  if (*((unsigned char *)a1 + 8)) {
    unint64_t v3 = "";
  }
  else {
    unint64_t v3 = " noUV";
  }
  if (*((unsigned char *)a1 + 9)) {
    uint64_t v4 = "";
  }
  else {
    uint64_t v4 = " noNorm";
  }
  if (*((unsigned char *)a1 + 10)) {
    uint64_t v2 = " merge";
  }
  return re::DynamicString::format((re::DynamicString *)"%f/%d;%s%s%s", a2, *((float *)a1 + 1), *a1, v3, v4, v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<SphereDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763E8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF763E8);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF763E0 = re::internal::getOrCreateInfo((re::internal *)"SphereDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_SphereDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_SphereDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76310, 0);
      __cxa_guard_release(&qword_26AF763E8);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF763E0;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void Capsule::~Capsule(Capsule *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<CapsuleDescriptorParameters,re::GeomBuildCapsuleOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t anonymous namespace'::PrimitiveProvider<CapsuleDescriptorParameters,re::GeomBuildCapsuleOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    int v8 = *(const char **)(a2 + 16);
  }
  else {
    int v8 = (const char *)(a2 + 9);
  }
  char v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v11 = a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v58, v10, v11);
    goto LABEL_17;
  }
  LODWORD(v53[0]) = 65544;
  WORD2(v53[0]) = 4;
  v53[1] = (re::DynamicString *)0x400000003F000000;
  __int16 v54 = 257;
  char v55 = 0;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<CapsuleDescriptorParameters>((re::AssetLoadDescriptor *)a2, v53);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    long long v18 = v58;
    long long v19 = v59;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  int v52 = 0;
  v49[1] = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  v49[0] = 0;
  int v51 = 0;
  v45[1] = 0;
  uint64_t v46 = 0;
  v45[0] = 0;
  int v47 = 0;
  if (v56)
  {
    re::buildCapsule((re::GeomMesh *)v49, (unsigned __int16 *)v53);
    uint64_t v13 = v50;
    re::DynamicArray<float>::resize((uint64_t)v45, v50);
    if (v13)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v46;
      uint64_t v16 = v48;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14) {
          goto LABEL_21;
        }
      }
      *(void *)&long long v40 = 0;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v58 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      int v64 = "operator[]";
      uint64_t v65 = 0x800000003150400;
      *(void *)uint64_t v66 = v15;
      *(_WORD *)&unsigned __int8 v66[8] = 2048;
      *(void *)&v66[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      *(void *)&long long v40 = 0;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v58 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      int v64 = "operator[]";
      uint64_t v65 = 0x800000003150400;
      *(void *)uint64_t v66 = 0;
      *(_WORD *)&unsigned __int8 v66[8] = 2048;
      *(void *)&v66[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v49, 1uLL);
    LODWORD(v58) = 0;
    re::DynamicArray<unsigned int>::resize(v45, 1uLL, &v58);
    if (!v50) {
      goto LABEL_35;
    }
    re::buildCapsule((uint64_t)v52, (unsigned __int16 *)v53);
  }
LABEL_21:
  int v63 = 16842752;
  LOBYTE(v64) = 1;
  *(_DWORD *)((char *)&v64 + 1) = 0;
  BYTE5(v64) = 0;
  v66[0] = 0;
  long long v68 = 0u;
  *(_OWORD *)&v66[4] = 0u;
  long long v67 = 0u;
  DWORD1(v68) = 0x7FFFFFFF;
  BYTE6(v64) = v57;
  uint64_t v65 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v52, v50, v48, v46, 0, &v63, (uint64_t)&v58);
  int v21 = v58;
  char v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  char v23 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22[2] + 32))(v22[2], 960, 8);
  long long v24 = v23;
  if (v21) {
    signed int v25 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v23, (uint64_t)&v58 + 8);
  }
  else {
    re::MeshAsset::MeshAsset(v23);
  }
  uint64_t v26 = a1[3];
  uint64_t v27 = re::MeshAsset::assetType(v25);
  long long v28 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v26, (unint64_t)v27);
  long long v29 = re::MeshAsset::assetType(v28);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v44, 2056, a3, (const char *)*v29);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v28 + 24))(v28, v24, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
    if (*(unsigned char *)(a2 + 120)) {
      uint64_t v31 = *(const char **)(a2 + 128);
    }
    else {
      uint64_t v31 = (const char *)(a2 + 121);
    }
    *(void *)&long long v43 = v24;
    BYTE8(v43) = 0;
    long long v36 = v40;
    uint64_t v37 = v41;
    uint64_t v38 = v42;
    *(unsigned char *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v43;
    *(unsigned char *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(void *)(a4 + 24) = v37;
    *(void *)(a4 + 32) = v38;
  }
  else
  {
    __int16 v32 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v24);
    long long v33 = v40;
    uint64_t v34 = v41;
    uint64_t v35 = v42;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(void *)(a4 + 24) = v34;
    *(void *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v58);
  double v39 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v66[4]);
  if (v45[0] && v48) {
    (*(void (**)(double))(*(void *)v45[0] + 40))(v39);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v49);
}

__n128 anonymous namespace'::PrimitiveProvider<CapsuleDescriptorParameters,re::GeomBuildCapsuleOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<CapsuleDescriptorParameters,re::GeomBuildCapsuleOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  LODWORD(v14[0]) = 65544;
  WORD2(v14[0]) = 4;
  v14[1] = (re::DynamicString *)0x400000003F000000;
  __int16 v15 = 257;
  char v16 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<CapsuleDescriptorParameters>(a2, v14))
  {
    if (v17) {
      uint64_t v5 = " split";
    }
    else {
      uint64_t v5 = "";
    }
    if (v18) {
      __n128 v6 = "";
    }
    else {
      __n128 v6 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, re::DynamicString **))(*(void *)a1 + 120))(&v8, a1, v14);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(void *)&v10[0])
    {
      if (BYTE8(v10[0])) {
        (*(void (**)(void))(**(void **)&v10[0] + 40))();
      }
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0) {
      (*(void (**)(void))(*(void *)v8 + 40))();
    }
    __n128 result = (re::DynamicString *)v11;
    if (v11)
    {
      if (v12) {
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(void *)v11 + 40))(v11, v13);
      }
    }
  }
  else
  {
    uint64_t v11 = "<mangled>";
    uint64_t v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Capsule::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  uint64_t v2 = "";
  if (*((unsigned char *)a1 + 16)) {
    unint64_t v3 = "";
  }
  else {
    unint64_t v3 = " noUV";
  }
  if (*((unsigned char *)a1 + 17)) {
    uint64_t v4 = "";
  }
  else {
    uint64_t v4 = " noNorm";
  }
  if (*((unsigned char *)a1 + 18)) {
    uint64_t v2 = " merge";
  }
  return re::DynamicString::format((re::DynamicString *)"%d; %f/%d; %f/%d;%s%s%s",
           a2,
           *a1,
           *((float *)a1 + 2),
           a1[2],
           *((float *)a1 + 3),
           a1[1],
           v3,
           v4,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<CapsuleDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF763F8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF763F8);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF763F0 = re::internal::getOrCreateInfo((re::internal *)"CapsuleDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_CapsuleDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_CapsuleDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76328, 0);
      __cxa_guard_release(&qword_26AF763F8);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF763F0;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void Pyramid::~Pyramid(Pyramid *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<PyramidDescriptorParameters,re::GeomBuildPyramidOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t anonymous namespace'::PrimitiveProvider<PyramidDescriptorParameters,re::GeomBuildPyramidOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    int v8 = *(const char **)(a2 + 16);
  }
  else {
    int v8 = (const char *)(a2 + 9);
  }
  char v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v11 = a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v63, v10, v11);
    goto LABEL_17;
  }
  LOWORD(v58) = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)((char *)&v58 + 4) = _D0;
  HIDWORD(v58) = 1065353216;
  __int16 v59 = 257;
  char v60 = 0;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<PyramidDescriptorParameters>((re::AssetLoadDescriptor *)a2, (re::DynamicString **)&v58);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    long long v23 = v63;
    long long v24 = v64;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v23;
    *(_OWORD *)(a4 + 24) = v24;
    return result;
  }
  char v57 = 0;
  v54[1] = 0;
  uint64_t v55 = 0;
  uint64_t v53 = 0;
  v54[0] = 0;
  int v56 = 0;
  v50[1] = 0;
  uint64_t v51 = 0;
  v50[0] = 0;
  int v52 = 0;
  if (v61)
  {
    re::buildPyramid((re::GeomMesh *)v54, &v58);
    uint64_t v18 = v55;
    re::DynamicArray<float>::resize((uint64_t)v50, v55);
    if (v18)
    {
      uint64_t v19 = 0;
      uint64_t v20 = v51;
      uint64_t v21 = v53;
      while (v20 != v19)
      {
        *(_DWORD *)(v21 + 4 * v19) = v19;
        if (v18 == ++v19) {
          goto LABEL_21;
        }
      }
      *(void *)&long long v45 = 0;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v63 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v68 = 136315906;
      uint64_t v69 = "operator[]";
      uint64_t v70 = 0x800000003150400;
      *(void *)uint64_t v71 = v20;
      *(_WORD *)&v71[8] = 2048;
      *(void *)&v71[10] = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      *(void *)&long long v45 = 0;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v63 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v68 = 136315906;
      uint64_t v69 = "operator[]";
      uint64_t v70 = 0x800000003150400;
      *(void *)uint64_t v71 = 0;
      *(_WORD *)&v71[8] = 2048;
      *(void *)&v71[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v54, 1uLL);
    LODWORD(v63) = 0;
    re::DynamicArray<unsigned int>::resize(v50, 1uLL, &v63);
    if (!v55) {
      goto LABEL_35;
    }
    re::buildPyramid((uint64_t)v57, (int *)&v58);
  }
LABEL_21:
  int v68 = 16842752;
  LOBYTE(v69) = 1;
  *(_DWORD *)((char *)&v69 + 1) = 0;
  BYTE5(v69) = 0;
  v71[0] = 0;
  long long v73 = 0u;
  *(_OWORD *)&v71[4] = 0u;
  long long v72 = 0u;
  DWORD1(v73) = 0x7FFFFFFF;
  BYTE6(v69) = v62;
  uint64_t v70 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v57, v55, v53, v51, 0, &v68, (uint64_t)&v63);
  int v26 = v63;
  uint64_t v27 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  long long v28 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v27[2] + 32))(v27[2], 960, 8);
  long long v29 = v28;
  if (v26) {
    long long v30 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v28, (uint64_t)&v63 + 8);
  }
  else {
    re::MeshAsset::MeshAsset(v28);
  }
  uint64_t v31 = a1[3];
  __int16 v32 = re::MeshAsset::assetType(v30);
  long long v33 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v31, (unint64_t)v32);
  uint64_t v34 = re::MeshAsset::assetType(v33);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v49, 2056, a3, (const char *)*v34);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v33 + 24))(v33, v29, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v49);
    if (*(unsigned char *)(a2 + 120)) {
      long long v36 = *(const char **)(a2 + 128);
    }
    else {
      long long v36 = (const char *)(a2 + 121);
    }
    *(void *)&long long v48 = v29;
    BYTE8(v48) = 0;
    long long v41 = v45;
    uint64_t v42 = v46;
    uint64_t v43 = v47;
    *(unsigned char *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v48;
    *(unsigned char *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v41;
    *(void *)(a4 + 24) = v42;
    *(void *)(a4 + 32) = v43;
  }
  else
  {
    uint64_t v37 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v29);
    long long v38 = v45;
    uint64_t v39 = v46;
    uint64_t v40 = v47;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v38;
    *(void *)(a4 + 24) = v39;
    *(void *)(a4 + 32) = v40;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v49);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v63);
  double v44 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v71[4]);
  if (v50[0] && v53) {
    (*(void (**)(double))(*(void *)v50[0] + 40))(v44);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v54);
}

__n128 anonymous namespace'::PrimitiveProvider<PyramidDescriptorParameters,re::GeomBuildPyramidOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<PyramidDescriptorParameters,re::GeomBuildPyramidOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  v19[0] = 1;
  __asm { FMOV            V0.2S, #1.0 }
  uint64_t v20 = _D0;
  int v21 = 1065353216;
  __int16 v22 = 257;
  char v23 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<PyramidDescriptorParameters>(a2, (re::DynamicString **)v19))
  {
    if (v24) {
      uint64_t v10 = " split";
    }
    else {
      uint64_t v10 = "";
    }
    if (v25) {
      uint64_t v11 = "";
    }
    else {
      uint64_t v11 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v16, v10, v11);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 120))(&v13, a1, v19);
    re::DynamicString::operator+((re::DynamicString *)&v13, (uint64_t)&v16, (re::DynamicString *)v15);
    re::DynamicString::operator=(a3, (re::DynamicString *)v15);
    if (*(void *)&v15[0])
    {
      if (BYTE8(v15[0])) {
        (*(void (**)(void))(**(void **)&v15[0] + 40))();
      }
      memset(v15, 0, sizeof(v15));
    }
    if (v13 && (v14 & 1) != 0) {
      (*(void (**)(void))(*(void *)v13 + 40))();
    }
    __n128 result = (re::DynamicString *)v16;
    if (v16)
    {
      if (v17) {
        return (re::DynamicString *)(*(uint64_t (**)(const char *, uint64_t))(*(void *)v16 + 40))(v16, v18);
      }
    }
  }
  else
  {
    char v16 = "<mangled>";
    uint64_t v17 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v16);
  }
  return result;
}

uint64_t Pyramid::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  uint64_t v2 = "";
  if (*((unsigned char *)a1 + 16)) {
    unint64_t v3 = "";
  }
  else {
    unint64_t v3 = " noUV";
  }
  if (*((unsigned char *)a1 + 17)) {
    uint64_t v4 = "";
  }
  else {
    uint64_t v4 = " noNorm";
  }
  if (*((unsigned char *)a1 + 18)) {
    uint64_t v2 = " merge";
  }
  return re::DynamicString::format((re::DynamicString *)"%fx%fx%f/%d;%s%s%s",
           a2,
           *((float *)a1 + 1),
           *((float *)a1 + 2),
           *((float *)a1 + 3),
           *a1,
           v3,
           v4,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<PyramidDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76408, memory_order_acquire) & 1) == 0)
  {
    uint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF76408);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF76400 = re::internal::getOrCreateInfo((re::internal *)"PyramidDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_PyramidDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_PyramidDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76340, 0);
      __cxa_guard_release(&qword_26AF76408);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF76400;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void Box::~Box(Box *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<BoxDescriptorParameters,re::GeomBuildBoxOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t anonymous namespace'::PrimitiveProvider<BoxDescriptorParameters,re::GeomBuildBoxOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    int v8 = *(const char **)(a2 + 16);
  }
  else {
    int v8 = (const char *)(a2 + 9);
  }
  char v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v11 = a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v59, v10, v11);
    goto LABEL_17;
  }
  uint64_t v53 = 0x1000100010001;
  long long v54 = xmmword_234371EE0;
  __int16 v55 = 257;
  char v56 = 0;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<BoxDescriptorParameters>((re::AssetLoadDescriptor *)a2, (re::DynamicString **)&v53);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    long long v18 = v59;
    long long v19 = v60;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  int v52 = 0;
  v49[1] = 0;
  uint64_t v50 = 0;
  uint64_t v48 = 0;
  v49[0] = 0;
  int v51 = 0;
  v45[1] = 0;
  uint64_t v46 = 0;
  v45[0] = 0;
  int v47 = 0;
  if (v57)
  {
    re::buildBox((re::GeomMesh *)v49, (uint64_t)&v53);
    uint64_t v13 = v50;
    re::DynamicArray<float>::resize((uint64_t)v45, v50);
    if (v13)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v46;
      uint64_t v16 = v48;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14) {
          goto LABEL_21;
        }
      }
      *(void *)&long long v40 = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v59 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v64 = 136315906;
      long long v65 = "operator[]";
      uint64_t v66 = 0x800000003150400;
      *(void *)long long v67 = v15;
      *(_WORD *)&v67[8] = 2048;
      *(void *)&v67[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      *(void *)&long long v40 = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v59 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v64 = 136315906;
      long long v65 = "operator[]";
      uint64_t v66 = 0x800000003150400;
      *(void *)long long v67 = 0;
      *(_WORD *)&v67[8] = 2048;
      *(void *)&v67[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v49, 1uLL);
    LODWORD(v59) = 0;
    re::DynamicArray<unsigned int>::resize(v45, 1uLL, &v59);
    if (!v50) {
      goto LABEL_35;
    }
    re::internal::buildBoxHelper(v52, &v59, (unsigned __int16 *)&v53);
  }
LABEL_21:
  int v64 = 16842752;
  LOBYTE(v65) = 1;
  *(_DWORD *)((char *)&v65 + 1) = 0;
  BYTE5(v65) = 0;
  v67[0] = 0;
  long long v69 = 0u;
  *(_OWORD *)&uint64_t v67[4] = 0u;
  long long v68 = 0u;
  DWORD1(v69) = 0x7FFFFFFF;
  BYTE6(v65) = v58;
  uint64_t v66 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v52, v50, v48, v46, 0, &v64, (uint64_t)&v59);
  int v21 = v59;
  __int16 v22 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  char v23 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22[2] + 32))(v22[2], 960, 8);
  char v24 = v23;
  if (v21) {
    char v25 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v23, (uint64_t)&v59 + 8);
  }
  else {
    re::MeshAsset::MeshAsset(v23);
  }
  uint64_t v26 = a1[3];
  uint64_t v27 = re::MeshAsset::assetType(v25);
  long long v28 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v26, (unint64_t)v27);
  long long v29 = re::MeshAsset::assetType(v28);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v44, 2056, a3, (const char *)*v29);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v28 + 24))(v28, v24, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
    if (*(unsigned char *)(a2 + 120)) {
      uint64_t v31 = *(const char **)(a2 + 128);
    }
    else {
      uint64_t v31 = (const char *)(a2 + 121);
    }
    *(void *)&long long v43 = v24;
    BYTE8(v43) = 0;
    long long v36 = v40;
    uint64_t v37 = v41;
    uint64_t v38 = v42;
    *(unsigned char *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v43;
    *(unsigned char *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v36;
    *(void *)(a4 + 24) = v37;
    *(void *)(a4 + 32) = v38;
  }
  else
  {
    __int16 v32 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v24);
    long long v33 = v40;
    uint64_t v34 = v41;
    uint64_t v35 = v42;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(void *)(a4 + 24) = v34;
    *(void *)(a4 + 32) = v35;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v59);
  double v39 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v67[4]);
  if (v45[0] && v48) {
    (*(void (**)(double))(*(void *)v45[0] + 40))(v39);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v49);
}

__n128 anonymous namespace'::PrimitiveProvider<BoxDescriptorParameters,re::GeomBuildBoxOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<BoxDescriptorParameters,re::GeomBuildBoxOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  uint64_t v13 = 0x1000100010001;
  long long v14 = xmmword_234371EE0;
  __int16 v15 = 257;
  char v16 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<BoxDescriptorParameters>(a2, (re::DynamicString **)&v13))
  {
    if (v17) {
      uint64_t v5 = " split";
    }
    else {
      uint64_t v5 = "";
    }
    if (v18) {
      __n128 v6 = "";
    }
    else {
      __n128 v6 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 120))(&v8, a1, &v13);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(void *)&v10[0])
    {
      if (BYTE8(v10[0])) {
        (*(void (**)(void))(**(void **)&v10[0] + 40))();
      }
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0) {
      (*(void (**)(void))(*(void *)v8 + 40))();
    }
    __n128 result = (re::DynamicString *)v11;
    if (v11)
    {
      if (v12) {
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v11 + 40))();
      }
    }
  }
  else
  {
    uint64_t v11 = "<mangled>";
    uint64_t v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t Box::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  uint64_t v2 = "";
  if (*((unsigned char *)a1 + 24)) {
    unint64_t v3 = "";
  }
  else {
    unint64_t v3 = " noUV";
  }
  if (*((unsigned char *)a1 + 25)) {
    uint64_t v4 = "";
  }
  else {
    uint64_t v4 = " noNorm";
  }
  if (*((unsigned char *)a1 + 26)) {
    uint64_t v2 = " merge";
  }
  return re::DynamicString::format((re::DynamicString *)"%fx%fx%f; %dx%dx%d; r=%f/%d;%s%s%s",
           a2,
           *((float *)a1 + 3),
           *((float *)a1 + 4),
           *((float *)a1 + 5),
           *a1,
           a1[1],
           a1[2],
           *((float *)a1 + 2),
           a1[3],
           v3,
           v4,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<BoxDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76418, memory_order_acquire) & 1) == 0)
  {
    uint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF76418);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF76410 = re::internal::getOrCreateInfo((re::internal *)"BoxDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_BoxDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_BoxDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76358, 0);
      __cxa_guard_release(&qword_26AF76418);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF76410;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void BoxWithRoundedCorners::~BoxWithRoundedCorners(BoxWithRoundedCorners *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<BoxWithRoundedCornersDescriptorParameters,re::GeomBuildBoxWithRoundedCornersOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t anonymous namespace'::PrimitiveProvider<BoxWithRoundedCornersDescriptorParameters,re::GeomBuildBoxWithRoundedCornersOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    int v8 = *(const char **)(a2 + 16);
  }
  else {
    int v8 = (const char *)(a2 + 9);
  }
  char v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (strcmp(v8, v9))
  {
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v11 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v11 = a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v63, v10, v11);
    goto LABEL_17;
  }
  uint64_t v54 = 0x3000100010001;
  __int16 v55 = 4;
  long long v56 = xmmword_234371EF0;
  int v57 = 1065353216;
  int v58 = 16777473;
  __int16 v59 = 1;
  char v60 = 0;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<BoxWithRoundedCornersDescriptorParameters>((re::AssetLoadDescriptor *)a2, (re::DynamicString **)&v54);
  if ((Introspectable & 1) == 0)
  {
LABEL_17:
    long long v18 = v63;
    long long v19 = v64;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_OWORD *)(a4 + 24) = v19;
    return result;
  }
  uint64_t v53 = 0;
  v50[1] = 0;
  uint64_t v51 = 0;
  uint64_t v49 = 0;
  v50[0] = 0;
  int v52 = 0;
  v46[1] = 0;
  uint64_t v47 = 0;
  v46[0] = 0;
  int v48 = 0;
  if (v61)
  {
    re::buildBoxWithRoundedCorners((re::GeomMesh *)v50, (long long *)&v54);
    uint64_t v13 = v51;
    re::DynamicArray<float>::resize((uint64_t)v46, v51);
    if (v13)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v47;
      uint64_t v16 = v49;
      while (v15 != v14)
      {
        *(_DWORD *)(v16 + 4 * v14) = v14;
        if (v13 == ++v14) {
          goto LABEL_21;
        }
      }
      *(void *)&long long v41 = 0;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v63 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v68 = 136315906;
      long long v69 = "operator[]";
      uint64_t v70 = 0x800000003150400;
      *(void *)uint64_t v71 = v15;
      *(_WORD *)&v71[8] = 2048;
      *(void *)&v71[10] = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      *(void *)&long long v41 = 0;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v63 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v68 = 136315906;
      long long v69 = "operator[]";
      uint64_t v70 = 0x800000003150400;
      *(void *)uint64_t v71 = 0;
      *(_WORD *)&v71[8] = 2048;
      *(void *)&v71[10] = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    re::DynamicArray<re::GeomMesh>::resize((uint64_t)v50, 1uLL);
    LODWORD(v63) = 0;
    re::DynamicArray<unsigned int>::resize(v46, 1uLL, &v63);
    if (!v51) {
      goto LABEL_35;
    }
    uint64_t v20 = v53;
  }
LABEL_21:
  int v68 = 16842752;
  LOBYTE(v69) = 1;
  *(_DWORD *)((char *)&v69 + 1) = 0;
  BYTE5(v69) = 0;
  v71[0] = 0;
  long long v73 = 0u;
  *(_OWORD *)&v71[4] = 0u;
  long long v72 = 0u;
  DWORD1(v73) = 0x7FFFFFFF;
  BYTE6(v69) = v62;
  uint64_t v70 = 0x10101003F800000;
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v53, v51, v49, v47, 0, &v68, (uint64_t)&v63);
  int v22 = v63;
  char v23 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  char v24 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v23[2] + 32))(v23[2], 960, 8);
  char v25 = v24;
  if (v22) {
    uint64_t v26 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v24, (uint64_t)&v63 + 8);
  }
  else {
    re::MeshAsset::MeshAsset(v24);
  }
  uint64_t v27 = a1[3];
  long long v28 = re::MeshAsset::assetType(v26);
  long long v29 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v27, (unint64_t)v28);
  long long v30 = re::MeshAsset::assetType(v29);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v45, 2056, a3, (const char *)*v30);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v29 + 24))(v29, v25, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v45);
    if (*(unsigned char *)(a2 + 120)) {
      __int16 v32 = *(const char **)(a2 + 128);
    }
    else {
      __int16 v32 = (const char *)(a2 + 121);
    }
    *(void *)&long long v44 = v25;
    BYTE8(v44) = 0;
    long long v37 = v41;
    uint64_t v38 = v42;
    uint64_t v39 = v43;
    *(unsigned char *)(a4 + 56) = 0;
    *(_OWORD *)(a4 + 40) = v44;
    *(unsigned char *)a4 = 1;
    *(_OWORD *)(a4 + 8) = v37;
    *(void *)(a4 + 24) = v38;
    *(void *)(a4 + 32) = v39;
  }
  else
  {
    long long v33 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v25);
    long long v34 = v41;
    uint64_t v35 = v42;
    uint64_t v36 = v43;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v34;
    *(void *)(a4 + 24) = v35;
    *(void *)(a4 + 32) = v36;
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v45);
  }
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v63);
  double v40 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v71[4]);
  if (v46[0] && v49) {
    (*(void (**)(double))(*(void *)v46[0] + 40))(v40);
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v50);
}

__n128 anonymous namespace'::PrimitiveProvider<BoxWithRoundedCornersDescriptorParameters,re::GeomBuildBoxWithRoundedCornersOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<BoxWithRoundedCornersDescriptorParameters,re::GeomBuildBoxWithRoundedCornersOptions>::getDescription(uint64_t a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  uint64_t v13 = 0x3000100010001;
  __int16 v14 = 4;
  long long v15 = xmmword_234371EF0;
  int v16 = 1065353216;
  int v17 = 16777473;
  __int16 v18 = 1;
  char v19 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<BoxWithRoundedCornersDescriptorParameters>(a2, (re::DynamicString **)&v13))
  {
    if (v20) {
      uint64_t v5 = " split";
    }
    else {
      uint64_t v5 = "";
    }
    if (v21) {
      __n128 v6 = "";
    }
    else {
      __n128 v6 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v11, v5, v6);
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 120))(&v8, a1, &v13);
    re::DynamicString::operator+((re::DynamicString *)&v8, (uint64_t)&v11, (re::DynamicString *)v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)v10);
    if (*(void *)&v10[0])
    {
      if (BYTE8(v10[0])) {
        (*(void (**)(void))(**(void **)&v10[0] + 40))();
      }
      memset(v10, 0, sizeof(v10));
    }
    if (v8 && (v9 & 1) != 0) {
      (*(void (**)(void))(*(void *)v8 + 40))();
    }
    __n128 result = (re::DynamicString *)v11;
    if (v11)
    {
      if (v12) {
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v11 + 40))();
      }
    }
  }
  else
  {
    uint64_t v11 = "<mangled>";
    uint64_t v12 = 9;
    return re::DynamicString::operator=(a3, (uint64_t)&v11);
  }
  return result;
}

uint64_t BoxWithRoundedCorners::describe@<X0>(unsigned __int16 *a1@<X1>, re::DynamicString *a2@<X8>)
{
  uint64_t v2 = "";
  if (*((unsigned char *)a1 + 35)) {
    unint64_t v3 = "";
  }
  else {
    unint64_t v3 = " disCorner";
  }
  if (*((unsigned char *)a1 + 36)) {
    uint64_t v4 = "";
  }
  else {
    uint64_t v4 = "noClamp";
  }
  if (*((unsigned char *)a1 + 37)) {
    uint64_t v5 = " normUV";
  }
  else {
    uint64_t v5 = "";
  }
  __n128 v6 = " reflUV";
  if (!*((unsigned char *)a1 + 38)) {
    __n128 v6 = "";
  }
  if (*((unsigned char *)a1 + 32)) {
    uint64_t v7 = "";
  }
  else {
    uint64_t v7 = " noUV";
  }
  if (*((unsigned char *)a1 + 33)) {
    uint64_t v8 = "";
  }
  else {
    uint64_t v8 = " noNorm";
  }
  if (*((unsigned char *)a1 + 34)) {
    uint64_t v2 = " merge";
  }
  return re::DynamicString::format((re::DynamicString *)"%fx%fx%f; %dx%dx%d; %f/%d; %f/%d;%s%s%s%s%s%s%s",
           a2,
           *((float *)a1 + 5),
           *((float *)a1 + 6),
           *((float *)a1 + 7),
           *a1,
           a1[1],
           a1[2],
           *((float *)a1 + 3),
           a1[3],
           *((float *)a1 + 4),
           a1[4],
           v3,
           v4,
           v5,
           v6,
           v7,
           v8,
           v2);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<BoxWithRoundedCornersDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76428, memory_order_acquire) & 1) == 0)
  {
    uint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF76428);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF76420 = re::internal::getOrCreateInfo((re::internal *)"BoxWithRoundedCornersDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_BoxWithRoundedCornersDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_BoxWithRoundedCornersDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76370, 0);
      __cxa_guard_release(&qword_26AF76428);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF76420;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void ExtrudedText::~ExtrudedText(ExtrudedText *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t anonymous namespace'::PrimitiveProvider<ExtrudedTextDescriptorParameters,re::GeomBuildExtrudedTextOptions>::schemeName(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t ExtrudedText::load@<X0>(ExtrudedText *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, const re::CancellationToken *a4@<X4>, uint64_t a5@<X2>, uint64_t a6@<X8>)
{
  if (*((unsigned char *)a2 + 8)) {
    uint64_t v10 = (const char *)*((void *)a2 + 2);
  }
  else {
    uint64_t v10 = (char *)a2 + 9;
  }
  uint64_t v11 = (const char *)(*(uint64_t (**)(ExtrudedText *))(*(void *)this + 32))(this);
  uint64_t v12 = (_anonymous_namespace_ *)strcmp(v10, v11);
  if (v12)
  {
    uint64_t v13 = (*(uint64_t (**)(ExtrudedText *))(*(void *)this + 32))(this);
    if (*((unsigned char *)a2 + 8)) {
      __int16 v14 = (char *)*((void *)a2 + 2);
    }
    else {
      __int16 v14 = (char *)a2 + 9;
    }
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v45, v13, v14);
    long long v30 = v45;
    uint64_t v31 = v46;
    uint64_t v32 = v47;
    *(unsigned char *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v30;
    *(void *)(a6 + 24) = v31;
    *(void *)(a6 + 32) = v32;
    return result;
  }
  *((void *)&v45 + 1) = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  long long v15 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v45, 0);
  *((void *)&v48 + 1) = 0;
  long long v49 = 0uLL;
  re::DynamicString::setCapacity(&v48, 0);
  __asm { FMOV            V0.2S, #1.0 }
  uint64_t v50 = _D0;
  char v51 = 5;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  char v54 = 0;
  __int16 v55 = 4;
  int v56 = 16843009;
  char v57 = 0;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<ExtrudedTextDescriptorParameters>(a2, (re::DynamicString **)&v45);
  if ((Introspectable & 1) == 0)
  {
    long long v33 = v40;
    uint64_t v34 = v41;
    uint64_t v35 = v42;
    *(unsigned char *)a6 = 0;
LABEL_18:
    *(_OWORD *)(a6 + 8) = v33;
    *(void *)(a6 + 24) = v34;
    *(void *)(a6 + 32) = v35;
    goto LABEL_19;
  }
  Asset = (re::MeshAsset *)re::MeshPrimitiveProvider::makeAsset((re::MeshPrimitiveProvider *)&v45, (const re::GeomBuildExtrudedTextOptions *)v58, v59);
  uint64_t v23 = *((void *)this + 3);
  char v24 = re::MeshAsset::assetType(Asset);
  char v25 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v23, (unint64_t)v24);
  uint64_t v26 = re::MeshAsset::assetType(v25);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v44, 2056, a5, (const char *)*v26);
  if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v25 + 24))(v25, Asset, 0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
    if (*((unsigned char *)a2 + 120)) {
      long long v28 = (const char *)*((void *)a2 + 16);
    }
    else {
      long long v28 = (char *)a2 + 121;
    }
    *(void *)&long long v43 = Asset;
    BYTE8(v43) = 0;
    long long v33 = v40;
    uint64_t v34 = v41;
    uint64_t v35 = v42;
    *(unsigned char *)(a6 + 56) = 0;
    *(_OWORD *)(a6 + 40) = v43;
    *(unsigned char *)a6 = 1;
    goto LABEL_18;
  }
  uint64_t v36 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 508, (void (***)(void))Asset);
  long long v37 = v40;
  uint64_t v38 = v41;
  uint64_t v39 = v42;
  *(unsigned char *)a6 = 0;
  *(_OWORD *)(a6 + 8) = v37;
  *(void *)(a6 + 24) = v38;
  *(void *)(a6 + 32) = v39;
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v44);
LABEL_19:
  if ((void)v48)
  {
    if (BYTE8(v48)) {
      (*(void (**)(void))(*(void *)v48 + 40))();
    }
    long long v48 = 0u;
    long long v49 = 0u;
  }
  uint64_t result = v45;
  if (void)v45 && (BYTE8(v45)) {
    return (*(uint64_t (**)(void))(*(void *)v45 + 40))();
  }
  return result;
}

__n128 anonymous namespace'::PrimitiveProvider<ExtrudedTextDescriptorParameters,re::GeomBuildExtrudedTextOptions>::resolveChild@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v6;
  uint64_t v4 = v7;
  uint64_t v5 = v8;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v4;
  *(void *)(a2 + 32) = v5;
  return result;
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<ExtrudedTextDescriptorParameters,re::GeomBuildExtrudedTextOptions>::getDescription(_anonymous_namespace_ *a1, re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  __n128 v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v20, 0);
  *((void *)&v24 + 1) = 0;
  long long v25 = 0uLL;
  re::DynamicString::setCapacity(&v24, 0);
  __asm { FMOV            V0.2S, #1.0 }
  uint64_t v26 = _D0;
  char v27 = 5;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  char v30 = 0;
  __int16 v31 = 4;
  int v32 = 16843009;
  char v33 = 0;
  if (re::AssetLoadDescriptor::getIntrospectableData<ExtrudedTextDescriptorParameters>(a2, &v20))
  {
    if (v34) {
      uint64_t v12 = " split";
    }
    else {
      uint64_t v12 = "";
    }
    if (v35) {
      uint64_t v13 = "";
    }
    else {
      uint64_t v13 = " full";
    }
    re::DynamicString::format((re::DynamicString *)"%s%s", (re::DynamicString *)&v18, v12, v13);
    (*(void (**)(uint64_t *__return_ptr, _anonymous_namespace_ *, re::DynamicString **))(*(void *)a1 + 120))(&v15, a1, &v20);
    re::DynamicString::operator+((re::DynamicString *)&v15, (uint64_t)&v18, (re::DynamicString *)v17);
    re::DynamicString::operator=(a3, (re::DynamicString *)v17);
    if (*(void *)&v17[0])
    {
      if (BYTE8(v17[0])) {
        (*(void (**)(void))(**(void **)&v17[0] + 40))();
      }
      memset(v17, 0, sizeof(v17));
    }
    if (v15 && (v16 & 1) != 0) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    if (v18 && (v19 & 1) != 0) {
      (*(void (**)(void))(*(void *)v18 + 40))();
    }
  }
  else
  {
    __int16 v18 = "<mangled>";
    uint64_t v19 = 9;
    re::DynamicString::operator=(a3, (uint64_t)&v18);
  }
  if ((void)v24)
  {
    if (BYTE8(v24)) {
      (*(void (**)(void))(*(void *)v24 + 40))();
    }
    long long v24 = 0u;
    long long v25 = 0u;
  }
  __n128 result = v20;
  if (v20)
  {
    if (v21) {
      return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v20 + 40))();
    }
  }
  return result;
}

uint64_t ExtrudedText::describe@<X0>(const re::GeomBuildExtrudedTextOptions *a1@<X1>, re::DynamicString *a2@<X8>)
{
  unint64_t v3 = *((char *)a1 + 96);
  if (v3 > 5) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = off_264BE24F0[v3];
  }
  unint64_t v5 = *((char *)a1 + 97);
  if (v5 > 4) {
    __n128 v6 = 0;
  }
  else {
    __n128 v6 = off_264BE2520[v5];
  }
  unint64_t v7 = *((char *)a1 + 98);
  if (v7 > 2) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = off_264BE2548[v7];
  }
  if (*((void *)a1 + 5)) {
    char v9 = (char *)*((void *)a1 + 6);
  }
  else {
    char v9 = (char *)a1 + 41;
  }
  uint64_t v10 = "";
  if (*((unsigned char *)a1 + 99)) {
    uint64_t v11 = "";
  }
  else {
    uint64_t v11 = " noSides";
  }
  if (*((unsigned char *)a1 + 100)) {
    uint64_t v12 = "";
  }
  else {
    uint64_t v12 = " noBack";
  }
  uint64_t v13 = " noUV";
  if (*((unsigned char *)a1 + 101)) {
    uint64_t v13 = "";
  }
  if (*((unsigned char *)a1 + 102)) {
    __int16 v14 = "";
  }
  else {
    __int16 v14 = " noNorm";
  }
  if (*((void *)a1 + 1)) {
    uint64_t v15 = (char *)*((void *)a1 + 2);
  }
  else {
    uint64_t v15 = (char *)a1 + 9;
  }
  if (*((unsigned char *)a1 + 103)) {
    uint64_t v10 = "instanceGlyphs";
  }
  return re::DynamicString::format((re::DynamicString *)"%s;%fx%f/%d;(%f,%f)x(%f,%f);%s;%s;%s;%s%s%s%s;%s;%s",
           a2,
           v9,
           *((float *)a1 + 16),
           *((float *)a1 + 17),
           *((unsigned __int8 *)a1 + 72),
           *((float *)a1 + 20),
           *((float *)a1 + 21),
           *((float *)a1 + 22),
           *((float *)a1 + 23),
           v4,
           v6,
           v8,
           v11,
           v12,
           v13,
           v14,
           v15,
           v10);
}

re::DynamicString *anonymous namespace'::PrimitiveProvider<ExtrudedTextDescriptorParameters,re::GeomBuildExtrudedTextOptions>::load@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8)) {
    uint64_t v8 = *(const char **)(a2 + 16);
  }
  else {
    uint64_t v8 = (const char *)(a2 + 9);
  }
  char v9 = (const char *)(*(uint64_t (**)(void *))(*a1 + 32))(a1);
  uint64_t v10 = (_anonymous_namespace_ *)strcmp(v8, v9);
  if (v10)
  {
    uint64_t v11 = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
    if (*(unsigned char *)(a2 + 8)) {
      uint64_t v12 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v12 = a2 + 9;
    }
    __n128 result = (re::DynamicString *)re::DynamicString::format((re::DynamicString *)"Expected scheme '%s', got '%s'", (re::DynamicString *)&v79, v11, v12);
    long long v25 = v79;
    long long v26 = v80;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v25;
    *(_OWORD *)(a4 + 24) = v26;
    return result;
  }
  uint64_t v64 = 0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  uint64_t v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v63, 0);
  *((void *)&v67 + 1) = 0;
  long long v68 = 0uLL;
  re::DynamicString::setCapacity(&v67, 0);
  __asm { FMOV            V0.2S, #1.0 }
  uint64_t v69 = _D0;
  char v70 = 5;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  char v73 = 0;
  __int16 v74 = 4;
  int v75 = 16843009;
  char v76 = 0;
  uint64_t Introspectable = re::AssetLoadDescriptor::getIntrospectableData<ExtrudedTextDescriptorParameters>((re::AssetLoadDescriptor *)a2, &v63);
  if (Introspectable)
  {
    char v62 = 0;
    v59[1] = 0;
    uint64_t v60 = 0;
    uint64_t v58 = 0;
    v59[0] = 0;
    int v61 = 0;
    v55[1] = 0;
    uint64_t v56 = 0;
    v55[0] = 0;
    int v57 = 0;
    if (v77)
    {
      re::buildExtrudedText((_anonymous_namespace_ *)v59, (uint64_t)&v63, 0);
      uint64_t v20 = v60;
      re::DynamicArray<float>::resize((uint64_t)v55, v60);
      if (v20)
      {
        uint64_t v21 = 0;
        uint64_t v22 = v56;
        uint64_t v23 = v58;
        while (v22 != v21)
        {
          *(_DWORD *)(v23 + 4 * v21) = v21;
          if (v20 == ++v21) {
            goto LABEL_20;
          }
        }
        *(void *)&long long v50 = 0;
        long long v82 = 0u;
        long long v83 = 0u;
        long long v80 = 0u;
        long long v81 = 0u;
        long long v79 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v84 = 136315906;
        long long v85 = "operator[]";
        uint64_t v86 = 0x800000003150400;
        *(void *)long long v87 = v22;
        *(_WORD *)&v87[8] = 2048;
        *(void *)&v87[10] = v22;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_41:
        *(void *)&long long v50 = 0;
        long long v82 = 0u;
        long long v83 = 0u;
        long long v80 = 0u;
        long long v81 = 0u;
        long long v79 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v84 = 136315906;
        long long v85 = "operator[]";
        uint64_t v86 = 0x800000003150400;
        *(void *)long long v87 = 0;
        *(_WORD *)&v87[8] = 2048;
        *(void *)&v87[10] = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
    }
    else
    {
      re::DynamicArray<re::GeomMesh>::resize((uint64_t)v59, 1uLL);
      LODWORD(v79) = 0;
      re::DynamicArray<unsigned int>::resize(v55, 1uLL, &v79);
      if (!v60) {
        goto LABEL_41;
      }
      re::buildExtrudedText(v62, (re::GeomMesh *)&v63, 0, v29);
    }
LABEL_20:
    int v84 = 16842752;
    LOBYTE(v85) = 1;
    *(_DWORD *)((char *)&v85 + 1) = 0;
    BYTE5(v85) = 0;
    v87[0] = 0;
    long long v89 = 0u;
    *(_OWORD *)&v87[4] = 0u;
    long long v88 = 0u;
    DWORD1(v89) = 0x7FFFFFFF;
    BYTE6(v85) = v78;
    uint64_t v86 = 0x10101003F800000;
    MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray(v62, v60, v58, v56, 0, &v84, (uint64_t)&v79);
    int v31 = v79;
    int v32 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
    char v33 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v32[2] + 32))(v32[2], 960, 8);
    char v34 = v33;
    if (v31) {
      char v35 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v33, (uint64_t)&v79 + 8);
    }
    else {
      re::MeshAsset::MeshAsset(v33);
    }
    uint64_t v36 = a1[3];
    long long v37 = re::MeshAsset::assetType(v35);
    uint64_t v38 = (re::MeshAsset *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(v36, (unint64_t)v37);
    uint64_t v39 = re::MeshAsset::assetType(v38);
    re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v54, 2056, a3, (const char *)*v39);
    if ((*(uint64_t (**)(re::MeshAsset *, re::MeshAsset *, void, void))(*(void *)v38 + 24))(v38, v34, 0, 0))
    {
      re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v54);
      if (*(unsigned char *)(a2 + 120)) {
        uint64_t v41 = *(const char **)(a2 + 128);
      }
      else {
        uint64_t v41 = (const char *)(a2 + 121);
      }
      *(void *)&long long v53 = v34;
      BYTE8(v53) = 0;
      long long v46 = v50;
      uint64_t v47 = v51;
      uint64_t v48 = v52;
      *(unsigned char *)(a4 + 56) = 0;
      *(_OWORD *)(a4 + 40) = v53;
      *(unsigned char *)a4 = 1;
      *(_OWORD *)(a4 + 8) = v46;
      *(void *)(a4 + 24) = v47;
      *(void *)(a4 + 32) = v48;
    }
    else
    {
      uint64_t v42 = re::internal::destroyPersistent<re::MeshAsset>((re *)"load", 119, (void (***)(void))v34);
      long long v43 = v50;
      uint64_t v44 = v51;
      uint64_t v45 = v52;
      *(unsigned char *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v43;
      *(void *)(a4 + 24) = v44;
      *(void *)(a4 + 32) = v45;
      re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v54);
    }
    re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v79);
    double v49 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v87[4]);
    if (v55[0] && v58) {
      (*(void (**)(double))(*(void *)v55[0] + 40))(v49);
    }
    re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v59);
  }
  else
  {
    long long v27 = v79;
    long long v28 = v80;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v27;
    *(_OWORD *)(a4 + 24) = v28;
  }
  if ((void)v67)
  {
    if (BYTE8(v67)) {
      (*(void (**)(void))(*(void *)v67 + 40))();
    }
    long long v67 = 0u;
    long long v68 = 0u;
  }
  __n128 result = v63;
  if (v63 && (v64 & 1) != 0) {
    return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v63 + 40))();
  }
  return result;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<ExtrudedTextDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76438, memory_order_acquire) & 1) == 0)
  {
    unint64_t v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF76438);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF76430 = re::internal::getOrCreateInfo((re::internal *)"ExtrudedTextDescriptorParameters", (uint64_t (*)(re::internal *))allocInfo_ExtrudedTextDescriptorParameters, (re::IntrospectionBase *(*)(void))initInfo_ExtrudedTextDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76388, 0);
      __cxa_guard_release(&qword_26AF76438);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  unint64_t v3 = (re **)qword_26AF76430;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void *re::allocInfo_RealityFileAssetLoadDescriptorParameters(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_55, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_55))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76A90, "RealityFileAssetLoadDescriptorParameters");
    __cxa_guard_release(&_MergedGlobals_55);
  }
  return &unk_26AF76A90;
}

void re::initInfo_RealityFileAssetLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  v13[0] = 0xB2FC42FECB8E66C6;
  v13[1] = "RealityFileAssetLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76A78, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF76A78);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_RealityFileDescriptor((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "realityFileDescriptor";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF76A80 = v7;
      int v8 = re::introspectionAllocator((re *)v7);
      uint64_t v10 = re::IntrospectionInfo<re::DynamicString>::get(1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "archiveEntrySpecifier";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0x4800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF76A88 = v11;
      __cxa_guard_release(&qword_26AF76A78);
    }
  }
  *((void *)this + 2) = 0x7800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF76A80;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RealityFileAssetLoadDescriptorParameters>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RealityFileAssetLoadDescriptorParameters>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RealityFileAssetLoadDescriptorParameters>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RealityFileAssetLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  long long v12 = v14;
}

void *re::internal::defaultConstruct<re::RealityFileAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 8) = 0u;
  uint64_t v4 = (void *)(a3 + 8);
  unint64_t v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v4, 0);
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  uint64_t v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)(v3 + 40), 0);
  *(_OWORD *)(v3 + 72) = 0u;
  v3 += 72;
  *(_OWORD *)(v3 + 16) = 0u;
  __n128 result = re::DynamicString::setCapacity((void *)v3, 0);
  *(unsigned char *)(v3 + 32) = 0;
  *(void *)(v3 + 40) = 1;
  return result;
}

double re::internal::defaultDestruct<re::RealityFileAssetLoadDescriptorParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicString::deinit((re::DynamicString *)(a3 + 72));
  re::DynamicString::deinit((re::DynamicString *)(a3 + 40));
  return re::DynamicString::deinit((re::DynamicString *)(a3 + 8));
}

void *re::internal::defaultConstructV2<re::RealityFileAssetLoadDescriptorParameters>(uint64_t a1)
{
  uint64_t v1 = a1;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v2, 0);
  *(_OWORD *)(v1 + 56) = 0u;
  *(_OWORD *)(v1 + 40) = 0u;
  uint64_t v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)(v1 + 40), 0);
  *(_OWORD *)(v1 + 72) = 0u;
  v1 += 72;
  *(_OWORD *)(v1 + 16) = 0u;
  __n128 result = re::DynamicString::setCapacity((void *)v1, 0);
  *(unsigned char *)(v1 + 32) = 0;
  *(void *)(v1 + 40) = 1;
  return result;
}

double re::internal::defaultDestructV2<re::RealityFileAssetLoadDescriptorParameters>(uint64_t a1)
{
  re::DynamicString::deinit((re::DynamicString *)(a1 + 72));
  re::DynamicString::deinit((re::DynamicString *)(a1 + 40));
  return re::DynamicString::deinit((re::DynamicString *)(a1 + 8));
}

uint64_t re::introspect_RealityFileAssetLoadDescriptorParameters(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RealityFileAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_RealityFileAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_RealityFileAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RealityFileAssetLoadDescriptorParameters>, this);
}

uint64_t re::RealityFileAssetLoadDescriptorFactory::make@<X0>(char *a1@<X0>, re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  uint64_t v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a3, 0);
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  *(void *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_DWORD *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(void *)(a3 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a3 + 112), 0);
  uint64_t v13 = "RealityFileAsset";
  uint64_t v14 = 16;
  re::DynamicString::operator=((re::DynamicString *)a3, (uint64_t)&v13);
  re::DynamicString::operator=((re::DynamicString *)(a3 + 112), a2);
  LOBYTE(v8) = *a1;
  re::DynamicString::DynamicString((re::DynamicString *)v9, (const re::DynamicString *)(a1 + 8));
  re::DynamicString::DynamicString((re::DynamicString *)v10, (const re::DynamicString *)(a1 + 40));
  re::DynamicString::DynamicString((re::DynamicString *)v11, (const re::DynamicString *)(a1 + 72));
  long long v12 = *(_OWORD *)(a1 + 104);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a3, (const re::IntrospectionBase *)re::RealityFileAssetProvider::s_loadDescriptorParametersIntrospect, &v8, 0);
  if (v11[0])
  {
    if (v11[1]) {
      (*(void (**)(void))(*(void *)v11[0] + 40))();
    }
    memset(v11, 0, sizeof(v11));
  }
  if (v10[0])
  {
    if (v10[1]) {
      (*(void (**)(void))(*(void *)v10[0] + 40))();
    }
    memset(v10, 0, sizeof(v10));
  }
  if (v9[0])
  {
    if (v9[1]) {
      (*(void (**)(void))(*(void *)v9[0] + 40))();
    }
    memset(v9, 0, sizeof(v9));
  }
  if (*(void *)(a3 + 80) <= 8uLL) {
    re::DynamicArray<BOOL>::setCapacity((void *)(a3 + 72), 9uLL);
  }
  uint64_t v13 = (const char *)&unk_26E7147E8;
  uint64_t v14 = a3 + 72;
  off_26E7147F8((re::DynamicArrayStreamWriter *)&v13, a1 + 104, 1uLL);
  return (*((uint64_t (**)(const char **, char *, uint64_t))v13 + 2))(&v13, a1 + 112, 8);
}

uint64_t re::RealityFileAssetProvider::RealityFileAssetProvider(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)a1 = &unk_26E6CB708;
  uint64_t v13 = re::globalAllocators(v12);
  *(void *)(a1 + 48) = v13[2];
  *(void *)(a1 + 56) = 0;
  uint64_t v14 = re::globalAllocators((re *)v13);
  *(void *)(a1 + 88) = v14[2];
  *(void *)(a1 + 96) = 0;
  uint64_t v15 = re::globalAllocators((re *)v14);
  *(void *)(a1 + 128) = v15[2];
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  char v16 = (re *)re::DynamicString::setCapacity((void *)(a1 + 144), 0);
  *(void *)a1 = &unk_26E6CCE88;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(void *)(a1 + 268) = 0x7FFFFFFFLL;
  int v17 = &qword_268772000;
  {
    int v17 = &qword_268772000;
    if (v16)
    {
      re::introspect<re::RealityFileAssetLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"RealityFileAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_RealityFileAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_RealityFileAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RealityFileAssetLoadDescriptorParameters>, 0);
      int v17 = &qword_268772000;
    }
  }
  re::RealityFileAssetProvider::s_loadDescriptorParametersIntrospect = v17[464];
  *(void *)(a1 + 192) = a2;
  *(void *)(a1 + 200) = a3;
  *(void *)(a1 + 208) = a4;
  *(void *)(a1 + 216) = a5;
  *(void *)(a1 + 224) = a6;
  __int16 v18 = re::globalAllocators(v16);
  uint64_t v19 = v18[2];
  v32[0] = &unk_26E6CCF28;
  v32[1] = a1;
  uint64_t v33 = v19;
  char v34 = v32;
  uint64_t v20 = re::globalAllocators((re *)v18)[2];
  v29[0] = &unk_26E6CCF90;
  v29[1] = a1;
  uint64_t v30 = v20;
  int v31 = v29;
  uint64_t v27 = v33;
  uint64_t v28 = 0;
  re::FunctionBase<24ul,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::operator=<24ul>((uint64_t)v26, (uint64_t)v32);
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  v22[3] = v30;
  v22[4] = 0;
  re::FunctionBase<24ul,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::operator=<24ul>((uint64_t)v22, (uint64_t)v29);
  re::RawAssetProvider::init(a1, "RealityFileAsset", a3, (uint64_t)v26, (uint64_t)v23, (uint64_t)v22);
  re::FunctionBase<24ul,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::destroyCallable((uint64_t)v22);
  re::FunctionBase<24ul,__CFError * ()(re::AssetLoadDescriptor const*,unsigned long long,re::internal::AssetReference *)>::destroyCallable((uint64_t)v23);
  re::FunctionBase<24ul,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::destroyCallable((uint64_t)v26);
  re::FunctionBase<24ul,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::destroyCallable((uint64_t)v29);
  re::FunctionBase<24ul,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::destroyCallable((uint64_t)v32);
  return a1;
}

uint64_t re::RawAssetProvider::init(uint64_t a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = (re::DynamicString *)(a1 + 144);
  v13[0] = __s;
  v13[1] = strlen(__s);
  re::DynamicString::operator=(v11, (uint64_t)v13);
  *(void *)(a1 + 184) = a3;
  re::FunctionBase<24ul,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::operator=<24ul>(a1 + 24, a4);
  re::FunctionBase<24ul,__CFError * ()(re::AssetLoadDescriptor const*,unsigned long long,re::internal::AssetReference *)>::operator=<24ul>(a1 + 64, a5);
  return re::FunctionBase<24ul,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::operator=<24ul>(a1 + 104, a6);
}

void re::RealityFileAssetProvider::~RealityFileAssetProvider(re::RealityFileAssetProvider *this)
{
  *(void *)this = &unk_26E6CCE88;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 29);
  *(void *)this = &unk_26E6CB708;
  re::DynamicString::deinit((re::RealityFileAssetProvider *)((char *)this + 144));
  re::FunctionBase<24ul,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::destroyCallable((uint64_t)this + 104);
  re::FunctionBase<24ul,__CFError * ()(re::AssetLoadDescriptor const*,unsigned long long,re::internal::AssetReference *)>::destroyCallable((uint64_t)this + 64);
  re::FunctionBase<24ul,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::destroyCallable((uint64_t)this + 24);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::RealityFileAssetProvider::~RealityFileAssetProvider(this);
  JUMPOUT(0x237DBCBD0);
}

id anonymous namespace'::makeError(_anonymous_namespace_ *this, const __CFString *a2, uint64_t a3, const char *a4)
{
  re::WrappedError::make((re::WrappedError *)@"RERealityFileErrorDomain", 0, (uint64_t)this, &v6);
  id v4 = v6;

  return v4;
}

unsigned char *anonymous namespace'::readRealityFileAssetLoadDescriptorParametersCFError(_anonymous_namespace_ *this, const re::AssetLoadDescriptor *a2)
{
  if (v30[0])
  {
    re::types::Ok<re::RealityFileAssetLoadDescriptorParameters>::Ok((uint64_t)v17, (uint64_t)v31);
    *(unsigned char *)this = 1;
    *((unsigned char *)this + 8) = v17[0];
    *((void *)this + 2) = v18;
    uint64_t v6 = v20;
    uint64_t v7 = v21;
    *(_OWORD *)((char *)this + 24) = v19;
    uint64_t v20 = 0;
    uint64_t v18 = 0;
    long long v19 = 0uLL;
    *((void *)this + 5) = v6;
    *((void *)this + 6) = v7;
    uint64_t v8 = v23;
    *((void *)this + 7) = v22;
    *((void *)this + 8) = v8;
    uint64_t v9 = v24;
    uint64_t v10 = v25;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    *((void *)this + 9) = v9;
    *((void *)this + 10) = v10;
    uint64_t v11 = v28;
    uint64_t v13 = v26;
    uint64_t v12 = v27;
    uint64_t v25 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    *((void *)this + 12) = v12;
    *((void *)this + 13) = v11;
    *((void *)this + 11) = v13;
    *((_OWORD *)this + 7) = v29;
  }
  else
  {
    if (v31[8]) {
      uint64_t v14 = *(_anonymous_namespace_ **)&v32[7];
    }
    else {
      uint64_t v14 = (_anonymous_namespace_ *)v32;
    }
    *(unsigned char *)this = 0;
    *((void *)this + 1) = Error;
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(v30);
}

__n128 anonymous namespace'::getAssetDescriptor(uint64_t a1, re::RealityFile *this, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 80)) {
    uint64_t v6 = *(char **)(a3 + 88);
  }
  else {
    uint64_t v6 = (char *)(a3 + 81);
  }
  uint64_t AssetDescriptorWithEntryName = re::RealityFile::findAssetDescriptorWithEntryName(this, v6);
  if (AssetDescriptorWithEntryName)
  {
    *(unsigned char *)a1 = 1;
    *(void *)(a1 + 8) = AssetDescriptorWithEntryName;
  }
  else
  {
    if (*(unsigned char *)(a3 + 80)) {
      uint64_t v9 = *(void *)(a3 + 88);
    }
    else {
      uint64_t v9 = a3 + 81;
    }
    re::DynamicString::format((re::DynamicString *)"Failed to find an asset with archive entry name %s in the reality file.", (re::DynamicString *)&v12, v9);
    __n128 result = v12;
    uint64_t v10 = v13;
    uint64_t v11 = v14;
    *(unsigned char *)a1 = 0;
    *(__n128 *)(a1 + 8) = result;
    *(void *)(a1 + 24) = v10;
    *(void *)(a1 + 32) = v11;
  }
  return result;
}

uint64_t *re::RealityFileAssetProvider::load@<X0>(re::RealityFileAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X2>, uint64_t a5@<X8>)
{
  uint64_t v93 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)a2 + 8)) {
    uint64_t v11 = (const char *)*((void *)a2 + 2);
  }
  else {
    uint64_t v11 = (char *)a2 + 9;
  }
  __n128 v12 = (_anonymous_namespace_ *)strcmp(v11, "RealityFileAsset");
  if (v12)
  {
    long long v14 = *(_OWORD *)v90;
    uint64_t v15 = *(void *)&v90[16];
    uint64_t v16 = v91;
    *(unsigned char *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v14;
    *(void *)(a5 + 24) = v15;
    *(void *)(a5 + 32) = v16;
    return result;
  }
  if (!v64[0])
  {
    re::DynamicString::DynamicString((re::DynamicString *)v90, (const re::DynamicString *)v65);
    *(unsigned char *)a5 = 0;
    uint64_t v20 = v91;
    *(void *)(a5 + 8) = *(void *)v90;
    *(void *)(a5 + 32) = v20;
    *(_OWORD *)(a5 + 16) = *(_OWORD *)&v90[8];
    return (uint64_t *)re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(v64);
  }
  re::RealityFileRegistry::getOrMountRealityFile((re::RealityFileDescriptor *)v65, *((dispatch_queue_t **)this + 24), *((os_unfair_lock_s **)this + 27), *((os_unfair_lock_s **)this + 28), (uint64_t)v84);
  if (!v84[0])
  {
    uint64_t v21 = (_anonymous_namespace_ *)re::WrappedError::localizedDescription((id *)&v85);
    long long v22 = *(_OWORD *)v90;
    uint64_t v23 = *(void *)&v90[16];
    uint64_t v24 = v91;
    *(unsigned char *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v22;
    *(void *)(a5 + 24) = v23;
    *(void *)(a5 + 32) = v24;
    goto LABEL_59;
  }
  int v17 = v85;
  if (v85) {
    uint64_t v18 = v85 + 8;
  }
  if (*((unsigned char *)a2 + 120)) {
    long long v19 = (char *)*((void *)a2 + 16);
  }
  else {
    long long v19 = (char *)a2 + 121;
  }
  unint64_t v25 = re::internal::AssetTypeRegistry::assetTypeWithName(*((re::internal::AssetTypeRegistry **)this + 25), v19);
  uint64_t v26 = (const char **)v25;
  if (!*((void *)this + 29)) {
    goto LABEL_17;
  }
  unint64_t v27 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) >> 27));
  uint64_t v28 = *(unsigned int *)(*((void *)this + 30) + 4 * ((v27 ^ (v27 >> 31)) % *((unsigned int *)this + 64)));
  if (v28 == 0x7FFFFFFF) {
    goto LABEL_17;
  }
  uint64_t v30 = *((void *)this + 31);
  if (*(void *)(v30 + 32 * v28 + 16) != v25)
  {
    while (1)
    {
      uint64_t v28 = *(_DWORD *)(v30 + 32 * v28 + 8) & 0x7FFFFFFF;
      if (v28 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v30 + 32 * v28 + 16) == v25) {
        goto LABEL_21;
      }
    }
LABEL_17:
    long long v29 = 0;
    goto LABEL_22;
  }
LABEL_21:
  long long v29 = (void *)(v30 + 32 * v28 + 24);
LABEL_22:
  if (!v81[0])
  {
    if (v29)
    {
      (*(void (**)(void, char *, unsigned char *, uint64_t, uint64_t *, __n128))(*(void *)*v29 + 32))(*v29, v17, v65, a4, &v82, AssetDescriptor);
      if (v81[0]) {
        goto LABEL_57;
      }
    }
    else
    {
      re::DynamicString::DynamicString((re::DynamicString *)v90, (const re::DynamicString *)&v82);
      *(unsigned char *)a5 = 0;
      uint64_t v49 = v91;
      *(void *)(a5 + 8) = *(void *)v90;
      *(void *)(a5 + 32) = v49;
      *(_OWORD *)(a5 + 16) = *(_OWORD *)&v90[8];
    }
    if (v82 && (v83 & 1) != 0)
    {
      (*(void (**)(void))(*(void *)v82 + 40))();
      if (!v17) {
        goto LABEL_59;
      }
      goto LABEL_58;
    }
LABEL_57:
    if (v17) {
LABEL_58:
    }

LABEL_59:
    re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v84);
    return (uint64_t *)re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(v64);
  }
  unint64_t v34 = *((void *)a2 + 15);
  unint64_t v35 = v34 >> 1;
  if ((v34 & 1) == 0) {
    unint64_t v35 = v34 >> 1;
  }
  if (!v35)
  {
LABEL_56:
    long long v51 = *(_OWORD *)v90;
    uint64_t v52 = *(void *)&v90[16];
    uint64_t v53 = v91;
    *(unsigned char *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v51;
    *(void *)(a5 + 24) = v52;
    *(void *)(a5 + 32) = v53;
    goto LABEL_57;
  }
  if (!v26)
  {
    if (v34) {
      uint64_t v48 = (char *)*((void *)a2 + 16);
    }
    else {
      uint64_t v48 = (char *)a2 + 121;
    }
    re::DynamicString::format((re::DynamicString *)"Could not find an AssetType registered with name '%s'.", (re::DynamicString *)v90, v48);
    goto LABEL_56;
  }
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x804, a4, *v26, v32);
  uint64_t v36 = v82;
  re::RealityFile::getInputStream((re::RealityFile *)v17, v82, (uint64_t)v90);
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x805, a4, *v26, v37);
  uint64_t v38 = (*(uint64_t (**)(uint64_t))(*(void *)v36 + 40))(v36);
  if (!v90[0])
  {
    long long v50 = (_anonymous_namespace_ *)re::WrappedError::localizedDescription((id *)&v90[8]);
    if (v29)
    {
      (*(void (**)(void, char *, unsigned char *, uint64_t, long long *))(*(void *)*v29 + 32))(*v29, v17, v65, a4, &v66);
    }
    else
    {
      re::DynamicString::DynamicString((re::DynamicString *)v77, (const re::DynamicString *)&v66);
      *(unsigned char *)a5 = 0;
      uint64_t v58 = *((void *)&v77[1] + 1);
      *(void *)(a5 + 8) = *(void *)&v77[0];
      *(void *)(a5 + 32) = v58;
      *(_OWORD *)(a5 + 16) = *(_OWORD *)((char *)v77 + 8);
    }
    if (void)v66 && (BYTE8(v66)) {
      (*(void (**)(void))(*(void *)v66 + 40))();
    }
LABEL_67:
    re::Result<re::RealityFileEntryStream,re::WrappedError>::~Result((uint64_t)v90);
    if (!v17) {
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  uint64_t v62 = v38;
  if (v92 < 2)
  {
    uint64_t v63 = (*(uint64_t (**)(unsigned char *))(*(void *)&v90[8] + 64))(&v90[8]);
    uint64_t v39 = *((void *)this + 25);
    v80[1] = 0;
    v80[2] = 0;
    v80[0] = v39;
    int v78 = 0;
    memset(v77, 0, sizeof(v77));
    uint64_t v79 = 0x7FFFFFFFLL;
    if (v29) {
      (*(void (**)(void, unsigned char *, _OWORD *))(*(void *)*v29 + 40))(*v29, v65, v77);
    }
    v76[0] = &unk_26E6CA6E8;
    v76[1] = a3;
    if (v92 < 2)
    {
      if (HIDWORD(v77[1])) {
        long long v40 = v77;
      }
      else {
        long long v40 = 0;
      }
      v70[0] = 1;
      uint64_t v71 = a4;
      re::AssetUtilities::loadCompiledAssetFromStream((re *)&v90[8], v80, v26, (uint64_t)v76, 0, (uint64_t)v40, (uint64_t)v70, (uint64_t)v72);
      if (v72[0])
      {
        uint64_t v41 = (const re::AssetLoadDescriptor *)((char *)a2 + 112);
        uint64_t v42 = v73;
        if (v29)
        {
          long long v43 = (re *)(*(void *(**)(long long *__return_ptr))(*(void *)*v29 + 48))(&v66);
          if (!(_BYTE)v66)
          {
            uint64_t v44 = *re::assetsLogObjects(v43);
            if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            {
              if (v67) {
                char v59 = v68;
              }
              else {
                char v59 = (char *)&v67 + 1;
              }
              *(_DWORD *)long long buf = 136315394;
              uint64_t v87 = v62;
              __int16 v88 = 2080;
              long long v89 = v59;
              _os_log_error_impl(&dword_233120000, v44, OS_LOG_TYPE_ERROR, "Post reality file load processing failed asset path '%s': %s", buf, 0x16u);
            }
            if (!(_BYTE)v66 && *((void *)&v66 + 1) && (v67 & 1) != 0) {
              (*(void (**)(void))(**((void **)&v66 + 1) + 40))();
            }
          }
        }
        re::DynamicString::DynamicString((re::DynamicString *)&v66, v41);
        *(void *)&long long v69 = v42;
        *((void *)&v69 + 1) = v63;
        long long v45 = v66;
        uint64_t v46 = v67;
        uint64_t v47 = v68;
        *(unsigned char *)a5 = 1;
        *(_OWORD *)(a5 + 8) = v45;
        *(void *)(a5 + 24) = v46;
        *(void *)(a5 + 32) = v47;
        *(unsigned char *)(a5 + 56) = 1;
        *(_OWORD *)(a5 + 40) = v69;
      }
      else
      {
        if (v74) {
          char v54 = *(unsigned char **)&v75[7];
        }
        else {
          char v54 = v75;
        }
        re::DynamicString::format((re::DynamicString *)"Failed to load compiled data for asset path '%s', due to error: %s.", (re::DynamicString *)&v66, v62, v54);
        long long v55 = v66;
        uint64_t v56 = v67;
        int v57 = v68;
        *(unsigned char *)a5 = 0;
        *(_OWORD *)(a5 + 8) = v55;
        *(void *)(a5 + 24) = v56;
        *(void *)(a5 + 32) = v57;
      }
      if (!v72[0] && v73 && (v74 & 1) != 0) {
        (*(void (**)(void))(*(void *)v73 + 40))();
      }
      re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v77);
      goto LABEL_67;
    }
  }
  uint64_t v60 = (_anonymous_namespace_ *)std::__throw_bad_variant_access[abi:nn180100]();
}

uint64_t *anonymous namespace'::readRealityFileAssetLoadDescriptorParameters(_anonymous_namespace_ *this, const re::AssetLoadDescriptor *a2)
{
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v33, 0);
  *((void *)&v37 + 1) = 0;
  long long v38 = 0uLL;
  unint64_t v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v37, 0);
  *((void *)&v39 + 1) = 0;
  long long v40 = 0uLL;
  re::DynamicString::setCapacity(&v39, 0);
  v41[0] = 0;
  uint64_t v42 = 1;
  uint64_t v6 = re::AssetLoadDescriptor::getIntrospectableData<re::RealityFileAssetLoadDescriptorParameters>(a2, &v32, 0);
  if (v6)
  {
    unint64_t v7 = *((void *)a2 + 11);
    if (v7)
    {
      uint64_t v8 = *((void *)a2 + 13);
      *(void *)&long long v20 = &unk_26E7150B0;
      *((void *)&v20 + 1) = v8;
      long long v21 = v7;
      off_26E7150C0((re::MemoryStreamReader *)&v20, v41, 1uLL);
      (*(void (**)(long long *, uint64_t *, uint64_t))(v20 + 16))(&v20, &v42, 8);
    }
    else
    {
      v41[0] = 0;
      uint64_t v42 = 1;
    }
    re::types::Ok<re::RealityFileAssetLoadDescriptorParameters>::Ok((uint64_t)&v20, (uint64_t)&v32);
    *(unsigned char *)this = 1;
    *((unsigned char *)this + 8) = v20;
    *((void *)this + 2) = *((void *)&v20 + 1);
    uint64_t v11 = v22;
    uint64_t v12 = v23;
    *(_OWORD *)((char *)this + 24) = v21;
    uint64_t v22 = 0;
    *((void *)&v20 + 1) = 0;
    long long v21 = 0uLL;
    *((void *)this + 5) = v11;
    *((void *)this + 6) = v12;
    uint64_t v13 = v25;
    *((void *)this + 7) = v24;
    *((void *)this + 8) = v13;
    uint64_t v14 = v26;
    uint64_t v15 = v27;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    *((void *)this + 9) = v14;
    *((void *)this + 10) = v15;
    uint64_t v16 = v30;
    uint64_t v18 = v28;
    uint64_t v17 = v29;
    uint64_t v27 = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    *((void *)this + 12) = v17;
    *((void *)this + 13) = v16;
    *((void *)this + 11) = v18;
    *((_OWORD *)this + 7) = v31;
  }
  else
  {
    long long v9 = v20;
    long long v10 = v21;
    *(unsigned char *)this = 0;
    *(_OWORD *)((char *)this + 8) = v9;
    *(_OWORD *)((char *)this + 24) = v10;
  }
  if ((void)v39)
  {
    if (BYTE8(v39)) {
      (*(void (**)(void))(*(void *)v39 + 40))();
    }
    long long v39 = 0u;
    long long v40 = 0u;
  }
  if ((void)v37)
  {
    if (BYTE8(v37)) {
      (*(void (**)(void))(*(void *)v37 + 40))();
    }
    long long v37 = 0u;
    long long v38 = 0u;
  }
  __n128 result = v33;
  if (v33)
  {
    if (v34) {
      return (uint64_t *)(*(uint64_t (**)(void))(*v33 + 40))();
    }
  }
  return result;
}

unsigned char *re::RealityFileAssetProvider::transformDescriptor@<X0>(uint64_t a1@<X1>, const re::SourceLoadDescriptorTransform *a2@<X2>, uint64_t a3@<X8>)
{
  (*(void (**)(const re::SourceLoadDescriptorTransform *))(*(void *)a2 + 32))(a2);
  if (v66[0])
  {
    re::RealityFileDescriptor::transform((re::RealityFileDescriptor *)v67, a2, (uint64_t)v62);
    if (v62[0])
    {
      v28[0] = v62[8];
      re::DynamicString::DynamicString((re::DynamicString *)&v29, (const re::DynamicString *)&v63);
      re::DynamicString::DynamicString((re::DynamicString *)v31, (const re::DynamicString *)v65);
      re::DynamicString::DynamicString((re::DynamicString *)v32, (const re::DynamicString *)&v68);
      char v33 = 0;
      uint64_t v34 = 1;
      re::RealityFileAssetLoadDescriptorFactory::make(v28, (re::DynamicString *)(a1 + 112), (uint64_t)&v18);
      v35[0] = 1;
      uint64_t v6 = v18;
      uint64_t v7 = v19;
      uint64_t v18 = 0;
      uint64_t v8 = *((void *)&v19 + 1);
      long long v9 = v20;
      long long v19 = 0u;
      long long v20 = 0u;
      ++v22;
      ++v25;
      long long v10 = v27;
      uint64_t v11 = *(void *)&v26[16];
      long long v27 = 0u;
      LOBYTE(v50) = 1;
      uint64_t v52 = v8;
      long long v53 = v9;
      uint64_t v38 = 0;
      uint64_t v39 = 0;
      *(void *)&long long v51 = v6;
      *((void *)&v51 + 1) = v7;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      uint64_t v40 = 0;
      long long v12 = v21;
      long long v21 = 0u;
      long long v54 = v12;
      long long v41 = 0u;
      long long v43 = 0u;
      long long v13 = v23;
      long long v14 = v24;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v56 = v13;
      long long v57 = v14;
      long long v44 = 0u;
      int v42 = 2;
      int v45 = 2;
      int v55 = 1;
      int v58 = 1;
      long long v15 = *(_OWORD *)v26;
      memset(v26, 0, sizeof(v26));
      long long v59 = v15;
      long long v46 = 0u;
      uint64_t v48 = 0;
      uint64_t v49 = 0;
      long long v61 = v10;
      uint64_t v60 = v11;
      uint64_t v47 = 0;
      *(unsigned char *)a3 = 1;
      re::Optional<re::AssetLoadDescriptor>::Optional(a3 + 8, (unsigned __int8 *)&v50);
      re::Optional<re::AssetLoadDescriptor>::~Optional(&v50);
      re::Optional<re::AssetLoadDescriptor>::~Optional(v35);
      if (*(void *)&v26[8])
      {
        if (v26[16]) {
          (*(void (**)(void))(**(void **)&v26[8] + 40))();
        }
        *(_OWORD *)&unsigned char v26[8] = 0u;
        long long v27 = 0u;
      }
      if (*((void *)&v23 + 1))
      {
        if (*(void *)v26) {
          (*(void (**)(void))(**((void **)&v23 + 1) + 40))();
        }
        *(void *)uint64_t v26 = 0;
        long long v24 = 0uLL;
        *((void *)&v23 + 1) = 0;
        ++v25;
      }
      if (*((void *)&v20 + 1))
      {
        if ((void)v23) {
          (*(void (**)(void))(**((void **)&v20 + 1) + 40))();
        }
        *(void *)&long long v23 = 0;
        long long v21 = 0uLL;
        *((void *)&v20 + 1) = 0;
        ++v22;
      }
      if (v18 && (v19 & 1) != 0) {
        (*(void (**)(void))(*(void *)v18 + 40))();
      }
      if (v32[0])
      {
        if (v32[1]) {
          (*(void (**)(void))(*(void *)v32[0] + 40))();
        }
        memset(v32, 0, sizeof(v32));
      }
      if (v31[0])
      {
        if (v31[1]) {
          (*(void (**)(void))(*(void *)v31[0] + 40))();
        }
        memset(v31, 0, sizeof(v31));
      }
      if (v29 && (v30 & 1) != 0) {
        (*(void (**)(void))(*(void *)v29 + 40))();
      }
    }
    else
    {
      v35[0] = 0;
      LOBYTE(v50) = 0;
      *(unsigned char *)a3 = 1;
      re::Optional<re::AssetLoadDescriptor>::Optional(a3 + 8, (unsigned __int8 *)&v50);
      re::Optional<re::AssetLoadDescriptor>::~Optional(&v50);
      re::Optional<re::AssetLoadDescriptor>::~Optional(v35);
    }
    if (v62[0])
    {
      if (v65[0])
      {
        if (v65[1]) {
          (*(void (**)(void))(*(void *)v65[0] + 40))();
        }
        memset(v65, 0, sizeof(v65));
      }
      if (v63 && (v64 & 1) != 0) {
        (*(void (**)(void))(*(void *)v63 + 40))();
      }
    }
  }
  else
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v50, (const re::DynamicString *)v67);
    *(unsigned char *)a3 = 0;
    uint64_t v16 = v52;
    *(void *)(a3 + 8) = v50;
    *(void *)(a3 + 32) = v16;
    *(_OWORD *)(a3 + 16) = v51;
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(v66);
}

unsigned char *re::RealityFileAssetProvider::getSource@<X0>(re::RealityFileAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t a3@<X8>)
{
  if (v19[0])
  {
    BOOL hasURL = re::RealityFileDescriptor::hasURL(v20, *((void *)this + 27));
    if (hasURL)
    {
      re::RealityFileDescriptor::getURL((uint64_t)v20, *((os_unfair_lock_s **)this + 27), *((os_unfair_lock_s **)this + 28), (uint64_t)v17);
      if (v17[0])
      {
        LOBYTE(v13) = 1;
        re::DynamicString::DynamicString((re::DynamicString *)&v14, (const re::DynamicString *)&v17[8]);
        long long v6 = v14;
        long long v14 = 0uLL;
        uint64_t v7 = v15;
        uint64_t v8 = v16;
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        *(_OWORD *)(a3 + 16) = v6;
        *(void *)(a3 + 32) = v7;
        *(void *)(a3 + 40) = v8;
        *(unsigned char *)a3 = 1;
        *(unsigned char *)(a3 + 8) = 1;
      }
      else
      {
        re::DynamicString::DynamicString((re::DynamicString *)&v13, (const re::DynamicString *)&v17[8]);
        *(unsigned char *)a3 = 0;
        *(void *)(a3 + 8) = v13;
        *(void *)(a3 + 32) = v15;
        *(_OWORD *)(a3 + 16) = v14;
      }
      if (*(void *)&v17[8] && (v17[16] & 1) != 0) {
        (*(void (**)(void))(**(void **)&v17[8] + 40))();
      }
    }
    else
    {
      long long v9 = *(_OWORD *)v17;
      uint64_t v10 = *(void *)&v17[16];
      uint64_t v11 = v18;
      *(unsigned char *)a3 = 0;
      *(_OWORD *)(a3 + 8) = v9;
      *(void *)(a3 + 24) = v10;
      *(void *)(a3 + 32) = v11;
    }
  }
  else
  {
    re::DynamicString::DynamicString((re::DynamicString *)v17, (const re::DynamicString *)v20);
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = *(void *)v17;
    *(void *)(a3 + 32) = v18;
    *(_OWORD *)(a3 + 16) = *(_OWORD *)&v17[8];
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(v19);
}

double re::RealityFileAssetProvider::getFileName@<D0>(re::RealityFileAssetProvider *this@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)this + 64))(&v18);
  if ((_BYTE)v18)
  {
    uint64_t v4 = NSURL;
    if (BYTE8(v20)) {
      unint64_t v5 = v21;
    }
    else {
      unint64_t v5 = (char *)&v20 + 9;
    }
    long long v6 = [NSString stringWithCString:v5 encoding:4];
    uint64_t v7 = [v4 URLWithString:v6];

    id v8 = [v7 lastPathComponent];
    long long v9 = (_anonymous_namespace_ *)[v8 UTF8String];
    long long v10 = v15;
    long long v15 = 0uLL;
    uint64_t v11 = v16;
    uint64_t v12 = v17;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    *(unsigned char *)a2 = 1;
    *(unsigned char *)(a2 + 8) = 1;
    *(_OWORD *)(a2 + 16) = v10;
    *(void *)(a2 + 32) = v11;
    *(void *)(a2 + 40) = v12;

    if ((_BYTE)v18)
    {
      if (!(_BYTE)v19) {
        return result;
      }
      long long v14 = (re::DynamicString *)&v20;
    }
    else
    {
      long long v14 = (re::DynamicString *)&v19;
    }
  }
  else
  {
    *(unsigned char *)a2 = 0;
    long long v14 = (re::DynamicString *)&v19;
    *(void *)(a2 + 8) = v19;
    *(void *)(a2 + 32) = v21;
    *(_OWORD *)(a2 + 16) = v20;
    long long v21 = 0;
    uint64_t v19 = 0;
    long long v20 = 0uLL;
  }
  return re::DynamicString::deinit(v14);
}

unsigned char *re::RealityFileAssetProvider::getDescription(re::RealityFileAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  if (v22[0])
  {
    uint64_t v4 = "URL";
    switch(v22[8])
    {
      case 0:
        unint64_t v5 = "None";
        uint64_t v6 = 4;
        goto LABEL_5;
      case 1:
        goto LABEL_9;
      case 2:
        uint64_t v4 = "Bundle";
        goto LABEL_9;
      case 3:
        uint64_t v4 = "MemoryFileID";
        goto LABEL_9;
      case 4:
        uint64_t v4 = "NameAlias";
LABEL_9:
        long long v20 = v4;
        v21[0] = strlen(v4);
        re::DynamicString::operator=(a3, (uint64_t)&v20);
        break;
      default:
        break;
    }
    char v7 = v23[0];
    if (v23[0]) {
      size_t v8 = v23[0] >> 1;
    }
    else {
      size_t v8 = LOBYTE(v23[0]) >> 1;
    }
    if (v8)
    {
      re::DynamicString::append(a3, "/", 1uLL);
      if (v7) {
        long long v9 = (const char *)v23[1];
      }
      else {
        long long v9 = (char *)v23 + 1;
      }
      re::DynamicString::append(a3, v9, v8);
    }
    char v10 = v24[0];
    if (v24[0]) {
      size_t v11 = v24[0] >> 1;
    }
    else {
      size_t v11 = LOBYTE(v24[0]) >> 1;
    }
    if (v11)
    {
      re::DynamicString::append(a3, "/", 1uLL);
      if (v10) {
        uint64_t v12 = (const char *)v24[1];
      }
      else {
        uint64_t v12 = (char *)v24 + 1;
      }
      re::DynamicString::append(a3, v12, v11);
    }
    char v13 = v25[0];
    if (v25[0]) {
      size_t v14 = v25[0] >> 1;
    }
    else {
      size_t v14 = LOBYTE(v25[0]) >> 1;
    }
    if (v14)
    {
      re::DynamicString::append(a3, "/", 1uLL);
      if (v13) {
        long long v15 = (const char *)v25[1];
      }
      else {
        long long v15 = (char *)v25 + 1;
      }
      re::DynamicString::append(a3, v15, v14);
    }
    if (v26 != 1)
    {
      re::DynamicString::format((re::DynamicString *)"<textureDownsampleLevel%d>", (re::DynamicString *)&v20, v26);
      uint64_t v16 = v21[0] & 1;
      if (v21[0]) {
        uint64_t v17 = (const char *)v21[1];
      }
      else {
        uint64_t v17 = (char *)v21 + 1;
      }
      if (v21[0]) {
        size_t v18 = v21[0] >> 1;
      }
      else {
        size_t v18 = LOBYTE(v21[0]) >> 1;
      }
      re::DynamicString::append(a3, v17, v18);
      if (v20 && v16) {
        (*(void (**)(void))(*(void *)v20 + 40))();
      }
    }
  }
  else
  {
    unint64_t v5 = "mangled";
    uint64_t v6 = 7;
LABEL_5:
    long long v20 = v5;
    v21[0] = v6;
    re::DynamicString::operator=(a3, (uint64_t)&v20);
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(v22);
}

unsigned char *re::RealityFileAssetProvider::getAssetPathForRelease@<X0>(re::RealityFileAssetProvider *a1@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t a3@<X8>)
{
  if (v29[0])
  {
    re::RealityFileAssetProvider::getFileName(a1, (uint64_t)&v26);
    if (!(_BYTE)v26)
    {
      long long v10 = v23;
      uint64_t v11 = v24;
      uint64_t v12 = v25;
      *(unsigned char *)a3 = 0;
      *(_OWORD *)(a3 + 8) = v10;
      *(void *)(a3 + 24) = v11;
      *(void *)(a3 + 32) = v12;
      long long v9 = (re::DynamicString *)&v27;
      goto LABEL_24;
    }
    re::DynamicString::operator+((re::DynamicString *)&v23, (uint64_t)&v31, (re::DynamicString *)&v20);
    if (v28[0]) {
      uint64_t v6 = (char *)v28[1];
    }
    else {
      uint64_t v6 = (char *)v28 + 1;
    }
    if (v21) {
      char v7 = *(unsigned char **)&v22[7];
    }
    else {
      char v7 = v22;
    }
    re::DynamicString::format((re::DynamicString *)"reality:%s/%s", (re::DynamicString *)&v17, v6, v7);
    re::DynamicString::DynamicString((re::DynamicString *)&v14, (const re::DynamicString *)&v17);
    *(unsigned char *)a3 = 1;
    *(void *)(a3 + 8) = v14;
    uint64_t v8 = v17;
    *(void *)(a3 + 32) = v16;
    *(_OWORD *)(a3 + 16) = v15;
    if (v8 && (v18 & 1) != 0) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 40))(v8, v19);
    }
    if (v20 && (v21 & 1) != 0) {
      (*(void (**)(void))(*(void *)v20 + 40))();
    }
    if (void)v23 && (BYTE8(v23)) {
      (*(void (**)(void))(*(void *)v23 + 40))();
    }
    if (!(_BYTE)v26)
    {
      long long v9 = (re::DynamicString *)&v27;
      goto LABEL_24;
    }
    if ((_BYTE)v27)
    {
      long long v9 = (re::DynamicString *)((char *)&v27 + 8);
LABEL_24:
      re::DynamicString::deinit(v9);
    }
  }
  else
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v26, (const re::DynamicString *)&v30);
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = v26;
    *(void *)(a3 + 32) = v28[0];
    *(_OWORD *)(a3 + 16) = v27;
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(v29);
}

unsigned char *re::RealityFileAssetProvider::initMetadataStrings(uint64_t a1, const re::AssetLoadDescriptor *a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (v15[0])
  {
    re::RealityFileRegistry::getOrMountRealityFile((re::RealityFileDescriptor *)&v16, *(dispatch_queue_t **)(a1 + 192), *(os_unfair_lock_s **)(a1 + 216), *(os_unfair_lock_s **)(a1 + 224), (uint64_t)v13);
    if (v13[0])
    {
      uint64_t v6 = v14;
      if (v14) {
        char v7 = v14 + 1;
      }
      uint64_t v8 = re::AssetMap::metadataForFileName(v6[14], (const re::DynamicString *)&v17);
      if (v8) {
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(a3, v8);
      }
    }
    else
    {
      long long v9 = *re::assetsLogObjects(v5);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        uint64_t v11 = v9;
        uint64_t v12 = re::WrappedError::localizedDescription((id *)&v14);
        *(_DWORD *)long long buf = 136315138;
        uint64_t v19 = v12;
        _os_log_error_impl(&dword_233120000, v11, OS_LOG_TYPE_ERROR, "Cannot init metadata due to reality file load error: %s", buf, 0xCu);
      }
    }
    re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v13);
  }
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(v15);
}

unsigned char *re::RealityFileAssetProvider::getPreloadableDependencies@<X0>(uint64_t a1@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::internal::AssetTypeRegistry **a3@<X2>, uint64_t a4@<X8>)
{
  if (!v62[0])
  {
    if (v63[8]) {
      uint64_t v37 = *(unsigned char **)&v64[7];
    }
    else {
      uint64_t v37 = v64;
    }
    re::WrappedError::make((re::WrappedError *)@"RERealityFileErrorDomain", (const __CFString *)0x11, (uint64_t)v37, &v47);
    uint64_t v38 = v47;
    uint64_t v47 = 0;
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = v38;

    return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(v62);
  }
  uint64_t v61 = 0;
  unint64_t v58 = 0;
  unint64_t v59 = 0;
  long long v57 = 0;
  int v60 = 0;
  re::RealityFileRegistry::getMountedRealityFile((re::RealityFileDescriptor *)v63, *(dispatch_queue_t **)(a1 + 192), *(os_unfair_lock_s **)(a1 + 216), *(os_unfair_lock_s **)(a1 + 224), (uint64_t)v55);
  if (v55[0])
  {
    uint64_t v8 = v56;
    if (v56) {
      id v9 = (id)(v56 + 8);
    }
    if (v64[71]) {
      long long v10 = *(const char **)&v65[7];
    }
    else {
      long long v10 = v65;
    }
    uint64_t v11 = re::AssetMap::assetDependenciesWithFileName(*(re::AssetMap **)(v8 + 112), v10);
    if (v11 && (uint64_t v12 = *(void *)(v11 + 16)) != 0)
    {
      unint64_t v13 = 0;
      uint64_t v14 = *(uint64_t **)(v11 + 32);
      uint64_t v45 = 0;
      uint64_t v44 = v8;
      uint64_t v15 = 8 * v12;
      while (1)
      {
        uint64_t v16 = *v14;
        if (*v14) {
          id v17 = (id)(v16 + 8);
        }
        char v18 = (re::path *)(*(uint64_t (**)(uint64_t))(*(void *)v16 + 40))(v16);
        if (!v18) {
          break;
        }
        uint64_t v20 = (unsigned char *)re::path::ext(v18, v19);
        if (*v20 != 46) {
          break;
        }
        char v21 = v20 + 1;
        if (!v20[1]) {
          break;
        }
        uint64_t v22 = re::internal::AssetTypeRegistry::assetTypeWithCompiledExtension(*a3, v21);
        if (!v22)
        {
          re::DynamicString::format((re::DynamicString *)"Failed to find AssetType with compiled extension '%s'.", (re::DynamicString *)&v47, v21);
          if (v48) {
            uint64_t v40 = (char *)*((void *)&v48 + 1);
          }
          else {
            uint64_t v40 = (char *)&v48 + 1;
          }
          uint64_t v41 = 9;
          goto LABEL_56;
        }
        long long v23 = (void *)v22;
        uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 40))(v16);
        uint64_t v25 = (_anonymous_namespace_ *)(*(void *(**)(uint64_t *__return_ptr, uint64_t, const re::AssetLoadDescriptor *, uint64_t, void))(*(void *)a1 + 48))(&v47, a1, a2, v24, *v23);
        int v26 = v47;
        if ((_BYTE)v47)
        {
          uint64_t v54 = 0;
          long long v52 = 0uLL;
          long long v51 = 0;
          int v53 = 0;
          re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(&v51, 1uLL);
          ++v53;
          long long v27 = re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)&v51, (re::DynamicString *)&v48);
          if (v13 >= v58)
          {
            if (v58 < v13 + 1)
            {
              if (v57)
              {
                unint64_t v32 = 8;
                if (v58) {
                  unint64_t v32 = 2 * v58;
                }
                if (v32 <= v13 + 1) {
                  unint64_t v33 = v13 + 1;
                }
                else {
                  unint64_t v33 = v32;
                }
                re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity(&v57, v33);
              }
              else
              {
                re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity(&v57, v13 + 1);
                ++v60;
              }
            }
            unint64_t v13 = v59;
            uint64_t v28 = v61;
          }
          else
          {
            uint64_t v28 = v45;
          }
          uint64_t v45 = v28;
          re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray(v28 + 40 * v13, (uint64_t *)&v51);
          unint64_t v13 = ++v59;
          ++v60;
          re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v51);
        }
        else
        {
          uint64_t v29 = (char *)&v48 + 9;
          if (BYTE8(v48)) {
            uint64_t v29 = v49;
          }
          re::DynamicString::format((re::DynamicString *)"RealityFileAssetProvider failed to resolve child AssetLoadDescriptor due to error: %s", (re::DynamicString *)&v51, v29);
          if (v52) {
            uint64_t v30 = (char *)*((void *)&v52 + 1);
          }
          else {
            uint64_t v30 = (char *)&v52 + 1;
          }
          re::WrappedError::make((re::WrappedError *)@"RERealityFileErrorDomain", (const __CFString *)0x13, (uint64_t)v30, &v46);
          uint64_t v31 = v46;
          uint64_t v46 = 0;
          *(unsigned char *)a4 = 0;
          *(void *)(a4 + 8) = v31;

          if (v51 && (v52 & 1) != 0) {
            (*(void (**)(void))(*v51 + 40))();
          }
        }
        re::Result<re::AssetLoadDescriptor,re::DynamicString>::~Result(&v47);

        if (!v26) {
          goto LABEL_60;
        }
        ++v14;
        v15 -= 8;
        if (!v15)
        {
          re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::DynamicArray((uint64_t)&v51, (uint64_t *)&v57);
          uint64_t v34 = v51;
          long long v51 = 0;
          uint64_t v35 = v54;
          uint64_t v54 = 0;
          ++v53;
          *(unsigned char *)a4 = 1;
          *(void *)(a4 + 8) = v34;
          uint64_t v47 = 0;
          long long v36 = v52;
          long long v52 = 0u;
          *(_OWORD *)(a4 + 16) = v36;
          long long v48 = 0u;
          *(void *)(a4 + 40) = v35;
          uint64_t v50 = 0;
          LODWORD(v49) = 2;
          *(_DWORD *)(a4 + 32) = 1;
          re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v47);
          re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v51);
          goto LABEL_60;
        }
      }
      uint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 40))(v16);
      re::DynamicString::format((re::DynamicString *)"Failed to parse extension from archive entry name '%s'.", (re::DynamicString *)&v47, v39);
      if (v48) {
        uint64_t v40 = (char *)*((void *)&v48 + 1);
      }
      else {
        uint64_t v40 = (char *)&v48 + 1;
      }
      uint64_t v41 = 18;
LABEL_56:
      re::WrappedError::make((re::WrappedError *)@"RERealityFileErrorDomain", (const __CFString *)v41, (uint64_t)v40, &v51);
      int v42 = v51;
      long long v51 = 0;
      *(unsigned char *)a4 = 0;
      *(void *)(a4 + 8) = v42;

      if (v47 && (v48 & 1) != 0) {
        (*(void (**)(void))(*(void *)v47 + 40))();
      }

LABEL_60:
      uint64_t v8 = v44;
      if (!v44) {
        goto LABEL_62;
      }
    }
    else
    {
      uint64_t v54 = 0;
      long long v51 = 0;
      long long v52 = 0u;
      int v53 = 1;
      *(unsigned char *)a4 = 1;
      uint64_t v47 = 0;
      *(_OWORD *)(a4 + 8) = 0u;
      *(void *)(a4 + 24) = 0;
      long long v48 = 0u;
      *(void *)(a4 + 40) = 0;
      uint64_t v50 = 0;
      LODWORD(v49) = 2;
      *(_DWORD *)(a4 + 32) = 1;
      re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v47);
      re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v51);
    }
  }
  else
  {
    re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::DynamicArray((uint64_t)&v47, (uint64_t *)&v57);
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = v47;
    *(_OWORD *)(a4 + 16) = v48;
    uint64_t v47 = 0;
    long long v48 = 0uLL;
    *(void *)(a4 + 40) = v50;
    uint64_t v50 = 0;
    LODWORD(v49) = v49 + 1;
    *(_DWORD *)(a4 + 32) = 1;
    re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v47);
  }
LABEL_62:
  if (v55[0] && v56) {

  }
  re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)&v57);
  return re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(v62);
}

uint64_t re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::add<re::RealityFileAssetProvider::PerTypeLoadCallbacks*&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addEmplace<re::RealityFileAssetProvider::PerTypeLoadCallbacks*&>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 32 * v10;
  return v12 + 24;
}

void re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_0,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::~Callable()
{
}

unsigned char *re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_0,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::operator()@<X0>(uint64_t a1@<X0>, const char **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *a2;
  if ((*a2)[8]) {
    unint64_t v5 = (const char *)*((void *)v4 + 2);
  }
  else {
    unint64_t v5 = v4 + 9;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = (_anonymous_namespace_ *)strcmp(v5, "RealityFileAsset");
  if (!v7)
  {
    if (!(_BYTE)v38)
    {
      uint64_t v24 = v39[0];
      *(unsigned char *)a3 = 0;
      *(void *)(a3 + 8) = v24;
      return re::Result<re::RealityFileAssetLoadDescriptorParameters,__CFError *>::~Result(&v38);
    }
    re::RealityFileRegistry::getOrMountRealityFile((re::RealityFileDescriptor *)v39, *(dispatch_queue_t **)(v6 + 192), *(os_unfair_lock_s **)(v6 + 216), *(os_unfair_lock_s **)(v6 + 224), (uint64_t)v36);
    uint64_t v14 = (char *)v37;
    if (!v36[0])
    {
      id v25 = v37;
      CFRetain(v25);
      *(unsigned char *)a3 = 0;
      *(void *)(a3 + 8) = v25;
LABEL_38:
      re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v36);
      return re::Result<re::RealityFileAssetLoadDescriptorParameters,__CFError *>::~Result(&v38);
    }
    if (v37) {
      uint64_t v15 = (char *)v37 + 8;
    }
    if (v40) {
      uint64_t v16 = *(char **)&v41[7];
    }
    else {
      uint64_t v16 = v41;
    }
    if (!strcmp(v16, "assetMap.json") || !strcmp(v16, "header.json") || !strcmp(v16, "dedupe.json"))
    {
      re::RealityFile::newDataByLoading((re::RealityFile *)v14, v16, (uint64_t)v32);
      id v20 = v33;
      if (!v32[0])
      {
        id v26 = v33;
        CFRetain(v26);
        int v27 = v32[0];
        *(unsigned char *)a3 = 0;
        *(void *)(a3 + 8) = v26;
        if (v27) {
          goto LABEL_36;
        }
        id v23 = v33;
LABEL_31:

LABEL_36:
        if (v14) {

        }
        goto LABEL_38;
      }
    }
    else
    {
      if (!v32[0])
      {
        if (v34) {
          uint64_t v28 = *(_anonymous_namespace_ **)&v35[7];
        }
        else {
          uint64_t v28 = (_anonymous_namespace_ *)v35;
        }
        *(unsigned char *)a3 = 0;
        *(void *)(a3 + 8) = Error;
        if (!v32[0] && v33 && (v34 & 1) != 0) {
          (*(void (**)(void))(*(void *)v33 + 40))();
        }
        goto LABEL_36;
      }
      re::RealityFile::newDataByLoading((re::RealityFile *)v14, (uint64_t)v33, (uint64_t)v30);
      id v20 = v31;
      if (!v30[0])
      {
        id v21 = v31;
        CFRetain(v21);
        int v22 = v30[0];
        *(unsigned char *)a3 = 0;
        *(void *)(a3 + 8) = v21;
        if (v22) {
          goto LABEL_36;
        }
        id v23 = v31;
        goto LABEL_31;
      }
    }
    *(unsigned char *)a3 = 1;
    *(void *)(a3 + 8) = v20;
    goto LABEL_36;
  }
  if (v39[0]) {
    uint64_t v11 = (_anonymous_namespace_ *)v39[1];
  }
  else {
    uint64_t v11 = (_anonymous_namespace_ *)((char *)v39 + 1);
  }
  *(unsigned char *)a3 = 0;
  *(void *)(a3 + 8) = v12;
  double result = v38;
  if (v38)
  {
    if (v39[0]) {
      return (unsigned char *)(*(uint64_t (**)(void))(*(void *)v38 + 40))();
    }
  }
  return result;
}

void *re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_0,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6CCF28;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_0,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6CCF28;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_0,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::size()
{
  return 16;
}

void re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_1,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::~Callable()
{
}

const char *re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_1,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::operator()@<X0>(const char **a1@<X1>, const char **a2@<X2>, const char **a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v5 = *a1;
  uint64_t v6 = *a2;
  unint64_t v7 = *a3;
  if ((*a1)[8]) {
    CFStringRef v8 = (const char *)*((void *)v5 + 2);
  }
  else {
    CFStringRef v8 = v5 + 9;
  }
  if (!strcmp(v8, "RealityFileAsset"))
  {
    if (v60[0])
    {
      uint64_t v51 = 0;
      uint64_t v52 = 0;
      uint64_t v53 = 0;
      uint64_t v16 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v50, 0);
      *((void *)&v54 + 1) = 0;
      long long v55 = 0uLL;
      CFStringRef v17 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v54, 0);
      *((void *)&v56 + 1) = 0;
      long long v57 = 0uLL;
      re::DynamicString::setCapacity(&v56, 0);
      char v58 = 0;
      uint64_t v59 = 1;
      v49[0] = v61;
      re::DynamicString::operator=((re::DynamicString *)&v50, (re::DynamicString *)&v62);
      re::DynamicString::operator=((re::DynamicString *)&v54, (re::DynamicString *)v63);
      uint64_t v35 = v6;
      v36[0] = strlen(v6);
      uint64_t v18 = re::DynamicString::operator=((re::DynamicString *)&v56, (uint64_t)&v35);
      char v58 = v63[64];
      re::RealityFileAssetLoadDescriptorFactory::make(v49, (re::DynamicString *)&v21, (uint64_t)&v35);
      if (v21 && (v22 & 1) != 0) {
        (*(void (**)(void))(*(void *)v21 + 40))();
      }
      re::AssetLoadDescriptor::AssetLoadDescriptor((re::AssetLoadDescriptor *)&v21, (const re::AssetLoadDescriptor *)&v35);
      v19.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a4, (uint64_t)&v21);
      if ((void)v33)
      {
        if (BYTE8(v33)) {
          (*(void (**)(double))(*(void *)v33 + 40))(v19.n128_f64[0]);
        }
        __n128 v19 = 0uLL;
        long long v33 = 0u;
        long long v34 = 0u;
      }
      if (v28)
      {
        if (v32) {
          (*(void (**)(__n128))(*(void *)v28 + 40))(v19);
        }
        uint64_t v32 = 0;
        uint64_t v29 = 0;
        uint64_t v30 = 0;
        uint64_t v28 = 0;
        ++v31;
      }
      if (v23)
      {
        if (v27) {
          (*(void (**)(__n128))(*(void *)v23 + 40))(v19);
        }
        uint64_t v27 = 0;
        uint64_t v24 = 0;
        uint64_t v25 = 0;
        uint64_t v23 = 0;
        ++v26;
      }
      if (v21 && (v22 & 1) != 0) {
        (*(void (**)(__n128))(*(void *)v21 + 40))(v19);
      }
      if ((void)v47)
      {
        if (BYTE8(v47)) {
          (*(void (**)(__n128))(*(void *)v47 + 40))(v19);
        }
        __n128 v19 = 0uLL;
        long long v47 = 0u;
        long long v48 = 0u;
      }
      if (v42)
      {
        if (v46) {
          (*(void (**)(__n128))(*(void *)v42 + 40))(v19);
        }
        uint64_t v46 = 0;
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        uint64_t v42 = 0;
        ++v45;
      }
      if (v37)
      {
        if (v41) {
          (*(void (**)(__n128))(*(void *)v37 + 40))(v19);
        }
        uint64_t v41 = 0;
        uint64_t v38 = 0;
        uint64_t v39 = 0;
        uint64_t v37 = 0;
        ++v40;
      }
      if (v35 && (v36[0] & 1) != 0) {
        (*(void (**)(__n128))(*(void *)v35 + 40))(v19);
      }
      if ((void)v56)
      {
        if (BYTE8(v56)) {
          (*(void (**)(__n128))(*(void *)v56 + 40))(v19);
        }
        __n128 v19 = 0uLL;
        long long v56 = 0u;
        long long v57 = 0u;
      }
      if ((void)v54)
      {
        if (BYTE8(v54)) {
          (*(void (**)(__n128))(*(void *)v54 + 40))(v19);
        }
        __n128 v19 = 0uLL;
        long long v54 = 0u;
        long long v55 = 0u;
      }
      if (v50 && (v51 & 1) != 0) {
        (*(void (**)(__n128))(*v50 + 40))(v19);
      }
    }
    else
    {
      uint64_t v20 = v61;
      *(unsigned char *)a4 = 0;
      *(void *)(a4 + 8) = v20;
    }
    return re::Result<re::RealityFileAssetLoadDescriptorParameters,__CFError *>::~Result(v60);
  }
  else
  {
    re::DynamicString::format((re::DynamicString *)"Cannot resolve with a parent AssetLoadDescriptor of scheme %s. Expected scheme %s.", (re::DynamicString *)&v35, v8, "RealityFileAsset");
    if (v36[0]) {
      id v12 = (_anonymous_namespace_ *)v36[1];
    }
    else {
      id v12 = (_anonymous_namespace_ *)((char *)v36 + 1);
    }
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = Error;
    double result = v35;
    if (v35)
    {
      if (v36[0]) {
        return (const char *)(*(uint64_t (**)(void))(*(void *)v35 + 40))();
      }
    }
  }
  return result;
}

void *re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_1,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6CCF90;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_1,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6CCF90;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RealityFileAssetProvider::RealityFileAssetProvider(re::RealityFileRegistry *,re::internal::AssetTypeRegistry const*,re::AssetProviderRegistry const*,re::NamedFileRegistry const*,re::BundleFilePathRegistry *)::$_1,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::size()
{
  return 16;
}

uint64_t re::FunctionBase<24ul,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,re::Result<__CFData const*,__CFError *> ()(re::AssetLoadDescriptor const*,unsigned long long)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t re::FunctionBase<24ul,__CFError * ()(re::AssetLoadDescriptor const*,unsigned long long,re::internal::AssetReference *)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,__CFError * ()(re::AssetLoadDescriptor const*,unsigned long long,re::internal::AssetReference *)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t re::FunctionBase<24ul,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,re::Result<re::AssetLoadDescriptor,__CFError *> ()(re::AssetLoadDescriptor const*,char const*,char const*)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t re::types::Ok<re::RealityFileAssetLoadDescriptorParameters>::Ok(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 8), (const re::DynamicString *)(a2 + 8));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 72), (const re::DynamicString *)(a2 + 72));
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  return a1;
}

unsigned char *re::Result<re::RealityFileAssetLoadDescriptorParameters,re::DynamicString>::~Result(unsigned char *a1)
{
  if (*a1)
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 80));
    re::DynamicString::deinit((re::DynamicString *)(a1 + 48));
    uint64_t v2 = (re::DynamicString *)(a1 + 16);
  }
  else
  {
    uint64_t v2 = (re::DynamicString *)(a1 + 8);
  }
  re::DynamicString::deinit(v2);
  return a1;
}

unsigned char *re::Result<re::RealityFileAssetLoadDescriptorParameters,__CFError *>::~Result(unsigned char *a1)
{
  if (*a1)
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 80));
    re::DynamicString::deinit((re::DynamicString *)(a1 + 48));
    re::DynamicString::deinit((re::DynamicString *)(a1 + 16));
  }
  return a1;
}

uint64_t re::Result<re::RealityFileEntryStream,re::WrappedError>::~Result(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(unsigned int *)(a1 + 224);
    if (v2 != -1) {
      off_26E6CCFE8[v2]((int)&v4, (re::FileSeekableInputStream *)(a1 + 8));
    }
    *(_DWORD *)(a1 + 224) = -1;
  }
  else
  {
  }
  return a1;
}

void *re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 40 * v9;
        uint64_t v11 = v7 + 4;
        do
        {
          *uint64_t v11 = 0;
          *(v11 - 3) = 0;
          *(v11 - 2) = 0;
          *(v11 - 4) = 0;
          *((_DWORD *)v11 - 2) = 0;
          uint64_t v12 = *(void *)(v8 + 8);
          *(v11 - 4) = *(void *)v8;
          *(v11 - 3) = v12;
          *(void *)uint64_t v8 = 0;
          *(void *)(v8 + 8) = 0;
          uint64_t v13 = *(v11 - 2);
          *(v11 - 2) = *(void *)(v8 + 16);
          *(void *)(v8 + 16) = v13;
          uint64_t v14 = *v11;
          *uint64_t v11 = *(void *)(v8 + 32);
          *(void *)(v8 + 32) = v14;
          ++*(_DWORD *)(v8 + 24);
          ++*((_DWORD *)v11 - 2);
          re::DynamicArray<re::AssetLoadDescriptor>::deinit(v8);
          v11 += 5;
          v8 += 40;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    unint64_t v6 = a2[2];
    if (v6 >= *(void *)(a1 + 16))
    {
      re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::setCapacity((void *)a1, a2[2]);
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,0>(a2[4], (uint64_t *)(a2[4] + 40 * *(void *)(a1 + 16)), *(void *)(a1 + 32));
      uint64_t v10 = *(void *)(a1 + 16);
      if (v10 != v6)
      {
        uint64_t v11 = 5 * v10;
        uint64_t v12 = (uint64_t *)(a2[4] + 8 * v11);
        uint64_t v13 = *(void *)(a1 + 32) + 8 * v11;
        uint64_t v14 = 40 * v6 - 8 * v11;
        do
        {
          uint64_t v15 = re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray(v13, v12);
          v12 += 5;
          uint64_t v13 = v15 + 40;
          v14 -= 40;
        }
        while (v14);
      }
    }
    else
    {
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,0>(a2[4], (uint64_t *)(a2[4] + 40 * v6), *(void *)(a1 + 32));
      uint64_t v7 = *(void *)(a1 + 16);
      if (v6 != v7)
      {
        uint64_t v8 = *(void *)(a1 + 32) + 40 * v6;
        uint64_t v9 = 40 * v7 - 40 * v6;
        do
        {
          re::DynamicArray<re::AssetLoadDescriptor>::deinit(v8);
          v8 += 40;
          v9 -= 40;
        }
        while (v9);
      }
    }
    *(void *)(a1 + 16) = v6;
  }
  return a1;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,re::DynamicArray<re::AssetLoadDescriptor> *,0>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  if ((uint64_t *)result != a2)
  {
    unint64_t v5 = (uint64_t *)result;
    do
    {
      double result = re::DynamicArray<re::AssetLoadDescriptor>::operator=(a3, v5);
      v5 += 5;
      a3 += 40;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addEmplace<re::RealityFileAssetProvider::PerTypeLoadCallbacks*&>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, uint64_t *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  uint64_t v13 = a2;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  uint64_t v14 = *a5;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  if (v14) {
    id v15 = (id)(v14 + 8);
  }
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v13) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(void *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v22, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v22;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)char v22 = v5;
      *(void *)&unsigned char v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&unsigned char v22[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        uint64_t v13 = (void *)(v6 + 24);
        do
        {
          if ((*(_DWORD *)(v13 - 2) & 0x80000000) != 0)
          {
            unint64_t v14 = *(v13 - 3);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashTable<re::AssetType const*,re::SharedPtr<re::RealityFileAssetProvider::PerTypeLoadCallbacks>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 32 * v17) = v14;
            *(void *)(*(void *)(a1 + 16) + 32 * v17 + 16) = *(v13 - 1);
            *(void *)(*(void *)(a1 + 16) + 32 * v17 + 24) = *v13;
            *uint64_t v13 = 0;
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 4;
          --v10;
        }
        while (v10);
      }
      re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2) {
      signed int v21 = a2;
    }
    else {
      signed int v21 = 3;
    }
  }
}

uint64_t re::AssetLoader::registerAsset(re::AssetLoader *this, void *a2, const re::ExistingAssetInformation *a3)
{
  (*(void (**)(void *__return_ptr))(*(void *)this + 104))(v9);
  if (v10)
  {
    uint64_t v3 = 0;
    uint64_t v4 = v11;
    uint64_t v5 = 24 * v10;
    while (1)
    {
      uint64_t v6 = *((void *)v4 + 1);
      if (v6)
      {
        unsigned int v7 = atomic_load((unsigned int *)(v6 + 704));
        if (v7 != 2)
        {
          if (v7 == 3)
          {
            uint64_t v3 = 2;
            goto LABEL_11;
          }
          re::AssetHandle::loadAsync(v4);
          uint64_t v3 = 1;
        }
      }
      uint64_t v4 = (re::AssetHandle *)((char *)v4 + 24);
      v5 -= 24;
      if (!v5) {
        goto LABEL_11;
      }
    }
  }
  uint64_t v3 = 0;
LABEL_11:
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v9);
  return v3;
}

void *re::AssetLoader::findDependencies@<X0>(re::AssetLoader *this@<X0>, const re::IntrospectionBase **a2@<X1>, uint64_t a3@<X8>)
{
  v8[4] = *MEMORY[0x263EF8340];
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  uint64_t v5 = (*(uint64_t (**)(re::AssetLoader *))(*(void *)this + 112))(this);
  v7[0] = &unk_26E6CD018;
  v7[1] = a3;
  v7[3] = v7;
  v8[0] = &unk_26E6CA550;
  v8[1] = v7;
  _OWORD v8[3] = v8;
  re::IntrospectionWalker::walk(v5, a2, (uint64_t)v8);
  std::__function::__value_func<void ()(re::IntrospectionBase const&,void const*)>::~__value_func[abi:nn180100](v8);
  return std::__function::__value_func<void ()(re::AssetHandle *)>::~__value_func[abi:nn180100](v7);
}

void *re::AssetLoader::internalFindAssetHandleFields@<X0>(re::AssetLoader *this@<X0>, const re::IntrospectionBase **a2@<X1>, uint64_t a3@<X8>)
{
  v8[4] = *MEMORY[0x263EF8340];
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  uint64_t v5 = (*(uint64_t (**)(re::AssetLoader *))(*(void *)this + 112))(this);
  v7[0] = &unk_26E6CD0A8;
  v7[1] = a3;
  v7[3] = v7;
  v8[0] = &unk_26E6CA550;
  v8[1] = v7;
  _OWORD v8[3] = v8;
  re::IntrospectionWalker::walk(v5, a2, (uint64_t)v8);
  std::__function::__value_func<void ()(re::IntrospectionBase const&,void const*)>::~__value_func[abi:nn180100](v8);
  return std::__function::__value_func<void ()(re::AssetHandle *)>::~__value_func[abi:nn180100](v7);
}

uint64_t re::AssetLoader::findRegistrationDependencies(re::AssetLoader *this, void *a2)
{
  return (*(uint64_t (**)(re::AssetLoader *, void *))(*(void *)this + 104))(this, a2);
}

uint64_t re::AssetLoader::createRuntimeData()
{
  return 1;
}

uint64_t re::AssetLoader::assetByteSize(re::AssetLoader *this, void *a2)
{
  return (*(uint64_t (**)(re::AssetLoader *, void *))(*(void *)this + 40))(this, a2);
}

size_t re::AssetLoader::assetIntrospectionByteSize(re::AssetLoader *this, re::AssetUtilities *a2)
{
  uint64_t v3 = (re **)(*(uint64_t (**)(re::AssetLoader *))(*(void *)this + 112))(this);
  return re::AssetUtilities::computeIntrospectedDataSizeV2(a2, v3, v4);
}

uint64_t re::AssetLoader::assetNonIntrospectionNonSharedDataByteSize(re::AssetLoader *this, void *a2)
{
  return 0;
}

uint64_t re::AssetLoader::serializeAssetBlob()
{
  return 1;
}

uint64_t re::AssetLoader::cloneAsset(re::AssetLoader *this, const re::IntrospectionBase **a2, re::AssetSerializationScheme *a3)
{
  re::AssetLoader::makeSharedResourcePayload(this, a2, a3, &v11);
  uint64_t v4 = (*(uint64_t (**)(re::AssetLoader *))(*(void *)this + 120))(this);
  v10[0] = 0;
  uint64_t v5 = v11;
  long long v9 = v5;
  (*(void (**)(re::AssetLoader *, RESerializedPayload **, uint64_t, void (***)(re::PassthroughAssetSerialization *__hidden), char *, void))(*(void *)this + 208))(this, &v9, v4, re::PassthroughAssetSerialization::instance(void)::instance, v10, 0);

  uint64_t v6 = v5;
  unsigned int v8 = v6;
  (*(void (**)(re::AssetLoader *, RESerializedPayload **, uint64_t, const char *))(*(void *)this + 224))(this, &v8, v4, "unknown clone asset");

  return v4;
}

void re::AssetLoader::makeSharedResourcePayload(re::AssetLoader *this@<X0>, const re::IntrospectionBase **a2@<X1>, re::AssetSerializationScheme *a3@<X2>, RESerializedPayload **a4@<X8>)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v8 = (*(uint64_t (**)(re::AssetLoader *))(*(void *)this + 112))(this);
  v16[1] = 0;
  void v16[2] = 0;
  v16[0] = a3;
  v14[0] = this;
  v14[1] = a2;
  uint64_t v9 = re::globalAllocators((re *)v8)[2];
  *(void *)&long long buf = &unk_26E6CD128;
  *((void *)&buf + 1) = v14;
  uint64_t v18 = v9;
  p_long long buf = (re *)&buf;
  re::SerializedPayload::make(v8, a2, (uint64_t)v16, (uint64_t)&buf, &v15);
  uint64_t v10 = v15;
  unint64_t v15 = 0;
  int v11 = p_buf;
  if (p_buf)
  {
    int v11 = (re *)(**(uint64_t (***)(re *))p_buf)(p_buf);
    if (p_buf != (re *)&buf) {
      int v11 = (re *)(*(uint64_t (**)(uint64_t))(*(void *)v18 + 40))(v18);
    }
  }
  if (!v10)
  {
    if (*(_DWORD *)(v8 + 16) == 8) {
      uint64_t v12 = *(const char **)(v8 + 48);
    }
    else {
      uint64_t v12 = "<unknown>";
    }
    uint64_t v13 = *re::assetsLogObjects(v11);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v12;
      _os_log_fault_impl(&dword_233120000, v13, OS_LOG_TYPE_FAULT, "Asset type '%s' has not adopted resource sharing", (uint8_t *)&buf, 0xCu);
    }
  }
  *a4 = v10;
}

uint64_t re::AssetLoader::cloneAsset(re::AssetLoader *this, void *a2)
{
  re::DefaultAssetSerialize::DefaultAssetSerialize((re::DefaultAssetSerialize *)&v6, 0);
  uint64_t v4 = (*(uint64_t (**)(re::AssetLoader *, void *, void **))(*(void *)this + 144))(this, a2, &v6);
  uint64_t v6 = &unk_26E6CA958;
  re::Optional<re::AssetPath>::~Optional(v7);
  return v4;
}

void *re::AssetLoader::allocateAsset(re::AssetLoader *this)
{
  uint64_t v1 = (*(uint64_t (**)(re::AssetLoader *))(*(void *)this + 112))(this);
  size_t v2 = *(int *)(v1 + 20);
  uint64_t v3 = re::globalAllocators((re *)v1);
  uint64_t v4 = (void *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v3[2] + 32))(v3[2], *(unsigned int *)(v1 + 20), 1);
  bzero(v4, v2);
  (*(void (**)(uint64_t, void, void *))(v1 + 72))(v1, 0, v4);
  return v4;
}

uint64_t re::AssetLoader::allocateSampleAsset(re::AssetLoader *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 120))();
}

uint64_t re::AssetLoader::createRuntimeDataWithPayload(uint64_t a1, uint64_t a2, id *this, uint64_t a4)
{
  re::SerializedPayload::dynamicCast(this, &v12);
  if (v12)
  {
    re::SerializedPayload::blobData(&v12, &v9);
    re::DataSeekableInputStream::DataSeekableInputStream((uint64_t)v10, &v9, 1, 0);

    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)a1 + 24))(a1, a2, v10, a4);
    v10[0] = &unk_26E714530;

    v10[0] = &unk_26E7144B8;
    re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)v11);
  }
  else
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)a1 + 24))(a1, a2, 0, a4);
  }

  return v7;
}

uint64_t re::AssetLoader::initializeAssetWithSerializedDataFromPayloadWithoutRuntimeData(uint64_t a1, id *a2, re::DynamicString **a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
  if (*(_DWORD *)(v7 + 16) != 8)
  {
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) ", "info->type == IntrospectionType::kStructure", "initializeAssetWithSerializedDataFromPayloadWithoutRuntimeData", 209);
    _os_crash();
    __break(1u);
  }
  uint64_t v9 = v7;
  re::SerializedPayload::dynamicCast(a2, &v20);
  if (v20)
  {
    v19[1] = 0;
    _WORD v19[2] = 0;
    v19[0] = a4;
    int v11 = re::globalAllocators(v10);
    uint64_t v12 = re::SerializedPayload::deserializeIntoStruct(&v20, v9, a3, (uint64_t)v19, v11[2]);
    uint64_t v13 = v12;
    if ((v12 & 1) == 0)
    {
      unint64_t v14 = *re::assetsLogObjects((re *)v12);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      {
        re::SerializedPayload::typeName(&v20, (re::DynamicString *)v21);
        if (v21[8]) {
          unint64_t v15 = v22;
        }
        else {
          unint64_t v15 = &v21[9];
        }
        *(_DWORD *)long long buf = 136315138;
        uint64_t v24 = v15;
        _os_log_fault_impl(&dword_233120000, v14, OS_LOG_TYPE_FAULT, "Failed to deserialize payload for asset type '%s'", buf, 0xCu);
        if (*(void *)v21 && (v21[8] & 1) != 0) {
          (*(void (**)(void))(**(void **)v21 + 40))();
        }
      }
    }
  }
  else
  {
    unint64_t v16 = *re::assetsLogObjects(v10);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
    {
      uint64_t v18 = *(void *)(v9 + 48);
      *(_DWORD *)signed int v21 = 136315138;
      *(void *)&v21[4] = v18;
      _os_log_fault_impl(&dword_233120000, v16, OS_LOG_TYPE_FAULT, "Unexpected payload object ignored by asset type '%s' (expected a serialized payload)", v21, 0xCu);
    }
    uint64_t v13 = 0;
  }

  return v13;
}

uint64_t re::AssetLoader::initializeAssetWithSerializedDataFromPayload(uint64_t a1, id *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  re::SerializedPayload::dynamicCast(this, &v24);
  if (!v24)
  {
    uint64_t v19 = *re::assetsLogObjects(v12);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl(&dword_233120000, v19, OS_LOG_TYPE_DEBUG, "No serialized payload found", buf, 2u);
    }
    goto LABEL_11;
  }
  id v23 = *this;
  int v13 = (*(uint64_t (**)(uint64_t, id *, uint64_t, uint64_t))(*(void *)a1 + 296))(a1, &v23, a3, a4);

  if (v13)
  {
    re::SerializedPayload::serializedData(&v24, buf);
    uint64_t v14 = [*(id *)buf length];
    if (!*(unsigned char *)a5) {
      *(unsigned char *)a5 = 1;
    }
    *(void *)(a5 + 8) = v14;

    id v21 = *this;
    char v15 = re::AssetLoader::createRuntimeDataWithPayload(a1, a3, &v21, a6);

    if ((v15 & 1) == 0)
    {
      uint64_t v17 = *re::assetsLogObjects(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)long long buf = 0;
        _os_log_debug_impl(&dword_233120000, v17, OS_LOG_TYPE_DEBUG, "createRuntimeData returned false for asset created from a payload", buf, 2u);
      }
      goto LABEL_8;
    }
LABEL_11:
    uint64_t v18 = 1;
    goto LABEL_12;
  }
LABEL_8:
  uint64_t v18 = 0;
LABEL_12:

  return v18;
}

uint64_t re::AssetLoader::postInitializeAssetFromPayload()
{
  return 1;
}

uint64_t re::AssetLoader::postInitializeAssetFromPayloadWithLogging(uint64_t a1, id *a2, uint64_t a3, const char *a4)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = std::chrono::system_clock::now().__d_.__rep_;
  id v15 = *a2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, id *, uint64_t))(*(void *)a1 + 216))(a1, &v15, a3);

  v10.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v11 = rep - v10.__d_.__rep_;
  if (rep - v10.__d_.__rep_ >= 2000)
  {
    uint64_t v12 = *re::assetsLogObjects((re *)v10.__d_.__rep_);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = "unknown asset";
      if (a4) {
        int v13 = a4;
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v17 = v13;
      __int16 v18 = 2048;
      uint64_t v19 = v11 / 1000;
      _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Asset '%s' was in postInitializeAssetFromPayload for '%lld' ms.", buf, 0x16u);
    }
  }
  return v9;
}

void re::AssetLoader::resourceDidUpdate(uint64_t a1, re::DynamicString **a2, id *a3, uint64_t a4)
{
  id v7 = *a3;
  re::AssetLoader::initializeAssetWithSerializedDataFromPayloadWithoutRuntimeData(a1, &v7, a2, a4);
}

uint64_t re::AssetLoader::shouldCompress(re::AssetLoader *this, void *a2)
{
  return 1;
}

void *re::AssetLoader::serializableAsset@<X0>(void *a1@<X1>, void *a2@<X8>)
{
  v4[4] = *MEMORY[0x263EF8340];
  v4[0] = &unk_26E6CD1E8;
  v4[3] = v4;
  a2[4] = a2 + 1;
  *a2 = a1;
  a2[1] = &unk_26E6CD1E8;
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](v4);
}

void re::AssetLoader::checkCredentialsOfNetworkAsset(_WORD *a1@<X8>)
{
  *a1 = 257;
}

uint64_t re::AssetLoader::needsCustomSerializationCopy(re::AssetLoader *this, void *a2)
{
  return 0;
}

uint64_t re::AssetLoader::tryMakeCustomSerializationCopy(re::AssetLoader *this, void *a2)
{
  return 0;
}

void std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::~__func()
{
}

void *std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_26E6CD018;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6CD018;
  a2[1] = v2;
  return result;
}

re::AssetHandle *std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::operator()(uint64_t a1, re::AssetHandle **a2)
{
  return re::DynamicArray<re::AssetHandle>::add(*(_anonymous_namespace_ **)(a1 + 8), *a2);
}

uint64_t std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AssetLoader::findDependencies(void *)::$_0,std::allocator<re::AssetLoader::findDependencies(void *)::$_0>,void ()(re::AssetHandle *)>::target_type()
{
}

void *std::__function::__value_func<void ()(re::AssetHandle *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::~__func()
{
}

void *std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_26E6CD0A8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6CD0A8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  return re::DynamicArray<re::TransitionCondition *>::add(*(void **)(a1 + 8), &v3);
}

uint64_t std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0,std::allocator<re::AssetLoader::internalFindAssetHandleFields(void *)::$_0>,void ()(re::AssetHandle *)>::target_type()
{
}

void re::internal::CallableRef<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::~CallableRef()
{
}

uint64_t re::internal::CallableRef<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void, void))(***(void ***)(a1 + 8) + 56))(**(void **)(a1 + 8), a2, *(void *)(*(void *)(a1 + 8) + 8), 0);
}

uint64_t re::internal::CallableRef<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::cloneInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(_OWORD **)(a1 + 8);
  *(void *)a2 = &unk_26E6CD190;
  *(_OWORD *)(a2 + 8) = *v2;
  return a2;
}

uint64_t re::internal::CallableRef<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::moveInto(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 24))();
}

uint64_t re::internal::CallableRef<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::size()
{
  return 24;
}

void re::internal::Callable<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::~Callable()
{
}

uint64_t re::internal::Callable<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void, void))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), a2, *(void *)(a1 + 16), 0);
}

uint64_t re::internal::Callable<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6CD190;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6CD190;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::AssetLoader::makeSharedResourcePayload(void *,re::AssetSerializationScheme *)::$_0,BOOL ()(re::StreamWriter &)>::size()
{
  return 24;
}

void std::__function::__func<re::AssetLoader::serializableAsset(void *)::$_0,std::allocator<re::AssetLoader::serializableAsset(void *)::$_0>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<re::AssetLoader::serializableAsset(void *)::$_0,std::allocator<re::AssetLoader::serializableAsset(void *)::$_0>,void ()(void *)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_26E6CD1E8;
  return result;
}

void std::__function::__func<re::AssetLoader::serializableAsset(void *)::$_0,std::allocator<re::AssetLoader::serializableAsset(void *)::$_0>,void ()(void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6CD1E8;
}

uint64_t std::__function::__func<re::AssetLoader::serializableAsset(void *)::$_0,std::allocator<re::AssetLoader::serializableAsset(void *)::$_0>,void ()(void *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AssetLoader::serializableAsset(void *)::$_0,std::allocator<re::AssetLoader::serializableAsset(void *)::$_0>,void ()(void *)>::target_type()
{
}

re::AssetLoadRequest *re::AssetLoadRequest::makeAssetLoadRequest@<X0>(re::AssetLoadRequest *this@<X0>, re::AssetLoadRequest **a2@<X8>)
{
                                                    + 32))();
  double result = re::AssetLoadRequest::AssetLoadRequest(v3);
  *a2 = result;
  return result;
}

void anonymous namespace'::assetLoadRequestAllocator(_anonymous_namespace_ *this)
{
  {
    byte_26879E520 = 0;
    *(void *)algn_26879E518 = "AssetLoadRequest allocator";
  }
}

re::AssetLoadRequest *re::AssetLoadRequest::AssetLoadRequest(re::AssetLoadRequest *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *((void *)this + 3) = 0;
  *(void *)this = &unk_26E6CD268;
  uint64_t v4 = re::AssetLoadRequest::Data::Data(v3);
  uint64_t v5 = *((void *)this + 3);
  *((void *)this + 3) = v4;
  if (v5) {

  }
  return this;
}

re::AssetLoadRequest::Data *re::AssetLoadRequest::Data::Data(re::AssetLoadRequest::Data *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *((void *)this + 3) = 0;
  *(void *)this = &unk_26E6CD298;
  *((void *)this + 7) = 0;
  *((unsigned char *)this + 64) = 0;
  *((_WORD *)this + 40) = 0;
  *((unsigned char *)this + 82) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((void *)this + 15) = 0;
  re::DynamicString::setCapacity((void *)this + 12, 0);
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((unsigned char *)this + 144) = 0;
  *((_DWORD *)this + 48) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 25) = 0;
  *((_DWORD *)this + 56) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 260) = 0u;
  *(void *)((char *)this + 276) = 0x7FFFFFFFLL;
  *((void *)this + 37) = 0;
  *((void *)this + 38) = 0;
  *((void *)this + 36) = 0;
  *((_DWORD *)this + 78) = 1;
  *((_DWORD *)this + 84) = 0;
  *((void *)this + 40) = 0;
  *((void *)this + 41) = 0;
  *(void *)((char *)this + 349) = 0;
  *((void *)this + 43) = 0;
  return this;
}

void re::AssetLoadRequest::setShouldLoadAndWaitForResourceSharingClients(re::AssetLoadRequest *this@<X0>, char a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8 = (os_unfair_lock_s *)(*((void *)this + 3) + 192);
  os_unfair_lock_lock(v8);
  uint64_t v9 = (unsigned char *)*((void *)this + 3);
  if (v9[352])
  {
    std::chrono::system_clock::time_point v10 = "Cannot call AssetLoadRequest::setShouldLoadAndWaitForResourceSharingClients after the AssetLoadRequest already"
          " has assets added.";
  }
  else
  {
    if (!a3 || (a2 & 1) != 0)
    {
      v9[80] = a2;
      v9[81] = a3;
      *(unsigned char *)a4 = 1;
      goto LABEL_8;
    }
    std::chrono::system_clock::time_point v10 = "Cannot call AssetLoadRequest::setShouldLoadAndWaitForResourceSharingClients(BOOL shouldLoad, BOOL shouldWait) "
          "with shouldLoad set to false and shouldWait set to true. An AssetLoadRequest can't wait for preloading if it w"
          "ill not initiate preloading.";
  }
  re::WrappedError::make((re::WrappedError *)@"REAssetRefErrorDomain", (const __CFString *)4, (uint64_t)v10, &v12);
  uint64_t v11 = v12;
  uint64_t v12 = 0;
  *(unsigned char *)a4 = 0;
  *(void *)(a4 + 8) = v11;

LABEL_8:
  os_unfair_lock_unlock(v8);
}

void re::AssetLoadRequest::setShouldBlockECSSendsUntilCompleted(re::AssetLoadRequest *this@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (os_unfair_lock_s *)(*((void *)this + 3) + 192);
  os_unfair_lock_lock(v6);
  uint64_t v7 = *((void *)this + 3);
  if (*(unsigned char *)(v7 + 352))
  {
    re::WrappedError::make((re::WrappedError *)@"REAssetRefErrorDomain", (const __CFString *)4, (uint64_t)"Cannot call AssetLoadRequest::setShouldBlockECSSendsUntilCompleted after the AssetLoadRequest already has assets added.", &v10);
    uint64_t v8 = v10;
    uint64_t v10 = 0;
    *(void *)(a3 + 8) = v8;

    char v9 = 0;
  }
  else
  {
    *(unsigned char *)(v7 + 82) = a2;
    char v9 = 1;
  }
  *(unsigned char *)a3 = v9;
  os_unfair_lock_unlock(v6);
}

uint64_t re::AssetLoadRequest::Data::addAsset(re::AssetLoadRequest::Data *this, const re::AssetHandle *a2)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  uint64_t v49 = 0;
  v46[1] = 0;
  uint64_t v47 = 0;
  v46[0] = 0;
  int v48 = 0;
  int v44 = 0;
  memset(v43, 0, sizeof(v43));
  uint64_t v45 = 0x7FFFFFFFLL;
  re::AssetManager::getAssetDependenciesFromAssetProvidersRecursive(*((void *)this + 3), (_anonymous_namespace_ *)v46, (uint64_t)v43, a2, 1, (uint64_t)v41);
  if (!v41[0])
  {
    uint64_t v5 = *re::assetsLogObjects(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v38 = re::AssetHandle::assetInfo(a2);
      if (v38[17]) {
        uint64_t v39 = (char *)v38[18];
      }
      else {
        uint64_t v39 = (char *)v38 + 137;
      }
      uint64_t v40 = re::WrappedError::localizedDescription(&v42);
      *(_DWORD *)long long v55 = 136315394;
      *(void *)&v55[4] = v39;
      *(_WORD *)&v55[12] = 2080;
      *(void *)&v55[14] = v40;
      _os_log_error_impl(&dword_233120000, v5, OS_LOG_TYPE_ERROR, "Failed to add dependencies of asset '%s' to the load request due to error: %s", v55, 0x16u);
    }
    uint64_t v6 = v47;
    uint64_t v47 = 0;
    if (v6)
    {
      uint64_t v7 = v49;
      uint64_t v8 = 24 * v6;
      do
      {
        re::AssetHandle::~AssetHandle(v7);
        uint64_t v7 = (re::AssetHandle *)(v9 + 24);
        v8 -= 24;
      }
      while (v8);
    }
    ++v48;
  }
  uint64_t v10 = *((void *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 1600));
  re::DynamicOverflowArray<unsigned long long,1ul>::DynamicOverflowArray((uint64_t)v55, (uint64_t *)(v10 + 1608));
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 1600));
  os_unfair_lock_lock((os_unfair_lock_t)this + 48);
  int v11 = *((_DWORD *)this + 84);
  int v13 = *re::assetsLogObjects(v12);
  if (v11 == 2)
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      long long v34 = re::AssetHandle::assetInfo(a2);
      if (v34[17]) {
        uint64_t v35 = (char *)v34[18];
      }
      else {
        uint64_t v35 = (char *)v34 + 137;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v35;
      _os_log_error_impl(&dword_233120000, v13, OS_LOG_TYPE_ERROR, "AssetLoadRequest can't add asset '%s' because it is in the kError state", buf, 0xCu);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 48);
  }
  else
  {
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      long long v36 = re::AssetHandle::assetInfo(a2);
      if (v36[17]) {
        uint64_t v37 = (char *)v36[18];
      }
      else {
        uint64_t v37 = (char *)v36 + 137;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v37;
      _os_log_debug_impl(&dword_233120000, v13, OS_LOG_TYPE_DEBUG, "AssetLoadRequest add '%s'", buf, 0xCu);
    }
    if (*((unsigned char *)this + 356))
    {
      uint64_t v14 = (char *)this + 296;
      id v15 = v55;
    }
    else
    {
      *((unsigned char *)this + 356) = 1;
      id v15 = (char *)this + 296;
      uint64_t v14 = v55;
    }
    if (v15 != v14)
    {
      uint64_t v16 = *(void *)v14;
      if (*(void *)v15)
      {
        if (v16) {
          re::DynamicOverflowArray<unsigned long long,1ul>::copy((uint64_t)v15, (uint64_t)v14);
        }
        else {
          *((void *)v15 + 1) = 0;
        }
        *((_DWORD *)v15 + 4) += 2;
      }
      else if (v16)
      {
        unint64_t v17 = *((void *)v14 + 1);
        *(void *)id v15 = v16;
        re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(v15, v17);
        *((_DWORD *)v15 + 4) += 2;
        re::DynamicOverflowArray<unsigned long long,1ul>::copy((uint64_t)v15, (uint64_t)v14);
      }
    }
    if (*((_DWORD *)this + 84)) {
      *((_DWORD *)this + 84) = 0;
    }
    if (!*((unsigned char *)this + 352))
    {
      uint64_t v18 = *((void *)re::AssetHandle::assetInfo(a2) + 10);
      if (v18 == -1) {
        uint64_t v18 = 0;
      }
      *((void *)this + 11) = v18;
      uint64_t v19 = (char *)re::AssetHandle::assetInfo(a2);
      if (*((void *)v19 + 17)) {
        uint64_t v20 = (const char *)*((void *)v19 + 18);
      }
      else {
        uint64_t v20 = v19 + 137;
      }
      size_t v21 = strlen(v20);
      *(void *)long long buf = v20;
      *(void *)&uint8_t buf[8] = v21;
      char v22 = re::DynamicString::operator=((re::AssetLoadRequest::Data *)((char *)this + 96), (uint64_t)buf);
      id v23 = *re::assetsLogObjects(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = *((void *)this + 11);
        if (*((unsigned char *)this + 104)) {
          uint64_t v25 = (char *)*((void *)this + 14);
        }
        else {
          uint64_t v25 = (char *)this + 105;
        }
        int v26 = *((unsigned __int8 *)this + 81);
        int v27 = *((unsigned __int8 *)this + 82);
        *(_DWORD *)long long buf = 134218754;
        *(void *)&uint8_t buf[4] = v24;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v25;
        __int16 v51 = 1024;
        int v52 = v26;
        __int16 v53 = 1024;
        int v54 = v27;
        _os_log_impl(&dword_233120000, v23, OS_LOG_TYPE_DEFAULT, "AssetLoadRequest started loading first asset with id %llu (%s). m_shouldWaitForPeers = %u, m_shouldBlockECSUpdatesUntilCompleted = %u", buf, 0x22u);
      }
      *((std::chrono::steady_clock::time_point *)this + 16) = std::chrono::steady_clock::now();
      *((unsigned char *)this + 144) = 1;
    }
    *((unsigned char *)this + 352) = 1;
    if (v55[16]) {
      uint64_t v28 = &v56;
    }
    else {
      uint64_t v28 = v57;
    }
    *(void *)long long buf = v28;
    *(void *)&uint8_t buf[8] = *(void *)&v55[8];
    *((unsigned char *)this + 354) = re::AssetLoadRequest::Data::addAssetToLoadingSet_stateLocked((uint64_t)this, (uint64_t *)a2, (uint64_t)buf) ^ 1;
    if (v47)
    {
      uint64_t v29 = (uint64_t *)v49;
      uint64_t v30 = 24 * v47;
      do
      {
        if (v55[16]) {
          int v31 = &v56;
        }
        else {
          int v31 = v57;
        }
        *(void *)long long buf = v31;
        *(void *)&uint8_t buf[8] = *(void *)&v55[8];
        int v32 = re::AssetLoadRequest::Data::addAssetToLoadingSet_stateLocked((uint64_t)this, v29, (uint64_t)buf) ^ 1;
        if (*((unsigned char *)this + 354)) {
          LOBYTE(v32) = 1;
        }
        *((unsigned char *)this + 354) = v32;
        v29 += 3;
        v30 -= 24;
      }
      while (v30);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 48);
    atomic_store(1u, (unsigned __int8 *)(*((void *)this + 3) + 640));
  }
  if (*(void *)v55 && (v55[16] & 1) == 0) {
    (*(void (**)(void))(**(void **)v55 + 40))();
  }
  if (!v41[0]) {

  }
  re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v43);
  return re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v46);
}

uint64_t re::AssetLoadRequest::Data::addAssetToLoadingSet_stateLocked(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (a2[1]
    && (uint64_t v6 = a1 + 240,
        !re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::contains(a1 + 240, (uint64_t)a2)))
  {
    re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(v6, (re::AssetHandle *)a2);
    unsigned int v8 = atomic_load((unsigned int *)(a2[1] + 704));
    int canShareAssetOverNetwork = re::AssetManager::canShareAssetOverNetwork(*(os_unfair_lock_s **)(a1 + 24), (const re::AssetHandle *)a2);
    memset(v25, 0, sizeof(v25));
    char v27 = 0;
    re::AssetHandle::operator=((uint64_t)v25, a2);
    char v26 = canShareAssetOverNetwork;
    uint64_t v9 = *(void *)(a1 + 24);
    if (*(unsigned char *)(a1 + 81)) {
      *(_OWORD *)long long buf = *(_OWORD *)a3;
    }
    else {
      memset(buf, 0, 16);
    }
    CombinedLoadState = (re *)re::AssetManager::getCombinedLoadState(v9, (re::AssetHandle *)v25, canShareAssetOverNetwork, v8, (uint64_t)buf);
    switch(CombinedLoadState)
    {
      case 2:
        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add(a1 + 200, (re::AssetHandle *)v25);
        uint64_t v14 = *(void *)(a1 + 288);
        if (v14) {
          re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(v14 + 24, (re::AssetHandle *)a2);
        }
        if (*(unsigned char *)(a1 + 81)) {
          *(_OWORD *)long long buf = *(_OWORD *)a3;
        }
        else {
          memset(buf, 0, 16);
        }
        re::AssetLoadRequest::Data::processFailedAsset_stateLocked(a1, a2[1], (uint64_t)buf);
        LOBYTE(canShareAssetOverNetwork) = 0;
        break;
      case 1:
        LOBYTE(canShareAssetOverNetwork) = re::AssetLoadRequest::Data::checkAssetDependencies_stateLocked(a1, (uint64_t)v25, a3);
        break;
      case 0:
        if (*(unsigned char *)(a1 + 80))
        {
          if (*(void *)(a3 + 8))
          {
            if (v26)
            {
              uint64_t v12 = *(void *)(a1 + 24);
              if (*(void *)(v12 + 1144))
              {
                if (!*(unsigned char *)(v12 + 1379))
                {
                  CombinedLoadState = (re *)re::AssetHandle::assetInfo((re::AssetHandle *)a2);
                  uint64_t v11 = *((void *)CombinedLoadState + 10);
                  if ((unint64_t)(v11 + 1) >= 2) {
                    re::NetworkActionQueue::queueSyncActionPreloadOnLocalPeer((re::NetworkActionQueue *)(*(void *)(a1 + 24) + 704), v11);
                  }
                }
              }
            }
          }
        }
        switch(v8)
        {
          case 0u:
            int v13 = *re::assetsLogObjects(CombinedLoadState);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            {
              size_t v21 = re::AssetHandle::assetInfo((re::AssetHandle *)a2);
              if (v21[17]) {
                char v22 = (char *)v21[18];
              }
              else {
                char v22 = (char *)v21 + 137;
              }
              *(_DWORD *)long long buf = 136315138;
              *(void *)&uint8_t buf[4] = v22;
              _os_log_debug_impl(&dword_233120000, v13, OS_LOG_TYPE_DEBUG, "AssetLoadRequest async loading '%s'", buf, 0xCu);
            }
            re::AssetManager::loadAssetAsync(*(re::AssetManager **)(a1 + 24), (os_unfair_lock_s *)a2[1], 0);
            goto LABEL_33;
          case 1u:
            id v15 = *re::assetsLogObjects(CombinedLoadState);
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_33;
            }
            uint64_t v16 = re::AssetHandle::assetInfo((re::AssetHandle *)a2);
            if (v16[17]) {
              unint64_t v17 = (char *)v16[18];
            }
            else {
              unint64_t v17 = (char *)v16 + 137;
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v17;
            uint64_t v18 = "AssetLoadRequest already loading '%s'";
            break;
          case 2u:
            id v15 = *re::assetsLogObjects(CombinedLoadState);
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_33;
            }
            id v23 = re::AssetHandle::assetInfo((re::AssetHandle *)a2);
            if (v23[17]) {
              uint64_t v24 = (char *)v23[18];
            }
            else {
              uint64_t v24 = (char *)v23 + 137;
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v24;
            uint64_t v18 = "AssetLoadRequest already loaded '%s', but still waiting on peer";
            break;
          case 3u:
            re::internal::assertLog((re::internal *)4, v11, "assertion failure: '%s' (%s:line %i) The combined load state is not kFailed even though the local load state is kLoadFailed.", "!\"Unreachable code\"", "addAssetToLoadingSet_stateLocked", 238);
            _os_crash();
            __break(1u);
            JUMPOUT(0x2333C4648);
          default:
            goto LABEL_33;
        }
        _os_log_debug_impl(&dword_233120000, v15, OS_LOG_TYPE_DEBUG, v18, buf, 0xCu);
LABEL_33:
        LOBYTE(canShareAssetOverNetwork) = re::AssetLoadRequest::Data::checkAssetDependencies_stateLocked(a1, (uint64_t)v25, a3);
        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add(a1 + 200, (re::AssetHandle *)v25);
        uint64_t v19 = *(void *)(a1 + 288);
        if (v19) {
          re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(v19 + 24, (re::AssetHandle *)a2);
        }
        break;
    }
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v25);
  }
  else
  {
    LOBYTE(canShareAssetOverNetwork) = 1;
  }
  return canShareAssetOverNetwork & 1;
}

uint64_t re::AssetLoadRequest::Data::checkAssetDependencies_stateLocked(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 25)) {
    return 1;
  }
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v16 = 0;
  int hasLoadingAssetPointer = re::internal::AssetEntry::hasLoadingAssetPointer((re::internal::AssetEntry *)v7);
  uint64_t v9 = 712;
  if (hasLoadingAssetPointer) {
    uint64_t v9 = 720;
  }
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(&v16, *(void *)(v7 + v9));
  if (!v16) {
    return 1;
  }
  *(unsigned char *)(a2 + 25) = 1;
  uint64_t v11 = *re::assetsLogObjects(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    if (*(unsigned char *)(v7 + 168)) {
      uint64_t v15 = *(void *)(v7 + 176);
    }
    else {
      uint64_t v15 = v7 + 169;
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v18 = v15;
    _os_log_debug_impl(&dword_233120000, v11, OS_LOG_TYPE_DEBUG, "AssetLoadRequest getting dependencies for '%s'", buf, 0xCu);
  }
  uint64_t v12 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)(*(void *)(a1 + 24) + 1040), *(void *)(v7 + 264));
  (*(void (**)(uint8_t *__return_ptr))(*(void *)v12 + 104))(buf);
  if (!v19)
  {
LABEL_11:
    re::DynamicArray<re::AssetHandle>::deinit((uint64_t)buf);
    if (v16) {

    }
    return 1;
  }
  uint64_t v13 = v20;
  uint64_t v14 = 24 * v19;
  while ((re::AssetLoadRequest::Data::addAssetToLoadingSet_stateLocked(a1, v13, a3) & 1) != 0)
  {
    v13 += 24;
    v14 -= 24;
    if (!v14) {
      goto LABEL_11;
    }
  }
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)buf);
  if (v16) {

  }
  return 0;
}

re::AssetHandle *re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add(uint64_t a1, re::AssetHandle *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  double result = re::AssetHandle::AssetHandle((re::AssetHandle *)(*(void *)(a1 + 32) + 32 * v5), a2);
  *((_WORD *)result + 12) = *((_WORD *)a2 + 12);
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::AssetLoadRequest::Data::processFailedAsset_stateLocked(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  unint64_t v6 = (os_unfair_lock_s *)(a2 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 384));
  uint64_t v8 = *(void *)(a2 + 728);
  if (*(unsigned char *)(v8 + 208))
  {
    if (*(unsigned char *)(v8 + 224)) {
      unint64_t v9 = *(const char **)(v8 + 232);
    }
    else {
      unint64_t v9 = (const char *)(v8 + 225);
    }
  }
  else
  {
    unint64_t v9 = "Load failure on peer.";
  }
  unint64_t v10 = *re::assetsLogObjects(v7);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    if (*(unsigned char *)(a2 + 168)) {
      uint64_t v26 = *(void *)(a2 + 176);
    }
    else {
      uint64_t v26 = a2 + 169;
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v26;
    __int16 v29 = 2080;
    *(void *)uint64_t v30 = v9;
    _os_log_error_impl(&dword_233120000, v10, OS_LOG_TYPE_ERROR, "AssetLoadRequest failed because asset failed to load '%s' (%s)", buf, 0x16u);
  }
  *(_DWORD *)(a1 + 336) = 2;
  if (*(unsigned char *)(a2 + 168)) {
    uint64_t v11 = *(void *)(a2 + 176);
  }
  else {
    uint64_t v11 = a2 + 169;
  }
  re::DynamicString::format((re::DynamicString *)"failed to load '%s' (%s)", (re::DynamicString *)buf, v11, v9);
  if (buf[8]) {
    uint64_t v12 = *(unsigned char **)&v30[2];
  }
  else {
    uint64_t v12 = &buf[9];
  }
  re::WrappedError::make((re::WrappedError *)@"REAssetLoadRequestErrorDomain", (const __CFString *)0xC8, (uint64_t)v12, &v27);
  uint64_t v13 = (id *)(a1 + 344);
  if (v13 != &v27)
  {
    id v14 = v27;
    id v27 = 0;
    id v15 = *v13;
    *uint64_t v13 = v14;
  }
  uint64_t v16 = *(void *)(a3 + 8);
  if (v16)
  {
    unint64_t v17 = *(void **)a3;
    uint64_t v18 = *(void *)a3 + 8 * v16;
    uint64_t v19 = *(void *)(a2 + 528);
    while (1)
    {
      uint64_t v20 = a2 + 544;
      if ((*(_DWORD *)(a2 + 536) & 1) == 0) {
        uint64_t v20 = *(void *)(a2 + 552);
      }
      if (v19)
      {
        uint64_t v21 = (_DWORD *)(v20 + 28);
        uint64_t v22 = 32 * v19;
        while (*(void *)(v21 - 7) != *v17)
        {
          v21 += 8;
          v22 -= 32;
          if (!v22) {
            goto LABEL_26;
          }
        }
        if (*((unsigned char *)v21 - 4) && *v21 == 400) {
          break;
        }
      }
LABEL_26:
      if (++v17 == (void *)v18) {
        goto LABEL_27;
      }
    }
    re::DynamicString::append((re::DynamicString *)buf, " Resource memory limit hit cannot load asset!", 0x2DuLL);
    if (buf[8]) {
      id v23 = *(unsigned char **)&v30[2];
    }
    else {
      id v23 = &buf[9];
    }
    re::WrappedError::make((re::WrappedError *)@"REResourceLimitErrorDomain", (const __CFString *)0x12C, (uint64_t)v23, &v27);
    if (v13 != &v27)
    {
      id v24 = v27;
      id v27 = 0;
      id v25 = *v13;
      *uint64_t v13 = v24;
    }
  }
LABEL_27:
  if (*(void *)buf && (buf[8] & 1) != 0) {
    (*(void (**)(void))(**(void **)buf + 40))();
  }
  os_unfair_lock_unlock(v6);
}

void re::AssetLoadRequest::Data::update(os_unfair_lock_s *this)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  uint64_t v2 = this + 48;
  os_unfair_lock_lock(this + 48);
  unsigned int v4 = this[84]._os_unfair_lock_opaque - 1;
  if (v4 <= 1)
  {
    if (!BYTE2(this[88]._os_unfair_lock_opaque))
    {
      os_unfair_lock_unlock(v2);
      return;
    }
    BYTE2(this[88]._os_unfair_lock_opaque) = 0;
  }
  uint64_t os_unfair_lock_opaque = this[68]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (int *)(*(void *)&this[64]._os_unfair_lock_opaque + 8);
    while (1)
    {
      int v8 = *v7;
      v7 += 10;
      if (v8 < 0) {
        break;
      }
      if (os_unfair_lock_opaque == ++v6)
      {
        LODWORD(v6) = this[68];
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if (os_unfair_lock_opaque != v6)
  {
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *(void *)(*(void *)&this[64]._os_unfair_lock_opaque + 40 * v9 + 24);
      if (!atomic_load((unsigned int *)(v10 + 704)))
      {
        uint64_t v21 = *re::assetsLogObjects(v3);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          if (*(unsigned char *)(v10 + 168)) {
            uint64_t v48 = *(void *)(v10 + 176);
          }
          else {
            uint64_t v48 = v10 + 169;
          }
          *(_DWORD *)long long buf = 136315138;
          *(void *)&uint8_t buf[4] = v48;
          _os_log_error_impl(&dword_233120000, v21, OS_LOG_TYPE_ERROR, "AssetLoadRequest failed because asset got unloaded '%s'", buf, 0xCu);
        }
        LODWORD(v14) = 1;
        goto LABEL_82;
      }
      if (this[68]._os_unfair_lock_opaque <= (v6 + 1)) {
        uint32_t v12 = v6 + 1;
      }
      else {
        uint32_t v12 = this[68]._os_unfair_lock_opaque;
      }
      while (1)
      {
        uint64_t v9 = (v6 + 1);
        if (v12 - 1 == v6) {
          break;
        }
        LODWORD(v6) = v6 + 1;
        uint32_t v13 = v9;
        if ((*(_DWORD *)(*(void *)&this[64]._os_unfair_lock_opaque + 40 * v9 + 8) & 0x80000000) != 0) {
          goto LABEL_20;
        }
      }
      uint32_t v13 = v12;
LABEL_20:
      LODWORD(v6) = v13;
    }
    while (os_unfair_lock_opaque != v13);
  }
  unint64_t v14 = 1;
  if (v4 < 2) {
    goto LABEL_82;
  }
  uint64_t v15 = *(void *)&this[6]._os_unfair_lock_opaque;
  os_unfair_lock_lock((os_unfair_lock_t)(v15 + 1600));
  re::DynamicOverflowArray<unsigned long long,1ul>::DynamicOverflowArray((uint64_t)v56, (uint64_t *)(v15 + 1608));
  os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 1600));
  __int16 v51 = 0;
  uint64_t v52 = 0;
  int v53 = 1;
  unint64_t v54 = 0;
  long long v55 = 0;
  if (LOBYTE(this[89]._os_unfair_lock_opaque))
  {
    unint64_t v17 = *(void *)&this[76]._os_unfair_lock_opaque;
    re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(&v51, v17);
    char v18 = v53;
    v53 += 2;
    if (v18) {
      unint64_t v19 = 1;
    }
    else {
      unint64_t v19 = v54;
    }
    if (v19 < v17) {
      re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(&v51, v17);
    }
    if (this[78]._os_unfair_lock_opaque) {
      uint64_t v20 = this + 80;
    }
    else {
      uint64_t v20 = *(os_unfair_lock_s **)&this[82]._os_unfair_lock_opaque;
    }
    uint64_t v22 = *(void *)&this[76]._os_unfair_lock_opaque;
    if (v22)
    {
      unint64_t v14 = 8 * v22;
      do
      {
        *(void *)uint64_t v59 = *(void *)&v20->_os_unfair_lock_opaque;
        re::DynamicOverflowArray<unsigned long long,1ul>::indexOf((uint64_t)v56, v59, (uint64_t)buf);
        if (buf[0]) {
          re::DynamicOverflowArray<unsigned long long,1ul>::add((uint64_t)&v51, v59);
        }
        v20 += 2;
        v14 -= 8;
      }
      while (v14);
    }
  }
  if ((int)*(void *)&this[54]._os_unfair_lock_opaque < 1)
  {
LABEL_64:
    LODWORD(v14) = 0;
    goto LABEL_76;
  }
  uint64_t v23 = *(void *)&this[54]._os_unfair_lock_opaque + 1;
  while (1)
  {
    unint64_t v24 = (v23 - 2);
    unint64_t v25 = *(void *)&this[54]._os_unfair_lock_opaque;
    if (v25 <= v24)
    {
      uint64_t v58 = 0;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      *(_OWORD *)long long buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v59 = 136315906;
      *(void *)&v59[4] = "operator[]";
      *(_WORD *)&v59[12] = 1024;
      *(_DWORD *)&v59[14] = 789;
      __int16 v60 = 2048;
      uint64_t v61 = (v23 - 2);
      __int16 v62 = 2048;
      unint64_t v63 = v25;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_94:
      uint64_t v58 = 0;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      *(_OWORD *)long long buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v59 = 136315906;
      *(void *)&v59[4] = "operator[]";
      *(_WORD *)&v59[12] = 1024;
      *(_DWORD *)&v59[14] = 789;
      __int16 v60 = 2048;
      uint64_t v61 = (v23 - 2);
      __int16 v62 = 2048;
      unint64_t v63 = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_95:
      uint64_t v58 = 0;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      *(_OWORD *)long long buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v59 = 136315906;
      *(void *)&v59[4] = "operator[]";
      *(_WORD *)&v59[12] = 1024;
      *(_DWORD *)&v59[14] = 789;
      __int16 v60 = 2048;
      uint64_t v61 = (v23 - 2);
      __int16 v62 = 2048;
      unint64_t v63 = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_96:
      uint64_t v58 = 0;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      *(_OWORD *)long long buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v59 = 136315906;
      *(void *)&v59[4] = "operator[]";
      *(_WORD *)&v59[12] = 1024;
      *(_DWORD *)&v59[14] = 789;
      __int16 v60 = 2048;
      uint64_t v61 = (v23 - 2);
      __int16 v62 = 2048;
      unint64_t v63 = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_97:
      re::internal::assertLog((re::internal *)4, v40, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "update", 345);
      _os_crash();
      __break(1u);
    }
    re::AssetHandle::AssetHandle((re::AssetHandle *)v49, (const re::AssetHandle *)(*(void *)&this[58]._os_unfair_lock_opaque + 32 * v24));
    unsigned int v26 = atomic_load((unsigned int *)(v50 + 704));
    unint64_t v14 = *(void *)&this[54]._os_unfair_lock_opaque;
    if (v14 <= v24) {
      goto LABEL_94;
    }
    uint64_t v27 = *(void *)&this[58]._os_unfair_lock_opaque + 32 * v24;
    if (v53) {
      uint64_t v28 = &v54;
    }
    else {
      uint64_t v28 = v55;
    }
    *(void *)long long buf = v28;
    *(void *)&uint8_t buf[8] = v52;
    if (!re::AssetLoadRequest::Data::checkAssetDependencies_stateLocked((uint64_t)this, v27, (uint64_t)buf)) {
      goto LABEL_75;
    }
    unint64_t v14 = *(void *)&this[54]._os_unfair_lock_opaque;
    if (v14 <= v24) {
      goto LABEL_95;
    }
    unint64_t v14 = *(void *)&this[6]._os_unfair_lock_opaque;
    int v29 = *(unsigned __int8 *)(*(void *)&this[58]._os_unfair_lock_opaque + 32 * v24 + 24);
    if (BYTE1(this[20]._os_unfair_lock_opaque))
    {
      re::DynamicOverflowArray<unsigned long long,1ul>::DynamicOverflowArray((uint64_t)buf, (uint64_t *)&v51);
      char v30 = v65;
      uint64_t v31 = (char *)v66;
      uint64_t v32 = *(void *)&buf[8];
    }
    else
    {
      uint64_t v32 = 0;
      uint64_t v31 = 0;
      memset(buf, 0, sizeof(buf));
      char v30 = 1;
      LODWORD(v65) = 1;
      *((void *)&v65 + 1) = 0;
      *(void *)&long long v66 = 0;
    }
    if (v30) {
      uint64_t v31 = (char *)&v65 + 8;
    }
    *(void *)uint64_t v59 = v31;
    *(void *)&v59[8] = v32;
    int CombinedLoadState = re::AssetManager::getCombinedLoadState(v14, (re::AssetHandle *)v49, v29 != 0, v26, (uint64_t)v59);
    if (*(void *)buf && (v65 & 1) == 0) {
      (*(void (**)(void))(**(void **)buf + 40))();
    }
    if (CombinedLoadState)
    {
      unint64_t v14 = *(void *)&this[54]._os_unfair_lock_opaque;
      if (v14 <= v24) {
        goto LABEL_96;
      }
      if (v14 - 1 > v24)
      {
        uint64_t v34 = *(void *)&this[58]._os_unfair_lock_opaque;
        uint64_t v35 = v34 + 32 * v14;
        long long v36 = (long long *)(v34 + 32 * v24);
        long long v37 = *v36;
        *(void *)long long v36 = 0;
        uint64_t v38 = *(void *)(v35 - 24);
        *(void *)long long v36 = *(void *)(v35 - 32);
        *((void *)v36 + 1) = v38;
        *(_OWORD *)(v35 - 32) = v37;
        uint64_t v39 = *((void *)v36 + 2);
        *((void *)v36 + 2) = *(void *)(v35 - 16);
        *(void *)(v35 - 16) = v39;
        *((_WORD *)v36 + 12) = *(_WORD *)(v35 - 8);
        unint64_t v14 = *(void *)&this[54]._os_unfair_lock_opaque;
      }
      re::AssetHandle::~AssetHandle((re::AssetHandle *)(*(void *)&this[58]._os_unfair_lock_opaque + 32 * v14 - 32));
      --*(void *)&this[54]._os_unfair_lock_opaque;
      ++this[56]._os_unfair_lock_opaque;
      if (CombinedLoadState != 1) {
        break;
      }
    }
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v49);
    if ((unint64_t)--v23 <= 1) {
      goto LABEL_64;
    }
  }
  if (CombinedLoadState != 2) {
    goto LABEL_97;
  }
  if (BYTE1(this[20]._os_unfair_lock_opaque))
  {
    re::DynamicOverflowArray<unsigned long long,1ul>::DynamicOverflowArray((uint64_t)buf, (uint64_t *)&v51);
    uint64_t v41 = *(void *)&buf[8];
    if (v65) {
      id v42 = (char *)&v65 + 8;
    }
    else {
      id v42 = (char *)v66;
    }
  }
  else
  {
    uint64_t v41 = 0;
    memset(buf, 0, sizeof(buf));
    LODWORD(v65) = 1;
    id v42 = (char *)&v65 + 8;
    *((void *)&v65 + 1) = 0;
    *(void *)&long long v66 = 0;
  }
  *(void *)uint64_t v59 = v42;
  *(void *)&v59[8] = v41;
  re::AssetLoadRequest::Data::processFailedAsset_stateLocked((uint64_t)this, v50, (uint64_t)v59);
  if (*(void *)buf)
  {
    int v43 = v65;
    if ((v65 & 1) == 0)
    {
      (*(void (**)(void))(**(void **)buf + 40))();
      int v43 = v65;
    }
    LODWORD(v65) = (v43 | 1) + 2;
  }
LABEL_75:
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v49);
  LODWORD(v14) = 1;
LABEL_76:
  if (v51 && (v53 & 1) == 0) {
    (*(void (**)(void))(*v51 + 40))();
  }
  if (v56[0] && (v57 & 1) == 0) {
    (*(void (**)(void))(*(void *)v56[0] + 40))();
  }
LABEL_82:
  uint64_t v44 = *(void *)&this[54]._os_unfair_lock_opaque;
  int os_unfair_lock_opaque_low = LOBYTE(this[88]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2);
  re::AssetLoadRequest::Data::checkForLongLoadAndLogDetails(this);
  if (v14)
  {
    uint64_t v46 = (re::AssetLoadRequest::Data *)this;
    int v47 = 0;
    goto LABEL_87;
  }
  if (!v44 && os_unfair_lock_opaque_low)
  {
    uint64_t v46 = (re::AssetLoadRequest::Data *)this;
    int v47 = 1;
LABEL_87:
    re::AssetLoadRequest::Data::complete((uint64_t)v46, v47, 0);
  }
}

void re::AssetLoadRequest::Data::checkForLongLoadAndLogDetails(os_unfair_lock_s *this)
{
  v61[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = this + 48;
  os_unfair_lock_lock(this + 48);
  if (LOBYTE(this[36]._os_unfair_lock_opaque))
  {
    v3.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    double v4 = 0.0;
    if (LOBYTE(this[36]._os_unfair_lock_opaque)) {
      double v4 = 1.0;
    }
    double v5 = *(double *)&this[34]._os_unfair_lock_opaque
       + (double)(v3.__d_.__rep_ - *(void *)&this[32]._os_unfair_lock_opaque) / 1000000000.0 * v4;
    {
      int v47 = v2;
      uint64_t v7 = *(void *)&this[54]._os_unfair_lock_opaque;
      int v8 = *re::assetsLogObjects(v6);
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      if (v9)
      {
        uint64_t v10 = *(void *)&this[22]._os_unfair_lock_opaque;
        uint32_t v12 = "and contains these assets:";
        *(_DWORD *)long long buf = 134218498;
        *(void *)&uint8_t buf[4] = v10;
        if (!v7) {
          uint32_t v12 = "";
        }
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(double *)&buf[14] = LoggingThreshold;
        __int16 v59 = 2080;
        __int16 v60 = v12;
        _os_log_impl(&dword_233120000, v8, OS_LOG_TYPE_DEFAULT, "AssetLoadRequest with first assetId %llu exceeded loading threshold of %f seconds %s", buf, 0x20u);
      }
      uint64_t v48 = 0;
      while (1)
      {
        uint64_t v13 = *(void *)&this[54]._os_unfair_lock_opaque;
        if (v13) {
          break;
        }
LABEL_63:
        if (++v48 == 4)
        {
          *(double *)&this[34]._uint64_t os_unfair_lock_opaque = *(double *)&this[34]._os_unfair_lock_opaque
                                                      + (double)(std::chrono::steady_clock::now().__d_.__rep_
                                                               - *(void *)&this[32]._os_unfair_lock_opaque)
                                                      / 1000000000.0;
          LOBYTE(this[36]._os_unfair_lock_opaque) = 0;
          uint64_t v2 = v47;
          goto LABEL_65;
        }
      }
      int v14 = dword_234372A80[v48];
      uint64_t v15 = *(const re::AssetHandle **)&this[58]._os_unfair_lock_opaque;
      uint64_t v16 = (const re::AssetHandle *)((char *)v15 + 32 * v13);
      uint64_t v49 = v14 - 1;
      int v50 = v14;
      while (1)
      {
        uint64_t v17 = *((void *)v15 + 1);
        os_unfair_lock_lock((os_unfair_lock_t)(v17 + 384));
        unsigned int v18 = atomic_load((unsigned int *)(v17 + 704));
        if (v18 == v14) {
          break;
        }
LABEL_62:
        os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 384));
        uint64_t v15 = (const re::AssetHandle *)((char *)v15 + 32);
        if (v15 == v16) {
          goto LABEL_63;
        }
      }
      re::AssetHandle::AssetHandle((re::AssetHandle *)v51, v15);
      unint64_t v19 = (re *)re::AssetHandle::assetInfo((re::AssetHandle *)v51);
      if (*((void *)v19 + 17)) {
        uint64_t v20 = (char *)*((void *)v19 + 18);
      }
      else {
        uint64_t v20 = (char *)v19 + 137;
      }
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      *(_DWORD *)&uint8_t buf[16] = 1;
      __int16 v60 = 0;
      v61[0] = 0;
      if (!*(void *)(v17 + 520)) {
        goto LABEL_68;
      }
      unint64_t v21 = *(void *)(v17 + 528);
      *(void *)long long buf = *(void *)(v17 + 520);
      re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::setCapacity((uint64_t *)buf, v21);
      char v22 = buf[16];
      *(_DWORD *)&buf[16] += 2;
      unint64_t v23 = *(void *)(v17 + 528);
      if (v23 >= *(void *)&buf[8])
      {
        re::DynamicOverflowArray<re::internal::AssetEntry::State::ResourceSharingClientLoadState,1ul>::setCapacity((uint64_t *)buf, *(void *)(v17 + 528));
        if (*(_DWORD *)(v17 + 536)) {
          uint64_t v27 = (_DWORD *)(v17 + 544);
        }
        else {
          uint64_t v27 = *(_DWORD **)(v17 + 552);
        }
        if (buf[16]) {
          uint64_t v28 = &v60;
        }
        else {
          uint64_t v28 = (const char **)v61[0];
        }
        unint64_t v19 = (re *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState*>(v27, &v27[8 * *(void *)&buf[8]], (uint64_t)v28);
        if (*(unsigned char *)(v17 + 536)) {
          uint64_t v29 = v17 + 544;
        }
        else {
          uint64_t v29 = *(void *)(v17 + 552);
        }
        if (*(void *)&buf[8] != v23)
        {
          char v30 = (long long *)(v29 + 32 * v23);
          uint64_t v31 = (const char **)v61[0];
          if (buf[16]) {
            uint64_t v31 = &v60;
          }
          uint64_t v32 = (long long *)(v29 + 32 * *(void *)&buf[8]);
          long long v33 = &v31[4 * *(void *)&buf[8]];
          do
          {
            long long v34 = *v32;
            v33[2] = (const char *)*((void *)v32 + 2);
            *(_OWORD *)long long v33 = v34;
            int v35 = *((unsigned __int8 *)v32 + 24);
            *((unsigned char *)v33 + 24) = v35;
            if (v35) {
              *((_DWORD *)v33 + 7) = *((_DWORD *)v32 + 7);
            }
            v32 += 2;
            v33 += 4;
          }
          while (v32 != v30);
        }
      }
      else
      {
        int v24 = v22 & 1;
        unint64_t v25 = (*(_DWORD *)(v17 + 536) & 1) != 0 ? (_DWORD *)(v17 + 544) : *(_DWORD **)(v17 + 552);
        unsigned int v26 = v24 ? &v60 : (const char **)v61[0];
        unint64_t v19 = (re *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState*>(v25, &v25[8 * v23], (uint64_t)v26);
      }
      *(void *)&uint8_t buf[8] = v23;
      if (v23)
      {
        long long v36 = *re::assetsLogObjects(v19);
        if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_58;
        }
        long long v37 = "Unloaded";
        if (v49 <= 2) {
          long long v37 = off_264BE2580[v49];
        }
        uint64_t v38 = (_DWORD *)(v61[0] + 8);
        if (buf[16]) {
          uint64_t v38 = v61;
        }
        unsigned int v39 = *v38 - 1;
        uint64_t v40 = "Unloaded";
        if (v39 <= 2) {
          uint64_t v40 = off_264BE2580[v39];
        }
        *(_DWORD *)uint64_t v52 = 136315650;
        int v53 = v20;
        __int16 v54 = 2080;
        long long v55 = v37;
        __int16 v56 = 2080;
        char v57 = v40;
        uint64_t v41 = v36;
        id v42 = "%s has local load state: %s and backboardd load state is: %s";
        uint32_t v43 = 32;
      }
      else
      {
LABEL_68:
        if (LOBYTE(this[20]._os_unfair_lock_opaque))
        {
          uint64_t v44 = *re::assetsLogObjects(v19);
          unint64_t v19 = (re *)os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT);
          if (v19)
          {
            *(_DWORD *)uint64_t v52 = 136315138;
            int v53 = v20;
            _os_log_impl(&dword_233120000, v44, OS_LOG_TYPE_DEFAULT, "%s has not received any backboardd client load states", v52, 0xCu);
          }
        }
        uint64_t v45 = *re::assetsLogObjects(v19);
        if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_58;
        }
        uint64_t v46 = "Unloaded";
        if (v49 <= 2) {
          uint64_t v46 = off_264BE2580[v49];
        }
        *(_DWORD *)uint64_t v52 = 136315394;
        int v53 = v20;
        __int16 v54 = 2080;
        long long v55 = v46;
        uint64_t v41 = v45;
        id v42 = "%s has local load state: %s";
        uint32_t v43 = 22;
      }
      _os_log_impl(&dword_233120000, v41, OS_LOG_TYPE_DEFAULT, v42, v52, v43);
LABEL_58:
      if (*(void *)buf && (buf[16] & 1) == 0) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v51);
      int v14 = v50;
      goto LABEL_62;
    }
  }
LABEL_65:
  os_unfair_lock_unlock(v2);
}

void re::AssetLoadRequest::Data::complete(uint64_t a1, int a2, int a3)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 192);
  if (a2) {
    int v7 = 1;
  }
  else {
    int v7 = 2;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
  *(_DWORD *)(a1 + 336) = v7;
  os_unfair_lock_unlock(v6);
  BOOL v9 = *re::assetsLogObjects(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = *(void *)(a1 + 88);
    if (*(unsigned char *)(a1 + 104)) {
      uint64_t v11 = *(void *)(a1 + 112);
    }
    else {
      uint64_t v11 = a1 + 105;
    }
    uint32_t v12 = "failed";
    *(_DWORD *)long long buf = 134218498;
    uint64_t v21 = v10;
    __int16 v22 = 2080;
    if (a2) {
      uint32_t v12 = "succeeded";
    }
    uint64_t v23 = v11;
    __int16 v24 = 2080;
    unint64_t v25 = v12;
    _os_log_impl(&dword_233120000, v9, OS_LOG_TYPE_DEFAULT, "AssetLoadRequest with first assetId %llu (%s) %s loading.", buf, 0x20u);
  }
  if (*(unsigned char *)(a1 + 144))
  {
    *(double *)(a1 + 136) = *(double *)(a1 + 136)
                          + (double)(std::chrono::steady_clock::now().__d_.__rep_ - *(void *)(a1 + 128))
                          / 1000000000.0;
    *(unsigned char *)(a1 + 144) = 0;
  }
  if (*(void *)(a1 + 56))
  {
    os_unfair_lock_lock(v6);
    int v13 = *(unsigned __int8 *)(a1 + 353);
    *(unsigned char *)(a1 + 353) = 1;
    os_unfair_lock_unlock(v6);
    if (!v13)
    {
      id v14 = (id)(a1 + 8);
      if (a3 == 1 || *(unsigned char *)(a1 + 64))
      {
        if (*(unsigned char *)(a1 + 64)) {
          uint64_t v15 = (id *)(a1 + 72);
        }
        else {
          uint64_t v15 = (id *)(*(void *)(a1 + 24) + 520);
        }
        uint64_t v16 = *v15;
        v17[0] = MEMORY[0x263EF8330];
        v17[1] = 0x40000000;
        _OWORD v17[2] = ___ZN2re16AssetLoadRequest4Data8completeEbNS0_11QueueOptionE_block_invoke;
        v17[3] = &__block_descriptor_tmp_3;
        v17[4] = a1;
        char v19 = a2;
        int v18 = v7;
        dispatch_async(v16, v17);
      }
      else
      {
        std::function<void ()(BOOL)>::operator()(*(void *)(a1 + 56), a2);
        os_unfair_lock_lock(v6);
        *(unsigned char *)(a1 + 353) = 0;
        os_unfair_lock_unlock(v6);
      }
    }
  }
}

float re::AssetLoadRequest::Data::progress(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 48;
  os_unfair_lock_lock(this + 48);
  float v3 = 1.0;
  if (this[84]._os_unfair_lock_opaque != 1) {
    float v3 = 1.0
  }
       - exp2f(-(float)((unint64_t)this[67]._os_unfair_lock_opaque - *(void *)&this[54]._os_unfair_lock_opaque));
  os_unfair_lock_unlock(v2);
  return v3;
}

BOOL re::AssetLoadRequest::Data::tryStopRequest(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 48;
  os_unfair_lock_lock(this + 48);
  int v3 = BYTE1(this[88]._os_unfair_lock_opaque);
  if (!BYTE1(this[88]._os_unfair_lock_opaque) && !this[84]._os_unfair_lock_opaque)
  {
    this[84]._uint64_t os_unfair_lock_opaque = 2;
    re::WrappedError::make((re::WrappedError *)@"REAssetLoadRequestErrorDomain", (const __CFString *)0x64, (uint64_t)"Cancelled", &v8);
    double v4 = (void **)&this[86];
    if (&this[86] != (os_unfair_lock_s *)&v8)
    {
      id v5 = v8;
      id v8 = 0;
      uint64_t v6 = *v4;
      re *v4 = v5;
    }
  }
  os_unfair_lock_unlock(v2);
  return v3 == 0;
}

void re::AssetLoadRequest::Data::setCompletionHandler(uint64_t a1, uint64_t a2, id *a3)
{
  uint64_t v6 = (void *)(a1 + 32);
  if (*(void *)(a1 + 56))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
    *(_DWORD *)(a1 + 336) = 0;
    *(unsigned char *)(a1 + 352) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
  }
  std::function<void ()(BOOL)>::operator=(v6, a2);
  if (!a3 || (id v7 = *(id *)(*(void *)(a1 + 24) + 520), v8 = *a3, v7, v8 == v7))
  {
    v9[0] = 0;
  }
  else
  {
    v9[0] = 1;
    id v10 = *a3;
  }
  re::Optional<re::dispatch::Queue>::operator=(a1 + 64, v9);
  if (v9[0]) {
}
  }

void *std::function<void ()(BOOL)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:nn180100]((uint64_t)v4, a2);
  std::__function::__value_func<void ()(BOOL)>::swap[abi:nn180100](v4, a1);
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:nn180100](v4);
  return a1;
}

uint64_t re::Optional<re::dispatch::Queue>::operator=(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (*(unsigned char *)a1) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = v3 == 0;
  }
  if (!v4)
  {
    if (*(unsigned char *)a1) {
      BOOL v5 = v3 == 0;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {

      *(unsigned char *)a1 = 0;
    }
    else
    {
      if (*(unsigned char *)a1) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = v3 == 0;
      }
      if (v6)
      {
        if ((unsigned __int8 *)a1 != a2)
        {
          uint64_t v7 = *((void *)a2 + 1);
          *((void *)a2 + 1) = 0;
          id v8 = *(void **)(a1 + 8);
          *(void *)(a1 + 8) = v7;
        }
      }
      else
      {
        *(unsigned char *)a1 = 1;
        uint64_t v9 = *((void *)a2 + 1);
        *((void *)a2 + 1) = 0;
        *(void *)(a1 + 8) = v9;
      }
    }
  }
  return a1;
}

void ___ZN2re16AssetLoadRequest4Data8completeEbNS0_11QueueOptionE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  std::function<void ()(BOOL)>::operator()(*(void *)(v1 + 56), *(unsigned char *)(a1 + 44));
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 192));
  *(unsigned char *)(v1 + 353) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 192));
}

uint64_t std::function<void ()(BOOL)>::operator()(uint64_t a1, char a2)
{
  char v4 = a2;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 48))(a1, &v4);
  }
  int v3 = std::__throw_bad_function_call[abi:nn180100]();
  return re::AssetLoadRequest::Data::waitForCompletion(v3);
}

void re::AssetLoadRequest::Data::waitForCompletion(uint64_t a1, int a2)
{
  v38[2] = *MEMORY[0x263EF8340];
  if (a2 == 1)
  {
    uint64_t v7 = *re::assetsLogObjects((re *)a1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void *)(a1 + 88);
      if (*(unsigned char *)(a1 + 104)) {
        uint64_t v9 = *(void *)(a1 + 112);
      }
      else {
        uint64_t v9 = a1 + 105;
      }
      int v35 = *(unsigned __int8 *)(a1 + 81);
      int v36 = *(unsigned __int8 *)(a1 + 82);
      *(_DWORD *)long long buf = 134218754;
      *(void *)&uint8_t buf[4] = v8;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v9;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v38[0]) = v35;
      WORD2(v38[0]) = 1024;
      *(_DWORD *)((char *)v38 + 6) = v36;
      _os_log_debug_impl(&dword_233120000, v7, OS_LOG_TYPE_DEBUG, "Blocking a non-engine queue waiting for AssetLoadRequest. First asset is %llu (%s). m_shouldWaitForPeers = %u. m_shouldBlockECSUpdatesUntilCompleted = %u.", buf, 0x22u);
    }
  }
  else if (!a2)
  {
    char v4 = *re::assetsLogObjects((re *)a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 88);
      if (*(unsigned char *)(a1 + 104)) {
        uint64_t v6 = *(void *)(a1 + 112);
      }
      else {
        uint64_t v6 = a1 + 105;
      }
      int v10 = *(unsigned __int8 *)(a1 + 81);
      int v11 = *(unsigned __int8 *)(a1 + 82);
      *(_DWORD *)long long buf = 134218754;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v6;
      *(_WORD *)&unsigned char buf[22] = 1024;
      LODWORD(v38[0]) = v10;
      WORD2(v38[0]) = 1024;
      *(_DWORD *)((char *)v38 + 6) = v11;
      _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "Blocking engine queue waiting for AssetLoadRequest! First asset is %llu (%s). m_shouldWaitForPeers = %u.m_shouldBlockECSUpdatesUntilCompleted = %u.", buf, 0x22u);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
  BOOL v13 = *(unsigned char *)(a1 + 353) == 0;
  int v14 = *(_DWORD *)(a1 + 336);
  if (*(unsigned char *)(a1 + 353) || (v14 - 1) >= 2)
  {
    do
    {
      if (v14 || *(void *)(a1 + 216))
      {
        if (!a2 && *(unsigned char *)(a1 + 81) && !*(unsigned char *)(*(void *)(a1 + 24) + 1380))
        {
          long long v34 = *re::assetsLogObjects(v12);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_error_impl(&dword_233120000, v34, OS_LOG_TYPE_ERROR, "AssetLoadRequest failed because waitForCompletion was called while this request is configured to wait for peers to load with AssetLoadRequest::setShouldLoadAndWaitForResourceSharingClients() or REAssetLoadRequestSetLoadAndWaitForResourceSharingClients.", buf, 2u);
          }
          break;
        }
        uint64_t v15 = *(void *)(a1 + 216);
        if (v15)
        {
          uint64_t v16 = 32 * v15;
          uint64_t v17 = (os_unfair_lock_s **)(*(void *)(a1 + 232) + 8);
          while (1)
          {
            int v18 = *v17;
            char v19 = *v17 + 96;
            os_unfair_lock_lock(v19);
            if (BYTE1(v18[104]._os_unfair_lock_opaque)) {
              break;
            }
            os_unfair_lock_unlock(v19);
            v17 += 4;
            v16 -= 32;
            if (!v16) {
              goto LABEL_22;
            }
          }
          uint64_t v23 = *re::assetsLogObjects(v20);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            if (v18[42]._os_unfair_lock_opaque) {
              long long v33 = *(char **)&v18[44]._os_unfair_lock_opaque;
            }
            else {
              long long v33 = (char *)&v18[42]._os_unfair_lock_opaque + 1;
            }
            *(_DWORD *)long long buf = 136315138;
            *(void *)&uint8_t buf[4] = v33;
            _os_log_error_impl(&dword_233120000, v23, OS_LOG_TYPE_ERROR, "AssetLoadRequest failed because waitForCompletion can't be called on an asset that is loading over the network. For '%s'", buf, 0xCu);
          }
          os_unfair_lock_unlock(v19);
          int v22 = 0;
          char v21 = 1;
        }
        else
        {
LABEL_22:
          char v21 = 0;
          int v22 = 0;
        }
      }
      else
      {
        char v21 = 0;
        int v22 = 1;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
      re::AssetLoadRequest::Data::checkForLongLoadAndLogDetails((os_unfair_lock_s *)a1);
      if ((v21 & 1) != 0 || v22)
      {
        re::AssetLoadRequest::Data::complete(a1, v22, a2);
        goto LABEL_47;
      }
      if (v13)
      {
        if (a2 == 1)
        {
          re::AssetManager::waitForLoadQueueToComplete(*(void *)(a1 + 24), 1);
LABEL_46:
          usleep(0x3E8u);
          goto LABEL_47;
        }
        if (a2) {
          goto LABEL_47;
        }
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
        if (*(void *)(a1 + 216))
        {
          unint64_t v24 = 0;
          uint64_t v25 = 8;
          do
          {
            uint64_t v26 = *(void *)(*(void *)(a1 + 232) + v25);
            if (v26)
            {
              uint64_t v27 = (os_unfair_lock_s *)(*(void *)(a1 + 24) + 1280);
              os_unfair_lock_lock(v27);
              uint64_t v28 = (os_unfair_lock_s *)(v26 + 384);
              os_unfair_lock_lock((os_unfair_lock_t)(v26 + 384));
              uint64_t v29 = *(void *)(v26 + 400);
              os_unfair_lock_unlock(v28);
              if (v29)
              {
                char v30 = *(re::internal::AssetLoadItem **)(v29 + 8);
                os_unfair_lock_unlock(v27);
                if (v30) {
                  re::internal::AssetBackgroundLoader::loadNow(*(os_unfair_lock_s **)(*(void *)(a1 + 24) + 1032), v30, 1);
                }
              }
              else
              {
                os_unfair_lock_unlock(v27);
              }
            }
            ++v24;
            v25 += 32;
          }
          while (v24 < *(void *)(a1 + 216));
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
        unint64_t v31 = *(void *)(a1 + 24);
        *(void *)long long buf = &unk_26E6C9DD8;
        *(_OWORD *)&uint8_t buf[8] = v31;
        v38[0] = buf;
        re::runInLocalAutoreleasePool((uint64_t)buf);
        std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](buf);
        if (*(unsigned char *)(a1 + 81))
        {
          os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
          int v32 = *(_DWORD *)(a1 + 336);
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
          if (!v32) {
            usleep(0x3E8u);
          }
        }
      }
      if (a2 == 1) {
        goto LABEL_46;
      }
LABEL_47:
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
      BOOL v13 = *(unsigned char *)(a1 + 353) == 0;
      int v14 = *(_DWORD *)(a1 + 336);
    }
    while (*(unsigned char *)(a1 + 353) || (v14 - 1) > 1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 192));
}

double anonymous namespace'::longLoadLoggingThreshold(_anonymous_namespace_ *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76B10, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76B10))
  {
    re::Defaults::doubleValue((re::Defaults *)"longLoadLoggingThreshold", v2, (uint64_t)v4);
    double v3 = v5;
    if (!v4[0]) {
      double v3 = 4.0;
    }
    _MergedGlobals_56 = *(void *)&v3;
    __cxa_guard_release(&qword_26AF76B10);
  }
  return *(double *)&_MergedGlobals_56;
}

void re::AssetLoadRequest::getStatistics(re::AssetLoadRequest *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 192));
  uint64_t v5 = *(void *)(v3 + 288);
  if (v5)
  {
    *a2 = v5;
LABEL_6:
    id v7 = (id)(v5 + 8);
    goto LABEL_7;
  }
  re::make::shared::object<re::AssetLoadRequest::LoadStatistics>(v4, &v8);
  uint64_t v6 = *(void *)(v3 + 288);
  uint64_t v5 = v8;
  *(void *)(v3 + 288) = v8;
  uint64_t v8 = v6;
  if (v6)
  {

    uint64_t v5 = *(void *)(v3 + 288);
  }
  *a2 = v5;
  if (v5) {
    goto LABEL_6;
  }
LABEL_7:
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 192));
}

double re::AssetLoadRequest::LoadStatistics::forEachStat(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  unsigned int v77 = 0;
  long long v75 = 0u;
  long long v76 = 0u;
  uint64_t v78 = 0x7FFFFFFFLL;
  uint64_t v67 = *(unsigned int *)(a1 + 56);
  uint64_t v3 = 0;
  if (v67)
  {
    char v4 = (int *)(*(void *)(a1 + 40) + 8);
    while (1)
    {
      int v5 = *v4;
      v4 += 10;
      if (v5 < 0) {
        break;
      }
      if (v67 == ++v3)
      {
        LODWORD(v3) = *(_DWORD *)(a1 + 56);
        break;
      }
    }
  }
  if (v67 == v3)
  {
    unsigned int v6 = 0;
    unint64_t v7 = 0;
    goto LABEL_50;
  }
  uint64_t v59 = 0;
  uint64_t v8 = 0;
  unsigned int v60 = 0;
  uint64_t v61 = 0;
  unsigned int v9 = 0;
  uint64_t v10 = 0;
  unsigned int v62 = 0;
  unsigned int v66 = 0;
  uint64_t v11 = v3;
  do
  {
    uint64_t v12 = *(void *)(*(void *)(v2 + 40) + 40 * v11 + 24);
    unsigned int v68 = v9;
    uint64_t v69 = v8;
    if (*(unsigned char *)(v12 + 744) && *(unsigned char *)(v12 + 760))
    {
      char v13 = 0;
      uint64_t v63 = (*(unsigned char *)(v12 + 752) - *(unsigned char *)(v12 + 736));
      unint64_t v64 = (*(void *)(v12 + 752) - *(void *)(v12 + 736)) & 0xFFFFFFFFFFFFFF00;
    }
    else
    {
      uint64_t v63 = 0;
      unint64_t v64 = 0;
      char v13 = 1;
    }
    uint64_t v65 = *(void *)(v12 + 768);
    uint64_t v14 = *(unsigned __int8 *)(v12 + 776);
    uint64_t v15 = **(char ***)(v12 + 264);
    size_t v16 = re::RigEvaluation::HashString::operator()((int)&v70, v15);
    unint64_t v17 = v75;
    if (!(void)v75 || (uint64_t v18 = *(unsigned int *)(v69 + 4 * (v16 % v66)), v18 == 0x7FFFFFFF))
    {
LABEL_17:
      long long v74 = 0uLL;
      if (v13) {
        goto LABEL_19;
      }
LABEL_18:
      *(void *)&long long v74 = (v64 | v63) + v74;
      goto LABEL_19;
    }
    while (1)
    {
      size_t v16 = strcmp(*(const char **)(v10 + 72 * v18 + 16), v15);
      if (!v16) {
        break;
      }
      uint64_t v18 = *(_DWORD *)(v10 + 72 * v18 + 8) & 0x7FFFFFFF;
      if (v18 == 0x7FFFFFFF) {
        goto LABEL_17;
      }
    }
    uint64_t v34 = v10 + 72 * v18;
    re::DynamicString::DynamicString((re::DynamicString *)&v70, (const re::DynamicString *)(v34 + 24));
    long long v74 = *(_OWORD *)(v34 + 56);
    if ((v13 & 1) == 0) {
      goto LABEL_18;
    }
LABEL_19:
    if (v14) {
      *((void *)&v74 + 1) += v65;
    }
    size_t v19 = re::RigEvaluation::HashString::operator()((int)&v79, v15);
    unsigned int v9 = v68;
    if (!v17) {
      goto LABEL_24;
    }
    unint64_t v17 = v19 % v62;
    uint64_t v20 = *(unsigned int *)(v69 + 4 * v17);
    if (v20 == 0x7FFFFFFF)
    {
      unsigned int v66 = v62;
LABEL_24:
      uint64_t v21 = v61;
LABEL_25:
      uint64_t v22 = v78;
      if (v78 == 0x7FFFFFFF)
      {
        unsigned int v23 = v68;
        if (v68 == v21)
        {
          size_t v24 = v19;
          re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::setCapacity((uint64_t)&v75, 2 * v60);
          size_t v19 = v24;
          unsigned int v23 = v77;
          unint64_t v17 = v24 % DWORD2(v76);
          uint64_t v21 = DWORD2(v76);
          uint64_t v10 = v76;
          uint64_t v59 = *((void *)&v75 + 1);
        }
        unsigned int v25 = v23 + 1;
        unsigned int v77 = v23 + 1;
        uint64_t v22 = v68;
        uint64_t v26 = v21;
        int v27 = *(_DWORD *)(v10 + 72 * v68 + 8);
        uint64_t v8 = v59;
        unsigned int v62 = v26;
        uint64_t v61 = v26;
        unsigned int v66 = v26;
        unsigned int v28 = v68;
      }
      else
      {
        int v27 = *(_DWORD *)(v10 + 72 * v78 + 8);
        LODWORD(v78) = v27 & 0x7FFFFFFF;
        unsigned int v25 = v68;
        unsigned int v28 = v22;
        uint64_t v8 = v69;
      }
      uint64_t v29 = 9 * v22;
      *(_DWORD *)(v10 + 8 * v29 + 8) = v27 | 0x80000000;
      uint64_t v10 = v76;
      uint64_t v30 = v76 + 8 * v29;
      *(_DWORD *)(v30 + 8) = *(_DWORD *)(v30 + 8) & 0x80000000 | *(_DWORD *)(v8 + 4 * v17);
      *(void *)uint64_t v30 = v19;
      *(void *)(v30 + 16) = v15;
      re::DynamicString::DynamicString((re::DynamicString *)(v30 + 24), (const re::DynamicString *)&v70);
      *(_OWORD *)(v30 + 56) = v74;
      *(_DWORD *)(v8 + 4 * v17) = v28;
      unsigned int v60 = ++HIDWORD(v76);
      ++HIDWORD(v78);
      unsigned int v9 = v25;
      goto LABEL_31;
    }
    size_t v33 = v19;
    while (strcmp(*(const char **)(v10 + 72 * v20 + 16), v15))
    {
      uint64_t v20 = *(_DWORD *)(v10 + 72 * v20 + 8) & 0x7FFFFFFF;
      if (v20 == 0x7FFFFFFF)
      {
        unsigned int v66 = v62;
        uint64_t v21 = v61;
        size_t v19 = v33;
        goto LABEL_25;
      }
    }
    unsigned int v66 = v62;
    uint64_t v8 = v69;
LABEL_31:
    a1 = (uint64_t)v70;
    if (v70 && (v71 & 1) != 0) {
      a1 = (*(uint64_t (**)(void))(*v70 + 40))();
    }
    if (*(_DWORD *)(v2 + 56) <= (v3 + 1)) {
      int v31 = v3 + 1;
    }
    else {
      int v31 = *(_DWORD *)(v2 + 56);
    }
    while (1)
    {
      uint64_t v11 = (v3 + 1);
      if (v31 - 1 == v3) {
        break;
      }
      LODWORD(v3) = v3 + 1;
      int v32 = v11;
      if ((*(_DWORD *)(*(void *)(v2 + 40) + 40 * v11 + 8) & 0x80000000) != 0) {
        goto LABEL_41;
      }
    }
    int v32 = v31;
LABEL_41:
    LODWORD(v3) = v32;
  }
  while (v67 != v32);
  unint64_t v7 = v60;
  unsigned int v6 = v77;
LABEL_50:
  *(void *)&long long v74 = 0;
  unint64_t v71 = 0;
  unint64_t v72 = 0;
  int v73 = 0;
  int v35 = (_anonymous_namespace_ *)re::DynamicArray<re::AssetLoadRequest::LoadStatistics::AssetTypeStats>::setCapacity(&v70, v7);
  int v36 = ++v73;
  uint64_t v37 = 0;
  if (v6)
  {
    uint64_t v38 = (int *)(v76 + 8);
    while (1)
    {
      int v39 = *v38;
      v38 += 18;
      if (v39 < 0) {
        break;
      }
      if (v6 == ++v37)
      {
        LODWORD(v37) = v6;
        break;
      }
    }
  }
  if (v6 == v37)
  {
    uint64_t v40 = v74;
    unint64_t v41 = v72;
  }
  else
  {
    uint64_t v42 = v37;
    uint64_t v43 = v76;
    unint64_t v41 = v72;
    do
    {
      if (v41 >= v71)
      {
        if (v71 < v41 + 1)
        {
          if (v70)
          {
            if (v71) {
              unint64_t v44 = 2 * v71;
            }
            else {
              unint64_t v44 = 8;
            }
            if (v44 <= v41 + 1) {
              unint64_t v45 = v41 + 1;
            }
            else {
              unint64_t v45 = v44;
            }
            re::DynamicArray<re::AssetLoadRequest::LoadStatistics::AssetTypeStats>::setCapacity(&v70, v45);
            int v36 = v73;
          }
          else
          {
            re::DynamicArray<re::AssetLoadRequest::LoadStatistics::AssetTypeStats>::setCapacity(&v70, v41 + 1);
            int v36 = v73 + 1;
          }
        }
        unint64_t v41 = v72;
      }
      uint64_t v40 = v74;
      int v35 = re::DynamicString::DynamicString((re::DynamicString *)(v74 + 48 * v41), (const re::DynamicString *)(v43 + 72 * v42 + 24));
      *((_OWORD *)v35 + 2) = *(_OWORD *)(v43 + 72 * v42 + 56);
      unint64_t v72 = ++v41;
      int v73 = ++v36;
      if (v6 <= (int)v37 + 1) {
        unsigned int v46 = v37 + 1;
      }
      else {
        unsigned int v46 = v6;
      }
      while (1)
      {
        uint64_t v42 = (v37 + 1);
        if (v46 - 1 == v37) {
          break;
        }
        LODWORD(v37) = v37 + 1;
        unsigned int v47 = v42;
        if ((*(_DWORD *)(v43 + 72 * v42 + 8) & 0x80000000) != 0) {
          goto LABEL_77;
        }
      }
      unsigned int v47 = v46;
LABEL_77:
      LODWORD(v37) = v47;
    }
    while (v6 != v47);
  }
  unint64_t v48 = 126 - 2 * __clz(v41);
  if (v41) {
    uint64_t v49 = v48;
  }
  else {
    uint64_t v49 = 0;
  }
  std::__introsort<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>,false>((_OWORD *)(v40 + 48 * v41), (long long *)(v40 + 48 * v41), v40, v40, v49, 1);
  if (v41)
  {
    uint64_t v50 = v41 - 1;
    if (v41 - 1 >= 9) {
      uint64_t v50 = 9;
    }
    uint64_t v51 = v50 + 1;
    uint64_t v52 = v40;
    do
    {
      (*(void (**)(uint64_t, uint64_t))(a2 + 16))(a2, v52);
      v52 += 48;
      --v51;
    }
    while (v51);
  }
  int v53 = v70;
  if (v70) {
    BOOL v54 = v40 == 0;
  }
  else {
    BOOL v54 = 1;
  }
  if (!v54)
  {
    if (v41)
    {
      uint64_t v55 = 48 * v41;
      __int16 v56 = (re::DynamicString *)v40;
      do
      {
        re::DynamicString::deinit(v56);
        __int16 v56 = (re::DynamicString *)((char *)v56 + 48);
        v55 -= 48;
      }
      while (v55);
    }
    (*(void (**)(uint64_t *, uint64_t))(*v53 + 40))(v53, v40);
  }
  return re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::deinit((uint64_t *)&v75);
}

void re::AssetLoadRequest::addAsset(re::AssetLoadRequest::Data **this, const re::AssetHandle *a2)
{
  re::AssetLoadRequest::Data::addAsset(this[3], a2);
  char v4 = this[3];
  if (*((unsigned char *)v4 + 82))
  {
    uint64_t v5 = *((void *)a2 + 1);
    if (v5) {
      *(unsigned char *)(v5 + 259) = 1;
    }
    uint64_t v6 = *(void *)(*((void *)v4 + 3) + 1152);
    if (v6)
    {
      uint64_t v8 = this;
      unint64_t v7 = this + 1;
      (*(void (**)(uint64_t, re::AssetLoadRequest::Data ***))(*(void *)v6 + 8))(v6, &v8);
      if (v8) {
    }
      }
  }
}

void re::AssetLoadRequest::error(re::AssetLoadRequest *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 192));
  *a2 = *(id *)(v3 + 344);
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 192));
}

void *re::AssetLoadRequest::setCompletionHandler(uint64_t a1, uint64_t a2, id *a3)
{
  v6[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 24);
  std::__function::__value_func<void ()(BOOL)>::__value_func[abi:nn180100]((uint64_t)v6, a2);
  re::AssetLoadRequest::Data::setCompletionHandler(v4, (uint64_t)v6, a3);
  return std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:nn180100](v6);
}

void re::AssetLoadRequest::~AssetLoadRequest(re::AssetLoadRequest *this)
{
  uint64_t v2 = *((void *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 192));
  *(unsigned char *)(v2 + 355) = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 192));
  uint64_t v3 = *((void *)this + 3);
  uint64_t v4 = *(void *)(v3 + 24);
  if (!v4 || (atomic_store(1u, (unsigned __int8 *)(v4 + 640)), (uint64_t v3 = *((void *)this + 3)) != 0))
  {

    *((void *)this + 3) = 0;
  }
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::AssetLoadRequest::~AssetLoadRequest(this);
  JUMPOUT(0x237DBCBD0);
}

void re::AssetLoadRequest::Data::~Data(id *this)
{
  if (*((unsigned char *)this + 64)) {

  }
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:nn180100](this + 4);
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
}

{
  uint64_t vars8;

  re::ThreadSafeValue<re::AssetLoadRequest::Data::State,re::UnfairLock>::~ThreadSafeValue((uint64_t)(this + 24));
  re::DynamicString::deinit((re::DynamicString *)(this + 12));
  if (*((unsigned char *)this + 64)) {

  }
  std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:nn180100](this + 4);
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
  JUMPOUT(0x237DBCBC0);
}

double re::make::shared::object<re::AssetLoadRequest::LoadStatistics>@<D0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = re::globalAllocators(a1);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 72, 8);
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(void *)(v4 + 64) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v4, 0);
  *(void *)uint64_t v4 = &unk_26E6CD2F8;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_DWORD *)(v4 + 56) = 0;
  *(void *)&double result = 0x7FFFFFFFLL;
  *(void *)(v4 + 60) = 0x7FFFFFFFLL;
  *a2 = v4;
  return result;
}

void re::AssetLoadRequest::LoadStatistics::~LoadStatistics(re::AssetLoadRequest::LoadStatistics *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

void *re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 32 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 32 * v9;
        uint64_t v11 = v7;
        do
        {
          *uint64_t v11 = 0;
          v11[1] = 0;
          _OWORD v11[2] = 0;
          v11[1] = *(void *)(v8 + 8);
          *(void *)(v8 + 8) = 0;
          uint64_t v12 = *v11;
          *uint64_t v11 = 0;
          *uint64_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = v12;
          uint64_t v13 = v11[2];
          _OWORD v11[2] = *(void *)(v8 + 16);
          *(void *)(v8 + 16) = v13;
          *((_WORD *)v11 + 12) = *(_WORD *)(v8 + 24);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v8);
          v8 += 32;
          v11 += 4;
          v10 -= 32;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *std::__function::__value_func<void ()(BOOL)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        double result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        double result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      double result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

_DWORD *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState const*,re::internal::AssetEntry::State::ResourceSharingClientLoadState*>(_DWORD *result, _DWORD *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v3 = a3 + 24;
    uint64_t v4 = result + 7;
    do
    {
      long long v5 = *(_OWORD *)(v4 - 7);
      *(void *)(v3 - 8) = *(void *)(v4 - 3);
      *(_OWORD *)(v3 - 24) = v5;
      int v6 = *((unsigned __int8 *)v4 - 4);
      if (*(unsigned char *)v3) {
        BOOL v7 = 0;
      }
      else {
        BOOL v7 = v6 == 0;
      }
      if (!v7)
      {
        if (*(unsigned char *)v3) {
          BOOL v8 = v6 == 0;
        }
        else {
          BOOL v8 = 0;
        }
        if (v8)
        {
          *(unsigned char *)uint64_t v3 = 0;
        }
        else
        {
          if (*(unsigned char *)v3) {
            BOOL v9 = 1;
          }
          else {
            BOOL v9 = v6 == 0;
          }
          if (!v9) {
            *(unsigned char *)uint64_t v3 = 1;
          }
          *(_DWORD *)(v3 + 4) = *v4;
        }
      }
      uint64_t v10 = v4 - 7;
      v3 += 32;
      v4 += 8;
    }
    while (v10 + 8 != a2);
  }
  return result;
}

double re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::DynamicString::deinit((re::DynamicString *)(v6 + 24));
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 72;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(void *)&v25[36] = 0x7FFFFFFFLL;
      re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init((uint64_t)v25, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v25;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v25[8];
      *(_OWORD *)unsigned int v25 = v5;
      *(void *)&v25[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v25[24];
      *(_OWORD *)&unsigned char v25[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        uint64_t v13 = v6 + 32;
        do
        {
          if ((*(_DWORD *)(v13 - 24) & 0x80000000) != 0)
          {
            unint64_t v14 = *(void *)(v13 - 32);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 72 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 72 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 72 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 72 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 72 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 72 * v17) = v14;
            *(void *)(*(void *)(a1 + 16) + 72 * v17 + 16) = *(void *)(v13 - 16);
            uint64_t v21 = *(void *)(a1 + 16) + 72 * v17;
            *(_OWORD *)(v21 + 40) = 0u;
            *(_OWORD *)(v21 + 24) = 0u;
            *(void *)(v21 + 24) = *(void *)(v13 - 8);
            *(void *)(v13 - 8) = 0;
            uint64_t v22 = *(void *)(v21 + 40);
            *(void *)(v21 + 40) = *(void *)(v13 + 8);
            *(void *)(v13 + 8) = v22;
            *(void *)(v21 + 48) = *(void *)(v13 + 16);
            *(void *)(v13 + 16) = 0;
            uint64_t v23 = *(void *)(v21 + 32);
            *(void *)(v21 + 32) = *(void *)v13;
            *(void *)uint64_t v13 = v23;
            *(_OWORD *)(v21 + 56) = *(_OWORD *)(v13 + 24);
            uint64_t v12 = *(void *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 72;
          --v10;
        }
        while (v10);
      }
      re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::deinit((uint64_t *)v25);
    }
  }
  else
  {
    if (a2) {
      signed int v24 = a2;
    }
    else {
      signed int v24 = 3;
    }
  }
}

void re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    long long v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unsigned int v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 72 * v10, 16);
  if (v12)
  {
    unint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void *re::DynamicArray<re::AssetLoadRequest::LoadStatistics::AssetTypeStats>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    long long v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::AssetLoadRequest::LoadStatistics::AssetTypeStats>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            long long v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      long long v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 48 * v9;
        uint64_t v11 = v7;
        do
        {
          *(_OWORD *)uint64_t v11 = 0u;
          *((_OWORD *)v11 + 1) = 0u;
          v11[3] = *(void *)(v8 + 24);
          uint64_t v12 = *(void *)(v8 + 8);
          *uint64_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          uint64_t v13 = *(void *)(v8 + 16);
          *(void *)(v8 + 24) = 0;
          uint64_t v15 = v11[1];
          uint64_t v14 = v11[2];
          v11[1] = v12;
          _OWORD v11[2] = v13;
          *(void *)(v8 + 8) = v15;
          *(void *)(v8 + 16) = v14;
          *((_OWORD *)v11 + 2) = *(_OWORD *)(v8 + 32);
          re::DynamicString::deinit((re::DynamicString *)v8);
          v8 += 48;
          v11 += 6;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>,false>(_OWORD *a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
uint64_t std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (re::DynamicString *)(a2 - 48);
  uint64_t v5 = *(void *)(a1 - 48);
  uint64_t v4 = a1 - 48;
  uint64_t v7 = v5;
  *(void *)uint64_t v4 = 0;
  uint64_t v9 = *(void *)(v4 + 16);
  *(void *)(v4 + 16) = 0;
  uint64_t v10 = *(void *)(v4 + 24);
  *(void *)(v4 + 24) = 0;
  uint64_t v8 = *(void *)(v4 + 8);
  *(void *)(v4 + 8) = 0;
  long long v11 = *(_OWORD *)(v4 + 32);
  *((_OWORD *)re::DynamicString::operator=((re::DynamicString *)v4, (re::DynamicString *)(a2 - 48)) + 2) = *(_OWORD *)(a2 - 16);
  re::DynamicString::operator=(v3, (re::DynamicString *)&v7);
  *(_OWORD *)(a2 - 16) = v11;
  uint64_t result = v7;
  if (v7)
  {
    if (v8) {
      return (*(uint64_t (**)(void))(*(void *)v7 + 40))();
    }
  }
  return result;
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v9 = *(void *)(a4 - 16);
  unint64_t v10 = *(void *)(a6 - 16);
  if (v9 >= *(void *)(a2 - 16))
  {
    if (v10 >= v9) {
      return;
    }
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a4, a6);
    if (*(void *)(a4 - 16) >= *(void *)(a2 - 16)) {
      return;
    }
    uint64_t v11 = a2;
    uint64_t v12 = a4;
  }
  else
  {
    uint64_t v11 = a2;
    if (v10 >= v9)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2, a4);
      if (*(void *)(a6 - 16) >= *(void *)(a4 - 16)) {
        return;
      }
      uint64_t v11 = a4;
    }
    uint64_t v12 = a6;
  }
  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(v11, v12);
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v6 = 1;
  switch(0xAAAAAAAAAAAAAAABLL * ((a2 - a4) >> 4))
  {
    case 0uLL:
    case 1uLL:
      return v6;
    case 2uLL:
      if (*(void *)(a4 + 32) < *(void *)(a2 - 16)) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2, a4 + 48);
      }
      return v6;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(a1, a2, a2 - 48, a2 - 48, a3, a4 + 48);
      return v6;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(a1, a2, a2 - 48, a2 - 48, a2 - 96, a2 - 96, a3, a4 + 48);
      return v6;
    case 5uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(a1, a2, a2 - 48, a2 - 48, a2 - 96, a2 - 96, a2 - 144, a2 - 144);
      if (*(void *)(a4 + 32) < *(void *)(a2 - 160))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2 - 144, a4 + 48);
        if (*(void *)(a2 - 160) < *(void *)(a2 - 112))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2 - 96, a2 - 144);
          if (*(void *)(a2 - 112) < *(void *)(a2 - 64))
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2 - 48, a2 - 96);
            if (*(void *)(a2 - 64) < *(void *)(a2 - 16)) {
              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2, a2 - 48);
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v7 = a2 - 96;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(a1, a2, a2 - 48, a2 - 48, a2 - 96, a2 - 96);
      uint64_t v8 = a2 - 144;
      if (a2 - 144 == a4) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    uint64_t v11 = v8 - 48;
    if (*(void *)(v8 - 16) < *(void *)(v7 - 16)) {
      break;
    }
LABEL_15:
    v9 -= 48;
    uint64_t v7 = v8;
    v8 -= 48;
    if (v11 == a4) {
      return 1;
    }
  }
  uint64_t v16 = *(void *)(v8 - 48);
  *(void *)(v8 - 48) = 0;
  uint64_t v18 = *(void *)(v8 - 32);
  *(void *)(v8 - 32) = 0;
  uint64_t v19 = *(void *)(v8 - 24);
  *(void *)(v8 - 24) = 0;
  uint64_t v17 = *(void *)(v8 - 40);
  *(void *)(v8 - 40) = 0;
  long long v20 = *(_OWORD *)(v8 - 16);
  uint64_t v12 = v9;
  do
  {
    uint64_t v13 = a2 + v12;
    uint64_t v14 = (re::DynamicString *)(a2 + v12 - 144);
    re::DynamicString::operator=((re::DynamicString *)(a2 + v12 - 192), v14);
    *(_OWORD *)(a2 + v12 - 160) = *(_OWORD *)(a2 + v12 - 112);
    if (v12 == 96) {
      break;
    }
    v12 += 48;
  }
  while ((unint64_t)v20 < *(void *)(v13 - 64));
  re::DynamicString::operator=(v14, (re::DynamicString *)&v16);
  *(_OWORD *)(v13 - 112) = v20;
  if (++v10 != 8)
  {
    if (v16 && (v17 & 1) != 0) {
      (*(void (**)(void))(*(void *)v16 + 40))();
    }
    goto LABEL_15;
  }
  BOOL v6 = v11 == a4;
  if (v16 && (v17 & 1) != 0) {
    (*(void (**)(void))(*(void *)v16 + 40))();
  }
  return v6;
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(a1, a2, a3, a4, a5, a6);
  if (*(void *)(a8 - 16) < *(void *)(a6 - 16))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a6, a8);
    if (*(void *)(a6 - 16) < *(void *)(a4 - 16))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a4, a6);
      if (*(void *)(a4 - 16) < *(void *)(a2 - 16))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(a2, a4);
      }
    }
  }
}

uint64_t std::__function::__value_func<void ()(BOOL)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t re::ThreadSafeValue<re::AssetLoadRequest::Data::State,re::UnfairLock>::~ThreadSafeValue(uint64_t a1)
{
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1 + 104);
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2)
  {

    *(void *)(a1 + 96) = 0;
  }
  v3.n128_f64[0] = re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)(a1 + 48));
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v5 = *(re::AssetHandle **)(a1 + 40);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 24);
      if (v6)
      {
        uint64_t v7 = 32 * v6;
        do
        {
          re::AssetHandle::~AssetHandle(v5);
          uint64_t v5 = (re::AssetHandle *)((char *)v5 + 32);
          v7 -= 32;
        }
        while (v7);
        uint64_t v4 = *(void *)(a1 + 8);
        uint64_t v5 = *(re::AssetHandle **)(a1 + 40);
      }
      (*(void (**)(uint64_t, re::AssetHandle *, __n128))(*(void *)v4 + 40))(v4, v5, v3);
    }
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 8) = 0;
    ++*(_DWORD *)(a1 + 32);
  }
  return a1;
}

void *re::allocInfo_NetworkAssetSerializationService(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_57, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_57))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76B20, "NetworkAssetSerializationService");
    __cxa_guard_release(&_MergedGlobals_57);
  }
  return &unk_26AF76B20;
}

void re::initInfo_NetworkAssetSerializationService(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0xD4DD228B7CB34A8ELL;
  v5[1] = "NetworkAssetSerializationService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 8) = &re::initInfo_NetworkAssetSerializationService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_NetworkAssetSerializationService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"NetworkAssetSerializationService", (uint64_t (*)(re::internal *))re::allocInfo_NetworkAssetSerializationService, (re::IntrospectionBase *(*)(void))re::initInfo_NetworkAssetSerializationService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NetworkAssetSerializationService>, this);
}

void re::SerializedPayload::make(uint64_t a1@<X0>, const re::IntrospectionBase **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, RESerializedPayload **a5@<X8>)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 16) == 8)
  {
    int v10 = [NSString stringWithUTF8String:*(void *)(a1 + 48)];
    uint64_t v27 = 0;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    int v26 = 0;
    re::DynamicArray<char>::setCapacity(v23, 0x100uLL);
    ++v26;
    v22[0] = &unk_26E7147E8;
    v22[1] = v23;
    if (v11)
    {
      uint64_t v12 = v25;
      uint64_t v13 = *(void *)(a4 + 32);
      if (!v13)
      {
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        uint64_t v15 = v27;
LABEL_14:
        uint64_t v21 = [[RESerializedPayload alloc] initWithTypeName:v10 serializedBytes:v15 size:v12 blobBytes:v17 size:v16];
        *a5 = v21;

LABEL_19:
        if (*(void *)v23)
        {
          if (v27) {
            (*(void (**)(void))(**(void **)v23 + 40))();
          }
        }

        return;
      }
      uint64_t v14 = (re *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 16))(v13, v22);
      if (v14)
      {
        uint64_t v15 = v27;
        uint64_t v16 = v25 - v12;
        if (v25 == v12) {
          uint64_t v17 = 0;
        }
        else {
          uint64_t v17 = v27 + v12;
        }
        goto LABEL_14;
      }
      uint64_t v19 = *re::foundationSerializationLogObjects(v14);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        unint64_t v29 = v10;
        long long v20 = "Failed to serialize blob for payload of type %@";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v19 = *re::foundationSerializationLogObjects((re *)v11);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        unint64_t v29 = v10;
        long long v20 = "Failed to serialize payload of type %@";
LABEL_17:
        _os_log_fault_impl(&dword_233120000, v19, OS_LOG_TYPE_FAULT, v20, buf, 0xCu);
      }
    }
    *a5 = 0;
    goto LABEL_19;
  }
  uint64_t v18 = *re::foundationSerializationLogObjects((re *)a1);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v23 = 0;
    _os_log_fault_impl(&dword_233120000, v18, OS_LOG_TYPE_FAULT, "Serializing payloads for types other than structs is not supported", v23, 2u);
  }
  *a5 = 0;
}

void re::SerializedPayload::dynamicCast(id *this@<X0>, void *a2@<X8>)
{
  id v5 = *this;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v4 = v5;
  }
  else {
    id v4 = 0;
  }
  *a2 = v4;
}

uint64_t re::SerializedPayload::deserializeIntoStruct(id *a1, uint64_t a2, re::DynamicString **a3, uint64_t a4, uint64_t a5)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a2 + 16) == 8)
  {
    int v10 = [NSString stringWithUTF8String:*(void *)(a2 + 48)];
    id v11 = *a1;
    uint64_t v12 = [v11 typeName];
    char v13 = [v10 isEqualToString:v12];

    if (v13)
    {
      id v15 = [v11 serializedData];

      id v16 = v15;
      *(void *)long long buf = &unk_26E7150B0;
      *(void *)&uint8_t buf[8] = [v16 bytes];
      *(void *)&uint8_t buf[16] = [v16 length];
      uint64_t v30 = 0;
      uint64_t v18 = v17;
      if ((v17 & 1) == 0)
      {
        uint64_t v19 = *re::foundationSerializationLogObjects((re *)v17);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          uint64_t v25 = v19;
          int v26 = [v11 typeName];
          int v27 = 138412290;
          unint64_t v28 = v26;
          _os_log_fault_impl(&dword_233120000, v25, OS_LOG_TYPE_FAULT, "Failed to deserialize payload of type %@", (uint8_t *)&v27, 0xCu);
        }
      }
    }
    else
    {
      uint64_t v21 = *re::foundationSerializationLogObjects(v14);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
      {
        uint64_t v23 = v21;
        uint64_t v24 = [v11 typeName];
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v10;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v24;
        _os_log_fault_impl(&dword_233120000, v23, OS_LOG_TYPE_FAULT, "Tried to deserialize a payload into a structure with an unexpected type name (expected '%@', got '%@')", buf, 0x16u);
      }
      uint64_t v18 = 0;
    }
  }
  else
  {
    long long v20 = *re::foundationSerializationLogObjects((re *)a1);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl(&dword_233120000, v20, OS_LOG_TYPE_FAULT, "Serializing payloads for types other than structs is not supported", buf, 2u);
    }
    return 0;
  }
  return v18;
}

void re::SerializedPayload::typeName(id *this@<X0>, re::DynamicString *a2@<X8>)
{
  id v4 = [*this typeName];
  __n128 v3 = (_anonymous_namespace_ *)[v4 UTF8String];
}

void re::SerializedPayload::serializedData(id *this@<X0>, void *a2@<X8>)
{
  id v3 = [*this serializedData];
  *a2 = v3;
}

void re::SerializedPayload::blobData(id *this@<X0>, void *a2@<X8>)
{
  id v3 = [*this blobData];
  *a2 = v3;
}

uint64_t re::AssetSignpost::fireImpulse(re::AssetSignpost *this, unsigned int a2, const char *a3, const char *a4)
{
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    if (a3) {
      strncpy(__dst, a3, 8uLL);
    }
    return kdebug_trace();
  }
  return result;
}

re::internal::AriadneSignpostScopeGuard *re::AssetSignpost::ScopeGuard::ScopeGuard(re::AssetSignpost::ScopeGuard *this, int a2, uint64_t a3, const char *__src)
{
  if (__src) {
    strncpy(__dst, __src, 8uLL);
  }
  return re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard(this, a2, a3);
}

void re::RealityFileRegistry::init(void **this)
{
  dispatch_queue_t v2 = dispatch_queue_create("com.apple.CoreRE.reality-file-registry-queue", 0);
  re::ObjCObject::operator=(this, v2);

  this[10] = (void *)8;
}

void re::RealityFileRegistry::getOrMountRealityFile(dispatch_queue_t *this@<X0>, const re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v15 = 0;
  id v16 = &v15;
  uint64_t v17 = 0x3812000000;
  uint64_t v18 = __Block_byref_object_copy__0;
  uint64_t v19 = __Block_byref_object_dispose__0;
  long long v20 = "";
  uint64_t v21 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x3812000000;
  id v11 = __Block_byref_object_copy__1;
  uint64_t v12 = __Block_byref_object_dispose__2;
  uint64_t v13 = 0;
  id v14 = 0;
  v7[0] = MEMORY[0x263EF8330];
  v7[1] = 3221225472;
  _OWORD v7[2] = ___ZN2re19RealityFileRegistry21getOrMountRealityFileERKNS_13DynamicStringE_block_invoke;
  v7[3] = &unk_264BE25A0;
  v7[6] = this;
  v7[7] = a2;
  void v7[4] = &v15;
  v7[5] = &v8;
  dispatch_sync(*this, v7);
  id v4 = (char *)v16[6];
  if (v4)
  {
    id v5 = v4 + 8;
    char v6 = 1;
  }
  else
  {
    id v4 = (char *)(id)v9[6];
    char v6 = 0;
  }
  *(unsigned char *)a3 = v6;
  *(void *)(a3 + 8) = v4;
  _Block_object_dispose(&v8, 8);

  _Block_object_dispose(&v15, 8);
  if (v21) {
}
  }

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if (v1)
  {

    *(void *)(a1 + 48) = 0;
  }
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(void *)(result + 80) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(_DWORD *)(result + 72) = 0;
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  id v3 = *(void *)(result + 64);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v3;
  id v4 = *(void *)(result + 80);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v4;
  ++*(_DWORD *)(a2 + 72);
  ++*(_DWORD *)(result + 72);
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

{
  re::DynamicInlineArray<re::VideoObject<re::VideoPixelBufferBase>,2ul>::clear(a1 + 48);
}

void ___ZN2re19RealityFileRegistry21getOrMountRealityFileERKNS_13DynamicStringE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  id v3 = re::RealityFileRegistryLRUCache::tryGet((re::RealityFileRegistryLRUCache *)(v2 + 8), *(const re::DynamicString **)(a1 + 56));
  if (!v3)
  {
    uint64_t v8 = *(void *)(a1 + 56);
    if (*(unsigned char *)(v8 + 8)) {
      uint64_t v9 = *(re::RealityFile **)(v8 + 16);
    }
    else {
      uint64_t v9 = (re::RealityFile *)(v8 + 9);
    }
    re::RealityFile::makeByOpeningFileAtURL(v9, (uint64_t)v28);
    if (!v28[0])
    {
      re::ObjCObject::operator=((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 48), (id *)&v29);
LABEL_30:
      re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v28);
      return;
    }
    uint64_t v10 = *(const re::DynamicString **)(a1 + 56);
    id v11 = (uint64_t **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v2 + 32, (uint64_t)v10);
    if (v11)
    {
      uint64_t v12 = *v11;
      uint64_t v13 = **v11;
      *(void *)(v13 + 8) = (*v11)[1];
      *(void *)v12[1] = v13;
      --*(void *)(v2 + 24);
      std::__destroy_at[abi:nn180100]<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,0>((re::DynamicString *)(v12 + 2));
      operator delete(v12);
      re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v2 + 32, (uint64_t)v10);
    }
LABEL_13:
    if (*(void *)(v2 + 80) <= (unint64_t)*(unsigned int *)(v2 + 60))
    {
      id v14 = (void *)(v2 + 8);
      while (v14 != *(void **)(v2 + 16))
      {
        id v14 = (void *)*v14;
        if (!*((_DWORD *)v14 + 14))
        {
          re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v2 + 32, (uint64_t)(v14 + 2));
          uint64_t v15 = (void *)*v14;
          v15[1] = v14[1];
          *(void *)v14[1] = v15;
          --*(void *)(v2 + 24);
          std::__destroy_at[abi:nn180100]<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,0>((re::DynamicString *)(v14 + 2));
          operator delete(v14);
          goto LABEL_13;
        }
      }
    }
    id v16 = v29;
    if (v29) {
      uint64_t v17 = v29 + 8;
    }
    re::DynamicString::DynamicString((re::DynamicString *)&v30, v10);
    int v33 = 1;
    uint64_t v18 = (char *)operator new(0x40uLL);
    *((void *)v18 + 2) = v30;
    uint64_t v19 = v32;
    long long v20 = v31;
    uint64_t v30 = 0;
    *((void *)&v31 + 1) = 0;
    uint64_t v32 = 0;
    *(_OWORD *)(v18 + 24) = v20;
    *((void *)v18 + 5) = v19;
    *((void *)v18 + 6) = v16;
    *((_DWORD *)v18 + 14) = 1;
    *(void *)uint64_t v18 = v2 + 8;
    uint64_t v21 = *(void **)(v2 + 16);
    *((void *)v18 + 1) = v21;
    *uint64_t v21 = v18;
    uint64_t v22 = *(void *)(v2 + 24) + 1;
    *(void *)(v2 + 16) = v18;
    *(void *)(v2 + 24) = v22;
    uint64_t v30 = v18;
    unint64_t v23 = re::Hash<re::DynamicString>::operator()((uint64_t)&v34, (uint64_t)v10);
    unint64_t v24 = v23;
    if (*(void *)(v2 + 32))
    {
      unint64_t v25 = v23 % *(unsigned int *)(v2 + 56);
      uint64_t v26 = *(unsigned int *)(*(void *)(v2 + 40) + 4 * v25);
      if (v26 != 0x7FFFFFFF)
      {
        uint64_t v27 = *(void *)(v2 + 48);
        while (!re::DynamicString::operator==(v27 + 56 * v26 + 16, (uint64_t)v10))
        {
          uint64_t v26 = *(_DWORD *)(v27 + 56 * v26 + 8) & 0x7FFFFFFF;
          if (v26 == 0x7FFFFFFF) {
            goto LABEL_28;
          }
        }
        goto LABEL_29;
      }
    }
    else
    {
      LODWORD(v25) = 0;
    }
LABEL_28:
    re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(v2 + 32, v25, v24, v10, &v30);
    ++*(_DWORD *)(v2 + 72);
LABEL_29:
    re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 48), (uint64_t)v29);
    goto LABEL_30;
  }
  id v4 = (uint64_t *)v3;
  uint64_t v5 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v2 + 32, *(void *)(a1 + 56));
  if (v5) {
    ++*(_DWORD *)(*(void *)v5 + 56);
  }
  char v6 = (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 48);
  uint64_t v7 = *v4;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(v6, v7);
}

uint64_t **re::RealityFileRegistryLRUCache::tryGet(re::RealityFileRegistryLRUCache *this, const re::DynamicString *a2)
{
  uint64_t result = (uint64_t **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this + 24, (uint64_t)a2);
  if (result)
  {
    id v4 = (uint64_t *)*((void *)this + 1);
    uint64_t v5 = *result;
    if (v4 != *result)
    {
      char v6 = (uint64_t *)v5[1];
      if (v6 != v4)
      {
        uint64_t v7 = *v5;
        *(void *)(v7 + 8) = v6;
        *(void *)v5[1] = v7;
        uint64_t v8 = *v4;
        *(void *)(v8 + 8) = v5;
        *uint64_t v5 = v8;
        uint64_t *v4 = (uint64_t)v5;
        v5[1] = (uint64_t)v4;
      }
    }
    return (uint64_t **)(v5 + 6);
  }
  return result;
}

void re::RealityFileRegistry::getMountedRealityFile(dispatch_queue_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x3812000000;
  uint64_t v10 = __Block_byref_object_copy__0;
  id v11 = __Block_byref_object_dispose__0;
  uint64_t v12 = "";
  uint64_t v13 = 0;
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = ___ZN2re19RealityFileRegistry21getMountedRealityFileERKNS_13DynamicStringE_block_invoke;
  v6[3] = &unk_264BE25C8;
  void v6[5] = a1;
  v6[6] = a2;
  void v6[4] = &v7;
  dispatch_sync(*a1, v6);
  uint64_t v4 = v8[6];
  if (v4)
  {
    *(void *)(a3 + 8) = v4;
    id v5 = (id)(v4 + 8);
    LOBYTE(v4) = 1;
  }
  *(unsigned char *)a3 = v4;
  _Block_object_dispose(&v7, 8);
  if (v13) {
}
  }

void ___ZN2re19RealityFileRegistry21getMountedRealityFileERKNS_13DynamicStringE_block_invoke(uint64_t a1)
{
  uint64_t v2 = re::RealityFileRegistryLRUCache::tryGet((re::RealityFileRegistryLRUCache *)(*(void *)(a1 + 40) + 8), *(const re::DynamicString **)(a1 + 48));
  if (v2)
  {
    uint64_t v3 = (uint64_t)*v2;
    uint64_t v4 = (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 48);
    re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(v4, v3);
  }
}

uint64_t re::RealityFileRegistry::unmountRealityFile(dispatch_queue_t *a1, uint64_t a2)
{
  uint64_t v5 = 0;
  char v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = ___ZN2re19RealityFileRegistry18unmountRealityFileERKNS_13DynamicStringE_block_invoke;
  block[3] = &unk_264BE25C8;
  block[5] = a1;
  block[6] = a2;
  block[4] = &v5;
  dispatch_sync(*a1, block);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___ZN2re19RealityFileRegistry18unmountRealityFileERKNS_13DynamicStringE_block_invoke(void *a1)
{
  uint64_t v2 = a1[5] + 32;
  uint64_t result = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v2, a1[6]);
  if (result)
  {
    int v4 = *(_DWORD *)(*(void *)result + 56);
    if (v4)
    {
      uint64_t result = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v2, a1[6]);
      if (result) {
        --*(_DWORD *)(*(void *)result + 56);
      }
      LOBYTE(v4) = 1;
    }
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v4;
  return result;
}

uint64_t re::RealityFileRegistry::mountRealityFileFromBuffer@<X0>(dispatch_queue_t *this@<X0>, const re::Data *a2@<X1>, uint64_t a3@<X8>)
{
  re::RealityFile::makeByReadingBuffer(a2, (uint64_t)v10);
  if (v10[0])
  {
    uuid_generate_random(out);
    v8[0] = MEMORY[0x263EF8330];
    v8[1] = 3321888768;
    void v8[2] = ___ZN2re19RealityFileRegistry26mountRealityFileFromBufferERKNS_4DataE_block_invoke;
    _OWORD v8[3] = &__block_descriptor_64_a8_48c69_ZTSN2re6ResultINS_9SharedPtrINS_11RealityFileEEENS_12WrappedErrorEEE_e5_v8__0l;
    id v5 = (id)((*(void *)&out[8] + (*(void *)out << 6) + (*(void *)out >> 2) - 0x61C8864680B583E9) ^ *(void *)out);
    v8[4] = this;
    void v8[5] = v5;
    re::Result<re::SharedPtr<re::RealityFile>,re::WrappedError>::Result((uint64_t)v9, v10);
    dispatch_sync(*this, v8);
    re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v9);
    char v6 = 1;
  }
  else
  {
    id v5 = v11;
    char v6 = 0;
  }
  *(unsigned char *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  return re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v10);
}

void ___ZN2re19RealityFileRegistry26mountRealityFileFromBufferERKNS_4DataE_block_invoke(void *a1)
{
  uint64_t v3 = a1[4];
  unint64_t v2 = a1[5];
  LODWORD(v4) = *(void *)(v3 + 88);
  unint64_t v5 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
  unint64_t v6 = v5 ^ (v5 >> 31);
  if (*(void *)(v3 + 88))
  {
    unint64_t v4 = v6 % *(unsigned int *)(v3 + 112);
    uint64_t v7 = *(unsigned int *)(*(void *)(v3 + 96) + 4 * v4);
    if (v7 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(v3 + 104);
      if (*(void *)(v16 + 32 * v7 + 16) == v2) {
        return;
      }
      while (1)
      {
        uint64_t v7 = *(_DWORD *)(v16 + 32 * v7 + 8) & 0x7FFFFFFF;
        if (v7 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v16 + 32 * v7 + 16) == v2) {
          return;
        }
      }
    }
  }
  uint64_t v8 = *(unsigned int *)(v3 + 124);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(v3 + 120);
    int v9 = v8;
    if (v8 == *(_DWORD *)(v3 + 112))
    {
      re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(v3 + 88, 2 * *(_DWORD *)(v3 + 116));
      LODWORD(v4) = v6 % *(unsigned int *)(v3 + 112);
      int v9 = *(_DWORD *)(v3 + 120);
      unint64_t v2 = a1[5];
    }
    *(_DWORD *)(v3 + 120) = v9 + 1;
    uint64_t v10 = *(void *)(v3 + 104);
    int v11 = *(_DWORD *)(v10 + 32 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(v3 + 104);
    int v11 = *(_DWORD *)(v10 + 32 * v8 + 8);
    *(_DWORD *)(v3 + 124) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 32 * v8 + 8) = v11 | 0x80000000;
  uint64_t v12 = v4;
  uint64_t v13 = *(void *)(v3 + 96);
  *(_DWORD *)(*(void *)(v3 + 104) + 32 * v8 + 8) = *(_DWORD *)(*(void *)(v3 + 104) + 32 * v8 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v4);
  *(void *)(*(void *)(v3 + 104) + 32 * v8) = v6;
  *(void *)(*(void *)(v3 + 104) + 32 * v8 + 16) = v2;
  uint64_t v14 = a1[7];
  *(void *)(*(void *)(v3 + 104) + 32 * v8 + 24) = v14;
  if (v14)
  {
    id v15 = (id)(v14 + 8);
    uint64_t v13 = *(void *)(v3 + 96);
  }
  *(_DWORD *)(v13 + 4 * v12) = v8;
  ++*(_DWORD *)(v3 + 116);
  ++*(_DWORD *)(v3 + 128);
}

uint64_t __copy_helper_block_a8_48c69_ZTSN2re6ResultINS_9SharedPtrINS_11RealityFileEEENS_12WrappedErrorEEE(uint64_t a1, uint64_t a2)
{
  return re::Result<re::SharedPtr<re::RealityFile>,re::WrappedError>::Result(a1 + 48, (unsigned __int8 *)(a2 + 48));
}

uint64_t __destroy_helper_block_a8_48c69_ZTSN2re6ResultINS_9SharedPtrINS_11RealityFileEEENS_12WrappedErrorEEE(uint64_t a1)
{
  return re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result(a1 + 48);
}

void re::RealityFileRegistry::tryGetRealityFile(dispatch_queue_t *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v8 = 0;
  int v9 = &v8;
  uint64_t v10 = 0x2020000000;
  uint64_t v11 = 0;
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = ___ZN2re19RealityFileRegistry17tryGetRealityFileEy_block_invoke;
  block[3] = &unk_264BE25C8;
  block[4] = &v8;
  block[5] = this;
  block[6] = a2;
  dispatch_sync(*this, block);
  unint64_t v4 = (uint64_t *)v9[3];
  if (v4)
  {
    uint64_t v5 = *v4;
    *a3 = v5;
    if (v5) {
      id v6 = (id)(v5 + 8);
    }
  }
  else
  {
    *a3 = 0;
  }
  _Block_object_dispose(&v8, 8);
}

void *___ZN2re19RealityFileRegistry17tryGetRealityFileEy_block_invoke(void *result)
{
  uint64_t v1 = result[5];
  uint64_t v2 = *(void *)(v1 + 88);
  if (v2)
  {
    unint64_t v3 = result[6];
    unint64_t v4 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v3 ^ (v3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v3 ^ (v3 >> 30))) >> 27));
    uint64_t v5 = *(unsigned int *)(*(void *)(v1 + 96) + 4 * ((v4 ^ (v4 >> 31)) % *(unsigned int *)(v1 + 112)));
    if (v5 != 0x7FFFFFFF)
    {
      uint64_t v6 = *(void *)(v1 + 104);
      if (*(void *)(v6 + 32 * v5 + 16) == v3)
      {
LABEL_7:
        uint64_t v2 = v6 + 32 * v5 + 24;
        goto LABEL_8;
      }
      while (1)
      {
        uint64_t v5 = *(_DWORD *)(v6 + 32 * v5 + 8) & 0x7FFFFFFF;
        if (v5 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v6 + 32 * v5 + 16) == v3) {
          goto LABEL_7;
        }
      }
    }
    uint64_t v2 = 0;
  }
LABEL_8:
  *(void *)(*(void *)(result[4] + 8) + 24) = v2;
  return result;
}

uint64_t re::RealityFileRegistry::unmountRealityFile(dispatch_queue_t *this, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = ___ZN2re19RealityFileRegistry18unmountRealityFileEy_block_invoke;
  block[3] = &unk_264BE25C8;
  block[4] = &v5;
  block[5] = this;
  block[6] = a2;
  dispatch_sync(*this, block);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void ___ZN2re19RealityFileRegistry18unmountRealityFileEy_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = *(void *)(v2 + 88);
  if (v3)
  {
    unint64_t v4 = a1[6];
    unint64_t v5 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) >> 27));
    unint64_t v6 = (v5 ^ (v5 >> 31)) % *(unsigned int *)(v2 + 112);
    uint64_t v7 = *(void *)(v2 + 96);
    uint64_t v8 = *(unsigned int *)(v7 + 4 * v6);
    if (v8 == 0x7FFFFFFF)
    {
LABEL_3:
      LOBYTE(vre::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
      goto LABEL_13;
    }
    uint64_t v9 = *(void *)(v2 + 104);
    uint64_t v10 = v9 + 32 * v8;
    if (*(void *)(v10 + 16) != v4)
    {
      while (1)
      {
        unsigned int v11 = v8;
        int v12 = *(_DWORD *)(v9 + 32 * v8 + 8);
        uint64_t v8 = v12 & 0x7FFFFFFF;
        if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF) {
          goto LABEL_3;
        }
        uint64_t v13 = v9 + 32 * v8;
        if (*(void *)(v13 + 16) == v4)
        {
          *(_DWORD *)(v9 + 32 * v11 + 8) = *(_DWORD *)(v9 + 32 * v11 + 8) & 0x80000000 | *(_DWORD *)(v13 + 8) & 0x7FFFFFFF;
          goto LABEL_9;
        }
      }
    }
    *(_DWORD *)(v7 + 4 * v6) = *(_DWORD *)(v10 + 8) & 0x7FFFFFFF;
LABEL_9:
    uint64_t v14 = *(void *)(v2 + 104) + 32 * v8;
    int v15 = *(_DWORD *)(v14 + 8);
    if (v15 < 0)
    {
      *(_DWORD *)(v14 + 8) = v15 & 0x7FFFFFFF;
      uint64_t v18 = *(void *)(v14 + 24);
      uint64_t v17 = (void *)(v14 + 24);
      uint64_t v16 = v18;
      if (v18)
      {

        *uint64_t v17 = 0;
      }
    }
    int v19 = *(_DWORD *)(v2 + 128);
    *(_DWORD *)(*(void *)(v2 + 104) + 32 * v8 + 8) = *(_DWORD *)(*(void *)(v2 + 104) + 32 * v8 + 8) & 0x80000000 | *(_DWORD *)(v2 + 124);
    --*(_DWORD *)(v2 + 116);
    *(_DWORD *)(v2 + 124) = v8;
    *(_DWORD *)(v2 + 128) = v19 + 1;
    LOBYTE(vre::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 1;
  }
LABEL_13:
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v3;
}

void re::RealityFileRegistry::getOrMountRealityFile(re::RealityFileDescriptor *this@<X1>, dispatch_queue_t *a2@<X0>, os_unfair_lock_s *a3@<X2>, os_unfair_lock_s *a4@<X3>, uint64_t a5@<X8>)
{
  int v7 = *(unsigned __int8 *)this;
  if ((v7 - 1) < 2)
  {
LABEL_4:
    re::RealityFileDescriptor::getURL((uint64_t)this, a3, a4, (uint64_t)&v25);
    if ((_BYTE)v25)
    {
      uint64_t v8 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a2 + 4), (uint64_t)&v26);
      if (v8) {
        BOOL v9 = *(_DWORD *)(*(void *)v8 + 56) != 0;
      }
      else {
        BOOL v9 = 0;
      }
      re::RealityFileRegistry::getOrMountRealityFile(a2, (const re::DynamicString *)&v26, a5);
      if (*(unsigned char *)a5)
      {
        if (!v9)
        {
          uint64_t v15 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a2 + 4), (uint64_t)&v26);
          if (v15) {
            --*(_DWORD *)(*(void *)v15 + 56);
          }
        }
      }
    }
    else
    {
      if (v27) {
        uint64_t v10 = v29;
      }
      else {
        uint64_t v10 = v28;
      }
      re::WrappedError::make((re::WrappedError *)@"RERealityFileErrorDomain", (const __CFString *)0xD, (uint64_t)v10, &v20);
      uint64_t v11 = v20;
      uint64_t v20 = 0;
      *(unsigned char *)a5 = 0;
      *(void *)(a5 + 8) = v11;
    }
LABEL_25:
    if (v26)
    {
      if (v27) {
        (*(void (**)(void))(*(void *)v26 + 40))();
      }
    }
    return;
  }
  if (v7 != 3)
  {
    if (v7 != 4)
    {
      re::WrappedError::make((re::WrappedError *)@"RERealityFileErrorDomain", (const __CFString *)0xA, (uint64_t)"The realityFileDescriptor is invalid.", &v25);
      uint64_t v14 = v25;
      uint64_t v25 = 0;
      *(unsigned char *)a5 = 0;
      *(void *)(a5 + 8) = v14;

      return;
    }
    goto LABEL_4;
  }
  re::RealityFileDescriptor::getMemoryFileID(this, (uint64_t)&v25);
  if ((_BYTE)v25)
  {
    re::RealityFileRegistry::tryGetRealityFile(a2, v26, &v24);
    uint64_t v12 = v24;
    if (v24)
    {
      id v13 = (id)(v24 + 8);
      *(unsigned char *)a5 = 1;
      *(void *)(a5 + 8) = v12;
    }
    else
    {
      re::DynamicString::format((re::DynamicString *)"No reality file is registered with MemoryFileID %llu.", (re::DynamicString *)&v20, v26);
      if (v21) {
        uint64_t v18 = *(unsigned char **)&v22[7];
      }
      else {
        uint64_t v18 = v22;
      }
      re::WrappedError::make((re::WrappedError *)@"RERealityFileErrorDomain", (const __CFString *)0xC, (uint64_t)v18, &v23);
      uint64_t v19 = v23;
      uint64_t v23 = 0;
      *(unsigned char *)a5 = 0;
      *(void *)(a5 + 8) = v19;

      if (v20 && (v21 & 1) != 0) {
        (*(void (**)(void))(*(void *)v20 + 40))();
      }
    }
  }
  else
  {
    if (v27) {
      uint64_t v16 = v29;
    }
    else {
      uint64_t v16 = v28;
    }
    re::WrappedError::make((re::WrappedError *)@"RERealityFileErrorDomain", (const __CFString *)0xC, (uint64_t)v16, &v20);
    uint64_t v17 = v20;
    uint64_t v20 = 0;
    *(unsigned char *)a5 = 0;
    *(void *)(a5 + 8) = v17;
  }
  if (!(_BYTE)v25) {
    goto LABEL_25;
  }
}

void re::RealityFileRegistry::getMountedRealityFile(re::RealityFileDescriptor *this@<X1>, dispatch_queue_t *a2@<X0>, os_unfair_lock_s *a3@<X2>, os_unfair_lock_s *a4@<X3>, uint64_t a5@<X8>)
{
  int v7 = *(unsigned __int8 *)this;
  if ((v7 - 1) < 2) {
    goto LABEL_4;
  }
  if (v7 != 3)
  {
    if (v7 != 4)
    {
      *(unsigned char *)a5 = 0;
      return;
    }
LABEL_4:
    re::RealityFileDescriptor::getURL((uint64_t)this, a3, a4, (uint64_t)v10);
    if (v10[0])
    {
      re::RealityFileRegistry::getMountedRealityFile(a2, (uint64_t)&v11, a5);
      goto LABEL_12;
    }
LABEL_11:
    *(unsigned char *)a5 = 0;
LABEL_12:
    if (v11)
    {
      if (v12) {
        (*(void (**)(void))(*(void *)v11 + 40))();
      }
    }
    return;
  }
  re::RealityFileDescriptor::getMemoryFileID(this, (uint64_t)v10);
  if (!v10[0]) {
    goto LABEL_11;
  }
  re::RealityFileRegistry::tryGetRealityFile(a2, v11, &v9);
  char v8 = v9;
  if (v9)
  {
    *(void *)(a5 + 8) = v9;
    char v8 = 1;
  }
  *(unsigned char *)a5 = v8;
  if (!v10[0]) {
    goto LABEL_12;
  }
}

uint64_t re::RealityFileRegistry::unmountRealityFile(dispatch_queue_t *a1, re::RealityFileDescriptor *this, os_unfair_lock_s *a3, os_unfair_lock_s *a4)
{
  int v5 = *(unsigned __int8 *)this;
  if ((v5 - 1) >= 2)
  {
    if (v5 == 3)
    {
      re::RealityFileDescriptor::getMemoryFileID(this, (uint64_t)v8);
      if (v8[0])
      {
        uint64_t v6 = re::RealityFileRegistry::unmountRealityFile(a1, v9);
        if (v8[0]) {
          return v6;
        }
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v5 != 4) {
      return 0;
    }
  }
  re::RealityFileDescriptor::getURL((uint64_t)this, a3, a4, (uint64_t)v8);
  if (!v8[0])
  {
LABEL_9:
    uint64_t v6 = 0;
    goto LABEL_10;
  }
  uint64_t v6 = re::RealityFileRegistry::unmountRealityFile(a1, (uint64_t)&v9);
LABEL_10:
  if (v9 && (v10 & 1) != 0) {
    (*(void (**)(void))(*(void *)v9 + 40))();
  }
  return v6;
}

void re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v17, a2);
  if (*(void *)a1)
  {
    unint64_t v5 = v4 % *(unsigned int *)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
    if (v7 != 0x7FFFFFFF)
    {
      uint64_t v8 = *(void *)(a1 + 16);
      if (re::DynamicString::operator==(v8 + 56 * v7 + 16, a2))
      {
        *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v8 + 56 * v7 + 8) & 0x7FFFFFFF;
LABEL_8:
        uint64_t v11 = *(void *)(a1 + 16);
        uint64_t v12 = v11 + 56 * v7;
        int v15 = *(_DWORD *)(v12 + 8);
        uint64_t v14 = (int *)(v12 + 8);
        int v13 = v15;
        if (v15 < 0)
        {
          int *v14 = v13 & 0x7FFFFFFF;
          re::DynamicString::deinit((re::DynamicString *)(v11 + 56 * v7 + 16));
          uint64_t v11 = *(void *)(a1 + 16);
          int v13 = *(_DWORD *)(v11 + 56 * v7 + 8);
        }
        int v16 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v11 + 56 * v7 + 8) = *(_DWORD *)(a1 + 36) | v13 & 0x80000000;
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v7;
        *(_DWORD *)(a1 + 40) = v16 + 1;
      }
      else
      {
        while (1)
        {
          unsigned int v9 = v7;
          int v10 = *(_DWORD *)(v8 + 56 * v7 + 8);
          uint64_t v7 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF) {
            break;
          }
          if (re::DynamicString::operator==(v8 + 56 * v7 + 16, a2))
          {
            *(_DWORD *)(v8 + 56 * v9 + 8) = *(_DWORD *)(v8 + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(v8 + 56 * v7 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

void re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(void *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v23, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v23;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)uint64_t v23 = v5;
      *(void *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&unsigned char v23[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      unsigned int v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        uint64_t v12 = v7;
        int v13 = DWORD1(v9);
        uint64_t v14 = (void *)(v6 + 24);
        do
        {
          if ((*(_DWORD *)(v14 - 2) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 3);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * v13));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 32 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 32 * v18 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v18 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 32 * v18) = v15;
            *(void *)(*(void *)(a1 + 16) + 32 * v18 + 16) = *(v14 - 1);
            *(void *)(*(void *)(a1 + 16) + 32 * v18 + 24) = *v14;
            void *v14 = 0;
            *(_DWORD *)(v12 + 4 * v17) = v18;
            int v13 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v13;
            unsigned int v10 = *(_DWORD *)&v23[32];
          }
          ++v11;
          v14 += 4;
        }
        while (v11 < v10);
      }
      re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2) {
      signed int v22 = a2;
    }
    else {
      signed int v22 = 3;
    }
  }
}

uint64_t re::Result<re::SharedPtr<re::RealityFile>,re::WrappedError>::Result(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  *(unsigned char *)a1 = v3;
  uint64_t v4 = *((void *)a2 + 1);
  if (v3)
  {
    *(void *)(a1 + 8) = v4;
    if (v4) {
      id v5 = (id)(v4 + 8);
    }
  }
  else
  {
    *(void *)(a1 + 8) = (id)v4;
  }
  return a1;
}

re::DynamicString *re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, const re::DynamicString *a4, void *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      int v12 = *(_DWORD *)(a1 + 28);
      signed int v13 = 2 * v12;
      uint64_t v14 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v13) {
          BOOL v15 = v10 == v13;
        }
        else {
          BOOL v15 = 1;
        }
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v27, 0, 36);
          *(void *)&v27[36] = 0x7FFFFFFFLL;
          re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v27, v14, v13);
          long long v16 = *(_OWORD *)v27;
          *(_OWORD *)char v27 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          uint64_t v17 = *(void *)&v27[16];
          *(void *)&unsigned char v27[16] = *(void *)(a1 + 16);
          *(void *)(a1 + 16) = v17;
          long long v19 = *(_OWORD *)&v27[24];
          *(_OWORD *)&v27[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v27[32];
          *(_OWORD *)(a1 + 24) = v19;
          unsigned int v20 = v18;
          if (v18)
          {
            uint64_t v21 = 0;
            unint64_t v22 = 0;
            do
            {
              if ((*(_DWORD *)(*(void *)&v27[16] + v21 + 8) & 0x80000000) != 0)
              {
                re::HashTable<re::DynamicString,std::__list_iterator<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,void *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(void *)(*(void *)&v27[16] + v21) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v27[16] + v21), *(void *)&v27[16] + v21 + 16, *(void *)&v27[16] + v21 + 48);
                unsigned int v20 = *(_DWORD *)&v27[32];
              }
              ++v22;
              v21 += 56;
            }
            while (v22 < v20);
          }
          re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v27);
        }
      }
      else
      {
        if (v13) {
          signed int v25 = 2 * v12;
        }
        else {
          signed int v25 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 56 * v10 + 8);
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 56 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 56 * v10 + 8) = v24 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * v10) = a3;
  uint64_t result = re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v10 + 16), a4);
  *(void *)(*(void *)(a1 + 16) + 56 * v10 + 48) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

void re::ResourceSharingManager::xpcInterface(void *a1@<X8>)
{
  id v3 = [MEMORY[0x263F08D80] interfaceWithProtocol:&unk_26E74AE58];
  *a1 = v3;
}

double re::ResourceSharingManager::ResourceSharingManager(re::ResourceSharingManager *this)
{
  *(void *)this = &unk_26E6CD370;
  *((void *)this + 1) = &unk_26E6CD3D8;
  *((unsigned char *)this + 16) = 0;
  *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 12) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_DWORD *)this + 22) = 0;
  return result;
}

void re::ResourceSharingManager::~ResourceSharingManager(void **this)
{
  re::ResourceSharingManager::deinit(this);
  re::DynamicArray<re::ResourceSharingManager::Connection>::deinit((uint64_t)(this + 8));
  uint64_t v2 = (char *)this[7];
  if (v2)
  {

    this[7] = 0;
  }
}

{
  uint64_t vars8;

  re::ResourceSharingManager::~ResourceSharingManager(this);
  JUMPOUT(0x237DBCBD0);
}

void **re::ResourceSharingManager::deinit(void **this)
{
  if (*((unsigned char *)this + 16))
  {
    uint64_t v1 = this;
    (*(void (**)(void *, void))(*(void *)this[3] + 232))(this[3], 0);
    uint64_t v2 = v1[5];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = ___ZN2re22ResourceSharingManager6deinitEv_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = v1;
    dispatch_sync(v2, block);
    re::DynamicArray<re::ResourceSharingManager::Connection>::deinit((uint64_t)(v1 + 8));
    id v3 = (char *)v1[7];
    if (v3)
    {

      v1[7] = 0;
    }
    v1[6] = 0;
    re::ObjCObject::operator=(v1 + 5, 0);
    this = re::ObjCObject::operator=(v1 + 4, 0);
    v1[3] = 0;
    *((unsigned char *)v1 + 16) = 0;
  }
  return this;
}

void non-virtual thunk to're::ResourceSharingManager::~ResourceSharingManager(void **this)
{
}

{
  uint64_t vars8;

  re::ResourceSharingManager::~ResourceSharingManager(this - 1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ResourceSharingManager::init(re::ResourceSharingManager *this, AssetService *a2, id *a3, uint64_t a4)
{
  *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = a2;
  re::ObjCObject::operator=((id *)this + 4, a3);
  uint64_t v6 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  long long v7 = dispatch_get_global_queue(21, 0);
  dispatch_queue_t v8 = dispatch_queue_create_with_target_V2("com.apple.RealityKit.resource-sharing", v6, v7);
  re::ObjCObject::operator=((void **)this + 5, v8);

  *((void *)this + 6) = a4;
  re::make::shared::object<re::internal::ResourceRequestQueue>(v9, &v14);
  uint64_t v11 = *((void *)this + 7);
  *((void *)this + 7) = v14;
  uint64_t v14 = v11;
  if (v11) {

  }
  int v12 = (char *)this + 64;
  re::DynamicArray<re::ResourceSharingManager::Connection>::setCapacity(v12, 2uLL);
  ++*((_DWORD *)v12 + 6);
  uint64_t result = (*(uint64_t (**)(void, char *))(**((void **)v12 - 5) + 232))(*((void *)v12 - 5), v12 - 56);
  *(v12 - 48) = 1;
  return result;
}

void ___ZN2re22ResourceSharingManager6deinitEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 80);
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 96);
    uint64_t v4 = 168 * v2;
    do
    {
      re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(v3 + 72);
      re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(v3 + 120);
      re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear(v3 + 24);
      unint64_t v5 = *(void *)(v3 + 16);
      long long v7 = re::PeerIDValidator::instance(v6);
      re::PeerIDValidator::remove_impl((re::PeerIDValidator *)v7, v5);
      [*(id *)v3 invalidate];
      [*(id *)(v3 + 8) invalidate];
      re::ObjCObject::operator=((void **)v3, 0);
      dispatch_queue_t v8 = *(void **)(v3 + 8);
      *(void *)(v3 + 8) = 0;

      v3 += 168;
      v4 -= 168;
    }
    while (v4);
  }
}

uint64_t re::DynamicArray<re::ResourceSharingManager::Connection>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        unint64_t v5 = (uint64_t *)(v3 + 72);
        uint64_t v6 = 168 * v4;
        do
        {
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v5 + 6);
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v5);
          re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit(v5 - 6);

          v5 += 21;
          v6 -= 168;
        }
        while (v6);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::ResourceSharingManager::connect(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  uint64_t v6 = [[REResourceSharingClientObject alloc] initWithAssetService:*(void *)(a1 + 24) resourceSharingManager:a1 peerID:a3];
  re::xpc::Connection::makeWithListenerEndpoint(a2, &v26);
  long long v7 = v6;
  *(void *)&long long buf = v7;
  re::xpc::Connection::setExportedObject(&v26, (const re::ObjCObject *)&buf);

  re::ResourceSharingManager::xpcInterface(&buf);
  re::xpc::Connection::setExportedInterface(&v26, (uint64_t *)&buf);

  re::ResourceFetchManager::xpcInterface(&buf);
  re::xpc::Connection::setRemoteObjectInterface(&v26, (uint64_t *)&buf);

  re::xpc::Connection::setQueue(&v26, (const re::dispatch::Queue *)(a1 + 40));
  v24[0] = MEMORY[0x263EF8330];
  v24[1] = 3221225472;
  v24[2] = ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke;
  v24[3] = &unk_264BE2330;
  dispatch_queue_t v8 = v7;
  signed int v25 = v8;
  [v26 setInterruptionHandler:v24];
  v22[0] = MEMORY[0x263EF8330];
  v22[1] = 3221225472;
  void v22[2] = ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke_54;
  v22[3] = &unk_264BE2330;
  long long v9 = v8;
  uint64_t v23 = v9;
  uint64_t v10 = *re::resourceSharingLogObjects((re *)[v26 setInvalidationHandler:v22]);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = a3;
    _os_log_debug_impl(&dword_233120000, v10, OS_LOG_TYPE_DEBUG, "Establishing new resource connection with peer ID %llu", (uint8_t *)&buf, 0xCu);
  }
  *(void *)&long long buf = 0;
  *((void *)&buf + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = &buf;
  uint64_t v28 = 0x2020000000;
  char v29 = 1;
  uint64_t v11 = *(void **)(a1 + 40);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3321888768;
  block[2] = ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke_55;
  block[3] = &unk_26E6CD410;
  p_long long buf = &buf;
  uint64_t v19 = a1;
  uint64_t v20 = a3;
  int v12 = v11;
  id v21 = v26;
  signed int v13 = v9;
  uint64_t v17 = v13;
  dispatch_sync(v12, block);

  if (*(unsigned char *)(*((void *)&buf + 1) + 24))
  {
    uint64_t v14 = objc_opt_new();
    [v26 resume];
    re::xpc::Connection::remoteObjectProxy(&v26, &v15);
    [v15 associateConnectionWithPeerID:*(void *)(a1 + 48) clientPorts:v14];

    (*(void (**)(void))(**(void **)(a1 + 24) + 376))();
  }

  _Block_object_dispose(&buf, 8);
}

void ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke(id *a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v2 = *re::resourceSharingLogObjects((re *)a1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = a1[4];
    *(_DWORD *)long long buf = 138412290;
    id v9 = v3;
    _os_log_impl(&dword_233120000, v2, OS_LOG_TYPE_DEFAULT, "Resource connection with server %@ was interrupted", buf, 0xCu);
  }
  uint64_t v4 = [a1[4] resourceSharingManager];
  if (v4)
  {
    uint64_t v5 = v4;
    id v6 = a1[4];
    id v7 = v6;
    re::ResourceSharingManager::connectionInterruptedOrInvalidated(v5, &v7);
  }
}

void re::ResourceSharingManager::connectionInterruptedOrInvalidated(uint64_t a1, id *a2)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 40));
  uint64_t v47 = a2;
  uint64_t v4 = (re::PeerIDValidator *)[*a2 peerID];
  uint64_t v5 = re::PeerIDValidator::instance(v4);
  re::PeerIDValidator::remove_impl((re::PeerIDValidator *)v5, (unint64_t)v4);
  unint64_t v7 = *(void *)(a1 + 80);
  if (!v7)
  {
LABEL_5:
    int v12 = *re::resourceSharingLogObjects(v6);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    id v13 = *a2;
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v13;
    uint64_t v14 = v12;
    id v15 = "Resource connection with server %@ interrupted/invalidated: not found in connection list";
LABEL_49:
    _os_log_debug_impl(&dword_233120000, v14, OS_LOG_TYPE_DEBUG, v15, buf, 0xCu);

    return;
  }
  unint64_t v8 = 0;
  uint64_t v9 = *(void *)(a1 + 96);
  uint64_t v10 = 120;
  while (1)
  {
    uint64_t v11 = v9 + v10;
    if (*(id *)(v9 + v10 - 112) == *a2) {
      break;
    }
    ++v8;
    v10 += 168;
    if (v7 == v8) {
      goto LABEL_5;
    }
  }
  uint64_t v16 = *(unsigned int *)(v11 - 64);
  if (v16)
  {
    uint64_t v17 = 0;
    unsigned int v18 = (int *)(*(void *)(v9 + v10 - 80) + 8);
    while (1)
    {
      int v19 = *v18;
      v18 += 6;
      if (v19 < 0) {
        break;
      }
      if (v16 == ++v17)
      {
        LODWORD(v17) = *(_DWORD *)(v11 - 64);
        break;
      }
    }
  }
  else
  {
    LODWORD(v17) = 0;
  }
  if (v16 != v17)
  {
    uint64_t v20 = v17;
    uint64_t v21 = v9 + v10;
    do
    {
      uint64_t v22 = *(void *)(*(void *)(v21 - 80) + 24 * v20 + 16) + 72;
      id v23 = *a2;
      re::DynamicArray<REResourceSharingClientObject * {__strong}>::remove(v22, (uint64_t)v23);

      unsigned int v24 = *(_DWORD *)(v11 - 64);
      if (v24 <= (int)v17 + 1) {
        unsigned int v24 = v17 + 1;
      }
      int v25 = v17;
      while (1)
      {
        uint64_t v20 = (v25 + 1);
        if (v24 - 1 == v25) {
          break;
        }
        ++v25;
        LODWORD(v17) = v20;
        if ((*(_DWORD *)(*(void *)(v21 - 80) + 24 * v20 + 8) & 0x80000000) != 0) {
          goto LABEL_22;
        }
      }
      LODWORD(v17) = v24;
LABEL_22:
      ;
    }
    while (v16 != v17);
    unint64_t v7 = *(void *)(a1 + 80);
  }
  if (v7 <= v8)
  {
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_51;
  }
  re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear(*(void *)(a1 + 96) + v10 - 96);
  if (*(void *)(a1 + 80) <= v8)
  {
LABEL_51:
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_52;
  }
  [*(id *)(*(void *)(a1 + 96) + v10 - 120) invalidate];
  if (*(void *)(a1 + 80) <= v8)
  {
LABEL_52:
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_53;
  }
  [*(id *)(*(void *)(a1 + 96) + v10 - 112) invalidate];
  if (*(void *)(a1 + 80) <= v8)
  {
LABEL_53:
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  (*(void (**)(void, void))(**(void **)(a1 + 24) + 384))(*(void *)(a1 + 24), *(void *)(*(void *)(a1 + 96) + v10 - 104));
  unint64_t v26 = *(void *)(a1 + 80);
  if (v26 <= v8) {
    goto LABEL_54;
  }
  if (v26 - 1 > v8)
  {
    uint64_t v27 = *(void *)(a1 + 96);
    uint64_t v28 = v27 + 168 * v26;
    uint64_t v29 = v10 - 168 * v26;
    uint64_t v30 = v27 + v10;
    if (v29 != -48)
    {
      uint64_t v31 = *(void *)(v28 - 168);
      *(void *)(v28 - 168) = 0;
      uint64_t v32 = *(void **)(v30 - 120);
      *(void *)(v30 - 120) = v31;
    }
    uint64_t v33 = *(void *)(v28 - 160);
    *(void *)(v28 - 160) = 0;
    char v34 = *(void **)(v30 - 112);
    *(void *)(v30 - 112) = v33;

    *(void *)(v30 - 104) = *(void *)(v28 - 152);
    if (v29 != -48)
    {
      uint64_t v35 = (uint64_t *)(v30 - 96);
      uint64_t v36 = (uint64_t *)(v28 - 144);
      uint64_t v37 = *(void *)(v30 - 96);
      if (!v37 || (uint64_t v38 = *v36, v37 == *v36))
      {
        re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v35, v36);
      }
      else
      {
        re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear((uint64_t)v35);
        if (v38)
        {
          unsigned int v39 = *(_DWORD *)(v28 - 116);
          if (*(_DWORD *)(v27 + v10 - 72) < v39) {
            re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::setCapacity((uint64_t)v35, v39);
          }
          unint64_t v40 = *(unsigned int *)(v28 - 112);
          if (v40)
          {
            uint64_t v41 = 0;
            for (unint64_t i = 0; i < v40; ++i)
            {
              uint64_t v43 = *(void *)(v28 - 128) + v41;
              if ((*(_DWORD *)(v43 + 8) & 0x80000000) != 0)
              {
                re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::addAsCopy((uint64_t)v35, *(void *)v43 % (unint64_t)*(unsigned int *)(v27 + v10 - 72), *(void *)v43, (uint64_t *)(v43 + 16));
                unint64_t v40 = *(unsigned int *)(v28 - 112);
              }
              v41 += 24;
            }
          }
          ++*(_DWORD *)(v27 + v10 - 56);
        }
      }
    }
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(v27 + v10 - 48, v28 - 96);
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(v27 + v10, v28 - 48);
    unint64_t v26 = *(void *)(a1 + 80);
  }
  uint64_t v44 = *(void *)(a1 + 96) + 168 * v26;
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(v44 - 48));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(v44 - 96));
  re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)(v44 - 144));

  --*(void *)(a1 + 80);
  ++*(_DWORD *)(a1 + 88);
  unsigned int v46 = *re::resourceSharingLogObjects(v45);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
  {
    id v13 = *v47;
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v13;
    uint64_t v14 = v46;
    id v15 = "Resource connection with server %@ interrupted/invalidated: removed from connection list";
    goto LABEL_49;
  }
}

void ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke_54(id *a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v2 = *re::resourceSharingLogObjects((re *)a1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = a1[4];
    *(_DWORD *)long long buf = 138412290;
    id v9 = v3;
    _os_log_impl(&dword_233120000, v2, OS_LOG_TYPE_DEFAULT, "Resource connection with server %@ was invalidated", buf, 0xCu);
  }
  uint64_t v4 = [a1[4] resourceSharingManager];
  if (v4)
  {
    uint64_t v5 = v4;
    id v6 = a1[4];
    id v7 = v6;
    re::ResourceSharingManager::connectionInterruptedOrInvalidated(v5, &v7);
  }
}

void ___ZN2re22ResourceSharingManager7connectERKNS_3xpc16ListenerEndpointEy_block_invoke_55(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  *(_DWORD *)&unsigned char v21[8] = objc_msgSend(*(id *)(a1 + 64), "processIdentifier", *(void *)(a1 + 56));
  id v3 = *(void **)(a1 + 64);
  if (v3) {
    id v3 = (void *)[v3 auditToken];
  }
  else {
    memset(&v21[12], 0, 32);
  }
  *(_DWORD *)&v21[44] = 0;
  uint64_t v4 = re::PeerIDValidator::instance((re::PeerIDValidator *)v3);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = re::PeerIDValidator::validateOrAdd_impl(v4, (uint64_t)v21);
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    id v5 = *(id *)(a1 + 64);
    id v6 = (_anonymous_namespace_ *)*(id *)(a1 + 32);
    id v7 = v6;
    uint64_t v8 = *(void *)(a1 + 56);
    *(void *)&v21[16] = v8;
    uint64_t v26 = 0;
    uint64_t v35 = 0x7FFFFFFF00000000;
    uint64_t v36 = 0;
    uint64_t v32 = 0;
    uint64_t v34 = 0;
    unint64_t v9 = *(void *)(v2 + 72);
    unint64_t v10 = *(void *)(v2 + 80);
    if (v10 >= v9)
    {
      unint64_t v11 = v10 + 1;
      if (v9 < v10 + 1)
      {
        if (*(void *)(v2 + 64))
        {
          uint64_t v12 = 2 * v9;
          BOOL v13 = v9 == 0;
          unint64_t v14 = 8;
          if (!v13) {
            unint64_t v14 = v12;
          }
          if (v14 <= v11) {
            unint64_t v15 = v11;
          }
          else {
            unint64_t v15 = v14;
          }
          re::DynamicArray<re::ResourceSharingManager::Connection>::setCapacity((void *)(v2 + 64), v15);
        }
        else
        {
          re::DynamicArray<re::ResourceSharingManager::Connection>::setCapacity((void *)(v2 + 64), v11);
          ++*(_DWORD *)(v2 + 88);
        }
      }
      unint64_t v10 = *(void *)(v2 + 80);
    }
    uint64_t v16 = *(void *)(v2 + 96) + 168 * v10;
    *(_OWORD *)uint64_t v21 = 0u;
    *(void *)uint64_t v16 = v5;
    *(void *)(v16 + 8) = v7;
    *(_DWORD *)(v16 + 64) = 0;
    *(void *)(v16 + 16) = v8;
    *(void *)(v16 + 24) = 0;
    *(void *)&v21[24] = 0;
    *(void *)(v16 + 32) = 0;
    *(void *)&unsigned char v21[32] = 0;
    *(void *)(v16 + 40) = 0;
    *(void *)&v21[40] = 0;
    *(_DWORD *)(v16 + 48) = 0;
    int v22 = 0;
    *(_DWORD *)(v16 + 52) = 0;
    int v23 = 0;
    *(_DWORD *)(v16 + 56) = 0;
    int v24 = 0;
    *(_DWORD *)(v16 + 60) = 0x7FFFFFFF;
    int v25 = 0x7FFFFFFF;
    *(_DWORD *)(v16 + 104) = 0;
    *(void *)(v16 + 96) = 0;
    *(_OWORD *)(v16 + 80) = 0u;
    *(_DWORD *)(v16 + 112) = 0;
    *(void *)(v16 + 72) = 0;
    v27[0] = 0;
    uint64_t v17 = *(void *)(v16 + 80);
    *(void *)(v16 + 80) = 0;
    v27[1] = v17;
    uint64_t v18 = *(void *)(v16 + 88);
    *(void *)(v16 + 88) = 0;
    _OWORD v27[2] = v18;
    LODWORD(v18) = *(_DWORD *)(v16 + 96);
    *(_DWORD *)(v16 + 96) = 0;
    int v28 = v18;
    LODWORD(v18) = *(_DWORD *)(v16 + 100);
    *(_DWORD *)(v16 + 100) = 0;
    int v29 = v18;
    LODWORD(v18) = *(_DWORD *)(v16 + 104);
    *(_DWORD *)(v16 + 104) = 0;
    int v30 = v18;
    *(_DWORD *)(v16 + 108) = 0x7FFFFFFF;
    int v31 = 0x7FFFFFFF;
    *(_DWORD *)(v16 + 152) = 0;
    *(void *)(v16 + 144) = 0;
    *(_OWORD *)(v16 + 128) = 0u;
    *(_DWORD *)(v16 + 160) = 0;
    *(void *)(v16 + 120) = 0;
    v33[0] = 0;
    uint64_t v19 = *(void *)(v16 + 128);
    *(void *)(v16 + 128) = 0;
    v33[1] = v19;
    uint64_t v20 = *(void *)(v16 + 136);
    *(void *)(v16 + 136) = 0;
    v33[2] = v20;
    LODWORD(v20) = *(_DWORD *)(v16 + 144);
    *(_DWORD *)(v16 + 144) = 0;
    LODWORD(v34) = v20;
    LODWORD(v20) = *(_DWORD *)(v16 + 148);
    *(_DWORD *)(v16 + 148) = HIDWORD(v34);
    HIDWORD(v34) = v20;
    LODWORD(v20) = *(_DWORD *)(v16 + 152);
    *(_DWORD *)(v16 + 152) = v35;
    LODWORD(v35) = v20;
    *(_DWORD *)(v16 + 156) = HIDWORD(v35);
    HIDWORD(v35) = 0x7FFFFFFF;
    ++*(void *)(v2 + 80);
    ++*(_DWORD *)(v2 + 88);
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v33);
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v27);
    re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)&v21[24]);
  }
}

id __copy_helper_block_a8_64c25_ZTSN2re3xpc10ConnectionE(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 64);
  *(void *)(a1 + 64) = result;
  return result;
}

void __destroy_helper_block_a8_64c25_ZTSN2re3xpc10ConnectionE(uint64_t a1)
{
}

uint64_t re::ResourceSharingManager::connectedPeers@<X0>(re::ResourceSharingManager *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v6 = 0;
  id v7 = &v6;
  uint64_t v8 = 0x5812000000;
  unint64_t v9 = __Block_byref_object_copy__1;
  unint64_t v10 = __Block_byref_object_dispose__1;
  unint64_t v11 = "";
  uint64_t v16 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v12 = 0;
  int v15 = 0;
  id v3 = *((void *)this + 5);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = ___ZNK2re22ResourceSharingManager14connectedPeersEv_block_invoke;
  block[3] = &unk_264BE25F0;
  void block[4] = &v6;
  void block[5] = this;
  dispatch_sync(v3, block);
  re::DynamicArray<char const*>::DynamicArray(a2, v7 + 6);
  _Block_object_dispose(&v6, 8);
  uint64_t result = v12;
  if (v12)
  {
    if (v16) {
      return (*(uint64_t (**)(void))(*(void *)v12 + 40))();
    }
  }
  return result;
}

uint64_t __Block_byref_object_dispose__1(uint64_t a1)
{
  return re::DynamicArray<unsigned long>::deinit(a1 + 48);
}

void *___ZNK2re22ResourceSharingManager14connectedPeersEv_block_invoke(void *result)
{
  uint64_t v1 = result[5];
  uint64_t v2 = *(void *)(v1 + 80);
  if (v2)
  {
    id v3 = result;
    uint64_t v4 = 168 * v2;
    id v5 = (void *)(*(void *)(v1 + 96) + 16);
    do
    {
      uint64_t result = re::DynamicArray<re::TransitionCondition *>::add((void *)(*(void *)(v3[4] + 8) + 48), v5);
      v5 += 21;
      v4 -= 168;
    }
    while (v4);
  }
  return result;
}

void re::ResourceSharingManager::pushDirectCommit(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_assert_queue_not_V2(*(dispatch_queue_t *)(a1 + 40));
  uint64_t v4 = *(NSObject **)(a1 + 40);
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = ___ZN2re22ResourceSharingManager16pushDirectCommitEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
  v6[3] = &unk_264BE2618;
  id v7 = v3;
  uint64_t v8 = a1;
  id v5 = v3;
  dispatch_sync(v4, v6);
}

void ___ZN2re22ResourceSharingManager16pushDirectCommitEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 80);
  if (v2)
  {
    uint64_t v4 = *(id **)(v1 + 96);
    uint64_t v5 = 168 * v2;
    do
    {
      uint64_t v6 = re::ResourceFetchManager::Connection::remoteObjectProxy(v4);
      id v7 = [[REXPCObject alloc] initWithObject:*(void *)(a1 + 32)];
      [v6 receiveDirectResourceCommit:v7];

      v4 += 21;
      v5 -= 168;
    }
    while (v5);
  }
}

void re::ResourceSharingManager::sendReferenceObject(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_assert_queue_not_V2(*(dispatch_queue_t *)(a1 + 40));
  uint64_t v4 = *(NSObject **)(a1 + 40);
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = ___ZN2re22ResourceSharingManager19sendReferenceObjectEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
  v6[3] = &unk_264BE2618;
  id v7 = v3;
  uint64_t v8 = a1;
  id v5 = v3;
  dispatch_sync(v4, v6);
}

void ___ZN2re22ResourceSharingManager19sendReferenceObjectEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 80);
  if (v2)
  {
    uint64_t v4 = *(id **)(v1 + 96);
    uint64_t v5 = 168 * v2;
    do
    {
      uint64_t v6 = re::ResourceFetchManager::Connection::remoteObjectProxy(v4);
      id v7 = [[REXPCObject alloc] initWithObject:*(void *)(a1 + 32)];
      [v6 receiveReferenceObject:v7];

      v4 += 21;
      v5 -= 168;
    }
    while (v5);
  }
}

uint64_t re::ResourceSharingManager::decodeShaderGraph@<X0>(dispatch_queue_t *this@<X0>, const re::Data *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  dispatch_assert_queue_not_V2(this[5]);
  uint64_t v30 = 0;
  int v31 = &v30;
  uint64_t v32 = 0x5812000000;
  uint64_t v33 = __Block_byref_object_copy__59;
  uint64_t v34 = __Block_byref_object_dispose__60;
  uint64_t v35 = "";
  uint64_t v38 = 0;
  memset(v36, 0, sizeof(v36));
  int v37 = 0;
  uint64_t v6 = this[5];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = ___ZN2re22ResourceSharingManager17decodeShaderGraphERKNS_4DataE_block_invoke;
  block[3] = &unk_264BE25F0;
  void block[4] = &v30;
  void block[5] = this;
  dispatch_sync(v6, block);
  if ((unint64_t)v31[8] >= 2)
  {
    uint64_t v8 = *re::resourceSharingLogObjects(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = v31[8];
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v18;
      _os_log_error_impl(&dword_233120000, v8, OS_LOG_TYPE_ERROR, "Expected num connections <= 1, have %zu", (uint8_t *)&buf, 0xCu);
    }
  }
  *(void *)&long long buf = 0;
  *((void *)&buf + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = &buf;
  uint64_t v40 = 0x3812000000;
  uint64_t v41 = __Block_byref_object_copy__62;
  unint64_t v42 = __Block_byref_object_dispose__63;
  uint64_t v43 = 0;
  id v44 = [MEMORY[0x263F087E8] errorWithDomain:@"No XPC connection" code:0 userInfo:0];

  uint64_t v22 = 0;
  int v23 = &v22;
  uint64_t v24 = 0x3812000000;
  int v25 = __Block_byref_object_copy__66;
  uint64_t v27 = 0;
  id v28 = 0;
  uint64_t v26 = __Block_byref_object_dispose__67;
  uint64_t v9 = v31[8];
  if (!v9) {
    goto LABEL_9;
  }
  unint64_t v10 = (id *)v31[10];
  uint64_t v11 = MEMORY[0x263EF8330];
  uint64_t v12 = 8 * v9;
  do
  {
    v20[0] = v11;
    v20[1] = 3221225472;
    v20[2] = ___ZN2re22ResourceSharingManager17decodeShaderGraphERKNS_4DataE_block_invoke_68;
    v20[3] = &unk_264BE2640;
    v20[4] = &buf;
    re::xpc::Connection::syncRemoteObjectProxy(v10, (uint64_t)v20, &v21);
    uint64_t v13 = *(void *)a2;
    v19[0] = MEMORY[0x263EF8330];
    v19[1] = 3221225472;
    _WORD v19[2] = ___ZN2re22ResourceSharingManager17decodeShaderGraphERKNS_4DataE_block_invoke_2;
    void v19[3] = &unk_264BE2668;
    uint64_t v19[4] = &buf;
    v19[5] = &v22;
    [v21 decodeShaderGraph:v13 withReply:v19];

    ++v10;
    v12 -= 8;
  }
  while (v12);
  uint64_t v14 = (void *)v23[6];
  if (v14)
  {
    char v15 = 1;
  }
  else
  {
LABEL_9:
    char v15 = 0;
    uint64_t v14 = *(void **)(*((void *)&buf + 1) + 48);
  }
  id v16 = v14;
  *(unsigned char *)a3 = v15;
  *(void *)(a3 + 8) = v16;
  _Block_object_dispose(&v22, 8);

  _Block_object_dispose(&buf, 8);
  _Block_object_dispose(&v30, 8);
  return re::DynamicArray<re::ObjCObject>::deinit((uint64_t)v36);
}

uint64_t __Block_byref_object_copy__59(uint64_t result, uint64_t a2)
{
  *(void *)(result + 80) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(_DWORD *)(result + 72) = 0;
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v3 = *(void *)(result + 64);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v3;
  uint64_t v4 = *(void *)(result + 80);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v4;
  ++*(_DWORD *)(a2 + 72);
  ++*(_DWORD *)(result + 72);
  return result;
}

uint64_t __Block_byref_object_dispose__60(uint64_t a1)
{
  return re::DynamicArray<re::ObjCObject>::deinit(a1 + 48);
}

_anonymous_namespace_ *___ZN2re22ResourceSharingManager17decodeShaderGraphERKNS_4DataE_block_invoke(_anonymous_namespace_ *result)
{
  uint64_t v1 = *((void *)result + 5);
  uint64_t v2 = *(void *)(v1 + 80);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void ***)(v1 + 96);
    uint64_t v5 = 168 * v2;
    do
    {
      uint64_t v6 = *(void *)(*((void *)v3 + 4) + 8);
      unint64_t v7 = *(void *)(v6 + 56);
      unint64_t v8 = *(void *)(v6 + 64);
      if (v8 >= v7)
      {
        unint64_t v9 = v8 + 1;
        if (v7 < v9)
        {
          if (*(void *)(v6 + 48))
          {
            if (v7) {
              unint64_t v10 = 2 * v7;
            }
            else {
              unint64_t v10 = 8;
            }
            if (v10 <= v9) {
              unint64_t v11 = v9;
            }
            else {
              unint64_t v11 = v10;
            }
            re::DynamicArray<re::ObjCObject>::setCapacity((void *)(v6 + 48), v11);
          }
          else
          {
            re::DynamicArray<re::ObjCObject>::setCapacity((void *)(v6 + 48), v9);
            ++*(_DWORD *)(v6 + 72);
          }
        }
        unint64_t v8 = *(void *)(v6 + 64);
      }
      uint64_t v12 = *(void *)(v6 + 80);
      uint64_t v13 = *v4;
      v4 += 21;
      uint64_t result = v13;
      *(void *)(v12 + 8 * v8) = result;
      ++*(void *)(v6 + 64);
      ++*(_DWORD *)(v6 + 72);
      v5 -= 168;
    }
    while (v5);
  }
  return result;
}

uint64_t __Block_byref_object_copy__62(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__63(uint64_t a1)
{
}

uint64_t __Block_byref_object_copy__66(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__67(uint64_t a1)
{
}

void **___ZN2re22ResourceSharingManager17decodeShaderGraphERKNS_4DataE_block_invoke_68(uint64_t a1, void *a2)
{
  return re::ObjCObject::operator=((void **)(*(void *)(*(void *)(a1 + 32) + 8) + 48), a2);
}

void ___ZN2re22ResourceSharingManager17decodeShaderGraphERKNS_4DataE_block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  if (v5)
  {
    uint64_t v6 = (void **)(*(void *)(*(void *)(a1 + 32) + 8) + 48);
    unint64_t v7 = v5;
  }
  else
  {
    if (!v8) {
      goto LABEL_6;
    }
    uint64_t v6 = (void **)(*(void *)(*(void *)(a1 + 40) + 8) + 48);
    unint64_t v7 = v8;
  }
  re::ObjCObject::operator=(v6, v7);
LABEL_6:
}

void re::ResourceSharingManager::payloadDidChange(dispatch_queue_t *this, const re::AssetHandle *a2)
{
  dispatch_assert_queue_V2(this[4]);
  uint64_t v4 = this[5];
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3221225472;
  void v5[2] = ___ZN2re22ResourceSharingManager16payloadDidChangeERKNS_11AssetHandleE_block_invoke;
  v5[3] = &__block_descriptor_48_e5_v8__0l;
  void v5[4] = this;
  v5[5] = a2;
  dispatch_sync(v4, v5);
}

void ___ZN2re22ResourceSharingManager16payloadDidChangeERKNS_11AssetHandleE_block_invoke(uint64_t a1)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(const re::AssetHandle **)(a1 + 32);
  uint64_t v3 = re::AssetHandle::assetInfo(*(re::AssetHandle **)(a1 + 40));
  uint64_t v4 = (re *)re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)v3 + 96);
  uint64_t v5 = *((void *)v2 + 10);
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *((void *)v2 + 12);
    uint64_t v8 = v7 + 168 * v5;
    do
    {
      uint64_t v9 = *(unsigned int *)(v7 + 56);
      if (v9)
      {
        uint64_t v10 = 0;
        unint64_t v11 = (int *)(*(void *)(v7 + 40) + 8);
        while (1)
        {
          int v12 = *v11;
          v11 += 6;
          if (v12 < 0) {
            break;
          }
          if (v9 == ++v10)
          {
            LODWORD(v10) = *(_DWORD *)(v7 + 56);
            break;
          }
        }
      }
      else
      {
        LODWORD(v10) = 0;
      }
      if (v9 != v10)
      {
        uint64_t v13 = v10;
        uint64_t v14 = *(void *)(v7 + 40);
        while (1)
        {
          uint64_t v15 = *(void *)(v14 + 24 * v13 + 16);
          if (*(re **)(v15 + 56) == v4) {
            break;
          }
          if (v9 <= (int)v10 + 1) {
            int v16 = v10 + 1;
          }
          else {
            int v16 = *(_DWORD *)(v7 + 56);
          }
          while (1)
          {
            uint64_t v13 = (v10 + 1);
            if (v16 - 1 == v10) {
              break;
            }
            LODWORD(v10) = v10 + 1;
            int v17 = v13;
            if ((*(_DWORD *)(v14 + 24 * v13 + 8) & 0x80000000) != 0) {
              goto LABEL_19;
            }
          }
          int v17 = v16;
LABEL_19:
          LODWORD(v10) = v17;
          if (v9 == v17) {
            goto LABEL_22;
          }
        }
        uint64_t v6 = (void *)v15;
      }
LABEL_22:
      v7 += 168;
    }
    while (v7 != v8);
    if (v6 && v6[11])
    {
      uint64_t v18 = *re::resourceSharingLogObjects(v4);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        unint64_t v42 = *(re::AssetHandle **)(a1 + 40);
        uint64_t v43 = v18;
        id v44 = re::AssetHandle::assetInfo(v42);
        if (v44[17]) {
          uint64_t v45 = (char *)v44[18];
        }
        else {
          uint64_t v45 = (char *)v44 + 137;
        }
        uint64_t v46 = v6[11];
        *(_DWORD *)long long buf = 136315394;
        *(void *)int64_t v54 = v45;
        *(_WORD *)&v54[8] = 2048;
        *(void *)&v54[10] = v46;
        _os_log_debug_impl(&dword_233120000, v43, OS_LOG_TYPE_DEBUG, "Sending updated resource payload for '%s' to %zu subscribed servers", buf, 0x16u);
      }
      re::ResourceSharingManager::makeFetchRequestResult((re::ResourceSharingManager *)v49, v2, *(const re::AssetHandle **)(a1 + 40));
      uint64_t v20 = v6[11];
      if (v20)
      {
        id v21 = (id *)v6[13];
        uint64_t v22 = &v21[v20];
        *(void *)&long long v19 = 138412290;
        long long v47 = v19;
        unint64_t v48 = v22;
        do
        {
          id v23 = *v21;
          char v24 = v49[0];
          int v25 = (re *)v50;
          uint64_t v26 = v25;
          uint64_t v27 = *((void *)v2 + 10);
          if (v27)
          {
            uint64_t v28 = *((void *)v2 + 12);
            uint64_t v29 = 168 * v27;
            while (*(id *)(v28 + 8) != v23)
            {
              v28 += 168;
              v29 -= 168;
              if (!v29) {
                goto LABEL_32;
              }
            }
            if (v6[4]) {
              uint64_t v33 = (char *)v6[5];
            }
            else {
              uint64_t v33 = (char *)v6 + 33;
            }
            uint64_t v34 = objc_msgSend(NSString, "stringWithUTF8String:", v33, v47);
            v51[0] = v24;
            long long v52 = v26;
            re::ResourceSharingManager::validateResult((uint64_t)buf, (uint64_t)v2, v28, v6, (uint64_t)v51);

            int v35 = buf[0];
            uint64_t v36 = *(void **)&v54[4];
            if (buf[0]) {
              int v37 = *(void **)&v54[4];
            }
            else {
              int v37 = 0;
            }
            id v38 = v37;
            if (v35) {
              id v39 = 0;
            }
            else {
              id v39 = v36;
            }
            id v40 = v39;

            uint64_t v41 = re::ResourceFetchManager::Connection::remoteObjectProxy((id *)v28);
            [v41 resourceAtAssetPath:v34 payloadDidUpdate:v38 error:v40];

            uint64_t v22 = v48;
          }
          else
          {
LABEL_32:
            uint64_t v30 = *re::resourceSharingLogObjects(v25);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
            {
              id v31 = v23;
              *(_DWORD *)long long buf = v47;
              *(void *)int64_t v54 = v31;
              uint64_t v32 = v30;
              _os_log_fault_impl(&dword_233120000, v32, OS_LOG_TYPE_FAULT, "No resource connection exists for server %@", buf, 0xCu);
            }
          }

          ++v21;
        }
        while (v21 != v22);
      }
    }
  }
}

uint64_t re::ResourceSharingManager::makeFetchRequestResult(re::ResourceSharingManager *this, const re::AssetHandle *a2, const re::AssetHandle *a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v6 = *((void *)a2 + 6);
  memset(buf, 0, 32);
  uint64_t v7 = (_anonymous_namespace_ *)snprintf_l((char *)buf, 0x20uLL, 0, "%llu", v6);
  if ((v7 - 32) <= 0xFFFFFFE0)
  {
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) ", "0 < ret && ret < sizeof(str)", "peerIDToString", 202);
    _os_crash();
    __break(1u);
  }
  uint64_t v9 = *((void *)a2 + 3);
  re::AssetHandle::AssetHandle((re::AssetHandle *)v26, a3);
  if (v29) {
    uint64_t v10 = *(unsigned char **)&v30[7];
  }
  else {
    uint64_t v10 = v30;
  }
  (*(void (**)(id *__return_ptr, uint64_t, unsigned char *, unsigned char *))(*(void *)v9 + 224))(&v27, v9, v26, v10);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v26);
  if (v27)
  {
    int v12 = *re::resourceSharingLogObjects(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = v12;
      long long v19 = re::AssetHandle::assetInfo(a3);
      if (v19[17]) {
        uint64_t v20 = (char *)v19[18];
      }
      else {
        uint64_t v20 = (char *)v19 + 137;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v20;
      _os_log_debug_impl(&dword_233120000, v18, OS_LOG_TYPE_DEBUG, "Responding to resource fetch request for '%s'", buf, 0xCu);
    }
    id v13 = v27;
    *(unsigned char *)this = 1;
    *((void *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v13;
  }
  else
  {
    re::makeResourceSharingError((__CFString *)1, 0, &v25);
    uint64_t v15 = *re::resourceSharingLogObjects(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      id v21 = v15;
      uint64_t v22 = re::AssetHandle::assetInfo(a3);
      if (v22[17]) {
        id v23 = (char *)v22[18];
      }
      else {
        id v23 = (char *)v22 + 137;
      }
      id v24 = v25;
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v23;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v24;
      _os_log_error_impl(&dword_233120000, v21, OS_LOG_TYPE_ERROR, "Failed to handle resource fetch request for '%s': %@", buf, 0x16u);
    }
    id v16 = v25;
    *(unsigned char *)this = 0;
    *((void *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v16;
  }
  uint64_t result = v28;
  if (v28)
  {
    if (v29) {
      return (*(uint64_t (**)(void))(*(void *)v28 + 40))();
    }
  }
  return result;
}

void non-virtual thunk to're::ResourceSharingManager::payloadDidChange(dispatch_queue_t *this, const re::AssetHandle *a2)
{
}

void re::ResourceSharingManager::pushLoadAsset(re::ResourceSharingManager *this, const re::AssetHandle *a2, char a3)
{
  uint64_t v3 = *((void *)this + 5);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3221225472;
  block[2] = ___ZN2re22ResourceSharingManager13pushLoadAssetERKNS_11AssetHandleEb_block_invoke;
  block[3] = &__block_descriptor_49_e5_v8__0l;
  void block[4] = this;
  void block[5] = a2;
  char v5 = a3;
  dispatch_sync(v3, block);
}

void ___ZN2re22ResourceSharingManager13pushLoadAssetERKNS_11AssetHandleEb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 80);
  if (v2)
  {
    uint64_t v4 = *(id **)(v1 + 96);
    uint64_t v5 = 168 * v2;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
      if (v6) {
        uint64_t v7 = *(void **)(v6 + 264);
      }
      else {
        uint64_t v7 = 0;
      }
      uint64_t v8 = re::ResourceFetchManager::Connection::remoteObjectProxy(v4);
      uint64_t v9 = re::AssetHandle::assetInfo(*(re::AssetHandle **)(a1 + 40));
      if (v9[10] == -1) {
        uint64_t v10 = 0;
      }
      else {
        uint64_t v10 = v9[10];
      }
      unint64_t v11 = [NSString stringWithUTF8String:*v7];
      [v8 pushLoadResourceWithAssetId:v10 assetType:v11 isPriorityAsset:*(unsigned __int8 *)(a1 + 48)];

      v4 += 21;
      v5 -= 168;
    }
    while (v5);
  }
}

void non-virtual thunk to're::ResourceSharingManager::pushLoadAsset(re::ResourceSharingManager *this, const re::AssetHandle *a2, char a3)
{
}

void re::ResourceSharingManager::releaseAsset(re::ResourceSharingManager *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 5);
  v3[0] = MEMORY[0x263EF8330];
  v3[1] = 3221225472;
  v3[2] = ___ZN2re22ResourceSharingManager12releaseAssetEy_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = this;
  v3[5] = a2;
  dispatch_sync(v2, v3);
}

void ___ZN2re22ResourceSharingManager12releaseAssetEy_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 80);
  if (v2)
  {
    uint64_t v4 = *(id **)(v1 + 96);
    uint64_t v5 = 168 * v2;
    do
    {
      uint64_t v6 = re::ResourceFetchManager::Connection::remoteObjectProxy(v4);
      [v6 releaseResourceWithAssetId:*(void *)(a1 + 40)];

      v4 += 21;
      v5 -= 168;
    }
    while (v5);
  }
}

void non-virtual thunk to're::ResourceSharingManager::releaseAsset(re::ResourceSharingManager *this, uint64_t a2)
{
}

unint64_t re::ResourceSharingManager::drainResourceRequestQueue(re::ResourceSharingManager *this, dispatch_time_t a2)
{
  dispatch_time_t v3 = *((void *)this + 7);
  unint64_t v4 = *(void *)(v3 + 48);
  re::internal::ResourceRequestQueue::flushSync(v3, a2);
  unint64_t v5 = *(void *)(*((void *)this + 7) + 48);
  BOOL v6 = v4 >= v5;
  unint64_t v7 = v4 - v5;
  if (v6) {
    return v7;
  }
  else {
    return 0;
  }
}

unint64_t non-virtual thunk to're::ResourceSharingManager::drainResourceRequestQueue(re::ResourceSharingManager *this, dispatch_time_t a2)
{
  dispatch_time_t v3 = *((void *)this + 6);
  unint64_t v4 = *(void *)(v3 + 48);
  re::internal::ResourceRequestQueue::flushSync(v3, a2);
  unint64_t v5 = *(void *)(*((void *)this + 6) + 48);
  BOOL v6 = v4 >= v5;
  unint64_t v7 = v4 - v5;
  if (v6) {
    return v7;
  }
  else {
    return 0;
  }
}

void re::DynamicArray<REResourceSharingClientObject * {__strong}>::remove(uint64_t a1, uint64_t a2)
{
  dispatch_time_t v3 = *(void **)(a1 + 32);
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = &v3[v4];
  BOOL v6 = v3;
  if (v4)
  {
    uint64_t v7 = 8 * v4;
    BOOL v6 = *(void **)(a1 + 32);
    while (*v6 != a2)
    {
      ++v6;
      v7 -= 8;
      if (!v7)
      {
        BOOL v6 = &v3[v4];
        break;
      }
    }
  }
  unint64_t v8 = v6 - v3;
  if (v8 != v4)
  {
    if (v4 <= v8)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v4 - 1 > v8)
    {
      uint64_t v9 = *(v5 - 1);
      *(v5 - re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      uint64_t v10 = *(void *)(a1 + 32);
      unint64_t v11 = *(void **)(v10 + 8 * v8);
      *(void *)(v10 + 8 * v8) = v9;

      unint64_t v4 = *(void *)(a1 + 16);
      dispatch_time_t v3 = *(void **)(a1 + 32);
    }

    --*(void *)(a1 + 16);
    ++*(_DWORD *)(a1 + 24);
  }
}

uint64_t ___ZN2re22ResourceSharingManager19enqueueFetchRequestENS0_12FetchRequestE_block_invoke(uint64_t a1)
{
  uint64_t v82 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  int v37 = *(_DWORD *)(a1 + 40);
  re::DynamicString::DynamicString((re::DynamicString *)&v38, (const re::DynamicString *)(a1 + 48));
  re::DynamicString::DynamicString((re::DynamicString *)v40, (const re::DynamicString *)(a1 + 80));
  dispatch_time_t v3 = *(void **)(a1 + 120);
  uint64_t v41 = *(void *)(a1 + 112);
  id v42 = v3;
  aBlock = _Block_copy(*(const void **)(a1 + 128));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  uint64_t v61 = 0;
  uint64_t v62 = &v61;
  uint64_t v63 = 0x2020000000;
  uint64_t v64 = 0;
  unint64_t v4 = *(void **)(v2 + 40);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3321888768;
  block[2] = ___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke;
  block[3] = &unk_26E6CD4D8;
  void block[5] = v2;
  int v56 = v37;
  unint64_t v5 = v4;
  re::DynamicString::DynamicString((re::DynamicString *)v57, (const re::DynamicString *)&v38);
  re::DynamicString::DynamicString((re::DynamicString *)v58, (const re::DynamicString *)v40);
  void v58[4] = v41;
  id v59 = v42;
  id v60 = _Block_copy(aBlock);
  void block[4] = &v61;
  dispatch_sync(v5, block);

  if (v62[3])
  {
    (***(void (****)(uint64_t *__return_ptr))(v2 + 24))(&v53);
    if (v54) {
      uint64_t v7 = *(const char ***)(v54 + 264);
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v9 = re::AssetHandle::assetInfo((re::AssetHandle *)&v53);
    if (v9[10] == -1) {
      LODWORD(v1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    }
    else {
      uint64_t v11 = v9[10];
    }
    if (v7) {
      int v12 = *v7;
    }
    else {
      int v12 = 0;
    }
    id v13 = (re *)re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x80D, v11, v12, v10);
    if (v54)
    {
      unsigned int v14 = atomic_load((unsigned int *)(v54 + 704));
      if (v14 == 2)
      {
        re::ResourceSharingManager::makeFetchRequestResult((re::ResourceSharingManager *)v51, (const re::AssetHandle *)v2, (const re::AssetHandle *)&v53);
        *(void *)&long long v77 = 0;
        *((void *)&v77 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = &v77;
        uint64_t v78 = 0x3032000000;
        uint64_t v79 = __Block_byref_object_copy__87;
        uint64_t v80 = __Block_byref_object_dispose__88;
        id v81 = 0;
        uint64_t v45 = 0;
        uint64_t v46 = &v45;
        uint64_t v47 = 0x3032000000;
        unint64_t v48 = __Block_byref_object_copy__87;
        long long v49 = __Block_byref_object_dispose__88;
        id v50 = 0;
        uint64_t v15 = *(void **)(v2 + 40);
        *(void *)&long long buf = MEMORY[0x263EF8330];
        *((void *)&buf + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 3321888768;
        uint64_t v66 = ___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke_89;
        unint64_t v67 = &unk_26E6CD510;
        v70[1] = v2;
        unsigned int v68 = &v61;
        id v16 = v15;
        re::AssetHandle::AssetHandle((re::AssetHandle *)v71, (const re::AssetHandle *)&v53);
        BYTE8(v72) = v51[0];
        id v17 = v52;
        *(void *)&long long v73 = v17;
        uint64_t v69 = &v77;
        v70[0] = &v45;
        dispatch_sync(v16, &buf);

        uint64_t v18 = aBlock;
        id v19 = *(id *)(*((void *)&v77 + 1) + 40);
        id v44 = v19;

        re::AssetHandle::~AssetHandle((re::AssetHandle *)v71);
        _Block_object_dispose(&v45, 8);

        _Block_object_dispose(&v77, 8);
LABEL_38:
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v53);
        goto LABEL_39;
      }
      unsigned int v20 = atomic_load((unsigned int *)(v54 + 704));
      BOOL v21 = v20 == 3;
    }
    else
    {
      BOOL v21 = 0;
    }
    uint64_t v22 = *re::resourceSharingLogObjects(v13);
    BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
    if (v21)
    {
      if (!v23)
      {
LABEL_28:
        uint64_t v30 = aBlock;
        re::ResourceSharingManager::makeFetchRequestError((re::ResourceSharingManager *)&buf);

        goto LABEL_38;
      }
      id v24 = v22;
      uint64_t v66 = 0;
      unint64_t v67 = 0;
      long long buf = (unint64_t)v38;
      re::DynamicString::setCapacity(&buf, 0);
      re::AssetPath::fullAssetPath((re::DynamicString *)&v37, (re::DynamicString *)&buf);
      if (BYTE8(buf)) {
        id v25 = v66;
      }
      else {
        id v25 = (void (*)(uint64_t))((char *)&buf + 9);
      }
      LODWORD(v77) = 136315138;
      *(void *)((char *)&v77 + 4) = v25;
      uint64_t v26 = "Handled resource fetch request for '%s': asset loading has already failed";
    }
    else
    {
      if (v23)
      {
        uint64_t v34 = v22;
        uint64_t v66 = 0;
        unint64_t v67 = 0;
        long long buf = (unint64_t)v38;
        re::DynamicString::setCapacity(&buf, 0);
        re::AssetPath::fullAssetPath((re::DynamicString *)&v37, (re::DynamicString *)&buf);
        int v35 = (BYTE8(buf) & 1) != 0 ? v66 : (void (*)(uint64_t))((char *)&buf + 9);
        LODWORD(v77) = 136315138;
        *(void *)((char *)&v77 + 4) = v35;
        _os_log_debug_impl(&dword_233120000, v34, OS_LOG_TYPE_DEBUG, "Requesting async load of '%s' due to resource fetch request", (uint8_t *)&v77, 0xCu);

        if ((void)buf)
        {
          if (BYTE8(buf)) {
            (*(void (**)(void))(*(void *)buf + 40))();
          }
        }
      }
      re::AssetHandle::loadAsync((re::AssetHandle *)&v53);
      if (!v54 || (unsigned int v28 = atomic_load((unsigned int *)(v54 + 704)), v28 != 3))
      {
        id v31 = *(void **)(v2 + 40);
        *(void *)&long long buf = MEMORY[0x263EF8330];
        *((void *)&buf + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 3321888768;
        uint64_t v66 = ___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke_90;
        unint64_t v67 = &unk_26E6CD548;
        unsigned int v68 = &v61;
        uint64_t v69 = (long long *)v2;
        uint64_t v32 = v31;
        re::AssetHandle::AssetHandle((re::AssetHandle *)v70, (const re::AssetHandle *)&v53);
        v71[2] = v37;
        re::DynamicString::DynamicString((re::DynamicString *)&v72, (const re::DynamicString *)&v38);
        re::DynamicString::DynamicString((re::DynamicString *)v74, (const re::DynamicString *)v40);
        v74[4] = v41;
        id v75 = v42;
        id v76 = _Block_copy(aBlock);
        dispatch_sync(v32, &buf);

        if (v74[0])
        {
          if (v74[1]) {
            (*(void (**)(void))(*(void *)v74[0] + 40))();
          }
          memset(v74, 0, 32);
        }
        if ((void)v72)
        {
          if (BYTE8(v72)) {
            (*(void (**)(void))(*(void *)v72 + 40))();
          }
          long long v72 = 0u;
          long long v73 = 0u;
        }
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v70);
        goto LABEL_38;
      }
      char v29 = *re::resourceSharingLogObjects(v27);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_28;
      }
      id v24 = v29;
      uint64_t v66 = 0;
      unint64_t v67 = 0;
      long long buf = (unint64_t)v38;
      re::DynamicString::setCapacity(&buf, 0);
      re::AssetPath::fullAssetPath((re::DynamicString *)&v37, (re::DynamicString *)&buf);
      if (BYTE8(buf)) {
        uint64_t v36 = v66;
      }
      else {
        uint64_t v36 = (void (*)(uint64_t))((char *)&buf + 9);
      }
      LODWORD(v77) = 136315138;
      *(void *)((char *)&v77 + 4) = v36;
      uint64_t v26 = "Handled resource fetch request for '%s': asset loading failed to begin";
    }
    _os_log_debug_impl(&dword_233120000, v24, OS_LOG_TYPE_DEBUG, v26, (uint8_t *)&v77, 0xCu);

    if (void)buf && (BYTE8(buf)) {
      (*(void (**)(void))(*(void *)buf + 40))();
    }
    goto LABEL_28;
  }
  unint64_t v8 = *re::resourceSharingLogObjects(v6);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v42;
    _os_log_fault_impl(&dword_233120000, v8, OS_LOG_TYPE_FAULT, "No resource connection exists for server %@", (uint8_t *)&buf, 0xCu);
  }
LABEL_39:

  if (v58[0])
  {
    if (v58[1]) {
      (*(void (**)(void))(*(void *)v58[0] + 40))();
    }
    memset(v58, 0, 32);
  }
  if (v57[0])
  {
    if (v57[1]) {
      (*(void (**)(void))(*(void *)v57[0] + 40))();
    }
    memset(v57, 0, sizeof(v57));
  }
  _Block_object_dispose(&v61, 8);

  if (v40[0])
  {
    if (v40[1]) {
      (*(void (**)(void))(*(void *)v40[0] + 40))();
    }
    memset(v40, 0, sizeof(v40));
  }
  uint64_t result = v38;
  if (v38)
  {
    if (v39) {
      return (*(uint64_t (**)(void))(*(void *)v38 + 40))();
    }
  }
  return result;
}

void *__copy_helper_block_a8_40c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 48), (const re::DynamicString *)(a2 + 48));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 80), (const re::DynamicString *)(a2 + 80));
  unint64_t v4 = *(void **)(a2 + 120);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a1 + 120) = v4;
  uint64_t result = _Block_copy(*(const void **)(a2 + 128));
  *(void *)(a1 + 128) = result;
  return result;
}

double __destroy_helper_block_a8_40c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(id *a1)
{
  re::DynamicString::deinit((re::DynamicString *)(a1 + 10));
  return re::DynamicString::deinit((re::DynamicString *)(a1 + 6));
}

uint64_t ___ZN2re22ResourceSharingManager25enqueueUnsubscribeRequestENS0_18UnsubscribeRequestE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  dispatch_time_t v3 = *(void **)(v2 + 40);
  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3321888768;
  _OWORD v10[2] = ___ZN2re22ResourceSharingManager25enqueueUnsubscribeRequestENS0_18UnsubscribeRequestE_block_invoke_2;
  v10[3] = &__block_descriptor_80_a8_40c54_ZTSKN2re22ResourceSharingManager18UnsubscribeRequestE_e5_v8__0l;
  void v10[4] = v2;
  unint64_t v4 = (const re::DynamicString *)(a1 + 40);
  unint64_t v5 = v3;
  re::DynamicString::DynamicString((re::DynamicString *)&v11, v4);
  id v14 = *(id *)(a1 + 72);
  dispatch_sync(v5, v10);

  uint64_t result = v11;
  if (v11)
  {
    if (v12) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 40))(v11, v13, v6, v7, v8);
    }
  }
  return result;
}

uint64_t ___ZN2re22ResourceSharingManager25enqueueUnsubscribeRequestENS0_18UnsubscribeRequestE_block_invoke_2(uint64_t a1)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  re::DynamicString::DynamicString((re::DynamicString *)&v50, (const re::DynamicString *)(a1 + 40));
  id v54 = *(id *)(a1 + 72);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 40));
  uint64_t v4 = *(void *)(v2 + 80);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(v2 + 96);
    uint64_t v7 = 168 * v4;
    while (*(id *)(v6 + v5 + 8) != v54)
    {
      v5 += 168;
      if (v7 == v5) {
        goto LABEL_5;
      }
    }
    uint64_t v9 = *(unsigned int *)(v6 + v5 + 56);
    if (v9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = (int *)(*(void *)(v6 + v5 + 40) + 8);
      while (1)
      {
        int v12 = *v11;
        v11 += 6;
        if (v12 < 0) {
          break;
        }
        if (v9 == ++v10)
        {
          LODWORD(v10) = *(_DWORD *)(v6 + v5 + 56);
          break;
        }
      }
    }
    else
    {
      LODWORD(v10) = 0;
    }
    if (v9 == v10)
    {
LABEL_24:
      uint64_t v22 = *re::resourceSharingLogObjects((re *)v3);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        if (v51) {
          int v35 = v53;
        }
        else {
          int v35 = v52;
        }
        *(_DWORD *)long long buf = 138412546;
        id v56 = v54;
        __int16 v57 = 2080;
        int64_t v58 = v35;
        _os_log_error_impl(&dword_233120000, v22, OS_LOG_TYPE_ERROR, "Resource connection %@ ignored an unsubscribe request for '%s': no subscription exists", buf, 0x16u);
      }
    }
    else
    {
      uint64_t v13 = v10;
      uint64_t v14 = v6 + v5;
      uint64_t v15 = *(void *)(v6 + v5 + 40);
      while (1)
      {
        uint64_t v16 = v15 + 24 * v13;
        uint64_t v19 = *(void *)(v16 + 16);
        id v17 = (unint64_t *)(v16 + 16);
        uint64_t v18 = v19;
        BOOL v3 = re::DynamicString::operator==(v19 + 24, (uint64_t)&v50);
        if (v3) {
          break;
        }
        if (v9 <= (int)v10 + 1) {
          int v20 = v10 + 1;
        }
        else {
          int v20 = v9;
        }
        while (1)
        {
          uint64_t v13 = (v10 + 1);
          if (v20 - 1 == v10) {
            break;
          }
          LODWORD(v10) = v10 + 1;
          int v21 = v13;
          if ((*(_DWORD *)(v15 + 24 * v13 + 8) & 0x80000000) != 0) {
            goto LABEL_23;
          }
        }
        int v21 = v20;
LABEL_23:
        LODWORD(v10) = v21;
        if (v9 == v21) {
          goto LABEL_24;
        }
      }
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(v6 + v5 + 72, *(void *)(v18 + 64));
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(v6 + v5 + 120, *(void *)(*v17 + 64));
      unint64_t v24 = *v17;
      if (*v17) {
        id v25 = (id)(v24 + 8);
      }
      re::DynamicArray<REResourceSharingClientObject * {__strong}>::remove(v24 + 72, (uint64_t)v54);
      unint64_t v27 = *(unsigned int *)(v6 + v5 + 48);
      if (v27)
      {
        unint64_t v28 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v24 ^ (v24 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v24 ^ (v24 >> 30))) >> 27));
        unint64_t v29 = (v28 ^ (v28 >> 31)) % v27;
        uint64_t v30 = *(void *)(v6 + v5 + 32);
        uint64_t v31 = *(unsigned int *)(v30 + 4 * v29);
        if (v31 != 0x7FFFFFFF)
        {
          uint64_t v32 = *(void *)(v14 + 40);
          if (*(void *)(v32 + 24 * v31 + 16) == v24)
          {
            *(_DWORD *)(v30 + 4 * v29) = *(_DWORD *)(v32 + 24 * v31 + 8) & 0x7FFFFFFF;
LABEL_42:
            uint64_t v36 = *(void *)(v14 + 40);
            uint64_t v37 = v36 + 24 * v31;
            int v40 = *(_DWORD *)(v37 + 8);
            uint64_t v38 = (int *)(v37 + 8);
            int v39 = v40;
            if (v40 < 0)
            {
              *uint64_t v38 = v39 & 0x7FFFFFFF;
              uint64_t v41 = v36 + 24 * v31;
              uint64_t v44 = *(void *)(v41 + 16);
              uint64_t v43 = (void *)(v41 + 16);
              uint64_t v42 = v44;
              if (v44)
              {

                *uint64_t v43 = 0;
              }
            }
            uint64_t v45 = (_DWORD *)(v6 + v5);
            uint64_t v46 = *(void *)(v14 + 40) + 24 * v31;
            *(_DWORD *)(v46 + 8) = *(_DWORD *)(v46 + 8) & 0x80000000 | *(_DWORD *)(v6 + v5 + 60);
            v45[13] = *(_DWORD *)(v6 + v5 + 52) - 1;
            int v47 = *(_DWORD *)(v6 + v5 + 64) + 1;
            v45[15] = v31;
            unsigned char v45[16] = v47;
          }
          else
          {
            while (1)
            {
              unsigned int v33 = v31;
              int v34 = *(_DWORD *)(v32 + 24 * v31 + 8);
              uint64_t v31 = v34 & 0x7FFFFFFF;
              if ((v34 & 0x7FFFFFFF) == 0x7FFFFFFF) {
                break;
              }
              if (*(void *)(v32 + 24 * v31 + 16) == v24)
              {
                *(_DWORD *)(v32 + 24 * v33 + 8) = *(_DWORD *)(v32 + 24 * v33 + 8) & 0x80000000 | *(_DWORD *)(v32 + 24 * v31 + 8) & 0x7FFFFFFF;
                goto LABEL_42;
              }
            }
          }
        }
      }
      unint64_t v48 = *re::resourceSharingLogObjects(v26);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        if (v51) {
          long long v49 = v53;
        }
        else {
          long long v49 = v52;
        }
        *(_DWORD *)long long buf = 138412546;
        id v56 = v54;
        __int16 v57 = 2080;
        int64_t v58 = v49;
        _os_log_debug_impl(&dword_233120000, v48, OS_LOG_TYPE_DEBUG, "Resource connection %@ unsubscribed from '%s'", buf, 0x16u);
        if (!v24) {
          goto LABEL_25;
        }
      }
      else if (!v24)
      {
        goto LABEL_25;
      }
    }
  }
  else
  {
LABEL_5:
    uint64_t v8 = *re::resourceSharingLogObjects((re *)v3);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v56 = v54;
      _os_log_fault_impl(&dword_233120000, v8, OS_LOG_TYPE_FAULT, "No resource connection exists for server %@", buf, 0xCu);
    }
  }
LABEL_25:

  uint64_t result = v50;
  if (v50)
  {
    if (v51) {
      return (*(uint64_t (**)(void))(*(void *)v50 + 40))();
    }
  }
  return result;
}

id __copy_helper_block_a8_40c54_ZTSKN2re22ResourceSharingManager18UnsubscribeRequestE(uint64_t a1, uint64_t a2)
{
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  id result = *(id *)(a2 + 72);
  *(void *)(a1 + 72) = result;
  return result;
}

double __destroy_helper_block_a8_40c54_ZTSKN2re22ResourceSharingManager18UnsubscribeRequestE(uint64_t a1)
{
  uint64_t v1 = (re::DynamicString *)(a1 + 40);

  return re::DynamicString::deinit(v1);
}

uint64_t ___ZN2re22ResourceSharingManager24enqueueSetOptionsRequestENS0_17SetOptionsRequestE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = *(void **)(v2 + 40);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3321888768;
  block[2] = ___ZN2re22ResourceSharingManager24enqueueSetOptionsRequestENS0_17SetOptionsRequestE_block_invoke_2;
  block[3] = &__block_descriptor_88_a8_40c52_ZTSN2re22ResourceSharingManager17SetOptionsRequestE_e5_v8__0l;
  void block[4] = v2;
  uint64_t v4 = (const re::DynamicString *)(a1 + 40);
  uint64_t v5 = v3;
  re::DynamicString::DynamicString((re::DynamicString *)&v8, v4);
  id v10 = *(id *)(a1 + 72);
  id v11 = *(id *)(a1 + 80);
  dispatch_sync(v5, block);

  uint64_t result = v8;
  if (v8)
  {
    if (v9) {
      return (*(uint64_t (**)(void))(*(void *)v8 + 40))();
    }
  }
  return result;
}

uint64_t ___ZN2re22ResourceSharingManager24enqueueSetOptionsRequestENS0_17SetOptionsRequestE_block_invoke_2(uint64_t a1)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  re::DynamicString::DynamicString((re::DynamicString *)&v38, (const re::DynamicString *)(a1 + 40));
  id v42 = *(id *)(a1 + 72);
  id v43 = *(id *)(a1 + 80);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 40));
  BOOL v3 = (re *)re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)&v38);
  uint64_t v4 = *(void *)(v2 + 80);
  if (!v4)
  {
LABEL_5:
    uint64_t v7 = *re::resourceSharingLogObjects(v3);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v51 = v42;
      _os_log_fault_impl(&dword_233120000, v7, OS_LOG_TYPE_FAULT, "No resource connection exists for server %@", buf, 0xCu);
    }
    goto LABEL_25;
  }
  uint64_t v5 = *(void *)(v2 + 96) + 40;
  uint64_t v6 = 168 * v4;
  while (*(id *)(v5 - 32) != v42)
  {
    v5 += 168;
    v6 -= 168;
    if (!v6) {
      goto LABEL_5;
    }
  }
  uint64_t v8 = *(unsigned int *)(v5 + 16);
  if (v8)
  {
    uint64_t v9 = 0;
    id v10 = (int *)(*(void *)v5 + 8);
    while (1)
    {
      int v11 = *v10;
      v10 += 6;
      if (v11 < 0) {
        break;
      }
      if (v8 == ++v9)
      {
        LODWORD(v9) = *(_DWORD *)(v5 + 16);
        break;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if (v8 == v9)
  {
LABEL_24:
    uint64_t v19 = *re::resourceSharingLogObjects(v3);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      if (v39) {
        uint64_t v32 = v41;
      }
      else {
        uint64_t v32 = v40;
      }
      *(_DWORD *)long long buf = 138412546;
      id v51 = v42;
      __int16 v52 = 2080;
      *(void *)uint64_t v53 = v32;
      _os_log_error_impl(&dword_233120000, v19, OS_LOG_TYPE_ERROR, "Resource connection %@ ignored a set-options request for '%s': no subscription exists", buf, 0x16u);
    }
    goto LABEL_25;
  }
  uint64_t v12 = v9;
  uint64_t v13 = *(void *)v5;
  while (1)
  {
    uint64_t v14 = v13 + 24 * v12;
    uint64_t v16 = *(void *)(v14 + 16);
    uint64_t v15 = (uint64_t *)(v14 + 16);
    if (*(re **)(v16 + 56) == v3) {
      break;
    }
    if (v8 <= (int)v9 + 1) {
      int v17 = v9 + 1;
    }
    else {
      int v17 = v8;
    }
    while (1)
    {
      uint64_t v12 = (v9 + 1);
      if (v17 - 1 == v9) {
        break;
      }
      LODWORD(v9) = v9 + 1;
      int v18 = v12;
      if ((*(_DWORD *)(v13 + 24 * v12 + 8) & 0x80000000) != 0) {
        goto LABEL_23;
      }
    }
    int v18 = v17;
LABEL_23:
    LODWORD(v9) = v18;
    if (v8 == v18) {
      goto LABEL_24;
    }
  }
  int v21 = (re *)(*(void *(**)(uint8_t *__return_ptr))(**(void **)(v2 + 24) + 112))(buf);
  if (!buf[0])
  {
    unint64_t v24 = *re::resourceSharingLogObjects(v21);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      id v25 = v41;
      if ((v39 & 1) == 0) {
        id v25 = v40;
      }
      uint64_t v26 = *v15;
      if (*(unsigned char *)(*v15 + 32)) {
        unint64_t v27 = *(void **)(v26 + 40);
      }
      else {
        unint64_t v27 = (void *)(v26 + 33);
      }
      *(_DWORD *)uint64_t v44 = 138412802;
      id v45 = v42;
      __int16 v46 = 2080;
      int v47 = v25;
      __int16 v48 = 2080;
      id v49 = v27;
      _os_log_error_impl(&dword_233120000, v24, OS_LOG_TYPE_ERROR, "Resource connection %@ has a subscription for '%s', but no AssetHandle '%s' could be found in AssetService.", v44, 0x20u);
    }
    goto LABEL_47;
  }
  if (!*(void *)&v53[2])
  {
    uint64_t v30 = *re::resourceSharingLogObjects(v21);
    goto LABEL_46;
  }
  unsigned int v22 = atomic_load((unsigned int *)(*(void *)&v53[2] + 704));
  if (v22 != 2)
  {
    unsigned int v28 = atomic_load((unsigned int *)(*(void *)&v53[2] + 704));
    unint64_t v29 = (os_log_t *)re::resourceSharingLogObjects(v21);
    uint64_t v30 = *v29;
    if (v28 == 3)
    {
      if (os_log_type_enabled(*v29, OS_LOG_TYPE_DEBUG))
      {
        if (v39) {
          uint64_t v31 = v41;
        }
        else {
          uint64_t v31 = v40;
        }
        *(_DWORD *)uint64_t v44 = 136315138;
        id v45 = v31;
        _os_log_debug_impl(&dword_233120000, v30, OS_LOG_TYPE_DEBUG, "Handled set-options request for '%s': asset loading has already failed", v44, 0xCu);
      }
      goto LABEL_47;
    }
LABEL_46:
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
    {
      if (v39) {
        unsigned int v33 = v41;
      }
      else {
        unsigned int v33 = v40;
      }
      *(_DWORD *)uint64_t v44 = 136315138;
      id v45 = v33;
      _os_log_fault_impl(&dword_233120000, v30, OS_LOG_TYPE_FAULT, "Set-options request for '%s' arrived while asset is loading, which isn't yet implemented", v44, 0xCu);
    }
    goto LABEL_47;
  }
  BOOL v23 = *re::resourceSharingLogObjects(v21);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    if (v39) {
      int v34 = v41;
    }
    else {
      int v34 = v40;
    }
    id v35 = v42;
    id v36 = v43;
    *(_DWORD *)uint64_t v44 = 138412802;
    id v45 = v35;
    __int16 v46 = 2080;
    int v47 = v34;
    __int16 v48 = 2112;
    id v49 = v36;
    uint64_t v37 = v23;
    _os_log_debug_impl(&dword_233120000, v37, OS_LOG_TYPE_DEBUG, "Resource connection %@ set payload options on '%s': %@", v44, 0x20u);
  }
  re::AssetManager::setAssetPayloadRequestOptions(*(void *)(*(void *)&v53[2] + 24), *(uint64_t *)&v53[2], &v43);
LABEL_47:
  if (buf[0]) {
    re::AssetHandle::~AssetHandle((re::AssetHandle *)((char *)&v51 + 4));
  }
LABEL_25:

  uint64_t result = v38;
  if (v38)
  {
    if (v39) {
      return (*(uint64_t (**)(void))(*(void *)v38 + 40))();
    }
  }
  return result;
}

id __copy_helper_block_a8_40c52_ZTSN2re22ResourceSharingManager17SetOptionsRequestE(void *a1, id *a2)
{
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 5), (const re::DynamicString *)(a2 + 5));
  a1[9] = a2[9];
  id result = a2[10];
  a1[10] = result;
  return result;
}

double __destroy_helper_block_a8_40c52_ZTSN2re22ResourceSharingManager17SetOptionsRequestE(id *a1)
{
  uint64_t v2 = (re::DynamicString *)(a1 + 5);

  return re::DynamicString::deinit(v2);
}

void *___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke(void *result)
{
  uint64_t v1 = result[5];
  uint64_t v2 = *(void *)(v1 + 80);
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 96);
    uint64_t v4 = 168 * v2;
    while (*(void *)(v3 + 8) != result[16])
    {
      v3 += 168;
      v4 -= 168;
      if (!v4) {
        return result;
      }
    }
    *(void *)(*(void *)(result[4] + 8) + 24) = v3;
  }
  return result;
}

void *__copy_helper_block_a8_48c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 56), (const re::DynamicString *)(a2 + 56));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 88), (const re::DynamicString *)(a2 + 88));
  uint64_t v4 = *(void **)(a2 + 128);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  *(void *)(a1 + 128) = v4;
  id result = _Block_copy(*(const void **)(a2 + 136));
  *(void *)(a1 + 136) = result;
  return result;
}

double __destroy_helper_block_a8_48c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(id *a1)
{
  re::DynamicString::deinit((re::DynamicString *)(a1 + 11));
  return re::DynamicString::deinit((re::DynamicString *)(a1 + 7));
}

uint64_t __Block_byref_object_copy__87(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__88(uint64_t a1)
{
}

void ___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke_89(uint64_t a1)
{
  uint64_t v2 = *(Connection **)(a1 + 56);
  re::ResourceSharingManager::findOrAddSubscription((re::ResourceSharingManager *)&v13, v2, *(const re::AssetHandle **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), (re::AssetHandle *)(a1 + 64));
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  uint64_t v4 = v13;
  v9[0] = *(unsigned char *)(a1 + 88);
  id v10 = *(id *)(a1 + 96);
  re::ResourceSharingManager::validateResult((uint64_t)v11, (uint64_t)v2, v3, v4, (uint64_t)v9);

  int v5 = v11[0];
  uint64_t v6 = v12;
  if (v11[0]) {
    uint64_t v7 = v12;
  }
  else {
    uint64_t v7 = 0;
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v7);
  if (v5) {
    id v8 = 0;
  }
  else {
    id v8 = v6;
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), v8);
}

id re::ResourceSharingManager::findOrAddSubscription(re::ResourceSharingManager *this, Connection *a2, const re::AssetHandle *a3, re::AssetHandle *a4)
{
  id v8 = re::AssetHandle::assetInfo(a4);
  uint64_t v9 = (re *)re::Hash<re::DynamicString>::operator()((uint64_t)v44, (uint64_t)v8 + 96);
  uint64_t v10 = *((unsigned int *)a3 + 14);
  if (v10)
  {
    uint64_t v11 = 0;
    uint64_t v12 = (int *)(*((void *)a3 + 5) + 8);
    while (1)
    {
      int v13 = *v12;
      v12 += 6;
      if (v13 < 0) {
        break;
      }
      if (v10 == ++v11)
      {
        LODWORD(v1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *((_DWORD *)a3 + 14);
        break;
      }
    }
  }
  else
  {
    LODWORD(v1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  }
  if (v10 != v11)
  {
    uint64_t v14 = v11;
    uint64_t v15 = *((void *)a3 + 5);
    while (1)
    {
      uint64_t v16 = *(void *)(v15 + 24 * v14 + 16);
      if (*(re **)(v16 + 56) == v9) {
        break;
      }
      if (v10 <= (int)v11 + 1) {
        int v17 = v11 + 1;
      }
      else {
        int v17 = *((_DWORD *)a3 + 14);
      }
      while (1)
      {
        uint64_t v14 = (v11 + 1);
        if (v17 - 1 == v11) {
          break;
        }
        LODWORD(v1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v11 + 1;
        int v18 = v14;
        if ((*(_DWORD *)(v15 + 24 * v14 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      int v18 = v17;
LABEL_17:
      LODWORD(v1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v18;
      if (v10 == v18) {
        goto LABEL_18;
      }
    }
    *(void *)this = v16;
    id v43 = (void *)(v16 + 8);
    return v43;
  }
LABEL_18:
  uint64_t v19 = *((void *)a2 + 10);
  if (v19)
  {
    uint64_t v20 = *((void *)a2 + 12);
    uint64_t v21 = v20 + 168 * v19;
    while (1)
    {
      if (*((void *)a3 + 1) != *(void *)(v20 + 8))
      {
        uint64_t v22 = *(unsigned int *)(v20 + 56);
        if (v22)
        {
          uint64_t v23 = 0;
          unint64_t v24 = (int *)(*(void *)(v20 + 40) + 8);
          while (1)
          {
            int v25 = *v24;
            v24 += 6;
            if (v25 < 0) {
              break;
            }
            if (v22 == ++v23)
            {
              LODWORD(v2re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(_DWORD *)(v20 + 56);
              break;
            }
          }
        }
        else
        {
          LODWORD(v2re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
        }
        if (v22 != v23) {
          break;
        }
      }
LABEL_38:
      v20 += 168;
      if (v20 == v21) {
        goto LABEL_39;
      }
    }
    uint64_t v26 = v23;
    uint64_t v27 = *(void *)(v20 + 40);
    while (1)
    {
      uint64_t v28 = v27 + 24 * v26;
      uint64_t v31 = *(void *)(v28 + 16);
      uint64_t v30 = (uint64_t *)(v28 + 16);
      uint64_t v29 = v31;
      if (*(re **)(v31 + 56) == v9) {
        break;
      }
      if (v22 <= (int)v23 + 1) {
        int v32 = v23 + 1;
      }
      else {
        int v32 = *(_DWORD *)(v20 + 56);
      }
      while (1)
      {
        uint64_t v26 = (v23 + 1);
        if (v32 - 1 == v23) {
          break;
        }
        LODWORD(v2re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v23 + 1;
        int v33 = v26;
        if ((*(_DWORD *)(v27 + 24 * v26 + 8) & 0x80000000) != 0) {
          goto LABEL_37;
        }
      }
      int v33 = v32;
LABEL_37:
      LODWORD(v2re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v33;
      if (v22 == v33) {
        goto LABEL_38;
      }
    }
    re::DynamicArray<REResourceSharingClientObject * {__strong}>::add(v29 + 72, (id *)a3 + 1);
    id result = (id)re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::add((uint64_t)a3 + 24, v30);
    uint64_t v42 = *v30;
    *(void *)this = *v30;
    if (v42)
    {
      id v43 = (void *)(v42 + 8);
      return v43;
    }
  }
  else
  {
LABEL_39:
    int v34 = re::globalAllocators(v9);
    uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v34[2] + 32))(v34[2], 160, 8);
    *(_OWORD *)uint64_t v35 = 0u;
    *(_OWORD *)(v35 + 16) = 0u;
    *(_OWORD *)(v35 + 32) = 0u;
    *(_OWORD *)(v35 + 48) = 0u;
    *(_OWORD *)(v35 + 64) = 0u;
    *(_OWORD *)(v35 + 80) = 0u;
    *(_OWORD *)(v35 + 96) = 0u;
    *(_OWORD *)(v35 + 112) = 0u;
    *(_OWORD *)(v35 + 128) = 0u;
    *(_OWORD *)(v35 + 144) = 0u;
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)v35, 0);
    *(void *)uint64_t v35 = &unk_26E6CD718;
    *(_OWORD *)(v35 + 40) = 0u;
    *(_OWORD *)(v35 + 24) = 0u;
    re::DynamicString::setCapacity((void *)(v35 + 24), 0);
    *(_DWORD *)(v35 + 96) = 0;
    *(void *)(v35 + 72) = 0;
    *(void *)(v35 + 80) = 0;
    *(void *)(v35 + 88) = 0;
    *(void *)(v35 + 152) = 0;
    *(_OWORD *)(v35 + 104) = 0u;
    *(_OWORD *)(v35 + 120) = 0u;
    *(_OWORD *)(v35 + 132) = 0u;
    *(void *)this = v35;
    uint64_t v37 = (char *)re::AssetHandle::assetInfo(a4);
    if (*((void *)v37 + 13)) {
      uint64_t v38 = (const char *)*((void *)v37 + 14);
    }
    else {
      uint64_t v38 = v37 + 105;
    }
    size_t v39 = strlen(v38);
    v44[0] = v38;
    v44[1] = v39;
    re::DynamicString::operator=((re::DynamicString *)(v35 + 24), (uint64_t)v44);
    *(void *)(v35 + 56) = re::Hash<re::DynamicString>::operator()((uint64_t)v44, v35 + 24);
    uint64_t v40 = *((void *)re::AssetHandle::assetInfo(a4) + 10);
    if (v40 == -1) {
      uint64_t v40 = 0;
    }
    *(void *)(v35 + 64) = v40;
    re::DynamicArray<REResourceSharingClientObject * {__strong}>::add(v35 + 72, (id *)a3 + 1);
    return (id)re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::add((uint64_t)a3 + 24, (uint64_t *)this);
  }
  return result;
}

void re::ResourceSharingManager::validateResult(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void **)(a5 + 8);
  if (*(unsigned char *)a5 && v7)
  {
    id v11 = v7;
    uint64_t v45 = a3 + 72;
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a3 + 72, a4[8]);
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a3 + 120, a4[8]);
    uint64_t v12 = *(unsigned int *)(a3 + 152);
    if (v12)
    {
      uint64_t v13 = 0;
      uint64_t v14 = (int *)(*(void *)(a3 + 136) + 8);
      while (1)
      {
        int v15 = *v14;
        v14 += 8;
        if (v15 < 0) {
          break;
        }
        if (v12 == ++v13)
        {
          LODWORD(v1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(_DWORD *)(a3 + 152);
          break;
        }
      }
    }
    else
    {
      LODWORD(v1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
    }
    if (v12 == v13)
    {
      uint64_t v16 = 0;
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v17 = v13;
      uint64_t v18 = *(void *)(a3 + 136);
      do
      {
        v16 += *(void *)(v18 + 32 * v17 + 24);
        if (v12 <= (int)v13 + 1) {
          int v19 = v13 + 1;
        }
        else {
          int v19 = *(_DWORD *)(a3 + 152);
        }
        int v20 = v13;
        while (1)
        {
          uint64_t v17 = (v20 + 1);
          if (v19 - 1 == v20) {
            break;
          }
          ++v20;
          LODWORD(v1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v17;
          if ((*(_DWORD *)(v18 + 32 * v17 + 8) & 0x80000000) != 0) {
            goto LABEL_21;
          }
        }
        LODWORD(v1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v19;
LABEL_21:
        ;
      }
      while (v12 != v13);
    }
    uint64_t v21 = *(unsigned int *)(a3 + 104);
    if (v21)
    {
      uint64_t v22 = 0;
      uint64_t v23 = (int *)(*(void *)(a3 + 88) + 8);
      while (1)
      {
        int v24 = *v23;
        v23 += 8;
        if (v24 < 0) {
          break;
        }
        if (v21 == ++v22)
        {
          LODWORD(v22) = *(_DWORD *)(a3 + 104);
          break;
        }
      }
    }
    else
    {
      LODWORD(v22) = 0;
    }
    if (v21 == v22)
    {
      uint64_t v25 = 0;
    }
    else
    {
      uint64_t v25 = 0;
      uint64_t v26 = v22;
      uint64_t v27 = *(void *)(a3 + 88);
      do
      {
        v25 += *(void *)(v27 + 32 * v26 + 24);
        if (v21 <= (int)v22 + 1) {
          int v28 = v22 + 1;
        }
        else {
          int v28 = *(_DWORD *)(a3 + 104);
        }
        int v29 = v22;
        while (1)
        {
          uint64_t v26 = (v29 + 1);
          if (v28 - 1 == v29) {
            break;
          }
          ++v29;
          LODWORD(v22) = v26;
          if ((*(_DWORD *)(v27 + 32 * v26 + 8) & 0x80000000) != 0) {
            goto LABEL_39;
          }
        }
        LODWORD(v22) = v28;
LABEL_39:
        ;
      }
      while (v21 != v22);
    }
    id v30 = v11;
    uint64_t v31 = (re *)malloc_size(v11);
    int v47 = v31;
    int v32 = *re::resourceSharingLogObjects(v31);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      if (a4[4]) {
        uint64_t v38 = (char *)a4[5];
      }
      else {
        uint64_t v38 = (char *)a4 + 33;
      }
      *(_DWORD *)long long buf = 136315394;
      uint64_t v49 = (uint64_t)v38;
      __int16 v50 = 2048;
      id v51 = v31;
      _os_log_debug_impl(&dword_233120000, v32, OS_LOG_TYPE_DEBUG, "Asset '%s' estimated to be size:%zu", buf, 0x16u);
    }
    if ((unint64_t)v31 + v25 + v16 <= (*(uint64_t (**)(void))(**(void **)(a2 + 24) + 400))(*(void *)(a2 + 24)))
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace<unsigned long &>(v45, a4 + 8, &v47);
      id v37 = *(id *)(a5 + 8);
      *(unsigned char *)a1 = 1;
      *(void *)(a1 + 8) = v37;
      uint64_t v35 = v30;
    }
    else
    {
      re::makeResourceSharingError((__CFString *)0x258, 0, &v46);
      int v34 = *re::resourceSharingLogObjects(v33);
      uint64_t v35 = v30;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        uint64_t v39 = *(void *)(a2 + 24);
        uint64_t v40 = *(uint64_t (**)(uint64_t))(*(void *)v39 + 400);
        uint64_t v41 = v34;
        uint64_t v42 = v40(v39);
        if (a4[4]) {
          id v43 = (re *)a4[5];
        }
        else {
          id v43 = (re *)((char *)a4 + 33);
        }
        id v44 = v46;
        *(_DWORD *)long long buf = 134218498;
        uint64_t v49 = v42;
        __int16 v50 = 2080;
        id v51 = v43;
        __int16 v52 = 2112;
        id v53 = v44;
        _os_log_error_impl(&dword_233120000, v41, OS_LOG_TYPE_ERROR, "Specified upperBound limit of %zu was hit. Failed send payload for '%s': %@", buf, 0x20u);
      }
      id v36 = v46;
      *(unsigned char *)a1 = 0;
      *(void *)(a1 + 8) = v36;
    }
  }
  else
  {
    *(unsigned char *)a1 = *(unsigned char *)a5;
    *(void *)(a5 + 8) = 0;
    *(void *)(a1 + 8) = v7;
  }
}

id __copy_helper_block_a8_64c23_ZTSKN2re11AssetHandleE88c63_ZTSN2re6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEE(uint64_t a1, uint64_t a2)
{
  re::AssetHandle::AssetHandle((re::AssetHandle *)(a1 + 64), (const re::AssetHandle *)(a2 + 64));
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a2 + 88);
  id result = *(id *)(a2 + 96);
  *(void *)(a1 + 96) = result;
  return result;
}

void __destroy_helper_block_a8_64c23_ZTSKN2re11AssetHandleE88c63_ZTSN2re6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEE(uint64_t a1)
{
  uint64_t v1 = (re::AssetHandle *)(a1 + 64);

  re::AssetHandle::~AssetHandle(v1);
}

void re::anonymous namespace'::internalSendFetchResponse(void *a1, void *a2, void *a3, re::AssetHandle *a4)
{
  id v7 = a3;
  uint64_t v14 = a1;
  id v8 = re::AssetHandle::assetInfo(a4);
  uint64_t v10 = *((void *)a4 + 1);
  if (v10 && (id v11 = *(const char ***)(v10 + 264)) != 0) {
    uint64_t v12 = *v11;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v8[10] == -1) {
    LODWORD(v1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  }
  else {
    uint64_t v13 = v8[10];
  }
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x80E, v13, v12, v9);
  v14[2](v14, *a2, v7);
}

void re::anonymous namespace'::sendFetchResponse(void *a1, uint64_t a2, re::AssetHandle *a3)
{
  id v5 = a1;
  uint64_t v6 = re::AssetHandle::assetInfo(a3);
  if (v6[10] == -1) {
    LODWORD(v8) = 0;
  }
  else {
    uint64_t v8 = v6[10];
  }
  uint64_t v9 = *((void *)a3 + 1);
  if (v9 && (uint64_t v10 = *(const char ***)(v9 + 264)) != 0) {
    id v11 = *v10;
  }
  else {
    id v11 = 0;
  }
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x80E, v8, v11, v7);
  if (*(unsigned char *)a2) {
    uint64_t v12 = *(void **)(a2 + 8);
  }
  else {
    uint64_t v12 = 0;
  }
  id v13 = v12;
  if (*(unsigned char *)a2) {
    id v14 = 0;
  }
  else {
    id v14 = *(id *)(a2 + 8);
  }
  id v15 = v14;

  id v16 = v13;
  id v17 = v16;
}

void re::ResourceSharingManager::makeFetchRequestError(re::ResourceSharingManager *this)
{
  re::makeResourceSharingError((__CFString *)0x190, 0, &v3);
  uint64_t v2 = v3;
  uint64_t v3 = 0;
  *(unsigned char *)this = 0;
  *((void *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v2;
}

void ___ZN2re22ResourceSharingManager19processFetchRequestENS0_12FetchRequestE_block_invoke_90(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(Connection **)(a1 + 40);
  uint64_t v3 = (const re::AssetHandle *)(a1 + 48);
  re::ResourceSharingManager::findOrAddSubscription((re::ResourceSharingManager *)&v23, v2, *(const re::AssetHandle **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), (re::AssetHandle *)(a1 + 48));
  uint64_t v4 = v23;
  if (!*(void *)(v23 + 112))
  {
    (*(void (**)(void *__return_ptr))(**((void **)v2 + 3) + 208))(v24);
    uint64_t v5 = *(void *)(v4 + 112);
    uint64_t v6 = (re::AssetLoadRequest::Data **)v24[0];
    *(void *)(v4 + 112) = v24[0];
    v24[0] = v5;
    if (v5)
    {

      uint64_t v6 = *(re::AssetLoadRequest::Data ***)(v4 + 112);
    }
    id v7 = (id)(v4 + 8);
    v24[2] = v4;
    uint64_t v25 = 0;
    v24[0] = &unk_26E6CD628;
    v24[1] = v2;
    id v8 = (id)(v4 + 8);
    uint64_t v25 = v24;
    re::AssetLoadRequest::setCompletionHandler((uint64_t)v6, (uint64_t)v24, 0);
    std::__function::__value_func<void ()(BOOL)>::~__value_func[abi:nn180100](v24);

    re::AssetLoadRequest::addAsset(v6, v3);
  }
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  uint64_t v10 = (re *)*(id *)(a1 + 160);
  id v11 = re::globalAllocators(v10);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11[2] + 32))(v11[2], 40, 8);
  *(_OWORD *)uint64_t v12 = 0u;
  *(_OWORD *)(v12 + 16) = 0u;
  *(void *)(v12 + 32) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v12, 0);
  *(void *)(v12 + 24) = 0;
  *(void *)uint64_t v12 = &unk_26E6CD760;
  *(void *)(v12 + 32) = v9;
  id v13 = _Block_copy(v10);

  id v14 = *(void **)(v12 + 24);
  *(void *)(v12 + 24) = v13;

  unint64_t v16 = *(void *)(v4 + 128);
  unint64_t v17 = *(void *)(v4 + 136);
  if (v17 >= v16)
  {
    unint64_t v18 = v17 + 1;
    if (v16 < v17 + 1)
    {
      if (*(void *)(v4 + 120))
      {
        uint64_t v19 = 2 * v16;
        BOOL v20 = v16 == 0;
        unint64_t v21 = 8;
        if (!v20) {
          unint64_t v21 = v19;
        }
        if (v21 <= v18) {
          unint64_t v22 = v18;
        }
        else {
          unint64_t v22 = v21;
        }
        re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((void *)(v4 + 120), v22);
      }
      else
      {
        re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((void *)(v4 + 120), v18);
        ++*(_DWORD *)(v4 + 144);
      }
    }
    unint64_t v17 = *(void *)(v4 + 136);
  }
  *(void *)(*(void *)(v4 + 152) + 8 * v17) = v12;
  *(void *)(v4 + 136) = v17 + 1;
  ++*(_DWORD *)(v4 + 144);
}

void *__copy_helper_block_a8_48c23_ZTSKN2re11AssetHandleE72c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(uint64_t a1, uint64_t a2)
{
  re::AssetHandle::AssetHandle((re::AssetHandle *)(a1 + 48), (const re::AssetHandle *)(a2 + 48));
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 80), (const re::DynamicString *)(a2 + 80));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 112), (const re::DynamicString *)(a2 + 112));
  uint64_t v4 = *(void **)(a2 + 152);
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(void *)(a1 + 152) = v4;
  id result = _Block_copy(*(const void **)(a2 + 160));
  *(void *)(a1 + 160) = result;
  return result;
}

void __destroy_helper_block_a8_48c23_ZTSKN2re11AssetHandleE72c48_ZTSKN2re22ResourceSharingManager12FetchRequestE(id *a1)
{
  uint64_t v2 = (re::AssetHandle *)(a1 + 6);

  re::DynamicString::deinit((re::DynamicString *)(a1 + 14));
  re::DynamicString::deinit((re::DynamicString *)(a1 + 10));
  re::AssetHandle::~AssetHandle(v2);
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t result, unint64_t a2)
{
  if (*(void *)result)
  {
    unint64_t v2 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    unint64_t v3 = (v2 ^ (v2 >> 31)) % *(unsigned int *)(result + 24);
    uint64_t v4 = *(void *)(result + 8);
    uint64_t v5 = *(unsigned int *)(v4 + 4 * v3);
    if (v5 != 0x7FFFFFFF)
    {
      uint64_t v6 = *(void *)(result + 16);
      uint64_t v7 = v6 + 32 * v5;
      if (*(void *)(v7 + 16) == a2)
      {
        *(_DWORD *)(v4 + 4 * vre::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(_DWORD *)(v7 + 8) & 0x7FFFFFFF;
LABEL_8:
        uint64_t v10 = *(void *)(result + 16);
        uint64_t v11 = v10 + 32 * v5;
        int v14 = *(_DWORD *)(v11 + 8);
        id v13 = (int *)(v11 + 8);
        int v12 = v14;
        if (v14 < 0)
        {
          *id v13 = v12 & 0x7FFFFFFF;
          uint64_t v10 = *(void *)(result + 16);
          int v12 = *(_DWORD *)(v10 + 32 * v5 + 8);
        }
        int v15 = *(_DWORD *)(result + 40);
        *(_DWORD *)(v10 + 32 * v5 + 8) = *(_DWORD *)(result + 36) | v12 & 0x80000000;
        --*(_DWORD *)(result + 28);
        *(_DWORD *)(result + 36) = v5;
        *(_DWORD *)(result + 40) = v15 + 1;
      }
      else
      {
        while (1)
        {
          unsigned int v8 = v5;
          uint64_t v5 = *(_DWORD *)(v6 + 32 * v5 + 8) & 0x7FFFFFFF;
          if (v5 == 0x7FFFFFFF) {
            break;
          }
          uint64_t v9 = v6 + 32 * v5;
          if (*(void *)(v9 + 16) == a2)
          {
            *(_DWORD *)(v6 + 32 * v8 + 8) = *(_DWORD *)(v6 + 32 * v8 + 8) & 0x80000000 | *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace<unsigned long &>(uint64_t result, uint64_t *a2, void *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)result)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(result + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(result + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    id result = re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(result, v9, v8, a2, a3);
    goto LABEL_9;
  }
  uint64_t v11 = *(void *)(result + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  *(void *)(v11 + 32 * v10 + 24) = *a3;
LABEL_9:
  ++*(_DWORD *)(v5 + 40);
  return result;
}

id re::DynamicArray<REResourceSharingClientObject * {__strong}>::add(uint64_t a1, id *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v6)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t v11 = *(void *)(a1 + 32);
  id result = *a2;
  *(void *)(v11 + 8 * v5) = result;
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::add(uint64_t result, uint64_t *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(result + 24);
  if (v7)
  {
    unint64_t v8 = v6 % v7;
    uint64_t v9 = *(unsigned int *)(*(void *)(result + 8) + 4 * (v6 % v7));
    if (v9 != 0x7FFFFFFF)
    {
      uint64_t v10 = *(void *)(result + 16);
      if (*(void *)(v10 + 24 * v9 + 16) == v4) {
        return result;
      }
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
        if (v9 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v10 + 24 * v9 + 16) == v4) {
          return result;
        }
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  id result = re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::addAsCopy(result, v8, v6, a2);
  ++*(_DWORD *)(v3 + 40);
  return result;
}

void re::make::shared::object<re::internal::ResourceRequestQueue>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = re::globalAllocators(a1);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 80, 8);
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v4, 0);
  *(void *)uint64_t v4 = &unk_26E6CD5E0;
  *(_DWORD *)(v4 + 24) = 0;
  *(void *)(v4 + 64) = 0;
  *(void *)(v4 + 40) = 0;
  *(void *)(v4 + 48) = 0;
  *(void *)(v4 + 32) = 0;
  *(_DWORD *)(v4 + 56) = 0;
  *(unsigned char *)(v4 + 72) = 0;
  *a2 = v4;
}

void re::internal::ResourceRequestQueue::~ResourceRequestQueue(re::internal::ResourceRequestQueue *this)
{
  *(void *)this = &unk_26E6CD5E0;
  re::DynamicArray<re::ObjCObject>::deinit((uint64_t)this + 32);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6CD5E0;
  re::DynamicArray<re::ObjCObject>::deinit((uint64_t)this + 32);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

void *re::DynamicArray<re::ResourceSharingManager::Connection>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      id result = (void *)*result;
      if (!*v5)
      {
        id result = (void *)re::DynamicArray<re::ResourceSharingManager::Connection>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA8uLL))
        {
          uint64_t v2 = 168 * a2;
          id result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 168 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 168, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        id result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      unint64_t v8 = (long long *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = (long long *)((char *)v8 + 168 * v9);
        uint64_t v11 = v7;
        do
        {
          long long v12 = *v8;
          *(void *)unint64_t v8 = 0;
          *((void *)v8 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
          *(_OWORD *)uint64_t v11 = v12;
          _OWORD v11[2] = *((void *)v8 + 2);
          *(_OWORD *)(v11 + 5) = 0u;
          *((_DWORD *)v11 + 14) = 0;
          *(_OWORD *)(v11 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0u;
          *(void *)((char *)v11 + 60) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v11 + 3, (uint64_t *)v8 + 3);
          *((_DWORD *)v11 + 26) = 0;
          *(_OWORD *)(v11 + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
          *(_OWORD *)(v11 + 9) = 0u;
          *(void *)((char *)v11 + 108) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v11 + 9, (uint64_t *)v8 + 9);
          *(_OWORD *)(v11 + 15) = 0u;
          id v13 = v11 + 15;
          *((_DWORD *)v13 + 8) = 0;
          *((_OWORD *)v13 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
          *(void *)((char *)v13 + 36) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v13, (uint64_t *)v8 + 15);
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v8 + 15);
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v8 + 9);
          re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)v8 + 3);

          int v14 = *(void **)v8;
          unint64_t v8 = (long long *)((char *)v8 + 168);

          uint64_t v11 = v13 + 6;
        }
        while (v8 != v10);
        unint64_t v8 = (long long *)v5[4];
      }
      id result = (void *)(*(uint64_t (**)(void, long long *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    if (!*(void *)a1 || (uint64_t v4 = *(void *)a2, *(void *)a1 == *(void *)a2))
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, (uint64_t *)a2);
    }
    else
    {
      re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1);
      if (v4)
      {
        unsigned int v5 = *(_DWORD *)(a2 + 28);
        if (*(_DWORD *)(a1 + 24) < v5) {
          re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v5);
        }
        unint64_t v6 = *(unsigned int *)(a2 + 32);
        if (v6)
        {
          uint64_t v7 = 0;
          for (unint64_t i = 0; i < v6; ++i)
          {
            uint64_t v9 = (unint64_t *)(*(void *)(a2 + 16) + v7);
            if ((v9[1] & 0x80000000) != 0)
            {
              unint64_t v10 = *v9;
              unint64_t v11 = *(unsigned int *)(a1 + 24);
              unint64_t v12 = *v9 % v11;
              uint64_t v13 = *(unsigned int *)(a1 + 36);
              if (v13 == 0x7FFFFFFF)
              {
                uint64_t v13 = *(unsigned int *)(a1 + 32);
                int v14 = v13;
                if (v13 == v11)
                {
                  re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
                  unint64_t v12 = v10 % *(unsigned int *)(a1 + 24);
                  int v14 = *(_DWORD *)(a1 + 32);
                }
                *(_DWORD *)(a1 + 32) = v14 + 1;
                uint64_t v15 = *(void *)(a1 + 16);
                int v16 = *(_DWORD *)(v15 + 32 * v13 + 8);
              }
              else
              {
                uint64_t v15 = *(void *)(a1 + 16);
                int v16 = *(_DWORD *)(v15 + 32 * v13 + 8);
                *(_DWORD *)(a1 + 36) = v16 & 0x7FFFFFFF;
              }
              *(_DWORD *)(v15 + 32 * v13 + 8) = v16 | 0x80000000;
              uint64_t v17 = *(void *)(a1 + 8);
              *(_DWORD *)(*(void *)(a1 + 16) + 32 * v13 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v13 + 8) & 0x80000000 | *(_DWORD *)(v17 + 4 * v12);
              *(void *)(*(void *)(a1 + 16) + 32 * v1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v10;
              unint64_t v18 = v9[3];
              *(void *)(*(void *)(a1 + 16) + 32 * v13 + 16) = v9[2];
              *(void *)(*(void *)(a1 + 16) + 32 * v13 + 24) = v18;
              *(_DWORD *)(v17 + 4 * v12) = v13;
              ++*(_DWORD *)(a1 + 28);
              unint64_t v6 = *(unsigned int *)(a2 + 32);
            }
            v7 += 32;
          }
        }
        ++*(_DWORD *)(a1 + 40);
      }
    }
  }
  return a1;
}

void re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(void *)&v22[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)v22, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v22;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)unint64_t v22 = v5;
      *(void *)&unsigned char v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&unsigned char v22[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        int v11 = DWORD1(v9);
        uint64_t v12 = v7;
        uint64_t v13 = (void *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            unint64_t v14 = *(v13 - 2);
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = v14 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::setCapacity(a1, (2 * v11));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v12 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 24 * v17) = v14;
            *(void *)(*(void *)(a1 + 16) + 24 * v17 + 16) = *v13;
            *uint64_t v13 = 0;
            *(_DWORD *)(v12 + 4 * v16) = v17;
            int v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2) {
      signed int v21 = a2;
    }
    else {
      signed int v21 = 3;
    }
  }
}

uint64_t re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v7 = *(unsigned int *)(a1 + 36);
  if (v7 == 0x7FFFFFFF)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 32);
    int v8 = v7;
    if (v7 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::SharedPtr<re::ResourceSharingManager::Subscription>,re::SharedPtr<re::ResourceSharingManager::Subscription>,re::internal::ValueAsKey<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::Hash<re::SharedPtr<re::ResourceSharingManager::Subscription>>,re::EqualTo<re::SharedPtr<re::ResourceSharingManager::Subscription>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    uint64_t v9 = *(void *)(a1 + 16);
    int v10 = *(_DWORD *)(v9 + 24 * v7 + 8);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 16);
    int v10 = *(_DWORD *)(v9 + 24 * v7 + 8);
    *(_DWORD *)(a1 + 36) = v10 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v9 + 24 * v7 + 8) = v10 | 0x80000000;
  uint64_t v11 = a2;
  uint64_t v12 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v7 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v7 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v7) = a3;
  uint64_t v13 = *a4;
  *(void *)(*(void *)(a1 + 16) + 24 * v7 + 16) = *a4;
  if (v13)
  {
    id v14 = (id)(v13 + 8);
    uint64_t v12 = *(void *)(a1 + 8);
  }
  *(_DWORD *)(v12 + 4 * v1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v7;
  ++*(_DWORD *)(a1 + 28);
  return v7;
}

void re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&unsigned __int8 v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (void *)(*(void *)&v13[16] + v10 + 16), (void *)(*(void *)&v13[16] + v10 + 24));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  uint64_t v13 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void *re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    long long v5 = result;
    if (result[2] <= a2)
    {
      id result = (void *)*result;
      if (!*v5)
      {
        id result = (void *)re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 8 * a2;
          id result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            unsigned int v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        id result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unsigned int v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      long long v8 = (id *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 8 * v9;
        uint64_t v11 = v7;
        do
        {
          *v11++ = *v8;
          id v12 = *v8++;

          v10 -= 8;
        }
        while (v10);
        long long v8 = (id *)v5[4];
      }
      id result = (void *)(*(uint64_t (**)(void, id *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::~__func(void *a1)
{
  *a1 = &unk_26E6CD628;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  return a1;
}

void std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::~__func(void *a1)
{
  *a1 = &unk_26E6CD628;
  uint64_t v2 = a1[2];
  if (v2)
  {

    a1[2] = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

void *std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *uint64_t v2 = &unk_26E6CD628;
  v2[1] = v4;
  v2[2] = v3;
  if (v3) {
    id v5 = (id)(v3 + 8);
  }
  return v2;
}

void *std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::__clone(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = &unk_26E6CD628;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    return (id)(v2 + 8);
  }
  return result;
}

void std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {

    *(void *)(a1 + 16) = 0;
  }
}

void std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = __p[2];
  if (v2) {

  }
  operator delete(__p);
}

uint64_t std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::operator()(_anonymous_namespace_ *a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v4 = *((void *)a1 + 1);
  v59[0] = 0;
  v59[1] = v59;
  void v59[2] = 0x5012000000;
  v59[3] = __Block_byref_object_copy__157;
  v59[4] = __Block_byref_object_dispose__158;
  v59[5] = "";
  long long v60 = 0u;
  long long v61 = 0u;
  re::DynamicString::setCapacity(&v60, 0);
  uint64_t v50 = 0;
  id v51 = &v50;
  uint64_t v52 = 0x5812000000;
  id v53 = __Block_byref_object_copy__160;
  uint64_t v54 = __Block_byref_object_dispose__161;
  uint64_t v55 = "";
  uint64_t v58 = 0;
  memset(v56, 0, sizeof(v56));
  int v57 = 0;
  id v5 = *(id *)(v4 + 40);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3321888768;
  block[2] = ___ZZN2re22ResourceSharingManager22createAssetLoadRequestERKNS_9SharedPtrINS0_12SubscriptionEEERKNS_11AssetHandleEENK3__0clEb_block_invoke;
  block[3] = &unk_26E6CD690;
  uint64_t v25 = a1;
  uint64_t v6 = *((void *)a1 + 2);
  uint64_t v49 = v6;
  if (v6) {
    id v7 = (id)(v6 + 8);
  }
  void block[4] = v59;
  void block[5] = &v50;
  dispatch_sync(v5, block);

  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v4 + 24) + 112))(&v46);
  if (v3 && (_BYTE)v46) {
    re::ResourceSharingManager::makeFetchRequestResult((re::ResourceSharingManager *)v44, (const re::AssetHandle *)v4, (const re::AssetHandle *)v47);
  }
  else {
    re::ResourceSharingManager::makeFetchRequestError((re::ResourceSharingManager *)v44);
  }
  char v8 = v44[0];
  uint64_t v9 = (uint64_t *)v51[10];
  uint64_t v10 = v51[8];
  if (v44[0])
  {
    if (v10)
    {
      id v11 = v45;
      uint64_t v12 = 8 * v10;
      do
      {
        uint64_t v13 = *v9;
        if (*v9) {
          id v14 = (id)(v13 + 8);
        }
        uint64_t v38 = 0;
        uint64_t v39 = &v38;
        uint64_t v40 = 0x3032000000;
        uint64_t v41 = __Block_byref_object_copy__87;
        uint64_t v42 = __Block_byref_object_dispose__88;
        id v43 = 0;
        uint64_t v32 = 0;
        int v33 = &v32;
        uint64_t v34 = 0x3032000000;
        uint64_t v35 = __Block_byref_object_copy__87;
        id v36 = __Block_byref_object_dispose__88;
        id v37 = 0;
        unint64_t v15 = *(id *)(v4 + 40);
        v27[0] = MEMORY[0x263EF8330];
        v27[1] = 3321888768;
        _OWORD v27[2] = ___ZZN2re22ResourceSharingManager22createAssetLoadRequestERKNS_9SharedPtrINS0_12SubscriptionEEERKNS_11AssetHandleEENK3__0clEb_block_invoke_163;
        uint64_t v27[3] = &unk_26E6CD6C8;
        v27[6] = v4;
        uint64_t v28 = v13;
        if (v13) {
          id v16 = (id)(v13 + 8);
        }
        uint64_t v17 = *((void *)v25 + 2);
        uint64_t v29 = v17;
        if (v17) {
          id v18 = (id)(v17 + 8);
        }
        char v30 = v8;
        id v31 = v11;
        v27[4] = &v38;
        v27[5] = &v32;
        dispatch_sync(v15, v27);

        uint64_t v19 = *(void **)(v13 + 24);
        id v20 = (id)v39[5];
        id v26 = v20;

        if (v29)
        {

          uint64_t v29 = 0;
        }
        if (v28)
        {

          uint64_t v28 = 0;
        }
        _Block_object_dispose(&v32, 8);

        _Block_object_dispose(&v38, 8);
        ++v9;
        v12 -= 8;
      }
      while (v12);
    }
  }
  else if (v10)
  {
    uint64_t v21 = 8 * v10;
    do
    {
      uint64_t v22 = *v9;
      if (*v9) {
        id v23 = (id)(v22 + 8);
      }

      ++v9;
      v21 -= 8;
    }
    while (v21);
  }

  if ((_BYTE)v46) {
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v47);
  }
  if (v49)
  {

    uint64_t v49 = 0;
  }
  _Block_object_dispose(&v50, 8);
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)v56);
  _Block_object_dispose(v59, 8);
  uint64_t result = v60;
  if ((void)v60)
  {
    if (BYTE8(v60)) {
      return (*(uint64_t (**)(void, void))(*(void *)v60 + 40))(v60, v61);
    }
  }
  return result;
}

uint64_t std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0,std::allocator<re::ResourceSharingManager::createAssetLoadRequest(re::SharedPtr<re::ResourceSharingManager::Subscription> const&,re::AssetHandle const&)::$_0>,void ()(BOOL)>::target_type()
{
}

double __Block_byref_object_copy__157(uint64_t a1, void *a2)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 72) = a2[9];
  uint64_t v3 = a2[7];
  *(void *)(a1 + 48) = a2[6];
  a2[6] = 0;
  uint64_t v4 = a2[8];
  a2[9] = 0;
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 64);
  *(void *)(a1 + 56) = v3;
  *(void *)(a1 + 64) = v4;
  a2[7] = v6;
  a2[8] = v5;
  return result;
}

double __Block_byref_object_dispose__158(uint64_t a1)
{
  return re::DynamicString::deinit((re::DynamicString *)(a1 + 48));
}

uint64_t __Block_byref_object_copy__160(uint64_t result, uint64_t a2)
{
  *(void *)(result + 80) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  *(void *)(result + 48) = 0;
  *(_DWORD *)(result + 72) = 0;
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v3 = *(void *)(result + 64);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v3;
  uint64_t v4 = *(void *)(result + 80);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v4;
  ++*(_DWORD *)(a2 + 72);
  ++*(_DWORD *)(result + 72);
  return result;
}

uint64_t __Block_byref_object_dispose__161(uint64_t a1)
{
  return re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit(a1 + 48);
}

void ___ZZN2re22ResourceSharingManager22createAssetLoadRequestERKNS_9SharedPtrINS0_12SubscriptionEEERKNS_11AssetHandleEENK3__0clEb_block_invoke(void *a1)
{
  re::DynamicString::operator=((re::DynamicString *)(*(void *)(a1[4] + 8) + 48), (re::DynamicString *)(a1[6] + 24));
  uint64_t v2 = a1[6];
  uint64_t v3 = (uint64_t *)(v2 + 120);
  uint64_t v4 = *(void *)(a1[5] + 8);
  if (v4 + 48 != v2 + 120)
  {
    uint64_t v5 = *v3;
    if (*(void *)(v4 + 48))
    {
      uint64_t v6 = v4 + 48;
      if (v5)
      {
        re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::copy(v6, v2 + 120);
        ++*(_DWORD *)(v4 + 72);
      }
      else
      {
        re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::clear(v6);
      }
    }
    else if (v5)
    {
      unint64_t v7 = *(void *)(v2 + 136);
      *(void *)(v4 + 48) = v5;
      re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((void *)(v4 + 48), v7);
      ++*(_DWORD *)(v4 + 72);
      re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::copy(v4 + 48, (uint64_t)v3);
    }
  }
  uint64_t v8 = a1[6];
  uint64_t v9 = *(void *)(v8 + 112);
  if (v9)
  {

    *(void *)(v8 + 112) = 0;
    uint64_t v8 = a1[6];
  }
  re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::clear(v8 + 120);
}

void re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = 8 * v2;
    do
    {
      if (*(void *)v3)
      {

        *(void *)uint64_t v3 = 0;
      }
      v3 += 8;
      v4 -= 8;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void *__copy_helper_block_a8_48c65_ZTSRKN2re9SharedPtrINS_22ResourceSharingManager12SubscriptionEEE(void *result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  result[6] = v2;
  if (v2) {
    return (id)(v2 + 8);
  }
  return result;
}

void ___ZZN2re22ResourceSharingManager22createAssetLoadRequestERKNS_9SharedPtrINS0_12SubscriptionEEERKNS_11AssetHandleEENK3__0clEb_block_invoke_163(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 32);
  uint64_t v4 = *(void **)(a1 + 64);
  v8[0] = *(unsigned char *)(a1 + 72);
  id v9 = *(id *)(a1 + 80);
  re::ResourceSharingManager::validateResult((uint64_t)v10, v2, v3, v4, (uint64_t)v8);

  if (*(unsigned char *)(a1 + 72)) {
    uint64_t v5 = *(void **)(a1 + 80);
  }
  else {
    uint64_t v5 = 0;
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v5);
  if (*(unsigned char *)(a1 + 72)) {
    id v6 = 0;
  }
  else {
    id v6 = *(id *)(a1 + 80);
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v6);

  id v7 = v11;
}

id __copy_helper_block_a8_56c61_ZTSN2re9SharedPtrINS_22ResourceSharingManager10CompletionEEE64c65_ZTSRKN2re9SharedPtrINS_22ResourceSharingManager12SubscriptionEEE72c63_ZTSN2re6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 56) = v4;
  if (v4) {
    id v5 = (id)(v4 + 8);
  }
  uint64_t v6 = *(void *)(a2 + 64);
  *(void *)(a1 + 64) = v6;
  if (v6) {
    id v7 = (id)(v6 + 8);
  }
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  id result = *(id *)(a2 + 80);
  *(void *)(a1 + 80) = result;
  return result;
}

void __destroy_helper_block_a8_56c61_ZTSN2re9SharedPtrINS_22ResourceSharingManager10CompletionEEE64c65_ZTSRKN2re9SharedPtrINS_22ResourceSharingManager12SubscriptionEEE72c63_ZTSN2re6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEE(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {

    *(void *)(a1 + 56) = 0;
  }
}

void re::DynamicArray<re::SharedPtr<re::ResourceSharingManager::Completion>>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= *(void *)(a1 + 16))
  {
    re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((void *)a1, *(void *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 8 * *(void *)(a1 + 16)), *(uint64_t **)(a1 + 32));
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v4)
    {
      id v9 = (uint64_t *)(*(void *)(a2 + 32) + 8 * v8);
      uint64_t v10 = (uint64_t *)(*(void *)(a1 + 32) + 8 * v8);
      uint64_t v11 = 8 * v4 - 8 * v8;
      do
      {
        uint64_t v12 = *v9;
        uint64_t *v10 = *v9;
        if (v12) {
          id v13 = (id)(v12 + 8);
        }
        ++v9;
        ++v10;
        v11 -= 8;
      }
      while (v11);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,re::SharedPtr<re::AssetDescriptorBase const> *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(void *)(a2 + 32) + 8 * v4), *(uint64_t **)(a1 + 32));
    uint64_t v5 = *(void *)(a1 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 32) + 8 * v4;
      uint64_t v7 = 8 * v5 - 8 * v4;
      do
      {
        if (*(void *)v6)
        {

          *(void *)uint64_t v6 = 0;
        }
        v6 += 8;
        v7 -= 8;
      }
      while (v7);
    }
  }
  *(void *)(a1 + 16) = v4;
}

void re::ResourceSharingManager::Subscription::~Subscription(re::ResourceSharingManager::Subscription *this)
{
  re::ResourceSharingManager::Subscription::~Subscription(this);
  JUMPOUT(0x237DBCBD0);
}

{
  uint64_t v2;
  uint64_t v3;
  void **v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(void *)this = &unk_26E6CD718;
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)this + 120);
  uint64_t v2 = *((void *)this + 14);
  if (v2)
  {

    *((void *)this + 14) = 0;
  }
  uint64_t v3 = *((void *)this + 9);
  if (v3)
  {
    unint64_t v4 = (void **)*((void *)this + 13);
    if (v4)
    {
      uint64_t v5 = *((void *)this + 11);
      if (v5)
      {
        uint64_t v6 = 8 * v5;
        do
        {
          uint64_t v7 = *v4++;

          v6 -= 8;
        }
        while (v6);
        uint64_t v3 = *((void *)this + 9);
        unint64_t v4 = (void **)*((void *)this + 13);
      }
      (*(void (**)(uint64_t, void **))(*(void *)v3 + 40))(v3, v4);
    }
    *((void *)this + 1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
    *((void *)this + 10) = 0;
    *((void *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    *((void *)this + 9) = 0;
    ++*((_DWORD *)this + 24);
  }
  re::DynamicString::deinit((re::ResourceSharingManager::Subscription *)((char *)this + 24));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

void re::ResourceSharingManager::Completion::~Completion(id *this)
{
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
}

{
  uint64_t vars8;

  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
  JUMPOUT(0x237DBCBD0);
}

void *re::allocInfo_DynamicAssetHeader(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76BA0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76BA0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76C50, "DynamicAssetHeader");
    __cxa_guard_release(&qword_26AF76BA0);
  }
  return &unk_26AF76C50;
}

void re::initInfo_DynamicAssetHeader(re *this, re::IntrospectionBase *a2)
{
  v9[0] = 0x8CA13F8BC694F7FCLL;
  v9[1] = "DynamicAssetHeader";
  re::StringID::destroyString((re::StringID *)v9);
  *((_OWORD *)this + 2) = v10;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76BB0, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF76BB0);
    if (v4)
    {
      uint64_t v5 = (re *)re::introspectionAllocator(v4);
      re::introspect_AssetSerializationFormat(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "assetSerializationFormat";
      *(void *)(v7 + 16) = &qword_26AF76C08;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF76BA8 = v7;
      __cxa_guard_release(&qword_26AF76BB0);
    }
  }
  *((void *)this + 2) = 0x400000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF76BA8;
  *((void *)this + 9) = re::internal::defaultConstruct<re::DynamicAssetHeader>;
  *((void *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::DynamicAssetHeader>;
  *((void *)this + 1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::internal::defaultConstructV2<re::DynamicAssetHeader>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::DynamicAssetHeader>;
  re::IntrospectionRegistry::add(this, v3);
  long long v8 = v10;
}

void re::introspect_AssetSerializationFormat(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76BC8, memory_order_acquire) & 1) == 0)
  {
    int v24 = (re *)__cxa_guard_acquire(&qword_26AF76BC8);
    if (v24)
    {
      uint64_t v25 = re::introspectionAllocator(v24);
      id v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)id v26 = 1;
      *((void *)v26 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      *((void *)v26 + 2) = "Unknown";
      qword_26AF76BE8 = (uint64_t)v26;
      uint64_t v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 1;
      *((void *)v28 + 2) = "JSON";
      qword_26AF76BF0 = (uint64_t)v28;
      uint64_t v29 = re::introspectionAllocator(v28);
      char v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)char v30 = 1;
      *((void *)v30 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 2;
      *((void *)v30 + 2) = "Binary";
      qword_26AF76BF8 = (uint64_t)v30;
      id v31 = re::introspectionAllocator(v30);
      uint64_t v32 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *(void *)(v32 + 8) = 3;
      *(void *)(v32 + 16) = "OPACK";
      qword_26AF76C00 = v32;
      __cxa_guard_release(&qword_26AF76BC8);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76BD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76BD0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF76C08, "AssetSerializationFormat", 4, 4, 1, 1);
    qword_26AF76C08 = (uint64_t)&unk_26E715E00;
    qword_26AF76C48 = (uint64_t)&re::introspect_AssetSerializationFormat(BOOL)::enumTable;
    dword_26AF76C18 = 9;
    __cxa_guard_release(&qword_26AF76BD0);
  }
  if ((_MergedGlobals_58 & 1) == 0)
  {
    _MergedGlobals_58 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF76C08, a2);
    uint64_t v34 = 0x69029CD6B845AE2ELL;
    uint64_t v35 = "AssetSerializationFormat";
    v38[0] = 208862;
    v38[1] = "int";
    uint64_t v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v38);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v38);
      unint64_t v4 = (unsigned int *)qword_26AF76C48;
      v37[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v38, &v34, 1, 1, (uint64_t)v37);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            id v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v36.var0 = 2 * v10;
            v36.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v38, v14, &v36);
            re::StringID::destroyString((re::StringID *)&v36);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              uint64_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    id v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v36.var0 = 2 * v18;
              v36.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v38, v22, &v36);
              re::StringID::destroyString((re::StringID *)&v36);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v38, v23);
      xmmword_26AF76C28 = (__int128)v36;
      re::StringID::destroyString((re::StringID *)&v34);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v38);
      re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "AssetSerializationFormat", v34, v35);
      _os_crash();
      __break(1u);
    }
  }
}

void re::AssetUtilities::init(re::AssetUtilities *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76BE0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76BE0))
  {
    qword_26AF76BD8 = re::internal::getOrCreateInfo((re::internal *)"DynamicAssetHeader", (uint64_t (*)(re::internal *))re::allocInfo_DynamicAssetHeader, (re::IntrospectionBase *(*)(void))re::initInfo_DynamicAssetHeader, (void (*)(re::IntrospectionBase *))&unk_26AF76BB8, 0);
    __cxa_guard_release(&qword_26AF76BE0);
  }
}

BOOL re::AssetUtilities::deserializeOPACK(uint64_t a1, uint64_t a2, re **a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  v52[6] = *MEMORY[0x263EF8340];
  re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v25);
  if (v23[0])
  {
    *(void *)long long buf = 0x935762BFD538CE16;
    *(void *)&uint8_t buf[8] = "AssetOPACKDeserializer";
    re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SerializerV2((uint64_t)&v34, (const StringID *)buf);
    re::StringID::destroyString((re::StringID *)buf);
    uint64_t v34 = &unk_26E6CB8E0;
    v40[14] = a4;
    re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::open((uint64_t)&v34, a1, a5, a6);
    if (!v38) {
      (*((void (**)(void **, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, void))v34 + 9))(&v34, "asset", 1, a2, v24, v24, 0);
    }
    (*((void (**)(void **))v34 + 7))(&v34);
    uint64_t v12 = re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::close((_anonymous_namespace_ *)&v37);
    BOOL v13 = v38 == 0;
    if (v38)
    {
      uint64_t v14 = *re::assetsLogObjects(v12);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = re::TypeInfo::name((re::TypeInfo *)v24)[1];
        buf[0] = v38;
        if (v38)
        {
          *(_OWORD *)&uint8_t buf[8] = v39;
          re::DynamicString::DynamicString((re::DynamicString *)&v27, (const re::DynamicString *)v40);
          int v21 = (v28 & 1) != 0 ? *(unsigned char **)&v29[7] : v29;
        }
        else
        {
          int v21 = v29;
        }
        *(_DWORD *)char v30 = 136315394;
        uint64_t v31 = v20;
        __int16 v32 = 2080;
        uint64_t v33 = v21;
        _os_log_error_impl(&dword_233120000, v14, OS_LOG_TYPE_ERROR, "Asset deserialization failed. Type \"%s\". Details: %s", v30, 0x16u);
        if (buf[0])
        {
          if (v27 && (v28 & 1) != 0) {
            (*(void (**)(void))(*(void *)v27 + 40))();
          }
        }
      }
    }
    uint64_t v34 = &unk_26E6CBB98;
    double v15 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(v52);
    if (v47)
    {
      if (v51) {
        (*(void (**)(double))(*(void *)v47 + 40))(v15);
      }
      uint64_t v51 = 0;
      uint64_t v48 = 0;
      uint64_t v49 = 0;
      uint64_t v47 = 0;
      ++v50;
    }
    double v16 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v46);
    if (v41)
    {
      if (v45) {
        (*(void (**)(double))(*(void *)v41 + 40))(v16);
      }
      uint64_t v45 = 0;
      uint64_t v42 = 0;
      uint64_t v43 = 0;
      uint64_t v41 = 0;
      ++v44;
    }
    re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::~Serializer((uint64_t)&v34);
  }
  else
  {
    PrettyTypeName = (re *)re::getPrettyTypeName((re *)a3, (const re::IntrospectionBase *)&v34);
    uint64_t v18 = *re::assetsLogObjects(PrettyTypeName);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      if (v35) {
        uint64_t v22 = *(unsigned char **)&v36[7];
      }
      else {
        uint64_t v22 = v36;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v22;
      _os_log_error_impl(&dword_233120000, v18, OS_LOG_TYPE_ERROR, "Asset serialization failed. Type info (\"%s\") not found.", buf, 0xCu);
    }
    if (v34 && (v35 & 1) != 0) {
      (*(void (**)(void))(*(void *)v34 + 40))();
    }
    BOOL v13 = 0;
  }
  re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v25);
  return v13;
}

uint64_t re::AssetUtilities::serializeIntrospectedAsset(_anonymous_namespace_ *a1, const re::IntrospectionBase **a2, const re::AssetPath *a3, uint64_t a4, int a5, const re::AssetPathMapping *a6, char a7)
{
  re::RemappedAssetSerialize::RemappedAssetSerialize((re::RemappedAssetSerialize *)&v22, a3, a6);
  _OWORD v21[2] = 0;
  uint64_t v22 = &unk_26E6CA6B8;
  v23[96] = a7;
  v21[0] = &v22;
  v21[1] = 0;
  switch(a5)
  {
    case 3:
      goto LABEL_6;
    case 2:
      if (*(_DWORD *)(a4 + 16) != 8 || strcmp(*(const char **)(a4 + 48), "SceneAsset"))
      {
LABEL_13:
        uint64_t v22 = &unk_26E6CA688;
        re::Optional<re::AssetPath>::~Optional(v23);
        return v16;
      }
LABEL_6:
      if (!v18[0] && v19 && (v20 & 1) != 0) {
        (*(void (**)(void))(*(void *)v19 + 40))();
      }
      goto LABEL_13;
    case 1:
      goto LABEL_6;
  }
  re::internal::assertLog((re::internal *)4, v15, "assertion failure: '%s' (%s:line %i) Invalid asset serialization format.", "!\"Unreachable code\"", "serializeIntrospectedAsset", 381);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t anonymous namespace'::unwrap(re *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)a1)
  {
    uint64_t v2 = *re::assetsLogObjects(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      if (*((void *)a1 + 2)) {
        unint64_t v4 = (char *)*((void *)a1 + 3);
      }
      else {
        unint64_t v4 = (char *)a1 + 17;
      }
      int v5 = 136446210;
      unint64_t v6 = v4;
      _os_log_error_impl(&dword_233120000, v2, OS_LOG_TYPE_ERROR, "%{public}s", (uint8_t *)&v5, 0xCu);
    }
  }
  return *(unsigned __int8 *)a1;
}

uint64_t deserializeIntrospectedAssetWithVersioning@<X0>(uint64_t a1@<X0>, const char **a2@<X1>, uint64_t *a3@<X2>, re::PersistedSchema *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int a7@<W6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)a8) {
    uint64_t v17 = *(void *)(a8 + 8);
  }
  else {
    uint64_t v17 = 0;
  }
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v43, 2054, v17, *a2);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v43);
  uint64_t v19 = (const re::IntrospectionBase *)a5;
  if (!a4) {
    goto LABEL_12;
  }
  re::getPrettyTypeName((re *)a5, (const re::IntrospectionBase *)&v37);
  if (BYTE8(v37)) {
    char v20 = v38;
  }
  else {
    char v20 = (char *)&v37 + 9;
  }
  uint64_t v21 = re::PersistedSchema::introspectionInfo(a4, v20);
  if (v21)
  {
    uint64_t v19 = (const re::IntrospectionBase *)v21;
    if (void)v37 && (BYTE8(v37)) {
      (*(void (**)(void))(*(void *)v37 + 40))();
    }
LABEL_12:
    *(void *)long long buf = a6;
    *(void *)&uint8_t buf[8] = 0;
    uint64_t v45 = deserializeIntrospectedAssetWithVersioning(re::SeekableInputStream &,re::AssetType const&,re::AssetLoadData const&,re::PersistedSchema const*,re::IntrospectionBase const&,re::AssetSerializationScheme &,re::AssetSerializationFormat,re::Optional<unsigned long long>)::$_0::__invoke;
    uint64_t v22 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*a3, (unint64_t)a2);
    int v24 = (re::DynamicString **)(*(uint64_t (**)(uint64_t))(*(void *)v22 + 120))(v22);
    if (a7 == 3)
    {
    }
    else
    {
      if (a7 != 2)
      {
        re::internal::assertLog((re::internal *)4, v23, "assertion failure: '%s' (%s:line %i) Unexpected asset serialization format.", "!\"Unreachable code\"", "deserializeIntrospectedAssetWithVersioning", 466);
        uint64_t result = _os_crash();
        __break(1u);
        return result;
      }
      if (*(_DWORD *)(a5 + 16) != 8 || strcmp(*(const char **)(a5 + 48), "SceneAsset"))
      {
        *(void *)&long long v37 = &unk_26E714DC0;
        *((void *)&v37 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = a1;
        char v38 = 0;
        LODWORD(v39) = 0;
        uint64_t v40 = 0;
        uint64_t v41 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        char v42 = 0;
        char v26 = result;
        if (v39) {
          uint64_t result = (*(uint64_t (**)(void))(**((void **)&v37 + 1) + 24))(*((void *)&v37 + 1));
        }
LABEL_20:
        if (v26)
        {
          *(unsigned char *)a9 = 1;
          *(void *)(a9 + 8) = v24;
        }
        else
        {
          uint64_t v27 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, re::DynamicString **))(*(void *)v22 + 16))(v22, v24);
          long long v28 = v37;
          uint64_t v29 = v38;
          uint64_t v30 = v39;
          *(unsigned char *)a9 = 0;
          *(_OWORD *)(a9 + 8) = v28;
          *(void *)(a9 + 24) = v29;
          *(void *)(a9 + 32) = v30;
        }
        return result;
      }
    }
    char v26 = result;
    if (!(_BYTE)v37)
    {
      uint64_t result = *((void *)&v37 + 1);
      if (*((void *)&v37 + 1))
      {
        if (v38) {
          uint64_t result = (*(uint64_t (**)(void))(**((void **)&v37 + 1) + 40))();
        }
      }
    }
    goto LABEL_20;
  }
  uint64_t v31 = *re::assetsLogObjects(0);
  BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
  if (v32)
  {
    if (BYTE8(v37)) {
      StringID v36 = (char *)v38;
    }
    else {
      StringID v36 = (char *)&v37 + 9;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v36;
    _os_log_error_impl(&dword_233120000, v31, OS_LOG_TYPE_ERROR, "Failed to find asset schema '%s'", buf, 0xCu);
  }
  long long v33 = *(_OWORD *)buf;
  uint64_t v34 = v45;
  uint64_t v35 = v46;
  *(unsigned char *)a9 = 0;
  *(_OWORD *)(a9 + 8) = v33;
  *(void *)(a9 + 24) = v34;
  *(void *)(a9 + 32) = v35;
  uint64_t result = v37;
  if (void)v37 && (BYTE8(v37)) {
    return (*(uint64_t (**)(void))(*(void *)v37 + 40))();
  }
  return result;
}

uint64_t re::AssetUtilities::deserializeIntrospectedAsset(uint64_t a1, const char **a2, uint64_t *a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  v8[0] = *(unsigned char *)a7;
  if (v8[0]) {
    uint64_t v9 = *(void *)(a7 + 8);
  }
  deserializeIntrospectedAssetWithVersioning(a1, a2, a3, 0, a4, a5, a6, (uint64_t)v8, (uint64_t)v10);
  uint64_t result = v11;
  if (!v10[0] && v11)
  {
    if (v12) {
      (*(void (**)(void))(*(void *)v11 + 40))();
    }
    return 0;
  }
  return result;
}

__n128 re::AssetUtilities::saveAssetHandleToPath@<Q0>(re::AssetHandle *this@<X1>, re::FileStreamWriter *a2@<X0>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v8 = *((void *)this + 1);
  if (!v8)
  {
    uint64_t v11 = 0;
    uint64_t v9 = 0;
    goto LABEL_5;
  }
  uint64_t v9 = *(uint64_t **)(v8 + 264);
  unsigned int v10 = atomic_load((unsigned int *)(v8 + 704));
  if (v10 != 2)
  {
    uint64_t v11 = *((void *)this + 1);
LABEL_5:
    re::AssetHandle::loadNow(v11, 0);
  }
  uint64_t v12 = *((void *)this + 1);
  if (v12 && (unsigned int v13 = atomic_load((unsigned int *)(v12 + 704)), v13 == 2))
  {
    re::AssetHandle::serializableAsset(this, &v21);
    uint64_t v14 = (const re::IntrospectionBase **)v21.n128_u64[0];
    uint64_t v15 = (const re::AssetPath *)re::AssetHandle::legacy_assetPath(this);
    re::AssetUtilities::saveCompiledAssetToPath(a2, v14, v15, v9, a3, a4);
    std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v21);
  }
  else
  {
    uint64_t v17 = re::AssetHandle::assetInfo(this);
    if (v17[17]) {
      uint64_t v18 = (char *)v17[18];
    }
    else {
      uint64_t v18 = (char *)v17 + 137;
    }
    re::DynamicString::format((re::DynamicString *)"Asset '%s' failed to load", (re::DynamicString *)&v21, v18);
    __n128 result = v21;
    uint64_t v19 = v22;
    uint64_t v20 = v23;
    *(unsigned char *)a4 = 0;
    *(__n128 *)(a4 + 8) = result;
    *(void *)(a4 + 24) = v19;
    *(void *)(a4 + 32) = v20;
  }
  return result;
}

uint64_t re::AssetUtilities::saveCompiledAssetToPath@<X0>(re::FileStreamWriter *a1@<X0>, const re::IntrospectionBase **a2@<X1>, const re::AssetPath *a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  if (re::ensureFolderExistsForFile(a1, (const char *)a2))
  {
    re::FileStreamWriter::open(a1, (uint64_t)&v22);
    if ((_BYTE)v22)
    {
      re::AssetUtilities::saveCompiledAssetToStream((uint64_t)&v22 + 8, a2, a3, a4, a5, (unsigned __int8 *)a6);
    }
    else
    {
      re::formattedErrorMessage<re::DetailedError>((uint64_t)&v22 + 8, (re::DynamicString *)&v19);
      long long v16 = v19;
      uint64_t v17 = v20;
      uint64_t v18 = v21;
      *(unsigned char *)a6 = 0;
      *(_OWORD *)(a6 + 8) = v16;
      *(void *)(a6 + 24) = v17;
      *(void *)(a6 + 32) = v18;
    }
    return re::Result<re::FileStreamWriter,re::DetailedError>::~Result((uint64_t)&v22);
  }
  else
  {
    uint64_t result = re::DynamicString::format((re::DynamicString *)"Failed to create directory for '%s'", (re::DynamicString *)&v22, a1);
    long long v13 = v22;
    uint64_t v14 = v23;
    uint64_t v15 = v24;
    *(unsigned char *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v13;
    *(void *)(a6 + 24) = v14;
    *(void *)(a6 + 32) = v15;
  }
  return result;
}

uint64_t re::AssetUtilities::saveCompiledAssetToStream@<X0>(uint64_t a1@<X0>, const re::IntrospectionBase **a2@<X1>, const re::AssetPath *a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, unsigned __int8 *a6@<X8>)
{
  v117[7] = *MEMORY[0x263EF8340];
  uint64_t v12 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(**(void **)a5, (unint64_t)a4);
  long long v13 = (const re::IntrospectionBase *)(*(uint64_t (**)(uint64_t))(*(void *)v12 + 112))(v12);
  uint64_t v14 = (re *)(*(uint64_t (**)(uint64_t, const re::IntrospectionBase **))(*(void *)v12 + 128))(v12, a2);
  int v15 = (int)v14;
  if (v14 == 1)
  {
    long long v16 = *re::assetsLogObjects(v14);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = *a4;
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl(&dword_233120000, v16, OS_LOG_TYPE_DEFAULT, "Asset may not be fully serialized. Type \"%s\"", buf, 0xCu);
    }
  }
  uint64_t v97 = 0;
  v94[1] = 0;
  uint64_t v95 = 0;
  v94[0] = 0;
  int v96 = 0;
  int v18 = *(_DWORD *)(a5 + 32);
  if (v18 != 2)
  {
LABEL_7:
    uint64_t v93 = 0;
    v90[1] = 0;
    uint64_t v91 = 0;
    int v92 = 0;
    v89[0] = &unk_26E7147E8;
    v89[1] = v90;
    v90[0] = 0;
    if ((re::AssetUtilities::serializeIntrospectedAsset((_anonymous_namespace_ *)v89, a2, a3, (uint64_t)v13, v18, *(const re::AssetPathMapping **)(a5 + 16), *(unsigned char *)(a5 + 37)) & 1) == 0)
    {
      re::DynamicString::format((re::DynamicString *)"Serializing compiled file failed", (re::DynamicString *)buf);
      __n128 v20 = *(__n128 *)buf;
      long long v25 = v99;
      *a6 = 0;
      *(__n128 *)(a6 + 8) = v20;
      *(_OWORD *)(a6 + 24) = v25;
LABEL_85:
      if (v90[0] && v93) {
        (*(void (**)(void))(*(void *)v90[0] + 40))();
      }
      goto LABEL_88;
    }
    uint64_t v88 = 0;
    v85[1] = 0;
    uint64_t v86 = 0;
    int v87 = 0;
    v84[0] = &unk_26E7147E8;
    v84[1] = v85;
    v85[0] = 0;
    uint64_t v21 = (re::DynamicAssetHeader *)(*(uint64_t (**)(uint64_t, void *, const re::IntrospectionBase **, void))(*(void *)v12 + 56))(v12, v84, a2, *(void *)(a5 + 24));
    if ((v21 & 1) == 0)
    {
      unint64_t v26 = *((void *)a3 + 1);
      BOOL v65 = 0;
      v66[0] = 0;
      __n128 v64 = (__n128)v26;
      re::DynamicString::setCapacity(&v64, 0);
      re::AssetPath::fullAssetPath(a3, (re::DynamicString *)&v64);
      if (v64.n128_u8[8]) {
        uint64_t v27 = v65;
      }
      else {
        uint64_t v27 = &v64.n128_i8[9];
      }
      re::DynamicString::format((re::DynamicString *)"Serializing compiled file blob failed for %s", (re::DynamicString *)buf, v27);
      __n128 v20 = *(__n128 *)buf;
      long long v28 = v99;
      *a6 = 0;
      *(__n128 *)(a6 + 8) = v20;
      *(_OWORD *)(a6 + 24) = v28;
      if (v64.n128_u64[0] && (v64.n128_u8[8] & 1) != 0) {
        (*(void (**)(void))(*(void *)v64.n128_u64[0] + 40))();
      }
      goto LABEL_82;
    }
    v81[0] = 825246019;
    int v23 = *(unsigned __int8 *)(a5 + 36);
    if (*(unsigned char *)(a5 + 36))
    {
      int v24 = 3;
    }
    else
    {
      int v29 = *(_DWORD *)(a5 + 32);
      if (v29 == 2)
      {
        int v24 = 1;
      }
      else
      {
        if (v29 != 3)
        {
          re::internal::assertLog((re::internal *)4, v22, "assertion failure: '%s' (%s:line %i) Unsupported compiled asset serialization format.", "!\"Unreachable code\"", "headerVersion", 199);
          uint64_t result = _os_crash();
          __break(1u);
          return result;
        }
        int v24 = 2;
      }
    }
    v81[1] = v24;
    v81[2] = 1;
    uint64_t v83 = *(void *)(a5 + 8);
    int v30 = v95 != 0;
    int v82 = v30;
    if (v86)
    {
      v30 |= 2u;
      int v82 = v30;
    }
    if (v23)
    {
      int v82 = v30 | 4;
      uint64_t v80 = 0;
      uint64_t v77 = 0;
      uint64_t v78 = 0;
      uint64_t v76 = 0;
      int v79 = 0;
      re::DynamicAssetHeader::DynamicAssetHeader(v21);
      int v75 = *(_DWORD *)(a5 + 32);
      re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v74);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76BE0, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF76BE0))
      {
        qword_26AF76BD8 = re::internal::getOrCreateInfo((re::internal *)"DynamicAssetHeader", (uint64_t (*)(re::internal *))re::allocInfo_DynamicAssetHeader, (re::IntrospectionBase *(*)(void))re::initInfo_DynamicAssetHeader, (void (*)(re::IntrospectionBase *))&unk_26AF76BB8, 0);
        __cxa_guard_release(&qword_26AF76BE0);
      }
      if (!v72[0])
      {
        long long v40 = *(_OWORD *)buf;
        long long v41 = v99;
        *a6 = 0;
        *(_OWORD *)(a6 + 8) = v40;
        *(_OWORD *)(a6 + 24) = v41;
        re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v74);
        goto LABEL_78;
      }
      v64.n128_u16[4] = 0;
      BOOL v65 = (char *)&v76;
      v64.n128_u64[0] = (unint64_t)&unk_26E714878;
      v66[0] = &unk_26E7148D0;
      v66[1] = 0;
      void v66[2] = &unk_26E6BE858;
      v66[3] = v66;
      __int16 v67 = 0;
      uint64_t v68 = 0;
      uint64_t v69 = 0;
      uint64_t v70 = 0x2000;
      uint64_t v71 = 0;
      *(void *)int v57 = 0x7F1E19097D86D060;
      *(void *)&v57[8] = "DynamicAssetHeaderSerializer";
      re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SerializerV2((uint64_t)buf, (const StringID *)v57);
      re::StringID::destroyString((re::StringID *)v57);
      uint64_t v32 = re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::open((uint64_t)buf, (uint64_t)&v64, 0, 0);
      if (v103
        || (uint64_t v32 = (*(uint64_t (**)(uint8_t *, const char *, void, int *, unsigned char *, unsigned char *, void))(*(void *)buf + 72))(buf, "DynamicAssetHeader", 0, &v75, v73, v73, 0), (v32 & 1) == 0))
      {
        int v46 = 0;
        long long v47 = *(_OWORD *)v57;
        uint64_t v48 = *(void *)&v57[16];
        uint64_t v49 = v58;
        *a6 = 0;
        *(_OWORD *)(a6 + 8) = v47;
        *((void *)a6 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v48;
        *((void *)a6 + 4) = v49;
      }
      else if (v103)
      {
        v57[0] = 1;
        *(_OWORD *)&v57[8] = v104;
        re::DynamicString::DynamicString((re::DynamicString *)&v58, (const re::DynamicString *)&v105);
        if (v59) {
          char v42 = *(unsigned char **)&v60[7];
        }
        else {
          char v42 = v60;
        }
        re::DynamicString::format((re::DynamicString *)"%s", (re::DynamicString *)&v61, v42);
        long long v43 = v61;
        uint64_t v44 = v62;
        uint64_t v45 = v63;
        *(void *)&long long v61 = 0;
        uint64_t v62 = 0;
        *a6 = 0;
        *(_OWORD *)(a6 + 8) = v43;
        *((void *)a6 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v44;
        *((void *)a6 + 4) = v45;
        if (v57[0] && v58 && (v59 & 1) != 0) {
          (*(void (**)(void))(*(void *)v58 + 40))();
        }
        int v46 = 0;
      }
      else
      {
        (*(void (**)(uint8_t *))(*(void *)buf + 56))(buf);
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::close((_anonymous_namespace_ *)((char *)&v99 + 8));
        re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::deinit(buf);
        int v46 = 1;
      }
      *(void *)long long buf = &unk_26E6C8CF8;
      double v50 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(v117);
      if (v112)
      {
        if (v116) {
          (*(void (**)(double))(*(void *)v112 + 40))(v50);
        }
        uint64_t v116 = 0;
        uint64_t v113 = 0;
        uint64_t v114 = 0;
        uint64_t v112 = 0;
        ++v115;
      }
      double v51 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v111);
      if (v106)
      {
        if (v110) {
          (*(void (**)(double))(*(void *)v106 + 40))(v51);
        }
        uint64_t v110 = 0;
        uint64_t v107 = 0;
        uint64_t v108 = 0;
        uint64_t v106 = 0;
        ++v109;
      }
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)buf);
      re::DynamicArrayBufferedOutputStream::~DynamicArrayBufferedOutputStream((re::DynamicArrayBufferedOutputStream *)&v64);
      re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v74);
      if (!v46) {
        goto LABEL_78;
      }
      if (*(unsigned char *)(a5 + 36))
      {
        *(void *)long long buf = 88;
        *(void *)&uint8_t buf[8] = v78;
        uint64_t v52 = v95;
        if (v82) {
          id v53 = (char *)v78 + 88;
        }
        else {
          id v53 = 0;
        }
        if ((v82 & 1) == 0) {
          uint64_t v52 = 0;
        }
        *(void *)&long long v99 = v53;
        *((void *)&v99 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v52;
        *(void *)&long long v100 = (char *)v78 + (void)v52 + 88;
        *((void *)&v100 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v91;
        if ((v82 & 2) != 0)
        {
          unint64_t v101 = (char *)v91 + (unint64_t)v78 + (void)v52 + 88;
          uint64_t v102 = v86;
        }
        else
        {
          uint64_t v102 = 0;
          unint64_t v101 = 0;
        }
      }
    }
    else
    {
      uint64_t v80 = 0;
      uint64_t v77 = 0;
      uint64_t v78 = 0;
      uint64_t v76 = 0;
      int v79 = 0;
    }
    long long v33 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, _DWORD *, uint64_t))(*(void *)a1 + 16))(a1, v81, 24);
    if (v33 == (_anonymous_namespace_ *)24)
    {
      if (!*(unsigned char *)(a5 + 36))
      {
LABEL_34:
        if (v95
          && (StringID v36 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 16))(a1, v97), v36 != v95))
        {
          uint64_t v39 = "write compiled file schema failed";
        }
        else
        {
          long long v37 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, _anonymous_namespace_ *))(*(void *)a1 + 16))(a1, v93, v91);
          if (v37 == v91)
          {
            if (!v86
              || (char v38 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 16))(a1, v88), v38 == v86))
            {
              *a6 = 1;
              goto LABEL_78;
            }
            uint64_t v39 = "write compiled file blob failed";
          }
          else
          {
            uint64_t v39 = "write compiled file data failed";
          }
        }
        goto LABEL_77;
      }
      uint64_t v34 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint8_t *, uint64_t))(*(void *)a1 + 16))(a1, buf, 64);
      if (v34 == (_anonymous_namespace_ *)64)
      {
        uint64_t v35 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, _anonymous_namespace_ *))(*(void *)a1 + 16))(a1, v80, v78);
        if (v35 == v78) {
          goto LABEL_34;
        }
        uint64_t v39 = "Failed to write DynamicAssetHeader bytes.";
      }
      else
      {
        uint64_t v39 = "Failed to write CompiledAssetOffsets bytes.";
      }
    }
    else
    {
      uint64_t v39 = "write compiled file header failed";
    }
LABEL_77:
    __n128 v20 = v64;
    uint64_t v54 = v65;
    uint64_t v55 = v66[0];
    *a6 = 0;
    *(__n128 *)(a6 + 8) = v20;
    *((void *)a6 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v54;
    *((void *)a6 + 4) = v55;
LABEL_78:
    if (v76)
    {
      if (v80) {
        (*(void (**)(void))(*(void *)v76 + 40))();
      }
      uint64_t v80 = 0;
    }
LABEL_82:
    if (v85[0] && v88) {
      (*(void (**)(void))(*(void *)v85[0] + 40))();
    }
    goto LABEL_85;
  }
  LODWORD(v100) = 0;
  *(_OWORD *)long long buf = 0u;
  long long v99 = 0u;
  *(void *)((char *)&v100 + 4) = 0x7FFFFFFFLL;
  re::PersistedSchema::addIntrospectionGraph((re::PersistedSchema *)buf, v13);
  v64.n128_u64[0] = (unint64_t)&unk_26E7147E8;
  v64.n128_u64[1] = (unint64_t)v94;
  int v19 = *a6;
  v20.n128_f64[0] = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)buf);
  if (v19)
  {
    int v18 = *(_DWORD *)(a5 + 32);
    goto LABEL_7;
  }
LABEL_88:
  uint64_t result = v94[0];
  if (v94[0] && v97) {
    uint64_t result = (*(uint64_t (**)(__n128))(*(void *)v94[0] + 40))(v20);
  }
  if (v15) {
    return (*(uint64_t (**)(uint64_t, const re::IntrospectionBase **, __n128))(*(void *)v12 + 136))(v12, a2, v20);
  }
  return result;
}

__n128 re::AssetUtilities::saveAssetHandleToStream@<Q0>(re::AssetHandle *this@<X1>, uint64_t a2@<X0>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v8 = *((void *)this + 1);
  if (!v8)
  {
    uint64_t v11 = 0;
    uint64_t v9 = 0;
    goto LABEL_5;
  }
  uint64_t v9 = *(uint64_t **)(v8 + 264);
  unsigned int v10 = atomic_load((unsigned int *)(v8 + 704));
  if (v10 != 2)
  {
    uint64_t v11 = *((void *)this + 1);
LABEL_5:
    re::AssetHandle::loadNow(v11, 0);
  }
  uint64_t v12 = *((void *)this + 1);
  if (v12 && (unsigned int v13 = atomic_load((unsigned int *)(v12 + 704)), v13 == 2))
  {
    re::AssetHandle::serializableAsset(this, &v21);
    uint64_t v14 = (const re::IntrospectionBase **)v21.n128_u64[0];
    int v15 = (const re::AssetPath *)re::AssetHandle::legacy_assetPath(this);
    re::AssetUtilities::saveCompiledAssetToStream(a2, v14, v15, v9, a3, (unsigned __int8 *)a4);
    std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v21);
  }
  else
  {
    uint64_t v17 = re::AssetHandle::assetInfo(this);
    if (v17[17]) {
      int v18 = (char *)v17[18];
    }
    else {
      int v18 = (char *)v17 + 137;
    }
    re::DynamicString::format((re::DynamicString *)"Asset '%s' failed to load", (re::DynamicString *)&v21, v18);
    __n128 result = v21;
    uint64_t v19 = v22;
    uint64_t v20 = v23;
    *(unsigned char *)a4 = 0;
    *(__n128 *)(a4 + 8) = result;
    *(void *)(a4 + 24) = v19;
    *(void *)(a4 + 32) = v20;
  }
  return result;
}

uint64_t re::AssetUtilities::loadCompiledAsset@<X0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X1>, const char **a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v17 = 0;
  int v18 = 0;
  uint64_t v19 = 0;
  re::DynamicString::setCapacity(&v16, 0);
  if (re::AssetPath::filePathToAsset(a1, (re::DynamicString *)&v16, 0, *(os_unfair_lock_s **)(a2 + 16)))
  {
    if (v17) {
      uint64_t v12 = v18;
    }
    else {
      uint64_t v12 = (char *)&v17 + 1;
    }
    v14[0] = *(unsigned char *)a5;
    if (v14[0]) {
      uint64_t v15 = *(void *)(a5 + 8);
    }
    re::AssetUtilities::loadCompiledAssetFromPath(v12, (uint64_t *)a2, a3, a4, v14, a6);
  }
  else
  {
    *(unsigned char *)a6 = 1;
    *(void *)(a6 + 8) = 0;
  }
  uint64_t result = (uint64_t)v16;
  if (v16)
  {
    if (v17) {
      return (*(uint64_t (**)(void))(*v16 + 40))();
    }
  }
  return result;
}

void re::AssetUtilities::loadCompiledAssetFromPath(char *a1@<X0>, uint64_t *a2@<X1>, const char **a3@<X2>, uint64_t a4@<X3>, char *a5@<X4>, uint64_t a6@<X8>)
{
  re::FileSeekableInputStream::FileSeekableInputStream((re::FileSeekableInputStream *)v31, a1, 0, -1);
  if (v33 == -1)
  {
    if (v31[48]) {
      unsigned int v13 = *(unsigned char **)&v32[7];
    }
    else {
      unsigned int v13 = v32;
    }
    re::DynamicString::format((re::DynamicString *)"Attempt to open compiled file '%s' did not succeed: %s", (re::DynamicString *)&v27, a1, v13);
    if (v28) {
      uint64_t v14 = v29;
    }
    else {
      uint64_t v14 = (char *)&v28 + 1;
    }
    re::WrappedError::make((re::WrappedError *)@"REAssetLoadingErrorDomain", (const __CFString *)0x12C, (uint64_t)v14, &v22);
    uint64_t v15 = v22;
    uint64_t v22 = 0;
    *(unsigned char *)a6 = 0;
    *(void *)(a6 + 8) = v15;

    uint64_t v16 = v27;
    if (v27 && (v28 & 1) != 0)
    {
      uint64_t v17 = v29;
LABEL_15:
      (*(void (**)(uint64_t, char *))(*(void *)v16 + 40))(v16, v17);
    }
  }
  else
  {
    v25[0] = *a5;
    if (v25[0]) {
      uint64_t v26 = *((void *)a5 + 1);
    }
    re::AssetUtilities::loadCompiledAssetFromStream((re *)v31, a2, a3, a4, 0, 0, (uint64_t)v25, (uint64_t)&v27);
    if ((_BYTE)v27)
    {
      uint64_t v12 = v28;
      *(unsigned char *)a6 = 1;
      *(void *)(a6 + 8) = v12;
      goto LABEL_26;
    }
    if (v29) {
      int v18 = v30;
    }
    else {
      int v18 = (char *)&v29 + 1;
    }
    re::DynamicString::format((re::DynamicString *)"Error loading compiled file '%s': %s", (re::DynamicString *)&v22, a1, v18);
    if (v23) {
      uint64_t v19 = *(unsigned char **)&v24[7];
    }
    else {
      uint64_t v19 = v24;
    }
    re::WrappedError::make((re::WrappedError *)@"REAssetLoadingErrorDomain", (const __CFString *)0x12C, (uint64_t)v19, &v21);
    uint64_t v20 = v21;
    uint64_t v21 = 0;
    *(unsigned char *)a6 = 0;
    *(void *)(a6 + 8) = v20;

    if (v22 && (v23 & 1) != 0) {
      (*(void (**)(void))(*(void *)v22 + 40))();
    }
    if (!(_BYTE)v27)
    {
      uint64_t v16 = v28;
      if (v28)
      {
        if (v29)
        {
          uint64_t v17 = v30;
          goto LABEL_15;
        }
      }
    }
  }
LABEL_26:
  re::FileSeekableInputStream::~FileSeekableInputStream((re::FileSeekableInputStream *)v31);
}

void re::AssetUtilities::loadCompiledAssetFromStream(re *a1@<X0>, uint64_t *a2@<X1>, const char **a3@<X2>, uint64_t a4@<X3>, unsigned char *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  v139[7] = *MEMORY[0x263EF8340];
  v126[0] = 0;
  *(void *)&long long v125 = 0;
  long long v124 = 0uLL;
  DWORD2(v125) = 0;
  *(void *)&v122[8] = 0;
  *(void *)&v122[16] = 0;
  *(void *)uint64_t v122 = a1;
  LODWORD(v12re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  BOOL Next = re::SeekableInputStreamBufferedReader::readNext((re::SeekableInputStreamBufferedReader *)v122, 0x18uLL);
  if (*(void *)&v122[16] <= 0x17uLL)
  {
    uint64_t v17 = *re::assetsLogObjects((re *)Next);
    BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    if (v18)
    {
      *(_WORD *)uint64_t v113 = 0;
      _os_log_error_impl(&dword_233120000, v17, OS_LOG_TYPE_ERROR, "Compiled file is too short", v113, 2u);
    }
    uint64_t v19 = "Compiled file is too short";
LABEL_5:
    long long v20 = *(_OWORD *)v113;
    uint64_t v21 = *(void *)&v113[16];
    uint64_t v22 = v114;
    char v108 = 0;
LABEL_15:
    *(_OWORD *)int v109 = v20;
    *(void *)&v109[16] = v21;
    uint64_t v110 = v22;
    int v30 = 1;
    goto LABEL_16;
  }
  int v23 = **(_DWORD **)&v122[8];
  if (**(_DWORD **)&v122[8] != 825246019)
  {
    uint64_t v28 = *re::assetsLogObjects((re *)Next);
    BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
    if (v29)
    {
      *(_DWORD *)uint64_t v113 = 67109376;
      *(_DWORD *)&v113[4] = v23;
      *(_WORD *)&v113[8] = 1024;
      *(_DWORD *)&v113[10] = 825246019;
      _os_log_error_impl(&dword_233120000, v28, OS_LOG_TYPE_ERROR, "Compiled file has incorrect file tag (got %x, expected %x)", v113, 0xEu);
    }
    long long v20 = *(_OWORD *)v113;
    uint64_t v21 = *(void *)&v113[16];
    uint64_t v22 = v114;
    char v108 = 0;
    goto LABEL_15;
  }
  int v24 = *(_DWORD *)(*(void *)&v122[8] + 4);
  int v25 = *(_DWORD *)(*(void *)&v122[8] + 8);
  if (a3 && v25 != 1)
  {
    uint64_t v26 = *re::assetsLogObjects((re *)Next);
    BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    if (v27)
    {
      *(_DWORD *)uint64_t v113 = 67109376;
      *(_DWORD *)&v113[4] = v25;
      *(_WORD *)&v113[8] = 1024;
      *(_DWORD *)&v113[10] = 1;
      _os_log_error_impl(&dword_233120000, v26, OS_LOG_TYPE_ERROR, "Compiled file has an incorrect asset version (got %d, expected %d)", v113, 0xEu);
    }
    uint64_t v19 = "Compiled file has an incorrect asset version";
    goto LABEL_5;
  }
  int v30 = 0;
  char v108 = 1;
  *(_DWORD *)int v109 = 825246019;
  *(_DWORD *)&v109[4] = v24;
  *(void *)&v109[12] = *(void *)(*(void *)&v122[8] + 12);
  int v43 = *(_DWORD *)(*(void *)&v122[8] + 20);
  *(_DWORD *)&v109[8] = v25;
  *(_DWORD *)&v109[20] = v43;
LABEL_16:
  if (v123)
  {
    (*(void (**)(void))(**(void **)v122 + 24))(*(void *)v122);
    LODWORD(v12re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  }
  memset(v122, 0, sizeof(v122));
  uint64_t v31 = (re::DynamicAssetHeader *)v124;
  if ((void)v124 && v126[0]) {
    uint64_t v31 = (re::DynamicAssetHeader *)(*(uint64_t (**)(void))(*(void *)v124 + 40))();
  }
  if (!v30)
  {
    memset(v107, 0, sizeof(v107));
    if ((v109[12] & 4) != 0)
    {
      uint64_t v39 = (_anonymous_namespace_ *)re::CopyRead(a1, (re::SeekableInputStream *)0x40, (uint64_t)v107, v16);
      if ((unint64_t)v39 <= 0x3F)
      {
        char v103 = 0;
        long long v104 = *(_OWORD *)v122;
        uint64_t v105 = *(void *)&v122[16];
        uint64_t v106 = v123;
        re::DynamicString::DynamicString((re::DynamicString *)v122, (const re::DynamicString *)&v104);
        *(unsigned char *)a8 = 0;
        long long v40 = v123;
        *(void *)(a8 + 8) = *(void *)v122;
        *(void *)(a8 + 32) = v40;
        *(_OWORD *)(a8 + 16) = *(_OWORD *)&v122[8];
LABEL_123:
        if (void)v104 && (BYTE8(v104)) {
          (*(void (**)(void))(*(void *)v104 + 40))();
        }
LABEL_126:
        if (v108) {
          return;
        }
        goto LABEL_127;
      }
      char v103 = 1;
      re::DynamicAssetHeader::DynamicAssetHeader(v39);
      int v102 = 0;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76BE0, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF76BE0))
      {
        qword_26AF76BD8 = re::internal::getOrCreateInfo((re::internal *)"DynamicAssetHeader", (uint64_t (*)(re::internal *))re::allocInfo_DynamicAssetHeader, (re::IntrospectionBase *(*)(void))re::initInfo_DynamicAssetHeader, (void (*)(re::IntrospectionBase *))&unk_26AF76BB8, 0);
        __cxa_guard_release(&qword_26AF76BE0);
      }
      long long v112 = *(_OWORD *)(qword_26AF76BD8 + 32);
      re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v111);
      re::TypeRegistry::typeInfo((re *)v112, (re **)&v112, v122);
      re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)&v122[8]);
      *(void *)uint64_t v113 = 0x2568151B0860AFE2;
      *(void *)&v113[8] = "DynamicAssetHeaderDeserializer";
      re::SerializerV2<re::EncoderOPACK<re::SeekableInputStream>>::SerializerV2((uint64_t)v122, (const StringID *)v113);
      re::StringID::destroyString((re::StringID *)v113);
      re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::init((uint64_t)v122, v112);
      uint64_t v44 = re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::open((uint64_t)v122, (uint64_t)a1, 0, 0);
      if (LOBYTE(v126[0])
        || (uint64_t v44 = (*(uint64_t (**)(uint8_t *, const char *, void, int *, uint8_t *, uint8_t *, void))(*(void *)v122 + 72))(v122, "DynamicAssetHeader", 0, &v102, buf, buf, 0), (v44 & 1) == 0))
      {
        int v59 = 0;
        char v98 = 0;
        long long v99 = *(_OWORD *)v113;
        uint64_t v100 = *(void *)&v113[16];
        uint64_t v101 = v114;
      }
      else
      {
        (*(void (**)(uint8_t *))(*(void *)v122 + 56))(v122);
        re::Encoder<re::EncoderOPACK<re::SeekableInputStream>,re::SeekableInputStream>::close((_anonymous_namespace_ *)&v123);
        if (LOBYTE(v126[0]))
        {
          v113[0] = 1;
          *(_OWORD *)&v113[8] = *(_OWORD *)&v126[1];
          re::DynamicString::DynamicString((re::DynamicString *)&v114, (const re::DynamicString *)&v127);
          if (v115) {
            uint64_t v58 = (char *)v116;
          }
          else {
            uint64_t v58 = (char *)&v115 + 1;
          }
          re::DynamicString::format((re::DynamicString *)"%s", (re::DynamicString *)v120, v58);
          char v98 = 0;
          long long v99 = *(_OWORD *)v120;
          uint64_t v100 = *(void *)&v120[16];
          uint64_t v101 = v121;
          if (v113[0] && v114 && (v115 & 1) != 0) {
            (*(void (**)(void))(*(void *)v114 + 40))();
          }
          int v59 = 0;
        }
        else
        {
          re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::deinit(v122);
          int v59 = 1;
        }
      }
      *(void *)uint64_t v122 = &unk_26E6CBB98;
      double v60 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(v139);
      if (v134)
      {
        if (v138) {
          (*(void (**)(double))(*(void *)v134 + 40))(v60);
        }
        uint64_t v138 = 0;
        uint64_t v135 = 0;
        uint64_t v136 = 0;
        uint64_t v134 = 0;
        ++v137;
      }
      double v61 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v133);
      if (v128)
      {
        if (v132) {
          (*(void (**)(double))(*(void *)v128 + 40))(v61);
        }
        uint64_t v132 = 0;
        uint64_t v129 = 0;
        uint64_t v130 = 0;
        uint64_t v128 = 0;
        ++v131;
      }
      re::Serializer<re::EncoderOPACK<re::SeekableInputStream>>::~Serializer((uint64_t)v122);
      re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v111);
      if (!v59)
      {
        if (!v98)
        {
          re::DynamicString::DynamicString((re::DynamicString *)v122, (const re::DynamicString *)&v99);
          *(unsigned char *)a8 = 0;
          uint64_t v62 = v123;
          *(void *)(a8 + 8) = *(void *)v122;
          *(void *)(a8 + 32) = v62;
          *(_OWORD *)(a8 + 16) = *(_OWORD *)&v122[8];
          if (void)v99 && (BYTE8(v99)) {
            (*(void (**)(void))(*(void *)v99 + 40))();
          }
          goto LABEL_122;
        }
LABEL_26:
        uint64_t v87 = a6;
        uint64_t v88 = a5;
        int v34 = v102;
        if (v102) {
          goto LABEL_27;
        }
        int v42 = *(_DWORD *)&v109[4];
        if (*(_DWORD *)&v109[4] == 1)
        {
          int v34 = 2;
LABEL_27:
          uint64_t v35 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*a2, (unint64_t)a3);
          uint64_t v36 = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 112))(v35);
          v122[16] = 0;
          *(void *)uint64_t v122 = &unk_26E6DEB60;
          *(void *)&v122[8] = "schema";
          long long v124 = 0u;
          long long v125 = 0u;
          LODWORD(v126[0]) = 0;
          *(void *)((char *)v126 + 4) = 0x7FFFFFFFLL;
          char v37 = v109[12];
          if (v109[12])
          {
            BOOL v41 = *(_DWORD *)(v36 + 16) == 8 && strcmp(*(const char **)(v36 + 48), "SceneAsset") == 0;
            int v45 = !v41;
            *(void *)uint64_t v113 = &unk_26E714DC0;
            *(void *)&v113[8] = a1;
            *(void *)&v113[16] = 0;
            LODWORD(v114) = 0;
            uint64_t v115 = 0;
            uint64_t v116 = (*(uint64_t (**)(re *))(*(void *)a1 + 40))(a1);
            LOBYTE(v117) = 0;
            if (!buf[0])
            {
              id v56 = *re::assetsLogObjects(v46);
              if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
              {
                if (v96) {
                  uint64_t v86 = *(unsigned char **)&v97[7];
                }
                else {
                  uint64_t v86 = v97;
                }
                *(_DWORD *)long long v120 = 136315138;
                *(void *)&v120[4] = v86;
                _os_log_error_impl(&dword_233120000, v56, OS_LOG_TYPE_ERROR, "%s", v120, 0xCu);
              }
              re::DynamicString::DynamicString((re::DynamicString *)v120, (const re::DynamicString *)&v95);
              *(unsigned char *)a8 = 0;
              uint64_t v57 = v121;
              *(void *)(a8 + 8) = *(void *)v120;
              *(void *)(a8 + 32) = v57;
              *(_OWORD *)(a8 + 16) = *(_OWORD *)&v120[8];
              if (!buf[0] && v95 && (v96 & 1) != 0) {
                (*(void (**)(void))(*(void *)v95 + 40))();
              }
              if (v114)
              {
                (*(void (**)(void))(**(void **)&v113[8] + 24))(*(void *)&v113[8]);
                LODWORD(v114) = 0;
              }
              goto LABEL_121;
            }
            char v38 = v95;
            if (v114) {
              (*(void (**)(void, __n128))(**(void **)&v113[8] + 24))(*(void *)&v113[8], v47);
            }
          }
          else
          {
            char v38 = 0;
          }
          if (a4)
          {
            v92[0] = *(unsigned char *)a7;
            if (v92[0]) {
              uint64_t v93 = *(void *)(a7 + 8);
            }
            deserializeIntrospectedAssetWithVersioning((uint64_t)a1, a3, a2, v38, v36, a4, v34, (uint64_t)v92, a8);
            if (!*(unsigned char *)a8) {
              goto LABEL_121;
            }
          }
          else
          {
            *(void *)uint64_t v113 = &unk_26E6CA830;
            v90[0] = *(unsigned char *)a7;
            if (v90[0]) {
              uint64_t v91 = *(void *)(a7 + 8);
            }
            uint64_t v48 = (re *)deserializeIntrospectedAssetWithVersioning((uint64_t)a1, a3, a2, v38, v36, (uint64_t)v113, v34, (uint64_t)v90, a8);
            if (!*(unsigned char *)a8)
            {
              char v74 = *re::assetsLogObjects(v48);
              if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)long long buf = 0;
                _os_log_error_impl(&dword_233120000, v74, OS_LOG_TYPE_ERROR, "Failed to deserialize asset data", buf, 2u);
              }
              goto LABEL_121;
            }
          }
          uint64_t v49 = *(void *)(a8 + 8);
          if ((v37 & 2) != 0)
          {
            re::SeekableInputStreamSlice::SeekableInputStreamSlice((re::SeekableInputStreamSlice *)buf, a1, -1);
            if (v88)
            {
              uint64_t v119 = 0;
              uint64_t v116 = 0;
              uint64_t v117 = 0;
              uint64_t v115 = 0;
              int v118 = 0;
              *(void *)&v113[8] = 0;
              *(void *)&v113[16] = 0;
              *(void *)uint64_t v113 = a1;
              LODWORD(v114) = 0;
              BOOL v52 = re::SeekableInputStreamBufferedReader::readNext((re::SeekableInputStreamBufferedReader *)v113, 0xFFFFFFFFFFFFFFFFLL);
              BOOL v53 = v52;
              if (v52)
              {
                re::Data::makeDataWithBytes(*(re::Data **)&v113[8], *(const void **)&v113[16], v120);
                if (v120 != v88)
                {
                  uint64_t v54 = *(void *)v120;
                  *(void *)long long v120 = 0;
                  uint64_t v55 = *(void **)v88;
                  *(void *)uint64_t v88 = v54;
                }
              }
              else
              {
                int v75 = *re::assetsLogObjects((re *)v52);
                if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long v120 = 0;
                  _os_log_error_impl(&dword_233120000, v75, OS_LOG_TYPE_ERROR, "Error reading asset blob", v120, 2u);
                }
                uint64_t v76 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v35 + 16))(v35, v49);
                long long v77 = *(_OWORD *)v120;
                uint64_t v78 = *(void *)&v120[16];
                uint64_t v79 = v121;
                *(unsigned char *)a8 = 0;
                *(_OWORD *)(a8 + 8) = v77;
                *(void *)(a8 + 24) = v78;
                *(void *)(a8 + 32) = v79;
              }
              if (v114)
              {
                (*(void (**)(void))(**(void **)v113 + 24))(*(void *)v113);
                LODWORD(v114) = 0;
              }
              memset(v113, 0, sizeof(v113));
              if (v115 && v119) {
                (*(void (**)(void))(*(void *)v115 + 40))();
              }
              if (!v53) {
                goto LABEL_120;
              }
              goto LABEL_116;
            }
          }
          else
          {
            uint64_t v50 = (*(uint64_t (**)(re *))(*(void *)a1 + 40))(a1);
            double v51 = (re *)(*(uint64_t (**)(re *))(*(void *)a1 + 64))(a1);
            if ((re *)v50 != v51)
            {
              uint64_t v69 = *re::assetsLogObjects(v51);
              if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)uint64_t v113 = 0;
                _os_log_error_impl(&dword_233120000, v69, OS_LOG_TYPE_ERROR, "Extra data in file", v113, 2u);
              }
              uint64_t v70 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v35 + 16))(v35, v49);
              long long v71 = *(_OWORD *)v113;
              uint64_t v72 = *(void *)&v113[16];
              uint64_t v73 = v114;
              *(unsigned char *)a8 = 0;
              *(_OWORD *)(a8 + 8) = v71;
              *(void *)(a8 + 24) = v72;
              *(void *)(a8 + 32) = v73;
              goto LABEL_121;
            }
            re::SeekableInputStreamSlice::SeekableInputStreamSlice((re::SeekableInputStreamSlice *)buf, a1, -1);
            if (v88) {
              goto LABEL_116;
            }
          }
          if (*(unsigned char *)a7) {
            uint64_t v68 = *(void *)(a7 + 8);
          }
          else {
            uint64_t v68 = 0;
          }
          re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v120, 2056, v68, *a3);
          uint64_t v80 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, uint8_t *, uint64_t))(*(void *)v35 + 24))(v35, v49, buf, v87);
          if ((v80 & 1) == 0)
          {
            id v81 = *re::assetsLogObjects(v80);
            if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)uint64_t v113 = 0;
              _os_log_error_impl(&dword_233120000, v81, OS_LOG_TYPE_ERROR, "Failed to create runtime data", v113, 2u);
            }
            int v82 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v35 + 16))(v35, v49);
            long long v83 = *(_OWORD *)v113;
            uint64_t v84 = *(void *)&v113[16];
            uint64_t v85 = v114;
            *(unsigned char *)a8 = 0;
            *(_OWORD *)(a8 + 8) = v83;
            *(void *)(a8 + 24) = v84;
            *(void *)(a8 + 32) = v85;
            re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v120);
            goto LABEL_120;
          }
          re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v120);
LABEL_116:
          *(unsigned char *)a8 = 1;
          *(void *)(a8 + 8) = v49;
LABEL_120:
          re::SeekableInputStreamSlice::detach((re::SeekableInputStreamSlice *)buf);
LABEL_121:
          re::AutoFreeAllocator::~AutoFreeAllocator((re::AutoFreeAllocator *)v122);
          goto LABEL_122;
        }
        if (*(_DWORD *)&v109[4] == 2)
        {
          int v34 = 3;
          goto LABEL_27;
        }
        uint64_t v63 = *re::assetsLogObjects(v33);
        BOOL v64 = os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
        if (v64)
        {
          *(_DWORD *)uint64_t v122 = 67109120;
          *(_DWORD *)&v122[4] = v42;
          _os_log_error_impl(&dword_233120000, v63, OS_LOG_TYPE_ERROR, "Compiled file has an incompatible header version (got %d, expected a valid CompiledAssetHeaderVersion enum value).", v122, 8u);
        }
        long long v65 = *(_OWORD *)v122;
        uint64_t v66 = *(void *)&v122[16];
        __int16 v67 = v123;
        *(unsigned char *)a8 = 0;
        *(_OWORD *)(a8 + 8) = v65;
        *(void *)(a8 + 24) = v66;
        *(void *)(a8 + 32) = v67;
LABEL_122:
        if (v103) {
          goto LABEL_126;
        }
        goto LABEL_123;
      }
    }
    else
    {
      char v103 = 1;
      re::DynamicAssetHeader::DynamicAssetHeader(v31);
      int v102 = 0;
    }
    char v98 = 1;
    goto LABEL_26;
  }
  re::DynamicString::DynamicString((re::DynamicString *)v122, (const re::DynamicString *)v109);
  *(unsigned char *)a8 = 0;
  uint64_t v32 = v123;
  *(void *)(a8 + 8) = *(void *)v122;
  *(void *)(a8 + 32) = v32;
  *(_OWORD *)(a8 + 16) = *(_OWORD *)&v122[8];
LABEL_127:
  if (*(void *)v109)
  {
    if (v109[8]) {
      (*(void (**)(void))(**(void **)v109 + 40))();
    }
  }
}

uint64_t re::AssetUtilities::loadCompiledAssetFromData@<X0>(id *a1@<X0>, uint64_t *a2@<X1>, const char **a3@<X2>, uint64_t a4@<X3>, unsigned char *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  id v16 = *a1;
  re::DataSeekableInputStream::DataSeekableInputStream((uint64_t)v17, &v16, 1, 0);

  v14[0] = *(unsigned char *)a6;
  if (v14[0]) {
    uint64_t v15 = *(void *)(a6 + 8);
  }
  re::AssetUtilities::loadCompiledAssetFromStream((re *)v17, a2, a3, a4, a5, 0, (uint64_t)v14, a7);
  v17[0] = &unk_26E714530;

  v17[0] = &unk_26E7144B8;
  return re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)v18);
}

uint64_t re::AssetUtilities::loadLocalCompiledOrSourceAsset@<X0>(char *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v14 = *(const char **)(a3 + 8);
  re::DynamicString::insert((re::DynamicString *)&v59, 0, ".", 1uLL);
  unint64_t v15 = *((void *)a1 + 1);
  if (v15) {
    unint64_t v16 = v15 >> 1;
  }
  else {
    unint64_t v16 = v15 >> 1;
  }
  if (v60[0]) {
    uint64_t v17 = (const char *)v60[1];
  }
  else {
    uint64_t v17 = (char *)v60 + 1;
  }
  if (v60[0]) {
    uint64_t v18 = v60[0] >> 1;
  }
  else {
    uint64_t v18 = LOBYTE(v60[0]) >> 1;
  }
  re::DynamicString::rfind((uint64_t)a1, v17, v18, v16 - 1, (uint64_t)v57);
  if (v57[0])
  {
    uint64_t v19 = (v60[0] & 1) != 0 ? v60[0] >> 1 : LOBYTE(v60[0]) >> 1;
    if (v58 == v16 - v19)
    {
      if (*((void *)a1 + 1)) {
        long long v20 = (char *)*((void *)a1 + 2);
      }
      else {
        long long v20 = a1 + 9;
      }
      v55[0] = *(unsigned char *)a5;
      if (v55[0]) {
        uint64_t v56 = *(void *)(a5 + 8);
      }
      re::AssetUtilities::loadCompiledAssetFromPath(v20, (uint64_t *)a2, (const char **)a3, a4, v55, (uint64_t)&v70);
      if ((_BYTE)v70)
      {
        uint64_t v21 = *((void *)&v70 + 1);
        *(unsigned char *)a7 = 1;
        *(void *)(a7 + 8) = v21;
      }
      else
      {
        int v42 = (_anonymous_namespace_ *)re::WrappedError::localizedDescription((id *)&v70 + 1);
        long long v43 = v64;
        uint64_t v44 = v65;
        int v45 = v66;
        *(unsigned char *)a7 = 0;
        *(_OWORD *)(a7 + 8) = v43;
        *(void *)(a7 + 24) = v44;
        *(void *)(a7 + 32) = v45;
      }
      goto LABEL_63;
    }
  }
  uint64_t v54 = a4;
  if (*(unsigned char *)a5) {
    uint64_t v22 = *(void *)(a5 + 8);
  }
  else {
    uint64_t v22 = 0;
  }
  if (*((void *)a1 + 1)) {
    int v23 = (re::path *)*((void *)a1 + 2);
  }
  else {
    int v23 = (re::path *)(a1 + 9);
  }
  uint64_t v24 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)a2, a3);
  int v25 = *(const char **)a3;
  BOOL v27 = (_anonymous_namespace_ *)re::path::ext(v23, v26);
  if (*(unsigned char *)v27 != 46) {
    goto LABEL_36;
  }
  uint64_t v28 = (***(uint64_t (****)(void, uint64_t))(a2 + 8))(*(void *)(a2 + 8), (uint64_t)v27 + 1);
  (*(void (**)(long long *__return_ptr))(*(void *)v28 + 16))(&v64);
  uint64_t v29 = v65 & 1;
  if (v65) {
    int v30 = v66;
  }
  else {
    int v30 = (char *)&v65 + 1;
  }
  int v31 = strcmp(v25, v30);
  BOOL v27 = (_anonymous_namespace_ *)*((void *)&v64 + 1);
  if (*((void *)&v64 + 1) && v29) {
    BOOL v27 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**((void **)&v64 + 1) + 40))();
  }
  if (v31)
  {
LABEL_36:
    re::DynamicString::operator+((re::DynamicString *)&v70, (uint64_t)&v68, (re::DynamicString *)&v64);
    long long v33 = v64;
    long long v64 = 0uLL;
    uint64_t v34 = v65;
    uint64_t v35 = v66;
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    *(unsigned char *)a7 = 0;
    *(_OWORD *)(a7 + 8) = v33;
    *(void *)(a7 + 24) = v34;
    *(void *)(a7 + 32) = v35;
    if (v68 && (v69 & 1) != 0) {
      (*(void (**)(void))(*(void *)v68 + 40))();
    }
    if (void)v70 && (BYTE8(v70)) {
      (*(void (**)(void))(*(void *)v70 + 40))();
    }
    goto LABEL_63;
  }
  uint64_t v36 = v24;
  uint64_t v37 = v22;
  uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v36 + 176))(v36, a6);
  uint64_t v39 = (_anonymous_namespace_ *)(*(void *(**)(long long *__return_ptr, uint64_t, re::path *, uint64_t, uint64_t))(*(void *)v28 + 40))(&v64, v28, v23, v38, v54);
  if ((_BYTE)v64)
  {
    uint64_t v40 = *((void *)&v64 + 1);
    re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v61, 2056, v37, v25);
    BOOL v41 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, void, void))(*(void *)v36 + 24))(v36, v40, 0, 0);
    if ((v41 & 1) == 0)
    {
      re::DynamicString::operator+((re::DynamicString *)&v68, (uint64_t)&v62, (re::DynamicString *)&v70);
      long long v50 = v70;
      long long v70 = 0uLL;
      uint64_t v51 = v71;
      uint64_t v52 = v72;
      uint64_t v71 = 0;
      uint64_t v72 = 0;
      *(unsigned char *)a7 = 0;
      *(_OWORD *)(a7 + 8) = v50;
      *(void *)(a7 + 24) = v51;
      *(void *)(a7 + 32) = v52;
      if (v62 && (v63 & 1) != 0) {
        (*(void (**)(void))(*(void *)v62 + 40))();
      }
      if (v68 && (v69 & 1) != 0) {
        (*(void (**)(void))(*(void *)v68 + 40))();
      }
      re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v61);
      goto LABEL_60;
    }
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v61);
    *(unsigned char *)a7 = 1;
    *(void *)(a7 + 8) = v40;
  }
  else
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v62, (const re::DynamicString *)&v66);
    re::DynamicString::operator+((re::DynamicString *)&v68, (uint64_t)&v62, (re::DynamicString *)&v70);
    long long v46 = v70;
    long long v70 = 0uLL;
    uint64_t v47 = v71;
    uint64_t v48 = v72;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    *(unsigned char *)a7 = 0;
    *(_OWORD *)(a7 + 8) = v46;
    *(void *)(a7 + 24) = v47;
    *(void *)(a7 + 32) = v48;
    if (v62 && (v63 & 1) != 0) {
      (*(void (**)(void))(*(void *)v62 + 40))();
    }
    if (v68 && (v69 & 1) != 0) {
      (*(void (**)(void))(*(void *)v68 + 40))();
    }
  }
  uint64_t v40 = 0;
LABEL_60:
  if (!(_BYTE)v64 && v66 && (v67 & 1) != 0) {
    (*(void (**)(void))(*(void *)v66 + 40))();
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v28 + 56))(v28, v38);
  if (v40) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v36 + 16))(v36, v40);
  }
LABEL_63:
  uint64_t result = v59;
  if (v59)
  {
    if (v60[0]) {
      return (*(uint64_t (**)(void))(*(void *)v59 + 40))();
    }
  }
  return result;
}

uint64_t re::AssetUtilities::readSourceJson@<X0>(re::AssetUtilities *this@<X0>, const char *a2@<X1>, uint64_t a3@<X2>, const re::IntrospectionBase *a4@<X3>, uint64_t a5@<X8>)
{
  re::FileStreamReader::open(this, (uint64_t)v29);
  if (v29[0])
  {
    v28[1] = 0;
    _OWORD v28[2] = 0;
    v28[0] = a4;
    if ((_BYTE)v23)
    {
      *(unsigned char *)a5 = 1;
    }
    else
    {
      if (v26) {
        unint64_t v15 = *(unsigned char **)&v27[7];
      }
      else {
        unint64_t v15 = v27;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to read JSON source asset \"%s\": %s", (re::DynamicString *)&v20, this, v15);
      long long v16 = v20;
      uint64_t v17 = v21;
      uint64_t v18 = v22;
      *(unsigned char *)a5 = 0;
      *(_OWORD *)(a5 + 8) = v16;
      *(void *)(a5 + 24) = v17;
      *(void *)(a5 + 32) = v18;
      if (!(_BYTE)v23 && v25 && (v26 & 1) != 0) {
        (*(void (**)(void))(*(void *)v25 + 40))();
      }
    }
  }
  else
  {
    re::formattedErrorMessage<re::DetailedError>((uint64_t)v30, (re::DynamicString *)&v23);
    long long v12 = v23;
    uint64_t v13 = v24;
    uint64_t v14 = v25;
    *(unsigned char *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v12;
    *(void *)(a5 + 24) = v13;
    *(void *)(a5 + 32) = v14;
  }
  return re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v29);
}

size_t re::AssetUtilities::estimateSize_introspectionLockedShared(re::AssetUtilities *this, re::TypeInfo *a2, const re::TypeInfo *a3)
{
  if (!this) {
    return 0;
  }
  unint64_t v4 = this;
  if (a3) {
    size_t v5 = *(unsigned int *)(*((void *)a2 + 2) + 8);
  }
  else {
    size_t v5 = 0;
  }
  if (*((unsigned char *)a2 + 12) == 8)
  {
    unint64_t v6 = re::TypeInfo::name(a2);
    if ((unint64_t)*v6 >> 1 == 94623636)
    {
      uint64_t v7 = (char *)v6[1];
      if (v7 == "char*" || !strcmp(v7, "char*"))
      {
        long long v12 = *(const char **)v4;
        goto LABEL_19;
      }
    }
    uint64_t v8 = re::TypeInfo::name(a2);
    if ((unint64_t)*v8 >> 1 == 0x134375A94D9F7110)
    {
      uint64_t v9 = (char *)v8[1];
      if (v9 == "DynamicString" || !strcmp(v9, "DynamicString"))
      {
        unint64_t v14 = *((void *)v4 + 1);
        if (v14) {
          unint64_t v15 = v14 >> 1;
        }
        else {
          unint64_t v15 = v14 >> 1;
        }
        size_t v13 = v5 + v15;
        goto LABEL_24;
      }
    }
    unsigned int v10 = re::TypeInfo::name(a2);
    if ((unint64_t)*v10 >> 1 == 0x22C6ED80D0CLL)
    {
      uint64_t v11 = (char *)v10[1];
      if (v11 == "StringID" || !strcmp(v11, "StringID")) && (*(unsigned char *)v4)
      {
        long long v12 = (const char *)*((void *)v4 + 1);
LABEL_19:
        size_t v13 = v5 + strlen(v12);
LABEL_24:
        size_t v5 = v13 + 1;
      }
    }
  }
  long long v16 = (void *)*((void *)a2 + 2);
  if ((v16[6] & 2) == 0)
  {
    switch(*((unsigned char *)a2 + 12))
    {
      case 1:
      case 2:
        return v5;
      case 3:
        re::TypeInfo::TypeInfo((uint64_t)&v54, (uint64_t)a2);
        uint64_t v17 = (*(uint64_t (**)(re::AssetUtilities *))(v56 + 80))(v4);
        if (!v17) {
          return v5;
        }
        unint64_t v4 = (re::AssetUtilities *)v17;
        re::TypeRegistry::typeInfo(v54, *(void *)(v56 + 72), v59);
        re::TypeInfo::TypeInfo((uint64_t)&v51, (uint64_t)v59 + 8);
        uint64_t v19 = (char *)&v51;
        goto LABEL_54;
      case 4:
        re::TypeInfo::TypeInfo((uint64_t)&v54, (uint64_t)a2);
        re::TypeRegistry::typeInfo(v54, *(void *)(v56 + 72), v59);
        re::TypeInfo::TypeInfo((uint64_t)&v51, (uint64_t)v59 + 8);
        uint64_t v20 = re::ArrayAccessor::size((re::ArrayAccessor *)&v54, (char *)v4);
        uint64_t v21 = v20;
        if ((*(_DWORD *)(v56 + 84) & 0xFFFFFF) != 0) {
          v5 += v20 * *(unsigned int *)(v52 + 8);
        }
        if ((*(unsigned char *)(v52 + 48) & 2) == 0 && v20)
        {
          unint64_t v22 = 0;
          do
          {
            long long v23 = (re::AssetUtilities *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v54, (char *)v4, v22);
            v5 += re::AssetUtilities::estimateSize_introspectionLockedShared(v23, &v51, 0, v24);
            ++v22;
          }
          while (v21 != v22);
        }
        return v5;
      case 5:
        re::TypeInfo::TypeInfo((uint64_t)&v54, (uint64_t)a2);
        re::TypeRegistry::typeInfo(v54, *(void *)(v56 + 72), v59);
        re::TypeInfo::TypeInfo((uint64_t)&v51, (uint64_t)v59 + 8);
        uint64_t v25 = (_anonymous_namespace_ *)(*(uint64_t (**)(re::AssetUtilities *))(v56 + 80))(v4);
        v5 += (void)v25 * *(unsigned int *)(v52 + 8);
        if ((*(unsigned char *)(v52 + 48) & 2) == 0)
        {
          if (*(void *)(v56 + 96))
          {
            char v26 = v25;
            if (v25)
            {
              BOOL v27 = 0;
              do
              {
                uint64_t v28 = (re::AssetUtilities *)(*(uint64_t (**)(re::AssetUtilities *, _anonymous_namespace_ *))(v56 + 96))(v4, v27);
                v5 += re::AssetUtilities::estimateSize_introspectionLockedShared(v28, &v51, 0, v29);
                BOOL v27 = (_anonymous_namespace_ *)((char *)v27 + 1);
              }
              while (v26 != v27);
            }
          }
          else if (*(void *)(v56 + 104) && *(void *)(v56 + 112) && *(void *)(v56 + 120))
          {
            for (unint64_t i = *(uint64_t (**)(void))(v56 + 112); ; unint64_t i = *(uint64_t (**)(void))(v56 + 112))
            {
              uint64_t v48 = (re::AssetUtilities *)i();
              if (!v48) {
                break;
              }
              v5 += re::AssetUtilities::estimateSize_introspectionLockedShared(v48, &v51, 0, v49);
            }
          }
        }
        return v5;
      case 6:
        re::TypeInfo::TypeInfo((uint64_t)&v54, (uint64_t)a2);
        re::TypeRegistry::typeInfo(v54, *(void *)(v56 + 72), v59);
        re::TypeInfo::TypeInfo((uint64_t)&v51, (uint64_t)v59 + 8);
        re::TypeRegistry::typeInfo(v54, *(void *)(v56 + 80), v59);
        re::TypeInfo::TypeInfo((uint64_t)v57, (uint64_t)v59 + 8);
        int v30 = (_anonymous_namespace_ *)(*(uint64_t (**)(re::AssetUtilities *))(v56 + 88))(v4);
        v5 += (*(unsigned int *)(v58 + 8) + (unint64_t)*(unsigned int *)(v52 + 8)) * (void)v30;
        int v31 = *(_DWORD *)(v52 + 48);
        int v32 = *(_DWORD *)(v58 + 48);
        if ((v31 & 2) == 0 || (v32 & 2) == 0)
        {
          if ((*(unsigned int (**)(void))(v56 + 120))())
          {
            do
            {
              if ((v31 & 2) == 0)
              {
                uint64_t v34 = (re::AssetUtilities *)(*(uint64_t (**)(uint64_t))(v56 + 128))(v33);
                v5 += re::AssetUtilities::estimateSize_introspectionLockedShared(v34, &v51, 0, v35);
              }
              if ((v32 & 2) == 0)
              {
                uint64_t v36 = (re::AssetUtilities *)(*(uint64_t (**)(uint64_t))(v56 + 136))(v33);
                v5 += re::AssetUtilities::estimateSize_introspectionLockedShared(v36, v57, 0, v37);
              }
            }
            while (((*(uint64_t (**)(uint64_t))(v56 + 120))(v33) & 1) != 0);
          }
        }
        return v5;
      case 7:
        re::TypeInfo::TypeInfo((uint64_t)&v54, (uint64_t)a2);
        re::UnionAccessor::activeMemberType((re::UnionAccessor *)&v54, (char *)v4, v59);
        if (!LOBYTE(v59[0])) {
          return v5;
        }
        uint64_t v19 = (char *)v59 + 8;
LABEL_54:
        uint64_t v38 = v4;
        uint64_t v39 = 0;
        break;
      case 8:
        re::TypeRegistry::typeInfo(*(void **)a2, v16[9], &v54);
        if ((_BYTE)v54) {
          v5 += re::AssetUtilities::estimateSize_introspectionLockedShared(v4, &v55, 0, v40);
        }
        re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v51, *(void *)a2, *((void *)a2 + 2));
        uint64_t v41 = v53;
        if (v53)
        {
          unint64_t v42 = 0;
          do
          {
            re::TypeMemberCollection::operator[]((uint64_t *)&v51, v42, (uint64_t)v57);
            re::TypeRegistry::typeInfo(v57[0], *(void *)v58, v59);
            re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)v59 + 8);
            v5 += re::AssetUtilities::estimateSize_introspectionLockedShared((re::AssetUtilities *)((char *)v4 + *(unsigned int *)(v58 + 24)), v50, 0, v43);
            ++v42;
          }
          while (v41 != v42);
        }
        return v5;
      case 9:
        uint64_t v44 = *(char **)v4;
        if (!*(void *)v4) {
          return v5;
        }
        re::TypeRegistry::typeInfo(*(void **)a2, v16[9], v59);
        re::TypeInfo::TypeInfo((uint64_t)&v54, (uint64_t)v59 + 8);
        if (re::TypeInfo::isPointerToPolymorphicType(a2))
        {
          re::TypeInfo::getActualTypeFromPointer((uint64_t)a2, (char *)v4, &v51);
          if ((void)v51
            || (re::TypeInfo::getActualType((re::TypeInfo *)&v54, v44, v59), long long v51 = v59[0], *(void *)&v59[0]))
          {
            re::TypeRegistry::typeInfo(*(re **)a2, (re **)&v51, v59);
            re::TypeInfo::operator=((uint64_t)&v54, (uint64_t)v59 + 8);
          }
        }
        uint64_t v19 = (char *)&v54;
        uint64_t v38 = (re::AssetUtilities *)v44;
        uint64_t v39 = 1;
        break;
      default:
        re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Unexpected type category.", "!\"Unreachable code\"", "estimateSize_introspectionLockedShared", 1403);
        _os_crash();
        __break(1u);
        JUMPOUT(0x2333D7CF0);
    }
    v5 += re::AssetUtilities::estimateSize_introspectionLockedShared(v38, v19, (const re::TypeInfo *)v39, v18);
  }
  return v5;
}

size_t re::AssetUtilities::computeIntrospectedDataSizeV2(re::AssetUtilities *this, re **a2, const re::IntrospectionBase *a3)
{
  re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v13);
  if (v11[0])
  {
    size_t locked = re::AssetUtilities::estimateSize_introspectionLockedShared(this, (re::TypeInfo *)&v12, (const re::TypeInfo *)1);
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v13);
    return locked;
  }
  else
  {
    re::getPrettyTypeName((re *)a2, (const re::IntrospectionBase *)v9);
    re::DynamicString::~DynamicString((re::DynamicString *)v9);
    re::getPrettyTypeName((re *)a2, (const re::IntrospectionBase *)v9);
    if (v9[8]) {
      uint64_t v8 = *(unsigned char **)&v10[7];
    }
    else {
      uint64_t v8 = v10;
    }
    re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Type info (\"%s\") is missing.", "type", "computeIntrospectedDataSizeV2", 1419, v8);
    re::DynamicString::~DynamicString((re::DynamicString *)v9);
    size_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t deserializeIntrospectedAssetWithVersioning(re::SeekableInputStream &,re::AssetType const&,re::AssetLoadData const&,re::PersistedSchema const*,re::IntrospectionBase const&,re::AssetSerializationScheme &,re::AssetSerializationFormat,re::Optional<unsigned long long>)::$_0::__invoke(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 16) != 8) {
    return 0;
  }
  uint64_t v2 = *(const char **)(a1 + 48);
  if (strlen(v2) < 0x10 || strncmp(v2, "CustomComponent", 0xFuLL))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 56);
    if (v3)
    {
      for (unint64_t i = *(void **)(a1 + 64); ; ++i)
      {
        size_t v5 = (_DWORD *)*i;
        if (*(_DWORD *)*i == 1 && v5[10] == 3) {
          break;
        }
        if (!--v3) {
          return 0;
        }
      }
      uint64_t v7 = *((void *)v5 + 2);
      if (v7)
      {
        while (*(_DWORD *)(v7 + 16) == 8)
        {
          if (!strcmp(*(const char **)(v7 + 48), "Component")) {
            return 1;
          }
          uint64_t v8 = *(unsigned int *)(v7 + 56);
          if (!v8) {
            break;
          }
          for (unint64_t j = *(void **)(v7 + 64); ; ++j)
          {
            unsigned int v10 = (_DWORD *)*j;
            if (*(_DWORD *)*j == 1 && v10[10] == 3) {
              break;
            }
            if (!--v8) {
              return 0;
            }
          }
          uint64_t result = 0;
          uint64_t v7 = *((void *)v10 + 2);
          if (!v7) {
            return result;
          }
        }
      }
    }
    return 0;
  }
  return 1;
}

void re::DynamicAssetHeader::DynamicAssetHeader(re::DynamicAssetHeader *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76BE0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76BE0))
  {
    qword_26AF76BD8 = re::internal::getOrCreateInfo((re::internal *)"DynamicAssetHeader", (uint64_t (*)(re::internal *))re::allocInfo_DynamicAssetHeader, (re::IntrospectionBase *(*)(void))re::initInfo_DynamicAssetHeader, (void (*)(re::IntrospectionBase *))&unk_26AF76BB8, 0);
    __cxa_guard_release(&qword_26AF76BE0);
  }
  qword_26AF76BC0 = qword_26AF76BD8;
}

uint64_t re::Result<re::FileStreamWriter,re::DetailedError>::~Result(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(FILE **)(a1 + 16);
    if (v2 && *(unsigned char *)(a1 + 24))
    {
      fclose(v2);
      *(void *)(a1 + 16) = 0;
      *(unsigned char *)(a1 + 24) = 0;
    }
  }
  else
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

uint64_t re::Result<re::FileStreamReader,re::DetailedError>::~Result(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(FILE **)(a1 + 16);
    if (v2 && *(unsigned char *)(a1 + 32))
    {
      fclose(v2);
      *(void *)(a1 + 16) = 0;
      *(unsigned char *)(a1 + 32) = 0;
    }
  }
  else
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

uint64_t re::RealityArchiveEntryTable::RealityArchiveEntryTable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)a1 = &unk_26E6CD7A8;
  signed int v6 = *(_DWORD *)(a3 + 184);
  *(_OWORD *)(a1 + 24) = 0u;
  uint64_t v7 = a1 + 24;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 60) = 0x7FFFFFFFLL;
  uint64_t v23 = a1;
  *(void *)(a1 + 72) = a2;
  uint64_t v26 = 0;
  unint64_t v9 = *(void *)(a3 + 184);
  if (v9)
  {
    for (i = 0; i < v9; uint64_t v26 = ++i)
    {
      unint64_t v11 = *(void *)(a3 + 176) + i;
      uint64_t v12 = *(void *)(*(void *)(a3 + 152) + 8 * (v11 / 0x27));
      unint64_t v13 = v11 % 0x27;
      uint64_t v14 = v12 + 104 * v13;
      unint64_t v15 = (const char *)(v14 + 8);
      char v16 = *(unsigned char *)(v14 + 31);
      if (v16 < 0)
      {
        uint64_t v18 = *(void *)(v12 + 104 * v13 + 16);
        if (!v18)
        {
          if (!zip_entry_is_alignment(v14)) {
            goto LABEL_15;
          }
          continue;
        }
        uint64_t v17 = *(const char **)v15;
      }
      else
      {
        if (!*(unsigned char *)(v14 + 31))
        {
          if (!zip_entry_is_alignment(v12 + 104 * v13)) {
            goto LABEL_16;
          }
          continue;
        }
        uint64_t v17 = (const char *)(v14 + 8);
        uint64_t v18 = *(unsigned __int8 *)(v14 + 31);
      }
      if (v17[v18 - 1] != 47 && !zip_entry_is_alignment(v14))
      {
        if (v16 < 0) {
LABEL_15:
        }
          unint64_t v15 = *(const char **)v15;
LABEL_16:
        if (isDoubleCompressed)
        {
          uint64_t v20 = (_anonymous_namespace_ *)strlen(v15);
          size_t v21 = (size_t)v20 - 4;
        }
        else
        {
        }
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>(v7, (re::DynamicString *)&v24, &v26);
        if (v24 && (v25 & 1) != 0) {
          (*(void (**)(void))(*(void *)v24 + 40))();
        }
        unint64_t i = v26;
      }
    }
  }
  return v23;
}

unint64_t re::RealityArchiveEntryTable::findEntry(_anonymous_namespace_ *a1, char *a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t)a1 + 24;
  signed int v6 = (void *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v5, (uint64_t)&v12);
  if (v12 && (v13 & 1) != 0) {
    (*(void (**)(void))(*(void *)v12 + 40))();
  }
  if (v6) {
    return *(void *)(*(void *)(a3 + 152) + 8 * ((*(void *)(a3 + 176) + *v6) / 0x27uLL))
  }
         + 104 * ((*(void *)(a3 + 176) + *v6) % 0x27uLL);
  re::filePathURLConverted((re *)a2, (re::DynamicString *)&v12);
  if (v13) {
    uint64_t v8 = *(const char **)&v14[7];
  }
  else {
    uint64_t v8 = v14;
  }
  signed int v6 = (void *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v5, (uint64_t)&v10);
  if (v10 && (v11 & 1) != 0) {
    (*(void (**)(void))(*(void *)v10 + 40))();
  }
  if (v12)
  {
    if (v13) {
      (*(void (**)(void))(*(void *)v12 + 40))();
    }
  }
  if (v6) {
    return *(void *)(*(void *)(a3 + 152) + 8 * ((*(void *)(a3 + 176) + *v6) / 0x27uLL))
  }
         + 104 * ((*(void *)(a3 + 176) + *v6) % 0x27uLL);
  else {
    return 0;
  }
}

void re::RealityArchive::~RealityArchive(re::RealityArchive *this)
{
  *(void *)this = &unk_26E6CD7D8;
  zip_close(*((void **)this + 3));
  *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  uint64_t v2 = (FILE *)*((void *)this + 10);
  if (v2) {
    fclose(v2);
  }

  re::DynamicString::deinit((re::RealityArchive *)((char *)this + 40));
  uint64_t v3 = *((void *)this + 4);
  if (v3)
  {

    *((void *)this + 4) = 0;
  }
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::RealityArchive::~RealityArchive(this);
  JUMPOUT(0x237DBCBD0);
}

id re::RealityArchive::createOrReuseTable@<X0>(re *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (a3 && *(re **)(a3 + 72) == a1)
  {
    *a4 = a3;
    return (id)(a3 + 8);
  }
  else
  {
    uint64_t v8 = re::globalAllocators(a1);
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 80, 8);
    id result = (id)re::RealityArchiveEntryTable::RealityArchiveEntryTable(v9, (uint64_t)a1, a2);
    *a4 = result;
  }
  return result;
}

__n128 re::RealityArchive::makeByOpeningFileAtPath@<Q0>(re::RealityArchive *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  *__error() = 0;
  uint64_t v7 = fopen((const char *)this, "rb");
  if (!v7)
  {
    uint64_t v17 = __error();
    uint64_t v20 = strerror(*v17);
    re::DynamicString::format((re::DynamicString *)"RERealityArchive: Failed to open FILE pointer due to error: %s", (re::DynamicString *)&v22, v20);
LABEL_12:
    __n128 result = v22;
    uint64_t v18 = v23;
    uint64_t v19 = v24;
    *(unsigned char *)a3 = 0;
    *(__n128 *)(a3 + 8) = result;
    *(void *)(a3 + 24) = v18;
    *(void *)(a3 + 32) = v19;
    return result;
  }
  uint64_t v8 = v7;
  uint64_t v9 = zip_file_read(v7);
  if (!v9)
  {
    fclose(v8);
    re::DynamicString::format((re::DynamicString *)"RERealityArchive: Failed to open archive, file corrupted or not a proper archive file", (re::DynamicString *)&v22);
    goto LABEL_12;
  }
  uint64_t v10 = v9;
  char v11 = (re *)strlen((const char *)this);
  if (v11)
  {
    MurmurHash3_x64_128((uint64_t)this, (int)v11, 0, v22.n128_u64);
    char v11 = (re *)((v22.n128_u64[1] + (v22.n128_u64[0] << 6) + (v22.n128_u64[0] >> 2) - 0x61C8864680B583E9) ^ v22.n128_u64[0]);
  }
  uint64_t v12 = (re *)re::RealityArchive::createOrReuseTable(v11, v10, (uint64_t)a2, &v21);
  char v13 = re::globalAllocators(v12);
  uint64_t v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v13[2] + 32))(v13[2], 88, 8);
  uint64_t v15 = v21;
  re::RealityArchive::RealityArchive((uint64_t)v14, v10, v21);
  v14[10] = v8;
  re::DynamicString::operator=((re::DynamicString *)(v14 + 5), (re::DynamicString *)&v22);
  *(unsigned char *)a3 = 1;
  *(void *)(a3 + 8) = v14;
  if (v22.n128_u64[0] && (v22.n128_u8[8] & 1) != 0) {
    (*(void (**)(void))(*(void *)v22.n128_u64[0] + 40))();
  }
  if (v15) {

  }
  return result;
}

__n128 re::RealityArchive::makeFromFile@<Q0>(FILE *this@<X0>, __sFILE *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = zip_file_read(this);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = (re *)re::RealityArchive::createOrReuseTable((re *)this, v7, (uint64_t)a2, &v17);
    uint64_t v10 = re::globalAllocators(v9);
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10[2] + 32))(v10[2], 88, 8);
    unint64_t v12 = v17.n128_u64[0];
    uint64_t v13 = re::RealityArchive::RealityArchive(v11, v8, v17.n128_i64[0]);
    *(unsigned char *)a3 = 1;
    *(void *)(a3 + 8) = v13;
    if (v12) {
  }
    }
  else
  {
    re::DynamicString::format((re::DynamicString *)"RERealityArchive: Failed to create archive", (re::DynamicString *)&v17);
    __n128 result = v17;
    uint64_t v15 = v18;
    uint64_t v16 = v19;
    *(unsigned char *)a3 = 0;
    *(__n128 *)(a3 + 8) = result;
    *(void *)(a3 + 24) = v15;
    *(void *)(a3 + 32) = v16;
  }
  return result;
}

__n128 re::RealityArchive::makeByReadingBuffer@<Q0>(id *this@<X0>, const re::Data *a2@<X1>, uint64_t a3@<X8>)
{
  *__error() = 0;
  uint64_t v7 = fmemopen((void *)[*this bytes], objc_msgSend(*this, "length"), "rb");
  if (!v7)
  {
    __n128 v17 = __error();
    uint64_t v20 = strerror(*v17);
    re::DynamicString::format((re::DynamicString *)"Failed to open FILE pointer due to error: %s", (re::DynamicString *)&v21, v20);
LABEL_7:
    __n128 result = v21;
    uint64_t v18 = v22;
    uint64_t v19 = v23;
    *(unsigned char *)a3 = 0;
    *(__n128 *)(a3 + 8) = result;
    *(void *)(a3 + 24) = v18;
    *(void *)(a3 + 32) = v19;
    return result;
  }
  uint64_t v8 = v7;
  uint64_t v9 = zip_file_read(v7);
  if (!v9)
  {
    fclose(v8);
    re::DynamicString::format((re::DynamicString *)"RERealityArchive: Failed to create archive", (re::DynamicString *)&v21);
    goto LABEL_7;
  }
  uint64_t v10 = v9;
  uint64_t v11 = (re *)re::RealityArchive::createOrReuseTable((re *)[*this bytes], v9, (uint64_t)a2, &v21);
  unint64_t v12 = re::globalAllocators(v11);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12[2] + 32))(v12[2], 88, 8);
  unint64_t v14 = v21.n128_u64[0];
  uint64_t v15 = re::RealityArchive::RealityArchive(v13, v10, v21.n128_i64[0]);
  *(void *)(v15 + 80) = v8;
  re::ObjCObject::operator=((id *)(v15 + 72), this);
  *(unsigned char *)a3 = 1;
  *(void *)(a3 + 8) = v13;
  if (v14) {

  }
  return result;
}

__n128 re::RealityArchive::verifyRealityArchiveAtFilePath@<Q0>(re::RealityArchive *this@<X0>, uint64_t a2@<X8>)
{
  *__error() = 0;
  uint64_t v5 = fopen((const char *)this, "rb");
  if (v5)
  {
    signed int v6 = v5;
    uint64_t v7 = (void *)zip_file_read(v5);
    if (v7)
    {
      uint64_t v8 = v7;
      BOOL v9 = zip_verify_crc_archive(v7);
      zip_close(v8);
      fclose(v6);
      *(unsigned char *)a2 = 1;
      *(unsigned char *)(a2 + 8) = v9;
      return result;
    }
    fclose(v6);
    re::DynamicString::format((re::DynamicString *)"RERealityArchive: Failed to create archive from provided file path: %s", (re::DynamicString *)&v15, this);
  }
  else
  {
    uint64_t v11 = __error();
    unint64_t v14 = strerror(*v11);
    re::DynamicString::format((re::DynamicString *)"Failed to open FILE pointer due to error: %s", (re::DynamicString *)&v15, v14);
  }
  __n128 result = v15;
  uint64_t v12 = v16;
  uint64_t v13 = v17;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v12;
  *(void *)(a2 + 32) = v13;
  return result;
}

__n128 re::RealityArchive::copy@<Q0>(re::RealityArchive *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = *((void *)this + 6);
  if (v4) {
    unint64_t v5 = v4 >> 1;
  }
  else {
    unint64_t v5 = v4 >> 1;
  }
  if (v5)
  {
    *__error() = 0;
    if (*((unsigned char *)this + 48)) {
      signed int v6 = (const char *)*((void *)this + 7);
    }
    else {
      signed int v6 = (char *)this + 49;
    }
    uint64_t v7 = fopen(v6, "rb");
  }
  else
  {
    if (!*((void *)this + 9))
    {
      goto LABEL_15;
    }
    *__error() = 0;
    uint64_t v7 = fmemopen((void *)[*((id *)this + 9) bytes], objc_msgSend(*((id *)this + 9), "length"), "rb");
  }
  if (v7) {
    zip_copy_with_read_handle();
  }
  uint64_t v8 = __error();
  uint64_t v12 = strerror(*v8);
  re::DynamicString::format((re::DynamicString *)"Failed to open FILE pointer due to error: %s", (re::DynamicString *)&v13, v12);
LABEL_15:
  __n128 result = v13;
  uint64_t v10 = v14;
  uint64_t v11 = v15;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v10;
  *(void *)(a2 + 32) = v11;
  return result;
}

void *re::RealityArchive::entryNames@<X0>(re::RealityArchive *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v4 = *(unsigned int *)(*((void *)this + 4) + 52);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  __n128 result = re::DynamicArray<re::DynamicString>::setCapacity((void *)a2, v4);
  ++*(_DWORD *)(a2 + 24);
  uint64_t v6 = *((void *)this + 4);
  uint64_t v7 = *(unsigned int *)(v6 + 56);
  if (v7)
  {
    uint64_t v8 = 0;
    BOOL v9 = (int *)(*(void *)(v6 + 40) + 8);
    while (1)
    {
      int v10 = *v9;
      v9 += 14;
      if (v10 < 0) {
        break;
      }
      if (v7 == ++v8)
      {
        LODWORD(v8) = *(_DWORD *)(v6 + 56);
        break;
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  if (v7 != v8)
  {
    uint64_t v11 = v8;
    do
    {
      __n128 result = re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)a2, (re::DynamicString *)(*(void *)(v6 + 40) + 56 * v11 + 16));
      if (*(_DWORD *)(v6 + 56) <= (v8 + 1)) {
        int v12 = v8 + 1;
      }
      else {
        int v12 = *(_DWORD *)(v6 + 56);
      }
      int v13 = v8;
      while (1)
      {
        uint64_t v11 = (v13 + 1);
        if (v12 - 1 == v13) {
          break;
        }
        ++v13;
        LODWORD(v8) = v11;
        if ((*(_DWORD *)(*(void *)(v6 + 40) + 56 * v11 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v8) = v12;
LABEL_17:
      ;
    }
    while (v7 != v8);
  }
  return result;
}

__n128 re::RealityArchive::newDataByLoadingEntryWithName@<Q0>(re::RealityArchive *this@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (re::RealityArchiveEntryTable::findEntry(*((_anonymous_namespace_ **)this + 4), a2, *((void *)this + 3))) {
    reality_v1_entry_load_data_begin();
  }
  re::DynamicString::format((re::DynamicString *)"Could not find archive entry named %s.", (re::DynamicString *)v7, a2);
  __n128 result = (__n128)v7[0];
  long long v6 = v7[1];
  *(unsigned char *)a3 = 0;
  *(__n128 *)(a3 + 8) = result;
  *(_OWORD *)(a3 + 24) = v6;
  return result;
}

uint64_t re::RealityArchive::uncompressedEntryRange(re::RealityArchive *this, char *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t Entry = re::RealityArchiveEntryTable::findEntry(*((_anonymous_namespace_ **)this + 4), a2, *((void *)this + 3));
  if (Entry
    && *(void *)(v7 + 40) == *(void *)(v7 + 48))
  {
    *a3 = zip_entry_data_offset((void **)v7);
    unint64_t v8 = *(void *)(v7 + 48);
    uint64_t result = 1;
  }
  else
  {
    unint64_t v8 = 0;
    uint64_t result = 0;
    *a3 = 0;
  }
  *a4 = v8;
  return result;
}

uint64_t *re::RealityArchive::unarchiveToDirectory@<X0>(re::RealityArchive *this@<X0>, re *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = this;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  re::DynamicString::setCapacity(&v45, 0);
  BOOL v7 = re::ensureFolderExists(a2, v6);
  if (!v7)
  {
    re::DynamicString::format((re::DynamicString *)"Failed to create directory %s.", (re::DynamicString *)v42, a2);
    long long v32 = *(_OWORD *)v42;
    uint64_t v33 = *(void *)&v42[16];
    uint64_t v34 = v43;
    *(unsigned char *)a3 = 0;
    *(_OWORD *)(a3 + 8) = v32;
    *(void *)(a3 + 24) = v33;
    *(void *)(a3 + 32) = v34;
    goto LABEL_48;
  }
  uint64_t v39 = *(void *)(*((void *)v4 + 3) + 184);
  if (!v39)
  {
    goto LABEL_47;
  }
  uint64_t v36 = a3;
  BOOL v37 = v4;
  uint64_t v9 = 0;
  char v10 = 1;
  uint64_t v38 = (const char *)a2;
  do
  {
    uint64_t v11 = *((void *)v4 + 3);
    unint64_t v12 = *(void *)(v11 + 176) + v9;
    uint64_t v13 = *(void *)(*(void *)(v11 + 152) + 8 * (v12 / 0x27));
    unint64_t v14 = v12 % 0x27;
    uint64_t v15 = v13 + 104 * (v12 % 0x27);
    std::string::basic_string[abi:nn180100]<0>(&v44, (char *)a2);
    std::string::append(&v44, "/");
    uint64_t v16 = (const std::string::value_type **)(v15 + 8);
    uint64_t v17 = (const std::string::value_type *)(v15 + 8);
    if (*(char *)(v15 + 31) < 0) {
      uint64_t v17 = *v16;
    }
    std::string::append(&v44, v17);
    if (*(char *)(v15 + 31) < 0)
    {
      uint64_t v20 = *(void *)(v13 + 104 * v14 + 16);
      if (!v20)
      {
LABEL_16:
        if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v22 = &v44;
        }
        else {
          uint64_t v22 = (std::string *)v44.__r_.__value_.__r.__words[0];
        }
        goto LABEL_19;
      }
      uint64_t v19 = *v16;
    }
    else
    {
      uint64_t v19 = (const std::string::value_type *)(v15 + 8);
      uint64_t v20 = *(unsigned __int8 *)(v15 + 31);
      if (!*(unsigned char *)(v15 + 31)) {
        goto LABEL_16;
      }
    }
    int v21 = v19[v20 - 1];
    if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v22 = &v44;
    }
    else {
      uint64_t v22 = (std::string *)v44.__r_.__value_.__r.__words[0];
    }
    if (v21 == 47)
    {
      re::ensureFolderExists((re *)v22, v18);
      int v23 = 0;
      goto LABEL_37;
    }
LABEL_19:
    re::ensureFolderExistsForFile((re *)v22, v18);
    char v24 = HIBYTE(v44.__r_.__value_.__r.__words[2]);
    std::string::size_type v25 = v44.__r_.__value_.__r.__words[0];
    if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v26 = &v44;
    }
    else {
      uint64_t v26 = (std::string *)v44.__r_.__value_.__r.__words[0];
    }
    BOOL v27 = strrchr((char *)v26, 46);
    if (v27)
    {
      uint64_t v28 = v27;
      if (!strcmp(v27, ".arz"))
      {
        std::string::erase(&v44, v28 - (char *)v26, 4uLL);
        char v24 = HIBYTE(v44.__r_.__value_.__r.__words[2]);
        std::string::size_type v25 = v44.__r_.__value_.__r.__words[0];
      }
    }
    if (v24 >= 0) {
      BOOL v29 = &v44;
    }
    else {
      BOOL v29 = (std::string *)v25;
    }
    re::FileStreamWriter::open((re::FileStreamWriter *)v29, (uint64_t)v42);
    if (v42[0]) {
      reality_v1_entry_load_data_begin();
    }
    if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v30 = &v44;
    }
    else {
      int v30 = (std::string *)v44.__r_.__value_.__r.__words[0];
    }
    re::DynamicString::format((re::DynamicString *)"RERealityArchive: Failed to open file for writing at %s.", (re::DynamicString *)&v40, v30);
    re::DynamicString::operator=((re::DynamicString *)&v45, (re::DynamicString *)&v40);
    if (v40 && (v41 & 1) != 0) {
      (*(void (**)(void))(*(void *)v40 + 40))();
    }
    unint64_t v4 = v37;
    a2 = (re *)v38;
    re::Result<re::FileStreamWriter,re::DetailedError>::~Result((uint64_t)v42);
    char v10 = 0;
    int v23 = 1;
LABEL_37:
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v44.__r_.__value_.__l.__data_);
    }
    if (++v9 == v39) {
      int v31 = 1;
    }
    else {
      int v31 = v23;
    }
  }
  while (v31 != 1);
  a3 = v36;
  if ((v10 & 1) == 0)
  {
    re::DynamicString::DynamicString((re::DynamicString *)v42, (const re::DynamicString *)&v45);
    *(unsigned char *)uint64_t v36 = 0;
    *(void *)(v36 + 8) = *(void *)v42;
    *(void *)(v36 + 32) = v43;
    *(_OWORD *)(v36 + 16) = *(_OWORD *)&v42[8];
    goto LABEL_48;
  }
LABEL_47:
  *(unsigned char *)a3 = 1;
LABEL_48:
  uint64_t result = v45;
  if (v45)
  {
    if (v46) {
      return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t))(*v45 + 40))(v45, v47);
    }
  }
  return result;
}

__n128 re::RealityArchive::archiveFromDirectory@<Q0>(char *a1@<X0>, char *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (stat(a1, &v13) || (v13.st_mode & 0x4000) == 0)
  {
    re::DynamicString::format((re::DynamicString *)"Could not find directory %s.", (re::DynamicString *)&v13, a1);
  }
  else if (re::ensureFolderExistsForFile((re *)a2, v8))
  {
    uint64_t v9 = (_anonymous_namespace_ *)reality_archive_file_pack(a1, a2, a3 == 1);
    if (v9)
    {
      *(unsigned char *)a4 = 1;
      return result;
    }
  }
  else
  {
    re::DynamicString::format((re::DynamicString *)"Could not create parent folders for file path %s.", (re::DynamicString *)&v13, a2);
  }
  __n128 result = *(__n128 *)&v13.st_dev;
  uint64_t v11 = *(void *)&v13.st_uid;
  uint64_t v12 = *(void *)&v13.st_rdev;
  *(unsigned char *)a4 = 0;
  *(__n128 *)(a4 + 8) = result;
  *(void *)(a4 + 24) = v11;
  *(void *)(a4 + 32) = v12;
  return result;
}

uint64_t re::RealityArchive::RealityArchive(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(a1 + 24) = a2;
  *(void *)a1 = &unk_26E6CD7D8;
  *(void *)(a1 + 32) = a3;
  if (a3) {
    long long v6 = (_anonymous_namespace_ *)(id)(a3 + 8);
  }
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  re::DynamicString::setCapacity((void *)(a1 + 40), 0);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  return a1;
}

void re::RealityArchiveEntryTable::~RealityArchiveEntryTable(re::RealityArchiveEntryTable *this)
{
  *(void *)this = &unk_26E6CD7A8;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 3);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6CD7A8;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 3);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

BOOL anonymous namespace'::isDoubleCompressed(uint64_t a1)
{
  uint64_t v1 = (const char *)(a1 + 8);
  if (*(char *)(a1 + 31) < 0) {
    uint64_t v1 = *(const char **)v1;
  }
  size_t v2 = strlen(v1);
  return v2 >= 4 && *(_DWORD *)&v1[v2 - 4] == 2054316334;
}

void anonymous namespace'::ArchiveEntryData::~ArchiveEntryData(CFTypeRef *this)
{
  *this = &unk_26E6CD838;
  CFRelease(this[3]);
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
}

{
  uint64_t vars8;

  *this = &unk_26E6CD838;
  CFRelease(this[3]);
  *this = &unk_26E6DECE0;
  objc_destructInstance(this + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::RenderGraphEmitterAsset::~RenderGraphEmitterAsset(re::RenderGraphEmitterAsset *this)
{
  *(void *)this = &unk_26E6CD880;
  size_t v2 = (void (***)(void))*((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = re::globalAllocators(this)[2];
    (**v2)(v2);
    (*(void (**)(uint64_t, void (***)(void)))(*(void *)v3 + 40))(v3, v2);
    *((void *)this + 2) = 0;
  }
}

{
  uint64_t vars8;

  re::RenderGraphEmitterAsset::~RenderGraphEmitterAsset(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::RenderGraphEmitterAsset::assetType(re::RenderGraphEmitterAsset *this)
{
  {
    re::RenderGraphEmitterAsset::assetType(void)::type = (uint64_t)"RenderGraphEmitter";
    qword_26879E540 = 0;
    re::AssetType::generateCompiledExtension((re::AssetType *)&re::RenderGraphEmitterAsset::assetType(void)::type);
  }
  return &re::RenderGraphEmitterAsset::assetType(void)::type;
}

char **re::RenderGraphEmitterAssetLoader::introspectionType(re::RenderGraphEmitterAssetLoader *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::RenderGraphEmitterAsset>(void)::info = re::internal::getOrCreateInfo((re::internal *)"RenderGraphEmitterAsset", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphEmitterAsset, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphEmitterAsset, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphEmitterAsset>, 0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[147];
}

re *re::RenderGraphEmitterAssetLoader::unloadAsset(re::RenderGraphEmitterAssetLoader *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::RenderGraphEmitterAsset>((re *)"unloadAsset", 69, a2);
}

re *re::internal::destroyPersistent<re::RenderGraphEmitterAsset>(re *result, uint64_t a2, void (***a3)(void))
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    (**a3)(a3);
    unint64_t v5 = *(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::RenderGraphEmitterAssetLoader::findDependencies(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
}

BOOL re::RenderGraphEmitterAssetLoader::isSupportedSourceExtension(re::RenderGraphEmitterAssetLoader *this, const char *a2)
{
  return !strcasecmp(a2, "rerendergraphemitter")
      || !strcasecmp(a2, "rendergraphemitter")
      || strcasecmp(a2, "hmrendergraphemitter") == 0;
}

uint64_t re::RenderGraphEmitterAssetLoader::registerAsset(re::RenderGraphEmitterAssetLoader *this, void *a2, const re::ExistingAssetInformation *a3)
{
  a2[3] = re::ServiceLocator::service<re::AssetService>(*((void *)this + 1));
  return 0;
}

uint64_t re::ServiceLocator::service<re::AssetService>(uint64_t a1)
{
  uint64_t result = re::ServiceLocator::serviceOrNull<re::AssetService>(a1);
  if (!result)
  {
    size_t v2 = (re::internal *)re::introspect<re::AssetService>();
    re::StringID::invalid((re::StringID *)v6);
    re::internal::missingServiceErrorMessage(v2, (const re::IntrospectionBase *)v6, (re::DynamicString *)v7);
    re::DynamicString::~DynamicString((re::DynamicString *)v7);
    re::StringID::~StringID((re::StringID *)v6);
    int v3 = (re::internal *)re::introspect<re::AssetService>();
    re::StringID::invalid((re::StringID *)v6);
    re::internal::missingServiceErrorMessage(v3, (const re::IntrospectionBase *)v6, (re::DynamicString *)v7);
    if (v7[8]) {
      unint64_t v5 = *(unsigned char **)&v8[7];
    }
    else {
      unint64_t v5 = v8;
    }
    re::internal::assertLog((re::internal *)5, v4, "assertion failure: '%s' (%s:line %i) %s", "service", "service", 69, v5);
    re::DynamicString::~DynamicString((re::DynamicString *)v7);
    re::StringID::~StringID((re::StringID *)v6);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

void *re::allocInfo_RenderGraphEmitterPointer(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76CD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76CD0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76D58, "RenderGraphEmitterPointer");
    __cxa_guard_release(&qword_26AF76CD0);
  }
  return &unk_26AF76D58;
}

void re::initInfo_RenderGraphEmitterPointer(re *this, re::IntrospectionBase *a2)
{
  v12[0] = 0x32C67EAE114248ELL;
  v12[1] = "RenderGraphEmitterPointer";
  re::StringID::destroyString((re::StringID *)v12);
  *((_OWORD *)this + 2) = v13;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76CD8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF76CD8);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      re::IntrospectionInfo<re::RenderGraphEmitterBase *>::get();
      BOOL v7 = re::introspect_size_t((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "emitter";
      *(void *)(v8 + 16) = &qword_26AF76D18;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 0x800000001;
      *(_DWORD *)(v8 + 40) = 2;
      *(void *)(v8 + 48) = v7;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF76D08 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      char v10 = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 8, 4);
      void *v10 = 0x100000004;
      qword_26AF76D10 = (uint64_t)v10;
      __cxa_guard_release(&qword_26AF76CD8);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF76D08;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphEmitterPointer>;
  *((void *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphEmitterPointer>;
  *((void *)this + 1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::internal::defaultConstructV2<re::RenderGraphEmitterPointer>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphEmitterPointer>;
  re::IntrospectionRegistry::add(this, v3);
  long long v11 = v13;
}

void re::IntrospectionInfo<re::RenderGraphEmitterBase *>::get()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76D00, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76D00))
  {
    re::IntrospectionPointer::IntrospectionPointer((re::IntrospectionPointer *)&qword_26AF76D18);
    __cxa_guard_release(&qword_26AF76D00);
  }
  if ((_MergedGlobals_59 & 1) == 0)
  {
    _MergedGlobals_59 = 1;
    uint64_t v0 = re::introspect_RenderGraphEmitterBase((re::IntrospectionBase **)1);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF76D18, 0);
    qword_26AF76D28 = 0x800000001;
    dword_26AF76D30 = 8;
    word_26AF76D34 = 0;
    *(void *)&xmmword_26AF76D38 = 0;
    *((void *)&xmmword_26AF76D38 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0xFFFFFFFFLL;
    qword_26AF76D18 = (uint64_t)&unk_26E6CDA08;
    qword_26AF76D48 = v0;
    unk_26AF76D50 = 0;
    re::IntrospectionRegistry::add(v1, v2);
    re::getPrettyTypeName((re *)&qword_26AF76D18, (const re::IntrospectionBase *)&v6);
    if (BYTE8(v6)) {
      int v3 = v7;
    }
    else {
      int v3 = (char *)&v6 + 9;
    }
    if (void)v6 && (BYTE8(v6)) {
      (*(void (**)(void))(*(void *)v6 + 40))();
    }
    if (v8 >> 1 == 94623636 && (__s1 == "char*" || !strcmp(__s1, "char*")))
    {
      long long v4 = v6;
    }
    else
    {
      long long v6 = *(_OWORD *)(v0 + 32);
      long long v4 = v5;
    }
    xmmword_26AF76D38 = v4;
    re::StringID::destroyString((re::StringID *)&v8);
  }
}

void re::internal::defaultConstruct<re::RenderGraphEmitterPointer>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + 8) = 0;
}

uint64_t re::internal::defaultConstructV2<re::RenderGraphEmitterPointer>(uint64_t result)
{
  *(void *)(result + 8) = 0;
  return result;
}

uint64_t re::introspect_RenderGraphEmitterPointer(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphEmitterPointer", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphEmitterPointer, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphEmitterPointer, (void (*)(re::IntrospectionBase *))&qword_26AF76CE0, this);
}

void *re::allocInfo_RenderGraphEmitterAsset(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76CE8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76CE8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76DD0, "RenderGraphEmitterAsset");
    __cxa_guard_release(&qword_26AF76CE8);
  }
  return &unk_26AF76DD0;
}

void re::initInfo_RenderGraphEmitterAsset(re *this, re::IntrospectionBase *a2)
{
  v11[0] = 0xA52A22BD1BA272F4;
  v11[1] = "RenderGraphEmitterAsset";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76CF8, memory_order_acquire) & 1) == 0)
  {
    long long v4 = (re *)__cxa_guard_acquire(&qword_26AF76CF8);
    if (v4)
    {
      long long v5 = (re *)re::introspectionAllocator(v4);
      long long v6 = v5;
      BOOL v7 = (re *)qword_26AF76CE0;
      if (!qword_26AF76CE0)
      {
        BOOL v7 = (re *)re::allocInfo_RenderGraphEmitterPointer(v5);
        qword_26AF76CE0 = (uint64_t)v7;
        re::initInfo_RenderGraphEmitterPointer(v7, v8);
      }
      uint64_t v9 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v6 + 32))(v6, 72, 8);
      *(_DWORD *)uint64_t v9 = 1;
      *(void *)(v9 + 8) = "data";
      *(void *)(v9 + 16) = v7;
      *(void *)(v9 + 24) = 0;
      *(void *)(v9 + 32) = 0x800000001;
      *(_DWORD *)(v9 + 40) = 0;
      *(void *)(v9 + 48) = 0;
      *(void *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_26AF76CF0 = v9;
      __cxa_guard_release(&qword_26AF76CF8);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF76CF0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RenderGraphEmitterAsset>;
  *((void *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RenderGraphEmitterAsset>;
  *((void *)this + 1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::internal::defaultConstructV2<re::RenderGraphEmitterAsset>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RenderGraphEmitterAsset>;
  re::IntrospectionRegistry::add(this, v3);
  long long v10 = v12;
}

void re::internal::defaultConstruct<re::RenderGraphEmitterAsset>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = &unk_26E6CD880;
  a3[2] = 0;
}

uint64_t re::internal::defaultDestruct<re::RenderGraphEmitterAsset>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

void *re::internal::defaultConstructV2<re::RenderGraphEmitterAsset>(void *result)
{
  *uint64_t result = &unk_26E6CD880;
  result[2] = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RenderGraphEmitterAsset>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_RenderGraphEmitterAsset(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RenderGraphEmitterAsset", (uint64_t (*)(re::internal *))re::allocInfo_RenderGraphEmitterAsset, (re::IntrospectionBase *(*)(void))re::initInfo_RenderGraphEmitterAsset, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RenderGraphEmitterAsset>, this);
}

void re::RenderGraphEmitterAssetLoader::~RenderGraphEmitterAssetLoader(re::RenderGraphEmitterAssetLoader *this)
{
}

uint64_t re::introspect<re::AssetService>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::introspect<re::AssetService>(void)::info = re::introspect_AssetService(0);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[405];
}

re::IntrospectionPointer *re::IntrospectionPointer::IntrospectionPointer(re::IntrospectionPointer *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)((char *)v2 + 22) = 0;
  v2[2] = 0;
  v2[4] = 0;
  v2[5] = 0xFFFFFFFFLL;
  *int v2 = &unk_26E6CDA08;
  *((void *)this + 7) = 0;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(v2 + 6));
  return this;
}

void re::IntrospectionPointer::~IntrospectionPointer(re::IntrospectionPointer *this)
{
  *(void *)this = &unk_26E6CDA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)this + 48);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6CDA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)this + 48);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::IntrospectionPointer::childInfoCount(re::IntrospectionPointer *this)
{
  return 1;
}

uint64_t re::IntrospectionPointer::childInfo(re::IntrospectionPointer *this, uint64_t a2)
{
  if (!a2) {
    return *((void *)this + 6);
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Index out of range.", "index == 0", "childInfo", 986);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void *re::allocInfo_BuiltinTextureLoadDescriptorParameters(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_60, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_60))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76E78, "BuiltinTextureLoadDescriptorParameters");
    __cxa_guard_release(&_MergedGlobals_60);
  }
  return &unk_26AF76E78;
}

void re::initInfo_BuiltinTextureLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  v10[0] = 0xAFF0BF94697C90EELL;
  v10[1] = "BuiltinTextureLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v10);
  *((_OWORD *)this + 2) = v11;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76E58, memory_order_acquire) & 1) == 0)
  {
    long long v4 = (re *)__cxa_guard_acquire(&qword_26AF76E58);
    if (v4)
    {
      long long v5 = re::introspectionAllocator(v4);
      BOOL v7 = re::IntrospectionInfo<re::DynamicString>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "name";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF76E50 = v8;
      __cxa_guard_release(&qword_26AF76E58);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF76E50;
  *((void *)this + 9) = re::internal::defaultConstruct<re::BuiltinTextureLoadDescriptorParameters>;
  *((void *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::BuiltinTextureLoadDescriptorParameters>;
  *((void *)this + 1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::internal::defaultConstructV2<re::BuiltinTextureLoadDescriptorParameters>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::BuiltinTextureLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  long long v9 = v11;
}

void *re::internal::defaultConstruct<re::BuiltinTextureLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  return re::DynamicString::setCapacity((void *)a3, 0);
}

double re::internal::defaultDestruct<re::BuiltinTextureLoadDescriptorParameters>(int a1, int a2, re::DynamicString *this)
{
  return re::DynamicString::deinit(this);
}

void *re::internal::defaultConstructV2<re::BuiltinTextureLoadDescriptorParameters>(_anonymous_namespace_ *a1)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
  return re::DynamicString::setCapacity(a1, 0);
}

_anonymous_namespace_ *re::BuiltinTextureAssetProvider::BuiltinTextureAssetProvider(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_26E6CDA60;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76E70, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76E70))
  {
    qword_26AF76E68 = re::internal::getOrCreateInfo((re::internal *)"BuiltinTextureLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_BuiltinTextureLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_BuiltinTextureLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76E60, 0);
    __cxa_guard_release(&qword_26AF76E70);
  }
  re::BuiltinTextureAssetProvider::s_loadDescriptorParametersIntrospect = qword_26AF76E68;
  *((void *)a1 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = a2;
  *((void *)a1 + 4) = re::ServiceLocator::serviceOrNull<re::RenderManager>(a3);
  return a1;
}

uint64_t re::ServiceLocator::serviceOrNull<re::RenderManager>(uint64_t a1)
{
  {
    re::introspect<re::RenderManager>(void)::info = re::introspect_RenderManager(0);
  }
  uint64_t v2 = re::introspect<re::RenderManager>(void)::info;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

void re::BuiltinTextureAssetProvider::~BuiltinTextureAssetProvider(re::BuiltinTextureAssetProvider *this)
{
  *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::BuiltinTextureAssetProvider::makeDescriptor@<X0>(re::BuiltinTextureAssetProvider *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  long long v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a2, 0);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(_DWORD *)(a2 + 56) = 0;
  *(void *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_DWORD *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(void *)(a2 + 136) = 0;
  re::DynamicString::setCapacity((void *)(a2 + 112), 0);
  uint64_t v15 = (uint64_t *)"BuiltinTexture";
  uint64_t v16 = 14;
  long long v6 = re::DynamicString::operator=((re::DynamicString *)a2, (uint64_t)&v15);
  BOOL v7 = (const char *)*re::TextureAsset::assetType(v6);
  size_t v8 = strlen(v7);
  uint64_t v15 = (uint64_t *)v7;
  uint64_t v16 = v8;
  long long v9 = re::DynamicString::operator=((re::DynamicString *)(a2 + 112), (uint64_t)&v15);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  re::DynamicString::setCapacity(&v15, 0);
  size_t v10 = strlen((const char *)this);
  v19[0] = this;
  v19[1] = v10;
  re::DynamicString::operator=((re::DynamicString *)&v15, (uint64_t)v19);
  re::DynamicString::DynamicString((re::DynamicString *)v14, (const re::DynamicString *)&v15);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a2, (const re::IntrospectionBase *)re::BuiltinTextureAssetProvider::s_loadDescriptorParametersIntrospect, (const re::IntrospectionBase **)v14, 0);
  if (*(void *)&v14[0])
  {
    if (BYTE8(v14[0])) {
      (*(void (**)(void))(**(void **)&v14[0] + 40))();
    }
    memset(v14, 0, sizeof(v14));
  }
  uint64_t result = v15;
  if (v15)
  {
    if (v16) {
      return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(*v15 + 40))(v15, v17, v11, v12);
    }
  }
  return result;
}

re::DynamicString *re::BuiltinTextureAssetProvider::load@<X0>(re::BuiltinTextureAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t a3@<X8>)
{
  if (*((unsigned char *)a2 + 8)) {
    size_t v8 = (const char *)*((void *)a2 + 2);
  }
  else {
    size_t v8 = (char *)a2 + 9;
  }
  long long v9 = (re::TextureAsset *)strcmp(v8, "BuiltinTexture");
  int v10 = (int)v9;
  uint64_t v11 = (const char *)*re::TextureAsset::assetType(v9);
  if (*((void *)a2 + 15)) {
    uint64_t v12 = (const char *)*((void *)a2 + 16);
  }
  else {
    uint64_t v12 = (char *)a2 + 121;
  }
  long long v13 = (_anonymous_namespace_ *)strcmp(v12, v11);
  if (v10 | v13)
  {
    long long v20 = *(_OWORD *)v43;
    uint64_t v21 = v44;
    uint64_t v22 = v45;
    *(unsigned char *)a3 = 0;
    *(_OWORD *)(a3 + 8) = v20;
    *(void *)(a3 + 24) = v21;
    *(void *)(a3 + 32) = v22;
    return result;
  }
  long long v52 = 0uLL;
  uint64_t v53 = 0;
  re::DynamicString::setCapacity(&v51, 0);
  uint64_t v14 = re::AssetLoadDescriptor::getIntrospectableData<re::BuiltinTextureLoadDescriptorParameters>(a2, &v51);
  if (v14)
  {
    long long v50 = 0;
    uint64_t v15 = *((void *)this + 4);
    if (!v15) {
      goto LABEL_35;
    }
    uint64_t v16 = *(void *)(v15 + 64);
    if (!v16) {
      goto LABEL_35;
    }
    if (v52)
    {
      uint64_t v18 = (char *)*((void *)&v52 + 1);
      uint64_t v14 = strncmp(*((const char **)&v52 + 1), "fallback.", 9uLL);
      if (v14) {
        goto LABEL_35;
      }
    }
    else
    {
      if (*(void *)((char *)&v52 + 1) != 0x6B6361626C6C6166 || BYTE9(v52) != 46) {
        goto LABEL_35;
      }
      uint64_t v18 = (char *)&v52 + 1;
    }
    uint64_t v26 = *(void **)(v16 + 224);
    uint64_t v27 = v18[9];
    if (v18[9])
    {
      char v28 = v18[10];
      if (v28)
      {
        BOOL v29 = (unsigned __int8 *)(v18 + 11);
        do
        {
          uint64_t v27 = 31 * v27 + v28;
          int v30 = *v29++;
          char v28 = v30;
        }
        while (v30);
      }
      v27 &= ~0x8000000000000000;
    }
    v43[0] = (id)v27;
    uint64_t v14 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(v26 + 1, v43);
    if (v14 != -1)
    {
      (*(void (**)(id *__return_ptr, void *, void))(*v26 + 24))(v43, v26, *(unsigned __int8 *)(v26[2] + 16 * v14 + 9));
      NS::SharedPtr<MTL::Texture>::operator=(&v50, v43);
      if (v43[0]) {

      }
      uint64_t v14 = (uint64_t)v50;
      if (v50)
      {
        int v31 = (const re::AssetLoadDescriptor *)((char *)a2 + 112);
        LOBYTE(v43[0]) = 0;
        v43[1] = v50;
        unsigned int v48 = 0;
        id v49 = 0;
        *(void *)&v42[9] = 0;
        *(void *)&uint64_t v42[4] = 0;
        LODWORD(v4re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 16777473;
        BYTE4(v4re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 1;
        *(_DWORD *)unint64_t v42 = 1;
        *(_DWORD *)&v42[20] = 0;
        uint64_t TextureAsset = re::TextureAsset::makeTextureAsset((uint64_t)v43, 6, (long long *)&v41);

        if (v48 != -1) {
          uint64_t v33 = (_anonymous_namespace_ *)((uint64_t (*)(void **, id *))*(&off_26E6CDAF0 + v48))(&v41, &v43[1]);
        }
        v43[1] = 0;
        uint64_t v44 = 0;
        uint64_t v45 = 0;
        re::DynamicString::setCapacity(v43, 0);
        BYTE8(v46) = 0;
        char v47 = 0;
        *(void *)&long long v46 = TextureAsset;
        re::DynamicString::operator=((re::DynamicString *)v43, v31);
        re::DynamicString::DynamicString((re::DynamicString *)&v41, (const re::DynamicString *)v43);
        char v34 = v47;
        long long v35 = v46;
        *(unsigned char *)a3 = 1;
        *(void *)(a3 + 8) = v41;
        *(void *)(a3 + 32) = *(void *)&v42[16];
        *(_OWORD *)(a3 + 16) = *(_OWORD *)v42;
        *(_OWORD *)(a3 + 40) = v35;
        *(unsigned char *)(a3 + 56) = v34;
        id v36 = v43[0];
        if (!v43[0] || ((uint64_t)v43[1] & 1) == 0) {
          goto LABEL_39;
        }
        uint64_t v37 = v44;
        goto LABEL_38;
      }
    }
LABEL_35:
    re::DynamicString::operator+((re::DynamicString *)&v41, (uint64_t)&v51, (re::DynamicString *)v43);
    long long v38 = *(_OWORD *)v43;
    v43[0] = 0;
    v43[1] = 0;
    uint64_t v39 = v44;
    uint64_t v40 = v45;
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    *(unsigned char *)a3 = 0;
    *(_OWORD *)(a3 + 8) = v38;
    *(void *)(a3 + 24) = v39;
    *(void *)(a3 + 32) = v40;
    id v36 = v41;
    if (!v41 || (v42[0] & 1) == 0)
    {
LABEL_39:
      if (v50) {

      }
      goto LABEL_41;
    }
    uint64_t v37 = *(void *)&v42[8];
LABEL_38:
    (*(void (**)(id, uint64_t))(*(void *)v36 + 40))(v36, v37);
    goto LABEL_39;
  }
  long long v23 = *(_OWORD *)v43;
  uint64_t v24 = v44;
  uint64_t v25 = v45;
  *(unsigned char *)a3 = 0;
  *(_OWORD *)(a3 + 8) = v23;
  *(void *)(a3 + 24) = v24;
  *(void *)(a3 + 32) = v25;
LABEL_41:
  uint64_t result = v51;
  if (v51)
  {
    if (v52) {
      return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v51 + 40))();
    }
  }
  return result;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<re::BuiltinTextureLoadDescriptorParameters>(re::AssetLoadDescriptor *a1, re::DynamicString **a2)
{
  uint64_t v2 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76E70, memory_order_acquire) & 1) == 0)
  {
    long long v5 = a1;
    int v7 = __cxa_guard_acquire(&qword_26AF76E70);
    uint64_t v2 = a2;
    int v8 = v7;
    a1 = v5;
    if (v8)
    {
      qword_26AF76E68 = re::internal::getOrCreateInfo((re::internal *)"BuiltinTextureLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_BuiltinTextureLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_BuiltinTextureLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&unk_26AF76E60, 0);
      __cxa_guard_release(&qword_26AF76E70);
      a1 = v5;
      uint64_t v2 = a2;
    }
  }
  uint64_t v3 = (re **)qword_26AF76E68;
  return re::AssetLoadDescriptor::getIntrospectableData(a1, v3, v2, 0);
}

void **NS::SharedPtr<MTL::Texture>::operator=(void **a1, void **a2)
{
  long long v4 = *a1;
  long long v5 = *a2;
  if (v4 == *a2)
  {
  }
  else
  {
    if (v4)
    {

      long long v5 = *a2;
    }
    *a1 = v5;
  }
  *a2 = 0;
  return a1;
}

{
  void *v3;
  void *v4;

  uint64_t v3 = *a1;
  long long v4 = *a2;
  if (v3 != *a2)
  {
    if (v3)
    {

      long long v4 = *a2;
    }
    *a1 = v4;
  }
  return a1;
}

__n128 re::BuiltinTextureAssetProvider::resolveChild@<Q0>(re::BuiltinTextureAssetProvider *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = v9;
  uint64_t v7 = v10;
  uint64_t v8 = v11;
  *(unsigned char *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(void *)(a2 + 24) = v7;
  *(void *)(a2 + 32) = v8;
  return result;
}

re::DynamicString *re::BuiltinTextureAssetProvider::getDescription(re::BuiltinTextureAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  re::DynamicString::setCapacity(&v6, 0);
  if (re::AssetLoadDescriptor::getIntrospectableData<re::BuiltinTextureLoadDescriptorParameters>(a2, &v6))
  {
    re::DynamicString::operator=(a3, (re::DynamicString *)&v6);
  }
  else
  {
    v10[0] = "mangled";
    v10[1] = 7;
    re::DynamicString::operator=(a3, (uint64_t)v10);
  }
  __n128 result = v6;
  if (v6)
  {
    if (v7) {
      return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v6 + 40))();
    }
  }
  return result;
}

uint64_t re::BuiltinTextureAssetProvider::buildFallbackTextureDescriptors@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  uint64_t v4 = *(void *)(this + 32);
  if (v4)
  {
    long long v5 = *(void **)(v4 + 64);
    if (v5)
    {
      uint64_t v6 = v5[28];
      unint64_t v7 = v5[30];
      uint64_t v8 = v5[31];
      uint64_t v9 = (uint64_t *)(v6 + 8);
      v40[0] = v6 + 8;
      unint64_t v10 = *(void *)(v6 + 24);
      if (v10 >= 0x10)
      {
        uint64_t v11 = 0;
        uint64_t v12 = *v9;
        unint64_t v13 = v10 >> 4;
        double v14 = -1.79399301e-307;
        double v15 = 4.74803907e-38;
        while (1)
        {
          unsigned __int16 v16 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v12 + v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
          v40[1] = (unsigned __int16)~v16;
          if (v16 != 0xFFFF) {
            break;
          }
          v11 += 16;
          if (!--v13) {
            return this;
          }
        }
        uint64_t v17 = __clz(__rbit64((unsigned __int16)~v16)) + v11;
        uint64_t v41 = v17;
        if (v17 != -1)
        {
          while (1)
          {
            unint64_t v18 = (unint64_t)*(unsigned __int16 *)(*(void *)(v40[0] + 8) + 16 * v17 + 8) >> 8;
            if (v7 <= v18) {
              break;
            }
            uint64_t v19 = v8 + 32 * v18;
            if (*(unsigned char *)(v19 + 8)) {
              uint64_t v20 = *(void *)(v19 + 16);
            }
            else {
              uint64_t v20 = v8 + 9 + 32 * v18;
            }
            re::DynamicString::format((re::DynamicString *)"fallback.%s", (re::DynamicString *)&v37, v20);
            if (v38) {
              uint64_t v21 = *(re::BuiltinTextureAssetProvider **)&v39[7];
            }
            else {
              uint64_t v21 = (re::BuiltinTextureAssetProvider *)v39;
            }
            re::BuiltinTextureAssetProvider::makeDescriptor(v21, (uint64_t)&v23);
            v22.n128_f64[0] = re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)a3, (uint64_t)&v23);
            if ((void)v35)
            {
              if (BYTE8(v35)) {
                (*(void (**)(double))(*(void *)v35 + 40))(v22.n128_f64[0]);
              }
              __n128 v22 = 0uLL;
              long long v35 = 0u;
              long long v36 = 0u;
            }
            if (v30)
            {
              if (v34) {
                (*(void (**)(__n128))(*(void *)v30 + 40))(v22);
              }
              uint64_t v34 = 0;
              uint64_t v31 = 0;
              uint64_t v32 = 0;
              uint64_t v30 = 0;
              ++v33;
            }
            if (v25)
            {
              if (v29) {
                (*(void (**)(__n128))(*(void *)v25 + 40))(v22);
              }
              uint64_t v29 = 0;
              uint64_t v26 = 0;
              uint64_t v27 = 0;
              uint64_t v25 = 0;
              ++v28;
            }
            if (v23 && (v24 & 1) != 0) {
              (*(void (**)(__n128))(*(void *)v23 + 40))(v22);
            }
            if (v37)
            {
              if (v38) {
                (*(void (**)(__n128))(*(void *)v37 + 40))(v22);
              }
            }
            this = (uint64_t)re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v40);
            uint64_t v17 = v41;
            if (v41 == -1) {
              return this;
            }
          }
          re::internal::assertLog((re::internal *)6, a2, v14, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, int64_t size = %zu", "index < size()", "operator[]", 251, v18, v7);
          this = _os_crash();
          __break(1u);
        }
      }
    }
  }
  return this;
}

double re::DynamicArray<re::AssetLoadDescriptor>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::AssetLoadDescriptor>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 144 * v4;
  double result = 0.0;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(void *)(v5 + 24) = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v8 = *(void *)(a2 + 16);
  *(void *)(a2 + 24) = 0;
  uint64_t v10 = *(void *)(v5 + 8);
  uint64_t v9 = *(void *)(v5 + 16);
  *(void *)(v5 + 8) = v7;
  *(void *)(v5 + 16) = v8;
  *(void *)(a2 + 8) = v10;
  *(void *)(a2 + 16) = v9;
  *(void *)(v5 + 64) = 0;
  *(_DWORD *)(v5 + 56) = 0;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + 32) = 0;
  uint64_t v11 = *(void *)(a2 + 40);
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  *(void *)(v5 + 40) = v11;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v12 = *(void *)(v5 + 48);
  *(void *)(v5 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v12;
  uint64_t v13 = *(void *)(v5 + 64);
  *(void *)(v5 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v13;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(v5 + 56);
  *(void *)(v5 + 104) = 0;
  *(void *)(v5 + 80) = 0;
  *(void *)(v5 + 88) = 0;
  *(void *)(v5 + 72) = 0;
  *(_DWORD *)(v5 + 96) = 0;
  uint64_t v14 = *(void *)(a2 + 80);
  *(void *)(v5 + 72) = *(void *)(a2 + 72);
  *(void *)(v5 + 80) = v14;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  uint64_t v15 = *(void *)(v5 + 88);
  *(void *)(v5 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v15;
  uint64_t v16 = *(void *)(v5 + 104);
  *(void *)(v5 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v16;
  ++*(_DWORD *)(a2 + 96);
  ++*(_DWORD *)(v5 + 96);
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(void *)(v5 + 136) = *(void *)(a2 + 136);
  uint64_t v17 = *(void *)(a2 + 120);
  *(void *)(v5 + 112) = *(void *)(a2 + 112);
  *(void *)(a2 + 112) = 0;
  uint64_t v18 = *(void *)(a2 + 128);
  *(void *)(a2 + 136) = 0;
  uint64_t v20 = *(void *)(v5 + 120);
  uint64_t v19 = *(void *)(v5 + 128);
  *(void *)(v5 + 120) = v17;
  *(void *)(v5 + 128) = v18;
  *(void *)(a2 + 120) = v20;
  *(void *)(a2 + 128) = v19;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

BOOL re::BuiltinTextureAssetProvider::isDeviceAssetForRelease(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return a3 > 9;
}

re::DynamicString *re::BuiltinTextureAssetProvider::getAssetPathForRelease@<X0>(_anonymous_namespace_ *a1@<X0>, re::AssetLoadDescriptor *a2@<X1>, unsigned int a3@<W4>, uint64_t a4@<X8>)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  re::DynamicString::setCapacity(&v18, 0);
  if (re::AssetLoadDescriptor::getIntrospectableData<re::BuiltinTextureLoadDescriptorParameters>(a2, &v18))
  {
    if (a3 < 0xA)
    {
      if (v19) {
        uint64_t v13 = v20;
      }
      else {
        uint64_t v13 = (char *)&v19 + 1;
      }
      re::DynamicString::format((re::DynamicString *)"memory:%s.compiledtexture", (re::DynamicString *)&v15, v13);
    }
    else
    {
      if (*((void *)a2 + 1)) {
        uint64_t v7 = (char *)*((void *)a2 + 2);
      }
      else {
        uint64_t v7 = (char *)a2 + 9;
      }
      if (v19) {
        uint64_t v8 = v20;
      }
      else {
        uint64_t v8 = (char *)&v19 + 1;
      }
      re::DynamicString::format((re::DynamicString *)"%s:%s.compiledtexture", (re::DynamicString *)&v15, v7, v8);
    }
    long long v10 = v15;
    uint64_t v11 = v16;
    uint64_t v12 = v17;
    *(unsigned char *)a4 = 1;
  }
  else
  {
    if (*((void *)a2 + 1)) {
      uint64_t v9 = (char *)*((void *)a2 + 2);
    }
    else {
      uint64_t v9 = (char *)a2 + 9;
    }
    re::DynamicString::format((re::DynamicString *)"Failed to deserialize parameters for %s", (re::DynamicString *)&v15, v9);
    long long v10 = v15;
    uint64_t v11 = v16;
    uint64_t v12 = v17;
    *(unsigned char *)a4 = 0;
  }
  *(_OWORD *)(a4 + 8) = v10;
  *(void *)(a4 + 24) = v11;
  *(void *)(a4 + 32) = v12;
  double result = v18;
  if (v18)
  {
    if (v19) {
      return (re::DynamicString *)(*(uint64_t (**)(void))(*(void *)v18 + 40))();
    }
  }
  return result;
}

void re::BuiltinTextureAssetProvider::makeDescriptorFromAssetPath(const re::AssetPath *a1@<X1>, unsigned char *a2@<X8>)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v5 = (char *)a1 + 17;
  if (*((void *)a1 + 2)) {
    uint64_t v6 = (const char *)*((void *)a1 + 3);
  }
  else {
    uint64_t v6 = (char *)a1 + 17;
  }
  uint64_t v7 = (re *)strcmp(v6, "BuiltinTexture");
  if (v7)
  {
    uint64_t v8 = *re::assetsLogObjects(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if (*((void *)a1 + 2)) {
        uint64_t v11 = (char *)*((void *)a1 + 3);
      }
      else {
        uint64_t v11 = v5;
      }
      *(_DWORD *)uint64_t v12 = 136315394;
      *(void *)&v12[4] = v11;
      __int16 v13 = 2080;
      uint64_t v14 = "BuiltinTexture";
      _os_log_error_impl(&dword_233120000, v8, OS_LOG_TYPE_ERROR, "Unexpected scheme: %s, expected: %s", v12, 0x16u);
    }
    *a2 = 0;
  }
  else
  {
    if (*((void *)a1 + 6)) {
      uint64_t v9 = (re::BuiltinTextureAssetProvider *)*((void *)a1 + 7);
    }
    else {
      uint64_t v9 = (const re::AssetPath *)((char *)a1 + 49);
    }
    re::BuiltinTextureAssetProvider::makeDescriptor(v9, (uint64_t)v12);
    v10.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional((uint64_t)a2, (uint64_t)v12);
    if ((void)v25)
    {
      if (BYTE8(v25)) {
        (*(void (**)(double))(*(void *)v25 + 40))(v10.n128_f64[0]);
      }
      __n128 v10 = 0uLL;
      long long v25 = 0u;
      long long v26 = 0u;
    }
    if (v20)
    {
      if (v24) {
        (*(void (**)(__n128))(*(void *)v20 + 40))(v10);
      }
      uint64_t v24 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64_t v20 = 0;
      ++v23;
    }
    if (v15)
    {
      if (v19) {
        (*(void (**)(__n128))(*(void *)v15 + 40))(v10);
      }
      uint64_t v19 = 0;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      uint64_t v15 = 0;
      ++v18;
    }
    if (*(void *)v12 && (v12[8] & 1) != 0) {
      (*(void (**)(__n128))(**(void **)v12 + 40))(v10);
    }
  }
}

const char *re::BuiltinTextureAssetProvider::schemeName(re::BuiltinTextureAssetProvider *this)
{
  return "BuiltinTexture";
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2NS9SharedPtrIN3MTL7TextureEEEN2re10CPUTextureEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSG_1EJSC_SE_EEEEEEDcSI_DpT0_(uint64_t a1, id *a2)
{
  if (*a2)
  {

    *a2 = 0;
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2NS9SharedPtrIN3MTL7TextureEEEN2re10CPUTextureEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSG_1EJSC_SE_EEEEEEDcSI_DpT0_(int a1, id *this)
{
}

void re::CPUTexture::~CPUTexture(id *this)
{
  if (*this)
  {

    *this = 0;
  }
}

uint64_t re::DynamicArray<re::DynamicArray<unsigned char>>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 40 * v4;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v3);
          v3 += 40;
          v5 -= 40;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(void *a1, void *a2)
{
  if (!a1[7]) {
    return -1;
  }
  unint64_t v2 = a1[2];
  if (v2 < 0x10 || !a1[3]) {
    return -1;
  }
  unint64_t v3 = v2 >> 4;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ (*a2 >> 30));
  unint64_t v5 = (0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31);
  unint64_t v6 = v5 % v3;
  int8x16_t v7 = vdupq_n_s8(v5 & 0x7F);
  v8.i64[0] = -1;
  v8.i64[1] = -1;
  unint64_t v9 = v5 % v3;
  while (1)
  {
    int8x16_t v10 = *(int8x16_t *)(*a1 + 16 * v9);
    unint64_t v11 = (unint64_t)vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v7, v10), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    unint64_t v12 = __clz(__rbit64(v11));
    if (v12 <= 0x3F) {
      break;
    }
LABEL_10:
    if (vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v10, v8), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800))
    {
      return -1;
    }
    if (v9 + 1 == v3) {
      unint64_t v9 = 0;
    }
    else {
      ++v9;
    }
    uint64_t v14 = -1;
    if (v9 == v6) {
      return v14;
    }
  }
  uint64_t v13 = 16 * v9;
  while (1)
  {
    uint64_t v14 = v12 + v13;
    if (*a2 == *(void *)(a1[1] + 16 * (v12 + v13))) {
      return v14;
    }
    if (v12 <= 0x3E)
    {
      unint64_t v12 = __clz(__rbit64((-2 << v12) & v11));
      if (v12 < 0x40) {
        continue;
      }
    }
    goto LABEL_10;
  }
}

void re::VFXAsset::~VFXAsset(re::VFXAsset *this)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (*((void *)this + 9) != -1)
  {
    unint64_t v2 = (re *)sandbox_extension_release();
    if (v2)
    {
      unint64_t v3 = (id)*re::assetTypesLogObjects(v2);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        int v4 = *__error();
        v5[0] = 67109120;
        v5[1] = v4;
        _os_log_error_impl(&dword_233120000, v3, OS_LOG_TYPE_ERROR, "VFXAsset: sandbox release error %i", (uint8_t *)v5, 8u);
      }
    }
  }

  re::DynamicString::deinit((re::VFXAsset *)((char *)this + 32));
  re::DynamicString::deinit(this);
}

void sub_2333DC1C4(_Unwind_Exception *a1)
{
  re::DynamicString::deinit((re::DynamicString *)(v1 + 4));
  re::DynamicString::deinit((re::DynamicString *)v1);
  _Unwind_Resume(a1);
}

uint64_t *re::VFXAsset::assetType(re::VFXAsset *this)
{
  {
    re::VFXAsset::assetType(void)::type = (uint64_t)"VFX";
    qword_26879E568 = 0;
    re::AssetType::generateCompiledExtension((re::AssetType *)&re::VFXAsset::assetType(void)::type);
  }
  return &re::VFXAsset::assetType(void)::type;
}

char **re::VFXAssetLoader::introspectionType(re::VFXAssetLoader *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::VFXAsset>(void)::info = re::internal::getOrCreateInfo((re::internal *)"VFXAsset", (uint64_t (*)(re::internal *))re::allocInfo_VFXAsset, (re::IntrospectionBase *(*)(void))re::initInfo_VFXAsset, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::VFXAsset>, 0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[149];
}

BOOL re::VFXAssetLoader::createRuntimeData(uint64_t *a1, void *a2)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  unint64_t v2 = a2[1];
  unint64_t v3 = v2 >> 1;
  if ((v2 & 1) == 0) {
    unint64_t v3 = v2 >> 1;
  }
  if (v3)
  {
    int v4 = (void **)(a2 + 8);
    if (a2[8]) {
      return 1;
    }
    if (v2) {
      int8x16_t v8 = (char *)a2[2];
    }
    else {
      int8x16_t v8 = (char *)a2 + 9;
    }
    unint64_t v9 = NSURL;
    int8x16_t v10 = [NSString stringWithUTF8String:v8];
    unint64_t v11 = [v9 fileURLWithPath:v10];

    uint64_t v31 = 0;
    if (!re::ServiceLocator::serviceOrNull<re::RenderManager>(a1[1]))
    {
      uint64_t v24 = *re::assetTypesLogObjects(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        int v33 = v11;
        _os_log_error_impl(&dword_233120000, v24, OS_LOG_TYPE_ERROR, "Can't load VFXAsset %@ null rendermanager", buf, 0xCu);
      }
      goto LABEL_20;
    }
    unint64_t v12 = (re *)re::ServiceLocator::service<re::RenderManager>(a1[1]);
    uint64_t v13 = *((void *)v12 + 13);
    VFXRESceneClass = re::getVFXRESceneClass(v12);
    uint64_t v15 = VFXRESceneClass;
    if (VFXRESceneClass)
    {
      VFXSceneLoadOptionsClass = re::getVFXSceneLoadOptionsClass(VFXRESceneClass);
      if (VFXSceneLoadOptionsClass)
      {
        uint64_t v17 = a1[1];
        {
          re::introspect<re::VFXManager>(void)::info = re::introspect_VFXManager(0);
        }
        uint64_t v18 = re::introspect<re::VFXManager>(void)::info;
        re::StringID::invalid((re::StringID *)buf);
        uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint8_t *))(*(void *)v17 + 16))(v17, v18, buf);
        re::StringID::destroyString((re::StringID *)buf);
        if (v19)
        {
          id v21 = objc_alloc_init(VFXSceneLoadOptionsClass);
          [v21 setSetupRenderer:v13 != 0];
          [v21 setAutomaticallyPrepareScene:v13 != 0];
          [v21 setEnableRuntimeScriptCompilation:*(unsigned __int8 *)(v19 + 16)];
          id v22 = [v15 alloc];
          if (v13) {
            id v23 = *(id *)v19;
          }
          else {
            id v23 = 0;
          }
          uint64_t v27 = (re *)[v22 initWithContentsOf:v11 commandQueue:v23 options:v21 error:&v31];
          int v28 = v27;
          if (v13) {

          }
          if (!v31)
          {
            re::ObjCObject::operator=(v4, v28);

            return 1;
          }
          uint64_t v29 = (id)*re::assetTypesLogObjects(v27);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            uint64_t v30 = [v11 path];
            *(_DWORD *)long long buf = 138412546;
            int v33 = v30;
            __int16 v34 = 2112;
            uint64_t v35 = v31;
            _os_log_error_impl(&dword_233120000, v29, OS_LOG_TYPE_ERROR, "Couldn't load %@ %@", buf, 0x16u);
          }
          return 0;
        }
        long long v25 = *re::assetTypesLogObjects(v20);
        if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          goto LABEL_20;
        }
        *(_WORD *)long long buf = 0;
        long long v26 = "VFX service is not loaded";
      }
      else
      {
        long long v25 = *re::assetTypesLogObjects(0);
        if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          goto LABEL_20;
        }
        *(_WORD *)long long buf = 0;
        long long v26 = "VFX framework is not loaded";
      }
      _os_log_error_impl(&dword_233120000, v25, OS_LOG_TYPE_ERROR, v26, buf, 2u);
    }
LABEL_20:

    return 0;
  }
  uint64_t v6 = *re::assetTypesLogObjects((re *)a1);
  BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  if (!result) {
    return result;
  }
  *(_WORD *)long long buf = 0;
  _os_log_error_impl(&dword_233120000, v6, OS_LOG_TYPE_ERROR, "Can't load VFXAsset empoty path", buf, 2u);
  return 0;
}

void sub_2333DC6DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t re::ServiceLocator::service<re::RenderManager>(uint64_t a1)
{
  uint64_t result = re::ServiceLocator::serviceOrNull<re::RenderManager>(a1);
  if (!result)
  {
    unint64_t v2 = (re::internal *)re::introspect<re::RenderManager>();
    re::StringID::invalid((re::StringID *)v6);
    re::internal::missingServiceErrorMessage(v2, (const re::IntrospectionBase *)v6, (re::DynamicString *)v7);
    re::DynamicString::~DynamicString((re::DynamicString *)v7);
    re::StringID::~StringID((re::StringID *)v6);
    unint64_t v3 = (re::internal *)re::introspect<re::RenderManager>();
    re::StringID::invalid((re::StringID *)v6);
    re::internal::missingServiceErrorMessage(v3, (const re::IntrospectionBase *)v6, (re::DynamicString *)v7);
    if (v7[8]) {
      unint64_t v5 = *(unsigned char **)&v8[7];
    }
    else {
      unint64_t v5 = v8;
    }
    re::internal::assertLog((re::internal *)5, v4, "assertion failure: '%s' (%s:line %i) %s", "service", "service", 69, v5);
    re::DynamicString::~DynamicString((re::DynamicString *)v7);
    re::StringID::~StringID((re::StringID *)v6);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::VFXAssetLoader::registerAsset(re::VFXAssetLoader *this, void *a2, const re::ExistingAssetInformation *a3)
{
  unint64_t v3 = *((void *)a2 + 1);
  if (v3) {
    unint64_t v4 = v3 >> 1;
  }
  else {
    unint64_t v4 = v3 >> 1;
  }
  if (!v4) {
    return 2;
  }
  if (*(void *)(re::ServiceLocator::service<re::RenderManager>(*((void *)this + 1)) + 104))
  {
    uint64_t v8 = *((void *)this + 1);
    uint64_t v9 = *((void *)a3 + 10);
    int8x16_t v10 = (os_unfair_lock_s *)re::ServiceLocator::serviceOrNull<re::AssetService>(v8);
    if (v10)
    {
      if (v9 == -1) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = v9;
      }
      re::AssetManager::fromPeerID(v10, v11, (uint64_t)v20);
      int v12 = LOBYTE(v20[0]);
      uint64_t v13 = v20[1];
      uint64_t v14 = re::ServiceLocator::serviceOrNull<re::ResourceFetchService>(v8);
      if (v14)
      {
        if (v12) {
          uint64_t v15 = v13;
        }
        else {
          uint64_t v15 = 0;
        }
        uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 56))(v14, v15);
        goto LABEL_20;
      }
      uint64_t v18 = *re::assetTypesLogObjects(0);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
LABEL_19:
        uint64_t v16 = 0;
LABEL_20:
        objc_msgSend(*((id *)a2 + 8), "setPeerPid:", 0xFFFFFFFFLL, v20[0]);
        [*((id *)a2 + 8) setPeerTaskIdentity:v16];
        [*((id *)a2 + 8) updateMemoryOwnership];
        return 0;
      }
      LOWORD(v20[0]) = 0;
      uint64_t v19 = "ResourceFetchService not available to retrieve peer task identity token";
    }
    else
    {
      uint64_t v18 = *re::assetTypesLogObjects(0);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_19;
      }
      LOWORD(v20[0]) = 0;
      uint64_t v19 = "AssetManager not available to retrieve peer task identity token";
    }
    _os_log_error_impl(&dword_233120000, v18, OS_LOG_TYPE_ERROR, v19, (uint8_t *)v20, 2u);
    goto LABEL_19;
  }
  return 0;
}

re *re::VFXAssetLoader::unloadAsset(re::VFXAssetLoader *this, re::VFXAsset *a2)
{
  return re::internal::destroyPersistent<re::VFXAsset>((re *)"unloadAsset", 216, a2);
}

re *re::internal::destroyPersistent<re::VFXAsset>(re *result, uint64_t a2, re::VFXAsset *a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::VFXAsset::~VFXAsset(a3);
    unint64_t v5 = *(uint64_t (**)(uint64_t, re::VFXAsset *))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

BOOL re::VFXAssetLoader::isSupportedSourceExtension(re::VFXAssetLoader *this, const char *a2)
{
  return !strcasecmp(a2, "vfx") || strcasecmp(a2, "vfxproj") == 0;
}

void *re::allocInfo_VFXFile(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_61, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_61))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76F30, "VFXFile");
    __cxa_guard_release(&_MergedGlobals_61);
  }
  return &unk_26AF76F30;
}

void re::initInfo_VFXFile(re *this, re::IntrospectionBase *a2)
{
  v14[0] = 0x2483894288;
  v14[1] = "VFXFile";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76EF8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF76EF8);
    if (v4)
    {
      unint64_t v5 = re::introspectionAllocator(v4);
      int8x16_t v7 = re::IntrospectionInfo<re::DynamicString>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "vfxFilePath";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF76F20 = v8;
      uint64_t v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::IntrospectionInfo<re::DynamicString>::get(1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "vfxSandboxToken";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x2000000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF76F28 = v12;
      __cxa_guard_release(&qword_26AF76EF8);
    }
  }
  *((void *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((void *)this + 8) = &qword_26AF76F20;
  *((void *)this + 9) = re::internal::defaultConstruct<re::VFXFile>;
  *((void *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::VFXFile>;
  *((void *)this + 1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::internal::defaultConstructV2<re::VFXFile>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::VFXFile>;
  re::IntrospectionRegistry::add(this, v3);
  long long v13 = v15;
}

void sub_2333DCD3C(_Unwind_Exception *a1)
{
}

void *re::internal::defaultConstruct<re::VFXFile>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  uint64_t v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a3, 0);
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  unint64_t v5 = (void *)(a3 + 32);
  return re::DynamicString::setCapacity(v5, 0);
}

double re::internal::defaultDestruct<re::VFXFile>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicString::deinit((re::DynamicString *)(a3 + 32));
  return re::DynamicString::deinit((re::DynamicString *)a3);
}

void *re::internal::defaultConstructV2<re::VFXFile>(_OWORD *a1)
{
  *a1 = 0u;
  a1[1] = 0u;
  unint64_t v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(a1, 0);
  a1[2] = 0u;
  a1[3] = 0u;
  unint64_t v3 = a1 + 2;
  return re::DynamicString::setCapacity(v3, 0);
}

double re::internal::defaultDestructV2<re::VFXFile>(uint64_t a1)
{
  re::DynamicString::deinit((re::DynamicString *)(a1 + 32));
  return re::DynamicString::deinit((re::DynamicString *)a1);
}

void *re::allocInfo_VFXAsset(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76F08, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF76F08))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF76FA8, "VFXAsset");
    __cxa_guard_release(&qword_26AF76F08);
  }
  return &unk_26AF76FA8;
}

void re::initInfo_VFXAsset(re *this, re::IntrospectionBase *a2)
{
  v11[0] = 0x46BED1B7050;
  v11[1] = "VFXAsset";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF76F18, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF76F18);
    if (v4)
    {
      unint64_t v5 = (re *)re::introspectionAllocator(v4);
      uint64_t v6 = v5;
      int8x16_t v7 = (re *)qword_26AF76F00;
      if (!qword_26AF76F00)
      {
        int8x16_t v7 = (re *)re::allocInfo_VFXFile(v5);
        qword_26AF76F00 = (uint64_t)v7;
        re::initInfo_VFXFile(v7, v8);
      }
      uint64_t v9 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v6 + 32))(v6, 72, 8);
      *(_DWORD *)uint64_t v9 = 1;
      *(void *)(v9 + 8) = "vfxFile";
      *(void *)(v9 + 16) = v7;
      *(void *)(v9 + 24) = 0;
      *(void *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(void *)(v9 + 48) = 0;
      *(void *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_26AF76F10 = v9;
      __cxa_guard_release(&qword_26AF76F18);
    }
  }
  *((void *)this + 2) = 0x5000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((void *)this + 8) = &qword_26AF76F10;
  *((void *)this + 9) = re::internal::defaultConstruct<re::VFXAsset>;
  *((void *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::VFXAsset>;
  *((void *)this + 1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::internal::defaultConstructV2<re::VFXAsset>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::VFXAsset>;
  re::IntrospectionRegistry::add(this, v3);
  long long v10 = v12;
}

void sub_2333DD10C(_Unwind_Exception *a1)
{
}

void *re::internal::defaultConstruct<re::VFXAsset>(_anonymous_namespace_ *a1, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = a3;
  *a3 = 0u;
  a3[1] = 0u;
  uint64_t v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v3, 0);
  v3[2] = 0u;
  v3[3] = 0u;
  v3 += 2;
  uint64_t result = re::DynamicString::setCapacity(v3, 0);
  *((void *)v3 + 4) = 0;
  *((void *)v3 + 5) = -1;
  return result;
}

void re::internal::defaultDestruct<re::VFXAsset>(int a1, int a2, re::VFXAsset *this)
{
}

void *re::internal::defaultConstructV2<re::VFXAsset>(_anonymous_namespace_ *a1)
{
  uint64_t v1 = a1;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
  unint64_t v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v1, 0);
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0u;
  uint64_t v1 = (_anonymous_namespace_ *)((char *)v1 + 32);
  uint64_t result = re::DynamicString::setCapacity(v1, 0);
  *((void *)v1 + 4) = 0;
  *((void *)v1 + 5) = -1;
  return result;
}

uint64_t re::introspect_VFXAsset(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"VFXAsset", (uint64_t (*)(re::internal *))re::allocInfo_VFXAsset, (re::IntrospectionBase *(*)(void))re::initInfo_VFXAsset, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::VFXAsset>, this);
}

void re::VFXAssetLoader::~VFXAssetLoader(re::VFXAssetLoader *this)
{
}

uint64_t re::introspect<re::RenderManager>()
{
  {
    re::introspect<re::RenderManager>(void)::info = re::introspect_RenderManager(0);
  }
  return re::introspect<re::RenderManager>(void)::info;
}

void sub_2333DD2B0(_Unwind_Exception *a1)
{
}

uint64_t *re::MeshAsset::assetType(re::MeshAsset *this)
{
  {
    re::MeshAsset::assetType(void)::type = (uint64_t)"Mesh";
    qword_26879E588 = 0;
    re::AssetType::generateCompiledExtension((re::AssetType *)&re::MeshAsset::assetType(void)::type);
  }
  return &re::MeshAsset::assetType(void)::type;
}

double re::MeshAsset::MeshAsset(re::MeshAsset *this)
{
  *(void *)this = &unk_26E6CDC68;
  *((void *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 0;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_DWORD *)this + 38) = 0;
  *((_DWORD *)this + 106) = 0;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 484) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *((_DWORD *)this + 48) = 0;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_DWORD *)this + 58) = 0;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_DWORD *)this + 68) = 0;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 372) = 0u;
  *((_DWORD *)this + 112) = 0;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0;
  *(void *)((char *)this + 500) = 0x7FFFFFFFLL;
  *((_DWORD *)this + 136) = 0;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 3re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0u;
  *(void *)((char *)this + 548) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 905) = 0u;
  *((_OWORD *)this + 55) = 0u;
  *((_OWORD *)this + 56) = 0u;
  *((_OWORD *)this + 5re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *((_OWORD *)this + 5re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
  *((_OWORD *)this + 52) = 0u;
  *((_OWORD *)this + 49) = 0u;
  *((_OWORD *)this + 50) = 0u;
  *((_OWORD *)this + 47) = 0u;
  *((_OWORD *)this + 48) = 0u;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((_OWORD *)this + 4re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((_OWORD *)this + 4re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_DWORD *)this + 23re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 2;
  *((void *)this + 116) = 0;
  *((void *)this + 118) = 0;
  *((void *)this + 117) = 0;
  *((unsigned char *)this + 952) = 0;
  return result;
}

uint64_t re::MeshAsset::MeshAsset(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26E6CDC68;
  *(void *)(a1 + 8) = 0;
  unint64_t v3 = (re::MeshAssetData *)(a1 + 8);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)unint64_t v3 = *(void *)a2;
  *(void *)a2 = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v4 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v4;
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v5;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(a1 + 32);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 48) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  *(void *)(a1 + 56) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  uint64_t v6 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v6;
  uint64_t v7 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v7;
  ++*(_DWORD *)(a2 + 64);
  ++*(_DWORD *)(a1 + 72);
  *(void *)(a1 + 88) = 0;
  uint64_t v8 = a1 + 88;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 88) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = 0;
  *(void *)(a1 + 96) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = 0;
  uint64_t v9 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = v9;
  uint64_t v10 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = *(void *)(a2 + 112);
  *(void *)(a2 + 112) = v10;
  ++*(_DWORD *)(a2 + 104);
  ++*(_DWORD *)(a1 + 112);
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(void *)(a1 + 128) = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = 0;
  *(void *)(a1 + 136) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = 0;
  uint64_t v11 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = *(void *)(a2 + 136);
  *(void *)(a2 + 136) = v11;
  uint64_t v12 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = *(void *)(a2 + 152);
  *(void *)(a2 + 152) = v12;
  ++*(_DWORD *)(a2 + 144);
  ++*(_DWORD *)(a1 + 152);
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 484) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_DWORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_DWORD *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 372) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 440) = 0;
  *(_DWORD *)(a1 + 448) = 0;
  *(void *)(a1 + 500) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_DWORD *)(a1 + 544) = 0;
  *(void *)(a1 + 548) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_OWORD *)(a1 + 864) = 0u;
  *(_OWORD *)(a1 + 880) = 0u;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_OWORD *)(a1 + 905) = 0u;
  *(_DWORD *)(a1 + 924) = 2;
  *(void *)(a1 + 928) = 0;
  *(void *)(a1 + 944) = 0;
  *(void *)(a1 + 936) = 0;
  *(unsigned char *)(a1 + 952) = 0;
  if (!*(void *)(a1 + 144)) {
    re::MeshAssetData::generateMetaData(v3);
  }
  re::DynamicArray<float>::operator=(a1 + 168, (uint64_t *)(a1 + 128));
  if (!*(void *)(a1 + 104))
  {
    uint64_t v13 = *(void *)(a1 + 24);
    if (v13)
    {
      uint64_t v14 = *(void *)(a1 + 40) + 232;
      while (!*(void *)(v14 + 16))
      {
        v14 += 512;
        if (!--v13) {
          goto LABEL_10;
        }
      }
      uint64_t v8 = v14;
    }
  }
LABEL_10:
  uint64_t v15 = *(void *)(v8 + 16);
  v17[0] = *(void *)(v8 + 32);
  v17[1] = v15;
  re::MeshAsset::setSkeletons((void *)a1, v17);
  return a1;
}

void re::MeshAsset::setSkeletons(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  unint64_t v5 = a2[1];
  uint64_t v6 = (_anonymous_namespace_ *)re::FixedArray<re::Skeleton>::deinit(a1 + 116);
  a1[117] = v5;
  if (v5)
  {
    if (v5 < 0x19999999999999ALL)
    {
      a1[118] = v8;
      if (!v8) {
        goto LABEL_22;
      }
      unint64_t v10 = v5 - 1;
      if (v5 == 1)
      {
        long long v12 = 0uLL;
        *(_OWORD *)uint64_t v8 = 0u;
        *(_OWORD *)(v8 + 128) = 0u;
        *(_OWORD *)(v8 + 144) = 0u;
        *(_OWORD *)(v8 + 96) = 0u;
        *(_OWORD *)(v8 + 112) = 0u;
        *(_OWORD *)(v8 + 64) = 0u;
        *(_OWORD *)(v8 + 80) = 0u;
        *(_OWORD *)(v8 + 16) = 0u;
        uint64_t v13 = (_OWORD *)(v8 + 16);
        *(void *)(v8 + 8) = "";
        uint64_t v11 = (_DWORD *)(v8 + 148);
        *(_OWORD *)(v8 + 32) = 0u;
        *(_OWORD *)(v8 + 48) = 0u;
      }
      else
      {
        uint64_t v11 = (_DWORD *)(v8 + 148);
        do
        {
          *(_OWORD *)(v11 - 37) = 0uLL;
          *(_OWORD *)(v11 - re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0uLL;
          *(_OWORD *)(v11 - 5) = 0uLL;
          *(_OWORD *)(v11 - 9) = 0uLL;
          *(_OWORD *)(v11 - 1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0uLL;
          *(_OWORD *)(v11 - 17) = 0uLL;
          *(_OWORD *)(v11 - 2re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0uLL;
          *(_OWORD *)(v11 - 25) = 0uLL;
          *(_OWORD *)(v11 - 29) = 0uLL;
          *(_OWORD *)(v11 - 3re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0uLL;
          *(void *)(v11 - 35) = "";
          *(void *)(v11 - re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0x7FFFFFFF00000000;
          v11 += 40;
          --v10;
        }
        while (v10);
        long long v12 = 0uLL;
        *(_OWORD *)(v11 - 3re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0u;
        uint64_t v13 = v11 - 33;
        *(_OWORD *)(v11 - 37) = 0u;
        v13[7] = 0u;
        char v13[8] = 0u;
        v13[5] = 0u;
        v13[6] = 0u;
        v13[3] = 0u;
        v13[4] = 0u;
        v13[1] = 0u;
        void v13[2] = 0u;
        *(void *)(v11 - 35) = "";
      }
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      unint64_t v16 = 0;
      *((_DWORD *)v13 + 32) = 0;
      *uint64_t v11 = 0x7FFFFFFF;
      v13[6] = v12;
      v13[7] = v12;
      v13[4] = v12;
      v13[5] = v12;
      void v13[2] = v12;
      v13[3] = v12;
      *uint64_t v13 = v12;
      v13[1] = v12;
      while (1)
      {
        unint64_t v17 = a2[1];
        if (v17 <= v16) {
          break;
        }
        unint64_t v2 = (uint64_t *)a1[117];
        if ((unint64_t)v2 <= v16) {
          goto LABEL_20;
        }
        unint64_t v2 = (uint64_t *)(*a2 + v15);
        uint64_t v18 = (uint64_t *)(a1[118] + v14);
        uint64_t v19 = v2[3];
        v31[0] = v2[4];
        v31[1] = v19;
        uint64_t v20 = v2[6];
        *(void *)long long v26 = v2[7];
        *(void *)&unsigned char v26[8] = v20;
        uint64_t v21 = v2[9];
        v22[0] = v2[10];
        v22[1] = v21;
        if (!v23[0])
        {
          uint64_t v8 = v24;
          if ((void)v24)
          {
            if (BYTE8(v24)) {
              uint64_t v8 = (*(uint64_t (**)(void))(*(void *)v24 + 40))();
            }
            long long v24 = 0u;
            long long v25 = 0u;
          }
        }
        ++v16;
        v15 += 112;
        v14 += 160;
        if (v5 == v16) {
          return;
        }
      }
      re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, int64_t size = %zu", "index < size()", "operator[]", 251, v16, v17);
      _os_crash();
      __break(1u);
LABEL_20:
      v22[0] = 0;
      memset(v31, 0, 80);
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v26 = 136315906;
      *(void *)&v26[4] = "operator[]";
      *(_WORD *)&v26[12] = 1024;
      *(_DWORD *)&v26[14] = 468;
      __int16 v27 = 2048;
      unint64_t v28 = v16;
      __int16 v29 = 2048;
      uint64_t v30 = v2;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element int64_t size = %zu, count = %zu", "!overflow", "init", 324, 160, v5);
    _os_crash();
    __break(1u);
LABEL_22:
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::MeshAsset::MeshAsset(uint64_t a1, id *a2, uint64_t a3)
{
  *(void *)a1 = &unk_26E6CDC68;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_DWORD *)(a1 + 152) = 0;
  *(void *)(a1 + 280) = 0;
  unint64_t v5 = (id *)(a1 + 288);
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_DWORD *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  uint64_t v6 = 0;
  *(void *)(a1 + 288) = *a2;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  do
  {
    NS::SharedPtr<MTL::Texture>::operator=((void **)(a1 + v6 + 296), (void **)(a3 + v6));
    v6 += 8;
  }
  while (v6 != 64);
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
  *(_DWORD *)(a1 + 384) = 0;
  *(void *)(a1 + 376) = 0;
  *(_DWORD *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 484) = 0u;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 440) = 0;
  *(_DWORD *)(a1 + 448) = 0;
  *(void *)(a1 + 500) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_DWORD *)(a1 + 544) = 0;
  *(void *)(a1 + 548) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_OWORD *)(a1 + 864) = 0u;
  *(_OWORD *)(a1 + 880) = 0u;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_OWORD *)(a1 + 905) = 0u;
  *(_DWORD *)(a1 + 924) = 2;
  *(void *)(a1 + 928) = 0;
  *(void *)(a1 + 944) = 0;
  *(void *)(a1 + 936) = 0;
  *(unsigned char *)(a1 + 952) = 0;
  re::makeMeshCollectionWithMeshPayload(v5, (id *)(a1 + 296), (uint64_t)v13);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(a1 + 248, (uint64_t)v13);
  re::DynamicArray<re::MeshModel>::deinit((uint64_t)v13);
  uint64_t v16 = 0;
  v13[1] = 0;
  uint64_t v14 = 0;
  v13[0] = 0;
  int v15 = 0;
  re::makeMeshAssetInstancesWithMeshPayload(v5, (uint64_t)v13);
  v12[0] = v16;
  v12[1] = v14;
  uint64_t v7 = *(void *)(a1 + 936);
  v11[0] = *(void *)(a1 + 944);
  v11[1] = v7;
  uint64_t v9 = re::globalAllocators(v8);
  re::MeshNameMap::init((uint64_t *)(a1 + 448), (re::_anonymous_namespace_::MeshCollectionAccessor *)(a1 + 248), (re::_anonymous_namespace_::MeshCollectionAccessor *)v12, (unint64_t)v11, v9[2]);
  re::makeBoundingBoxesWithMeshPayload(v5, (uint64_t *)(a1 + 872), (uint64_t *)(a1 + 896));
  re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)v13);
  return a1;
}

void re::MeshAsset::~MeshAsset(re::MeshAsset *this)
{
  *(void *)this = &unk_26E6CDC68;
  unint64_t v2 = (char *)this + 360;
  *((void *)this + 47) = 0;
  ++*((_DWORD *)this + 96);
  unint64_t v3 = (char *)this + 400;
  *((void *)this + 52) = 0;
  ++*((_DWORD *)this + 106);
  *((unsigned char *)this + 952) = 0;
  re::FixedArray<re::Skeleton>::deinit((void *)this + 116);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 112);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 109);
  re::MeshNameMap::~MeshNameMap((re::MeshAsset *)((char *)this + 448));
  re::DynamicArray<unsigned long>::deinit((uint64_t)v3);
  re::DynamicArray<unsigned long>::deinit((uint64_t)v2);
  for (uint64_t i = 352; i != 288; i -= 8)
  {
    unint64_t v5 = *(void **)((char *)this + i);
    if (v5)
    {

      *(void *)((char *)this + i) = 0;
    }
  }

  re::DynamicArray<re::MeshModel>::deinit((uint64_t)this + 248);
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)this + 208);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 168);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 128);
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)this + 88);
  re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)this + 48);
  re::DynamicArray<re::MeshAssetModel>::deinit((void *)this + 1);
}

{
  uint64_t vars8;

  re::MeshAsset::~MeshAsset(this);
  JUMPOUT(0x237DBCBD0);
}

void *re::FixedArray<re::Skeleton>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    unint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = (re::Skeleton *)result[2];
      uint64_t v5 = 160 * v2;
      do
      {
        re::Skeleton::~Skeleton(v4);
        uint64_t v4 = (re::Skeleton *)(v6 + 160);
        v5 -= 160;
      }
      while (v5);
      double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *unint64_t v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

void re::MeshAsset::replaceContentsWithMeshResourceDefinition(re::MeshAsset *a1, void *a2, Device **a3, re::MeshManager *a4, int a5)
{
  BOOL v8 = a2[30] != 0;
  *((unsigned char *)a1 + 920) = v8;
  int v11 = a5;
  BOOL v12 = v8;
  re::makeMeshPayloadWithMeshResourceDefinition(a2, a3, (uint64_t)&v11, &v10);
  LOBYTE(a4) = re::MeshAsset::replaceContentsWithPayload(a1, (id *)&v10, (id *)a3, a4);

  if ((a4 & 1) == 0)
  {
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) Unable to replace MeshAsset contents with a model definition", "success", "replaceContentsWithMeshResourceDefinition", 377);
    _os_crash();
    __break(1u);
  }
}

BOOL re::MeshAsset::replaceContentsWithPayload(re::MeshAsset *this, id *a2, id *a3, re::MeshManager *a4)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  *((unsigned char *)this + 952) = 0;
  if (*((void *)this + 50) && *((void *)this + 45))
  {
    re::MeshManager::destroyCollection((uint64_t (***)(void))a4, (void *)this + 45);
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + 400);
    re::DynamicArray<unsigned long>::deinit((uint64_t)this + 360);
  }
  re::FixedArray<re::Skeleton>::deinit((void *)this + 116);
  re::MeshNameMap::deinit((re::MeshAsset *)((char *)this + 448));
  *((void *)this + 2re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  ++*((_DWORD *)this + 48);
  re::ObjCObject::operator=((id *)this + 36, a2);
  re::MeshPayload::makeMeshPayloadBuffers(a2, a3, &v61);
  uint64_t v7 = (uint64_t *)((char *)this + 296);
  if ((long long *)((char *)this + 296) != &v61)
  {
    for (uint64_t i = 0; i != 8; ++i)
      NS::SharedPtr<MTL::Texture>::operator=((void **)&v7[i], (void **)((char *)&v61 + i * 8));
  }
  for (uint64_t j = 56; j != -8; j -= 8)
  {
    unint64_t v10 = *(void **)((char *)&v61 + j);
    if (v10)
    {

      *(void *)((char *)&v61 + j) = 0;
    }
  }
  uint64_t v11 = *v7;
  if (*v7)
  {
    uint64_t v38 = *v7;
    re::makeMeshCollectionWithMeshPayload(a2, (id *)this + 37, (uint64_t)&v61);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)this + 248, (uint64_t)&v61);
    re::DynamicArray<re::MeshModel>::deinit((uint64_t)&v61);
    uint64_t v52 = 0;
    v49[1] = 0;
    uint64_t v50 = 0;
    v49[0] = 0;
    int v51 = 0;
    re::makeMeshAssetSkeletonsWithMeshPayload(a2, (uint64_t)v49);
    *(void *)&long long v61 = v52;
    *((void *)&v61 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v50;
    re::MeshAsset::setSkeletons(this, &v61);
    uint64_t v48 = 0;
    v45[1] = 0;
    uint64_t v46 = 0;
    v45[0] = 0;
    int v47 = 0;
    re::makeMeshAssetInstancesWithMeshPayload(a2, (uint64_t)v45);
    *(void *)&long long v61 = v48;
    *((void *)&v61 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v46;
    uint64_t v12 = *((void *)this + 117);
    uint64_t v40 = *((void *)this + 118);
    uint64_t v41 = v12;
    uint64_t v14 = re::globalAllocators(v13);
    re::MeshNameMap::init((uint64_t *)this + 56, (re::MeshAsset *)((char *)this + 248), (re::_anonymous_namespace_::MeshCollectionAccessor *)&v61, (unint64_t)&v40, v14[2]);
    uint64_t v44 = 0;
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v40 = 0;
    int v43 = 0;
    uint64_t v15 = *((void *)this + 33);
    if (v15)
    {
      unint64_t v16 = 0;
      uint64_t v39 = *((void *)this + 33);
      do
      {
        unint64_t v17 = *((void *)this + 33);
        if (v17 <= v16)
        {
          uint64_t v53 = 0;
          long long v64 = 0u;
          long long v65 = 0u;
          long long v62 = 0u;
          long long v63 = 0u;
          long long v61 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v54 = 136315906;
          *(void *)&uint64_t v54[4] = "operator[]";
          __int16 v55 = 1024;
          int v56 = 797;
          __int16 v57 = 2048;
          unint64_t v58 = v16;
          __int16 v59 = 2048;
          unint64_t v60 = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v18 = *((void *)this + 35);
        uint64_t v19 = v18 + 816 * v16;
        uint64_t v20 = *(void *)(v19 + 176);
        if (v20 && (uint64_t v21 = *(void *)(v20 + 8)) != 0)
        {
          unint64_t v22 = 0;
          unint64_t v23 = 0;
          unint64_t v24 = 0;
          long long v25 = (void *)(v19 + 96);
          uint64_t v26 = v18 + 816 * v16;
          __int16 v27 = (unint64_t *)(v26 + 56);
          unint64_t v28 = (void *)(v26 + 64);
          do
          {
            uint64_t v29 = v25[10];
            if (v29
              && *(void *)(v29 + 8) > v22
              && (uint64_t v30 = *(unsigned __int8 *)(*(void *)(v29 + 16) + 72 * v22 + 2)) != 0)
            {
              if (v22 >= *v27) {
                uint64_t v31 = 0;
              }
              else {
                uint64_t v31 = *(unsigned int *)(*v28 + 560 * v22 + 468);
              }
              v24 += v31;
              v23 += v31 * (unint64_t)v30;
            }
            else
            {
              re::SkinningModelUtil::skinnedEndIndicesBuffer(v25, v22, v54);
              re::ReadOnlyCPUAccessibleBufferSliceContent::make(v54, (uint64_t)&v61);
              if ((_BYTE)v61)
              {
                v24 += (unint64_t)v62 >> 2;
                if ((unint64_t)v62 >= 4)
                {
                  uint64_t v32 = 0;
                  unint64_t v33 = (unint64_t)v62 >> 2;
                  __int16 v34 = (int *)*((void *)&v61 + 1);
                  if ((unint64_t)v62 >> 2 <= 1) {
                    unint64_t v33 = 1;
                  }
                  do
                  {
                    uint64_t v35 = *v34++;
                    unint64_t v23 = v23 - v32 + v35;
                    uint64_t v32 = v35;
                    --v33;
                  }
                  while (v33);
                }
              }
              re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(&v61);
              if (*(void *)v54) {
            }
              }
            ++v22;
          }
          while (v22 != v21);
          if (v24) {
            float v36 = (float)v23 / (float)v24;
          }
          else {
            float v36 = 0.0;
          }
          uint64_t v15 = v39;
        }
        else
        {
          float v36 = 0.0;
        }
        *(float *)&long long v61 = v36;
        re::DynamicArray<float>::add((_anonymous_namespace_ *)&v40, (float *)&v61);
        ++v16;
      }
      while (v16 != v15);
    }
    re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)this + 168, (uint64_t)&v40);
    if (v40 && v44) {
      (*(void (**)(void))(*(void *)v40 + 40))();
    }
    re::makeBoundingBoxesWithMeshPayload(a2, (uint64_t *)this + 109, (uint64_t *)this + 112);
    *((unsigned char *)this + 920) = [*a2 isLimitedRenderAsset];
    re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)v45);
    re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)v49);
    uint64_t v11 = v38;
  }
  return v11 != 0;
}

float32x4_t *re::MeshAsset::aabbFromMesh@<X0>(float32x4_t *result@<X0>, float32x4_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  *(void *)&long long v4 = 0x7F0000007FLL;
  *((void *)&v4 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0x7F0000007FLL;
  *(int32x4_t *)a3 = vdupq_n_s32(0x7F800000u);
  *(_OWORD *)(a3 + 16) = v4;
  if (result[27].i64[1])
  {
    uint64_t v5 = (uint64_t *)result;
    uint64_t v6 = result[23].u32[2];
    if (result[23].i32[2])
    {
      unint64_t v8 = 0;
      v9.i64[0] = 0x7F0000007FLL;
      v9.i64[1] = 0x7F0000007FLL;
      float32x4_t v24 = v9;
      float32x4_t v25 = (float32x4_t)vdupq_n_s32(0x7F800000u);
      do
      {
        unint64_t v10 = v5[47];
        if (v10 <= v8)
        {
          memset(v26, 0, sizeof(v26));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int16 v27 = 136315906;
          *(void *)&v27[4] = "operator[]";
          *(_WORD *)&v27[12] = 1024;
          *(_DWORD *)&v27[14] = 797;
          *(_WORD *)&v27[18] = 2048;
          *(void *)&v27[20] = v8;
          *(_WORD *)&v27[28] = 2048;
          *(void *)&v27[30] = v10;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        double result = (float32x4_t *)re::DataArray<re::MeshInstance>::tryGet(v5[55] + 72, *(void *)(v5[49] + 8 * v8));
        if (result)
        {
          uint64_t v11 = result;
          double result = (float32x4_t *)re::DataArray<re::MeshModel>::tryGet(v5[55] + 8, result[1].i64[0]);
          if (result)
          {
            unint64_t v12 = 0;
            float32x4_t v13 = *a2;
            float32x4_t v14 = a2[1];
            float32x4_t v15 = a2[2];
            float32x4_t v16 = a2[3];
            float32x4_t v17 = v11[3];
            float32x4_t v18 = v11[4];
            float32x4_t v19 = v11[5];
            *(float32x4_t *)__int16 v27 = v11[2];
            *(float32x4_t *)&unsigned char v27[16] = v17;
            *(float32x4_t *)&v27[32] = v18;
            float32x4_t v28 = v19;
            do
            {
              v26[v12 / 0x10] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v13, COERCE_FLOAT(*(_OWORD *)&v27[v12])), v14, *(float32x2_t *)&v27[v12], 1), v15, *(float32x4_t *)&v27[v12], 2), v16, *(float32x4_t *)&v27[v12], 3);
              v12 += 16;
            }
            while (v12 != 64);
            double result = re::AABB::transform(result + 1, v26, (uint64_t)v27);
            float32x4_t v21 = v24;
            float32x4_t v20 = v25;
            v20.i32[3] = 0;
            float32x4_t v22 = *(float32x4_t *)v27;
            float32x4_t v23 = *(float32x4_t *)&v27[16];
            v22.i32[3] = 0;
            v21.i32[3] = 0;
            v23.i32[3] = 0;
            float32x4_t v24 = vmaxnmq_f32(v21, v23);
            float32x4_t v25 = vminnmq_f32(v20, v22);
            *(float32x4_t *)a3 = v25;
            *(float32x4_t *)(a3 + 16) = v24;
          }
        }
        ++v8;
      }
      while (v8 != v6);
    }
  }
  return result;
}

uint64_t re::DataArray<re::MeshInstance>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (unsigned int v3 = *(_DWORD *)(a1 + 44)) : (unsigned int v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((uint64_t v4 = *(void *)(a1 + 32),
          (int v5 = *(_DWORD *)(*(void *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (BOOL v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (BOOL v6 = 0),
         v6)))
  {
    return *(void *)(v4 + 16 * WORD1(a2)) + 144 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

uint64_t re::DataArray<re::MeshModel>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (unsigned int v3 = *(_DWORD *)(a1 + 44)) : (unsigned int v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((uint64_t v4 = *(void *)(a1 + 32),
          (int v5 = *(_DWORD *)(*(void *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (BOOL v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (BOOL v6 = 0),
         v6)))
  {
    return *(void *)(v4 + 16 * WORD1(a2)) + 816 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

void re::MeshAsset::tightAABBFromMesh(uint64_t a1@<X0>, float32x4_t *a2@<X1>, float32x4_t *a3@<X8>)
{
  unsigned int v3 = a3;
  uint64_t v92 = *MEMORY[0x263EF8340];
  v4.i64[0] = 0x7F0000007FLL;
  v4.i64[1] = 0x7F0000007FLL;
  *(int32x4_t *)a3 = vdupq_n_s32(0x7F800000u);
  a3[1] = v4;
  if (*(void *)(a1 + 440))
  {
    int v5 = (void *)a1;
    uint64_t v56 = *(unsigned int *)(a1 + 376);
    if (*(_DWORD *)(a1 + 376))
    {
      unint64_t v6 = 0;
      float32x4_t v7 = (float32x4_t)vdupq_n_s32(0x7F800000u);
      v8.i64[0] = 0x7F0000007FLL;
      v8.i64[1] = 0x7F0000007FLL;
      float32x4_t v68 = v8;
      do
      {
        unint64_t v9 = v5[47];
        if (v9 <= v6)
        {
LABEL_51:
          *(void *)uint64_t v73 = 0;
          float32x4_t v90 = 0u;
          long long v91 = 0u;
          float32x4_t v88 = 0u;
          float32x4_t v89 = 0u;
          float32x4_t v87 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v78 = 136315906;
          *(void *)&v78[4] = "operator[]";
          *(_WORD *)&v78[12] = 1024;
          *(_DWORD *)&v78[14] = 797;
          *(_WORD *)&v78[18] = 2048;
          *(void *)&v78[20] = v6;
          *(_WORD *)&v78[28] = 2048;
          *(void *)&v78[30] = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_52:
          void v72[2] = 0;
          float32x4_t v90 = 0u;
          long long v91 = 0u;
          float32x4_t v88 = 0u;
          float32x4_t v89 = 0u;
          float32x4_t v87 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v80 = 136315906;
          *(void *)&v80[4] = "operator[]";
          __int16 v81 = 1024;
          int v82 = 476;
          __int16 v83 = 2048;
          unint64_t v84 = v9;
          __int16 v85 = 2048;
          unint64_t v86 = v6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        float32x4_t v69 = v7;
        uint64_t v10 = re::DataArray<re::MeshInstance>::tryGet(v5[55] + 72, *(void *)(v5[49] + 8 * v6));
        unint64_t v57 = v6;
        if (!v10) {
          goto LABEL_45;
        }
        uint64_t v11 = 0;
        float32x4_t v12 = *a2;
        float32x4_t v13 = a2[1];
        float32x4_t v14 = a2[2];
        float32x4_t v15 = a2[3];
        long long v16 = *(_OWORD *)(v10 + 48);
        long long v17 = *(_OWORD *)(v10 + 64);
        float32x4_t v18 = *(float32x4_t *)(v10 + 80);
        *(_OWORD *)uint64_t v78 = *(_OWORD *)(v10 + 32);
        *(_OWORD *)&v78[16] = v16;
        *(_OWORD *)&v78[32] = v17;
        float32x4_t v79 = v18;
        do
        {
          *(float32x4_t *)((char *)&v87 + v1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v12, COERCE_FLOAT(*(_OWORD *)&v78[v11])), v13, *(float32x2_t *)&v78[v11], 1), v14, *(float32x4_t *)&v78[v11], 2), v15, *(float32x4_t *)&v78[v11], 3);
          v11 += 16;
        }
        while (v11 != 64);
        float32x4_t v66 = v88;
        float32x4_t v67 = v87;
        float32x4_t v64 = v90;
        float32x4_t v65 = v89;
        uint64_t v19 = re::DataArray<re::MeshModel>::tryGet(v5[55] + 8, *(void *)(v10 + 16));
        if (v19)
        {
          uint64_t v20 = v19;
          float32x4_t v7 = v69;
          uint64_t v63 = *(unsigned int *)(v19 + 56);
          if (*(_DWORD *)(v19 + 56))
          {
            unint64_t v21 = 0;
            while (1)
            {
              unint64_t v6 = *(void *)(v20 + 56);
              if (v6 <= v21)
              {
                *(void *)uint64_t v73 = 0;
                float32x4_t v90 = 0u;
                long long v91 = 0u;
                float32x4_t v88 = 0u;
                float32x4_t v89 = 0u;
                float32x4_t v87 = 0u;
                unint64_t v9 = &_os_log_internal;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)uint64_t v78 = 136315906;
                *(void *)&v78[4] = "operator[]";
                *(_WORD *)&v78[12] = 1024;
                *(_DWORD *)&v78[14] = 476;
                *(_WORD *)&v78[18] = 2048;
                *(void *)&v78[20] = v21;
                *(_WORD *)&v78[28] = 2048;
                *(void *)&v78[30] = v6;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_49:
                *(void *)uint64_t v80 = 0;
                float32x4_t v90 = 0u;
                long long v91 = 0u;
                float32x4_t v88 = 0u;
                float32x4_t v89 = 0u;
                float32x4_t v87 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)uint64_t v73 = 136315906;
                *(void *)&v73[4] = "operator[]";
                *(_WORD *)&unsigned char v73[12] = 1024;
                *(_DWORD *)&v73[14] = 476;
                __int16 v74 = 2048;
                unint64_t v75 = v9;
                __int16 v76 = 2048;
                unint64_t v77 = v6;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_50:
                re::internal::assertLog((re::internal *)6, v35, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, int64_t size = %zu", "index < size()", "operator[]", 251, v9, v35);
                _os_crash();
                __break(1u);
                goto LABEL_51;
              }
              uint64_t v22 = 0;
              uint64_t v23 = *(void *)(v20 + 64);
              uint64_t v24 = v23 + 560 * v21;
              unint64_t v9 = *(unsigned __int8 *)(v24 + 477);
              long long v25 = *(_OWORD *)(v24 + 384);
              long long v26 = *(_OWORD *)(v24 + 400);
              float32x4_t v27 = *(float32x4_t *)(v24 + 416);
              *(_OWORD *)uint64_t v78 = *(_OWORD *)(v24 + 368);
              *(_OWORD *)&v78[16] = v25;
              *(_OWORD *)&v78[32] = v26;
              float32x4_t v79 = v27;
              do
              {
                *(float32x4_t *)((char *)&v87 + v22) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v67, COERCE_FLOAT(*(_OWORD *)&v78[v22])), v66, *(float32x2_t *)&v78[v22], 1), v65, *(float32x4_t *)&v78[v22], 2), v64, *(float32x4_t *)&v78[v22], 3);
                v22 += 16;
              }
              while (v22 != 64);
              *(float32x4_t *)uint64_t v78 = v87;
              *(float32x4_t *)&v78[16] = v88;
              *(float32x4_t *)&v78[32] = v89;
              float32x4_t v79 = v90;
              if (v9 == 255) {
                goto LABEL_42;
              }
              uint64_t v28 = v23 + 560 * v21;
              if (!*(_DWORD *)(v28 + 468)) {
                goto LABEL_42;
              }
              uint64_t v29 = v23 + 560 * v21;
              uint64_t v30 = (int *)(v28 + 468);
              uint64_t v31 = v29;
              do
              {
                uint64_t v32 = v31;
                uint64_t v31 = *(void *)(v31 + 8);
                unint64_t v6 = *(void *)(v32 + 32);
                if (v31) {
                  BOOL v33 = v6 == 0;
                }
                else {
                  BOOL v33 = 0;
                }
              }
              while (v33);
              if (v6 <= v9) {
                goto LABEL_49;
              }
              if (*(unsigned char *)(*(void *)(v32 + 40) + 16 * v9 + 12) != 30) {
                break;
              }
              float32x4_t v58 = v90;
              float32x4_t v59 = v89;
              float32x4_t v60 = v88;
              float32x4_t v61 = v87;
              float32x4_t v70 = v7;
              uint64_t v34 = re::AttributeTable::buffers((re::AttributeTable *)(v23 + 560 * v21));
              if (v35 <= v9) {
                goto LABEL_50;
              }
              uint64_t v36 = v34 + 16 * v9;
              id v37 = *(id *)v36;
              uint64_t v38 = *(void **)(v36 + 8);
              if (*(void *)v36) {
                id v37 = v37;
              }
              v72[0] = v37;
              v72[1] = v38;
              re::ReadOnlyCPUAccessibleBufferSliceContent::make(v72, (uint64_t)v73);
              int v39 = v73[0];
              if (v73[0])
              {
                do
                {
                  uint64_t v40 = v29;
                  uint64_t v29 = *(void *)(v29 + 8);
                  unint64_t v6 = *(void *)(v40 + 32);
                  if (v29) {
                    BOOL v41 = v6 == 0;
                  }
                  else {
                    BOOL v41 = 0;
                  }
                }
                while (v41);
                float32x4_t v43 = v68;
                float32x4_t v42 = v70;
                if (v6 <= v9) {
                  goto LABEL_52;
                }
                int v44 = *v30;
                if (*v30)
                {
                  uint64_t v45 = *(unsigned __int16 *)(*(void *)(v40 + 40) + 16 * v9);
                  uint64_t v46 = (float *)(*(void *)&v73[8] + 8);
                  unsigned int v3 = a3;
                  int v39 = v73[0];
                  do
                  {
                    float32x4_t v47 = vaddq_f32(v58, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v61, *(v46 - 2)), v60, *(v46 - 1)), v59, *v46));
                    float32x4_t v48 = vdivq_f32(v47, (float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3));
                    v42.i32[3] = 0;
                    v48.i32[3] = 0;
                    float32x4_t v42 = vminnmq_f32(v42, v48);
                    v43.i32[3] = 0;
                    float32x4_t v43 = vmaxnmq_f32(v43, v48);
                    uint64_t v46 = (float *)((char *)v46 + v45);
                    --v44;
                  }
                  while (v44);
                  float32x4_t v68 = v43;
                  float32x4_t v70 = v42;
                  *a3 = v42;
                  a3[1] = v43;
                }
                else
                {
                  unsigned int v3 = a3;
                  int v39 = v73[0];
                }
              }
              else
              {
                unsigned int v3 = a3;
              }
              re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(v73);
              if (v72[0]) {

              }
              float32x4_t v7 = v70;
              if (!v39) {
                goto LABEL_42;
              }
LABEL_43:
              if (++v21 == v63) {
                goto LABEL_46;
              }
            }
            unsigned int v3 = a3;
LABEL_42:
            float32x4_t v71 = v7;
            re::AABB::transform((float32x4_t *)(v23 + 560 * v21 + 432), (float32x4_t *)v78, (uint64_t)&v87);
            float32x4_t v49 = v68;
            float32x4_t v50 = v71;
            v50.i32[3] = 0;
            float32x4_t v51 = v87;
            float32x4_t v52 = v88;
            v51.i32[3] = 0;
            v49.i32[3] = 0;
            float32x4_t v7 = vminnmq_f32(v50, v51);
            v52.i32[3] = 0;
            float32x4_t v53 = vmaxnmq_f32(v49, v52);
            *unsigned int v3 = v7;
            v3[1] = v53;
            float32x4_t v68 = v53;
            goto LABEL_43;
          }
        }
        else
        {
LABEL_45:
          float32x4_t v7 = v69;
        }
LABEL_46:
        unint64_t v6 = v57 + 1;
        int v5 = (void *)a1;
      }
      while (v57 + 1 != v56);
    }
  }
}

uint64_t re::AttributeTable::buffers(re::AttributeTable *this)
{
  unint64_t v2 = (re::AttributeTable *)*((void *)this + 1);
  if (v2) {
    BOOL v3 = *((void *)this + 16) == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3) {
    return re::AttributeTable::buffers(v2);
  }
  else {
    return *((void *)this + 18);
  }
}

char **re::MeshAssetLoader::introspectionType(re::MeshAssetLoader *this)
{
  uint64_t v1 = &off_268773000;
  {
    uint64_t v1 = &off_268773000;
    if (v3)
    {
      re::introspect<re::MeshAsset>(void)::info = re::internal::getOrCreateInfo((re::internal *)"MeshAsset", (uint64_t (*)(re::internal *))re::allocInfo_MeshAsset, (re::IntrospectionBase *(*)(void))re::initInfo_MeshAsset, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::MeshAsset>, 0);
      uint64_t v1 = &off_268773000;
    }
  }
  return v1[151];
}

void re::DynamicArray<re::MeshAssetBlendShapeData>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    int v3 = *(re::StringID **)(a1 + 32);
    uint64_t v4 = 56 * v2;
    do
    {
      re::FixedArray<re::BlendShapeDefinition>::deinit((void *)v3 + 2);
      re::StringID::destroyString(v3);
      int v3 = (re::StringID *)((char *)v3 + 56);
      v4 -= 56;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

BOOL re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v9, a2);
  uint64_t v5 = 0x7FFFFFFFLL;
  if (*(void *)a1)
  {
    uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a1 + 16);
      uint64_t v5 = 0x7FFFFFFFLL;
      while (!re::DynamicString::operator==(v7 + 80 * v6 + 16, a2))
      {
        uint64_t v6 = *(_DWORD *)(v7 + 80 * v6 + 8) & 0x7FFFFFFF;
        if (v6 == 0x7FFFFFFF) {
          return v5 != 0x7FFFFFFF;
        }
      }
      uint64_t v5 = v6;
    }
  }
  return v5 != 0x7FFFFFFF;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew<char const*>(uint64_t a1, re::DynamicString *a2, const char **a3)
{
  unint64_t v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  unint64_t v7 = v6;
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v11 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<char const*&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 80 * v11;
    return v12 + 48;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 80 * v9 + 16, (uint64_t)a2))
  {
    uint64_t v9 = *(_DWORD *)(v10 + 80 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v10 + 80 * v9;
  return v12 + 48;
}

uint64_t re::MeshAsset::registerRuntimeData(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v49 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 248);
  *(unsigned char *)(a1 + 952) = 0;
  if (v4)
  {
    uint64_t v27 = a1 + 248;
    if (*(void *)(a1 + 288))
    {
      re::registerMeshCollectionWithMeshPayload(a1 + 248, (id *)(a1 + 288), a2, (uint64_t)v29);
      unint64_t v6 = (_OWORD *)(a1 + 360);
      if ((_OWORD *)(a1 + 360) == v29)
      {
LABEL_8:
        uint64_t v10 = *((void *)&v30 + 1);
        if (v6 == v29)
        {
LABEL_13:
          if (v10)
          {
            if (*((void *)&v32 + 1)) {
              (*(void (**)(uint64_t))(*(void *)v10 + 40))(v10);
            }
            *((void *)&v32 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
            long long v31 = 0uLL;
            *((void *)&v30 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
            LODWORD(v32) = v32 + 1;
          }
          if (*(void *)&v29[0] && (void)v30) {
            (*(void (**)(void))(**(void **)&v29[0] + 40))();
          }
LABEL_31:
          re::DynamicArray<re::MeshModel>::deinit(v27);
          uint64_t v2 = a2;
          goto LABEL_32;
        }
        uint64_t v11 = *(void *)(a1 + 400);
        if (!v11 || !*((void *)&v30 + 1) || v11 == *((void *)&v30 + 1))
        {
          *(void *)(a1 + 400) = *((void *)&v30 + 1);
          *((void *)&v30 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v11;
          long long v12 = *(_OWORD *)(a1 + 408);
          *(_OWORD *)(a1 + 408) = v31;
          long long v31 = v12;
          uint64_t v13 = *(void *)(a1 + 432);
          *(void *)(a1 + 432) = *((void *)&v32 + 1);
          *((void *)&v32 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v13;
          LODWORD(v32) = v32 + 1;
          uint64_t v10 = v11;
          ++*(_DWORD *)(a1 + 424);
          goto LABEL_13;
        }
LABEL_39:
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
        _os_crash();
        __break(1u);
      }
      uint64_t v7 = *(void *)v6;
      if (!*(void *)v6 || !*(void *)&v29[0] || v7 == *(void *)&v29[0])
      {
        *(void *)(a1 + 360) = *(void *)&v29[0];
        *(void *)&v29[0] = v7;
        long long v8 = *(_OWORD *)(a1 + 368);
        *(_OWORD *)(a1 + 368) = *(_OWORD *)((char *)v29 + 8);
        *(_OWORD *)((char *)v29 + 8) = v8;
        uint64_t v9 = *(void *)(a1 + 392);
        *(void *)(a1 + 392) = v30;
        *(void *)&long long v30 = v9;
        ++DWORD2(v29[1]);
        ++*(_DWORD *)(a1 + 384);
        goto LABEL_8;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(a1 + 264);
      if (v14)
      {
        float32x4_t v15 = *(uint64_t **)(a1 + 280);
        uint64_t v16 = 816 * v14;
        do
        {
          *(void *)&v29[0] = re::DataArray<re::MeshModel>::create<re::MeshModel>(v2 + 8, v15);
          re::DynamicArray<re::DataArrayHandle<re::MeshModel>>::add((void *)(a1 + 400), v29);
          v15 += 102;
          v16 -= 816;
        }
        while (v16);
      }
      uint64_t v17 = *(void *)(a1 + 64);
      if (!v17) {
        goto LABEL_31;
      }
      uint64_t v18 = *(void *)(a1 + 80);
      uint64_t v19 = v18 + 96 * v17;
      while (1)
      {
        re::StringID::StringID((re::StringID *)&v38, (const StringID *)v18);
        unint64_t v20 = *(unsigned int *)(v18 + 80);
        unint64_t v21 = *(void *)(a1 + 416);
        if (v21 <= v20) {
          break;
        }
        uint64_t v22 = *(void *)(*(void *)(a1 + 432) + 8 * v20);
        v29[0] = v38;
        *(void *)&long long v38 = 0;
        *((void *)&v38 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = "";
        *(void *)&v29[1] = 0xFFFFFFFFLL;
        BYTE8(v29[1]) = 0;
        HIDWORD(v29[1]) = 1065353216;
        long long v30 = 0u;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        re::DataArray<re::MeshModel>::tryGet(a2 + 8, v22);
        long long v23 = *(_OWORD *)(v18 + 64);
        long long v25 = *(_OWORD *)(v18 + 16);
        long long v24 = *(_OWORD *)(v18 + 32);
        long long v32 = *(_OWORD *)(v18 + 48);
        long long v33 = v23;
        long long v30 = v25;
        long long v31 = v24;
        *(void *)&v29[1] = v22;
        *((void *)&v29[1] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(void *)(v18 + 84);
        re::StringID::destroyString((re::StringID *)&v38);
        *(void *)&v48[0] = re::DataArray<re::MeshInstance>::create<re::MeshInstance>(a2 + 72, (uint64_t)v29);
        re::DynamicArray<re::DataArrayHandle<re::MeshModel>>::add((void *)(a1 + 360), v48);
        re::FixedArray<re::SharedPtr<re::MaterialParameterBlock>>::deinit((void *)&v35 + 1);
        if ((void)v34)
        {
          if (*((void *)&v34 + 1))
          {
            (*(void (**)(void))(*(void *)v34 + 40))();
            *((void *)&v34 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
            *(void *)&long long v35 = 0;
          }
          *(void *)&long long v34 = 0;
        }
        re::StringID::destroyString((re::StringID *)v29);
        v18 += 96;
        if (v18 == v19) {
          goto LABEL_31;
        }
      }
      uint64_t v39 = 0;
      memset(v48, 0, sizeof(v48));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v40 = 136315906;
      BOOL v41 = "operator[]";
      __int16 v42 = 1024;
      int v43 = 789;
      __int16 v44 = 2048;
      unint64_t v45 = v20;
      __int16 v46 = 2048;
      unint64_t v47 = v21;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
    _os_crash();
    __break(1u);
    goto LABEL_39;
  }
LABEL_32:
  *(void *)(a1 + 440) = v2;
  *(unsigned char *)(a1 + 952) = 1;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  memset(v29, 0, sizeof(v29));
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(a1 + 8, (uint64_t)v29);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(a1 + 48, (uint64_t)&v30 + 8);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(a1 + 88, (uint64_t)&v33);
  re::DynamicArray<re::RigComponentConstraint>::operator=(a1 + 128, (uint64_t)&v35 + 8);
  if (*((void *)&v35 + 1))
  {
    if (*((void *)&v37 + 1)) {
      (*(void (**)(void))(**((void **)&v35 + 1) + 40))();
    }
    *((void *)&v37 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    long long v36 = 0uLL;
    *((void *)&v35 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    LODWORD(v37) = v37 + 1;
  }
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v33);
  re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v30 + 8);
  re::DynamicArray<re::MeshAssetModel>::deinit(v29);
  return 0;
}

void *re::DynamicArray<re::DataArrayHandle<re::MeshModel>>::add(void *this, void *a2)
{
  int v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<float *>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  *(void *)(v3[4] + 8 * v4) = *a2;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

uint64_t re::DataArray<re::MeshModel>::get(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 32) + 16 * HIWORD(a2)) + 816 * (unsigned __int16)a2;
}

void re::MeshAssetLoader::~MeshAssetLoader(re::MeshAssetLoader *this)
{
  *(void *)this = &unk_26E6CDC88;
  *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 33);
  re::AssetHandle::~AssetHandle((re::MeshAssetLoader *)((char *)this + 216));
  re::AssetHandle::~AssetHandle((re::MeshAssetLoader *)((char *)this + 192));
  re::AssetHandle::~AssetHandle((re::MeshAssetLoader *)((char *)this + 168));
  re::AssetHandle::~AssetHandle((re::MeshAssetLoader *)((char *)this + 144));
  re::AssetHandle::~AssetHandle((re::MeshAssetLoader *)((char *)this + 120));
  re::AssetHandle::~AssetHandle((re::MeshAssetLoader *)((char *)this + 96));
  re::AssetHandle::~AssetHandle((re::MeshAssetLoader *)((char *)this + 72));
  re::AssetHandle::~AssetHandle((re::MeshAssetLoader *)((char *)this + 48));
}

{
  uint64_t vars8;

  re::MeshAssetLoader::~MeshAssetLoader(this);
  JUMPOUT(0x237DBCBD0);
}

void re::MeshAssetLoader::makeSharedResourcePayload(re::MeshAssetLoader *this@<X0>, void *a2@<X1>, re::AssetSerializationScheme *a3@<X2>, RESerializedPayload **a4@<X8>)
{
  long long v8 = (void *)*((void *)a2 + 36);
  if (v8 && [v8 isShareable])
  {
    *a4 = (RESerializedPayload *)*((id *)a2 + 36);
  }
  else
  {
    re::AssetLoader::makeSharedResourcePayload(this, (const re::IntrospectionBase **)a2, a3, a4);
  }
}

void re::MeshAssetLoader::resourceDidUpdate(uint64_t a1, re::MeshAsset *a2, id *a3, uint64_t a4)
{
  re::MeshPayload::dynamicCast(a3, &v12);
  if (v12)
  {
    re::MeshAsset::replaceContentsWithPayload(a2, &v12, (id *)(a1 + 8), *(re::MeshManager **)(a1 + 16));
    re::MeshAsset::registerRuntimeData((uint64_t)a2, *(void *)(a1 + 16));
  }
  else
  {
    uint64_t v9 = *re::assetsLogObjects(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_233120000, v9, OS_LOG_TYPE_DEFAULT, "Using fallback Mesh resourceDidUpdate, invalid MeshPayload found.", buf, 2u);
    }
    id v10 = *a3;
    re::AssetLoader::resourceDidUpdate(a1, (re::DynamicString **)a2, &v10, a4);
  }
}

uint64_t re::MeshAssetLoader::initializeAssetWithSerializedDataFromPayload(uint64_t a1, id *this, uint64_t a3, uint64_t a4, uint64_t a5)
{
  re::MeshPayload::dynamicCast(this, &v17);
  uint64_t v11 = v17;
  if (v17)
  {
    uint64_t v12 = 1;
  }
  else
  {
    uint64_t v13 = *re::assetsLogObjects(v10);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "Using fallback Mesh resourceDidUpdate, invalid MeshPayload found.", buf, 2u);
    }
    id v15 = *this;
    uint64_t v12 = re::AssetLoader::initializeAssetWithSerializedDataFromPayload(a1, &v15, a3, a4, a5, 0);

    uint64_t v11 = v17;
  }

  return v12;
}

uint64_t re::MeshAssetLoader::postInitializeAssetFromPayload(uint64_t a1, id *a2, re::MeshAsset *a3)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 24))
  {
    re::DirectMeshPayload::dynamicCast(a2, &v11);
    if (v11)
    {
      uint64_t v6 = *(void *)(a1 + 24);
      uint64_t v7 = re::DirectMeshPayload::connectionId(&v11);
      uuid_copy(dst, (const unsigned __int8 *)[v11 identifier]);
      if (re::DirectResourceAssetTracker::findResource(v6, v7, dst))
      {
        uint64_t v8 = DRResourceAsMesh();
        if (v8) {
          [v11 setDirectMesh:v8];
        }
      }
    }
  }
  re::MeshPayload::dynamicCast(a2, &v11);
  id v9 = v11;
  if (v11)
  {
    re::MeshAsset::replaceContentsWithPayload(a3, &v11, (id *)(a1 + 8), *(re::MeshManager **)(a1 + 16));
    id v9 = v11;
  }

  return 1;
}

uint64_t re::MeshAssetLoader::checkCredentialsOfNetworkAsset@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, _WORD *a4@<X8>)
{
  uint64_t result = re::ServiceLocator::serviceOrNull<re::EntitlementService>(*(void *)(a1 + 32));
  if (a2)
  {
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 64))(result, a3);
    }
    *a4 = 257;
  }
  else
  {
    *(unsigned char *)a4 = 0;
  }
  return result;
}

uint64_t re::ServiceLocator::serviceOrNull<re::EntitlementService>(uint64_t a1)
{
  {
    re::introspect<re::EntitlementService>(void)::info = re::introspect_EntitlementService(0);
  }
  uint64_t v2 = re::introspect<re::EntitlementService>(void)::info;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

void re::MeshAssetLoader::replaceAssetContentsWithMeshResourceDefinition(re::MeshAssetLoader *this, re::AssetHandle *a2, const re::MeshResourceDefinition *a3)
{
  uint64_t v4 = *((void *)a2 + 1);
  if (v4)
  {
    unsigned int v5 = atomic_load((unsigned int *)(v4 + 704));
    if (v5 == 2)
    {
      re::AssetHandle::mutateAssetCommon(a2);
      ++*(_DWORD *)(*((void *)a2 + 1) + 260);
      uint64_t v8 = (re::MeshAsset *)re::AssetHandle::loadedAsset<re::MeshAsset>(a2);
      if (v8)
      {
        uint64_t v9 = (uint64_t)v8;
        re::MeshAsset::replaceContentsWithMeshResourceDefinition(v8, a3, (Device **)this + 1, *((re::MeshManager **)this + 2), *((_DWORD *)this + 10));
        uint64_t v10 = *((void *)a2 + 1);
        if (!v10 || !*(unsigned char *)(v10 + 258))
        {
          re::MeshAsset::registerRuntimeData(v9, *((void *)this + 2));
          uint64_t v10 = *((void *)a2 + 1);
        }
        *(unsigned char *)(v10 + 256) = 1;
        re::internal::AssetEntry::updateMutatedRuntimeAssetSize((os_unfair_lock_s *)v10);
        re::internal::AssetEntry::updateMutatedAssetNonSharedDataSize(*((re::internal::AssetEntry **)a2 + 1));
      }
    }
  }
  re::AssetHandle::payloadDidChangeIfPossible(a2);
}

void re::MeshAssetLoader::replaceAssetContentsWithMeshPayload(uint64_t a1, re::internal::AssetEntry **a2, id *a3)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2[1];
  if (v4)
  {
    unsigned int v5 = atomic_load((unsigned int *)v4 + 176);
    if (v5 == 2)
    {
      re::AssetHandle::mutateAssetCommon((re::AssetHandle *)a2);
      ++*((_DWORD *)a2[1] + 65);
      uint64_t v8 = re::AssetHandle::loadedAsset<re::MeshAsset>((re::MeshAsset *)a2);
      if (v8)
      {
        uint64_t v9 = (re::MeshAsset *)v8;
        if (*(void *)(a1 + 24))
        {
          re::DirectMeshPayload::dynamicCast((id *)(v8 + 288), &v23);
          re::DirectMeshPayload::dynamicCast(a3, &v22);
          if (v23)
          {
            uint64_t v10 = re::DirectMeshPayload::connectionId(&v23);
            id v11 = (const unsigned __int8 *)[v23 identifier];
            uint64_t v28 = v10;
            uuid_copy(v29, v11);
            uint64_t v12 = *(void *)(a1 + 24);
            uint64_t v26 = v28;
            uuid_copy(v27, v29);
            uint64_t v13 = re::AssetHandle::assetInfo((re::AssetHandle *)a2);
            if (v13[10] == -1) {
              uint64_t v14 = 0;
            }
            else {
              uint64_t v14 = v13[10];
            }
            re::DirectResourceAssetTracker::unregisterDirectResourceBackedAsset(v12, (uint64_t)&v26, v14);
          }
          id v15 = v22;
          if (v22)
          {
            uint64_t v16 = re::DirectMeshPayload::connectionId(&v22);
            uint64_t v17 = (const unsigned __int8 *)[v22 identifier];
            uint64_t v28 = v16;
            uuid_copy(v29, v17);
            uint64_t v18 = *(void *)(a1 + 24);
            uint64_t v24 = v28;
            uuid_copy(v25, v29);
            uint64_t v19 = re::AssetHandle::assetInfo((re::AssetHandle *)a2);
            if (v19[10] == -1) {
              uint64_t v20 = 0;
            }
            else {
              uint64_t v20 = v19[10];
            }
            re::DirectResourceAssetTracker::registerDirectResourceBackedAsset(v18, (uint64_t)&v24, v20);
            id v15 = v22;
          }
        }
        re::MeshAsset::replaceContentsWithPayload(v9, a3, (id *)(a1 + 8), *(re::MeshManager **)(a1 + 16));
        unint64_t v21 = a2[1];
        if (!v21 || !*((unsigned char *)v21 + 258))
        {
          re::MeshAsset::registerRuntimeData((uint64_t)v9, *(void *)(a1 + 16));
          unint64_t v21 = a2[1];
        }
        *((unsigned char *)v21 + 256) = 1;
        re::internal::AssetEntry::updateMutatedRuntimeAssetSize((os_unfair_lock_s *)v21);
        re::internal::AssetEntry::updateMutatedAssetNonSharedDataSize(a2[1]);
      }
    }
  }
  re::AssetHandle::payloadDidChangeIfPossible((re::AssetHandle *)a2);
}

uint64_t re::MeshAssetLoader::findDependencies@<X0>(uint64_t *a1@<X1>, uint64_t a2@<X8>)
{
  return re::DynamicArray<re::AssetHandle>::DynamicArray(a2, a1 + 26);
}

void *re::MeshAssetLoader::internalFindAssetHandleFields@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
  uint64_t v4 = a1[28];
  if (v4)
  {
    uint64_t v5 = a1[30];
    uint64_t v6 = 24 * v4;
    do
    {
      uint64_t v8 = v5;
      uint64_t result = re::DynamicArray<re::TransitionCondition *>::add((void *)a2, &v8);
      v5 += 24;
      v6 -= 24;
    }
    while (v6);
  }
  return result;
}

void re::MeshAssetLoader::init(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = (id *)re::ServiceLocator::serviceOrNull<re::RenderManager>(a2);
  uint64_t v9 = v8;
  if (v8) {
    uint64_t v8 = (id *)v8[23];
  }
  id v11 = v8;
  re::ObjCObject::operator=((id *)(a1 + 8), (id *)&v11);

  if (!v9)
  {
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = a3;
    *(void *)(a1 + 32) = a2;
    if (a4) {
      goto LABEL_8;
    }
LABEL_9:
    int v10 = 0;
    goto LABEL_10;
  }
  *(void *)(a1 + 16) = v9[4];
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = a2;
  if (!a4) {
    goto LABEL_9;
  }
  if (([*(id *)(a1 + 8) supportsBufferWithIOSurface] & 1) == 0)
  {
LABEL_8:
    int v10 = 1;
    goto LABEL_10;
  }
  int v10 = 2;
LABEL_10:
  *(_DWORD *)(a1 + 40) = v10;
}

re *re::MeshAssetLoader::unloadAsset(re::MeshAssetLoader *this, void (***a2)(void))
{
  return re::internal::destroyPersistent<re::MeshAsset>((re *)"unloadAsset", 961, a2);
}

uint64_t re::MeshAssetLoader::createRuntimeData(uint64_t a1, uint64_t a2)
{
  uint64_t v75 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = (re *)(a1 + 8);
  int v4 = *((_DWORD *)v2 + 8);
  *(unsigned char *)(a2 + 952) = 0;
  if (!v3) {
    return 1;
  }
  if (*(void *)(a2 + 376) || *(void *)(a2 + 64) == 0) {
    return 1;
  }
  int v59 = v4;
  float32x4_t v60 = v2;
  unint64_t v61 = *(void *)(a2 + 64);
  if ((dyld_program_sdk_at_least() & 1) == 0)
  {
    uint64_t v7 = *(void *)(a2 + 24);
    if (v7)
    {
      uint64_t v8 = *(void *)(a2 + 40);
      uint64_t v62 = v8 + (v7 << 9);
      do
      {
        re::DynamicArray<re::MeshAssetBlendShapeData>::clear(v8 + 112);
        uint64_t v9 = *(void *)(v8 + 208);
        if (v9)
        {
          uint64_t v10 = *(void *)(v8 + 224);
          uint64_t v11 = v10 + (v9 << 8);
          do
          {
            uint64_t v12 = *(void *)(v10 + 16);
            if (v12)
            {
              char v13 = 0;
              uint64_t v14 = 80 * v12;
              id v15 = (void *)(*(void *)(v10 + 32) + 16);
              while (1)
              {
                uint64_t v16 = (*(v15 - 1) & 1) != 0 ? (const char *)*v15 : (char *)v15 - 7;
                if (!strcmp(v16, "vertexUV1")) {
                  break;
                }
                uint64_t v17 = (_anonymous_namespace_ *)strcmp(v16, "vertexUV");
                v13 |= v17 == 0;
                v15 += 10;
                v14 -= 80;
                if (!v14)
                {
                  if (v13)
                  {
                    BOOL v18 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(v10 + 200, (uint64_t)&v70);
                    uint64_t v19 = (_anonymous_namespace_ *)v70;
                    if (void)v70 && (BYTE8(v70)) {
                      uint64_t v19 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v70 + 40))();
                    }
                    if (!v18)
                    {
                      *(void *)uint64_t v63 = "vertexUV";
                      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew<char const*>(v10 + 200, (re::DynamicString *)&v70, (const char **)v63);
                      if ((void)v70)
                      {
                        if (BYTE8(v70)) {
                          (*(void (**)(void))(*(void *)v70 + 40))();
                        }
                      }
                    }
                  }
                  break;
                }
              }
            }
            v10 += 256;
          }
          while (v10 != v11);
        }
        v8 += 512;
      }
      while (v8 != v62);
    }
  }
  if (!*(void *)(a2 + 936))
  {
    uint64_t v20 = a2 + 88;
    if (!*(void *)(a2 + 104))
    {
      uint64_t v21 = *(void *)(a2 + 24);
      if (v21)
      {
        uint64_t v22 = *(void *)(a2 + 40) + 232;
        while (!*(void *)(v22 + 16))
        {
          v22 += 512;
          if (!--v21) {
            goto LABEL_36;
          }
        }
        uint64_t v20 = v22;
      }
    }
LABEL_36:
    uint64_t v23 = *(void *)(v20 + 32);
    uint64_t v24 = *(void *)(v20 + 16);
    *(void *)&long long v70 = v23;
    *((void *)&v70 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v24;
    re::MeshAsset::setSkeletons((void *)a2, &v70);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF77028, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF77028))
  {
    re::Defaults::BOOLValue((re::Defaults *)"EnableMeshPayload", v57, (char *)&v70);
    if ((_BYTE)v70) {
      char v58 = BYTE1(v70);
    }
    else {
      char v58 = 1;
    }
    _MergedGlobals_62 = v58;
    __cxa_guard_release(&qword_26AF77028);
  }
  uint64_t v25 = *(void *)(a2 + 24);
  if (v25)
  {
    uint64_t v26 = v25 << 9;
    uint64_t v27 = (void *)(*(void *)(a2 + 40) + 488);
    while (!*(v27 - 20) && !*(v27 - 15) && !*(v27 - 10) && !*(v27 - 5) && !*v27)
    {
      v27 += 64;
      v26 -= 512;
      if (!v26) {
        goto LABEL_46;
      }
    }
    goto LABEL_59;
  }
LABEL_46:
  if (!_MergedGlobals_62)
  {
LABEL_59:
    re::createMeshCollectionFromMeshAsset(v60, (const re::mtl::Device *)(a2 + 8), (uint64_t)&v70);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(a2 + 248, (uint64_t)&v70);
    re::DynamicArray<re::MeshModel>::deinit((uint64_t)&v70);
LABEL_60:
    long long v33 = (re *)re::MeshNameMap::deinit((re::MeshNameMap *)(a2 + 448));
    long long v34 = *(re::_anonymous_namespace_::MeshAssetAccessor **)(a2 + 80);
    unint64_t v35 = *(void *)(a2 + 64);
    long long v36 = re::globalAllocators(v33);
    re::MeshNameMap::init(a2 + 448, (re::_anonymous_namespace_::MeshAssetDataAccessor *)(a2 + 8), v34, v35, v36[2]);
    uint64_t v37 = *(void *)(a2 + 784);
    if (v37) {
      unint64_t v38 = *(unsigned int *)(*(void *)(a2 + 792) + 4 * v37 - 4);
    }
    else {
      unint64_t v38 = 0;
    }
    re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(a2 + 872));
    unint64_t v39 = a2 + 896;
    int v40 = (_anonymous_namespace_ *)re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(a2 + 896));
    unint64_t v42 = 0;
    uint64_t v43 = 0;
LABEL_64:
    unint64_t v44 = *(void *)(a2 + 64);
    if (v44 <= v42)
    {
      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v70 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v63 = 136315906;
      *(void *)&v63[4] = "operator[]";
      __int16 v64 = 1024;
      int v65 = 789;
      __int16 v66 = 2048;
      unint64_t v67 = v42;
      __int16 v68 = 2048;
      unint64_t v69 = v44;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_82:
      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v70 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v63 = 136315906;
      *(void *)&v63[4] = "operator[]";
      __int16 v64 = 1024;
      int v65 = 789;
      __int16 v66 = 2048;
      unint64_t v67 = v44;
      __int16 v68 = 2048;
      unint64_t v69 = v39;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_83:
      long long v73 = 0u;
      long long v74 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v70 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)uint64_t v63 = 136315906;
      *(void *)&v63[4] = "operator[]";
      __int16 v64 = 1024;
      int v65 = 468;
      __int16 v66 = 2048;
      unint64_t v67 = v42;
      __int16 v68 = 2048;
      unint64_t v69 = v39;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    unint64_t v44 = *(unsigned int *)(*(void *)(a2 + 80) + 96 * v42 + 80);
    unint64_t v39 = *(void *)(a2 + 24);
    if (v39 <= v44) {
      goto LABEL_82;
    }
    unint64_t v39 = *(void *)(a2 + 880);
    if (v39 <= v42) {
      goto LABEL_83;
    }
    uint64_t v45 = *(void *)(a2 + 40) + (v44 << 9);
    __int16 v46 = (_OWORD *)(*(void *)(a2 + 888) + 32 * v42);
    long long v47 = *(_OWORD *)(v45 + 32);
    *__int16 v46 = *(_OWORD *)(v45 + 16);
    v46[1] = v47;
    float32x4_t v48 = (unint64_t *)(v45 + 208);
    uint64_t v49 = *(void *)(v45 + 208);
    if (!v49) {
      goto LABEL_73;
    }
    uint64_t v50 = 0;
    unint64_t v51 = 0;
    float32x4_t v52 = (void *)(v45 + 224);
    while (1)
    {
      unint64_t v39 = *v48;
      if (*v48 <= v51) {
        break;
      }
      unint64_t v39 = *(void *)(a2 + 904);
      if (v39 <= v43 + v51) {
        goto LABEL_79;
      }
      uint64_t v53 = *v52 + 8 * v50;
      uint64_t v54 = (_OWORD *)(*(void *)(a2 + 912) + 32 * v43 + v50);
      long long v55 = *(_OWORD *)(v53 + 112);
      *uint64_t v54 = *(_OWORD *)(v53 + 96);
      v54[1] = v55;
      ++v51;
      v50 += 32;
      if (v49 == v51)
      {
        v43 += v51;
LABEL_73:
        if (++v42 == v61)
        {
          if (!*(void *)(a2 + 144)) {
            re::MeshAssetData::generateMetaData((re::MeshAssetData *)(a2 + 8));
          }
          re::DynamicArray<float>::operator=(a2 + 168, (uint64_t *)(a2 + 128));
          return 1;
        }
        goto LABEL_64;
      }
    }
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v70 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v63 = 136315906;
    *(void *)&v63[4] = "operator[]";
    __int16 v64 = 1024;
    int v65 = 797;
    __int16 v66 = 2048;
    unint64_t v67 = v51;
    __int16 v68 = 2048;
    unint64_t v69 = v39;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_79:
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v70 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v63 = 136315906;
    *(void *)&v63[4] = "operator[]";
    __int16 v64 = 1024;
    int v65 = 468;
    __int16 v66 = 2048;
    unint64_t v67 = v43 + v51;
    __int16 v68 = 2048;
    unint64_t v69 = v39;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    return 0;
  }
  if (*(void *)(a2 + 288)) {
    goto LABEL_91;
  }
  *(_DWORD *)uint64_t v63 = v59;
  v63[4] = *(unsigned char *)(a2 + 920);
  uint64_t v28 = operator new(0x20uLL);
  *uint64_t v28 = &unk_26E6CDDF0;
  v28[1] = a2;
  _OWORD v28[2] = v60;
  void v28[3] = v63;
  *((void *)&v71 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v28;
  re::runInLocalAutoreleasePool((uint64_t)&v70);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](&v70);
  if (*(void *)(a2 + 288))
  {
LABEL_91:
    if (*(void *)(a2 + 296)) {
      goto LABEL_58;
    }
    uint64_t v29 = (void *)(a2 + 296);
    re::MeshPayload::makeMeshPayloadBuffers((id *)(a2 + 288), (id *)v60, &v70);
    if ((long long *)(a2 + 296) != &v70)
    {
      for (uint64_t i = 0; i != 8; ++i)
        NS::SharedPtr<MTL::Texture>::operator=((void **)&v29[i], (void **)((char *)&v70 + i * 8));
    }
    for (uint64_t j = 56; j != -8; j -= 8)
    {
      long long v32 = *(void **)((char *)&v70 + j);
      if (v32)
      {

        *(void *)((char *)&v70 + j) = 0;
      }
    }
    if (*v29)
    {
LABEL_58:
      *(void *)&long long v70 = &unk_26E6CDE70;
      *((void *)&v70 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = a2;
      *((void *)&v71 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = &v70;
      re::runInLocalAutoreleasePool((uint64_t)&v70);
      std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](&v70);
      goto LABEL_60;
    }
  }
  return 0;
}

uint64_t re::MeshAssetLoader::assetByteSize(re::MeshAssetLoader *this, void *a2)
{
  uint64_t v4 = (*(uint64_t (**)(re::MeshAssetLoader *))(*(void *)this + 40))(this);
  uint64_t v5 = (void *)a2[36];
  if (v5)
  {
    v4 += [v5 totalPayloadSize];
  }
  else if (re::ServiceLocator::serviceOrNull<re::RenderManager>(*((void *)this + 4)))
  {
    uint64_t v7 = re::ServiceLocator::service<re::RenderManager>(*((void *)this + 4));
    uint64_t v8 = a2[52];
    if (v8)
    {
      uint64_t v9 = *(void *)(v7 + 32) + 8;
      uint64_t v10 = (void *)a2[54];
      uint64_t v11 = &v10[v8];
      do
      {
        uint64_t v12 = re::DataArray<re::MeshModel>::get(v9, *v10);
        uint64_t v13 = *(void *)(v12 + 56);
        if (v13)
        {
          uint64_t v14 = *(re::AttributeTable **)(v12 + 64);
          id v15 = (re::AttributeTable *)((char *)v14 + 560 * v13);
          do
          {
            uint64_t v16 = re::AttributeTable::buffers(v14);
            if (v17)
            {
              uint64_t v18 = 16 * v17;
              uint64_t v19 = (unsigned int *)(v16 + 12);
              do
              {
                unsigned int v20 = *v19;
                v19 += 4;
                v4 += v20;
                v18 -= 16;
              }
              while (v18);
            }
            uint64_t v14 = (re::AttributeTable *)((char *)v14 + 560);
          }
          while (v14 != v15);
        }
        ++v10;
      }
      while (v10 != v11);
    }
  }
  return v4;
}

uint64_t re::MeshAssetLoader::prepareAssetForSerialization(re::MeshAssetLoader *this, const re::MeshAsset *a2)
{
  if (!*((unsigned char *)a2 + 952)) {
    return 0;
  }
  re::MeshAsset::makeMeshAssetDataFromRegisteredMeshAsset((re::MeshAsset *)v4, a2);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)a2 + 8, (uint64_t)v4);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)a2 + 48, (uint64_t)v5);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)a2 + 88, (uint64_t)v6);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a2 + 128, (uint64_t)v7);
  if (v7[0])
  {
    if (v9) {
      (*(void (**)(void))(*(void *)v7[0] + 40))();
    }
    uint64_t v9 = 0;
    memset(v7, 0, sizeof(v7));
    ++v8;
  }
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)v6);
  re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)v5);
  re::DynamicArray<re::MeshAssetModel>::deinit(v4);
  return 2;
}

uint64_t re::MeshAsset::makeMeshAssetDataFromRegisteredMeshAsset(re::MeshAsset *this, const re::MeshAsset *a2)
{
  uint64_t v138 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)a2 + 952))
  {
    re::DynamicArray<re::MeshAssetModel>::DynamicArray((uint64_t)this, (uint64_t *)a2 + 1);
    re::DynamicArray<re::MeshAssetInstance>::DynamicArray((uint64_t)this + 40, (uint64_t *)a2 + 6);
    re::DynamicArray<re::MeshAssetSkeleton>::DynamicArray((uint64_t)this + 80, (uint64_t *)a2 + 11);
    return re::DynamicArray<float>::DynamicArray((uint64_t)this + 120, (uint64_t *)a2 + 16);
  }
  uint64_t v4 = v96;
  v96[0] = 0;
  v96[1] = 0;
  int v98 = 0;
  unint64_t v97 = 0;
  uint64_t v107 = 0;
  long long v99 = 0u;
  long long v100 = 0u;
  int v101 = 0;
  memset(v102, 0, sizeof(v102));
  int v103 = 0;
  long long v104 = 0u;
  long long v105 = 0u;
  int v106 = 0;
  uint64_t v5 = *((void *)a2 + 52);
  unint64_t v6 = *((unsigned int *)a2 + 94);
  uint64_t v90 = *((void *)a2 + 55);
  uint64_t v91 = v5;
  re::DynamicArray<re::MeshAssetModel>::resize((uint64_t)v96, v5);
  unint64_t v88 = v6;
  re::DynamicArray<re::MeshAssetInstance>::resize((uint64_t)&v99 + 8, v6);
  unsigned int v94 = 0;
  long long v92 = 0u;
  long long v93 = 0u;
  uint64_t v95 = 0x7FFFFFFFLL;
  if (v5) {
    signed int v8 = 2 * v5;
  }
  else {
    signed int v8 = 1;
  }
  uint64_t v10 = *((void *)a2 + 55);
  if (!v10)
  {
    unsigned int v20 = "No Mesh Manager on MeshAsset";
LABEL_30:
    LOBYTE(v112[0]) = 0;
    *((void *)&v112[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 100;
    *(void *)&v112[1] = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)((char *)&v112[1] + 8) = v118[0];
    *(_OWORD *)((char *)&v112[2] + 8) = v118[1];
    goto LABEL_31;
  }
  unint64_t v11 = *((void *)a2 + 117);
  uint64_t v12 = *((void *)a2 + 52);
  if (v12)
  {
    uint64_t v13 = v10 + 8;
    uint64_t v14 = (void *)*((void *)a2 + 54);
    uint64_t v15 = 8 * v12;
    while (1)
    {
      uint64_t v9 = (_anonymous_namespace_ *)re::DataArray<re::MeshModel>::get(v13, *v14);
      uint64_t v16 = *((void *)v9 + 22);
      if (v16)
      {
        if (*(void *)(v16 + 8)) {
          break;
        }
      }
      ++v14;
      v15 -= 8;
      if (!v15) {
        goto LABEL_11;
      }
    }
    uint64_t v21 = v16 + 32;
    uint64_t v17 = *(void *)(v16 + 32);
    uint64_t v18 = *(void *)(v21 + 8);
  }
  else
  {
LABEL_11:
    uint64_t v17 = 0;
    uint64_t v18 = 0;
  }
  if (v17 != v11)
  {
    unsigned int v20 = "Inverse bind transforms array doesn't match skeleton count";
    goto LABEL_30;
  }
  *(void *)&v137[2] = 0;
  memset(v135, 0, sizeof(v135));
  re::DynamicArray<re::MeshAssetSkeleton>::resize((uint64_t)v135, v11);
  if (!v11)
  {
LABEL_28:
    uint64_t v33 = *(void *)v135;
    memset(v135, 0, 24);
    uint64_t v34 = *(void *)&v137[2];
    *(void *)&v137[2] = 0;
    ++*(_DWORD *)&v135[24];
    LOBYTE(v112[0]) = 1;
    *((void *)&v112[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v33;
    memset(v118, 0, 24);
    v112[1] = *(_OWORD *)&v135[8];
    *((void *)&v112[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v34;
    *(void *)&long long v119 = 0;
    DWORD2(v118[1]) = 2;
    LODWORD(v112[2]) = 1;
    re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)v118);
    goto LABEL_38;
  }
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = (id *)(v18 + 8);
  while (1)
  {
    unint64_t v25 = *(void *)&v135[16];
    if (*(void *)&v135[16] <= (unint64_t)v23) {
      goto LABEL_88;
    }
    uint64_t v26 = *(void *)&v137[2];
    uint64_t v27 = *(void *)&v137[2] + v22;
    uint64_t v28 = (uint64_t *)re::MeshAsset::skeletonAtIndex(a2, (unint64_t)v23);
    re::StringID::operator=((unint64_t *)(v26 + v22), v28);
    uint64_t v29 = v28[3];
    *(void *)&v118[0] = v28[4];
    *((void *)&v118[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v29;
    re::FixedArray<re::StringID>::operator=((_anonymous_namespace_ *)(v27 + 16), (uint64_t)v118);
    uint64_t v30 = v28[6];
    *(void *)&v118[0] = v28[7];
    *((void *)&v118[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v30;
    re::FixedArray<int>::operator=((_anonymous_namespace_ *)(v27 + 40), (uint64_t)v118);
    uint64_t v31 = v28[9];
    *(void *)&v118[0] = v28[10];
    *((void *)&v118[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v31;
    re::FixedArray<re::GenericSRT<float>>::operator=((_anonymous_namespace_ *)(v27 + 64), (uint64_t)v118);
    v111[0] = *(v24 - 1);
    v111[1] = *v24;
    if (v111[0]) {
      break;
    }
LABEL_27:
    uint64_t v23 = (long long *)((char *)v23 + 1);
    v22 += 112;
    v24 += 2;
    if ((long long *)v11 == v23) {
      goto LABEL_28;
    }
  }
  re::ReadOnlyCPUAccessibleBufferSliceContent::make(v111, (uint64_t)v118);
  if (!LOBYTE(v118[0]))
  {
    unint64_t v35 = "Could not access inverset bind pose data";
    goto LABEL_36;
  }
  if (*(void *)&v118[1] < 0x40uLL || *(void *)(v26 + v22 + 48) == *(void *)&v118[1] >> 6)
  {
    *(void *)&v112[0] = *((void *)&v118[0] + 1);
    *((void *)&v112[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(void *)&v118[1] >> 6;
    re::FixedArray<re::Matrix4x4<float>>::operator=((_anonymous_namespace_ *)(v26 + v22 + 88), (uint64_t)v112);
    re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(v118);
    if (v111[0]) {

    }
    goto LABEL_27;
  }
  unint64_t v35 = "Inverse bind pose count does not match joint count";
LABEL_36:
  LOBYTE(v112[0]) = 0;
  *((void *)&v112[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 100;
  *(void *)&v112[1] = re::AssetErrorCategory(void)::instance;
  *(_OWORD *)((char *)&v112[1] + 8) = v108;
  *((void *)&v112[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v109;
  *(void *)&v112[3] = v110;
  re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(v118);
  if (v111[0]) {

  }
LABEL_38:
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)v135);
  if (LOBYTE(v112[0]))
  {
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v102[1], (uint64_t)v112 + 8);
    if (LOBYTE(v112[0]))
    {
      re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)v112 + 8);
      goto LABEL_41;
    }
  }
LABEL_31:
  if (*((void *)&v112[1] + 1) && (v112[2] & 1) != 0) {
    (*(void (**)(void))(**((void **)&v112[1] + 1) + 40))();
  }
LABEL_41:
  re::DirectMeshPayload::dynamicCast((id *)a2 + 36, v118);
  uint64_t v4 = *(uint64_t **)&v118[0];

  if (v5)
  {
    unint64_t v36 = 0;
    uint64_t v23 = &v119;
    unint64_t v25 = 0x7FFFFFFFLL;
    while (1)
    {
      unint64_t v37 = *((void *)a2 + 52);
      if (v37 <= v36) {
        break;
      }
      unint64_t v38 = (const re::MeshModel *)re::DataArray<re::MeshModel>::get(v90 + 8, *(void *)(*((void *)a2 + 54) + 8 * v36));
      if (!LOBYTE(v118[0]))
      {
        long long v82 = v119;
        long long v119 = 0uLL;
        long long v83 = v120;
        long long v120 = 0uLL;
        LOBYTE(v112[0]) = 0;
        *(_OWORD *)((char *)v112 + 8) = v118[1];
        *(_OWORD *)((char *)&v112[1] + 8) = v82;
        *(_OWORD *)((char *)&v112[2] + 8) = v83;
        re::Result<re::MeshAssetModel,re::DetailedError>::~Result(v118);
        goto LABEL_77;
      }
      unint64_t v37 = v97;
      if (v97 <= v36) {
        goto LABEL_86;
      }
      uint64_t v39 = v99 + (v36 << 9);
      long long v40 = v118[1];
      *((void *)&v118[1] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = "";
      *(void *)&v118[1] = 0;
      uint64_t v41 = *(void *)(v39 + 8);
      unint64_t v42 = v40 & 0xFFFFFFFFFFFFFFFELL | *(void *)v39 & 1;
      *(void *)(v39 + 8) = *((void *)&v40 + 1);
      *(void *)&v112[0] = v42;
      *((void *)&v112[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v41;
      *(void *)uint64_t v39 = v40;
      re::StringID::destroyString((re::StringID *)v112);
      long long v43 = v120;
      *(_OWORD *)(v39 + 16) = v119;
      *(_OWORD *)(v39 + 32) = v43;
      long long v44 = *(_OWORD *)v121;
      long long v45 = *(_OWORD *)&v121[16];
      long long v46 = v122;
      *(_OWORD *)(v39 + 80) = *(_OWORD *)&v121[32];
      *(_OWORD *)(v39 + 96) = v46;
      *(_OWORD *)(v39 + 48) = v44;
      *(_OWORD *)(v39 + 64) = v45;
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v39 + 112, (uint64_t)&v123);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v39 + 152, (uint64_t)&v126);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v39 + 192, (uint64_t)&v127);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v39 + 232, (uint64_t)&v128);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v39 + 272, (uint64_t)&v129);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v39 + 312, (uint64_t)&v130);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v39 + 352, (uint64_t)&v131);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v39 + 392, (uint64_t)&v132);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v39 + 432, (uint64_t)&v133);
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v39 + 472, (uint64_t)&v134);
      unint64_t v37 = *((void *)a2 + 52);
      if (v37 <= v36) {
        goto LABEL_87;
      }
      uint64_t v47 = *((void *)a2 + 54);
      uint64_t v48 = *(void *)(v47 + 8 * v36);
      unint64_t v49 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v48 & 0xFFFFFF)) ^ ((0xBF58476D1CE4E5B9 * (v48 & 0xFFFFFF)) >> 27));
      unint64_t v50 = v49 ^ (v49 >> 31);
      unint64_t v51 = v92;
      if (!(void)v92
        || (unint64_t v51 = v50 % DWORD2(v93), v52 = *(unsigned int *)(*((void *)&v92 + 1) + 4 * v51), v52 == 0x7FFFFFFF))
      {
LABEL_53:
        uint64_t v56 = v95;
        if (v95 == 0x7FFFFFFF)
        {
          uint64_t v56 = v94;
          unsigned int v57 = v94;
          if (v94 == DWORD2(v93))
          {
            re::HashTable<re::DataArrayHandle<re::MeshModel>,unsigned int,re::Hash<re::DataArrayHandle<re::MeshModel>>,re::EqualTo<re::DataArrayHandle<re::MeshModel>>,true,false>::setCapacity((uint64_t)&v92, 2 * HIDWORD(v93));
            unsigned int v57 = v94;
            unint64_t v51 = v50 % DWORD2(v93);
          }
          unsigned int v94 = v57 + 1;
          uint64_t v58 = v93;
          int v59 = *(_DWORD *)(v93 + 32 * v56 + 8);
        }
        else
        {
          uint64_t v58 = v93;
          int v59 = *(_DWORD *)(v93 + 32 * v95 + 8);
          LODWORD(v95) = v59 & 0x7FFFFFFF;
        }
        uint64_t v60 = v58 + 32 * v56;
        *(_DWORD *)(v60 + 8) = v59 | 0x80000000;
        uint64_t v61 = *((void *)&v92 + 1);
        *(_DWORD *)(v60 + 8) = *(_DWORD *)(*((void *)&v92 + 1) + 4 * v51) | 0x80000000;
        *(void *)uint64_t v60 = v50;
        *(void *)(v60 + 16) = *(void *)(v47 + 8 * v36);
        *(_DWORD *)(v60 + 24) = v36;
        *(_DWORD *)(v61 + 4 * v5re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v56;
        ++HIDWORD(v93);
        ++HIDWORD(v95);
      }
      else
      {
        while (1)
        {
          uint64_t v53 = v93 + 32 * v52;
          int v55 = *(unsigned __int16 *)(v53 + 16);
          uint64_t v54 = v53 + 16;
          if (v55 == (unsigned __int16)v48
            && *(unsigned __int16 *)(v54 + 2) == WORD1(v48)
            && ((*(_DWORD *)(v93 + 32 * v52 + 20) ^ HIDWORD(v48)) & 0xFFFFFF) == 0)
          {
            break;
          }
          uint64_t v52 = *(_DWORD *)(v93 + 32 * v52 + 8) & 0x7FFFFFFF;
          if (v52 == 0x7FFFFFFF) {
            goto LABEL_53;
          }
        }
      }
      re::Result<re::MeshAssetModel,re::DetailedError>::~Result(v118);
      if (++v36 == v91) {
        goto LABEL_60;
      }
    }
    *(void *)uint64_t v135 = 0;
    long long v120 = 0u;
    *(_OWORD *)uint64_t v121 = 0u;
    long long v119 = 0u;
    memset(v118, 0, sizeof(v118));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v112[0]) = 136315906;
    *(void *)((char *)v112 + 4) = "operator[]";
    WORD6(v112[0]) = 1024;
    *(_DWORD *)((char *)v112 + 14) = 797;
    WORD1(v112[1]) = 2048;
    *(void *)((char *)&v112[1] + 4) = v36;
    WORD6(v112[1]) = 2048;
    *(void *)((char *)&v112[1] + 14) = v37;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_86:
    *(void *)&long long v108 = 0;
    memset(v112, 0, sizeof(v112));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v135 = 136315906;
    *(void *)&v135[4] = "operator[]";
    *(_WORD *)&v135[12] = 1024;
    *(_DWORD *)&v135[14] = 789;
    *(_WORD *)&v135[18] = 2048;
    *(void *)&v135[20] = v36;
    __int16 v136 = 2048;
    *(void *)int v137 = v37;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_87:
    *(void *)&long long v108 = 0;
    memset(v112, 0, sizeof(v112));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v135 = 136315906;
    *(void *)&v135[4] = "operator[]";
    *(_WORD *)&v135[12] = 1024;
    *(_DWORD *)&v135[14] = 797;
    *(_WORD *)&v135[18] = 2048;
    *(void *)&v135[20] = v36;
    __int16 v136 = 2048;
    *(void *)int v137 = v37;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_88:
    *(void *)&long long v108 = 0;
    long long v120 = 0u;
    *(_OWORD *)uint64_t v121 = 0u;
    long long v119 = 0u;
    memset(v118, 0, sizeof(v118));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v112[0]) = 136315906;
    *(uint64_t *)((char *)v4 + 212) = (uint64_t)"operator[]";
    WORD6(v112[0]) = 1024;
    *(_DWORD *)((char *)v4 + 222) = 789;
    WORD1(v112[1]) = 2048;
    *(uint64_t *)((char *)v4 + 228) = (uint64_t)v23;
    WORD6(v112[1]) = 2048;
    *(uint64_t *)((char *)v4 + 238) = v25;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_89:
    *(void *)uint64_t v135 = 0;
    long long v120 = 0u;
    *(_OWORD *)uint64_t v121 = 0u;
    long long v119 = 0u;
    memset(v118, 0, sizeof(v118));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v112[0]) = 136315906;
    *(void *)((char *)v112 + 4) = "operator[]";
    WORD6(v112[0]) = 1024;
    *(_DWORD *)((char *)v112 + 14) = 797;
    WORD1(v112[1]) = 2048;
    *(void *)((char *)&v112[1] + 4) = v25;
    WORD6(v112[1]) = 2048;
    *(void *)((char *)&v112[1] + 14) = v23;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_90:
    *(void *)uint64_t v135 = 0;
    long long v120 = 0u;
    *(_OWORD *)uint64_t v121 = 0u;
    long long v119 = 0u;
    memset(v118, 0, sizeof(v118));
    uint64_t v85 = v74;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v112[0]) = 136315906;
    *(void *)((char *)v112 + 4) = "operator[]";
    WORD6(v112[0]) = 1024;
    *(_DWORD *)((char *)v112 + 14) = 789;
    WORD1(v112[1]) = 2048;
    *(void *)((char *)&v112[1] + 4) = v25;
    WORD6(v112[1]) = 2048;
    *(void *)((char *)&v112[1] + 14) = v85;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_91:
    *(void *)uint64_t v135 = 0;
    long long v120 = 0u;
    *(_OWORD *)uint64_t v121 = 0u;
    long long v119 = 0u;
    memset(v118, 0, sizeof(v118));
    uint64_t v86 = v75;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v112[0]) = 136315906;
    *(void *)((char *)v112 + 4) = "operator[]";
    WORD6(v112[0]) = 1024;
    *(_DWORD *)((char *)v112 + 14) = 789;
    WORD1(v112[1]) = 2048;
    *(void *)((char *)&v112[1] + 4) = v25;
    WORD6(v112[1]) = 2048;
    *(void *)((char *)&v112[1] + 14) = v86;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_92:
    *(void *)uint64_t v135 = 0;
    long long v120 = 0u;
    *(_OWORD *)uint64_t v121 = 0u;
    long long v119 = 0u;
    memset(v118, 0, sizeof(v118));
    uint64_t v87 = v80;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v112[0]) = 136315906;
    *(void *)((char *)v112 + 4) = "operator[]";
    WORD6(v112[0]) = 1024;
    *(_DWORD *)((char *)v112 + 14) = 789;
    WORD1(v112[1]) = 2048;
    *(void *)((char *)&v112[1] + 4) = v25;
    WORD6(v112[1]) = 2048;
    *(void *)((char *)&v112[1] + 14) = v87;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_60:
  if (v88)
  {
    unint64_t v25 = 0;
    unint64_t v62 = DWORD2(v93);
    long long v63 = v92;
    uint64_t v64 = v93;
    while (1)
    {
      uint64_t v23 = (long long *)*((void *)a2 + 47);
      if ((unint64_t)v23 <= v25) {
        goto LABEL_89;
      }
      int v65 = (uint64_t *)re::DataArray<re::MeshInstance>::get(v90 + 72, *(void *)(*((void *)a2 + 49) + 8 * v25));
      if (!(void)v63) {
        break;
      }
      __int16 v66 = v65;
      uint64_t v67 = v65[2];
      unint64_t v68 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v67 & 0xFFFFFF)) ^ ((0xBF58476D1CE4E5B9 * (v67 & 0xFFFFFF)) >> 27));
      uint64_t v69 = *(unsigned int *)(*((void *)&v63 + 1) + 4 * ((v68 ^ (v68 >> 31)) % v62));
      if (v69 == 0x7FFFFFFF) {
        break;
      }
      while (1)
      {
        uint64_t v70 = v64 + 32 * v69;
        int v72 = *(unsigned __int16 *)(v70 + 16);
        uint64_t v71 = v70 + 16;
        if (v72 == (unsigned __int16)v67 && *(unsigned __int16 *)(v71 + 2) == WORD1(v67))
        {
          uint64_t v73 = v64 + 32 * v69;
          if (((*(_DWORD *)(v73 + 20) ^ HIDWORD(v67)) & 0xFFFFFF) == 0) {
            break;
          }
        }
        uint64_t v69 = *(_DWORD *)(v64 + 32 * v69 + 8) & 0x7FFFFFFF;
        if (v69 == 0x7FFFFFFF) {
          goto LABEL_75;
        }
      }
      uint64_t v74 = *((void *)&v100 + 1);
      if (*((void *)&v100 + 1) <= v25) {
        goto LABEL_90;
      }
      re::StringID::operator=((unint64_t *)(v102[0] + 96 * v25), v65);
      uint64_t v75 = *((void *)&v100 + 1);
      if (*((void *)&v100 + 1) <= v25) {
        goto LABEL_91;
      }
      __int16 v76 = (_OWORD *)(v102[0] + 96 * v25);
      long long v77 = *((_OWORD *)v66 + 2);
      long long v78 = *((_OWORD *)v66 + 3);
      long long v79 = *((_OWORD *)v66 + 5);
      v76[3] = *((_OWORD *)v66 + 4);
      void v76[4] = v79;
      v76[1] = v77;
      void v76[2] = v78;
      uint64_t v80 = *((void *)&v100 + 1);
      if (*((void *)&v100 + 1) <= v25) {
        goto LABEL_92;
      }
      uint64_t v81 = v102[0] + 96 * v25;
      *(_DWORD *)(v81 + 80) = *(_DWORD *)(v73 + 24);
      *(void *)(v81 + 84) = v66[3];
      if (++v25 == v88) {
        goto LABEL_74;
      }
    }
LABEL_75:
    LOBYTE(v112[0]) = 0;
    *((void *)&v112[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 100;
    *(void *)&v112[1] = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)((char *)&v112[1] + 8) = v118[0];
    *(_OWORD *)((char *)&v112[2] + 8) = v118[1];
  }
  else
  {
LABEL_74:
    re::MeshAssetData::generateMetaData((re::MeshAssetData *)v96);
    re::DynamicArray<re::MeshAssetModel>::DynamicArray((uint64_t)v118, v96);
    re::DynamicArray<re::MeshAssetInstance>::DynamicArray((uint64_t)&v119 + 8, (uint64_t *)&v99 + 1);
    re::DynamicArray<re::MeshAssetSkeleton>::DynamicArray((uint64_t)&v121[16], &v102[1]);
    re::DynamicArray<float>::DynamicArray((uint64_t)&v122 + 8, (uint64_t *)&v104 + 1);
    LOBYTE(v112[0]) = 1;
    *((void *)&v112[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(void *)&v118[0];
    memset(v118, 0, 24);
    v112[1] = *(_OWORD *)((char *)v118 + 8);
    *(_OWORD *)((char *)&v112[2] + 8) = v119;
    *(_OWORD *)((char *)&v112[3] + 8) = v120;
    v113[0] = *(_OWORD *)&v121[8];
    v113[1] = *(_OWORD *)&v121[24];
    v115[0] = v122;
    ++DWORD2(v118[1]);
    long long v119 = 0u;
    long long v120 = 0u;
    LODWORD(v112[2]) = 1;
    DWORD2(v112[4]) = 1;
    memset(&v121[8], 0, 32);
    ++*(_DWORD *)v121;
    ++*(_DWORD *)&v121[40];
    v115[1] = v123;
    long long v122 = 0u;
    long long v123 = 0u;
    uint64_t v117 = v125;
    uint64_t v125 = 0;
    ++v124;
    int v114 = 1;
    int v116 = 1;
    re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v121[16]);
    re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v119 + 8);
    re::DynamicArray<re::MeshAssetModel>::deinit(v118);
  }
LABEL_77:
  double v84 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)&v92);
  if (*((void *)&v104 + 1))
  {
    if (v107) {
      (*(void (**)(double))(**((void **)&v104 + 1) + 40))(v84);
    }
    uint64_t v107 = 0;
    long long v105 = 0uLL;
    *((void *)&v104 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    ++v106;
  }
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v102[1]);
  re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v99 + 8);
  re::DynamicArray<re::MeshAssetModel>::deinit(v96);
  if (LOBYTE(v112[0]))
  {
    re::DynamicArray<re::MeshAssetModel>::DynamicArray((uint64_t)this, (uint64_t *)v112 + 1);
    re::DynamicArray<re::MeshAssetInstance>::DynamicArray((uint64_t)this + 40, (uint64_t *)&v112[3]);
    re::DynamicArray<re::MeshAssetSkeleton>::DynamicArray((uint64_t)this + 80, (uint64_t *)v113 + 1);
    re::DynamicArray<float>::DynamicArray((uint64_t)this + 120, (uint64_t *)v115 + 1);
  }
  else
  {
    *((_OWORD *)this + 8) = 0u;
    *((_OWORD *)this + 9) = 0u;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = 0u;
    *((_OWORD *)this + 2) = 0u;
    *((_OWORD *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0u;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
  }
  return re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)v112);
}

void *re::MeshAssetLoader::cleanupSerializationState(re::MeshAssetLoader *this, unsigned char *a2)
{
  if (a2[952])
  {
    long long v7 = 0u;
    long long v8 = 0u;
    long long v6 = 0u;
    memset(v5, 0, sizeof(v5));
    memset(v4, 0, sizeof(v4));
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)(a2 + 8), (uint64_t)v4);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)(a2 + 48), (uint64_t)&v4[2] + 8);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)(a2 + 88), (uint64_t)v5);
    re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a2 + 128), (uint64_t)&v6 + 8);
    if (*((void *)&v6 + 1))
    {
      if (*((void *)&v8 + 1)) {
        (*(void (**)(void))(**((void **)&v6 + 1) + 40))();
      }
      *((void *)&v8 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      long long v7 = 0uLL;
      *((void *)&v6 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      LODWORD(v8) = v8 + 1;
    }
    re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)v5);
    re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v4[2] + 8);
    return re::DynamicArray<re::MeshAssetModel>::deinit(v4);
  }
  return result;
}

uint64_t re::MeshAssetLoader::registerAsset(re::MeshAssetLoader *this, id *a2, const re::ExistingAssetInformation *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (*((void *)this + 1))
  {
    re::MeshAsset::registerRuntimeData((uint64_t)a2, *((void *)this + 2));
    if (*((void *)this + 3))
    {
      re::DirectMeshPayload::dynamicCast(a2 + 36, &v12);
      id v6 = v12;
      if (v12)
      {
        uint64_t v7 = re::DirectMeshPayload::connectionId(&v12);
        long long v8 = (const unsigned __int8 *)[v12 identifier];
        uint64_t v15 = v7;
        uuid_copy(v16, v8);
        uint64_t v9 = *((void *)this + 3);
        uint64_t v13 = v15;
        uuid_copy(v14, v16);
        if (*((void *)a3 + 10) == -1) {
          uint64_t v10 = 0;
        }
        else {
          uint64_t v10 = *((void *)a3 + 10);
        }
        re::DirectResourceAssetTracker::registerDirectResourceBackedAsset(v9, (uint64_t)&v13, v10);
        id v6 = v12;
      }
    }
  }
  return 0;
}

uint64_t (***re::MeshAssetLoader::unregisterAsset(uint64_t (***this)(void), id *a2, const re::ExistingAssetInformation *a3))(void)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (this[1])
  {
    uint64_t v4 = this;
    if (this[3])
    {
      re::DirectMeshPayload::dynamicCast(a2 + 36, &v11);
      id v6 = v11;
      if (v11)
      {
        uint64_t v7 = re::DirectMeshPayload::connectionId(&v11);
        long long v8 = (const unsigned __int8 *)[v11 identifier];
        uint64_t v14 = v7;
        uuid_copy(v15, v8);
        uint64_t v9 = (uint64_t)v4[3];
        uint64_t v12 = v14;
        uuid_copy(v13, v15);
        if (*((void *)a3 + 10) == -1) {
          uint64_t v10 = 0;
        }
        else {
          uint64_t v10 = *((void *)a3 + 10);
        }
        re::DirectResourceAssetTracker::unregisterDirectResourceBackedAsset(v9, (uint64_t)&v12, v10);
        id v6 = v11;
      }
    }
    *((unsigned char *)a2 + 952) = 0;
    this = re::MeshManager::destroyCollection((uint64_t (***)(void))v4[2], a2 + 45);
    a2[47] = 0;
    ++*((_DWORD *)a2 + 96);
    a2[52] = 0;
    ++*((_DWORD *)a2 + 106);
  }
  return this;
}

BOOL re::MeshAssetLoader::isSupportedSourceExtension(re::MeshAssetLoader *this, const char *a2)
{
  return !strcasecmp(a2, "obj") || !strcasecmp(a2, "usd") || !strcasecmp(a2, "usdz") || strcasecmp(a2, "usda") == 0;
}

uint64_t re::MeshAssetLoader::defaultAssetCompileOptions(re::MeshAssetLoader *this)
{
  uint64_t v2 = re::globalAllocators(this);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 72, 8);
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(_WORD *)(v3 + 2) = 257;
  *(unsigned char *)(v3 + 4) = 1;
  *(_DWORD *)(v3 + 5) = 0;
  *(_WORD *)(v3 + 9) = 0;
  *(_DWORD *)(v3 + 12) = 1036831949;
  *(_WORD *)(v3 + 17) = 257;
  *(unsigned char *)(v3 + 19) = 1;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_DWORD *)(v3 + 60) = 0x7FFFFFFF;
  uint64_t v4 = *(void *)((char *)this + 253);
  *(_OWORD *)uint64_t v3 = *((_OWORD *)this + 15);
  *(void *)(v3 + 1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v4;
  re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v3 + 24, (uint64_t)this + 264);
  return v3;
}

uint64_t re::MeshAssetLoader::setDefaultAssetCompileOptions(re::MeshAssetLoader *this, char *a2)
{
  long long v2 = *(_OWORD *)a2;
  *(void *)((char *)this + 25re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(void *)(a2 + 13);
  *((_OWORD *)this + 15) = v2;
  return re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)this + 264, (uint64_t)(a2 + 24));
}

void re::MeshAssetLoader::preloadAssets(float32x4_t *this)
{
  uint64_t v2 = re::ServiceLocator::service<re::AssetService>(this[2].i64[0]);
  re::GeomMesh::GeomMesh((re::GeomMesh *)v117, 0);
  re::buildCube((re *)v117, (re::GeomMesh *)1, 1.0, 1u);
  MeshAssetDataWithGeomMeshArray = (re *)re::makeMeshAssetDataWithGeomMeshArray((_anonymous_namespace_ *)v117, 1uLL, 0, 0, (uint64_t)&v129);
  int v4 = v129;
  uint64_t v5 = re::globalAllocators(MeshAssetDataWithGeomMeshArray);
  id v6 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 960, 8);
  uint64_t v7 = v6;
  if (v4) {
    long long v8 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v6, (uint64_t)&v130);
  }
  else {
    re::MeshAsset::MeshAsset(v6);
  }
  *((_DWORD *)v7 + 23re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 1;
  re::MeshAsset::assetType(v8);
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, re::MeshAsset *, uint64_t *, const char *, void, uint64_t, void))(*(void *)v2 + 424))(&v114, v2, v7, &re::MeshAsset::assetType(void)::type, "sharedCubeMesh.compiledmesh", 0, 2, 0);
  float32x4_t v9 = this[3];
  this[3] = v114;
  float32x4_t v114 = v9;
  uint64_t v10 = this[4].i64[0];
  this[4].i64[0] = *(void *)v115;
  *(void *)uint64_t v115 = v10;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v114);
  re::AssetHandle::loadAsync((re::AssetHandle *)&this[3]);
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v129);
  re::GeomMesh::~GeomMesh((re::GeomMesh *)v117);
  re::GeomMesh::GeomMesh((re::GeomMesh *)v117, 0);
  v114.i32[0] = 65537;
  v114.i16[2] = 0;
  *(_DWORD *)uint64_t v115 = 0;
  *(_WORD *)&v115[4] = 257;
  __asm { FMOV            V8.2S, #1.0 }
  v114.i64[1] = _D8;
  *(_DWORD *)&v115[8] = 2;
  re::buildPlane((re *)v117, (float32x2_t *)&v114);
  uint64_t v16 = (re *)re::makeMeshAssetDataWithGeomMeshArray((_anonymous_namespace_ *)v117, 1uLL, 0, 0, (uint64_t)&v129);
  int v17 = v129;
  uint64_t v18 = re::globalAllocators(v16);
  uint64_t v19 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v18[2] + 32))(v18[2], 960, 8);
  unsigned int v20 = v19;
  if (v17) {
    uint64_t v21 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v19, (uint64_t)&v130);
  }
  else {
    re::MeshAsset::MeshAsset(v19);
  }
  *((_DWORD *)v20 + 23re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 1;
  re::MeshAsset::assetType(v21);
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, re::MeshAsset *, uint64_t *, const char *, void, uint64_t, void))(*(void *)v2 + 424))(&v119, v2, v20, &re::MeshAsset::assetType(void)::type, "sharedPlaneMesh.compiledmesh", 0, 2, 0);
  float32x4_t v22 = *(float32x4_t *)((char *)this + 72);
  *(float32x4_t *)((char *)this + 72) = v119;
  float32x4_t v119 = v22;
  uint64_t v23 = (void *)this[5].i64[1];
  this[5].i64[1] = (uint64_t)v120;
  long long v120 = v23;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v119);
  re::AssetHandle::loadAsync((re::AssetHandle *)&this[4].u32[2]);
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v129);
  re::GeomMesh::~GeomMesh((re::GeomMesh *)v117);
  re::GeomMesh::GeomMesh((re::GeomMesh *)v117, 0);
  v114.i32[0] = 65537;
  v114.i16[2] = 0;
  *(_DWORD *)uint64_t v115 = 0;
  *(_WORD *)&v115[4] = 257;
  v114.i64[1] = _D8;
  *(_DWORD *)&v115[8] = 4;
  re::buildPlane((re *)v117, (float32x2_t *)&v114);
  uint64_t v24 = (re *)re::makeMeshAssetDataWithGeomMeshArray((_anonymous_namespace_ *)v117, 1uLL, 0, 0, (uint64_t)&v129);
  int v25 = v129;
  uint64_t v26 = re::globalAllocators(v24);
  uint64_t v27 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v26[2] + 32))(v26[2], 960, 8);
  uint64_t v28 = v27;
  if (v25) {
    uint64_t v29 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v27, (uint64_t)&v130);
  }
  else {
    re::MeshAsset::MeshAsset(v27);
  }
  *((_DWORD *)v28 + 23re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 1;
  re::MeshAsset::assetType(v29);
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, re::MeshAsset *, uint64_t *, const char *, void, uint64_t, void))(*(void *)v2 + 424))(&v119, v2, v28, &re::MeshAsset::assetType(void)::type, "sharedBillboardMesh.compiledmesh", 0, 2, 0);
  float32x4_t v30 = this[6];
  this[6] = v119;
  float32x4_t v119 = v30;
  uint64_t v31 = (void *)this[7].i64[0];
  this[7].i64[0] = (uint64_t)v120;
  long long v120 = v31;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v119);
  re::AssetHandle::loadAsync((re::AssetHandle *)&this[6]);
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v129);
  re::GeomMesh::~GeomMesh((re::GeomMesh *)v117);
  re::GeomMesh::GeomMesh((re::GeomMesh *)v117, 0);
  LODWORD(v129) = 65537;
  WORD2(v129) = 0;
  LODWORD(v13re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  uint64_t v130 = _D8;
  int v132 = 4;
  WORD2(v13re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  re::buildPlane((re *)v117, (float32x2_t *)&v129);
  long long v32 = (re *)re::makeMeshAssetDataWithGeomMeshArray((_anonymous_namespace_ *)v117, 1uLL, 0, 0, (uint64_t)&v129);
  int v33 = v129;
  uint64_t v34 = re::globalAllocators(v32);
  unint64_t v35 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v34[2] + 32))(v34[2], 960, 8);
  unint64_t v36 = v35;
  if (v33) {
    unint64_t v37 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v35, (uint64_t)&v130);
  }
  else {
    re::MeshAsset::MeshAsset(v35);
  }
  *((_DWORD *)v36 + 23re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 1;
  re::MeshAsset::assetType(v37);
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, re::MeshAsset *, uint64_t *, const char *, void, uint64_t, void))(*(void *)v2 + 424))(&v114, v2, v36, &re::MeshAsset::assetType(void)::type, "sharedDoubleBillboardMesh.compiledmesh", 0, 2, 0);
  float32x4_t v38 = *(float32x4_t *)((char *)this + 120);
  *(float32x4_t *)((char *)this + 120) = v114;
  float32x4_t v114 = v38;
  uint64_t v39 = this[8].i64[1];
  this[8].i64[1] = *(void *)v115;
  *(void *)uint64_t v115 = v39;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v114);
  re::AssetHandle::loadAsync((re::AssetHandle *)&this[7].u32[2]);
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v129);
  re::GeomMesh::~GeomMesh((re::GeomMesh *)v117);
  re::GeomMesh::GeomMesh((re::GeomMesh *)v117, 0);
  re::GeomMeshBuilder::GeomMeshBuilder((re *)&v129, (uint64_t)v117);
  if (v130 >= 0x11 && v133 && (v133 - 1) > v133)
  {
    while (1)
      ;
  }
  LODWORD(v130) = 16;
  unsigned int v136 = 16;
  if (v137)
  {
    long long v40 = v138;
    uint64_t v41 = 8 * v137;
    do
    {
      uint64_t v42 = *v40++;
      (*(void (**)(uint64_t, void))(*(void *)v42 + 72))(v42, v136);
      v41 -= 8;
    }
    while (v41);
  }
  if (v133 >= 0x13)
  {
    int v43 = v143;
    if (v143)
    {
      unsigned int v44 = 0;
      do
      {
        long long v45 = (re::internal *)re::internal::GeomAttributeContainer::attributeByIndex((re::internal::GeomAttributeContainer *)v142, v44);
        re::internal::accessFaceVaryingAttributeSubmesh(v45, v46);
        ++v44;
      }
      while (v43 != v44);
    }
  }
  re::DynamicArray<re::GeomCell4>::resize(&v131, 0x12uLL);
  unsigned int v139 = 18;
  if (v140)
  {
    uint64_t v47 = v141;
    uint64_t v48 = 8 * v140;
    do
    {
      uint64_t v49 = *v47++;
      (*(void (**)(uint64_t, void))(*(void *)v49 + 72))(v49, v139);
      v48 -= 8;
    }
    while (v48);
  }
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0, 0, 1, 3);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 1u, 3, 1, 2);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 2u, 4, 5, 0);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 3u, 4, 0, 15);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 4u, 5, 6, 0);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 5u, 0, 6, 1);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 6u, 6, 7, 1);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 7u, 1, 7, 8);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 8u, 2, 1, 8);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 9u, 2, 8, 9);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0xAu, 2, 9, 10);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0xBu, 2, 10, 11);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0xCu, 3, 2, 12);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0xDu, 12, 2, 11);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0xEu, 14, 3, 13);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0xFu, 13, 3, 12);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0x10u, 15, 0, 14);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0x11u, 14, 0, 3);
  re::GeomMesh::operator=((uint64_t)v117, &v130);
  re::GeomMesh::setName((re *)v117, v129);
  re::GeomMesh::freeName((re *)&v129);
  re::addVertexUVs((re *)v117, v50);
  uint64_t v127 = (float32x4_t *)re::GeomMesh::modifyVertexPositions((re::GeomMesh *)v117);
  uint64_t v128 = v51;
  v126[0] = re::modifyVertexUVs((re *)v117, v51);
  v126[1] = v52;
  v125[1] = v53;
  v124[1] = v54;
  v123[1] = v55;
  v119.i64[0] = (uint64_t)&v127;
  v119.i64[1] = (uint64_t)v126;
  long long v120 = v125;
  uint64_t v121 = v124;
  long long v122 = v123;
  float32x4_t v114 = (float32x4_t)xmmword_23435FD50;
  *(_OWORD *)uint64_t v115 = xmmword_23435FD80;
  *(_OWORD *)&v115[16] = xmmword_23435FD90;
  re::transform((re::GeomMesh *)v117, &v114);
  re::GeomMesh::freeName((re *)&v129);
  re::internal::GeomAttributeManager::~GeomAttributeManager((re::internal::GeomAttributeManager *)v135);
  if (v131 && v134) {
    (*(void (**)(void))(*(void *)v131 + 40))();
  }
  uint64_t v56 = (re *)re::makeMeshAssetDataWithGeomMeshArray((_anonymous_namespace_ *)v117, 1uLL, 0, 0, (uint64_t)&v129);
  int v57 = v129;
  uint64_t v58 = re::globalAllocators(v56);
  int v59 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v58[2] + 32))(v58[2], 960, 8);
  uint64_t v60 = v59;
  if (v57) {
    uint64_t v61 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v59, (uint64_t)&v130);
  }
  else {
    re::MeshAsset::MeshAsset(v59);
  }
  *((_DWORD *)v60 + 23re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 1;
  re::MeshAsset::assetType(v61);
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, re::MeshAsset *, uint64_t *, const char *, void, uint64_t, void))(*(void *)v2 + 424))(&v114, v2, v60, &re::MeshAsset::assetType(void)::type, "sharedDoubleVertexdBillboardMesh.compiledmesh", 0, 2, 0);
  float32x4_t v62 = this[9];
  this[9] = v114;
  float32x4_t v114 = v62;
  uint64_t v63 = this[10].i64[0];
  this[10].i64[0] = *(void *)v115;
  *(void *)uint64_t v115 = v63;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v114);
  re::AssetHandle::loadAsync((re::AssetHandle *)&this[9]);
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v129);
  re::GeomMesh::~GeomMesh((re::GeomMesh *)v117);
  re::GeomMesh::GeomMesh((re::GeomMesh *)v117, 0);
  uint64_t v129 = 0;
  re::internal::GeomBaseMesh::GeomBaseMesh((re::internal::GeomBaseMesh *)&v130, (const re::internal::GeomBaseMesh *)&v118);
  re::GeomMesh::setName((re *)&v129, v117[0]);
  if (v130 >= 0x52 && v133 && (v133 - 1) > v133)
  {
    while (1)
      ;
  }
  LODWORD(v130) = 81;
  unsigned int v136 = 81;
  if (v137)
  {
    uint64_t v64 = v138;
    uint64_t v65 = 8 * v137;
    do
    {
      uint64_t v66 = *v64++;
      (*(void (**)(uint64_t, void))(*(void *)v66 + 72))(v66, v136);
      v65 -= 8;
    }
    while (v65);
  }
  if (v133 >= 0x79)
  {
    int v67 = v143;
    if (v143)
    {
      unsigned int v68 = 0;
      do
      {
        uint64_t v69 = (re::internal *)re::internal::GeomAttributeContainer::attributeByIndex((re::internal::GeomAttributeContainer *)v142, v68);
        re::internal::accessFaceVaryingAttributeSubmesh(v69, v70);
        ++v68;
      }
      while (v67 != v68);
    }
  }
  re::DynamicArray<re::GeomCell4>::resize(&v131, 0x78uLL);
  unsigned int v139 = 120;
  if (v140)
  {
    uint64_t v71 = v141;
    uint64_t v72 = 8 * v140;
    do
    {
      uint64_t v73 = *v71++;
      (*(void (**)(uint64_t, void))(*(void *)v73 + 72))(v73, v139);
      v72 -= 8;
    }
    while (v72);
  }
  unsigned int v74 = 0;
  unsigned int v75 = 1;
  do
  {
    unsigned int v76 = v74 + 1;
    unsigned int v77 = v75 + 2;
    if (v75 >= 0x4E) {
      int v78 = v75 - 78;
    }
    else {
      int v78 = v75 + 2;
    }
    re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, v74, 0, v75, v78);
    unsigned int v74 = v76;
    unsigned int v75 = v77;
  }
  while (v76 != 40);
  do
  {
    re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, v76, v76 - 39, v76 - 38, v76 - 36);
    re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, v76 + 1, v76 - 39, v76 - 36, v76 - 37);
    _CF = v76 >= 0x74;
    v76 += 2;
  }
  while (!_CF);
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0x76u, 79, 80, 2);
  unsigned int v79 = 1;
  re::GeomMeshBuilder::setFaceVertices((uint64_t)&v129, 0x77u, 79, 2, 1);
  re::GeomMesh::operator=((uint64_t)v117, &v130);
  re::GeomMesh::setName((re *)v117, v129);
  re::GeomMesh::freeName((re *)&v129);
  re::addVertexUVs((re *)v117, v80);
  v114.i64[0] = re::GeomMesh::modifyVertexPositions((re::GeomMesh *)v117);
  v114.i64[1] = (uint64_t)v81;
  v119.i64[0] = re::modifyVertexUVs((re *)v117, v81);
  v119.i64[1] = v82;
  uint64_t v127 = &v114;
  uint64_t v128 = (re::GeomMesh *)&v119;
  int v83 = 0;
  do
  {
    __float2 v84 = __sincosf_stret((float)v83 * 0.15708);
    *(float32x2_t *)v85.i8 = vmul_f32((float32x2_t)__PAIR64__(LODWORD(v84.__sinval), LODWORD(v84.__cosval)), (float32x2_t)0x3F0000003F000000);
    int32x4_t v86 = vzip1q_s32(v85, v85);
    uint64_t v87 = v86.i64[1];
    uint64_t v88 = v86.u32[0];
    ++v83;
    _ZF = v79 == 79;
    v79 += 2;
  }
  while (!_ZF);
  re::GeomMesh::freeName((re *)&v129);
  re::internal::GeomAttributeManager::~GeomAttributeManager((re::internal::GeomAttributeManager *)v135);
  if (v131 && v134) {
    (*(void (**)(void))(*(void *)v131 + 40))();
  }
  v114.i8[4] = 1;
  *(__int32 *)((char *)&v114.i32[1] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  *(__int16 *)((char *)&v114.i16[4] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  v114.i32[3] = 1036831949;
  *(_DWORD *)uint64_t v115 = 16843008;
  v115[4] = 0;
  long long v116 = 0u;
  memset(&v115[8], 0, 32);
  DWORD1(v116) = 0x7FFFFFFF;
  v114.i32[0] = 0x10000;
  float32x4_t v89 = (re *)re::makeMeshAssetDataWithGeomMeshArray((_anonymous_namespace_ *)v117, 1uLL, 0, (int *)&v114, (uint64_t)&v129);
  int v90 = v129;
  uint64_t v91 = re::globalAllocators(v89);
  long long v92 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v91[2] + 32))(v91[2], 960, 8);
  long long v93 = v92;
  if (v90) {
    unsigned int v94 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v92, (uint64_t)&v130);
  }
  else {
    re::MeshAsset::MeshAsset(v92);
  }
  *((_DWORD *)v93 + 23re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 1;
  re::MeshAsset::assetType(v94);
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, re::MeshAsset *, uint64_t *, const char *, void, uint64_t, void))(*(void *)v2 + 424))(&v119, v2, v93, &re::MeshAsset::assetType(void)::type, "sharedDoubleVertexCircularPlaneMesh.compiledmesh", 0, 2, 0);
  float32x4_t v95 = *(float32x4_t *)((char *)this + 216);
  *(float32x4_t *)((char *)this + 216) = v119;
  float32x4_t v119 = v95;
  char v96 = (void *)this[14].i64[1];
  this[14].i64[1] = (uint64_t)v120;
  long long v120 = v96;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v119);
  re::AssetHandle::loadAsync((re::AssetHandle *)&this[13].u32[2]);
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v129);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v115[8]);
  re::GeomMesh::~GeomMesh((re::GeomMesh *)v117);
  re::GeomMesh::GeomMesh((re::GeomMesh *)v117, 0);
  v114.i32[0] = 65537;
  v114.i16[2] = 0;
  *(_DWORD *)uint64_t v115 = 0;
  *(_WORD *)&v115[4] = 257;
  v114.i64[1] = 0x4000000040000000;
  *(_DWORD *)&v115[8] = 4;
  re::buildPlane((re *)v117, (float32x2_t *)&v114);
  unint64_t v97 = (re *)re::makeMeshAssetDataWithGeomMeshArray((_anonymous_namespace_ *)v117, 1uLL, 0, 0, (uint64_t)&v129);
  int v98 = v129;
  long long v99 = re::globalAllocators(v97);
  long long v100 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v99[2] + 32))(v99[2], 960, 8);
  int v101 = v100;
  if (v98) {
    int v102 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v100, (uint64_t)&v130);
  }
  else {
    re::MeshAsset::MeshAsset(v100);
  }
  *((_DWORD *)v101 + 23re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 1;
  re::MeshAsset::assetType(v102);
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, re::MeshAsset *, uint64_t *, const char *, void, uint64_t, void))(*(void *)v2 + 424))(&v119, v2, v101, &re::MeshAsset::assetType(void)::type, "sharedFullscreenMesh.compiledmesh", 0, 2, 0);
  float32x4_t v103 = *(float32x4_t *)((char *)this + 168);
  *(float32x4_t *)((char *)this + 168) = v119;
  float32x4_t v119 = v103;
  long long v104 = (void *)this[11].i64[1];
  this[11].i64[1] = (uint64_t)v120;
  long long v120 = v104;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v119);
  re::AssetHandle::loadAsync((re::AssetHandle *)&this[10].u32[2]);
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v129);
  re::GeomMesh::~GeomMesh((re::GeomMesh *)v117);
  re::GeomMesh::GeomMesh((re::GeomMesh *)v117, 0);
  v114.i32[0] = 65537;
  *(_WORD *)&v115[4] = 257;
  v114.i64[1] = _D8;
  *(_DWORD *)uint64_t v115 = 1056964608;
  v114.i16[2] = 10;
  *(_DWORD *)&v115[8] = 2;
  re::buildPlane((re *)v117, (float32x2_t *)&v114);
  long long v105 = (re *)re::makeMeshAssetDataWithGeomMeshArray((_anonymous_namespace_ *)v117, 1uLL, 0, 0, (uint64_t)&v129);
  int v106 = v129;
  uint64_t v107 = re::globalAllocators(v105);
  long long v108 = (re::MeshAsset *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v107[2] + 32))(v107[2], 960, 8);
  uint64_t v109 = v108;
  if (v106) {
    uint64_t v110 = (re::MeshAsset *)re::MeshAsset::MeshAsset((uint64_t)v108, (uint64_t)&v130);
  }
  else {
    re::MeshAsset::MeshAsset(v108);
  }
  *((_DWORD *)v109 + 23re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 1;
  re::MeshAsset::assetType(v110);
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, re::MeshAsset *, uint64_t *, const char *, void, uint64_t, void))(*(void *)v2 + 424))(&v119, v2, v109, &re::MeshAsset::assetType(void)::type, "sharedCircularPlaneMesh.compiledmesh", 0, 2, 0);
  float32x4_t v112 = this[12];
  char v111 = (uint64_t *)&this[12];
  *(float32x4_t *)char v111 = v119;
  float32x4_t v119 = v112;
  uint64_t v113 = (void *)v111[2];
  id v111[2] = (uint64_t)v120;
  long long v120 = v113;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v119);
  re::AssetHandle::loadAsync((re::AssetHandle *)v111);
  re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)&v129);
  re::GeomMesh::~GeomMesh((re::GeomMesh *)v117);
  re::AssetHandle::loadNow(*(v111 - 17), 0);
  re::AssetHandle::loadNow(*(v111 - 14), 0);
  re::AssetHandle::loadNow(*(v111 - 11), 0);
  re::AssetHandle::loadNow(*(v111 - 8), 0);
  re::AssetHandle::loadNow(*(v111 - 5), 0);
  re::AssetHandle::loadNow(*(v111 - 2), 0);
  re::AssetHandle::loadNow(v111[1], 0);
  re::AssetHandle::loadNow(v111[4], 0);
}

void *re::MeshAssetLoader::serializableAsset@<X0>(re::MeshAsset *a1@<X1>, uint64_t *a2@<X8>)
{
  v16[4] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    re::internal::assertLog((re::internal *)4, 0, "assertion failure: '%s' (%s:line %i) ", "runtimeAssetPointer != nullptr", "serializableAsset", 1255);
    _os_crash();
    __break(1u);
  }
  if (*((unsigned char *)a1 + 952))
  {
    MeshAssetDataFromRegisteredMeshAsset = (re *)re::MeshAsset::makeMeshAssetDataFromRegisteredMeshAsset((re::MeshAsset *)v10, a1);
  }
  else
  {
    re::DynamicArray<re::MeshAssetModel>::DynamicArray((uint64_t)v10, (uint64_t *)a1 + 1);
    re::DynamicArray<re::MeshAssetInstance>::DynamicArray((uint64_t)v11, (uint64_t *)a1 + 6);
    re::DynamicArray<re::MeshAssetSkeleton>::DynamicArray((uint64_t)v12, (uint64_t *)a1 + 11);
    MeshAssetDataFromRegisteredMeshAsset = (re *)re::DynamicArray<float>::DynamicArray((uint64_t)v13, (uint64_t *)a1 + 16);
  }
  id v6 = re::globalAllocators(MeshAssetDataFromRegisteredMeshAsset);
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6[2] + 32))(v6[2], 960, 8);
  uint64_t v8 = re::MeshAsset::MeshAsset(v7, (uint64_t)v10);
  v16[0] = &unk_26E6CDEF0;
  void v16[3] = v16;
  a2[4] = (uint64_t)(a2 + 1);
  *a2 = v8;
  a2[1] = (uint64_t)&unk_26E6CDEF0;
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](v16);
  if (*a2) {
    re::DynamicArray<re::AssetHandle>::operator=(*a2 + 208, (uint64_t *)a1 + 26);
  }
  if (v13[0])
  {
    if (v15) {
      (*(void (**)(void))(*(void *)v13[0] + 40))();
    }
    uint64_t v15 = 0;
    memset(v13, 0, sizeof(v13));
    ++v14;
  }
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)v12);
  re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)v11);
  return re::DynamicArray<re::MeshAssetModel>::deinit(v10);
}

uint64_t re::DynamicArray<re::AssetHandle>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::AssetHandle>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::AssetHandle>::clear((re::AssetHandle *)a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::AssetHandle>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::AssetHandle>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetModel>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v10 = (a2 << 9) | 0x110;
    unint64_t v11 = a2;
    do
    {
      uint64_t v12 = *(void *)(a1 + 32) + v10;
      re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(v12 + 200);
      re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(v12 + 160);
      re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit(v12 + 120);
      re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(v12 + 80);
      re::DynamicArray<re::MeshAssetContactDeformerData>::deinit(v12 + 40);
      re::DynamicArray<unsigned long>::deinit(v12);
      re::DynamicArray<re::MeshAssetSkeleton>::deinit(v12 - 40);
      re::DynamicArray<re::MeshAssetPart>::deinit(v12 - 80);
      re::DynamicArray<re::MeshAssetSkinningData>::deinit(v12 - 120);
      re::DynamicArray<re::MeshAssetBlendShapeData>::deinit(v12 - 160);
      re::StringID::destroyString((re::StringID *)(v12 - 272));
      ++v11;
      v10 += 512;
    }
    while (v11 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::MeshAssetModel>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      unint64_t v6 = v4 << 9;
      int32x4_t v7 = vdupq_n_s32(0x7F800000u);
      *(void *)&long long v8 = 0x7F0000007FLL;
      *((void *)&v8 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0x7F0000007FLL;
      do
      {
        unint64_t v9 = *(void *)(a1 + 32) + v6;
        *(void *)unint64_t v9 = 0;
        *(void *)(v9 + 8) = "";
        *(int32x4_t *)(v9 + 16) = v7;
        *(_OWORD *)(v9 + 32) = v8;
        *(void *)(v9 + 504) = 0;
        *(_OWORD *)(v9 + 48) = 0uLL;
        *(_OWORD *)(v9 + 64) = 0uLL;
        *(_OWORD *)(v9 + 80) = 0uLL;
        *(_OWORD *)(v9 + 96) = 0uLL;
        *(_OWORD *)(v9 + 112) = 0uLL;
        *(_OWORD *)(v9 + 124) = 0uLL;
        *(_OWORD *)(v9 + 144) = 0uLL;
        *(_OWORD *)(v9 + 160) = 0uLL;
        *(_DWORD *)(v9 + 176) = 0;
        *(_OWORD *)(v9 + 184) = 0uLL;
        *(_OWORD *)(v9 + 200) = 0uLL;
        *(_DWORD *)(v9 + 216) = 0;
        *(_OWORD *)(v9 + 224) = 0uLL;
        *(_OWORD *)(v9 + 240) = 0uLL;
        *(_DWORD *)(v9 + 256) = 0;
        *(_DWORD *)(v9 + 296) = 0;
        *(_OWORD *)(v9 + 264) = 0uLL;
        *(_OWORD *)(v9 + 280) = 0uLL;
        *(_DWORD *)(v9 + 336) = 0;
        *(_OWORD *)(v9 + 304) = 0uLL;
        *(_OWORD *)(v9 + 320) = 0uLL;
        *(_DWORD *)(v9 + 376) = 0;
        *(_OWORD *)(v9 + 344) = 0uLL;
        *(_OWORD *)(v9 + 360) = 0uLL;
        *(_DWORD *)(v9 + 416) = 0;
        *(_OWORD *)(v9 + 384) = 0uLL;
        *(_OWORD *)(v9 + 400) = 0uLL;
        *(_DWORD *)(v9 + 456) = 0;
        *(_OWORD *)(v9 + 424) = 0uLL;
        *(_OWORD *)(v9 + 440) = 0uLL;
        *(_OWORD *)(v9 + 464) = 0uLL;
        *(_OWORD *)(v9 + 480) = 0uLL;
        v6 += 512;
        *(_DWORD *)(v9 + 496) = 0;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void re::DynamicArray<re::MeshAssetInstance>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 96 * a2;
    unint64_t v9 = a2;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(void *)(a1 + 32) + v8));
      ++v9;
      v8 += 96;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::MeshAssetInstance>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 96 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + 8) = "";
        *(_OWORD *)(v7 + 16) = 0uLL;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_OWORD *)(v7 + 64) = 0uLL;
        *(void *)(v7 + 77) = 0;
        *(_DWORD *)(v7 + 88) = 1065353216;
        v6 += 96;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void anonymous namespace'::makeMeshAssetModelFromMeshModel(_anonymous_namespace_ *this, const re::MeshModel *a2, re::MeshManager *a3, uint64_t a4)
{
  uint64_t v323 = *MEMORY[0x263EF8340];
  *(void *)&long long v236 = 0;
  *((void *)&v236 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = "";
  *(void *)&long long v7 = 0x7F0000007FLL;
  *((void *)&v7 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0x7F0000007FLL;
  int32x4_t v237 = vdupq_n_s32(0x7F800000u);
  long long v238 = v7;
  uint64_t v8 = (uint64_t)&v247 + 8;
  uint64_t v271 = 0;
  long long v239 = 0u;
  long long v240 = 0u;
  long long v241 = 0u;
  long long v242 = 0u;
  memset(v243, 0, 28);
  long long v244 = 0u;
  long long v245 = 0u;
  long long v247 = 0u;
  long long v248 = 0u;
  int v246 = 0;
  int v249 = 0;
  long long v250 = 0u;
  long long v251 = 0u;
  int v252 = 0;
  long long v253 = 0u;
  long long v254 = 0u;
  int v255 = 0;
  int v258 = 0;
  long long v256 = 0u;
  long long v257 = 0u;
  long long v259 = 0u;
  long long v260 = 0u;
  int v261 = 0;
  int v264 = 0;
  long long v262 = 0u;
  long long v263 = 0u;
  long long v265 = 0u;
  long long v266 = 0u;
  int v267 = 0;
  long long v268 = 0u;
  long long v269 = 0u;
  int v270 = 0;
  unint64_t v9 = re::StringID::operator=((unint64_t *)&v236, (uint64_t *)a2);
  long long v10 = *((_OWORD *)a2 + 2);
  int32x4_t v237 = *((int32x4_t *)a2 + 1);
  long long v238 = v10;
  unint64_t v11 = *((void *)a2 + 7);
  if ((unint64_t)v248 < v11) {
    unint64_t v9 = re::DynamicArray<re::MeshAssetPart>::setCapacity((void *)&v247 + 1, *((void *)a2 + 7));
  }
  unint64_t v12 = *((void *)a2 + 10);
  uint64_t v13 = (char *)*((void *)a2 + 11);
  v232 = a2;
  if (*((void *)&v253 + 1))
  {
    if (v12)
    {
      re::DynamicArray<re::MeshLodLevelInfo>::copy((void **)&v253 + 1, v13, v12);
      re::DynamicArray<re::MeshLodLevelInfo>::resize((uint64_t)&v253 + 8, v12);
    }
    else
    {
      *((void *)&v254 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      ++v255;
    }
  }
  else if (v12)
  {
    re::DynamicArray<re::MeshLodLevelInfo>::setCapacity((void *)&v253 + 1, v12);
    ++v255;
    re::DynamicArray<re::MeshLodLevelInfo>::copy((void **)&v253 + 1, v13, v12);
  }
  unint64_t v14 = (unint64_t)v310;
  uint64_t v15 = (const char *)a2;
  if (v11)
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    unint64_t v12 = (unint64_t)&v283[1];
    while (1)
    {
      unint64_t v18 = *((void *)v232 + 7);
      if (v18 <= v17) {
        break;
      }
      if (!LOBYTE(v283[0]))
      {
        v322[0] = v283[1];
        re::DynamicString::DynamicString((re::DynamicString *)&v322[1], (const re::DynamicString *)&v284);
        *(unsigned char *)this = 0;
        *((_OWORD *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v322[0];
        uint64_t v22 = *((void *)&v322[2] + 1);
        *((void *)this + 4) = *(void *)&v322[1];
        *((void *)this + 7) = v22;
        *(_OWORD *)((char *)this + 40) = *(_OWORD *)((char *)&v322[1] + 8);
        re::Result<re::MeshAssetPart,re::DetailedError>::~Result((uint64_t)v283);
        goto LABEL_318;
      }
      re::DynamicArray<re::MeshAssetPart>::add((_anonymous_namespace_ *)((char *)&v247 + 8), (uint64_t)&v283[1]);
      re::Result<re::MeshAssetPart,re::DetailedError>::~Result((uint64_t)v283);
      ++v17;
      v16 += 560;
      if (v11 == v17) {
        goto LABEL_14;
      }
    }
    uint64_t v277 = 0;
    long long v285 = 0u;
    long long v286 = 0u;
    long long v284 = 0u;
    memset(v283, 0, sizeof(v283));
    uint64_t v175 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v322[0]) = 136315906;
    *(void *)((char *)v322 + 4) = "operator[]";
    WORD6(v322[0]) = 1024;
    *(_DWORD *)((char *)v322 + 14) = 476;
    WORD1(v322[1]) = 2048;
    *(void *)((char *)&v322[1] + 4) = v17;
    WORD6(v322[1]) = 2048;
    *(void *)((char *)&v322[1] + 14) = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_263:
    unint64_t v27 = v14;
    goto LABEL_264;
  }
LABEL_14:
  *(void *)&v314[2] = 0;
  memset(v312, 0, sizeof(v312));
  unint64_t v19 = *((void *)v232 + 7);
  uint64_t v20 = *((void *)v232 + 22);
  if (v20) {
    uint64_t v21 = *(void *)(v20 + 8);
  }
  else {
    uint64_t v21 = 0;
  }
  a4 = (uint64_t)v310;
  v227 = (char *)&v247 + 8;
  uint64_t v23 = 0;
  int v24 = 0;
  v234 = (const re::MeshModel *)((char *)v232 + 96);
  long long v25 = 0uLL;
  uint64_t v26 = 0;
  if (!v19 || v21 != v19) {
    goto LABEL_87;
  }
  re::DynamicArray<re::MeshAssetSkinningData>::setCapacity(v312, v19);
  unint64_t v11 = 0;
  unint64_t v27 = (unint64_t)&v285 + 8;
  uint64_t v8 = (uint64_t)&v287;
  unint64_t v28 = (unint64_t)re::AssetErrorCategory(void)::instance;
  do
  {
    char v282 = 0;
    v281[1] = 0;
    v281[0] = 0;
    unint64_t v12 = re::SkinningModelUtil::skinnedInfluenceDataBuffer((uint64_t)v234, v11, &v282, (uint64_t)v281);
    re::ReadOnlyCPUAccessibleBufferSliceContent::make(v281, (uint64_t)&v277);
    if (!v12 || !(_BYTE)v277)
    {
      v310[0] = 0;
      *(void *)&v310[8] = 100;
      *(void *)&v310[16] = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)&v310[24] = v283[0];
      long long v311 = v283[1];
      int v36 = 1;
      goto LABEL_82;
    }
    long long v275 = 0uLL;
    uint64_t v276 = 0;
    if (v282)
    {
      unint64_t v14 = *((void *)&v278 + 1);
      uint64_t v30 = v278;
      unint64_t v12 = *((void *)&v278 + 1) >> 2;
      if (v14 >= 4)
      {
        uint64_t v32 = 0;
        unint64_t v14 = *((void *)&v275 + 1);
        if (v12 <= 1) {
          uint64_t v33 = 1;
        }
        else {
          uint64_t v33 = v12;
        }
        uint64_t v34 = (float *)(v276 + 4);
        while (v14 != v32)
        {
          unsigned int v35 = *(_DWORD *)(v30 + 4 * v32);
          *((_DWORD *)v34 - re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v35 >> 22;
          *uint64_t v34 = (float)(v35 & 0x3FFFFF) * 0.00000023842;
          v34 += 2;
          if (v33 == ++v32) {
            goto LABEL_34;
          }
        }
        *(void *)v315 = 0;
        long long v285 = 0u;
        long long v286 = 0u;
        long long v284 = 0u;
        memset(v283, 0, sizeof(v283));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v322[0]) = 136315906;
        *(void *)((char *)v322 + 4) = "operator[]";
        WORD6(v322[0]) = 1024;
        *(_DWORD *)((char *)v322 + 14) = 468;
        WORD1(v322[1]) = 2048;
        *(void *)((char *)&v322[1] + 4) = v14;
        WORD6(v322[1]) = 2048;
        *(void *)((char *)&v322[1] + 14) = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_213;
      }
    }
    else
    {
      *(void *)&v283[0] = v278;
      *((void *)&v283[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *((void *)&v278 + 1) >> 3;
      uint64_t v31 = re::FixedArray<re::SkinningInfluence>::operator=((_anonymous_namespace_ *)&v275, (uint64_t)v283);
    }
LABEL_34:
    uint64_t v37 = *((void *)v232 + 22);
    if (v37 && *(void *)(v37 + 8) > v11)
    {
      unint64_t v38 = *(unsigned __int8 *)(*(void *)(v37 + 16) + 72 * v11 + 2);
      long long v273 = 0uLL;
      unint64_t v274 = 0;
      if (v38)
      {
        unint64_t v39 = *((void *)&v275 + 1);
        unint64_t v12 = *((void *)&v275 + 1) / v38;
        if (v39 >= v38)
        {
          uint64_t v40 = 0;
          unint64_t v14 = *((void *)&v273 + 1);
          unint64_t v41 = v274;
          if (v12 <= 1) {
            uint64_t v42 = 1;
          }
          else {
            uint64_t v42 = v12;
          }
          int v43 = v38;
          while (v14 != v40)
          {
            *(_DWORD *)(v41 + 4 * v40) = v43;
            v43 += v38;
            if (v42 == ++v40) {
              goto LABEL_58;
            }
          }
          *(void *)v315 = 0;
          long long v285 = 0u;
          long long v286 = 0u;
          long long v284 = 0u;
          memset(v283, 0, sizeof(v283));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v322[0]) = 136315906;
          *(void *)((char *)v322 + 4) = "operator[]";
          WORD6(v322[0]) = 1024;
          *(_DWORD *)((char *)v322 + 14) = 468;
          WORD1(v322[1]) = 2048;
          *(void *)((char *)&v322[1] + 4) = v14;
          WORD6(v322[1]) = 2048;
          *(void *)((char *)&v322[1] + 14) = v14;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_324:
          v272[0] = 0;
          memset(v322, 0, sizeof(v322));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v315 = 136315906;
          *(void *)&v315[4] = "operator[]";
          __int16 v316 = 1024;
          int v317 = 476;
          __int16 v318 = 2048;
          unint64_t v319 = v11;
          __int16 v320 = 2048;
          unint64_t v321 = v14;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_325:
          *(void *)v315 = 0;
          long long v285 = 0u;
          long long v286 = 0u;
          long long v284 = 0u;
          memset(v283, 0, sizeof(v283));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v312 = 136315906;
          *(void *)&v312[4] = "operator[]";
          *(_WORD *)&v312[12] = 1024;
          *(_DWORD *)&v312[14] = 789;
          *(_WORD *)&v312[18] = 2048;
          *(void *)&v312[20] = v27;
          __int16 v313 = 2048;
          *(void *)v314 = a4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_326:
          *(void *)v312 = 0;
          long long v285 = 0u;
          long long v286 = 0u;
          long long v284 = 0u;
          memset(v283, 0, sizeof(v283));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v310 = 136315906;
          *(void *)(a4 + 4) = "operator[]";
          *(_WORD *)&v310[12] = 1024;
          *(_DWORD *)(a4 + 14) = 789;
          *(_WORD *)&v310[18] = 2048;
          *(void *)(a4 + 20) = v28;
          *(_WORD *)&v310[28] = 2048;
          *(void *)(a4 + 30) = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_327:
          *(void *)v312 = 0;
          long long v285 = 0u;
          long long v286 = 0u;
          long long v284 = 0u;
          memset(v283, 0, sizeof(v283));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v310 = 136315906;
          *(void *)&v310[4] = "operator[]";
          *(_WORD *)&v310[12] = 1024;
          *(_DWORD *)&v310[14] = 789;
          *(_WORD *)&v310[18] = 2048;
          *(void *)&v310[20] = v27;
          *(_WORD *)&v310[28] = 2048;
          *(void *)&v310[30] = a4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_328:
          re::internal::assertLog((re::internal *)4, v45, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
          _os_crash();
          __break(1u);
          goto LABEL_329;
        }
LABEL_58:
        uint64_t v52 = *((void *)v232 + 22);
        if (v52 && *(void *)(v52 + 8) > v11) {
          int v53 = *(_DWORD *)(*(void *)(v52 + 16) + 72 * v11 + 4);
        }
        else {
          int v53 = -1;
        }
        LODWORD(v283[0]) = v53;
        *(_OWORD *)((char *)v283 + 8) = v275;
        uint64_t v54 = v276;
        uint64_t v276 = 0;
        long long v275 = 0uLL;
        *((void *)&v283[1] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v54;
        long long v284 = v273;
        unint64_t v55 = v274;
        unint64_t v274 = 0;
        long long v273 = 0uLL;
        long long v285 = v55;
        long long v286 = 0uLL;
        unint64_t v14 = *((void *)v232 + 7);
        if (v14 <= v11) {
          goto LABEL_324;
        }
        uint64_t v56 = (_OWORD *)(*((void *)v232 + 8) + 560 * v11);
        long long v57 = v56[26];
        long long v59 = v56[23];
        long long v58 = v56[24];
        *(_OWORD *)v289 = v56[25];
        *(_OWORD *)&v289[16] = v57;
        long long v287 = v59;
        long long v288 = v58;
        __n128 v51 = re::DynamicArray<re::MeshAssetSkinningData>::add((_anonymous_namespace_ *)v312, (uint64_t)v283);
        if (*((void *)&v285 + 1))
        {
          if ((void)v286)
          {
            (*(void (**)(__n128))(**((void **)&v285 + 1) + 40))(v51);
            long long v286 = 0uLL;
          }
          *((void *)&v285 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
        }
        if ((void)v284)
        {
          if (*((void *)&v284 + 1))
          {
            (*(void (**)(__n128))(*(void *)v284 + 40))(v51);
            *((void *)&v284 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
            *(void *)&long long v285 = 0;
          }
          *(void *)&long long v284 = 0;
        }
        if (*((void *)&v283[0] + 1) && *(void *)&v283[1]) {
          (*(void (**)(__n128))(**((void **)&v283[0] + 1) + 40))(v51);
        }
        int v36 = 0;
        goto LABEL_76;
      }
    }
    else
    {
      long long v273 = 0uLL;
      unint64_t v274 = 0;
    }
    re::SkinningModelUtil::skinnedEndIndicesBuffer(v234, v11, v315);
    re::ReadOnlyCPUAccessibleBufferSliceContent::make(v315, (uint64_t)v283);
    int v46 = LOBYTE(v283[0]);
    if (LOBYTE(v283[0]))
    {
      uint64_t v47 = 0;
      unint64_t v12 = *(void *)&v283[1] >> 2;
      v272[0] = *((const void **)&v283[0] + 1);
      v272[1] = (const void *)(*(void *)&v283[1] >> 2);
      memset(v322, 0, 24);
      if (*(void *)&v283[1] >= 4uLL)
      {
        re::FixedArray<int>::copy(v322, v272);
        uint64_t v47 = *(void *)&v322[0];
      }
      uint64_t v48 = v273;
      if ((void)v273 && (void)v273 != v47) {
        goto LABEL_328;
      }
      uint64_t v49 = *((void *)&v273 + 1);
      unint64_t v50 = v274;
      *(void *)&long long v273 = v47;
      *((void *)&v273 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *((void *)&v322[0] + 1);
      *(void *)&v322[0] = v48;
      *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v49;
      unint64_t v274 = *(void *)&v322[1];
      *(void *)&v322[1] = v50;
      if (v48 && v49) {
        (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
      }
    }
    else
    {
      v310[0] = 0;
      *(void *)&v310[8] = 100;
      *(void *)&v310[16] = re::AssetErrorCategory(void)::instance;
      *(_OWORD *)&v310[24] = v322[0];
      long long v311 = v322[1];
    }
    re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(v283);
    if (*(void *)v315) {

    }
    if (v46) {
      goto LABEL_58;
    }
    int v36 = 1;
LABEL_76:
    if ((void)v273 && *((void *)&v273 + 1)) {
      (*(void (**)(__n128))(*(void *)v273 + 40))(v51);
    }
    if ((void)v275 && *((void *)&v275 + 1)) {
      (*(void (**)(__n128))(*(void *)v275 + 40))(v51);
    }
LABEL_82:
    re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(&v277);
    if (v281[0]) {

    }
    if (v36) {
      goto LABEL_88;
    }
    ++v11;
  }
  while (v11 != v19);
  uint64_t v26 = *(void *)v312;
  long long v25 = *(_OWORD *)&v312[8];
  uint64_t v23 = *(void *)&v314[2];
  int v24 = *(_DWORD *)&v312[24];
LABEL_87:
  *(void *)&v314[2] = 0;
  memset(v312, 0, 24);
  *(_DWORD *)&v312[24] = v24 + 1;
  v310[0] = 1;
  *(void *)&v310[8] = v26;
  *(_OWORD *)&v310[16] = v25;
  memset(v283, 0, 24);
  *(void *)&long long v311 = v23;
  *(void *)&long long v284 = 0;
  DWORD2(v283[1]) = 2;
  *(_DWORD *)&v310[32] = 1;
  re::DynamicArray<re::MeshAssetSkinningData>::deinit((uint64_t)v283);
LABEL_88:
  re::DynamicArray<re::MeshAssetSkinningData>::deinit((uint64_t)v312);
  if (!v310[0])
  {
    long long v74 = *(_OWORD *)&v310[24];
    *(void *)&v310[32] = 0;
    *(void *)&v310[24] = 0;
    long long v75 = v311;
    long long v311 = 0uLL;
    *(unsigned char *)this = 0;
    *((_OWORD *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(_OWORD *)&v310[8];
    *((_OWORD *)this + 2) = v74;
    *((_OWORD *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v75;
    re::Result<re::DynamicArray<re::MeshAssetSkinningData>,re::DetailedError>::~Result(v310);
    uint64_t v8 = (uint64_t)&v247 + 8;
    goto LABEL_318;
  }
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v244 + 8, (uint64_t)&v310[8]);
  uint64_t v60 = (_anonymous_namespace_ *)re::Result<re::DynamicArray<re::MeshAssetSkinningData>,re::DetailedError>::~Result(v310);
  *(void *)&v310[32] = 0;
  memset(v310, 0, 28);
  uint64_t v61 = *(void *)v234;
  uint64_t v8 = (uint64_t)&v247 + 8;
  if (*(void *)v234)
  {
    uint64_t v62 = *(void *)(v61 + 40);
    uint64_t v15 = "";
    if (v62 == *((void *)v232 + 7))
    {
      unint64_t v63 = *(void *)(v61 + 64);
      re::DynamicArray<re::MeshAssetBlendShapeData>::resize((uint64_t)v310, v63);
      if (v63)
      {
        unint64_t v27 = 0;
        unint64_t v11 = (unint64_t)&v322[1] + 8;
        unint64_t v28 = 1;
        unint64_t v14 = 56;
        while (1)
        {
          BlendShapeGroupDefinitionFromGroup = re::BlendShapeModelUtil::makeBlendShapeGroupDefinitionFromGroup(v234, (const DeformationModelData *)(v28 - 1), (unint64_t *)v322);
          if (!LOBYTE(v322[0])) {
            break;
          }
          a4 = *(void *)&v310[16];
          if (*(void *)&v310[16] <= v27) {
            goto LABEL_325;
          }
          uint64_t v65 = (void *)(*(void *)&v310[32] + 56 * v27);
          uint64_t v66 = *((void *)&v322[0] + 1);
          uint64_t v67 = *(void *)&v322[1];
          *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
          *(void *)&v322[1] = "";
          uint64_t v68 = v65[1];
          unint64_t v69 = v66 & 0xFFFFFFFFFFFFFFFELL | *v65 & 1;
          v65[1] = v67;
          *((void *)&v283[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v68;
          *(void *)&v283[0] = v69;
          *uint64_t v65 = v66;
          re::StringID::destroyString((re::StringID *)v283);
          re::FixedArray<float>::operator=(v65 + 2, (uint64_t *)&v322[1] + 1);
          v65[5] = *(void *)&v322[3];
          re::Result<re::BlendShapeGroupDefinition,re::DetailedError>::~Result((uint64_t)v322);
          unint64_t v27 = v28;
          BOOL v73 = v63 > v28;
          unint64_t v28 = (v28 + 1);
          if (!v73) {
            goto LABEL_96;
          }
        }
        LOBYTE(v277) = 0;
        *(void *)&long long v278 = 100;
        *((void *)&v278 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = re::AssetErrorCategory(void)::instance;
        long long v279 = v283[0];
        long long v280 = v283[1];
        re::Result<re::BlendShapeGroupDefinition,re::DetailedError>::~Result((uint64_t)v322);
        a4 = (uint64_t)v310;
      }
      else
      {
LABEL_96:
        if (v62)
        {
          unint64_t v70 = 0;
          uint64_t v71 = *(void *)v234;
          unint64_t v27 = *(void *)&v310[16];
          uint64_t v72 = *(void *)&v310[32];
          a4 = (uint64_t)v310;
          do
          {
            if (v71 && *(void *)(v71 + 40) > v70)
            {
              unint64_t v28 = *(unsigned int *)(*(void *)(v71 + 48) + 4 * v70);
              BOOL v73 = v28 != -1 && v63 > v28;
              if (v73)
              {
                if (v27 <= v28) {
                  goto LABEL_331;
                }
                *(_WORD *)(v72 + 56 * v28 + 48) = v70;
              }
            }
            ++v70;
          }
          while (v62 != v70);
        }
        else
        {
          unint64_t v27 = *(void *)&v310[16];
          a4 = (uint64_t)v310;
        }
        uint64_t v76 = *(void *)v310;
        uint64_t v77 = *(void *)&v310[8];
        memset(v310, 0, 24);
        uint64_t v78 = *(void *)&v310[32];
        *(void *)&v310[32] = 0;
        ++*(_DWORD *)&v310[24];
        LOBYTE(v277) = 1;
        *(void *)&long long v278 = v76;
        *((void *)&v278 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v77;
        *(void *)&long long v279 = v27;
        memset(v283, 0, 24);
        *(void *)&long long v280 = v78;
        *(void *)&long long v284 = 0;
        DWORD2(v283[1]) = 2;
        DWORD2(v279) = 1;
        re::DynamicArray<re::MeshAssetBlendShapeData>::deinit((uint64_t)v283);
      }
    }
    else
    {
      LOBYTE(v277) = 0;
      *(void *)&long long v278 = 100;
      *((void *)&v278 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = re::AssetErrorCategory(void)::instance;
      long long v279 = v283[0];
      long long v280 = v283[1];
    }
  }
  else
  {
    *(void *)&v310[32] = 0;
    memset(v310, 0, 24);
    *(_DWORD *)&v310[24] = 1;
    LOBYTE(v277) = 1;
    memset(v283, 0, 24);
    long long v278 = 0u;
    *(void *)&long long v279 = 0;
    *(void *)&long long v280 = 0;
    *(void *)&long long v284 = 0;
    DWORD2(v283[1]) = 2;
    DWORD2(v279) = 1;
    re::DynamicArray<re::MeshAssetBlendShapeData>::deinit((uint64_t)v283);
    uint64_t v15 = "";
  }
  re::DynamicArray<re::MeshAssetBlendShapeData>::deinit((uint64_t)v310);
  if (!(_BYTE)v277)
  {
    long long v104 = v279;
    long long v279 = 0uLL;
    long long v105 = v280;
    long long v280 = 0uLL;
    *(unsigned char *)this = 0;
    *((_OWORD *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v278;
    *((_OWORD *)this + 2) = v104;
    *((_OWORD *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v105;
    re::Result<re::DynamicArray<re::MeshAssetBlendShapeData>,re::DetailedError>::~Result(&v277);
    goto LABEL_318;
  }
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v243, (uint64_t)&v278);
  unsigned int v79 = (_anonymous_namespace_ *)re::Result<re::DynamicArray<re::MeshAssetBlendShapeData>,re::DetailedError>::~Result(&v277);
  *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  uint64_t v277 = 0;
  long long v278 = 0uLL;
  LODWORD(v279) = 0;
  uint64_t v80 = *((void *)v232 + 87);
  if (!v80)
  {
    *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    uint64_t v277 = 0;
    long long v278 = 0u;
    LODWORD(v279) = 1;
    LOBYTE(v322[0]) = 1;
    memset(v283, 0, 24);
    memset((char *)v322 + 8, 0, 24);
    *((void *)&v322[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    *(void *)&long long v284 = 0;
    DWORD2(v283[1]) = 2;
    LODWORD(v322[2]) = 1;
LABEL_161:
    re::DynamicArray<re::MeshAssetContactDeformerData>::deinit((uint64_t)v283);
LABEL_162:
    re::DynamicArray<re::MeshAssetContactDeformerData>::deinit((uint64_t)&v277);
    if (!LOBYTE(v322[0]))
    {
      long long v123 = *(_OWORD *)((char *)&v322[1] + 8);
      memset((char *)&v322[1] + 8, 0, 32);
      uint64_t v124 = *((void *)&v322[2] + 1);
      uint64_t v125 = *(void *)&v322[3];
      *(unsigned char *)this = 0;
      *((_OWORD *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(_OWORD *)((char *)v322 + 8);
      *((_OWORD *)this + 2) = v123;
      *((void *)this + 6) = v124;
      *((void *)this + 7) = v125;
      re::Result<re::DynamicArray<re::MeshAssetContactDeformerData>,re::DetailedError>::~Result(v322);
      goto LABEL_318;
    }
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v256 + 8, (uint64_t)v322 + 8);
    uint64_t v109 = (_anonymous_namespace_ *)re::Result<re::DynamicArray<re::MeshAssetContactDeformerData>,re::DetailedError>::~Result(v322);
    *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    uint64_t v277 = 0;
    long long v278 = 0uLL;
    LODWORD(v279) = 0;
    uint64_t v110 = *((void *)v232 + 67);
    if (v110)
    {
      uint64_t v111 = *(unsigned __int16 *)(v110 + 32);
      if (*((void *)v232 + 7) != v111)
      {
        LOBYTE(v322[0]) = 0;
        *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 100;
        *(void *)&v322[1] = re::AssetErrorCategory(void)::instance;
        *(_OWORD *)((char *)&v322[1] + 8) = v283[0];
        *(_OWORD *)((char *)&v322[2] + 8) = v283[1];
        goto LABEL_184;
      }
      uint64_t v112 = *(void *)(v110 + 8);
      unint64_t v113 = (unsigned __int16)v112;
      int v114 = (unsigned __int16)v112;
      re::DynamicArray<re::MeshAssetSmoothDeformerData>::resize((uint64_t)&v277, (unsigned __int16)v112);
      if (v114)
      {
        unint64_t v27 = 0;
        unint64_t v28 = 8;
        unint64_t v14 = 0xFFFFLL;
        do
        {
          a4 = *((void *)&v278 + 1);
          if (*((void *)&v278 + 1) <= v27) {
            goto LABEL_327;
          }
          uint64_t v115 = (uint64_t *)(*((void *)&v279 + 1) + v28);
          *(_WORD *)(*((void *)&v279 + 1) + v28 + 8) = -1;
          re::SmoothDeformerModelUtil::envelopeBufferNameForSmoothDataIndex(v234, (const DeformationModelData *)(unsigned __int16)v27, (re::StringID *)v310);
          uint64_t v116 = *(void *)v310;
          uint64_t v117 = *(void *)&v310[8];
          *(void *)&v310[8] = "";
          *(void *)v310 = 0;
          unint64_t v118 = v116 & 0xFFFFFFFFFFFFFFFELL | *(v115 - 1) & 1;
          uint64_t v119 = *v115;
          uint64_t *v115 = v117;
          *((void *)&v283[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v119;
          *(void *)&v283[0] = v118;
          *(v115 - re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v116;
          re::StringID::destroyString((re::StringID *)v283);
          re::StringID::destroyString((re::StringID *)v310);
          ++v27;
          v28 += 24;
        }
        while (v113 != v27);
      }
      if (v111)
      {
        unint64_t v120 = 0;
        uint64_t v121 = *((void *)v232 + 67);
        unint64_t v27 = *((void *)&v278 + 1);
        uint64_t v122 = *((void *)&v279 + 1);
        a4 = (uint64_t)v310;
        do
        {
          if (v121)
          {
            if (*(void *)(v121 + 32) > v120)
            {
              unint64_t v28 = *(unsigned __int16 *)(*(void *)(v121 + 40) + 2 * v120);
              if (v28 < v113)
              {
                if (v27 <= v28) {
                  goto LABEL_333;
                }
                *(_WORD *)(v122 + 24 * *(unsigned __int16 *)(*(void *)(v121 + 40) + 2 * v120) + 16) = v120;
              }
            }
          }
          ++v120;
        }
        while (v111 != v120);
      }
      else
      {
        unint64_t v27 = *((void *)&v278 + 1);
        a4 = (uint64_t)v310;
      }
      uint64_t v126 = v277;
      uint64_t v127 = v278;
      uint64_t v277 = 0;
      long long v278 = 0uLL;
      uint64_t v128 = *((void *)&v279 + 1);
      *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      LODWORD(v279) = v279 + 1;
      LOBYTE(v322[0]) = 1;
      *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v126;
      *(void *)&v322[1] = v127;
      *((void *)&v322[1] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v27;
      memset(v283, 0, 24);
      *((void *)&v322[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v128;
      *(void *)&long long v284 = 0;
      DWORD2(v283[1]) = 2;
      LODWORD(v322[2]) = 1;
    }
    else
    {
      *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      uint64_t v277 = 0;
      long long v278 = 0u;
      LODWORD(v279) = 1;
      LOBYTE(v322[0]) = 1;
      memset(v283, 0, 24);
      memset((char *)v322 + 8, 0, 24);
      *((void *)&v322[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      *(void *)&long long v284 = 0;
      DWORD2(v283[1]) = 2;
      LODWORD(v322[2]) = 1;
    }
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v283);
LABEL_184:
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v277);
    if (LOBYTE(v322[0]))
    {
      re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v259 + 8, (uint64_t)v322 + 8);
      uint64_t v129 = (_anonymous_namespace_ *)re::Result<re::DynamicArray<re::MeshAssetSmoothDeformerData>,re::DetailedError>::~Result(v322);
      *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      uint64_t v277 = 0;
      long long v278 = 0uLL;
      LODWORD(v279) = 0;
      uint64_t v130 = *((void *)v232 + 77);
      if (!v130)
      {
        *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
        uint64_t v277 = 0;
        long long v278 = 0u;
        LODWORD(v279) = 1;
        LOBYTE(v322[0]) = 1;
        memset(v283, 0, 24);
        memset((char *)v322 + 8, 0, 24);
        *((void *)&v322[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
        *(void *)&long long v284 = 0;
        DWORD2(v283[1]) = 2;
        LODWORD(v322[2]) = 1;
LABEL_215:
        re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit((uint64_t)v283);
        goto LABEL_216;
      }
      uint64_t v131 = *(unsigned __int16 *)(v130 + 32);
      if (*((void *)v232 + 7) != v131)
      {
        LOBYTE(v322[0]) = 0;
        *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 100;
        *(void *)&v322[1] = re::AssetErrorCategory(void)::instance;
        *(_OWORD *)((char *)&v322[1] + 8) = v283[0];
        *(_OWORD *)((char *)&v322[2] + 8) = v283[1];
LABEL_216:
        re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit((uint64_t)&v277);
        if (!LOBYTE(v322[0]))
        {
          long long v167 = *(_OWORD *)((char *)&v322[1] + 8);
          memset((char *)&v322[1] + 8, 0, 32);
          uint64_t v168 = *((void *)&v322[2] + 1);
          uint64_t v169 = *(void *)&v322[3];
          *(unsigned char *)this = 0;
          *((_OWORD *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(_OWORD *)((char *)v322 + 8);
          *((_OWORD *)this + 2) = v167;
          *((void *)this + 6) = v168;
          *((void *)this + 7) = v169;
          re::Result<re::DynamicArray<re::MeshAssetWrapDeformerData>,re::DetailedError>::~Result(v322);
          goto LABEL_318;
        }
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v262 + 8, (uint64_t)v322 + 8);
        int v153 = (_anonymous_namespace_ *)re::Result<re::DynamicArray<re::MeshAssetWrapDeformerData>,re::DetailedError>::~Result(v322);
        *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
        uint64_t v277 = 0;
        long long v278 = 0uLL;
        LODWORD(v279) = 0;
        uint64_t v154 = *((void *)v232 + 62);
        if (!v154)
        {
          *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
          uint64_t v277 = 0;
          long long v278 = 0u;
          LODWORD(v279) = 1;
          LOBYTE(v322[0]) = 1;
          memset(v283, 0, 24);
          memset((char *)v322 + 8, 0, 24);
          *((void *)&v322[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
          *(void *)&long long v284 = 0;
          DWORD2(v283[1]) = 2;
          LODWORD(v322[2]) = 1;
          goto LABEL_239;
        }
        uint64_t v155 = *(unsigned __int16 *)(v154 + 32);
        if (*((void *)v232 + 7) != v155)
        {
          LOBYTE(v322[0]) = 0;
          *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 100;
          *(void *)&v322[1] = re::AssetErrorCategory(void)::instance;
          *(_OWORD *)((char *)&v322[1] + 8) = v283[0];
          *(_OWORD *)((char *)&v322[2] + 8) = v283[1];
          goto LABEL_240;
        }
        uint64_t v156 = *(void *)(v154 + 8);
        unint64_t v157 = (unsigned __int16)v156;
        int v158 = (unsigned __int16)v156;
        re::DynamicArray<re::MeshAssetSmoothDeformerData>::resize((uint64_t)&v277, (unsigned __int16)v156);
        if (!v158)
        {
LABEL_223:
          if (!v155) {
            goto LABEL_237;
          }
          unint64_t v164 = 0;
          uint64_t v165 = *((void *)v232 + 62);
          unint64_t v27 = *((void *)&v278 + 1);
          uint64_t v166 = *((void *)&v279 + 1);
          a4 = (uint64_t)v310;
          do
          {
            if (v165)
            {
              if (*(void *)(v165 + 32) > v164)
              {
                unint64_t v28 = *(unsigned __int16 *)(*(void *)(v165 + 40) + 2 * v164);
                if (v28 < v157)
                {
                  if (v27 <= v28) {
                    goto LABEL_338;
                  }
                  *(_WORD *)(v166 + 24 * *(unsigned __int16 *)(*(void *)(v165 + 40) + 2 * v164) + 16) = v164;
                }
              }
            }
            ++v164;
          }
          while (v155 != v164);
          goto LABEL_238;
        }
        unint64_t v27 = 0;
        unint64_t v28 = 8;
        unint64_t v14 = 0xFFFFLL;
        while (1)
        {
          a4 = *((void *)&v278 + 1);
          if (*((void *)&v278 + 1) <= v27) {
            break;
          }
          unint64_t v159 = *((void *)&v279 + 1) + v28;
          re::OffsetsDeformerModelUtil::envelopeBufferNameForOffsetsDataIndex(v234, (const DeformationModelData *)(unsigned __int16)v27, (re::StringID *)v310);
          uint64_t v160 = *(void *)v310;
          uint64_t v161 = *(void *)&v310[8];
          *(void *)&v310[8] = "";
          *(void *)v310 = 0;
          unint64_t v162 = v160 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v159 - 8) & 1;
          uint64_t v163 = *(void *)v159;
          *(void *)unint64_t v159 = v161;
          *((void *)&v283[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v163;
          *(void *)&v283[0] = v162;
          *(void *)(v159 - 8) = v160;
          re::StringID::destroyString((re::StringID *)v283);
          re::StringID::destroyString((re::StringID *)v310);
          *(_WORD *)(v159 + 8) = -1;
          ++v27;
          v28 += 24;
          if (v157 == v27) {
            goto LABEL_223;
          }
        }
LABEL_330:
        *(void *)v312 = 0;
        long long v285 = 0u;
        long long v286 = 0u;
        long long v284 = 0u;
        memset(v283, 0, sizeof(v283));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v310 = 136315906;
        *(void *)&v310[4] = "operator[]";
        *(_WORD *)&v310[12] = 1024;
        *(_DWORD *)&v310[14] = 789;
        *(_WORD *)&v310[18] = 2048;
        *(void *)&v310[20] = v27;
        *(_WORD *)&v310[28] = 2048;
        *(void *)&v310[30] = a4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_331:
        *(void *)v312 = 0;
        long long v285 = 0u;
        long long v286 = 0u;
        long long v284 = 0u;
        memset(v283, 0, sizeof(v283));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v322[0]) = 136315906;
        *(void *)(a4 + 164) = "operator[]";
        WORD6(v322[0]) = 1024;
        *(_DWORD *)(a4 + 174) = 789;
        WORD1(v322[1]) = 2048;
        *(void *)(a4 + 180) = v28;
        WORD6(v322[1]) = 2048;
        *(void *)(a4 + 190) = v27;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_332:
        *(void *)v312 = 0;
        long long v285 = 0u;
        long long v286 = 0u;
        long long v284 = 0u;
        memset(v283, 0, sizeof(v283));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v310 = 136315906;
        *(void *)&v310[4] = "operator[]";
        *(_WORD *)&v310[12] = 1024;
        *(_DWORD *)&v310[14] = 789;
        *(_WORD *)&v310[18] = 2048;
        *(void *)&v310[20] = v27;
        *(_WORD *)&v310[28] = 2048;
        *(void *)&v310[30] = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_333:
        *(void *)v312 = 0;
        long long v285 = 0u;
        long long v286 = 0u;
        long long v284 = 0u;
        memset(v283, 0, sizeof(v283));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v310 = 136315906;
        *(void *)(a4 + 4) = "operator[]";
        *(_WORD *)&v310[12] = 1024;
        *(_DWORD *)(a4 + 14) = 789;
        *(_WORD *)&v310[18] = 2048;
        *(void *)(a4 + 20) = v28;
        *(_WORD *)&v310[28] = 2048;
        *(void *)(a4 + 30) = v27;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_334:
        *(void *)v312 = 0;
        long long v285 = 0u;
        long long v286 = 0u;
        long long v284 = 0u;
        memset(v283, 0, sizeof(v283));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v322[0]) = 136315906;
        *(void *)((char *)v322 + 4) = "operator[]";
        WORD6(v322[0]) = 1024;
        *(_DWORD *)((char *)v322 + 14) = 468;
        WORD1(v322[1]) = 2048;
        *(void *)((char *)&v322[1] + 4) = v14;
        WORD6(v322[1]) = 2048;
        *(void *)((char *)&v322[1] + 14) = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_335;
      }
      uint64_t v132 = *(void *)(v130 + 8);
      int v133 = (unsigned __int16)v132;
      uint64_t v228 = (unsigned __int16)v132;
      re::DynamicArray<re::MeshAssetWrapDeformerData>::resize((uint64_t)&v277, (unsigned __int16)v132);
      if (!v133)
      {
LABEL_200:
        if (v131)
        {
          unint64_t v144 = 0;
          uint64_t v145 = *((void *)v232 + 77);
          unint64_t v27 = *((void *)&v278 + 1);
          uint64_t v146 = *((void *)&v279 + 1);
          uint64_t v15 = "";
          do
          {
            if (v145)
            {
              if (*(void *)(v145 + 32) > v144)
              {
                unint64_t v28 = *(unsigned __int16 *)(*(void *)(v145 + 40) + 2 * v144);
                if (v28 < v228)
                {
                  if (v27 <= v28) {
                    goto LABEL_337;
                  }
                  *(_WORD *)(v146 + 112 * *(unsigned __int16 *)(*(void *)(v145 + 40) + 2 * v144) + 104) = v144;
                }
              }
            }
            ++v144;
          }
          while (v131 != v144);
          goto LABEL_214;
        }
LABEL_213:
        unint64_t v27 = *((void *)&v278 + 1);
        uint64_t v15 = "";
LABEL_214:
        uint64_t v150 = v277;
        uint64_t v151 = v278;
        uint64_t v277 = 0;
        long long v278 = 0uLL;
        uint64_t v152 = *((void *)&v279 + 1);
        *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
        LODWORD(v279) = v279 + 1;
        LOBYTE(v322[0]) = 1;
        *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v150;
        *(void *)&v322[1] = v151;
        *((void *)&v322[1] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v27;
        memset(v283, 0, 24);
        *((void *)&v322[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v152;
        *(void *)&long long v284 = 0;
        DWORD2(v283[1]) = 2;
        LODWORD(v322[2]) = 1;
        goto LABEL_215;
      }
      unint64_t v28 = 0;
      unint64_t v27 = 0;
      unint64_t v12 = 112 * v228;
      while (1)
      {
        unint64_t v14 = *((void *)&v278 + 1);
        if (*((void *)&v278 + 1) <= v27) {
          break;
        }
        uint64_t v134 = *((void *)&v279 + 1);
        uint64_t v135 = (void *)(*((void *)&v279 + 1) + v28);
        unint64_t v11 = (unsigned __int16)v27;
        re::WrapDeformerModelUtil::targetMeshInstanceNameForWrapDataIndex(v234, (const DeformationModelData *)v11, (re::StringID *)v310);
        uint64_t v136 = *(void *)v310;
        uint64_t v137 = *(void *)&v310[8];
        *(void *)&v310[8] = "";
        *(void *)v310 = 0;
        uint64_t v138 = v135[1];
        unint64_t v139 = v136 & 0xFFFFFFFFFFFFFFFELL | *v135 & 1;
        v135[1] = v137;
        *((void *)&v283[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v138;
        *(void *)&v283[0] = v139;
        *uint64_t v135 = v136;
        re::StringID::destroyString((re::StringID *)v283);
        re::StringID::destroyString((re::StringID *)v310);
        re::WrapDeformerModelUtil::envelopeBufferNameForWrapDataIndex(v234, (const DeformationModelData *)v11, (re::StringID *)v310);
        uint64_t v140 = *(void *)v310;
        uint64_t v141 = *(void *)&v310[8];
        *(void *)&v310[8] = "";
        *(void *)v310 = 0;
        uint64_t v142 = v135[3];
        unint64_t v143 = v140 & 0xFFFFFFFFFFFFFFFELL | v135[2] & 1;
        v135[3] = v141;
        *((void *)&v283[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v142;
        *(void *)&v283[0] = v143;
        v135[2] = v140;
        re::StringID::destroyString((re::StringID *)v283);
        re::StringID::destroyString((re::StringID *)v310);
        re::WrapDeformerModelUtil::faceIndicesForWrapDataIndex(v234, (const DeformationModelData *)v11, (uint64_t)v283);
        re::FixedArray<float>::operator=(v135 + 4, (uint64_t *)v283);
        if (*(void *)&v283[0] && *((void *)&v283[0] + 1)) {
          (*(void (**)(void))(**(void **)&v283[0] + 40))();
        }
        re::WrapDeformerModelUtil::faceCoordinatesForWrapDataIndex(v234, (const DeformationModelData *)(unsigned __int16)v27, (uint64_t *)v283);
        re::FixedArray<float>::operator=(v135 + 7, (uint64_t *)v283);
        if (*(void *)&v283[0] && *((void *)&v283[0] + 1)) {
          (*(void (**)(void))(**(void **)&v283[0] + 40))();
        }
        re::WrapDeformerModelUtil::positionOffsetsForWrapDataIndex(v234, (const DeformationModelData *)(unsigned __int16)v27, (uint64_t *)v283);
        unint64_t v14 = v134 + v28;
        re::FixedArray<float>::operator=((uint64_t *)(v14 + 80), (uint64_t *)v283);
        a4 = (uint64_t)v310;
        if (*(void *)&v283[0] && *((void *)&v283[0] + 1)) {
          (*(void (**)(void))(**(void **)&v283[0] + 40))();
        }
        *(_WORD *)(v14 + 104) = -1;
        ++v27;
        v28 += 112;
        if (v12 == v28) {
          goto LABEL_200;
        }
      }
LABEL_329:
      *(void *)v312 = 0;
      long long v285 = 0u;
      long long v286 = 0u;
      long long v284 = 0u;
      memset(v283, 0, sizeof(v283));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v310 = 136315906;
      *(void *)(a4 + 4) = "operator[]";
      *(_WORD *)&v310[12] = 1024;
      *(_DWORD *)(a4 + 14) = 789;
      *(_WORD *)&v310[18] = 2048;
      *(void *)(a4 + 20) = v27;
      *(_WORD *)&v310[28] = 2048;
      *(void *)(a4 + 30) = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_330;
    }
LABEL_209:
    long long v147 = *(_OWORD *)((char *)&v322[1] + 8);
    memset((char *)&v322[1] + 8, 0, 32);
    uint64_t v148 = *((void *)&v322[2] + 1);
    uint64_t v149 = *(void *)&v322[3];
    *(unsigned char *)this = 0;
    *((_OWORD *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(_OWORD *)((char *)v322 + 8);
    *((_OWORD *)this + 2) = v147;
    *((void *)this + 6) = v148;
    *((void *)this + 7) = v149;
    re::Result<re::DynamicArray<re::MeshAssetSmoothDeformerData>,re::DetailedError>::~Result(v322);
    goto LABEL_318;
  }
  if (*(void *)(v80 + 32) != *((void *)v232 + 7))
  {
    LOBYTE(v322[0]) = 0;
    *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 100;
    *(void *)&v322[1] = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)((char *)&v322[1] + 8) = v283[0];
    *(_OWORD *)((char *)&v322[2] + 8) = v283[1];
    goto LABEL_162;
  }
  unint64_t v225 = *(void *)(v80 + 32);
  unint64_t v81 = *(void *)(v80 + 56);
  re::DynamicArray<re::MeshAssetContactDeformerData>::resize((uint64_t)&v277, v81);
  if (!v81)
  {
LABEL_143:
    if (v225)
    {
      unsigned __int16 v100 = 0;
      uint64_t v101 = *((void *)v232 + 87);
      unint64_t v27 = *((void *)&v278 + 1);
      uint64_t v102 = *((void *)&v279 + 1);
      uint64_t v8 = (uint64_t)&v247 + 8;
      do
      {
        if (v101 && *(void *)(v101 + 56) > (unint64_t)v100)
        {
          unint64_t v28 = *(unsigned __int16 *)(*(void *)(v101 + 64) + 2 * v100);
          if (v28 != 0xFFFF && v81 > v28)
          {
            if (v27 <= v28) {
              goto LABEL_336;
            }
            *(_WORD *)(v102 + 48 * *(unsigned __int16 *)(*(void *)(v101 + 64) + 2 * v100) + 40) = v100;
          }
        }
        ++v100;
      }
      while (v225 > v100);
    }
    else
    {
      unint64_t v27 = *((void *)&v278 + 1);
      uint64_t v8 = (uint64_t)&v247 + 8;
    }
    uint64_t v106 = v277;
    uint64_t v107 = v278;
    uint64_t v277 = 0;
    long long v278 = 0uLL;
    uint64_t v108 = *((void *)&v279 + 1);
    *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    LODWORD(v279) = v279 + 1;
    LOBYTE(v322[0]) = 1;
    *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v106;
    *(void *)&v322[1] = v107;
    *((void *)&v322[1] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v27;
    memset(v283, 0, 24);
    *((void *)&v322[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v108;
    *(void *)&long long v284 = 0;
    DWORD2(v283[1]) = 2;
    LODWORD(v322[2]) = 1;
    goto LABEL_161;
  }
  unint64_t v28 = 0;
  uint64_t v8 = 0;
  while (1)
  {
    unint64_t v27 = *((void *)&v278 + 1);
    if (*((void *)&v278 + 1) <= v28) {
      goto LABEL_326;
    }
    uint64_t v82 = *((void *)v232 + 87);
    if (v82 && *(void *)(v82 + 32) > (unint64_t)(unsigned __int16)v8) {
      uint64_t v15 = *(const char **)(*(void *)(v82 + 40) + 24 * (unsigned __int16)v8 + 8);
    }
    else {
      uint64_t v15 = 0;
    }
    unint64_t v14 = *((void *)&v279 + 1);
    uint64_t v83 = *((void *)&v279 + 1) + 48 * v28;
    unint64_t v11 = 48;
    *(_WORD *)(v83 + 40) = -1;
    re::ContactDeformerModelUtil::offsetBufferName(v234, (const DeformationModelData *)(unsigned __int16)v8, (re::StringID *)v310);
    uint64_t v84 = *(void *)v310;
    uint64_t v85 = *(void *)&v310[8];
    *(void *)&v310[8] = "";
    *(void *)v310 = 0;
    uint64_t v86 = *(void *)(v83 + 8);
    unint64_t v87 = v84 & 0xFFFFFFFFFFFFFFFELL | *(void *)v83 & 1;
    *(void *)(v83 + 8) = v85;
    *((void *)&v283[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v86;
    *(void *)&v283[0] = v87;
    *(void *)uint64_t v83 = v84;
    re::StringID::destroyString((re::StringID *)v283);
    re::StringID::destroyString((re::StringID *)v310);
    unint64_t v12 = v83 + 16;
    if (v15) {
      break;
    }
LABEL_142:
    uint64_t v8 = (v8 + 1);
    unint64_t v28 = (unsigned __int16)v8;
    a4 = (uint64_t)v310;
    uint64_t v15 = "";
    if (v81 <= (unsigned __int16)v8) {
      goto LABEL_143;
    }
  }
  uint64_t v89 = 0;
  uint64_t v90 = 0;
  unint64_t v12 = 0;
  unint64_t v91 = v14 + 48 * v28;
  long long v92 = (unint64_t *)(v91 + 24);
  long long v93 = (uint64_t *)(v91 + 32);
  unint64_t v14 = (unsigned __int16)v8;
  while (1)
  {
    unint64_t v11 = *v92;
    if (*v92 <= v12) {
      break;
    }
    uint64_t v94 = *((void *)v232 + 87);
    if (v94 && *(void *)(v94 + 32) > (unint64_t)(unsigned __int16)v8)
    {
      uint64_t v95 = *(void *)(v94 + 40);
      if (*(void *)(v95 + 24 * (unsigned __int16)v8 + 8) <= v12) {
        int v96 = -1;
      }
      else {
        int v96 = *(_DWORD *)(*(void *)(v95 + 24 * (unsigned __int16)v8 + 16) + v89);
      }
      uint64_t v97 = *v93;
      *(_DWORD *)(*v93 + v90) = v96;
      uint64_t v99 = *(void *)(v94 + 40);
      int v98 = 0;
      if (*(void *)(v99 + 24 * (unsigned __int16)v8 + 8) > v12) {
        int v98 = *(_DWORD *)(*(void *)(v99 + 24 * (unsigned __int16)v8 + 16) + v89 + 4);
      }
    }
    else
    {
      uint64_t v97 = *v93;
      *(_DWORD *)(*v93 + v90) = -1;
      int v98 = 0;
    }
    *(_DWORD *)(v97 + v90 + 4) = v98;
    re::ContactDeformerModelUtil::heightMapForTarget(v234, (const DeformationModelData *)(unsigned __int16)v8, v12, (uint64_t *)v312);
    unint64_t v11 = *v92;
    if (*v92 <= v12) {
      goto LABEL_236;
    }
    re::FixedArray<float>::operator=((uint64_t *)(*v93 + v90 + 8), (uint64_t *)v312);
    if (*(void *)v312 && *(void *)&v312[8]) {
      (*(void (**)(void))(**(void **)v312 + 40))();
    }
    ++v12;
    v90 += 32;
    v89 += 16;
    if (v15 == (const char *)v12) {
      goto LABEL_142;
    }
  }
  *(void *)v312 = 0;
  long long v285 = 0u;
  long long v286 = 0u;
  long long v284 = 0u;
  memset(v283, 0, sizeof(v283));
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  *(_DWORD *)v310 = 136315906;
  *(void *)&v310[4] = "operator[]";
  *(_WORD *)&v310[12] = 1024;
  *(_DWORD *)&v310[14] = 468;
  *(_WORD *)&v310[18] = 2048;
  *(void *)&v310[20] = v12;
  *(_WORD *)&v310[28] = 2048;
  *(void *)&v310[30] = v11;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_236:
  *(void *)v315 = 0;
  long long v285 = 0u;
  long long v286 = 0u;
  long long v284 = 0u;
  memset(v283, 0, sizeof(v283));
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  *(_DWORD *)v310 = 136315906;
  *(void *)&v310[4] = "operator[]";
  *(_WORD *)&v310[12] = 1024;
  *(_DWORD *)&v310[14] = 468;
  *(_WORD *)&v310[18] = 2048;
  *(void *)&v310[20] = v12;
  *(_WORD *)&v310[28] = 2048;
  *(void *)&v310[30] = v11;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_237:
  unint64_t v27 = *((void *)&v278 + 1);
  a4 = (uint64_t)v310;
LABEL_238:
  uint64_t v170 = v277;
  uint64_t v171 = v278;
  uint64_t v277 = 0;
  long long v278 = 0uLL;
  uint64_t v172 = *((void *)&v279 + 1);
  *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  LODWORD(v279) = v279 + 1;
  LOBYTE(v322[0]) = 1;
  *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v170;
  *(void *)&v322[1] = v171;
  *((void *)&v322[1] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v27;
  memset(v283, 0, 24);
  *((void *)&v322[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v172;
  *(void *)&long long v284 = 0;
  DWORD2(v283[1]) = 2;
  LODWORD(v322[2]) = 1;
LABEL_239:
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v283);
LABEL_240:
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v277);
  if (!LOBYTE(v322[0])) {
    goto LABEL_209;
  }
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v265 + 8, (uint64_t)v322 + 8);
  uint64_t v173 = (_anonymous_namespace_ *)re::Result<re::DynamicArray<re::MeshAssetSmoothDeformerData>,re::DetailedError>::~Result(v322);
  *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  uint64_t v277 = 0;
  long long v278 = 0uLL;
  LODWORD(v279) = 0;
  uint64_t v174 = *((void *)v232 + 97);
  if (!v174)
  {
    *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    uint64_t v277 = 0;
    long long v278 = 0u;
    LODWORD(v279) = 1;
    LOBYTE(v322[0]) = 1;
    memset(v283, 0, 24);
    memset((char *)v322 + 8, 0, 24);
    *((void *)&v322[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    *(void *)&long long v284 = 0;
    DWORD2(v283[1]) = 2;
    LODWORD(v322[2]) = 1;
    goto LABEL_273;
  }
  uint64_t v175 = *(unsigned __int16 *)(v174 + 104);
  if (*((void *)v232 + 7) != v175)
  {
    LOBYTE(v322[0]) = 0;
    *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 100;
    *(void *)&v322[1] = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)((char *)&v322[1] + 8) = v283[0];
    *(_OWORD *)((char *)&v322[2] + 8) = v283[1];
    goto LABEL_274;
  }
  unint64_t v14 = *(unsigned __int16 *)(v174 + 56);
  if (*(_WORD *)(v174 + 56))
  {
    re::DynamicArray<re::MeshAssetJiggleDeformerData>::setCapacity(&v277, *(unsigned __int16 *)(v174 + 56));
    unint64_t v176 = v14 - *((void *)&v278 + 1);
    if (v14 > *((void *)&v278 + 1))
    {
      uint64_t v177 = 48 * *((void *)&v278 + 1);
      do
      {
        uint64_t v178 = *((void *)&v279 + 1) + v177;
        *(void *)uint64_t v178 = 0;
        *(void *)(v178 + 8) = v15;
        *(void *)(v178 + 16) = 0;
        *(void *)(v178 + 24) = v15;
        *(void *)(v178 + 32) = 0;
        *(_WORD *)(v178 + 40) = 0;
        v177 += 48;
        --v176;
      }
      while (v176);
    }
    *((void *)&v278 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v14;
    LODWORD(v279) = v279 + 1;
  }
  if (!v14) {
    goto LABEL_263;
  }
  unint64_t v28 = 0;
  unint64_t v27 = 0;
  unint64_t v229 = v14;
  v14 *= 48;
  a4 = (uint64_t)v232 + 96;
  do
  {
    unint64_t v11 = *((void *)&v278 + 1);
    if (*((void *)&v278 + 1) <= v27) {
      goto LABEL_332;
    }
    unint64_t v12 = *((void *)&v279 + 1);
    unint64_t v179 = *((void *)&v279 + 1) + v28;
    re::JiggleDeformerModelUtil::massBufferNameForJiggleDataIndex(v234, (const DeformationModelData *)(unsigned __int16)v27, (re::StringID *)v310);
    uint64_t v180 = *(void *)v310;
    uint64_t v181 = *(void *)&v310[8];
    *(void *)&v310[8] = "";
    *(void *)v310 = 0;
    uint64_t v182 = *(void *)(v179 + 8);
    unint64_t v183 = v180 & 0xFFFFFFFFFFFFFFFELL | *(void *)v179 & 1;
    *(void *)(v179 + 8) = v181;
    *((void *)&v283[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v182;
    *(void *)&v283[0] = v183;
    *(void *)unint64_t v179 = v180;
    re::StringID::destroyString((re::StringID *)v283);
    re::StringID::destroyString((re::StringID *)v310);
    re::JiggleDeformerModelUtil::envelopeBufferNameForJiggleDataIndex(v234, (const DeformationModelData *)(unsigned __int16)v27, (re::StringID *)v310);
    uint64_t v184 = *(void *)v310;
    uint64_t v185 = *(void *)&v310[8];
    *(void *)&v310[8] = "";
    *(void *)v310 = 0;
    uint64_t v186 = *(void *)(v179 + 24);
    unint64_t v187 = v184 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v179 + 16) & 1;
    *(void *)(v179 + 24) = v185;
    *((void *)&v283[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v186;
    *(void *)&v283[0] = v187;
    *(void *)(v179 + 16) = v184;
    re::StringID::destroyString((re::StringID *)v283);
    re::StringID::destroyString((re::StringID *)v310);
    v188 = (void *)*((void *)v232 + 97);
    if (v188)
    {
      int v189 = 0;
      int v190 = 0;
      if (v188[7] > v27) {
        int v190 = *(_DWORD *)(v188[8] + 4 * v27);
      }
      *(_DWORD *)(v12 + v28 + 32) = v190;
      uint64_t v15 = "";
      if (v188[10] > v27) {
        int v189 = *(_DWORD *)(v188[11] + 4 * v27);
      }
    }
    else
    {
      *(_DWORD *)(v179 + 32) = 0;
      int v189 = 0;
      uint64_t v15 = "";
    }
    unint64_t v191 = v12 + v28;
    *(_DWORD *)(v191 + 36) = v189;
    *(_WORD *)(v191 + 40) = -1;
    ++v27;
    v28 += 48;
  }
  while (v14 != v28);
  unint64_t v27 = *((void *)&v278 + 1);
  a4 = (uint64_t)v310;
  unint64_t v14 = v229;
LABEL_264:
  uint64_t v192 = *((void *)&v279 + 1);
  if (v175)
  {
    unint64_t v193 = 0;
    uint64_t v194 = *((void *)v232 + 97);
    do
    {
      if (v194)
      {
        if (*(void *)(v194 + 104) > v193)
        {
          unint64_t v28 = *(unsigned __int16 *)(*(void *)(v194 + 112) + 2 * v193);
          if (v28 < v14)
          {
            if (v27 <= v28) {
              goto LABEL_339;
            }
            *(_WORD *)(v192 + 48 * *(unsigned __int16 *)(*(void *)(v194 + 112) + 2 * v193) + 40) = v193;
          }
        }
      }
      ++v193;
    }
    while (v175 != v193);
  }
  uint64_t v195 = v277;
  uint64_t v196 = v278;
  *((void *)&v279 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  uint64_t v277 = 0;
  long long v278 = 0uLL;
  LODWORD(v279) = v279 + 1;
  LOBYTE(v322[0]) = 1;
  *((void *)&v322[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v195;
  *(void *)&v322[1] = v196;
  *((void *)&v322[1] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v27;
  memset(v283, 0, 24);
  *((void *)&v322[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v192;
  *(void *)&long long v284 = 0;
  DWORD2(v283[1]) = 2;
  LODWORD(v322[2]) = 1;
LABEL_273:
  re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit((uint64_t)v283);
LABEL_274:
  re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit((uint64_t)&v277);
  if (LOBYTE(v322[0]))
  {
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v268 + 8, (uint64_t)v322 + 8);
    v197 = (_anonymous_namespace_ *)re::Result<re::DynamicArray<re::MeshAssetJiggleDeformerData>,re::DetailedError>::~Result(v322);
    if (*((void *)&v248 + 1))
    {
      LODWORD(v198) = 0;
      uint64_t v199 = *((void *)&v248 + 1) << 8;
      v200 = (_DWORD *)(v250 + 48);
      do
      {
        unint64_t v198 = (*v200 + v198);
        v200 += 64;
        v199 -= 256;
      }
      while (v199);
    }
    else
    {
      unint64_t v198 = 0;
    }
    memset(v310, 0, 24);
    v204 = (char *)*((void *)&v248 + 1);
    unint64_t v28 = *((void *)&v245 + 1);
    if (v204)
    {
      unsigned int v206 = 0;
      unint64_t v27 = 0;
      a4 = 144;
      *(_OWORD *)v235 = xmmword_23435FBB0;
      long long v233 = xmmword_23435FD80;
      long long v230 = xmmword_23435FD60;
      long long v226 = xmmword_23435FD50;
      while (1)
      {
        if (v27 >= v28)
        {
          BOOL v207 = 0;
        }
        else
        {
          unint64_t v14 = *((void *)&v245 + 1);
          if (*((void *)&v245 + 1) <= v27) {
            goto LABEL_341;
          }
          BOOL v207 = *(_DWORD *)(v247 + 144 * v27) != -1;
        }
        unint64_t v14 = *((void *)&v248 + 1);
        if (*((void *)&v248 + 1) <= v27) {
          goto LABEL_340;
        }
        uint64_t v208 = v250 + (v27 << 8);
        uint64_t v209 = *(void *)(v208 + 16);
        if (!v209) {
          break;
        }
        uint64_t v210 = *(unsigned int *)(v208 + 48);
        uint64_t v211 = *(void *)(v208 + 32);
        while (re::DynamicString::operator!=(v211, (uint64_t)&v277))
        {
          v211 += 80;
          if (!--v209) {
            goto LABEL_306;
          }
        }
        uint64_t v213 = *(void *)(v211 + 64);
        if (v207)
        {
          unint64_t v14 = *((void *)&v245 + 1);
          uint64_t v15 = "";
          if (*((void *)&v245 + 1) <= v27) {
            goto LABEL_342;
          }
          if (v210)
          {
            v214 = (float32x4_t *)(v247 + 144 * v27 + 80);
            v215 = (float *)(v213 + 8);
            while (1)
            {
              unint64_t v14 = v206;
              unint64_t v12 = *(void *)&v310[8];
              if (*(void *)&v310[8] <= (unint64_t)v206) {
                break;
              }
              ++v206;
              float v216 = *(v215 - 2);
              float v217 = *(v215 - 1);
              float v218 = *v215;
              v215 += 3;
              float32x4_t v219 = vaddq_f32(v214[3], vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*v214, v216), v214[1], v217), v214[2], v218));
              *(float32x4_t *)(*(void *)&v310[16] + 16 * v14) = vdivq_f32(v219, (float32x4_t)vdupq_laneq_s32((int32x4_t)v219, 3));
              if (!--v210) {
                goto LABEL_304;
              }
            }
LABEL_335:
            *(void *)v312 = 0;
            long long v285 = 0u;
            long long v286 = 0u;
            long long v284 = 0u;
            memset(v283, 0, sizeof(v283));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v322[0]) = 136315906;
            *(void *)((char *)v322 + 4) = "operator[]";
            WORD6(v322[0]) = 1024;
            *(_DWORD *)((char *)v322 + 14) = 468;
            WORD1(v322[1]) = 2048;
            *(void *)((char *)&v322[1] + 4) = v14;
            WORD6(v322[1]) = 2048;
            *(void *)((char *)&v322[1] + 14) = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_336:
            *(void *)v312 = 0;
            long long v285 = 0u;
            long long v286 = 0u;
            long long v284 = 0u;
            memset(v283, 0, sizeof(v283));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v310 = 136315906;
            *(void *)(a4 + 4) = "operator[]";
            *(_WORD *)&v310[12] = 1024;
            *(_DWORD *)(a4 + 14) = 789;
            *(_WORD *)&v310[18] = 2048;
            *(void *)(a4 + 20) = v28;
            *(_WORD *)&v310[28] = 2048;
            *(void *)(a4 + 30) = v27;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_337:
            *(void *)v312 = 0;
            long long v285 = 0u;
            long long v286 = 0u;
            long long v284 = 0u;
            memset(v283, 0, sizeof(v283));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v310 = 136315906;
            *(void *)(a4 + 4) = "operator[]";
            *(_WORD *)&v310[12] = 1024;
            *(_DWORD *)(a4 + 14) = 789;
            *(_WORD *)&v310[18] = 2048;
            *(void *)(a4 + 20) = v28;
            *(_WORD *)&v310[28] = 2048;
            *(void *)(a4 + 30) = v27;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_338:
            *(void *)v312 = 0;
            long long v285 = 0u;
            long long v286 = 0u;
            long long v284 = 0u;
            memset(v283, 0, sizeof(v283));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v310 = 136315906;
            *(void *)(a4 + 4) = "operator[]";
            *(_WORD *)&v310[12] = 1024;
            *(_DWORD *)(a4 + 14) = 789;
            *(_WORD *)&v310[18] = 2048;
            *(void *)(a4 + 20) = v28;
            *(_WORD *)&v310[28] = 2048;
            *(void *)(a4 + 30) = v27;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_339:
            *(void *)v312 = 0;
            long long v285 = 0u;
            long long v286 = 0u;
            long long v284 = 0u;
            memset(v283, 0, sizeof(v283));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v310 = 136315906;
            *(void *)(a4 + 4) = "operator[]";
            *(_WORD *)&v310[12] = 1024;
            *(_DWORD *)(a4 + 14) = 789;
            *(_WORD *)&v310[18] = 2048;
            *(void *)(a4 + 20) = v28;
            *(_WORD *)&v310[28] = 2048;
            *(void *)(a4 + 30) = v27;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_340:
            *(void *)v312 = 0;
            long long v285 = 0u;
            long long v286 = 0u;
            long long v284 = 0u;
            memset(v283, 0, sizeof(v283));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v322[0]) = 136315906;
            *(void *)((char *)v322 + 4) = "operator[]";
            WORD6(v322[0]) = 1024;
            *(_DWORD *)((char *)v322 + 14) = 797;
            WORD1(v322[1]) = 2048;
            *(void *)((char *)&v322[1] + 4) = v27;
            WORD6(v322[1]) = 2048;
            *(void *)((char *)&v322[1] + 14) = v14;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_341:
            *(void *)v312 = 0;
            long long v285 = 0u;
            long long v286 = 0u;
            long long v284 = 0u;
            memset(v283, 0, sizeof(v283));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v322[0]) = 136315906;
            *(void *)((char *)v322 + 4) = "operator[]";
            WORD6(v322[0]) = 1024;
            *(_DWORD *)((char *)v322 + 14) = 797;
            WORD1(v322[1]) = 2048;
            *(void *)((char *)&v322[1] + 4) = v27;
            WORD6(v322[1]) = 2048;
            *(void *)((char *)&v322[1] + 14) = v14;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_342:
            *(void *)v312 = 0;
            long long v285 = 0u;
            long long v286 = 0u;
            long long v284 = 0u;
            memset(v283, 0, sizeof(v283));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v322[0]) = 136315906;
            *(void *)((char *)v322 + 4) = "operator[]";
            WORD6(v322[0]) = 1024;
            *(_DWORD *)((char *)v322 + 14) = 797;
            WORD1(v322[1]) = 2048;
            *(void *)((char *)&v322[1] + 4) = v27;
            WORD6(v322[1]) = 2048;
            *(void *)((char *)&v322[1] + 14) = v14;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
        }
        else
        {
          uint64_t v15 = "";
          if (v210)
          {
            v220 = (_DWORD *)(v213 + 8);
            do
            {
              unint64_t v14 = v206;
              unint64_t v12 = *(void *)&v310[8];
              if (*(void *)&v310[8] <= (unint64_t)v206) {
                goto LABEL_334;
              }
              *(void *)&long long v212 = *((void *)v220 - 1);
              DWORD2(v212) = *v220;
              ++v206;
              *(_OWORD *)(*(void *)&v310[16] + 16 * v14) = v212;
              v220 += 3;
            }
            while (--v210);
          }
        }
LABEL_304:
        if ((char *)++v27 == v204) {
          goto LABEL_305;
        }
      }
LABEL_306:
      uint64_t v15 = "";
    }
    else
    {
LABEL_305:
      *(double *)&long long v221 = MEMORY[0x237DBD720](*(void *)&v310[8], *(void *)&v310[16]);
      long long v226 = v221;
      long long v230 = v222;
      long long v233 = v223;
      *(_OWORD *)v235 = v224;
    }
    if (v277 && (v278 & 1) != 0) {
      (*(void (**)(uint64_t, void))(*(void *)v277 + 40))(v277, *((void *)&v278 + 1));
    }
    if (*(void *)v310 && *(void *)&v310[8]) {
      (*(void (**)(void, void))(**(void **)v310 + 40))(*(void *)v310, *(void *)&v310[16]);
    }
    long long v239 = v226;
    long long v240 = v230;
    long long v241 = v233;
    long long v242 = *(_OWORD *)v235;
    v283[0] = v236;
    *(void *)&long long v236 = 0;
    *((void *)&v236 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v15;
    long long v285 = v226;
    long long v286 = v230;
    long long v287 = v233;
    long long v288 = *(_OWORD *)v235;
    v283[1] = v237;
    long long v284 = v238;
    *(void *)v289 = *(void *)&v243[0];
    memset(v243, 0, 24);
    *(_OWORD *)&v289[8] = *(_OWORD *)((char *)v243 + 8);
    ++DWORD2(v243[1]);
    *(_DWORD *)&v289[24] = 1;
    v290[0] = v244;
    v290[1] = v245;
    long long v244 = 0u;
    long long v245 = 0u;
    v292[0] = v247;
    long long v247 = 0u;
    v292[1] = v248;
    long long v248 = 0u;
    ++v246;
    ++v249;
    int v291 = 1;
    int v293 = 1;
    v294[0] = v250;
    v294[1] = v251;
    long long v250 = 0u;
    long long v251 = 0u;
    ++v252;
    int v295 = 1;
    long long v296 = v253;
    long long v297 = v254;
    long long v253 = 0u;
    long long v254 = 0u;
    ++v255;
    int v298 = 1;
    v299[0] = v256;
    v299[1] = v257;
    long long v256 = 0u;
    long long v257 = 0u;
    ++v258;
    int v300 = 1;
    v301[0] = v259;
    v301[1] = v260;
    long long v259 = 0u;
    long long v260 = 0u;
    ++v261;
    int v302 = 1;
    v303[0] = v262;
    v303[1] = v263;
    long long v262 = 0u;
    long long v263 = 0u;
    ++v264;
    int v304 = 1;
    v305[0] = v265;
    v305[1] = v266;
    long long v265 = 0u;
    long long v266 = 0u;
    ++v267;
    int v306 = 1;
    v307[0] = v268;
    v307[1] = v269;
    long long v268 = 0u;
    long long v269 = 0u;
    uint64_t v309 = v271;
    uint64_t v271 = 0;
    ++v270;
    int v308 = 1;
    *(unsigned char *)this = 1;
    re::MeshAssetModel::MeshAssetModel((uint64_t)this + 16, (uint64_t *)v283);
    re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit((uint64_t)v307 + 8);
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v305 + 8);
    re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit((uint64_t)v303 + 8);
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v301 + 8);
    re::DynamicArray<re::MeshAssetContactDeformerData>::deinit((uint64_t)v299 + 8);
    uint64_t v8 = (uint64_t)v227;
    if (*((void *)&v296 + 1))
    {
      if (*(void *)&v299[0]) {
        (*(void (**)(void, void))(**((void **)&v296 + 1) + 40))(*((void *)&v296 + 1), *(void *)&v299[0]);
      }
      *(void *)&v299[0] = 0;
      long long v297 = 0uLL;
      *((void *)&v296 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      ++v298;
    }
    re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)v294 + 8);
    re::DynamicArray<re::MeshAssetPart>::deinit((uint64_t)v292 + 8);
    re::DynamicArray<re::MeshAssetSkinningData>::deinit((uint64_t)v290 + 8);
    re::DynamicArray<re::MeshAssetBlendShapeData>::deinit((uint64_t)v289);
    re::StringID::destroyString((re::StringID *)v283);
  }
  else
  {
    long long v201 = *(_OWORD *)(a4 + 184);
    memset((char *)&v322[1] + 8, 0, 32);
    uint64_t v202 = *((void *)&v322[2] + 1);
    uint64_t v203 = *(void *)&v322[3];
    *(unsigned char *)this = 0;
    *((_OWORD *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(_OWORD *)((char *)v322 + 8);
    *((_OWORD *)this + 2) = v201;
    *((void *)this + 6) = v202;
    *((void *)this + 7) = v203;
    re::Result<re::DynamicArray<re::MeshAssetJiggleDeformerData>,re::DetailedError>::~Result(v322);
  }
LABEL_318:
  re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit((uint64_t)&v268 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v265 + 8);
  re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit((uint64_t)&v262 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v259 + 8);
  re::DynamicArray<re::MeshAssetContactDeformerData>::deinit((uint64_t)&v256 + 8);
  if (*((void *)&v253 + 1))
  {
    if ((void)v256) {
      (*(void (**)(void, void))(**((void **)&v253 + 1) + 40))(*((void *)&v253 + 1), v256);
    }
    *(void *)&long long v256 = 0;
    long long v254 = 0uLL;
    *((void *)&v253 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    ++v255;
  }
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v250 + 8);
  re::DynamicArray<re::MeshAssetPart>::deinit(v8);
  re::DynamicArray<re::MeshAssetSkinningData>::deinit((uint64_t)&v244 + 8);
  re::DynamicArray<re::MeshAssetBlendShapeData>::deinit((uint64_t)v243);
  re::StringID::destroyString((re::StringID *)&v236);
}

uint64_t re::DataArray<re::MeshInstance>::get(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 32) + 16 * HIWORD(a2)) + 144 * (unsigned __int16)a2;
}

void *re::MeshAssetLoader::downgradeMeshAssetFromFall2021@<X0>(void *this@<X0>, unsigned char *a2@<X8>)
{
  if (this)
  {
    unint64_t v5 = this;
    uint64_t v6 = this[3];
    if (v6)
    {
      unint64_t v7 = 0;
      uint64_t v8 = 232;
      do
      {
        if (v5[3] <= v7)
        {
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        this = (void *)re::DynamicArray<re::MeshAssetSkeleton>::operator=(v5[5] + v8, v5 + 11);
        ++v7;
        v8 += 512;
      }
      while (v6 != v7);
    }
  }
  *a2 = 1;
  return this;
}

uint64_t re::DynamicArray<re::MeshAssetSkeleton>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::MeshAssetSkeleton>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::MeshAssetSkeleton>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::MeshAssetSkeleton>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::MeshAssetSkeleton>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::MeshAssetLoader::assetNonIntrospectionNonSharedDataByteSize(re::MeshAssetLoader *this, void *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = a2;
  uint64_t v3 = 4 * a2[22] + 8 * a2[51] + 8 * a2[46] + 960;
  uint64_t v4 = a2[55];
  if (v4)
  {
    uint64_t v65 = a2[52];
    if (v65)
    {
      unint64_t v5 = 0;
      uint64_t v63 = v4 + 8;
      do
      {
        if (v2[52] <= v5) {
          goto LABEL_63;
        }
        uint64_t v6 = re::DataArray<re::MeshModel>::get(v63, *(void *)(v2[54] + 8 * v5));
        uint64_t v8 = (void *)v6;
        if (*(unsigned char *)v6) {
          size_t v9 = strlen(*(const char **)(v6 + 8)) + 1;
        }
        else {
          size_t v9 = 0;
        }
        uint64_t v66 = v3;
        uint64_t v10 = v8[7];
        if (v10)
        {
          uint64_t v11 = 0;
          uint64_t v12 = v8[8];
          do
          {
            uint64_t v13 = v12 + 560 * v11;
            uint64_t v14 = v13;
            do
            {
              uint64_t v15 = *(void *)(v14 + 32);
              uint64_t v14 = *(void *)(v14 + 8);
              if (v14) {
                BOOL v16 = v15 == 0;
              }
              else {
                BOOL v16 = 0;
              }
            }
            while (v16);
            uint64_t v17 = v12 + 560 * v11;
            do
            {
              uint64_t v18 = v17;
              uint64_t v17 = *(void *)(v17 + 8);
            }
            while (v17 && !*(void *)(v18 + 128));
            unint64_t v19 = *(void *)(v18 + 64);
            uint64_t v20 = v12 + 560 * v11;
            do
            {
              uint64_t v21 = v20;
              uint64_t v20 = *(void *)(v20 + 8);
            }
            while (v20 && !*(void *)(v21 + 128));
            unint64_t v22 = v19 + v15 + (v19 >> 4) + *(void *)(v21 + 120);
            uint64_t v23 = v12 + 560 * v11;
            do
            {
              uint64_t v24 = *(void *)(v23 + 128);
              uint64_t v23 = *(void *)(v23 + 8);
              if (v23) {
                BOOL v25 = v24 == 0;
              }
              else {
                BOOL v25 = 0;
              }
            }
            while (v25);
            do
            {
              uint64_t v26 = *(void *)(v13 + 128);
              uint64_t v13 = *(void *)(v13 + 8);
              if (v13) {
                BOOL v27 = v26 == 0;
              }
              else {
                BOOL v27 = 0;
              }
            }
            while (v27);
            BOOL v28 = (v26 & 7) != 0;
            if (*(unsigned char *)(v12 + 560 * v11 + 504)) {
              size_t v29 = strlen(*(const char **)(v12 + 560 * v11 + 512)) + 1;
            }
            else {
              size_t v29 = 0;
            }
            unint64_t v30 = (v24 + 8 * v28) & 0xFFFFFFFFFFFFFFF8;
            uint64_t v31 = *(void *)(v12 + 560 * v11 + 344);
            uint64_t v32 = v30 + v29 + 16 * (v22 + v31) + 560;
            if (v31)
            {
              uint64_t v33 = (const char **)(*(void *)(v12 + 560 * v11 + 352) + 8);
              do
              {
                if (*(unsigned char *)(v33 - 1)) {
                  size_t v34 = strlen(*v33) + 1;
                }
                else {
                  size_t v34 = 0;
                }
                v32 += v34;
                v33 += 2;
                --v31;
              }
              while (v31);
            }
            v9 += v32;
            ++v11;
          }
          while (v11 != v10);
        }
        unsigned int v35 = (re::SmoothDeformerModelUtil *)(v8 + 12);
        uint64_t v37 = re::BlendShapeModelUtil::computeBlendShapeModelSizeExcludingMetalBuffers((re::BlendShapeModelUtil *)(v8 + 12), v7);
        uint64_t v38 = v8[22];
        if (v38) {
          uint64_t v39 = 72 * *(void *)(v38 + 8) + 16 * *(void *)(v38 + 32) + 48;
        }
        else {
          uint64_t v39 = 0;
        }
        size_t v40 = re::ContactDeformerModelUtil::computeContactModelSizeExcludingMetalBuffers((re::ContactDeformerModelUtil *)(v8 + 12), v36);
        uint64_t v42 = re::SmoothDeformerModelUtil::computeSmoothDeformerModelSizeExcludingMetalBuffers(v35, v41);
        uint64_t v44 = re::WrapDeformerModelUtil::computeWrapDeformerModelSizeExcludingMetalBuffers(v35, v43);
        uint64_t v46 = re::OffsetsDeformerModelUtil::computeOffsetsDeformerModelSizeExcludingMetalBuffers(v35, v45);
        uint64_t v3 = v66
           + v9
           + v37
           + v39
           + v40
           + v42
           + v44
           + v46
           + re::JiggleDeformerModelUtil::computeJiggleDeformerModelSizeExcludingMetalBuffers(v35, v47)
           + 8;
        ++v5;
        uint64_t v2 = a2;
      }
      while (v5 != v65);
      uint64_t v4 = a2[55];
    }
    uint64_t v48 = v2[47];
    if (v48)
    {
      unint64_t v49 = 0;
      uint64_t v50 = v4 + 72;
      while (v2[47] > v49)
      {
        uint64_t v51 = re::DataArray<re::MeshInstance>::get(v50, *(void *)(v2[49] + 8 * v49));
        uint64_t v52 = v51;
        if (*(unsigned char *)v51) {
          size_t v53 = strlen(*(const char **)(v51 + 8)) + 1;
        }
        else {
          size_t v53 = 0;
        }
        v3 += 144 + v53 + 4 * *(void *)(v52 + 104) + 8 * *(void *)(v52 + 128);
        if (v48 == ++v49) {
          goto LABEL_53;
        }
      }
      goto LABEL_64;
    }
  }
LABEL_53:
  uint64_t v54 = 24 * v2[27];
  unint64_t v55 = (void *)v2[36];
  if (v55) {
    uint64_t v56 = [v55 estimatePayloadContainerOverheadSize];
  }
  else {
    uint64_t v56 = 0;
  }
  uint64_t v58 = v2[22];
  uint64_t v59 = v3
      + v54
      + v56
      + 4 * v58
      + re::MeshNameMap::estimateFootprint((re::MeshNameMap *)(v2 + 56))
      + 32 * (v2[113] + v2[110])
      - 424;
  uint64_t v60 = v2[117];
  if (v60)
  {
    uint64_t v61 = 0;
    unint64_t v62 = 0;
    while (v2[117] > v62)
    {
      v59 += re::Skeleton::estimatedFootprint((const char **)(v2[118] + v61));
      ++v62;
      v61 += 160;
      if (v60 == v62) {
        return v59 + 816 * v2[32];
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_63:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_64:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return v59 + 816 * v2[32];
}

void *re::MeshAsset::makeMeshAssetDataByCombiningPartsWithSharedMaterial(re::MeshAsset *this, const re::MeshAsset *a2)
{
  MEMORY[0x270FA5388](this);
  unint64_t v5 = v4;
  uint64_t v444 = *MEMORY[0x263EF8340];
  unint64_t v6 = (unint64_t)v379;
  memset(v379, 0, sizeof(v379));
  int v380 = 0;
  uint64_t v388 = 0;
  memset(v381, 0, sizeof(v381));
  int v382 = 0;
  memset(v383, 0, sizeof(v383));
  int v384 = 0;
  long long v385 = 0u;
  long long v386 = 0u;
  int v387 = 0;
  if (v3[952])
  {
    re::MeshAsset::makeMeshAssetDataFromRegisteredMeshAsset((re::MeshAsset *)&v392, (const re::MeshAsset *)v3);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v379, (uint64_t)&v392);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v381[8], (uint64_t)v394 + 8);
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v383[8], (uint64_t)v395);
    re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)&v385 + 8, (uint64_t)v396);
    if (v396[0])
    {
      if (v398) {
        (*(void (**)(void))(*(void *)v396[0] + 40))(v396[0]);
      }
      uint64_t v398 = 0;
      memset(v396, 0, sizeof(v396));
      ++v397;
    }
    re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)v395);
    re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)v394 + 8);
    uint64_t v3 = re::DynamicArray<re::MeshAssetModel>::deinit(&v392);
    unint64_t v7 = v379;
  }
  else
  {
    unint64_t v7 = v3 + 8;
  }
  unint64_t v8 = v7[2];
  if (!v8)
  {
    long long v85 = v392;
    long long v86 = v393;
    *(unsigned char *)unint64_t v5 = 0;
    *(void *)(v5 + 8) = 100;
    *(void *)(v5 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(v5 + 24) = v85;
    *(_OWORD *)(v5 + 40) = v86;
LABEL_462:
    if (*((void *)&v385 + 1))
    {
      if (v388) {
        (*(void (**)(void))(**((void **)&v385 + 1) + 40))();
      }
      uint64_t v388 = 0;
      long long v386 = 0uLL;
      *((void *)&v385 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
      ++v387;
    }
    re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v383[8]);
    re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v381[8]);
    return re::DynamicArray<re::MeshAssetModel>::deinit(v379);
  }
  v353 = v7;
  uint64_t v337 = v5;
  uint64_t v9 = (uint64_t)&v399;
  v399 = 0;
  unint64_t v400 = 0;
  int v401 = 1;
  unint64_t v402 = 0;
  v403 = 0;
  uint64_t v10 = (uint64_t)re::DynamicOverflowArray<unsigned int,128ul>::setCapacity(&v399, v8);
  char v11 = v401;
  v401 += 2;
  BOOL v12 = (v11 & 1) == 0;
  unint64_t v13 = 128;
  if (v12) {
    unint64_t v13 = v402;
  }
  if (v13 < v8) {
    uint64_t v10 = (uint64_t)re::DynamicOverflowArray<unsigned int,128ul>::setCapacity(&v399, v8);
  }
  unint64_t v14 = (unint64_t)&v402;
  unint64_t v15 = v400;
  if (v400 < v8)
  {
    do
    {
      if (v401) {
        BOOL v16 = &v402;
      }
      else {
        BOOL v16 = v403;
      }
      *((_DWORD *)v16 + v15++) = 0;
    }
    while (v8 != v15);
  }
  uint64_t v17 = v404;
  unint64_t v400 = v8;
  v401 += 2;
  uint64_t v18 = v353;
  unint64_t v19 = v353[2];
  v374 = 0;
  unint64_t v375 = 0;
  int v376 = 1;
  unint64_t v20 = (unint64_t)&v377;
  unint64_t v377 = 0;
  v378 = 0;
  if (v19)
  {
    uint64_t v10 = re::DynamicOverflowArray<re::DynamicOverflowArray<unsigned long long,64ul>,128ul>::setCapacity((uint64_t *)&v374, v19);
    char v21 = v376;
    v376 += 2;
    BOOL v12 = (v21 & 1) == 0;
    unint64_t v22 = 128;
    if (v12) {
      unint64_t v22 = v377;
    }
    if (v22 < v19) {
      uint64_t v10 = re::DynamicOverflowArray<re::DynamicOverflowArray<unsigned long long,64ul>,128ul>::setCapacity((uint64_t *)&v374, v19);
    }
    unint64_t v23 = v19 - v375;
    if (v19 > v375)
    {
      uint64_t v24 = 67 * v375;
      do
      {
        if (v376) {
          BOOL v25 = &v377;
        }
        else {
          BOOL v25 = v378;
        }
        uint64_t v26 = &v25[v24];
        *uint64_t v26 = 0;
        v26[1] = 0;
        *((_DWORD *)v26 + 4) = 1;
        v26[3] = 0;
        v26[4] = 0;
        v24 += 67;
        --v23;
      }
      while (v23);
    }
    unint64_t v375 = v19;
    v376 += 2;
    uint64_t v18 = v353;
    uint64_t v17 = v404;
    if (v353[2])
    {
      int v27 = 0;
      unint64_t v28 = 0;
      while (1)
      {
        unint64_t v29 = v375;
        if (v375 <= v28) {
          goto LABEL_476;
        }
        unint64_t v14 = v18[4];
        unint64_t v5 = v20;
        if (v376) {
          unint64_t v30 = v20;
        }
        else {
          unint64_t v30 = (unint64_t)v378;
        }
        uint64_t v31 = (void *)(v30 + 536 * v28);
        uint64_t v32 = (_OWORD *)(v14 + (v28 << 9));
        unint64_t v34 = *((void *)v32 + 26);
        unint64_t v2 = (unint64_t)(v32 + 13);
        unint64_t v33 = v34;
        unint64_t v36 = v31[1];
        unsigned int v35 = v31 + 1;
        BOOL v37 = v36 > v33;
        if (v36 >= v33)
        {
          uint64_t v9 = (uint64_t)&v399;
          if (!v37) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }
        if (*v31)
        {
          if (*(_DWORD *)(v30 + 536 * v28 + 16)) {
            goto LABEL_42;
          }
        }
        else
        {
          uint64_t v10 = (uint64_t)re::DynamicOverflowArray<unsigned long long,64ul>::setCapacity((void *)(v30 + 536 * v28), v33);
          uint64_t v17 = v404;
          unint64_t v39 = v30 + 536 * v28;
          int v40 = *(_DWORD *)(v39 + 16) + 2;
          *(_DWORD *)(v39 + 16) = v40;
          if (v40)
          {
LABEL_42:
            unint64_t v38 = 64;
            goto LABEL_43;
          }
        }
        unint64_t v38 = *(void *)(v30 + 536 * v28 + 24);
LABEL_43:
        if (v38 < v33)
        {
          uint64_t v10 = (uint64_t)re::DynamicOverflowArray<unsigned long long,64ul>::setCapacity((void *)(v30 + 536 * v28), v33);
          uint64_t v17 = v404;
        }
        unint64_t v41 = *v35;
        uint64_t v9 = (uint64_t)&v399;
        if (*v35 < v33)
        {
          unint64_t v42 = v30 + 536 * v28;
          int v43 = (unsigned char *)(v42 + 16);
          unint64_t v44 = v42 + 24;
          uint64_t v45 = (uint64_t *)(v42 + 32);
          do
          {
            unint64_t v46 = v44;
            if ((*v43 & 1) == 0) {
              unint64_t v46 = *v45;
            }
            *(void *)(v46 + 8 * v41++) = 0;
          }
          while (v33 != v41);
        }
LABEL_50:
        *unsigned int v35 = v33;
        *(_DWORD *)(v30 + 536 * v28 + 16) += 2;
LABEL_51:
        uint64_t v47 = (_OWORD *)(v14 + (v28 << 9));
        unint64_t v6 = (unint64_t)v379;
        unint64_t v20 = v5;
        if (*((void *)v47 + 16)) {
          goto LABEL_59;
        }
        if (*((void *)v47 + 21)) {
          goto LABEL_59;
        }
        uint64_t v48 = (_OWORD *)(v14 + (v28 << 9));
        if (*((void *)v48 + 36)) {
          goto LABEL_59;
        }
        if (*((void *)v48 + 41)) {
          goto LABEL_59;
        }
        unint64_t v49 = (_OWORD *)(v14 + (v28 << 9));
        if (*((void *)v49 + 46)) {
          goto LABEL_59;
        }
        if (*((void *)v49 + 51)) {
          goto LABEL_59;
        }
        uint64_t v50 = (_OWORD *)(v14 + (v28 << 9));
        if (*((void *)v50 + 56) || *((void *)v50 + 61)) {
          goto LABEL_59;
        }
        if (*(void *)v2)
        {
          size_t v53 = (_DWORD *)(*(void *)(v14 + (v28 << 9) + 224) + 64);
          uint64_t v54 = *(void *)v2 << 8;
          while (!*v53)
          {
            v53 += 64;
            v54 -= 256;
            if (!v54) {
              goto LABEL_70;
            }
          }
LABEL_59:
          unint64_t v29 = v400;
          if (v400 <= v28) {
            goto LABEL_477;
          }
          ++v27;
          unint64_t v14 = (unint64_t)&v402;
          if (v401) {
            uint64_t v51 = &v402;
          }
          else {
            uint64_t v51 = v403;
          }
          *((_DWORD *)v51 + v28) = v27;
          uint64_t v18 = v353;
          unint64_t v52 = v353[2];
          goto LABEL_64;
        }
LABEL_70:
        uint64_t v10 = re::DynamicOverflowArray<unsigned int,128ul>::operator[]((uint64_t)&v399, v28);
        *(_DWORD *)uint64_t v10 = 0;
        unint64_t v52 = v353[2];
        if (v52 <= v28) {
          goto LABEL_505;
        }
        uint64_t v55 = v353[4];
        uint64_t v17 = v404;
        if (*(void *)(v55 + (v28 << 9) + 208))
        {
          unint64_t v2 = 0;
          while (1)
          {
            uint64_t v56 = *(void *)(v55 + (v28 << 9) + 224);
            unint64_t v354 = v2;
            uint64_t v57 = v56 + (v2 << 8);
            uint64_t v58 = *(unsigned __int8 *)(v57 + 44);
            uint64_t v10 = re::MeshPartFlags::flattenToRenderFlags((re::MeshPartFlags *)(v57 + 192));
            unint64_t v2 = *(unsigned int *)(v57 + 232);
            if (v2)
            {
              uint64_t v59 = 0;
              uint64_t v60 = (int *)(*(void *)(v57 + 216) + 8);
              while (1)
              {
                int v61 = *v60;
                v60 += 20;
                if (v61 < 0) {
                  break;
                }
                if (v2 == ++v59)
                {
                  LODWORD(v59) = *(_DWORD *)(v57 + 232);
                  break;
                }
              }
            }
            else
            {
              LODWORD(v59) = 0;
            }
            unint64_t v62 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v58) ^ ((0xBF58476D1CE4E5B9 * v58) >> 27));
            unint64_t v63 = 0xBF58476D1CE4E5B9 * (v10 ^ ((unint64_t)v10 >> 30));
            unint64_t v64 = (((v62 ^ (v62 >> 31)) << 6)
                 - 0x61C8864680B583E9
                 + ((v62 ^ (v62 >> 31)) >> 2)
                 + ((0x94D049BB133111EBLL * (v63 ^ (v63 >> 27))) ^ ((0x94D049BB133111EBLL * (v63 ^ (v63 >> 27))) >> 31))) ^ v62 ^ (v62 >> 31);
            if (v2 != v59)
            {
              uint64_t v65 = v59;
              uint64_t v66 = v56 + (v354 << 8);
              uint64_t v69 = *(void *)(v66 + 216);
              uint64_t v68 = (uint64_t *)(v66 + 216);
              uint64_t v67 = v69;
              do
              {
                uint64_t v10 = re::Hash<re::DynamicString>::operator()((uint64_t)&v392, v67 + 80 * v65 + 16);
                v64 ^= (v64 << 6) - 0x61C8864680B583E9 + (v64 >> 2) + v10;
                uint64_t v67 = *v68;
                if (*(_DWORD *)(v57 + 232) <= (v59 + 1)) {
                  int v70 = v59 + 1;
                }
                else {
                  int v70 = *(_DWORD *)(v57 + 232);
                }
                int v71 = v59;
                while (1)
                {
                  uint64_t v65 = (v71 + 1);
                  if (v70 - 1 == v71) {
                    break;
                  }
                  ++v71;
                  LODWORD(v59) = v65;
                  if ((*(_DWORD *)(v67 + 80 * v65 + 8) & 0x80000000) != 0) {
                    goto LABEL_89;
                  }
                }
                LODWORD(v59) = v70;
LABEL_89:
                ;
              }
              while (v2 != v59);
            }
            uint64_t v72 = *(void *)(v57 + 16);
            if (v72)
            {
              uint64_t v73 = *(void *)(v57 + 32);
              unint64_t v2 = v73 + 80 * v72;
              unint64_t v6 = (unint64_t)v379;
              do
              {
                if (*(void *)(v73 + 8)) {
                  long long v74 = *(const char **)(v73 + 16);
                }
                else {
                  long long v74 = (const char *)(v73 + 9);
                }
                uint64_t v10 = strncmp(v74, "original", 8uLL);
                if (v10)
                {
                  if (*(unsigned char *)(v73 + 73) || !strcmp(v74, "indexTriangles"))
                  {
                    uint64_t v9 = (uint64_t)&v399;
                  }
                  else
                  {
                    uint64_t v77 = *(void *)(v73 + 48);
                    uint64_t v9 = (uint64_t)&v399;
                    if (v77)
                    {
                      uint64_t v78 = *(unsigned __int8 **)(v73 + 64);
                      do
                      {
                        unsigned int v79 = *v78++;
                        unint64_t v80 = 0x94D049BB133111EBLL
                            * ((0xBF58476D1CE4E5B9 * v79) ^ ((0xBF58476D1CE4E5B9 * v79) >> 27));
                        v64 ^= (v64 << 6) - 0x61C8864680B583E9 + (v64 >> 2) + (v80 ^ (v80 >> 31));
                        --v77;
                      }
                      while (v77);
                    }
                  }
                  uint64_t v10 = re::Hash<re::DynamicString>::operator()((uint64_t)&v392, v73);
                  unint64_t v75 = ((v64 << 6) - 0x61C8864680B583E9 + (v64 >> 2) + v10) ^ v64;
                  unint64_t v76 = 0x94D049BB133111EBLL
                      * ((0xBF58476D1CE4E5B9 * *(unsigned __int8 *)(v73 + 72)) ^ ((0xBF58476D1CE4E5B9
                                                                                   * *(unsigned __int8 *)(v73 + 72)) >> 27));
                  unint64_t v64 = ((v75 << 6) - 0x61C8864680B583E9 + (v75 >> 2) + (v76 ^ (v76 >> 31))) ^ v75;
                }
                else
                {
                  uint64_t v9 = (uint64_t)&v399;
                }
                v73 += 80;
              }
              while (v73 != v2);
            }
            else
            {
              unint64_t v6 = (unint64_t)v379;
              uint64_t v9 = (uint64_t)&v399;
            }
            unint64_t v52 = v375;
            if (v375 <= v28) {
              goto LABEL_506;
            }
            unint64_t v81 = (unint64_t)v378;
            if (v376) {
              unint64_t v81 = v5;
            }
            unint64_t v52 = *(void *)(v81 + 536 * v28 + 8);
            unint64_t v2 = v354;
            uint64_t v17 = v404;
            if (v52 <= v354) {
              goto LABEL_507;
            }
            unint64_t v20 = v5;
            uint64_t v82 = (*(unsigned char *)(v81 + 536 * v28 + 16) & 1) != 0 ? v81 + 536 * v28 + 24 : *(void *)(v81 + 536 * v28 + 32);
            *(void *)(v82 + 8 * v354) = v64;
            unint64_t v52 = v353[2];
            if (v52 <= v28) {
              break;
            }
            unint64_t v2 = v354 + 1;
            uint64_t v55 = v353[4];
            if (v354 + 1 >= *(void *)(v55 + (v28 << 9) + 208)) {
              goto LABEL_117;
            }
          }
LABEL_505:
          *(void *)&v410[0] = 0;
          memset(v394, 0, sizeof(v394));
          long long v393 = 0u;
          long long v392 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v404 = 136315906;
          *(void *)&v404[4] = "operator[]";
          *(_WORD *)&v404[12] = 1024;
          *(_DWORD *)&v404[14] = 797;
          *(_WORD *)&v404[18] = 2048;
          *(void *)&v404[20] = v28;
          *(_WORD *)&v404[28] = 2048;
          *(void *)&v404[30] = v52;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_506:
          *(void *)&v410[0] = 0;
          *(_OWORD *)(v6 + 248) = 0u;
          *(_OWORD *)(v6 + 232) = 0u;
          *(_OWORD *)(v6 + 216) = 0u;
          *(_OWORD *)(v6 + 200) = 0u;
          *(_OWORD *)(v6 + 184) = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v404 = 136315906;
          *(void *)&v404[4] = "operator[]";
          *(_WORD *)&v404[12] = 1024;
          *(_DWORD *)&v404[14] = 858;
          *(_WORD *)&v404[18] = 2048;
          *(void *)&v404[20] = v28;
          *(_WORD *)&v404[28] = 2048;
          *(void *)&v404[30] = v52;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_507:
          *((void *)v17 + 260) = 0;
          *(_OWORD *)(v6 + 248) = 0u;
          *(_OWORD *)(v6 + 232) = 0u;
          *(_OWORD *)(v6 + 216) = 0u;
          *(_OWORD *)(v6 + 200) = 0u;
          *(_OWORD *)(v6 + 184) = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v404 = 136315906;
          *(void *)&v404[4] = "operator[]";
          *(_WORD *)&v404[12] = 1024;
          *(_DWORD *)&v404[14] = 858;
          *(_WORD *)&v404[18] = 2048;
          *(void *)&v404[20] = v2;
          *(_WORD *)&v404[28] = 2048;
          *(void *)&v404[30] = v52;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_508:
          re::internal::assertLog((re::internal *)4, v146, "assertion failure: '%s' (%s:line %i) ", "combinedPartCount + nonCombinedCount == partTotal", "combineParts", 3061);
          _os_crash();
          __break(1u);
LABEL_509:
          uint64_t v256 = -1;
LABEL_510:
          uint64_t v391 = 0;
          long long v442 = 0u;
          long long v443 = 0u;
          memset(v441, 0, sizeof(v441));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v434 = 136315906;
          *(void *)&v434[4] = "operator[]";
          __int16 v435 = 1024;
          int v436 = 797;
          __int16 v437 = 2048;
          unint64_t v438 = v256;
          __int16 v439 = 2048;
          unint64_t v440 = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_117:
        uint64_t v18 = v353;
        unint64_t v14 = (unint64_t)&v402;
LABEL_64:
        if (++v28 >= v52) {
          goto LABEL_119;
        }
      }
    }
  }
  int v27 = 0;
  unint64_t v52 = 0;
LABEL_119:
  if (v52 == v27)
  {
    long long v83 = v392;
    long long v84 = v393;
    *(unsigned char *)uint64_t v337 = 0;
    *(void *)(v337 + 8) = 100;
    *(void *)(v337 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(v337 + 24) = v83;
    *(_OWORD *)(v337 + 40) = v84;
LABEL_448:
    if (v374)
    {
      char v319 = v376;
      if (v375)
      {
        if (v376) {
          uint64_t v320 = v20;
        }
        else {
          uint64_t v320 = (uint64_t)v378;
        }
        uint64_t v321 = 536 * v375;
        do
        {
          re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v320);
          v320 += 536;
          v321 -= 536;
        }
        while (v321);
        char v319 = v376;
      }
      if ((v319 & 1) == 0) {
        (*(void (**)(uint64_t *, unint64_t *))(*v374 + 40))(v374, v378);
      }
      v374 = 0;
      unint64_t v375 = 0;
    }
    if (v399 && (v401 & 1) == 0) {
      (*(void (**)(void))(*v399 + 40))();
    }
    goto LABEL_462;
  }
  long long v392 = 0uLL;
  LODWORD(v39re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 1;
  unint64_t v87 = v394;
  v394[0] = 0uLL;
  uint64_t v88 = v18[7];
  if (!v88) {
    goto LABEL_437;
  }
  LODWORD(v34re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v27;
  v333 = (const char *)v20;
  int v342 = 0;
  BOOL v355 = 0;
  uint64_t v89 = (unsigned int *)v18[9];
  uint64_t v90 = (_anonymous_namespace_ *)&v89[24 * v88];
  unint64_t v20 = (unint64_t)&v404[8];
  unint64_t v5 = 5152;
  v343 = v90;
  do
  {
    unint64_t v2 = v89[20];
    unint64_t v28 = v400;
    if (v400 <= v2) {
      goto LABEL_478;
    }
    unint64_t v91 = v403;
    if (v401) {
      unint64_t v91 = &v402;
    }
    if (*((_DWORD *)v91 + v2)) {
      goto LABEL_175;
    }
    v344 = v89;
    unint64_t v92 = v353[2];
    if (v92 <= v2) {
      goto LABEL_486;
    }
    unint64_t v93 = v353[4] + (v2 << 9);
    uint64_t v94 = *(void *)(v93 + 208);
    v351 = (unint64_t *)(v93 + 208);
    v342 += v94;
    if (!v94) {
      goto LABEL_174;
    }
    unint64_t v95 = 0;
    unint64_t v14 = (unint64_t)(v89 + 4);
    *(void *)v347 = v89[20];
    v349 = (void *)(v93 + 224);
    do
    {
      unint64_t v28 = *((void *)&v392 + 1);
      unint64_t v96 = *v349 + (v95 << 8);
      unsigned int v97 = *(unsigned __int16 *)(v96 + 56);
      uint64_t v9 = v96 + 56;
      unint64_t v2 = v97;
      if (*((void *)&v392 + 1) <= (unint64_t)v97)
      {
        unint64_t v28 = v2 + 1;
        if ((void)v392)
        {
          char v98 = v393;
        }
        else
        {
          uint64_t v17 = v404;
          char v98 = v393 + 2;
          LODWORD(v39re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v393 + 2;
        }
        BOOL v12 = (v98 & 1) == 0;
        unint64_t v99 = 64;
        if (v12) {
          unint64_t v99 = *(void *)&v394[0];
        }
        if (v99 <= v2)
        {
          uint64_t v17 = v404;
        }
        if (*((void *)&v392 + 1) <= v2)
        {
          uint64_t v100 = v2 - *((void *)&v392 + 1) + 1;
          uint64_t v101 = 322 * *((void *)&v392 + 1);
          do
          {
            if (v393) {
              uint64_t v102 = v394;
            }
            else {
              uint64_t v102 = (_OWORD *)*((void *)&v394[0] + 1);
            }
            float32x4_t v103 = &v102[v101];
            *(void *)float32x4_t v103 = 0;
            *((void *)v103 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
            *((_DWORD *)v103 + 4) = 1;
            *((void *)v103 + 4) = 0;
            *((void *)v103 + 5) = 0;
            v101 += 322;
            --v100;
          }
          while (v100);
        }
        *((void *)&v392 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v2 + 1;
        LODWORD(v39re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v393 + 2;
        unint64_t v2 = *(unsigned __int16 *)v9;
      }
      if (v28 <= v2)
      {
        *(void *)&v358.var0 = 0;
        memset(v404, 0, 80);
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v410[0]) = 136315906;
        *(void *)((char *)v410 + 4) = "operator[]";
        WORD6(v410[0]) = 1024;
        *(_DWORD *)((char *)v410 + 14) = 858;
        WORD1(v410[1]) = 2048;
        *(void *)((char *)&v410[1] + 4) = v2;
        WORD6(v410[1]) = 2048;
        *(void *)((char *)&v410[1] + 14) = v28;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_468:
        *(void *)&v358.var0 = 0;
        *((_OWORD *)v17 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0u;
        *((_OWORD *)v17 + 4) = 0u;
        *((_OWORD *)v17 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
        *((_OWORD *)v17 + 2) = 0u;
        *(_OWORD *)uint64_t v17 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v410[0]) = 136315906;
        *(void *)((char *)v410 + 4) = "operator[]";
        WORD6(v410[0]) = 1024;
        *(_DWORD *)((char *)v410 + 14) = 858;
        WORD1(v410[1]) = 2048;
        *(void *)((char *)&v410[1] + 4) = v28;
        WORD6(v410[1]) = 2048;
        *(void *)((char *)&v410[1] + 14) = v87;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_469:
        uint64_t v391 = 0;
        unint64_t v5 = (unint64_t)v428;
        long long v442 = 0u;
        long long v443 = 0u;
        memset(v441, 0, sizeof(v441));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v434 = 136315906;
        *(void *)&v434[4] = "operator[]";
        __int16 v435 = 1024;
        int v436 = 797;
        __int16 v437 = 2048;
        unint64_t v438 = v28;
        __int16 v439 = 2048;
        unint64_t v440 = v95;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_470:
        unint64_t v6 = (unint64_t)v379;
LABEL_471:
        uint64_t v391 = 0;
        unint64_t v29 = (unint64_t)v428;
        long long v442 = 0u;
        long long v443 = 0u;
        memset(v441, 0, sizeof(v441));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)v434 = 136315906;
        *(void *)&v434[4] = "operator[]";
        __int16 v435 = 1024;
        int v436 = 797;
        __int16 v437 = 2048;
        unint64_t v438 = v95;
        __int16 v439 = 2048;
        unint64_t v440 = v28;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_472;
      }
      if ((v393 & 1) == 0) {
        unint64_t v87 = (_OWORD *)*((void *)&v394[0] + 1);
      }
      long long v104 = &v87[322 * v2];
      *(_OWORD *)&v404[8] = *(_OWORD *)v14;
      *(_OWORD *)&v404[24] = *(_OWORD *)(v14 + 16);
      *(_OWORD *)&v404[40] = *(_OWORD *)(v14 + 32);
      *(_OWORD *)&v404[56] = *(_OWORD *)(v14 + 48);
      if (!*v104)
      {
        int v114 = &v87[322 * v2];
        unint64_t v115 = *((void *)v114 + 1) + 1;
        uint64_t v17 = v404;
        int v106 = *((_DWORD *)v114 + 4) + 2;
        *((_DWORD *)v114 + 4) = v106;
        goto LABEL_163;
      }
      long long v105 = &v87[322 * v2];
      int v108 = *((_DWORD *)v105 + 4);
      uint64_t v107 = v105 + 1;
      LOBYTE(v106) = v108;
      unint64_t v109 = *((void *)v107 - 1);
      if (v108)
      {
        if (v109 - 64 >= 0xFFFFFFFFFFFFFFBFLL) {
          goto LABEL_163;
        }
        unint64_t v111 = v109 + 1;
        unint64_t v113 = 128;
        goto LABEL_159;
      }
      unint64_t v110 = *(void *)&v87[322 * v2 + 2];
      BOOL v112 = v109 >= v110;
      unint64_t v111 = v109 + 1;
      BOOL v112 = !v112 || v110 >= v111;
      if (!v112)
      {
        unint64_t v113 = 2 * v110;
LABEL_159:
        if (v113 <= v111) {
          unint64_t v116 = v111;
        }
        else {
          unint64_t v116 = v113;
        }
        int v106 = *v107;
        uint64_t v17 = v404;
      }
LABEL_163:
      if (v106) {
        uint64_t v117 = (uint64_t)&v87[322 * v2 + 2];
      }
      else {
        uint64_t v117 = v104[5];
      }
      unint64_t v6 = (unint64_t)v379;
      unint64_t v118 = &v87[322 * v2];
      uint64_t v119 = v117 + 80 * *((void *)v118 + 1);
      unint64_t v2 = *(void *)v347;
      *(_DWORD *)uint64_t v119 = v347[0];
      *(_DWORD *)(v119 + 4) = v95;
      long long v121 = *(_OWORD *)&v404[32];
      long long v120 = *(_OWORD *)&v404[48];
      uint64_t v122 = *(void *)&v404[64];
      *(_OWORD *)(v119 + 24) = *(_OWORD *)&v404[16];
      *(void *)(v119 + 72) = v122;
      *(_OWORD *)(v119 + 56) = v120;
      *(_OWORD *)(v119 + 40) = v121;
      *(_OWORD *)(v119 + 8) = *(_OWORD *)v404;
      ++*((void *)v118 + 1);
      *((_DWORD *)v118 + 4) += 2;
      if (v355)
      {
        BOOL v355 = 1;
        unint64_t v87 = v394;
      }
      else
      {
        unint64_t v28 = *(unsigned __int16 *)v9;
        unint64_t v87 = (_OWORD *)*((void *)&v392 + 1);
        if (*((void *)&v392 + 1) <= v28) {
          goto LABEL_468;
        }
        long long v123 = (_OWORD *)*((void *)&v394[0] + 1);
        unint64_t v87 = v394;
        if (v393) {
          long long v123 = v394;
        }
        BOOL v355 = *((void *)&v123[322 * *(unsigned __int16 *)v9] + 1) > 1uLL;
      }
      ++v95;
    }
    while (v95 < *v351);
    uint64_t v9 = (uint64_t)&v399;
    unint64_t v14 = (unint64_t)&v402;
LABEL_174:
    uint64_t v90 = v343;
    uint64_t v89 = v344;
LABEL_175:
    v89 += 24;
  }
  while (v89 != (unsigned int *)v90);
  unint64_t v20 = (unint64_t)v333;
  unint64_t v5 = v341;
  if (!v355)
  {
LABEL_437:
    long long v313 = *(_OWORD *)v404;
    uint64_t v314 = *(void *)&v404[16];
    uint64_t v315 = *(void *)&v404[24];
    *(unsigned char *)uint64_t v337 = 0;
    *(void *)(v337 + 8) = 100;
    *(void *)(v337 + 16) = re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(v337 + 24) = v313;
    *(void *)(v337 + 40) = v314;
    *(void *)(v337 + 48) = v315;
LABEL_438:
    if ((void)v392)
    {
      char v316 = v393;
      if (*((void *)&v392 + 1))
      {
        if (v393) {
          int v317 = v394;
        }
        else {
          int v317 = (_OWORD *)*((void *)&v394[0] + 1);
        }
        uint64_t v318 = 5152 * *((void *)&v392 + 1);
        do
        {
          v317 += 322;
          v318 -= 5152;
        }
        while (v318);
        char v316 = v393;
      }
      if ((v316 & 1) == 0) {
        (*(void (**)(void, void))(*(void *)v392 + 40))(v392, *((void *)&v394[0] + 1));
      }
    }
    goto LABEL_448;
  }
  v373 = 0;
  long long v371 = 0uLL;
  uint64_t v370 = 0;
  int v372 = 0;
  re::DynamicArray<re::MeshAssetModel>::resize((uint64_t)&v370, (v341 + 1));
  unint64_t v124 = v353[7];
  uint64_t v369 = 0;
  long long v367 = 0uLL;
  int v368 = 0;
  re::DynamicArray<re::MeshAssetInstance>::setCapacity(&v366, v124);
  ++v368;
  uint64_t v126 = v373;
  re::StringID::destroyString(v373);
  *(void *)uint64_t v126 = 0x523B6FD560ALL;
  *((void *)v126 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = "combined";
  v335 = (float32x4_t *)v126;
  *(void *)&v358.var0 = 0;
  v358.var1 = "";
  long long v359 = xmmword_23435FD50;
  long long v360 = xmmword_23435FD60;
  long long v361 = xmmword_23435FD80;
  long long v362 = xmmword_23435FBB0;
  int v363 = 0;
  char v364 = 0;
  int v365 = 1065353216;
  re::DynamicArray<re::MeshAssetInstance>::add((_anonymous_namespace_ *)&v366, &v358);
  uint64_t v128 = v404;
  if (v341)
  {
    uint64_t v129 = v353;
    unint64_t v130 = v353[2];
    if (v130)
    {
      uint64_t v131 = 0;
      unint64_t v92 = 0;
      while (1)
      {
        unint64_t v28 = v400;
        if (v400 <= v92) {
          break;
        }
        if (v401) {
          unint64_t v29 = *((unsigned int *)&v402 + v92);
        }
        else {
          unint64_t v29 = *((unsigned int *)v403 + v92);
        }
        uint64_t v129 = v353;
        if (v29)
        {
          unint64_t v28 = *((void *)&v371 + 1);
          if (*((void *)&v371 + 1) <= v29) {
            goto LABEL_492;
          }
          uint64_t v132 = v353[4] + v131;
          int v133 = (unint64_t *)((char *)v373 + 512 * v29);
          re::StringID::operator=(v133, (uint64_t *)v132);
          long long v134 = *(_OWORD *)(v132 + 32);
          *((_OWORD *)v133 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(_OWORD *)(v132 + 16);
          *((_OWORD *)v133 + 2) = v134;
          long long v135 = *(_OWORD *)(v132 + 48);
          long long v136 = *(_OWORD *)(v132 + 64);
          long long v137 = *(_OWORD *)(v132 + 96);
          *((_OWORD *)v133 + 5) = *(_OWORD *)(v132 + 80);
          *((_OWORD *)v133 + 6) = v137;
          *((_OWORD *)v133 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v135;
          *((_OWORD *)v133 + 4) = v136;
          re::DynamicArray<re::MeshAssetBlendShapeData>::operator=((uint64_t)(v133 + 14), (uint64_t *)(v132 + 112));
          re::DynamicArray<re::MeshAssetSkinningData>::operator=((uint64_t)(v133 + 19), (uint64_t *)(v132 + 152));
          re::DynamicArray<re::MeshAssetPart>::operator=((uint64_t)(v133 + 24), (uint64_t *)(v132 + 192));
          re::DynamicArray<re::MeshAssetSkeleton>::operator=((uint64_t)(v133 + 29), (uint64_t *)(v132 + 232));
          re::DynamicArray<re::MeshLodLevelInfo>::operator=((uint64_t)(v133 + 34), (uint64_t *)(v132 + 272));
          re::DynamicArray<re::MeshAssetContactDeformerData>::operator=((uint64_t)(v133 + 39), (uint64_t *)(v132 + 312));
          re::DynamicArray<re::MeshAssetSmoothDeformerData>::operator=((uint64_t)(v133 + 44), (uint64_t *)(v132 + 352));
          re::DynamicArray<re::MeshAssetWrapDeformerData>::operator=((uint64_t)(v133 + 49), (uint64_t *)(v132 + 392));
          re::DynamicArray<re::MeshAssetSmoothDeformerData>::operator=((uint64_t)(v133 + 54), (uint64_t *)(v132 + 432));
          re::DynamicArray<re::MeshAssetJiggleDeformerData>::operator=((uint64_t)(v133 + 59), (uint64_t *)(v132 + 472));
          uint64_t v129 = v353;
          uint64_t v128 = v404;
          unint64_t v130 = v353[2];
        }
        ++v92;
        v131 += 512;
        if (v92 >= v130) {
          goto LABEL_188;
        }
      }
LABEL_487:
      unint64_t v29 = (unint64_t)v428;
      v441[0] = 0;
      v128[3] = 0u;
      v128[4] = 0u;
      v128[1] = 0u;
      v128[2] = 0u;
      *uint64_t v128 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 858;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v92;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v28;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_488:
      unint64_t v28 = (unint64_t)v428;
      v441[0] = 0;
      v128[3] = 0u;
      v128[4] = 0u;
      v128[1] = 0u;
      v128[2] = 0u;
      *uint64_t v128 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 858;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v92;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_489:
      re::internal::assertLog((re::internal *)4, (uint64_t)v255, "assertion failure: '%s' (%s:line %i) ", "bufferOffset + count * sizeof(IndexType) <= destBufferSize", "copyAndOffsetTriangleIndices", 2880);
      _os_crash();
      __break(1u);
LABEL_490:
      re::internal::assertLog((re::internal *)4, (uint64_t)v255, "assertion failure: '%s' (%s:line %i) ", "bufferOffset + count * sizeof(IndexType) <= destBufferSize", "copyAndOffsetTriangleIndices", 2880);
      _os_crash();
      __break(1u);
LABEL_491:
      re::internal::assertLog((re::internal *)4, v239, "assertion failure: '%s' (%s:line %i) ", "bufferIndex >= 0", "combineAttributeBuffers", 2944);
      _os_crash();
      __break(1u);
LABEL_492:
      unint64_t v92 = (unint64_t)v428;
      v441[0] = 0;
      v128[3] = 0u;
      v128[4] = 0u;
      v128[1] = 0u;
      v128[2] = 0u;
      *uint64_t v128 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 789;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v29;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v28;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_493:
      unint64_t v28 = (unint64_t)v410;
      v428[0] = 0;
      long long v411 = 0u;
      *(_OWORD *)v412 = 0u;
      memset(v410, 0, sizeof(v410));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v441[0]) = 136315906;
      *(void *)((char *)v441 + 4) = "operator[]";
      WORD2(v441[1]) = 1024;
      *(_DWORD *)((char *)&v441[1] + 6) = 858;
      WORD1(v441[2]) = 2048;
      *(void *)((char *)&v441[2] + 4) = v92;
      WORD2(v441[3]) = 2048;
      *(void *)((char *)&v441[3] + 6) = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_494:
      re::internal::assertLog((re::internal *)4, v247, "assertion failure: '%s' (%s:line %i) ", "srcBuffer.stepFunction != mtl::VertexStepFunction::kPerVertex || newElementCount == combinedPart.vertexCount", "combineAttributeBuffers", 2953);
      _os_crash();
      __break(1u);
LABEL_495:
      re::internal::assertLog((re::internal *)4, (uint64_t)v255, "assertion failure: '%s' (%s:line %i) ", "bufferOffset / elementSize == newElementCount", "combineAttributeBuffers", 2979);
      _os_crash();
      __break(1u);
      unint64_t v163 = (unint64_t)v428;
      v441[0] = 0;
      v324[3] = 0u;
      v324[4] = 0u;
      v324[1] = 0u;
      v324[2] = 0u;
      _OWORD *v324 = 0u;
      uint64_t v326 = v325;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 858;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v326;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v28;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_496:
      uint64_t v165 = v428;
      v441[0] = 0;
      v160[3] = 0u;
      uint64_t v160[4] = 0u;
      v160[1] = 0u;
      v160[2] = 0u;
      *uint64_t v160 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 797;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v28;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v163;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_497:
      unint64_t v28 = (unint64_t)v428;
      v441[0] = 0;
      v160[3] = 0u;
      uint64_t v160[4] = 0u;
      v160[1] = 0u;
      v160[2] = 0u;
      *uint64_t v160 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 797;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v163;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v165;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_498:
      unint64_t v163 = (unint64_t)v428;
      v441[0] = 0;
      v160[3] = 0u;
      uint64_t v160[4] = 0u;
      v160[1] = 0u;
      v160[2] = 0u;
      *uint64_t v160 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 866;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v28;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_499:
      unint64_t v172 = (unint64_t)v428;
      v441[0] = 0;
      v160[3] = 0u;
      uint64_t v160[4] = 0u;
      v160[1] = 0u;
      v160[2] = 0u;
      *uint64_t v160 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 866;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v163;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v165;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_500:
      unint64_t v156 = (unint64_t)v428;
      v441[0] = 0;
      v160[3] = 0u;
      uint64_t v160[4] = 0u;
      v160[1] = 0u;
      v160[2] = 0u;
      *uint64_t v160 = 0u;
      v214 = (void *)&_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 789;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v172;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v165;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_501:
      re::internal::assertLog((re::internal *)4, v213, "assertion failure: '%s' (%s:line %i) Combine vertex count overflow.", "combinedPart.indexType == mtl::IndexType::kUInt32 || combinedPart.vertexCount < 65535", "combineParts", 3050);
      _os_crash();
      __break(1u);
LABEL_502:
      v214[10] = 0;
      *((_OWORD *)v214 + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
      *((_OWORD *)v214 + 12) = 0u;
      *((_OWORD *)v214 + 9) = 0u;
      *((_OWORD *)v214 + 10) = 0u;
      *((_OWORD *)v214 + 8) = 0u;
      v214 = (void *)&_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v428[0]) = 136315906;
      *(void *)((char *)v428 + 4) = "operator[]";
      WORD2(v428[1]) = 1024;
      *(_DWORD *)((char *)&v428[1] + 6) = 797;
      WORD1(v428[2]) = 2048;
      *(void *)((char *)&v428[2] + 4) = v156;
      WORD2(v428[3]) = 2048;
      *(void *)((char *)&v428[3] + 6) = v172;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_503:
      v214[10] = 0;
      *((_OWORD *)v214 + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
      *((_OWORD *)v214 + 12) = 0u;
      *((_OWORD *)v214 + 9) = 0u;
      *((_OWORD *)v214 + 10) = 0u;
      *((_OWORD *)v214 + 8) = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v428[0]) = 136315906;
      *(void *)((char *)v428 + 4) = "operator[]";
      WORD2(v428[1]) = 1024;
      *(_DWORD *)((char *)&v428[1] + 6) = 797;
      WORD1(v428[2]) = 2048;
      *(void *)((char *)&v428[2] + 4) = v172;
      WORD2(v428[3]) = 2048;
      *(void *)((char *)&v428[3] + 6) = v156;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_504;
    }
LABEL_188:
    uint64_t v138 = v129[7];
    if (v138)
    {
      uint64_t v139 = v353[9];
      unint64_t v29 = 96 * v138;
      do
      {
        unint64_t v92 = *(unsigned int *)(v139 + 80);
        unint64_t v5 = v400;
        if (v400 <= v92) {
          goto LABEL_488;
        }
        uint64_t v140 = v403;
        if (v401) {
          uint64_t v140 = &v402;
        }
        if (*((_DWORD *)v140 + v92))
        {
          re::StringID::StringID((re::StringID *)v404, (const StringID *)v139);
          long long v141 = *(_OWORD *)(v139 + 16);
          long long v142 = *(_OWORD *)(v139 + 32);
          long long v143 = *(_OWORD *)(v139 + 64);
          *(_OWORD *)&v404[48] = *(_OWORD *)(v139 + 48);
          *(_OWORD *)&v404[64] = v143;
          *(_OWORD *)&v404[16] = v141;
          *(_OWORD *)&v404[32] = v142;
          unint64_t v5 = v400;
          if (v400 <= v92) {
            goto LABEL_493;
          }
          if (v401) {
            unint64_t v144 = &v402;
          }
          else {
            unint64_t v144 = v403;
          }
          *(_DWORD *)&v404[80] = *((_DWORD *)v144 + v92);
          *(void *)&v404[84] = *(void *)(v139 + 84);
          re::DynamicArray<re::MeshAssetInstance>::add((_anonymous_namespace_ *)&v366, (uint64_t *)v404);
          re::StringID::destroyString((re::StringID *)v404);
          uint64_t v128 = v404;
        }
        v139 += 96;
        v29 -= 96;
      }
      while (v29);
    }
  }
  v330 = (_anonymous_namespace_ *)&v335[12];
  uint64_t v145 = *((void *)&v392 + 1);
  uint64_t v146 = *((void *)&v392 + 1) + 4;
  if (v335[12].i64[1] < (unint64_t)(*((void *)&v392 + 1) + 4))
  {
    re::DynamicArray<re::MeshAssetPart>::setCapacity(v330, v146);
    uint64_t v145 = *((void *)&v392 + 1);
  }
  if (!v145) {
    goto LABEL_427;
  }
  long long v147 = 0;
  int v332 = 0;
  unint64_t v148 = 0;
  char v149 = v393;
  uint64_t v9 = 80;
  int32x4_t v327 = vdupq_n_s32(0x7F800000u);
LABEL_204:
  if (v149) {
    uint64_t v150 = v394;
  }
  else {
    uint64_t v150 = (_OWORD *)*((void *)&v394[0] + 1);
  }
  unint64_t v5 = (unint64_t)v147;
  unint64_t v151 = v148;
  if (v150[322 * v148 + 1]) {
    unint64_t v152 = (unint64_t)&v150[322 * v148 + 2];
  }
  else {
    unint64_t v152 = *((void *)&v150[322 * v148 + 2] + 1);
  }
  unint64_t v153 = *((void *)&v150[322 * v148] + 1);
  *(void *)v404 = &v374;
  unint64_t v154 = 126 - 2 * __clz(v153);
  if (v153) {
    uint64_t v155 = v154;
  }
  else {
    uint64_t v155 = 0;
  }
  unint64_t v156 = *((void *)&v392 + 1);
  unint64_t v157 = v151;
  if (*((void *)&v392 + 1) <= v151) {
    goto LABEL_504;
  }
  unint64_t v158 = 0;
  unint64_t v159 = (unint64_t *)&v394[322 * v151] + 1;
  uint64_t v160 = v404;
  unint64_t v329 = v151;
  uint64_t v146 = 5152;
  v331 = v159;
  long long v147 = (const char *)v5;
  while (1)
  {
    char v149 = v393;
    if (v393)
    {
      unint64_t v162 = *v159;
      uint64_t v161 = v394;
    }
    else
    {
      uint64_t v161 = (_OWORD *)*((void *)&v394[0] + 1);
      unint64_t v162 = *(void *)(*((void *)&v394[0] + 1) + 5152 * v157 + 8);
    }
    if (v158 >= v162)
    {
      unint64_t v148 = v157 + 1;
      if (v148 >= v156)
      {
        LODWORD(v145) = v332 + v147;
LABEL_427:
        if (v145 != v342) {
          goto LABEL_508;
        }
        uint64_t v409 = 0;
        int v405 = 0;
        float32x4_t v406 = 0u;
        long long v407 = 0u;
        int v408 = 0;
        *(void *)v404 = v370;
        uint64_t v370 = 0;
        *(_OWORD *)&v404[8] = v371;
        long long v371 = 0u;
        v312 = v373;
        v373 = 0;
        ++v372;
        *(_DWORD *)&v404[24] = 1;
        *(void *)&v404[32] = v312;
        *(void *)&v404[40] = v366;
        v366 = 0;
        *(_OWORD *)&v404[48] = v367;
        long long v367 = 0u;
        *(void *)&v404[72] = v369;
        memset(&v404[80], 0, 24);
        uint64_t v369 = 0;
        ++v368;
        *(_DWORD *)&v404[64] = 1;
        re::MeshAssetData::generateMetaData((re::MeshAssetData *)v404);
        *(void *)&v410[0] = *(void *)v404;
        memset(v404, 0, 24);
        *(_OWORD *)((char *)v410 + 8) = *(_OWORD *)&v404[8];
        ++*(_DWORD *)&v404[24];
        DWORD2(v410[1]) = 1;
        v410[2] = *(_OWORD *)&v404[32];
        long long v411 = *(_OWORD *)&v404[48];
        memset(&v404[32], 0, 32);
        ++*(_DWORD *)&v404[64];
        *(_DWORD *)v412 = 1;
        *(_OWORD *)&v412[8] = *(_OWORD *)&v404[72];
        memset(&v404[72], 0, 32);
        *(_OWORD *)v413 = *(_OWORD *)&v404[88];
        ++v405;
        *(_DWORD *)&v413[16] = 1;
        float32x4_t v414 = v406;
        long long v415 = v407;
        float32x4_t v406 = 0u;
        long long v407 = 0u;
        *((void *)&v416 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v409;
        uint64_t v409 = 0;
        ++v408;
        LODWORD(v416) = 1;
        re::Result<re::MeshAssetData,re::DetailedError>::Result(v337, (uint64_t)v410);
        if (v414.i64[1])
        {
          if (*((void *)&v416 + 1)) {
            (*(void (**)(void))(*(void *)v414.i64[1] + 40))();
          }
          *((void *)&v416 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
          long long v415 = 0uLL;
          v414.i64[1] = 0;
          LODWORD(v416) = v416 + 1;
        }
        re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v412[16]);
        re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v410[2] + 8);
        re::DynamicArray<re::MeshAssetModel>::deinit(v410);
        if (v406.i64[1])
        {
          if (v409) {
            (*(void (**)(void))(*(void *)v406.i64[1] + 40))();
          }
          uint64_t v409 = 0;
          long long v407 = 0uLL;
          v406.i64[1] = 0;
          ++v408;
        }
        re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v404[80]);
        re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v404[40]);
        re::DynamicArray<re::MeshAssetModel>::deinit(v404);
        re::StringID::destroyString((re::StringID *)&v358);
        re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v366);
        re::DynamicArray<re::MeshAssetModel>::deinit(&v370);
        unint64_t v20 = (unint64_t)v333;
        goto LABEL_438;
      }
      goto LABEL_204;
    }
    if (v161[322 * v157 + 1]) {
      unint64_t v2 = (unint64_t)&v161[322 * v157 + 2];
    }
    else {
      unint64_t v2 = *((void *)&v161[322 * v157 + 2] + 1);
    }
    unint64_t v28 = *(unsigned int *)(v2 + 80 * v158);
    unint64_t v163 = v353[2];
    if (v163 <= v28) {
      goto LABEL_496;
    }
    unint64_t v163 = *(unsigned int *)(v2 + 80 * v158 + 4);
    unint64_t v164 = v353[4] + (v28 << 9);
    uint64_t v165 = *(void **)(v164 + 208);
    if ((unint64_t)v165 <= v163) {
      goto LABEL_497;
    }
    uint64_t v9 = v375;
    if (v375 <= v28) {
      goto LABEL_498;
    }
    unint64_t v166 = (unint64_t)v378;
    if (v376) {
      unint64_t v166 = v20;
    }
    uint64_t v165 = *(void **)(v166 + 536 * v28 + 8);
    if ((unint64_t)v165 <= v163) {
      goto LABEL_499;
    }
    uint64_t v167 = (*(unsigned char *)(v166 + 536 * v28 + 16) & 1) != 0
         ? v166 + 536 * v28 + 24
         : *(void *)(v166 + 536 * v28 + 32);
    unint64_t v20 = v147;
    uint64_t v168 = *(void *)(v164 + 224);
    uint64_t v169 = v168 + (v163 << 8);
    uint64_t v170 = *(void *)(v167 + 8 * v163);
    v356 = (char *)(v158 + 1);
    uint64_t v171 = (unint64_t *)(*((void *)&v394[0] + 1) + 5152 * v157 + 8);
    unint64_t v172 = 80 * v158;
    uint64_t v173 = 80 * v158;
    unint64_t v174 = 1;
    v334 = (_anonymous_namespace_ *)v158;
    while (1)
    {
      unint64_t v175 = v158 + v174;
      if (v393)
      {
        unint64_t v14 = *v159;
        unint64_t v176 = v394;
        if (v175 < *v159) {
          goto LABEL_236;
        }
        uint64_t v180 = v394;
        if (v174 > 1) {
          goto LABEL_272;
        }
LABEL_252:
        unint64_t v181 = v335[13].u64[0];
        if (v181 >= v335[12].i64[1])
        {
          re::DynamicArray<re::MeshAssetPart>::growCapacity(v330, v181 + 1);
          unint64_t v181 = v335[13].u64[0];
        }
        uint64_t v182 = v335[14].i64[0];
        uint64_t v183 = v182 + (v181 << 8);
        re::DynamicArray<re::MeshAssetBuffer>::DynamicArray(v183, (uint64_t *)(v168 + (v163 << 8)));
        uint64_t v184 = v168 + (v163 << 8);
        long long v185 = *(_OWORD *)(v184 + 40);
        *(_OWORD *)(v183 + 52) = *(_OWORD *)(v184 + 52);
        *(_OWORD *)(v183 + 40) = v185;
        re::StringID::StringID((re::StringID *)(v183 + 72), (const StringID *)(v184 + 72));
        long long v186 = *(_OWORD *)(v184 + 112);
        *(_OWORD *)(v183 + 96) = *(_OWORD *)(v184 + 96);
        *(_OWORD *)(v183 + 112) = v186;
        long long v187 = *(_OWORD *)(v184 + 128);
        long long v188 = *(_OWORD *)(v184 + 144);
        long long v189 = *(_OWORD *)(v184 + 176);
        *(_OWORD *)(v183 + 160) = *(_OWORD *)(v184 + 160);
        *(_OWORD *)(v183 + 176) = v189;
        *(_OWORD *)(v183 + 128) = v187;
        *(_OWORD *)(v183 + 144) = v188;
        int v190 = *(unsigned __int8 *)(v184 + 192);
        *(unsigned char *)(v183 + 192) = v190;
        if (v190) {
          *(unsigned char *)(v183 + 19re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(unsigned char *)(v184 + 193);
        }
        int v191 = *(unsigned __int8 *)(v184 + 194);
        *(unsigned char *)(v183 + 194) = v191;
        if (v191) {
          *(unsigned char *)(v182 + (v181 << 8) + 195) = *(unsigned char *)(v168 + (v163 << 8) + 195);
        }
        unint64_t v192 = v182 + (v181 << 8);
        uint64_t v193 = v168 + (v163 << 8);
        int v194 = *(unsigned __int8 *)(v193 + 196);
        *(unsigned char *)(v192 + 196) = v194;
        uint64_t v195 = v335;
        if (v194) {
          *(unsigned char *)(v192 + 197) = *(unsigned char *)(v193 + 197);
        }
        uint64_t v196 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v192 + 200, v193 + 200);
        ++v335[13].i64[0];
        ++v335[13].i32[2];
        uint64_t v197 = *(void *)(v169 + 16);
        unint64_t v6 = (unint64_t)v379;
        if (v197)
        {
          int v198 = 0;
          if (v404[8]) {
            uint64_t v199 = *(const char **)&v404[16];
          }
          else {
            uint64_t v199 = &v404[9];
          }
          v200 = (const char **)(*(void *)(v169 + 32) + 16);
          unint64_t v5 = 80 * v197;
          do
          {
            if ((unint64_t)*(v200 - 1)) {
              long long v201 = *v200;
            }
            else {
              long long v201 = (char *)v200 - 7;
            }
            if (!strcmp(v199, v201)) {
              goto LABEL_271;
            }
            ++v198;
            v200 += 10;
            v5 -= 80;
          }
          while (v5);
          int v198 = -1;
LABEL_271:
          uint64_t v160 = v404;
          uint64_t v195 = v335;
        }
        else
        {
          int v198 = -1;
          uint64_t v160 = v404;
        }
        uint64_t v146 = 5152;
        unint64_t v159 = v331;
        int v291 = v334;
        if (*(void *)v404 && (v404[8] & 1) != 0)
        {
          (*(void (**)(void))(**(void **)v404 + 40))();
          int v291 = v334;
          unint64_t v159 = v331;
          uint64_t v146 = 5152;
          uint64_t v160 = v404;
        }
        uint64_t v292 = v195[14].i64[0] + (v195[13].i64[0] << 8);
        unint64_t v172 = v198;
        uint64_t v165 = *(void **)(v292 - 240);
        if ((unint64_t)v165 <= v198) {
          goto LABEL_500;
        }
        uint64_t v9 = 80;
        uint64_t v293 = *(void *)(v292 - 224) + 80 * (int)v172;
        unint64_t v294 = *(void *)(v293 + 48);
        uint64_t v295 = *(void *)(v293 + 64);
        long long v296 = (float32x4_t *)(v2 + 80 * (void)v291);
        float32x4_t v298 = v296[1];
        float32x4_t v299 = v296[2];
        long long v297 = v296 + 1;
        float32x4_t v300 = vaddq_f32(v297[3], vaddq_f32(v297[2], vmlaq_f32(vmulq_f32(v298, (float32x4_t)0), (float32x4_t)0, v299)));
        unint64_t v157 = v329;
        if (v300.f32[2] == 1.0
          || fabsf(v300.f32[2] + -1.0) < (float)((float)((float)(fabsf(v300.f32[2]) + 1.0) + 1.0) * 0.0001))
        {
          int8x16_t v301 = (int8x16_t)vmulq_f32(v300, v300);
          float v302 = vaddv_f32(vadd_f32(*(float32x2_t *)v301.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v301, v301, 8uLL)));
          v303 = v335;
          if (v302 == 1.0) {
            goto LABEL_422;
          }
          if (fabsf(v302 + -1.0) < (float)((float)((float)(fabsf(v302) + 1.0) + 1.0) * 0.0001) || v294 <= 0xB) {
            goto LABEL_422;
          }
        }
        else
        {
          v303 = v335;
          if (v294 < 0xC)
          {
LABEL_422:
            float32x4_t v308 = *(float32x4_t *)(v184 + 96);
            float32x4_t v309 = v303[1];
            float32x4_t v310 = v303[2];
            v309.i32[3] = 0;
            v308.i32[3] = 0;
            v303[1] = vminnmq_f32(v309, v308);
            v310.i32[3] = 0;
            float32x4_t v311 = *(float32x4_t *)(v168 + (v163 << 8) + 112);
            v311.i32[3] = 0;
            _OWORD v303[2] = vmaxnmq_f32(v310, v311);
            ++v332;
            v290 = v356;
            goto LABEL_423;
          }
        }
        unint64_t v305 = v294 / 0xC;
        int v306 = (float *)(v295 + 8);
        do
        {
          float32x4_t v307 = vaddq_f32(v297[3], vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*v297, *(v306 - 2)), v297[1], *(v306 - 1)), v297[2], *v306));
          *((void *)v306 - re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v307.i64[0];
          *int v306 = v307.f32[2];
          v306 += 3;
          --v305;
        }
        while (v305);
        goto LABEL_422;
      }
      unint64_t v14 = *v171;
      unint64_t v176 = (_OWORD *)*((void *)&v394[0] + 1);
      if (v175 >= *v171) {
        break;
      }
LABEL_236:
      if (v14 <= v175) {
        goto LABEL_479;
      }
      if (v176[322 * v157 + 1]) {
        uint64_t v177 = (uint64_t)&v176[322 * v157 + 2];
      }
      else {
        uint64_t v177 = *((void *)&v176[322 * v157 + 2] + 1);
      }
      uint64_t v178 = v177 + v173;
      unint64_t v6 = *(unsigned int *)(v178 + 80);
      if (v375 <= v6) {
        goto LABEL_480;
      }
      unint64_t v14 = *(unsigned int *)(v178 + 84);
      unint64_t v5 = *(void *)(v166 + 536 * v6 + 8);
      if (v5 <= v14) {
        goto LABEL_481;
      }
      uint64_t v179 = (*(unsigned char *)(v166 + 536 * v6 + 16) & 1) != 0
           ? v166 + 536 * v6 + 24
           : *(void *)(v166 + 536 * v6 + 32);
      unint64_t v6 = (unint64_t)v379;
      if (v170 != *(void *)(v179 + 8 * v14)) {
        break;
      }
      ++v174;
      v173 += 80;
    }
    if (v174 < 2) {
      goto LABEL_252;
    }
    uint64_t v180 = v394;
    if ((v393 & 1) == 0) {
      uint64_t v180 = (_OWORD *)*((void *)&v394[0] + 1);
    }
LABEL_272:
    char v202 = v180[322 * v157 + 1];
    uint64_t v203 = &v180[322 * v157];
    if (v202) {
      v204 = v203 + 2;
    }
    else {
      v204 = (_OWORD *)*((void *)v203 + 5);
    }
    uint64_t v9 = 80;
    *(void *)&v410[2] = 0;
    memset(v410, 0, 28);
    BYTE12(v410[2]) = 1;
    WORD4(v41re::ResourceSharingManager::~ResourceSharingManager(this - 1) = -1;
    *(void *)&v412[8] = 0;
    *(void *)&v412[16] = "";
    v205.i64[0] = 0x7F0000007FLL;
    v205.i64[1] = 0x7F0000007FLL;
    *(int32x4_t *)&v413[8] = v327;
    float32x4_t v414 = v205;
    char v421 = 0;
    char v423 = 0;
    memset(v425, 0, sizeof(v425));
    int v426 = 0;
    long long v415 = 0u;
    long long v416 = 0u;
    long long v417 = 0u;
    long long v418 = 0u;
    char v419 = 0;
    uint64_t v427 = 0x7FFFFFFFLL;
    uint64_t v206 = v168 + (v163 << 8);
    WORD4(v41re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(_WORD *)(v206 + 56);
    *(void *)&long long v411 = 0x100000000;
    DWORD1(v41re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(_DWORD *)(v206 + 52);
    DWORD2(v410[2]) = 0;
    HIDWORD(v41re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    *(_DWORD *)v412 = 0;
    BYTE12(v410[2]) = *(unsigned char *)(v206 + 44);
    if (*(unsigned char *)(v206 + 192))
    {
      char v419 = 1;
      char v420 = *(unsigned char *)(v206 + 193);
    }
    if (*(unsigned char *)(v206 + 194))
    {
      char v421 = 1;
      char v422 = *(unsigned char *)(v168 + (v163 << 8) + 195);
    }
    unint64_t v348 = v174;
    unsigned int v328 = v147;
    uint64_t v207 = v168 + (v163 << 8);
    if (*(unsigned char *)(v207 + 196))
    {
      char v423 = 1;
      char v424 = *(unsigned char *)(v207 + 197);
    }
    uint64_t v208 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v425, v207 + 200);
    long long v209 = *(_OWORD *)(v207 + 176);
    long long v211 = *(_OWORD *)(v207 + 128);
    long long v210 = *(_OWORD *)(v207 + 144);
    long long v417 = *(_OWORD *)(v207 + 160);
    long long v418 = v209;
    long long v415 = v211;
    long long v416 = v210;
    *(void *)&v404[8] = 0;
    *(_DWORD *)&v404[16] = 1;
    *(void *)&v404[24] = 0;
    *(void *)&v404[32] = 0;
    re::DynamicOverflowArray<unsigned long,256ul>::setCapacity(v404, 0x100uLL);
    char v212 = v404[16] + 2;
    *(_DWORD *)&v404[16] += 2;
    unint64_t v213 = v348;
    if (*(void *)&v404[8] >= v348)
    {
      v214 = v428;
      v215 = v334;
      if (*(void *)&v404[8] > v348) {
        goto LABEL_295;
      }
    }
    else
    {
      v214 = v428;
      v215 = v334;
      if (!*(void *)v404)
      {
        re::DynamicOverflowArray<unsigned long,256ul>::setCapacity(v404, v348);
        unint64_t v213 = v348;
        v215 = v334;
        char v212 = v404[16] + 2;
        *(_DWORD *)&v404[16] += 2;
      }
      BOOL v12 = (v212 & 1) == 0;
      unint64_t v216 = 256;
      if (v12) {
        unint64_t v216 = *(void *)&v404[24];
      }
      if (v216 < v213)
      {
        re::DynamicOverflowArray<unsigned long,256ul>::setCapacity(v404, v213);
        unint64_t v213 = v348;
        v215 = v334;
      }
      uint64_t v217 = *(void *)&v404[8];
      if (*(void *)&v404[8] < v213)
      {
        do
        {
          if (v404[16]) {
            float v218 = &v404[24];
          }
          else {
            float v218 = *(unsigned char **)&v404[32];
          }
          *(void *)&v218[8 * v217++] = 0;
        }
        while (v213 != v217);
      }
LABEL_295:
      *(void *)&v404[8] = v213;
      *(_DWORD *)&v404[16] += 2;
    }
    unint64_t v156 = 0;
    v350 = (unsigned int *)&v204[5 * (void)v215];
    unsigned int v219 = v411;
    int v220 = DWORD2(v410[2]);
    uint64_t v221 = v353[4];
    long long v222 = (unsigned int *)((char *)v204 + v172 + 4);
    do
    {
      unint64_t v172 = *(v222 - 1);
      unint64_t v5 = v353[2];
      if (v5 <= v172) {
        goto LABEL_482;
      }
      unint64_t v5 = *v222;
      unint64_t v20 = *(void *)(v221 + (v172 << 9) + 208);
      if (v20 <= v5) {
        goto LABEL_483;
      }
      unint64_t v20 = *(void *)&v404[8];
      if (*(void *)&v404[8] <= v156) {
        goto LABEL_484;
      }
      uint64_t v223 = *(void *)(v221 + (v172 << 9) + 224);
      if (v404[16]) {
        long long v224 = &v404[24];
      }
      else {
        long long v224 = *(unsigned char **)&v404[32];
      }
      *(void *)&v224[8 * v156] = v219;
      unint64_t v225 = (float32x4_t *)(v223 + (v5 << 8));
      v219 += v225[3].u32[0];
      LODWORD(v41re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v219;
      v220 += v225[2].i32[2];
      DWORD2(v410[2]) = v220;
      float32x4_t v226 = v225[6];
      float32x4_t v227 = *(float32x4_t *)&v413[8];
      float32x4_t v228 = v414;
      v227.i32[3] = 0;
      v226.i32[3] = 0;
      *(float32x4_t *)&v413[8] = vminnmq_f32(v227, v226);
      float32x4_t v229 = v225[7];
      v228.i32[3] = 0;
      v229.i32[3] = 0;
      float32x4_t v414 = vmaxnmq_f32(v228, v229);
      ++v156;
      v222 += 20;
    }
    while (v213 != v156);
    HIDWORD(v41re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v219;
    if (BYTE12(v410[2]) != 1 && v219 > 0xFFFE) {
      goto LABEL_501;
    }
    unint64_t v156 = *v350;
    unint64_t v172 = v353[2];
    if (v172 <= v156) {
      goto LABEL_502;
    }
    unint64_t v172 = DWORD1(v204[5 * (void)v215]);
    uint64_t v230 = v221 + (v156 << 9);
    unint64_t v156 = *(void *)(v230 + 208);
    if (v156 <= v172) {
      goto LABEL_503;
    }
    unint64_t v231 = *(void *)(v230 + 224) + (v172 << 8);
    unint64_t v232 = *(void *)(v231 + 16);
    if (*((void *)&v410[0] + 1) < v232)
    {
      re::DynamicArray<re::MeshAssetBuffer>::setCapacity(v410, *(void *)(v231 + 16));
      unint64_t v232 = *(void *)(v231 + 16);
    }
    if (!v232) {
      goto LABEL_402;
    }
    unint64_t v5 = 0;
    uint64_t v233 = 2;
    if (v348 > 2) {
      uint64_t v233 = v348;
    }
    uint64_t v345 = v233;
    unint64_t v341 = *(void *)&v404[8];
    char v340 = v404[16];
    unint64_t v338 = v231;
    v339 = *(unsigned char **)&v404[32];
LABEL_314:
    uint64_t v234 = *(void *)(v231 + 32);
    unint64_t v29 = v234 + 80 * v5;
    uint64_t v9 = v29 + 9;
    if (*(void *)(v29 + 8)) {
      unint64_t v20 = *(void *)(v29 + 16);
    }
    else {
      unint64_t v20 = v29 + 9;
    }
    v235 = (_anonymous_namespace_ *)strncmp((const char *)v20, "original", 8uLL);
    if (!v235) {
      goto LABEL_401;
    }
    unint64_t v389 = 0;
    v390 = "";
    unint64_t v336 = v5;
    uint64_t v236 = v234 + 80 * v5;
    unint64_t v5 = v236 + 72;
    unsigned int v238 = re::sizeFromVertexFormat(*(unsigned __int8 *)(v236 + 72), v237);
    int v241 = *(unsigned __int8 *)(v236 + 73);
    long long v240 = (unsigned char *)(v236 + 73);
    unint64_t v357 = v238;
    unint64_t v242 = *(void *)(v240 - 25) / (unint64_t)v238;
    if (v241
      || ((*(void *)(v29 + 8) & 1) != 0 ? (int v246 = *(const char **)(v29 + 16)) : (int v246 = (const char *)(v29 + 9)),
          long long v245 = (_anonymous_namespace_ *)strcmp(v246, "indexTriangles"),
          !v245))
    {
      unint64_t v20 = v353[2];
      uint64_t v9 = 1;
      while (1)
      {
        unint64_t v28 = v350[20 * v9];
        if (v20 <= v28) {
          break;
        }
        unint64_t v14 = v350[20 * v9 + 1];
        unint64_t v243 = v353[4] + (v28 << 9);
        unint64_t v28 = *(void *)(v243 + 208);
        if (v28 <= v14) {
          goto LABEL_473;
        }
        unint64_t v244 = *(void *)(v243 + 224) + (v14 << 8);
        unint64_t v14 = *(void *)(v244 + 16);
        if (!v14) {
          goto LABEL_491;
        }
        unint64_t v2 = 0;
        unint64_t v28 = *(void *)(v244 + 32);
        unint64_t v6 = 80 * v14;
        while (1)
        {
          long long v245 = (_anonymous_namespace_ *)re::DynamicString::operator==(v29, v28);
          if (v245) {
            break;
          }
          v28 += 80;
          ++v2;
          v6 -= 80;
          if (!v6) {
            goto LABEL_491;
          }
        }
        if (v14 <= v2) {
          goto LABEL_474;
        }
        if (*(unsigned __int8 *)v5 != *(unsigned __int8 *)(v28 + 72)) {
          goto LABEL_475;
        }
        v242 += *(void *)(v28 + 48) / v357;
        ++v9;
        unint64_t v6 = (unint64_t)v379;
        if (v9 == v345) {
          goto LABEL_335;
        }
      }
LABEL_472:
      *(void *)v434 = 0;
      long long v442 = 0u;
      long long v443 = 0u;
      memset(v441, 0, sizeof(v441));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v428[0]) = 136315906;
      *(void *)((char *)v428 + 4) = "operator[]";
      WORD2(v428[1]) = 1024;
      *(_DWORD *)((char *)&v428[1] + 6) = 797;
      WORD1(v428[2]) = 2048;
      *(void *)((char *)&v428[2] + 4) = v28;
      WORD2(v428[3]) = 2048;
      *(void *)((char *)&v428[3] + 6) = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_473:
      *(void *)v434 = 0;
      long long v442 = 0u;
      long long v443 = 0u;
      memset(v441, 0, sizeof(v441));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v428[0]) = 136315906;
      *(void *)((char *)v428 + 4) = "operator[]";
      WORD2(v428[1]) = 1024;
      *(_DWORD *)((char *)&v428[1] + 6) = 797;
      WORD1(v428[2]) = 2048;
      *(void *)((char *)&v428[2] + 4) = v14;
      WORD2(v428[3]) = 2048;
      *(void *)((char *)&v428[3] + 6) = v28;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_474:
      *(void *)v434 = 0;
      long long v442 = 0u;
      long long v443 = 0u;
      memset(v441, 0, sizeof(v441));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v428[0]) = 136315906;
      *(void *)((char *)v428 + 4) = "operator[]";
      WORD2(v428[1]) = 1024;
      *(_DWORD *)((char *)&v428[1] + 6) = 797;
      WORD1(v428[2]) = 2048;
      *(void *)((char *)&v428[2] + 4) = v2;
      WORD2(v428[3]) = 2048;
      *(void *)((char *)&v428[3] + 6) = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_475:
      re::internal::assertLog((re::internal *)4, v239, "assertion failure: '%s' (%s:line %i) ", "srcBuffer.format == buffer.format", "combineAttributeBuffers", 2946);
      _os_crash();
      __break(1u);
LABEL_476:
      *((void *)v17 + 260) = 0;
      *(_OWORD *)(v6 + 248) = 0u;
      *(_OWORD *)(v6 + 232) = 0u;
      *(_OWORD *)(v6 + 216) = 0u;
      *(_OWORD *)(v6 + 200) = 0u;
      *(_OWORD *)(v6 + 184) = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)(v9 + 536) = 136315906;
      *(void *)&v404[4] = "operator[]";
      *(_WORD *)&v404[12] = 1024;
      *(_DWORD *)&v404[14] = 858;
      *(_WORD *)&v404[18] = 2048;
      *(void *)&v404[20] = v28;
      *(_WORD *)&v404[28] = 2048;
      *(void *)&v404[30] = v29;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_477:
      *((void *)v17 + 260) = 0;
      *(_OWORD *)(v6 + 248) = 0u;
      *(_OWORD *)(v6 + 232) = 0u;
      *(_OWORD *)(v6 + 216) = 0u;
      *(_OWORD *)(v6 + 200) = 0u;
      *(_OWORD *)(v6 + 184) = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v404 = 136315906;
      *(void *)&v404[4] = "operator[]";
      *(_WORD *)&v404[12] = 1024;
      *(_DWORD *)&v404[14] = 858;
      *(_WORD *)&v404[18] = 2048;
      *(void *)&v404[20] = v28;
      *(_WORD *)&v404[28] = 2048;
      *(void *)&v404[30] = v29;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_478:
      *(void *)&v358.var0 = 0;
      *((_OWORD *)v17 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0u;
      *((_OWORD *)v17 + 4) = 0u;
      *((_OWORD *)v17 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
      *((_OWORD *)v17 + 2) = 0u;
      *(_OWORD *)uint64_t v17 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 858;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v2;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v28;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_479:
      v441[0] = 0;
      v160[3] = 0u;
      uint64_t v160[4] = 0u;
      v160[1] = 0u;
      v160[2] = 0u;
      *uint64_t v160 = 0u;
      unint64_t v172 = v158;
      unint64_t v323 = v174;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 858;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v172 + v323;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_480:
      v441[0] = 0;
      v160[3] = 0u;
      uint64_t v160[4] = 0u;
      v160[1] = 0u;
      v160[2] = 0u;
      *uint64_t v160 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 866;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v6;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_481:
      v441[0] = 0;
      v160[3] = 0u;
      uint64_t v160[4] = 0u;
      v160[1] = 0u;
      v160[2] = 0u;
      *uint64_t v160 = 0u;
      v214 = (void *)&_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 866;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v14;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_482:
      v214[10] = 0;
      *((_OWORD *)v214 + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
      *((_OWORD *)v214 + 12) = 0u;
      *((_OWORD *)v214 + 9) = 0u;
      *((_OWORD *)v214 + 10) = 0u;
      *((_OWORD *)v214 + 8) = 0u;
      v214 = (void *)&_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v428[0]) = 136315906;
      *(void *)((char *)v428 + 4) = "operator[]";
      WORD2(v428[1]) = 1024;
      *(_DWORD *)((char *)&v428[1] + 6) = 797;
      WORD1(v428[2]) = 2048;
      *(void *)((char *)&v428[2] + 4) = v172;
      WORD2(v428[3]) = 2048;
      *(void *)((char *)&v428[3] + 6) = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_483:
      v214[10] = 0;
      *((_OWORD *)v214 + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
      *((_OWORD *)v214 + 12) = 0u;
      *((_OWORD *)v214 + 9) = 0u;
      *((_OWORD *)v214 + 10) = 0u;
      *((_OWORD *)v214 + 8) = 0u;
      unint64_t v156 = (unint64_t)v428;
      v214 = (void *)&_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v428[0]) = 136315906;
      *(void *)((char *)v428 + 4) = "operator[]";
      WORD2(v428[1]) = 1024;
      *(_DWORD *)((char *)&v428[1] + 6) = 797;
      WORD1(v428[2]) = 2048;
      *(void *)((char *)&v428[2] + 4) = v5;
      WORD2(v428[3]) = 2048;
      *(void *)((char *)&v428[3] + 6) = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_484:
      v214[10] = 0;
      *((_OWORD *)v214 + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
      *((_OWORD *)v214 + 12) = 0u;
      *((_OWORD *)v214 + 9) = 0u;
      *((_OWORD *)v214 + 10) = 0u;
      *((_OWORD *)v214 + 8) = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v428[0]) = 136315906;
      *(void *)((char *)v428 + 4) = "operator[]";
      WORD2(v428[1]) = 1024;
      *(_DWORD *)((char *)&v428[1] + 6) = 858;
      WORD1(v428[2]) = 2048;
      *(void *)((char *)&v428[2] + 4) = v156;
      WORD2(v428[3]) = 2048;
      *(void *)((char *)&v428[3] + 6) = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_485:
      unint64_t v92 = (unint64_t)v379;
      uint64_t v391 = 0;
      unint64_t v28 = (unint64_t)v428;
      long long v442 = 0u;
      long long v443 = 0u;
      memset(v441, 0, sizeof(v441));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)v434 = 136315906;
      *(void *)&v434[4] = "operator[]";
      __int16 v435 = 1024;
      int v436 = 866;
      __int16 v437 = 2048;
      unint64_t v438 = v6;
      __int16 v439 = 2048;
      unint64_t v440 = v341;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_486:
      *(void *)&v358.var0 = 0;
      *((_OWORD *)v17 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0u;
      *((_OWORD *)v17 + 4) = 0u;
      *((_OWORD *)v17 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
      *((_OWORD *)v17 + 2) = 0u;
      *(_OWORD *)uint64_t v17 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 797;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v2;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v92;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_487;
    }
LABEL_335:
    memset(v428, 0, 32);
    unint64_t v28 = (unint64_t)v428;
    re::DynamicString::setCapacity(v428, 0);
    uint64_t v432 = 0;
    uint64_t v429 = 0;
    unint64_t v430 = 0;
    v428[4] = 0;
    int v431 = 0;
    __int16 v433 = 256;
    if (*v240 == 1 && v242 != v411) {
      goto LABEL_494;
    }
    re::DynamicString::operator=((re::DynamicString *)v428, (re::DynamicString *)v29);
    LOBYTE(v43re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(unsigned char *)v5;
    HIBYTE(v43re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *v240;
    re::DynamicArray<BOOL>::resize((uint64_t)&v428[4], (v242 * v357 + 3) & 0xFFFFFFFFFFFFFFFCLL);
    long long v248 = v350;
    unint64_t v95 = *v350;
    unint64_t v28 = v353[2];
    if (v28 <= v95) {
      goto LABEL_471;
    }
    unint64_t v2 = 0;
    unint64_t v6 = 0;
    __s1 = (char *)v390;
    int v249 = v353;
    unint64_t v14 = v389 >> 1;
    uint64_t v9 = 80;
LABEL_339:
    unint64_t v28 = v248[20 * v6 + 1];
    unint64_t v250 = v249[4] + (v95 << 9);
    unint64_t v95 = *(void *)(v250 + 208);
    if (v95 <= v28) {
      goto LABEL_469;
    }
    unint64_t v251 = *(void *)(v250 + 224) + (v28 << 8);
    unint64_t v5 = *(void *)(v251 + 16);
    if (!v5) {
      goto LABEL_509;
    }
    int v252 = 0;
    unint64_t v20 = *(void *)(v251 + 32);
    uint64_t v253 = 80 * v5;
    uint64_t v254 = v20;
    while (!re::DynamicString::operator==(v29, v254))
    {
      ++v252;
      v254 += 80;
      v253 -= 80;
      if (!v253)
      {
        int v252 = -1;
        break;
      }
    }
    uint64_t v256 = v252;
    if (v5 <= v252) {
      goto LABEL_510;
    }
    uint64_t v9 = 80;
    unint64_t v5 = v20 + 80 * (int)v256;
    unint64_t v28 = *(void *)(v5 + 48);
    unint64_t v352 = v28 / v357;
    if (v14 == 0x2B3FAC222C23CAEDLL)
    {
      if (__s1 == "vertexPosition" || !strcmp(__s1, "vertexPosition"))
      {
        int v255 = *(float **)(v20 + 80 * (int)v256 + 64);
        int v258 = (float32x4_t *)&v350[20 * v6];
        float32x4_t v260 = v258[1];
        float32x4_t v261 = v258[2];
        long long v259 = v258 + 1;
        float32x4_t v262 = vaddq_f32(v259[3], vaddq_f32(v259[2], vmlaq_f32(vmulq_f32(v260, (float32x4_t)0), (float32x4_t)0, v261)));
        if (v262.f32[2] != 1.0
          && fabsf(v262.f32[2] + -1.0) >= (float)((float)((float)(fabsf(v262.f32[2]) + 1.0) + 1.0) * 0.0001)
          || (int8x16_t v263 = (int8x16_t)vmulq_f32(v262, v262),
              float v264 = vaddv_f32(vadd_f32(*(float32x2_t *)v263.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v263, v263, 8uLL))),
              v264 != 1.0)
          && fabsf(v264 + -1.0) >= (float)((float)((float)(fabsf(v264) + 1.0) + 1.0) * 0.0001))
        {
          unint64_t v267 = v348;
          if (v28 >= v357)
          {
            unint64_t v274 = (_DWORD *)(v432 + v2 + 8);
            long long v275 = v255 + 2;
            unint64_t v276 = v28 / v357;
            do
            {
              float v277 = *(v275 - 2);
              float v278 = *(v275 - 1);
              float v279 = *v275;
              v275 += 3;
              float32x4_t v280 = vaddq_f32(v259[3], vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(*v259, v277), v259[1], v278), v259[2], v279));
              *((void *)v274 - re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v280.i64[0];
              *unint64_t v274 = v280.i32[2];
              v274 += 3;
              --v276;
            }
            while (v276);
          }
          goto LABEL_372;
        }
        memcpy((void *)(v432 + v2), v255, 12 * v352);
      }
      else
      {
LABEL_370:
        re::DynamicArray<REFrameAnalysisBottleneck>::copy(&v428[4], v2, *(char **)(v20 + 80 * (int)v256 + 64), v28);
      }
      unint64_t v267 = v348;
      goto LABEL_372;
    }
    if (v14 != 0x5353CF4AA93DFAB9 || __s1 != "indexTriangles" && strcmp(__s1, "indexTriangles")) {
      goto LABEL_370;
    }
    if (v341 <= v6) {
      goto LABEL_485;
    }
    long long v257 = (v340 & 1) != 0 ? &v404[24] : v339;
    uint64_t v265 = *(void *)&v257[8 * v6];
    if (!v265) {
      goto LABEL_370;
    }
    int v266 = *(unsigned __int8 *)(v20 + 80 * (int)v256 + 72);
    if (v266 != 36) {
      break;
    }
    unint64_t v267 = v348;
    if ((v28 & 0xFFFFFFFFFFFFFFFCLL) + v2 > v430) {
      goto LABEL_490;
    }
    if (v28 >= 4)
    {
      v281 = *(int **)(v20 + 80 * (int)v256 + 64);
      uint64_t v282 = v28 >> 2;
      v283 = (_DWORD *)(v432 + v2);
      if (v28 >> 2 <= 1) {
        uint64_t v282 = 1;
      }
      do
      {
        int v284 = *v281++;
        *v283++ = v284 + v265;
        --v282;
      }
      while (v282);
    }
LABEL_372:
    v2 += v352 * v357;
    if (*(unsigned char *)(v20 + 80 * (int)v256 + 73))
    {
      if (++v6 >= v267) {
        goto LABEL_392;
      }
LABEL_380:
      long long v248 = v350;
      unint64_t v95 = v350[20 * v6];
      int v249 = v353;
      unint64_t v28 = v353[2];
      if (v28 <= v95) {
        goto LABEL_470;
      }
      goto LABEL_339;
    }
    if (*(void *)(v5 + 8)) {
      v272 = *(const char **)(v5 + 16);
    }
    else {
      v272 = (const char *)(v5 + 9);
    }
    int v273 = strcmp(v272, "indexTriangles");
    if (++v6 < v348 && !v273) {
      goto LABEL_380;
    }
LABEL_392:
    if (v2 / v357 != v242) {
      goto LABEL_495;
    }
    v285.n128_f64[0] = re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)v410, (uint64_t)v428);
    unint64_t v6 = (unint64_t)v379;
    if (v428[4])
    {
      if (v432) {
        (*(void (**)(double))(*(void *)v428[4] + 40))(v285.n128_f64[0]);
      }
      uint64_t v432 = 0;
      uint64_t v429 = 0;
      unint64_t v430 = 0;
      v428[4] = 0;
      ++v431;
    }
    if (v428[0] && (v428[1] & 1) != 0) {
      (*(void (**)(__n128))(*(void *)v428[0] + 40))(v285);
    }
    re::StringID::destroyString((re::StringID *)&v389);
    unint64_t v232 = *(void *)(v338 + 16);
    unint64_t v5 = v336;
LABEL_401:
    ++v5;
    uint64_t v9 = 80;
    unint64_t v231 = v338;
    if (v5 < v232) {
      goto LABEL_314;
    }
LABEL_402:
    float32x4_t v286 = v335[1];
    float32x4_t v287 = v335[2];
    v286.i32[3] = 0;
    float32x4_t v288 = *(float32x4_t *)&v413[8];
    v288.i32[3] = 0;
    v335[1] = vminnmq_f32(v286, v288);
    float32x4_t v289 = v414;
    v287.i32[3] = 0;
    v289.i32[3] = 0;
    v335[2] = vmaxnmq_f32(v287, v289);
    re::DynamicArray<re::MeshAssetPart>::add(v330, (uint64_t)v410);
    if (*(void *)v404 && (v404[16] & 1) == 0) {
      (*(void (**)(void))(**(void **)v404 + 40))();
    }
    unint64_t v20 = v348 + v328;
    v290 = (char *)v334 + v348;
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v425);
    re::StringID::destroyString((re::StringID *)&v412[8]);
    re::DynamicArray<re::MeshAssetBuffer>::deinit((uint64_t)v410);
    uint64_t v160 = v404;
    unint64_t v157 = v329;
    uint64_t v146 = 5152;
    unint64_t v159 = v331;
LABEL_423:
    unint64_t v156 = *((void *)&v392 + 1);
    long long v147 = (const char *)v20;
    unint64_t v158 = (unint64_t)v290;
    unint64_t v20 = (unint64_t)v333;
    if (*((void *)&v392 + 1) <= v157)
    {
LABEL_504:
      unint64_t v28 = (unint64_t)v428;
      v441[0] = 0;
      memset(v404, 0, 80);
      unint64_t v52 = v157;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v410[0]) = 136315906;
      *(void *)((char *)v410 + 4) = "operator[]";
      WORD6(v410[0]) = 1024;
      *(_DWORD *)((char *)v410 + 14) = 858;
      WORD1(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 4) = v52;
      WORD6(v410[1]) = 2048;
      *(void *)((char *)&v410[1] + 14) = v156;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_505;
    }
  }
  unint64_t v267 = v348;
  if (v266 == 49)
  {
    if ((v28 & 0xFFFFFFFFFFFFFFFELL) + v2 > v430) {
      goto LABEL_489;
    }
    if (v28 >= 2)
    {
      long long v268 = *(__int16 **)(v20 + 80 * (int)v256 + 64);
      uint64_t v269 = v28 >> 1;
      int v270 = (_WORD *)(v432 + v2);
      if (v28 >> 1 <= 1) {
        uint64_t v269 = 1;
      }
      do
      {
        __int16 v271 = *v268++;
        *v270++ = v271 + v265;
        --v269;
      }
      while (v269);
    }
    goto LABEL_372;
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)v255, "assertion failure: '%s' (%s:line %i) Unsupported index type.", "false", "copyAndOffsetTriangleIndices", 2895);
  uint64_t result = (void *)_os_crash();
  __break(1u);
  return result;
}

uint64_t re::DynamicOverflowArray<unsigned int,128ul>::operator[](uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v2 = a1 + 24;
  }
  else {
    uint64_t v2 = *(void *)(a1 + 32);
  }
  return v2 + 4 * a2;
}

__n128 re::DynamicArray<re::MeshAssetInstance>::add(_anonymous_namespace_ *this, StringID *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::MeshAssetInstance>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  unint64_t v5 = re::StringID::StringID((re::StringID *)(*((void *)this + 4) + 96 * v4), a2);
  *((StringID *)v5 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = a2[1];
  __n128 result = (__n128)a2[2];
  StringID v7 = a2[3];
  StringID v8 = a2[4];
  *(StringID *)((char *)v5 + 76) = *(StringID *)((char *)a2 + 76);
  *((StringID *)v5 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v7;
  *((StringID *)v5 + 4) = v8;
  *((__n128 *)v5 + 2) = result;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

__n128 re::DynamicArray<re::MeshAssetInstance>::add(_anonymous_namespace_ *this, uint64_t *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::MeshAssetInstance>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 96 * v4;
  uint64_t v6 = *a2;
  *(void *)uint64_t v5 = *(void *)v5 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(void *)uint64_t v5 = *a2 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(void *)(v5 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  __n128 result = *(__n128 *)((char *)a2 + 76);
  long long v8 = *((_OWORD *)a2 + 2);
  long long v9 = *((_OWORD *)a2 + 4);
  *(_OWORD *)(v5 + 48) = *((_OWORD *)a2 + 3);
  *(_OWORD *)(v5 + 64) = v9;
  *(_OWORD *)(v5 + 32) = v8;
  *(_OWORD *)(v5 + 16) = *((_OWORD *)a2 + 1);
  *(__n128 *)(v5 + 76) = result;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(int a1, const re::IntrospectionBase *a2)
{
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::info = (uint64_t)&unk_26E6CDF70;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    int v3 = re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3) {
      return &re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::info;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  uint64_t v6 = re::introspect_AssetHandle((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      StringID v7 = re::introspectionSharedMutex((re *)v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    uint64_t v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::isInitialized = 1;
    int v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::info, 0);
    qword_2687734D8 = 0x2800000003;
    dword_2687734E0 = v10;
    word_2687734E4 = 0;
    *(void *)&xmmword_2687734E8 = 0;
    *((void *)&xmmword_2687734E8 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0xFFFFFFFFLL;
    qword_2687734F8 = v9;
    unk_268773500 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::info = (uint64_t)&unk_26E6CDF70;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if (BYTE8(v15)) {
      unint64_t v13 = v16;
    }
    else {
      unint64_t v13 = (char *)&v15 + 9;
    }
    if (void)v15 && (BYTE8(v15)) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    long long v15 = *(_OWORD *)(v9 + 32);
    xmmword_2687734E8 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(BOOL)::info;
}

void *re::allocInfo_MeshAsset(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF77038, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF77038))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF77060, "MeshAsset");
    __cxa_guard_release(&qword_26AF77038);
  }
  return &unk_26AF77060;
}

void re::initInfo_MeshAsset(re *this, re::IntrospectionBase *a2)
{
  v15[0] = 0x7CB41A3561C6;
  v15[1] = "MeshAsset";
  re::StringID::destroyString((re::StringID *)v15);
  *((_OWORD *)this + 2) = v16;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF77030, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF77030);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v6 = re::introspect_MeshAssetData((re::IntrospectionBase **)1);
      uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "meshAssetData";
      *(void *)(v7 + 16) = v6;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0x800000001;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF77048 = v7;
      long long v8 = re::introspectionAllocator((re *)v7);
      int v10 = re::IntrospectionInfo<re::DynamicArray<re::AssetHandle>>::get(1, v9);
      uint64_t v11 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *(void *)(v11 + 8) = "skeletons";
      *(void *)(v11 + 16) = v10;
      *(void *)(v11 + 24) = 0;
      *(void *)(v11 + 32) = 0xD000000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(void *)(v11 + 48) = 0;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_26AF77050 = v11;
      BOOL v12 = re::introspectionAllocator((re *)v11);
      uint64_t v13 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 64, 8);
      *(_DWORD *)uint64_t v13 = 6;
      *(void *)(v13 + 8) = 1;
      *(void *)(v13 + 16) = 0;
      *(void *)(v13 + 24) = 0;
      *(void *)(v13 + 32) = 0;
      *(unsigned char *)(v13 + 40) = 1;
      *(void *)(v13 + 48) = re::MeshAssetLoader::downgradeMeshAssetFromFall2021;
      *(_DWORD *)(v13 + 56) = 1;
      qword_26AF77058 = v13;
      __cxa_guard_release(&qword_26AF77030);
    }
  }
  *((void *)this + 2) = 0x3C000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((void *)this + 8) = &qword_26AF77048;
  *((void *)this + 9) = re::internal::defaultConstruct<re::MeshAsset>;
  *((void *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::MeshAsset>;
  *((void *)this + 1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::internal::defaultConstructV2<re::MeshAsset>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::MeshAsset>;
  re::IntrospectionRegistry::add(this, v3);
  long long v14 = v16;
}

double re::internal::defaultConstruct<re::MeshAsset>(int a1, int a2, re::MeshAsset *this)
{
  return re::MeshAsset::MeshAsset(this);
}

uint64_t re::internal::defaultDestruct<re::MeshAsset>(uint64_t a1, uint64_t a2, uint64_t (***a3)(void))
{
  return (**a3)(a3);
}

uint64_t re::internal::defaultDestructV2<re::MeshAsset>(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t re::introspect_MeshAsset(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"MeshAsset", (uint64_t (*)(re::internal *))re::allocInfo_MeshAsset, (re::IntrospectionBase *(*)(void))re::initInfo_MeshAsset, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::MeshAsset>, this);
}

uint64_t re::DynamicArray<re::MeshModel>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    int v3 = *(re::MeshModel **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 816 * v4;
        do
        {
          re::MeshModel::~MeshModel(v3);
          int v3 = (re::MeshModel *)((char *)v3 + 816);
          v5 -= 816;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        int v3 = *(re::MeshModel **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::MeshModel *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::MeshModel::~MeshModel(re::MeshModel *this)
{
  for (uint64_t i = 776; i != 56; i -= 40)
    std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)((char *)this + i));
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 9);
  re::FixedArray<re::MeshPart>::deinit((void *)this + 6);
  re::StringID::destroyString(this);
}

void *re::FixedArray<re::MeshPart>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    int v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = (void *)result[2];
      uint64_t v5 = 560 * v2;
      do
      {
        re::StringID::destroyString((re::StringID *)(v4 + 63));
        re::FixedArray<re::StringID>::deinit(v4 + 42);
        re::AttributeTable::~AttributeTable((re::AttributeTable *)v4);
        v4 += 70;
        v5 -= 560;
      }
      while (v5);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *int v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

void re::MeshNameMap::~MeshNameMap(re::MeshNameMap *this)
{
}

void *re::FixedArray<re::HashTable<re::StringID,unsigned short,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    int v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = (uint64_t *)result[2];
      uint64_t v5 = 48 * v2;
      do
      {
        double v6 = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v4);
        v4 += 6;
        v5 -= 48;
      }
      while (v5);
      uint64_t result = (void *)(*(uint64_t (**)(void, void, double))(*(void *)*v1 + 40))(*v1, v1[2], v6);
      *int v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

void *re::FixedArray<re::SharedPtr<re::MaterialParameterBlock>>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    int v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = result[2];
      uint64_t v5 = 8 * v2;
      do
      {
        if (*(void *)v4)
        {

          *(void *)uint64_t v4 = 0;
        }
        v4 += 8;
        v5 -= 8;
      }
      while (v5);
      uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *int v3 = 0;
      v3[1] = 0;
    }
    void *v1 = 0;
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u) {
        signed int v5 = 3;
      }
      else {
        signed int v5 = *(_DWORD *)(a2 + 28);
      }
      re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(a1, v4, v5);
      re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  signed int v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      signed int v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  BOOL v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    long long v14 = v12;
    *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_211, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (re::DynamicString *)(v8 + 16), (void *)(v8 + 48));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 56;
    }
  }
}

void re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_212, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      unint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16);
        int v7 = *(_DWORD *)(v6 + v5);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v5) = v7 & 0x7FFFFFFF;
          re::DynamicString::deinit((re::DynamicString *)(v6 + v5 + 8));
          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        ++v4;
        v5 += 56;
      }
      while (v4 < v3);
    }
    *(_DWORD *)(a1 + 2re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&unsigned __int8 v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&unsigned __int8 v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (re::DynamicString *)(*(void *)&v13[16] + v10 + 16), (void *)(*(void *)&v13[16] + v10 + 48));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, void *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 56 * v10 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * v10) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v10 + 16), a4);
  *(void *)(*(void *)(a1 + 16) + 56 * v10 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * are::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::GeomMeshBuilder::setFaceVertices(uint64_t this, unsigned int a2, int a3, int a4, int a5)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(this + 32);
  if (v6 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_14;
  }
  uint64_t v10 = (void *)this;
  int v11 = (int *)(*(void *)(this + 48) + 16 * a2);
  int v12 = *v11;
  int v13 = v11[3];
  if (v12 != -1 && v13 == -1)
  {
    int v15 = *(_DWORD *)(this + 416);
    if (v15)
    {
      for (unsigned int i = 0; i != v15; ++i)
      {
        uint64_t v17 = (re::internal *)re::internal::GeomAttributeContainer::attributeByIndex((re::internal::GeomAttributeContainer *)(v10 + 49), i);
        this = re::internal::accessFaceVaryingAttributeSubmesh(v17, v18);
      }
      unint64_t v6 = v10[4];
    }
  }
  if (v6 <= v5)
  {
LABEL_14:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v19 = (_DWORD *)(v10[6] + 16 * v5);
  *unint64_t v19 = a3;
  v19[1] = a4;
  void v19[2] = a5;
  void v19[3] = -1;
  return this;
}

void *anonymous namespace'::buildDoubleVertexBillboard(re::GeomMesh &)::$_0::operator()(void *result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(*result + 8) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_8;
  }
  unint64_t v5 = (void *)(*(void *)*result + 16 * a2);
  *unint64_t v5 = a3;
  v5[1] = a4;
  uint64_t v6 = result[1];
  if (*(_DWORD *)(v6 + 8) <= a2)
  {
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_9;
  }
  *(void *)(*(void *)v6 + 8 * are::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = a5;
  uint64_t v7 = result[2];
  if (*(_DWORD *)(v7 + 8) <= a2)
  {
LABEL_9:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_10;
  }
  long long v8 = (void *)(*(void *)v7 + 16 * a2);
  *long long v8 = 0x3F80000000000000;
  v8[1] = 0;
  uint64_t v9 = result[3];
  if (*(_DWORD *)(v9 + 8) <= a2)
  {
LABEL_10:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_11:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v10 = (void *)(*(void *)v9 + 16 * a2);
  void *v10 = 0;
  v10[1] = 1065353216;
  uint64_t v11 = result[4];
  if (*(_DWORD *)(v11 + 8) <= a2) {
    goto LABEL_11;
  }
  int v12 = (void *)(*(void *)v11 + 16 * a2);
  *int v12 = 1065353216;
  v12[1] = 0;
  return result;
}

void *re::DynamicArray<re::GeomCell4>::resize(void *result, unint64_t a2)
{
  unint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::BlendNode>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    if (v4 < a2)
    {
      uint64_t result = (void *)(v3[4] + 16 * v4);
      uint64_t v5 = 16 * a2 - 16 * v4;
      if (v5 >= 1) {
        uint64_t result = memset(result, 255, 16 * (((unint64_t)v5 >> 4) - ((unint64_t)v5 > 0xF)) + 16);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *anonymous namespace'::buildDoubleVertexCircularBillboard(re::GeomMesh &)::$_0::operator()(void *result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(*result + 8) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v5 = (void *)(*(void *)*result + 16 * a2);
  *uint64_t v5 = a3;
  v5[1] = a4;
  uint64_t v6 = result[1];
  if (*(_DWORD *)(v6 + 8) <= a2) {
    goto LABEL_5;
  }
  *(void *)(*(void *)v6 + 8 * are::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = a5;
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetModel>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetModel>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetModel>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetModel>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::MeshAssetModel>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetModel *,re::MeshAssetModel *,re::MeshAssetModel *>((uint64_t)&v6, *(void *)(a2 + 32), *(void *)(a2 + 32) + (a1[2] << 9), a1[4]);
    re::ObjectHelper::copyConstruct<re::MeshAssetModel>(a1[4] + (a1[2] << 9), *(void *)(a2 + 32) + (a1[2] << 9), *(void *)(a2 + 32) + (v4 << 9));
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetModel *,re::MeshAssetModel *,re::MeshAssetModel *>((uint64_t)&v5, *(void *)(a2 + 32), *(void *)(a2 + 32) + (v4 << 9), a1[4]);
    re::ObjectHelper::destroy<re::MeshAssetModel>((re::StringID *)(a1[4] + (v4 << 9)), (re::StringID *)(a1[4] + (a1[2] << 9)));
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::MeshAssetModel>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    char v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 55)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 512, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          unint64_t v2 = a2 << 9;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, a2 << 9, 16);
          if (result)
          {
            uint64_t v7 = (uint64_t)result;
            if (!v5[1])
            {
LABEL_9:
              void v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            re::ObjectHelper::move<re::MeshAssetModel>(v5[4], v5[4] + (v5[2] << 9), v7);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetModel>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::ObjectHelper::move<re::MeshAssetModel>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      re::MeshAssetModel::MeshAssetModel(a3 + v6, (uint64_t *)(a1 + v6));
      re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a1 + v6 + 472);
      re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a1 + v6 + 432);
      re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit(a1 + v6 + 392);
      re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a1 + v6 + 352);
      re::DynamicArray<re::MeshAssetContactDeformerData>::deinit(a1 + v6 + 312);
      re::DynamicArray<unsigned long>::deinit(a1 + v6 + 272);
      re::DynamicArray<re::MeshAssetSkeleton>::deinit(a1 + v6 + 232);
      re::DynamicArray<re::MeshAssetPart>::deinit(a1 + v6 + 192);
      re::DynamicArray<re::MeshAssetSkinningData>::deinit(a1 + v6 + 152);
      re::DynamicArray<re::MeshAssetBlendShapeData>::deinit(a1 + v6 + 112);
      re::StringID::destroyString((re::StringID *)(a1 + v6));
      v6 += 512;
    }
    while (a1 + v6 != a2);
  }
}

__n128 re::MeshAssetModel::MeshAssetModel(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(void *)a1 = *(void *)a1 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(void *)a1 = *a2 & 0xFFFFFFFFFFFFFFFELL | v2 & 1;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  long long v3 = *((_OWORD *)a2 + 2);
  *(_OWORD *)(a1 + 16) = *((_OWORD *)a2 + 1);
  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v3;
  __n128 result = *((__n128 *)a2 + 3);
  long long v5 = *((_OWORD *)a2 + 4);
  long long v6 = *((_OWORD *)a2 + 6);
  *(_OWORD *)(a1 + 80) = *((_OWORD *)a2 + 5);
  *(_OWORD *)(a1 + 96) = v6;
  *(__n128 *)(a1 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = result;
  *(_OWORD *)(a1 + 64) = v5;
  *(void *)(a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = 0;
  *(void *)(a1 + 1re::FixedArray<re::StringID>::deinit((void *)this + 20) = 0;
  *(void *)(a1 + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  uint64_t v7 = a2[15];
  *(void *)(a1 + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = a2[14];
  *(void *)(a1 + 1re::FixedArray<re::StringID>::deinit((void *)this + 20) = v7;
  a2[14] = 0;
  a2[15] = 0;
  uint64_t v8 = *(void *)(a1 + 128);
  *(void *)(a1 + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[16];
  a2[16] = v8;
  uint64_t v9 = *(void *)(a1 + 144);
  *(void *)(a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = a2[18];
  a2[18] = v9;
  ++*((_DWORD *)a2 + 34);
  ++*(_DWORD *)(a1 + 136);
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 16re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 15re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  uint64_t v10 = a2[20];
  *(void *)(a1 + 15re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = a2[19];
  *(void *)(a1 + 160) = v10;
  a2[19] = 0;
  a2[20] = 0;
  uint64_t v11 = *(void *)(a1 + 168);
  *(void *)(a1 + 16re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[21];
  a2[21] = v11;
  uint64_t v12 = *(void *)(a1 + 184);
  *(void *)(a1 + 184) = a2[23];
  a2[23] = v12;
  ++*((_DWORD *)a2 + 44);
  ++*(_DWORD *)(a1 + 176);
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 20re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 19re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  uint64_t v13 = a2[25];
  *(void *)(a1 + 19re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = a2[24];
  *(void *)(a1 + 200) = v13;
  a2[24] = 0;
  a2[25] = 0;
  uint64_t v14 = *(void *)(a1 + 208);
  *(void *)(a1 + 20re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[26];
  a2[26] = v14;
  uint64_t v15 = *(void *)(a1 + 224);
  *(void *)(a1 + 224) = a2[28];
  a2[28] = v15;
  ++*((_DWORD *)a2 + 54);
  ++*(_DWORD *)(a1 + 216);
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 24re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  uint64_t v16 = a2[30];
  *(void *)(a1 + 2re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = a2[29];
  *(void *)(a1 + 240) = v16;
  a2[29] = 0;
  a2[30] = 0;
  uint64_t v17 = *(void *)(a1 + 248);
  *(void *)(a1 + 24re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[31];
  a2[31] = v17;
  uint64_t v18 = *(void *)(a1 + 264);
  *(void *)(a1 + 264) = a2[33];
  a2[33] = v18;
  ++*((_DWORD *)a2 + 64);
  ++*(_DWORD *)(a1 + 256);
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 28re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 27re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  uint64_t v19 = a2[35];
  *(void *)(a1 + 27re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = a2[34];
  *(void *)(a1 + 280) = v19;
  a2[34] = 0;
  a2[35] = 0;
  uint64_t v20 = *(void *)(a1 + 288);
  *(void *)(a1 + 28re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[36];
  a2[36] = v20;
  uint64_t v21 = *(void *)(a1 + 304);
  *(void *)(a1 + 304) = a2[38];
  a2[38] = v21;
  ++*((_DWORD *)a2 + 74);
  ++*(_DWORD *)(a1 + 296);
  *(void *)(a1 + 3re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = 0;
  *(void *)(a1 + 3re::FixedArray<re::StringID>::deinit((void *)this + 20) = 0;
  *(void *)(a1 + 32re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 31re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  uint64_t v22 = a2[40];
  *(void *)(a1 + 31re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = a2[39];
  *(void *)(a1 + 3re::FixedArray<re::StringID>::deinit((void *)this + 20) = v22;
  a2[39] = 0;
  a2[40] = 0;
  uint64_t v23 = *(void *)(a1 + 328);
  *(void *)(a1 + 32re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[41];
  a2[41] = v23;
  uint64_t v24 = *(void *)(a1 + 344);
  *(void *)(a1 + 3re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = a2[43];
  a2[43] = v24;
  ++*((_DWORD *)a2 + 84);
  ++*(_DWORD *)(a1 + 336);
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 36re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 35re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  *(_DWORD *)(a1 + 376) = 0;
  uint64_t v25 = a2[45];
  *(void *)(a1 + 35re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = a2[44];
  *(void *)(a1 + 360) = v25;
  a2[44] = 0;
  a2[45] = 0;
  uint64_t v26 = *(void *)(a1 + 368);
  *(void *)(a1 + 36re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[46];
  a2[46] = v26;
  uint64_t v27 = *(void *)(a1 + 384);
  *(void *)(a1 + 384) = a2[48];
  a2[48] = v27;
  ++*((_DWORD *)a2 + 94);
  ++*(_DWORD *)(a1 + 376);
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 40re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 39re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  *(_DWORD *)(a1 + 416) = 0;
  uint64_t v28 = a2[50];
  *(void *)(a1 + 39re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = a2[49];
  *(void *)(a1 + 400) = v28;
  a2[49] = 0;
  a2[50] = 0;
  uint64_t v29 = *(void *)(a1 + 408);
  *(void *)(a1 + 40re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[51];
  a2[51] = v29;
  uint64_t v30 = *(void *)(a1 + 424);
  *(void *)(a1 + 424) = a2[53];
  a2[53] = v30;
  ++*((_DWORD *)a2 + 104);
  ++*(_DWORD *)(a1 + 416);
  *(void *)(a1 + 464) = 0;
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 44re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_DWORD *)(a1 + 456) = 0;
  uint64_t v31 = a2[55];
  *(void *)(a1 + 4re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = a2[54];
  *(void *)(a1 + 440) = v31;
  a2[54] = 0;
  a2[55] = 0;
  uint64_t v32 = *(void *)(a1 + 448);
  *(void *)(a1 + 44re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[56];
  a2[56] = v32;
  uint64_t v33 = *(void *)(a1 + 464);
  *(void *)(a1 + 464) = a2[58];
  a2[58] = v33;
  ++*((_DWORD *)a2 + 114);
  ++*(_DWORD *)(a1 + 456);
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 480) = 0;
  *(void *)(a1 + 48re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 47re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  *(_DWORD *)(a1 + 496) = 0;
  uint64_t v34 = a2[60];
  *(void *)(a1 + 47re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = a2[59];
  *(void *)(a1 + 480) = v34;
  a2[59] = 0;
  a2[60] = 0;
  uint64_t v35 = *(void *)(a1 + 488);
  *(void *)(a1 + 48re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a2[61];
  a2[61] = v35;
  uint64_t v36 = *(void *)(a1 + 504);
  *(void *)(a1 + 504) = a2[63];
  a2[63] = v36;
  ++*((_DWORD *)a2 + 124);
  ++*(_DWORD *)(a1 + 496);
  return result;
}

uint64_t re::ObjectHelper::copyConstruct<re::MeshAssetModel>(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = (_OWORD *)(v5 + v6);
      re::StringID::StringID((re::StringID *)(v5 + v6), (const StringID *)(a2 + v6));
      long long v8 = *(_OWORD *)(a2 + v6 + 32);
      v7[1] = *(_OWORD *)(a2 + v6 + 16);
      _OWORD v7[2] = v8;
      long long v9 = *(_OWORD *)(a2 + v6 + 48);
      long long v10 = *(_OWORD *)(a2 + v6 + 64);
      long long v11 = *(_OWORD *)(a2 + v6 + 96);
      v7[5] = *(_OWORD *)(a2 + v6 + 80);
      v7[6] = v11;
      void v7[3] = v9;
      void v7[4] = v10;
      re::DynamicArray<re::MeshAssetBlendShapeData>::DynamicArray(v5 + v6 + 112, (uint64_t *)(a2 + v6 + 112));
      re::DynamicArray<re::MeshAssetSkinningData>::DynamicArray(v5 + v6 + 152, (uint64_t *)(a2 + v6 + 152));
      re::DynamicArray<re::MeshAssetPart>::DynamicArray(v5 + v6 + 192, (uint64_t *)(a2 + v6 + 192));
      re::DynamicArray<re::MeshAssetSkeleton>::DynamicArray(v5 + v6 + 232, (uint64_t *)(a2 + v6 + 232));
      re::DynamicArray<re::MeshLodLevelInfo>::DynamicArray(v5 + v6 + 272, (uint64_t *)(a2 + v6 + 272));
      re::DynamicArray<re::MeshAssetContactDeformerData>::DynamicArray(v5 + v6 + 312, (uint64_t *)(a2 + v6 + 312));
      re::DynamicArray<re::MeshAssetSmoothDeformerData>::DynamicArray(v5 + v6 + 352, (uint64_t *)(a2 + v6 + 352));
      re::DynamicArray<re::MeshAssetWrapDeformerData>::DynamicArray(v5 + v6 + 392, (uint64_t *)(a2 + v6 + 392));
      re::DynamicArray<re::MeshAssetSmoothDeformerData>::DynamicArray(v5 + v6 + 432, (uint64_t *)(a2 + v6 + 432));
      __n128 result = re::DynamicArray<re::MeshAssetJiggleDeformerData>::DynamicArray(v5 + v6 + 472, (uint64_t *)(a2 + v6 + 472));
      v6 += 512;
    }
    while (a2 + v6 != a3);
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetModel *,re::MeshAssetModel *,re::MeshAssetModel *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    long long v8 = (_OWORD *)(a4 + v7);
    re::StringID::operator=((unint64_t *)(a4 + v7), (uint64_t *)(a2 + v7));
    long long v9 = *(_OWORD *)(a2 + v7 + 32);
    v8[1] = *(_OWORD *)(a2 + v7 + 16);
    void v8[2] = v9;
    long long v10 = *(_OWORD *)(a2 + v7 + 48);
    long long v11 = *(_OWORD *)(a2 + v7 + 64);
    long long v12 = *(_OWORD *)(a2 + v7 + 96);
    void v8[5] = *(_OWORD *)(a2 + v7 + 80);
    void v8[6] = v12;
    _OWORD v8[3] = v10;
    v8[4] = v11;
    re::DynamicArray<re::MeshAssetBlendShapeData>::operator=(a4 + v7 + 112, (uint64_t *)(a2 + v7 + 112));
    re::DynamicArray<re::MeshAssetSkinningData>::operator=(a4 + v7 + 152, (uint64_t *)(a2 + v7 + 152));
    re::DynamicArray<re::MeshAssetPart>::operator=(a4 + v7 + 192, (uint64_t *)(a2 + v7 + 192));
    re::DynamicArray<re::MeshAssetSkeleton>::operator=(a4 + v7 + 232, (uint64_t *)(a2 + v7 + 232));
    re::DynamicArray<re::MeshLodLevelInfo>::operator=(a4 + v7 + 272, (uint64_t *)(a2 + v7 + 272));
    re::DynamicArray<re::MeshAssetContactDeformerData>::operator=(a4 + v7 + 312, (uint64_t *)(a2 + v7 + 312));
    re::DynamicArray<re::MeshAssetSmoothDeformerData>::operator=(a4 + v7 + 352, (uint64_t *)(a2 + v7 + 352));
    re::DynamicArray<re::MeshAssetWrapDeformerData>::operator=(a4 + v7 + 392, (uint64_t *)(a2 + v7 + 392));
    re::DynamicArray<re::MeshAssetSmoothDeformerData>::operator=(a4 + v7 + 432, (uint64_t *)(a2 + v7 + 432));
    re::DynamicArray<re::MeshAssetJiggleDeformerData>::operator=(a4 + v7 + 472, (uint64_t *)(a2 + v7 + 472));
    v7 += 512;
  }
  while (a2 + v7 != v6);
  return v6;
}

uint64_t re::DynamicArray<re::MeshAssetBlendShapeData>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetBlendShapeData>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetBlendShapeData>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetBlendShapeData>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::MeshAssetBlendShapeData>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetBlendShapeData *,re::MeshAssetBlendShapeData *,re::MeshAssetBlendShapeData *>((uint64_t)&v15, *(void *)(a2 + 32), *(void *)(a2 + 32) + 56 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = a1[4];
      uint64_t v11 = 56 * v8;
      uint64_t v12 = 56 * v4;
      do
      {
        uint64_t v13 = v10 + v11;
        re::StringID::StringID((re::StringID *)(v10 + v11), (const StringID *)(v9 + v11));
        re::FixedArray<re::BlendShapeDefinition>::FixedArray((void *)(v10 + v11 + 16), v9 + v11 + 16);
        *(void *)(v13 + 40) = *(void *)(v9 + v11 + 40);
        *(_WORD *)(v13 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_WORD *)(v9 + v11 + 48);
        v9 += 56;
        v12 -= 56;
        v10 += 56;
      }
      while (v11 != v12);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetBlendShapeData *,re::MeshAssetBlendShapeData *,re::MeshAssetBlendShapeData *>((uint64_t)&v14, *(void *)(a2 + 32), *(void *)(a2 + 32) + 56 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = (re::StringID *)(a1[4] + 56 * v4);
      uint64_t v7 = -56 * v4 + 56 * v5;
      do
      {
        re::FixedArray<re::BlendShapeDefinition>::deinit((void *)v6 + 2);
        re::StringID::destroyString(v6);
        uint64_t v6 = (re::StringID *)((char *)v6 + 56);
        v7 -= 56;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::MeshAssetBlendShapeData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::MeshAssetBlendShapeData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x38uLL))
        {
          uint64_t v2 = 56 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 56 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 56, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = &v8[7 * v9];
        uint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *uint64_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *uint64_t v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *uint64_t v8 = 0;
          v8[1] = (uint64_t)"";
          void v11[2] = 0;
          v11[3] = 0;
          void v11[4] = 0;
          void v11[2] = v8[2];
          void v8[2] = 0;
          uint64_t v13 = v11[4];
          uint64_t v14 = v8[4];
          v11[3] = v8[3];
          void v11[4] = v14;
          _OWORD v8[3] = 0;
          v8[4] = v13;
          v11[5] = v8[5];
          *((_WORD *)v11 + 24) = *((_WORD *)v8 + 24);
          re::FixedArray<re::BlendShapeDefinition>::deinit(v8 + 2);
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 7;
          v11 += 7;
        }
        while (v8 != v10);
        uint64_t v8 = (uint64_t *)v5[4];
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetBlendShapeData *,re::MeshAssetBlendShapeData *,re::MeshAssetBlendShapeData *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    uint64_t v8 = a4 + v7;
    re::StringID::operator=((unint64_t *)(a4 + v7), (uint64_t *)(a2 + v7));
    re::FixedArray<re::BlendShapeDefinition>::operator=((void *)(a4 + v7 + 16), a2 + v7 + 16);
    *(void *)(v8 + 40) = *(void *)(a2 + v7 + 40);
    *(_WORD *)(v8 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_WORD *)(a2 + v7 + 48);
    v7 += 56;
  }
  while (a2 + v7 != v6);
  return v6;
}

void *re::FixedArray<re::BlendShapeDefinition>::operator=(void *a1, uint64_t a2)
{
  if (a1 != (void *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::BlendShapeDefinition>::init<>((uint64_t)a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::BlendShapeDefinition>::copy((uint64_t)a1, a2);
    }
  }
  return a1;
}

uint64_t re::FixedArray<re::BlendShapeDefinition>::init<>(uint64_t result, uint64_t a2, unint64_t a3)
{
  *(void *)__n128 result = a2;
  *(void *)(result + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = a3;
  if (!a3) {
    return result;
  }
  if (a3 >= 0x1E1E1E1E1E1E1E2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element int64_t size = %zu, count = %zu", "!overflow", "init", 324, 136, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v4 = result;
  __n128 result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 136 * a3, 8);
  *(void *)(v4 + 16) = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    __n128 result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v6 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *(void *)__n128 result = 0;
      *(void *)(result + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = "";
      *(_OWORD *)(result + 16) = 0uLL;
      *(_OWORD *)(result + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0uLL;
      *(_OWORD *)(result + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0uLL;
      *(_OWORD *)(result + 64) = 0uLL;
      *(_OWORD *)(result + 80) = 0uLL;
      *(_OWORD *)(result + 96) = 0uLL;
      *(_OWORD *)(result + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0uLL;
      *(void *)(result + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
      result += 136;
      --v6;
    }
    while (v6);
  }
  *(void *)__n128 result = 0;
  *(void *)(result + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = "";
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0u;
  *(_OWORD *)(result + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0u;
  *(void *)(result + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  return result;
}

uint64_t re::FixedArray<re::BlendShapeDefinition>::copy(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)(a2 + 8)) {
    return std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BlendShapeDefinition *,re::BlendShapeDefinition *,re::BlendShapeDefinition *>((uint64_t)&v4, *(void *)(a2 + 16), *(void *)(a2 + 16) + 136 * v2, *(void *)(a1 + 16));
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BlendShapeDefinition *,re::BlendShapeDefinition *,re::BlendShapeDefinition *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    re::StringID::operator=((unint64_t *)(a4 + v7), (uint64_t *)(a2 + v7));
    re::FixedArray<unsigned int>::operator=((uint64_t *)(a4 + v7 + 16), a2 + v7 + 16);
    re::FixedArray<float>::operator=((uint64_t *)(a4 + v7 + 40), a2 + v7 + 40);
    re::FixedArray<float>::operator=((uint64_t *)(a4 + v7 + 64), a2 + v7 + 64);
    re::FixedArray<float>::operator=((uint64_t *)(a4 + v7 + 88), a2 + v7 + 88);
    re::FixedArray<float>::operator=((uint64_t *)(a4 + v7 + 112), a2 + v7 + 112);
    v7 += 136;
  }
  while (a2 + v7 != v6);
  return v6;
}

void *re::FixedArray<re::BlendShapeDefinition>::FixedArray(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::FixedArray<re::BlendShapeDefinition>::init<>((uint64_t)a1, v4, *(void *)(a2 + 8));
    re::FixedArray<re::BlendShapeDefinition>::copy((uint64_t)a1, a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetSkinningData>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetSkinningData>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetSkinningData>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetSkinningData>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::MeshAssetSkinningData>::setCapacity(a1, *(void *)(a2 + 16));
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetSkinningData *,re::MeshAssetSkinningData *,re::MeshAssetSkinningData *>((uint64_t)&v20, *(void *)(a2 + 32), *(void *)(a2 + 32) + 144 * a1[2], a1[4]);
    uint64_t v9 = a1[2];
    if (v9 != v4)
    {
      uint64_t v10 = *(void *)(a2 + 32);
      uint64_t v11 = v10 + 144 * v4;
      uint64_t v12 = a1[4];
      uint64_t v13 = 144 * v9;
      do
      {
        uint64_t v14 = v10 + v13;
        char v15 = (_OWORD *)(v12 + v13);
        *(_DWORD *)(v12 + v1re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(_DWORD *)(v10 + v13);
        re::FixedArray<re::SkinningInfluence>::FixedArray((uint64_t *)(v12 + v13 + 8), v10 + v13 + 8);
        re::FixedArray<int>::FixedArray((uint64_t *)(v12 + v13 + 32), v10 + v13 + 32);
        uint64_t result = (uint64_t)re::FixedArray<int>::FixedArray((uint64_t *)(v12 + v13 + 56), v10 + v13 + 56);
        long long v16 = *(_OWORD *)(v10 + v13 + 80);
        long long v17 = *(_OWORD *)(v10 + v13 + 96);
        long long v18 = *(_OWORD *)(v10 + v13 + 128);
        v15[7] = *(_OWORD *)(v10 + v13 + 112);
        char v15[8] = v18;
        v15[5] = v16;
        v15[6] = v17;
        v10 += 144;
        v12 += 144;
      }
      while (v14 + 144 != v11);
    }
  }
  else
  {
    uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetSkinningData *,re::MeshAssetSkinningData *,re::MeshAssetSkinningData *>((uint64_t)&v19, *(void *)(a2 + 32), *(void *)(a2 + 32) + 144 * v4, a1[4]);
    uint64_t v6 = a1[2];
    if (v4 != v6)
    {
      uint64_t v7 = 144 * v6 - 144 * v4;
      uint64_t v8 = (uint64_t *)(a1[4] + 144 * v4 + 56);
      do
      {
        re::FixedArray<CoreIKTransform>::deinit(v8);
        re::FixedArray<CoreIKTransform>::deinit(v8 - 3);
        uint64_t result = re::FixedArray<CoreIKTransform>::deinit(v8 - 6);
        v8 += 18;
        v7 -= 144;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

void *re::DynamicArray<re::MeshAssetSkinningData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetSkinningData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x90uLL))
        {
          uint64_t v2 = 144 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 144 * a2, 16);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 144, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (int *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = &v8[36 * v9];
        uint64_t v11 = v7;
        do
        {
          int v12 = *v8;
          void v11[2] = 0;
          v11[3] = 0;
          v11[1] = 0;
          uint64_t v13 = (uint64_t *)(v8 + 2);
          v11[1] = *((void *)v8 + 1);
          *((void *)v8 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
          uint64_t v14 = v11[3];
          uint64_t v15 = *((void *)v8 + 3);
          void v11[2] = *((void *)v8 + 2);
          v11[3] = v15;
          *((void *)v8 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
          *((void *)v8 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v14;
          v11[5] = 0;
          v11[6] = 0;
          void v11[4] = 0;
          long long v16 = (uint64_t *)(v8 + 8);
          void v11[4] = *((void *)v8 + 4);
          *((void *)v8 + 4) = 0;
          uint64_t v17 = v11[6];
          uint64_t v18 = *((void *)v8 + 6);
          v11[5] = *((void *)v8 + 5);
          v11[6] = v18;
          *((void *)v8 + 5) = 0;
          *((void *)v8 + 6) = v17;
          v11[7] = 0;
          unsigned char v11[8] = 0;
          v11[9] = 0;
          uint64_t v20 = *((void *)v8 + 7);
          char v19 = v8 + 14;
          *(_DWORD *)uint64_t v11 = v12;
          v11[7] = v20;
          *(void *)char v19 = 0;
          uint64_t v21 = v11[9];
          uint64_t v22 = *((void *)v19 + 2);
          unsigned char v11[8] = *((void *)v19 + 1);
          v11[9] = v22;
          *((void *)v19 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
          *((void *)v19 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v21;
          long long v23 = *(_OWORD *)(v19 + 6);
          long long v24 = *(_OWORD *)(v19 + 10);
          long long v25 = *(_OWORD *)(v19 + 18);
          *((_OWORD *)v11 + 7) = *(_OWORD *)(v19 + 14);
          *((_OWORD *)v11 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v25;
          *((_OWORD *)v11 + 5) = v23;
          *((_OWORD *)v11 + 6) = v24;
          re::FixedArray<CoreIKTransform>::deinit((uint64_t *)v19);
          re::FixedArray<CoreIKTransform>::deinit(v16);
          re::FixedArray<CoreIKTransform>::deinit(v13);
          uint64_t v8 = v19 + 22;
          v11 += 18;
        }
        while (v8 != v10);
        uint64_t v8 = (int *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, int *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetSkinningData *,re::MeshAssetSkinningData *,re::MeshAssetSkinningData *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    *(_DWORD *)a4 = *(_DWORD *)v5;
    re::FixedArray<re::SkinningInfluence>::operator=((uint64_t *)(a4 + 8), v5 + 8);
    re::FixedArray<int>::operator=((uint64_t *)(a4 + 32), v5 + 32);
    re::FixedArray<int>::operator=((uint64_t *)(a4 + 56), v5 + 56);
    long long v7 = *(_OWORD *)(v5 + 128);
    long long v9 = *(_OWORD *)(v5 + 80);
    long long v8 = *(_OWORD *)(v5 + 96);
    *(_OWORD *)(a4 + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(_OWORD *)(v5 + 112);
    *(_OWORD *)(a4 + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v7;
    *(_OWORD *)(a4 + 80) = v9;
    *(_OWORD *)(a4 + 96) = v8;
    a4 += 144;
    v5 += 144;
  }
  while (v5 != v6);
  return v6;
}

uint64_t *re::FixedArray<re::SkinningInfluence>::operator=(uint64_t *a1, uint64_t a2)
{
  if (a1 != (uint64_t *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::SkinningInfluence>::init<>(a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<unsigned long>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t *re::FixedArray<int>::operator=(uint64_t *a1, uint64_t a2)
{
  if (a1 != (uint64_t *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<int>::init<>(a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<int>::copy(a1, a2);
    }
  }
  return a1;
}

void re::FixedArray<re::SkinningInfluence>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >> 61)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element int64_t size = %zu, count = %zu", "!overflow", "init", 324, 8, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 8 * a3;
  uint64_t v6 = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 8 * a3, 4);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  long long v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 8);
    long long v8 = (void *)((char *)v8 + v5 - 8);
  }
  *long long v8 = 0;
}

void *re::FixedArray<int>::copy(void *result, uint64_t a2)
{
  uint64_t v2 = result[1];
  if (v2 == *(void *)(a2 + 8))
  {
    if (v2)
    {
      uint64_t v3 = *(const void **)(a2 + 16);
      uint64_t v4 = (void *)result[2];
      return memmove(v4, v3, 4 * v2);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    uint64_t result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::FixedArray<re::SkinningInfluence>::FixedArray(uint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::FixedArray<re::SkinningInfluence>::init<>(a1, v4, *(void *)(a2 + 8));
    re::FixedArray<unsigned long>::copy(a1, a2);
  }
  return a1;
}

uint64_t *re::FixedArray<int>::FixedArray(uint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::FixedArray<int>::init<>(a1, v4, *(void *)(a2 + 8));
    re::FixedArray<int>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetPart>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetPart>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetPart>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void *re::DynamicArray<re::MeshAssetPart>::copy(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  unint64_t v5 = result[2];
  if (v4 >= v5)
  {
    uint64_t result = re::DynamicArray<re::MeshAssetPart>::setCapacity(result, *(void *)(a2 + 16));
    uint64_t v11 = *(void *)(a2 + 32);
    uint64_t v12 = v3[2];
    uint64_t v13 = v3[4];
    if (v12)
    {
      uint64_t v14 = v12 << 8;
      do
      {
        uint64_t result = (void *)re::MeshAssetPart::operator=(v13, v11);
        v11 += 256;
        v13 += 256;
        v14 -= 256;
      }
      while (v14);
      uint64_t v13 = v3[4];
      uint64_t v12 = v3[2];
      uint64_t v11 = *(void *)(a2 + 32);
    }
    if (v12 != v4)
    {
      uint64_t v15 = v12 << 8;
      uint64_t v16 = v4 << 8;
      do
      {
        uint64_t v17 = v13 + v15;
        uint64_t v18 = v11 + v15;
        re::DynamicArray<re::MeshAssetBuffer>::DynamicArray(v13 + v15, (uint64_t *)(v11 + v15));
        long long v19 = *(_OWORD *)(v11 + v15 + 40);
        *(_OWORD *)(v17 + 5re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(_OWORD *)(v11 + v15 + 52);
        *(_OWORD *)(v17 + 40) = v19;
        re::StringID::StringID((re::StringID *)(v13 + v15 + 72), (const StringID *)(v11 + v15 + 72));
        long long v20 = *(_OWORD *)(v11 + v15 + 112);
        *(_OWORD *)(v17 + 96) = *(_OWORD *)(v11 + v15 + 96);
        *(_OWORD *)(v17 + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v20;
        long long v21 = *(_OWORD *)(v11 + v15 + 128);
        long long v22 = *(_OWORD *)(v11 + v15 + 144);
        long long v23 = *(_OWORD *)(v11 + v15 + 176);
        *(_OWORD *)(v17 + 160) = *(_OWORD *)(v11 + v15 + 160);
        *(_OWORD *)(v17 + 176) = v23;
        *(_OWORD *)(v17 + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v21;
        *(_OWORD *)(v17 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = v22;
        int v24 = *(unsigned __int8 *)(v11 + v15 + 192);
        *(unsigned char *)(v17 + 19re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v24;
        if (v24) {
          *(unsigned char *)(v17 + 19re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(unsigned char *)(v18 + 193);
        }
        int v25 = *(unsigned __int8 *)(v18 + 194);
        *(unsigned char *)(v17 + 194) = v25;
        if (v25) {
          *(unsigned char *)(v13 + v15 + 195) = *(unsigned char *)(v11 + v15 + 195);
        }
        uint64_t v26 = v13 + v15;
        uint64_t v27 = v11 + v15;
        int v28 = *(unsigned __int8 *)(v11 + v15 + 196);
        *(unsigned char *)(v13 + v15 + 196) = v28;
        if (v28) {
          *(unsigned char *)(v26 + 197) = *(unsigned char *)(v27 + 197);
        }
        uint64_t result = (void *)re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v26 + 200, v27 + 200);
        v16 -= 256;
        v11 += 256;
        v13 += 256;
      }
      while (v15 != v16);
    }
  }
  else
  {
    uint64_t v6 = result[4];
    if (v4)
    {
      uint64_t v7 = *(void *)(a2 + 32);
      uint64_t v8 = v4 << 8;
      do
      {
        uint64_t result = (void *)re::MeshAssetPart::operator=(v6, v7);
        v7 += 256;
        v6 += 256;
        v8 -= 256;
      }
      while (v8);
      uint64_t v6 = v3[4];
      unint64_t v5 = v3[2];
    }
    if (v4 != v5)
    {
      uint64_t v9 = v6 + (v4 << 8);
      uint64_t v10 = (v5 << 8) - (v4 << 8);
      do
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v9 + 200));
        re::StringID::destroyString((re::StringID *)(v9 + 72));
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetBuffer>::deinit(v9);
        v9 += 256;
        v10 -= 256;
      }
      while (v10);
    }
  }
  v3[2] = v4;
  return result;
}

void *re::DynamicArray<re::MeshAssetPart>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetPart>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (HIBYTE(a2))
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 256, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          unint64_t v2 = a2 << 8;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, a2 << 8, 16);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v9 << 8;
        uint64_t v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::MeshAssetPart>(v8, v11);
          v8 += 256;
          v11 += 256;
          v10 -= 256;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::ObjectHelper::move<re::MeshAssetPart>(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a2 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)a2 = *(void *)a1;
  *(void *)(a2 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v3;
  *(void *)a1 = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v4;
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = *(void *)(a1 + 32);
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v5;
  ++*(_DWORD *)(a1 + 24);
  ++*(_DWORD *)(a2 + 24);
  long long v6 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 5re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(_OWORD *)(a1 + 52);
  *(_OWORD *)(a2 + 40) = v6;
  uint64_t v7 = (re::StringID *)(a1 + 72);
  LOBYTE(v5) = *(void *)(a1 + 72);
  *(void *)(a2 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(void *)(a2 + 72) & 0xFFFFFFFFFFFFFFFELL | *(void *)(a1 + 72) & 1;
  *(void *)(a2 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(void *)(a1 + 72) & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  *(void *)(a2 + 80) = *(void *)(a1 + 80);
  *(void *)(a1 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  *(void *)(a1 + 80) = "";
  long long v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(a2 + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v8;
  long long v9 = *(_OWORD *)(a1 + 128);
  long long v10 = *(_OWORD *)(a1 + 144);
  long long v11 = *(_OWORD *)(a1 + 176);
  *(_OWORD *)(a2 + 160) = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(a2 + 176) = v11;
  *(_OWORD *)(a2 + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v9;
  *(_OWORD *)(a2 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = v10;
  LODWORD(v5) = *(unsigned __int8 *)(a1 + 192);
  *(unsigned char *)(a2 + 19re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v5;
  if (v5) {
    *(unsigned char *)(a2 + 19re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(unsigned char *)(a1 + 193);
  }
  int v12 = *(unsigned __int8 *)(a1 + 194);
  *(unsigned char *)(a2 + 194) = v12;
  if (v12) {
    *(unsigned char *)(a2 + 195) = *(unsigned char *)(a1 + 195);
  }
  int v13 = *(unsigned __int8 *)(a1 + 196);
  *(unsigned char *)(a2 + 196) = v13;
  if (v13) {
    *(unsigned char *)(a2 + 197) = *(unsigned char *)(a1 + 197);
  }
  *(_OWORD *)(a2 + 200) = 0u;
  uint64_t v14 = a2 + 200;
  *(_DWORD *)(v14 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_OWORD *)(v14 + 16) = 0u;
  *(void *)(v14 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v14, (uint64_t *)(a1 + 200));
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a1 + 200));
  re::StringID::destroyString(v7);
  return re::DynamicArray<re::MeshAssetBuffer>::deinit(a1);
}

uint64_t re::MeshAssetPart::operator=(uint64_t a1, uint64_t a2)
{
  re::DynamicArray<re::MeshAssetBuffer>::operator=(a1, (uint64_t *)a2);
  long long v4 = *(_OWORD *)(a2 + 52);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 5re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v4;
  re::StringID::operator=((unint64_t *)(a1 + 72), (uint64_t *)(a2 + 72));
  long long v5 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v5;
  long long v6 = *(_OWORD *)(a2 + 128);
  long long v7 = *(_OWORD *)(a2 + 144);
  long long v8 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 176) = v8;
  *(_OWORD *)(a1 + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v6;
  *(_OWORD *)(a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = v7;
  if (*(unsigned char *)(a1 + 192) || *(unsigned char *)(a2 + 192))
  {
    if (!*(unsigned char *)(a1 + 192) || *(unsigned char *)(a2 + 192))
    {
      if (!*(unsigned char *)(a1 + 192) && *(unsigned char *)(a2 + 192)) {
        *(unsigned char *)(a1 + 19re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 1;
      }
      *(unsigned char *)(a1 + 19re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(unsigned char *)(a2 + 193);
    }
    else
    {
      *(unsigned char *)(a1 + 19re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
    }
  }
  if (*(unsigned char *)(a1 + 194) || *(unsigned char *)(a2 + 194))
  {
    if (!*(unsigned char *)(a1 + 194) || *(unsigned char *)(a2 + 194))
    {
      if (!*(unsigned char *)(a1 + 194) && *(unsigned char *)(a2 + 194)) {
        *(unsigned char *)(a1 + 194) = 1;
      }
      *(unsigned char *)(a1 + 195) = *(unsigned char *)(a2 + 195);
    }
    else
    {
      *(unsigned char *)(a1 + 194) = 0;
    }
  }
  if (*(unsigned char *)(a1 + 196) || *(unsigned char *)(a2 + 196))
  {
    if (!*(unsigned char *)(a1 + 196) || *(unsigned char *)(a2 + 196))
    {
      if (!*(unsigned char *)(a1 + 196) && *(unsigned char *)(a2 + 196)) {
        *(unsigned char *)(a1 + 196) = 1;
      }
      *(unsigned char *)(a1 + 197) = *(unsigned char *)(a2 + 197);
    }
    else
    {
      *(unsigned char *)(a1 + 196) = 0;
    }
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a1 + 200, a2 + 200);
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetBuffer>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::MeshAssetBuffer>::copy(a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::MeshAssetBuffer>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::MeshAssetBuffer>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::MeshAssetBuffer>::copy(a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u) {
        signed int v5 = 3;
      }
      else {
        signed int v5 = *(_DWORD *)(a2 + 28);
      }
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(a1, v4, v5);
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetBuffer>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= *(void *)(a1 + 16))
  {
    re::DynamicArray<re::MeshAssetBuffer>::setCapacity((void *)a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetBuffer *,re::MeshAssetBuffer *,re::MeshAssetBuffer *>((int)&v14, *(re::DynamicString **)(a2 + 32), (re::DynamicString *)(*(void *)(a2 + 32) + 80 * *(void *)(a1 + 16)), *(re::DynamicString **)(a1 + 32));
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = *(void *)(a1 + 32);
      uint64_t v11 = 80 * v8;
      uint64_t v12 = 80 * v4;
      do
      {
        re::DynamicString::DynamicString((re::DynamicString *)(v10 + v11), (const re::DynamicString *)(v9 + v11));
        re::DynamicArray<BOOL>::DynamicArray(v10 + v11 + 32, (uint64_t *)(v9 + v11 + 32));
        *(_WORD *)(v10 + v11 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(_WORD *)(v9 + v11 + 72);
        v9 += 80;
        v12 -= 80;
        v10 += 80;
      }
      while (v11 != v12);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetBuffer *,re::MeshAssetBuffer *,re::MeshAssetBuffer *>((int)&v13, *(re::DynamicString **)(a2 + 32), (re::DynamicString *)(*(void *)(a2 + 32) + 80 * v4), *(re::DynamicString **)(a1 + 32));
    uint64_t v5 = *(void *)(a1 + 16);
    if (v4 != v5)
    {
      long long v6 = (re::DynamicString *)(*(void *)(a1 + 32) + 80 * v4);
      uint64_t v7 = 80 * v5 - 80 * v4;
      do
      {
        re::DynamicArray<unsigned long>::deinit((uint64_t)v6 + 32);
        re::DynamicString::deinit(v6);
        long long v6 = (re::DynamicString *)((char *)v6 + 80);
        v7 -= 80;
      }
      while (v7);
    }
  }
  *(void *)(a1 + 16) = v4;
}

void re::DynamicArray<re::MeshAssetBuffer>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(re::DynamicString **)(a1 + 32);
    uint64_t v4 = 80 * v2;
    do
    {
      re::DynamicArray<unsigned long>::deinit((uint64_t)v3 + 32);
      re::DynamicString::deinit(v3);
      uint64_t v3 = (re::DynamicString *)((char *)v3 + 80);
      v4 -= 80;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void *re::DynamicArray<re::MeshAssetBuffer>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetBuffer>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x50uLL))
        {
          uint64_t v2 = 80 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 80 * v9;
        uint64_t v11 = v7;
        do
        {
          *(_OWORD *)uint64_t v11 = 0u;
          *((_OWORD *)v11 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0u;
          v11[3] = *(void *)(v8 + 24);
          uint64_t v12 = *(void *)(v8 + 8);
          *uint64_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          uint64_t v13 = *(void *)(v8 + 16);
          *(void *)(v8 + 24) = 0;
          uint64_t v15 = v11[1];
          uint64_t v14 = v11[2];
          v11[1] = v12;
          void v11[2] = v13;
          *(void *)(v8 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v15;
          *(void *)(v8 + 16) = v14;
          unsigned char v11[8] = 0;
          *((_DWORD *)v11 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 14) = 0;
          v11[5] = 0;
          v11[6] = 0;
          void v11[4] = 0;
          uint64_t v16 = *(void *)(v8 + 40);
          void v11[4] = *(void *)(v8 + 32);
          *(void *)(v8 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
          v11[5] = v16;
          *(void *)(v8 + 40) = 0;
          uint64_t v17 = v11[6];
          v11[6] = *(void *)(v8 + 48);
          *(void *)(v8 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v17;
          uint64_t v18 = v11[8];
          unsigned char v11[8] = *(void *)(v8 + 64);
          *(void *)(v8 + 64) = v18;
          ++*(_DWORD *)(v8 + 56);
          ++*((_DWORD *)v11 + 14);
          *((_WORD *)v11 + 36) = *(_WORD *)(v8 + 72);
          re::DynamicArray<unsigned long>::deinit(v8 + 32);
          re::DynamicString::deinit((re::DynamicString *)v8);
          v8 += 80;
          v11 += 10;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

re::DynamicString *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetBuffer *,re::MeshAssetBuffer *,re::MeshAssetBuffer *>(int a1, re::DynamicString *a2, re::DynamicString *a3, re::DynamicString *this)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      re::DynamicString::operator=(this, v5);
      re::DynamicArray<BOOL>::operator=((uint64_t)this + 32, (uint64_t *)v5 + 4);
      *((_WORD *)this + 36) = *((_WORD *)v5 + 36);
      uint64_t v5 = (re::DynamicString *)((char *)v5 + 80);
      this = (re::DynamicString *)((char *)this + 80);
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<re::DynamicString&>(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (re::DynamicString *)(v8 + 16), (const re::DynamicString *)(v8 + 48));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 80;
    }
  }
}

uint64_t re::DynamicArray<re::MeshAssetBuffer>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetBuffer>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetBuffer>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(a1, v4, v5);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshLodLevelInfo>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshLodLevelInfo>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshLodLevelInfo>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

void **re::DynamicArray<re::MeshLodLevelInfo>::copy(void **result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::MeshLodLevelInfo>::setCapacity(result, *(void *)(a2 + 16));
    unint64_t v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 12 * (void)v5);
      unint64_t v5 = v3[2];
    }
    uint64_t result = (void **)memcpy((char *)v3[4] + 12 * (void)v5, (const void *)(*(void *)(a2 + 32) + 12 * (void)v5), 12 * v4 - 12 * (void)v5);
  }
  else if (v4)
  {
    uint64_t result = (void **)memmove(result[4], *(const void **)(a2 + 32), 12 * v4);
  }
  v3[2] = (void *)v4;
  return result;
}

void *re::DynamicArray<re::MeshLodLevelInfo>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0xCuLL))
        {
          uint64_t v2 = 12 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 12 * a2, 4);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              void v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 12 * v5[2]);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 12, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshLodLevelInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetContactDeformerData>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetContactDeformerData>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetContactDeformerData>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetContactDeformerData>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::MeshAssetContactDeformerData>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetContactDeformerData *,re::MeshAssetContactDeformerData *,re::MeshAssetContactDeformerData *>((uint64_t)&v14, *(void *)(a2 + 32), *(void *)(a2 + 32) + 48 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = a1[4];
      uint64_t v11 = 48 * v8;
      uint64_t v12 = 48 * v4;
      do
      {
        re::StringID::StringID((re::StringID *)(v10 + v11), (const StringID *)(v9 + v11));
        re::FixedArray<re::MeshAssetContactDeformerTarget>::FixedArray((uint64_t *)(v10 + v11 + 16), v9 + v11 + 16);
        *(_WORD *)(v10 + v11 + 40) = *(_WORD *)(v9 + v11 + 40);
        v9 += 48;
        v12 -= 48;
        v10 += 48;
      }
      while (v11 != v12);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetContactDeformerData *,re::MeshAssetContactDeformerData *,re::MeshAssetContactDeformerData *>((uint64_t)&v13, *(void *)(a2 + 32), *(void *)(a2 + 32) + 48 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = (re::StringID *)(a1[4] + 48 * v4);
      uint64_t v7 = 48 * v5 - 48 * v4;
      do
      {
        re::FixedArray<re::MeshAssetContactDeformerTarget>::deinit((void *)v6 + 2);
        re::StringID::destroyString(v6);
        uint64_t v6 = (re::StringID *)((char *)v6 + 48);
        v7 -= 48;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::MeshAssetContactDeformerData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetContactDeformerData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = &v8[6 * v9];
        uint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *uint64_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *uint64_t v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *uint64_t v8 = 0;
          v8[1] = (uint64_t)"";
          void v11[2] = 0;
          v11[3] = 0;
          void v11[4] = 0;
          void v11[2] = v8[2];
          void v8[2] = 0;
          uint64_t v13 = v11[4];
          uint64_t v14 = v8[4];
          v11[3] = v8[3];
          void v11[4] = v14;
          _OWORD v8[3] = 0;
          v8[4] = v13;
          *((_WORD *)v11 + re::FixedArray<re::StringID>::deinit((void *)this + 20) = *((_WORD *)v8 + 20);
          re::FixedArray<re::MeshAssetContactDeformerTarget>::deinit(v8 + 2);
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 6;
          v11 += 6;
        }
        while (v8 != v10);
        uint64_t v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetContactDeformerData *,re::MeshAssetContactDeformerData *,re::MeshAssetContactDeformerData *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      re::StringID::operator=((unint64_t *)a4, (uint64_t *)v5);
      re::FixedArray<re::MeshAssetContactDeformerTarget>::operator=((uint64_t *)(a4 + 16), v5 + 16);
      *(_WORD *)(a4 + 40) = *(_WORD *)(v5 + 40);
      v5 += 48;
      a4 += 48;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

uint64_t *re::FixedArray<re::MeshAssetContactDeformerTarget>::operator=(uint64_t *a1, uint64_t a2)
{
  if (a1 != (uint64_t *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::MeshAssetContactDeformerTarget>::init<>(a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::MeshAssetContactDeformerTarget>::copy((uint64_t)a1, a2);
    }
  }
  return a1;
}

void re::FixedArray<re::MeshAssetContactDeformerTarget>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >> 59)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element int64_t size = %zu, count = %zu", "!overflow", "init", 324, 32, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 32 * a3;
  uint64_t v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 32 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  uint64_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 32);
    uint64_t v8 = (_OWORD *)((char *)v8 + v5 - 32);
  }
  *uint64_t v8 = 0u;
  v8[1] = 0u;
}

uint64_t *re::FixedArray<re::MeshAssetContactDeformerTarget>::copy(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)(a2 + 8))
  {
    uint64_t v3 = *(uint64_t **)(a2 + 16);
    uint64_t v4 = *(void **)(a1 + 16);
    return std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::MeshAssetContactDeformerTarget *,re::MeshAssetContactDeformerTarget *,re::MeshAssetContactDeformerTarget *,0>(v3, &v3[4 * v2], v4);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    uint64_t result = (uint64_t *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::MeshAssetContactDeformerTarget *,re::MeshAssetContactDeformerTarget *,re::MeshAssetContactDeformerTarget *,0>(uint64_t *a1, uint64_t *a2, void *a3)
{
  uint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  do
  {
    uint64_t v6 = (uint64_t)(v4 + 1);
    uint64_t v7 = *v4;
    v4 += 4;
    uint64_t v8 = a3 + 1;
    *a3 = v7;
    a3 += 4;
    re::FixedArray<float>::operator=(v8, v6);
  }
  while (v4 != v5);
  return v5;
}

uint64_t *re::FixedArray<re::MeshAssetContactDeformerTarget>::FixedArray(uint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::FixedArray<re::MeshAssetContactDeformerTarget>::init<>(a1, v4, *(void *)(a2 + 8));
    re::FixedArray<re::MeshAssetContactDeformerTarget>::copy((uint64_t)a1, a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetSmoothDeformerData>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetSmoothDeformerData>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetSmoothDeformerData>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetSmoothDeformerData>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::MeshAssetSmoothDeformerData>::setCapacity(a1, *(void *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::MeshAssetSmoothDeformerData *,re::MeshAssetSmoothDeformerData *,re::MeshAssetSmoothDeformerData *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 24 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = 3 * v8;
      uint64_t v10 = *(void *)(a2 + 32) + 8 * v9;
      uint64_t v11 = (re::StringID *)(a1[4] + 8 * v9);
      uint64_t v12 = 24 * v4 - 8 * v9;
      do
      {
        uint64_t v13 = re::StringID::StringID(v11, (const StringID *)v10);
        *((_WORD *)v13 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_WORD *)(v10 + 16);
        v10 += 24;
        uint64_t v11 = (re::StringID *)((char *)v13 + 24);
        v12 -= 24;
      }
      while (v12);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::MeshAssetSmoothDeformerData *,re::MeshAssetSmoothDeformerData *,re::MeshAssetSmoothDeformerData *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 24 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = (re::StringID *)(a1[4] + 24 * v4);
      uint64_t v7 = 24 * v5 - 24 * v4;
      do
      {
        re::StringID::destroyString(v6);
        uint64_t v6 = (re::StringID *)((char *)v6 + 24);
        v7 -= 24;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::MeshAssetSmoothDeformerData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetSmoothDeformerData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x18uLL))
        {
          uint64_t v2 = 24 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = &v8[3 * v9];
        uint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *uint64_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *uint64_t v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *uint64_t v8 = 0;
          v8[1] = (uint64_t)"";
          *((_WORD *)v11 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *((_WORD *)v8 + 8);
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 3;
          v11 += 3;
        }
        while (v8 != v10);
        uint64_t v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::MeshAssetSmoothDeformerData *,re::MeshAssetSmoothDeformerData *,re::MeshAssetSmoothDeformerData *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::StringID::operator=((unint64_t *)a3, (uint64_t *)v4);
      *(_WORD *)(a3 + 16) = *(_WORD *)(v4 + 16);
      v4 += 24;
      a3 += 24;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::DynamicArray<re::MeshAssetWrapDeformerData>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetWrapDeformerData>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetWrapDeformerData>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetWrapDeformerData>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::MeshAssetWrapDeformerData>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetWrapDeformerData *,re::MeshAssetWrapDeformerData *,re::MeshAssetWrapDeformerData *>((uint64_t)&v15, *(void *)(a2 + 32), *(void *)(a2 + 32) + 112 * a1[2], a1[4]);
    uint64_t v9 = a1[2];
    if (v9 != v4)
    {
      uint64_t v10 = *(void *)(a2 + 32);
      uint64_t v11 = a1[4];
      uint64_t v12 = 112 * v9;
      uint64_t v13 = 112 * v4;
      do
      {
        re::StringID::StringID((re::StringID *)(v11 + v12), (const StringID *)(v10 + v12));
        re::StringID::StringID((re::StringID *)(v11 + v12 + 16), (const StringID *)(v10 + v12 + 16));
        re::FixedArray<unsigned int>::FixedArray((uint64_t *)(v11 + v12 + 32), v10 + v12 + 32);
        re::FixedArray<re::Vector3<float>>::FixedArray((uint64_t *)(v11 + v12 + 56), v10 + v12 + 56);
        re::FixedArray<re::Vector3<float>>::FixedArray((uint64_t *)(v11 + v12 + 80), v10 + v12 + 80);
        *(_WORD *)(v11 + v12 + 104) = *(_WORD *)(v10 + v12 + 104);
        v10 += 112;
        v13 -= 112;
        v11 += 112;
      }
      while (v12 != v13);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetWrapDeformerData *,re::MeshAssetWrapDeformerData *,re::MeshAssetWrapDeformerData *>((uint64_t)&v14, *(void *)(a2 + 32), *(void *)(a2 + 32) + 112 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = a1[4];
      uint64_t v7 = 112 * v4;
      uint64_t v8 = 112 * v5;
      do
      {
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v6 + v7 + 80));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v6 + v7 + 56));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v6 + v7 + 32));
        re::StringID::destroyString((re::StringID *)(v6 + v7 + 16));
        re::StringID::destroyString((re::StringID *)(v6 + v7));
        v6 += 112;
        v8 -= 112;
      }
      while (v7 != v8);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::MeshAssetWrapDeformerData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x70uLL))
        {
          uint64_t v2 = 112 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 112 * a2, 8);
          if (result)
          {
            uint64_t v7 = (uint64_t)result;
            if (!v5[1])
            {
LABEL_9:
              void v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            re::ObjectHelper::move<re::MeshAssetWrapDeformerData>((uint64_t *)v5[4], (uint64_t *)(v5[4] + 112 * v5[2]), v7);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 112, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetWrapDeformerData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::ObjectHelper::move<re::MeshAssetWrapDeformerData>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      uint64_t v6 = *v5;
      *(void *)a3 = *(void *)a3 & 0xFFFFFFFFFFFFFFFELL | *v5 & 1;
      *(void *)a3 = *v5 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
      *(void *)(a3 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v5[1];
      *uint64_t v5 = 0;
      v5[1] = (uint64_t)"";
      LOBYTE(v6) = v5[2];
      *(void *)(a3 + 16) = *(void *)(a3 + 16) & 0xFFFFFFFFFFFFFFFELL | v5[2] & 1;
      *(void *)(a3 + 16) = v5[2] & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
      *(void *)(a3 + 24) = v5[3];
      v5[3] = (uint64_t)"";
      _OWORD v5[2] = 0;
      *(void *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
      *(void *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v5[4];
      void v5[4] = 0;
      uint64_t v7 = *(void *)(a3 + 48);
      uint64_t v8 = v5[6];
      *(void *)(a3 + 40) = v5[5];
      *(void *)(a3 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v8;
      v5[5] = 0;
      void v5[6] = v7;
      *(void *)(a3 + 56) = 0;
      *(void *)(a3 + 64) = 0;
      *(void *)(a3 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
      *(void *)(a3 + 56) = v5[7];
      v5[7] = 0;
      uint64_t v9 = *(void *)(a3 + 72);
      uint64_t v10 = v5[9];
      *(void *)(a3 + 64) = v5[8];
      *(void *)(a3 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v10;
      v5[8] = 0;
      v5[9] = v9;
      *(void *)(a3 + 80) = 0;
      *(void *)(a3 + 8re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
      *(void *)(a3 + 96) = 0;
      *(void *)(a3 + 80) = v5[10];
      v5[10] = 0;
      uint64_t v11 = *(void *)(a3 + 96);
      uint64_t v12 = v5[12];
      *(void *)(a3 + 8re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v5[11];
      *(void *)(a3 + 96) = v12;
      v5[11] = 0;
      v5[12] = v11;
      *(_WORD *)(a3 + 104) = *((_WORD *)v5 + 52);
      re::FixedArray<CoreIKTransform>::deinit(v5 + 10);
      re::FixedArray<CoreIKTransform>::deinit(v5 + 7);
      re::FixedArray<CoreIKTransform>::deinit(v5 + 4);
      re::StringID::destroyString((re::StringID *)(v5 + 2));
      re::StringID::destroyString((re::StringID *)v5);
      v5 += 14;
      a3 += 112;
    }
    while (v5 != a2);
  }
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetWrapDeformerData *,re::MeshAssetWrapDeformerData *,re::MeshAssetWrapDeformerData *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    re::StringID::operator=((unint64_t *)(a4 + v7), (uint64_t *)(a2 + v7));
    re::StringID::operator=((unint64_t *)(a4 + v7 + 16), (uint64_t *)(a2 + v7 + 16));
    re::FixedArray<unsigned int>::operator=((uint64_t *)(a4 + v7 + 32), a2 + v7 + 32);
    re::FixedArray<re::Vector3<float>>::operator=((uint64_t *)(a4 + v7 + 56), a2 + v7 + 56);
    re::FixedArray<re::Vector3<float>>::operator=((uint64_t *)(a4 + v7 + 80), a2 + v7 + 80);
    *(_WORD *)(a4 + v7 + 104) = *(_WORD *)(a2 + v7 + 104);
    v7 += 112;
  }
  while (a2 + v7 != v6);
  return v6;
}

uint64_t *re::FixedArray<re::Vector3<float>>::FixedArray(uint64_t *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    re::FixedArray<re::Vector3<float>>::init<>(a1, v4, *(void *)(a2 + 8));
    re::FixedArray<re::Vector3<float>>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetJiggleDeformerData>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetJiggleDeformerData>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetJiggleDeformerData>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetJiggleDeformerData>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::MeshAssetJiggleDeformerData>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetJiggleDeformerData *,re::MeshAssetJiggleDeformerData *,re::MeshAssetJiggleDeformerData *>((uint64_t)&v16, *(void *)(a2 + 32), *(void *)(a2 + 32) + 48 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = a1[4];
      uint64_t v11 = 48 * v8;
      uint64_t v12 = 48 * v4;
      do
      {
        uint64_t v13 = v10 + v11;
        re::StringID::StringID((re::StringID *)(v10 + v11), (const StringID *)(v9 + v11));
        re::StringID::StringID((re::StringID *)(v10 + v11 + 16), (const StringID *)(v9 + v11 + 16));
        uint64_t v14 = *(void *)(v9 + v11 + 32);
        *(_WORD *)(v13 + 40) = *(_WORD *)(v9 + v11 + 40);
        *(void *)(v13 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v14;
        v9 += 48;
        v12 -= 48;
        v10 += 48;
      }
      while (v11 != v12);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetJiggleDeformerData *,re::MeshAssetJiggleDeformerData *,re::MeshAssetJiggleDeformerData *>((uint64_t)&v15, *(void *)(a2 + 32), *(void *)(a2 + 32) + 48 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = a1[4] + 48 * v4;
      uint64_t v7 = 48 * v5 - 48 * v4;
      do
      {
        re::StringID::destroyString((re::StringID *)(v6 + 16));
        re::StringID::destroyString((re::StringID *)v6);
        v6 += 48;
        v7 -= 48;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::MeshAssetJiggleDeformerData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetJiggleDeformerData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = &v8[6 * v9];
        uint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *uint64_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *uint64_t v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *uint64_t v8 = 0;
          v8[1] = (uint64_t)"";
          LOBYTE(v1re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v8[2];
          void v11[2] = v11[2] & 0xFFFFFFFFFFFFFFFELL | v8[2] & 1;
          void v11[2] = v8[2] & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[3] = v8[3];
          _OWORD v8[3] = (uint64_t)"";
          void v8[2] = 0;
          uint64_t v13 = v8[4];
          *((_WORD *)v11 + re::FixedArray<re::StringID>::deinit((void *)this + 20) = *((_WORD *)v8 + 20);
          void v11[4] = v13;
          re::StringID::destroyString((re::StringID *)(v8 + 2));
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 6;
          v11 += 6;
        }
        while (v8 != v10);
        uint64_t v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetJiggleDeformerData *,re::MeshAssetJiggleDeformerData *,re::MeshAssetJiggleDeformerData *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v4 = a3;
  uint64_t v5 = a4 + 16;
  uint64_t v6 = a2 + 16;
  do
  {
    re::StringID::operator=((unint64_t *)(v5 - 16), (uint64_t *)(v6 - 16));
    re::StringID::operator=((unint64_t *)v5, (uint64_t *)v6);
    uint64_t v7 = *(void *)(v6 + 16);
    *(_WORD *)(v5 + 24) = *(_WORD *)(v6 + 24);
    *(void *)(v5 + 16) = v7;
    v5 += 48;
    uint64_t v8 = v6 + 32;
    v6 += 48;
  }
  while (v8 != v4);
  return v4;
}

uint64_t re::DynamicArray<re::MeshAssetInstance>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetInstance>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetInstance>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetInstance>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::MeshAssetInstance>::setCapacity(a1, *(void *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::MeshAssetInstance *,re::MeshAssetInstance *,re::MeshAssetInstance *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 96 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = 3 * v8;
      uint64_t v10 = *(void *)(a2 + 32) + 32 * v9;
      uint64_t v11 = (re::StringID *)(a1[4] + 32 * v9);
      uint64_t v12 = 96 * v4 - 32 * v9;
      do
      {
        uint64_t v13 = re::StringID::StringID(v11, (const StringID *)v10);
        *((_OWORD *)v13 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(_OWORD *)(v10 + 16);
        long long v14 = *(_OWORD *)(v10 + 32);
        long long v15 = *(_OWORD *)(v10 + 48);
        long long v16 = *(_OWORD *)(v10 + 64);
        *(_OWORD *)((char *)v13 + 76) = *(_OWORD *)(v10 + 76);
        *((_OWORD *)v13 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v15;
        *((_OWORD *)v13 + 4) = v16;
        *((_OWORD *)v13 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v14;
        v10 += 96;
        uint64_t v11 = (re::StringID *)((char *)v13 + 96);
        v12 -= 96;
      }
      while (v12);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::MeshAssetInstance *,re::MeshAssetInstance *,re::MeshAssetInstance *,0>(*(void *)(a2 + 32), *(void *)(a2 + 32) + 96 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = (re::StringID *)(a1[4] + 96 * v4);
      uint64_t v7 = 96 * v5 - 96 * v4;
      do
      {
        re::StringID::destroyString(v6);
        uint64_t v6 = (re::StringID *)((char *)v6 + 96);
        v7 -= 96;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::MeshAssetInstance>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetInstance>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x60uLL))
        {
          uint64_t v2 = 96 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 96 * a2, 16);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 96, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = &v8[12 * v9];
        uint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *uint64_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *uint64_t v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *uint64_t v8 = 0;
          v8[1] = (uint64_t)"";
          long long v13 = *(_OWORD *)((char *)v8 + 76);
          long long v14 = *((_OWORD *)v8 + 2);
          long long v15 = *((_OWORD *)v8 + 4);
          *((_OWORD *)v11 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *((_OWORD *)v8 + 3);
          *((_OWORD *)v11 + 4) = v15;
          *((_OWORD *)v11 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v14;
          *((_OWORD *)v11 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *((_OWORD *)v8 + 1);
          *(_OWORD *)((char *)v11 + 76) = v13;
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 12;
          v11 += 12;
        }
        while (v8 != v10);
        uint64_t v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::MeshAssetInstance *,re::MeshAssetInstance *,re::MeshAssetInstance *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::StringID::operator=((unint64_t *)a3, (uint64_t *)v4);
      *(_OWORD *)(a3 + 16) = *(_OWORD *)(v4 + 16);
      long long v6 = *(_OWORD *)(v4 + 32);
      long long v7 = *(_OWORD *)(v4 + 48);
      long long v8 = *(_OWORD *)(v4 + 64);
      *(_OWORD *)(a3 + 76) = *(_OWORD *)(v4 + 76);
      *(_OWORD *)(a3 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v7;
      *(_OWORD *)(a3 + 64) = v8;
      *(_OWORD *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v6;
      v4 += 96;
      a3 += 96;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::DynamicArray<re::MeshAssetSkeleton>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::MeshAssetSkeleton>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::MeshAssetSkeleton>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetSkeleton>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::MeshAssetSkeleton>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetSkeleton *,re::MeshAssetSkeleton *,re::MeshAssetSkeleton *>((uint64_t)&v15, *(void *)(a2 + 32), *(void *)(a2 + 32) + 112 * a1[2], a1[4]);
    uint64_t v9 = a1[2];
    if (v9 != v4)
    {
      uint64_t v10 = *(void *)(a2 + 32);
      uint64_t v11 = a1[4];
      uint64_t v12 = 112 * v9;
      uint64_t v13 = 112 * v4;
      do
      {
        re::StringID::StringID((re::StringID *)(v11 + v12), (const StringID *)(v10 + v12));
        re::FixedArray<re::StringID>::FixedArray((unint64_t *)(v11 + v12 + 16), v10 + v12 + 16);
        re::FixedArray<unsigned int>::FixedArray((uint64_t *)(v11 + v12 + 40), v10 + v12 + 40);
        re::FixedArray<re::GenericSRT<float>>::FixedArray((void *)(v11 + v12 + 64), v10 + v12 + 64);
        re::FixedArray<re::Matrix4x4<float>>::FixedArray((uint64_t *)(v11 + v12 + 88), v10 + v12 + 88);
        v10 += 112;
        v13 -= 112;
        v11 += 112;
      }
      while (v12 != v13);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetSkeleton *,re::MeshAssetSkeleton *,re::MeshAssetSkeleton *>((uint64_t)&v14, *(void *)(a2 + 32), *(void *)(a2 + 32) + 112 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = a1[4];
      uint64_t v7 = 112 * v4;
      uint64_t v8 = 112 * v5;
      do
      {
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v6 + v7 + 88));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v6 + v7 + 64));
        re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v6 + v7 + 40));
        re::FixedArray<re::StringID>::deinit((void *)(v6 + v7 + 16));
        re::StringID::destroyString((re::StringID *)(v6 + v7));
        v6 += 112;
        v8 -= 112;
      }
      while (v7 != v8);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::MeshAssetSkeleton>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x70uLL))
        {
          uint64_t v2 = 112 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 112 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              void v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            re::ObjectHelper::move<re::MeshAssetSkeleton>((uint64_t *)v5[4], (uint64_t *)(v5[4] + 112 * v5[2]), v7);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 112, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::MeshAssetSkeleton>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::ObjectHelper::move<re::MeshAssetSkeleton>(uint64_t *a1, uint64_t *a2, unint64_t *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      uint64_t v6 = *v5;
      *a3 = *a3 & 0xFFFFFFFFFFFFFFFELL | *v5 & 1;
      *a3 = *v5 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
      a3[1] = v5[1];
      *uint64_t v5 = 0;
      v5[1] = (uint64_t)"";
      a3[2] = 0;
      a3[3] = 0;
      a3[4] = 0;
      a3[2] = v5[2];
      _OWORD v5[2] = 0;
      uint64_t v7 = a3[4];
      uint64_t v8 = v5[4];
      a3[3] = v5[3];
      a3[4] = v8;
      v5[3] = 0;
      void v5[4] = v7;
      a3[5] = 0;
      a3[6] = 0;
      a3[7] = 0;
      a3[5] = v5[5];
      v5[5] = 0;
      uint64_t v9 = a3[7];
      uint64_t v10 = v5[7];
      a3[6] = v5[6];
      a3[7] = v10;
      void v5[6] = 0;
      v5[7] = v9;
      a3[8] = 0;
      a3[9] = 0;
      a3[10] = 0;
      a3[8] = v5[8];
      v5[8] = 0;
      uint64_t v11 = a3[10];
      uint64_t v12 = v5[10];
      a3[9] = v5[9];
      a3[10] = v12;
      v5[9] = 0;
      v5[10] = v11;
      a3[11] = 0;
      a3[12] = 0;
      a3[13] = 0;
      a3[11] = v5[11];
      v5[11] = 0;
      uint64_t v13 = a3[13];
      uint64_t v14 = v5[13];
      a3[12] = v5[12];
      a3[13] = v14;
      v5[12] = 0;
      v5[13] = v13;
      re::FixedArray<CoreIKTransform>::deinit(v5 + 11);
      re::FixedArray<CoreIKTransform>::deinit(v5 + 8);
      re::FixedArray<CoreIKTransform>::deinit(v5 + 5);
      re::FixedArray<re::StringID>::deinit(v5 + 2);
      re::StringID::destroyString((re::StringID *)v5);
      v5 += 14;
      a3 += 14;
    }
    while (v5 != a2);
  }
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::MeshAssetSkeleton *,re::MeshAssetSkeleton *,re::MeshAssetSkeleton *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    re::StringID::operator=((unint64_t *)(a4 + v7), (uint64_t *)(a2 + v7));
    re::FixedArray<re::StringID>::operator=((unint64_t *)(a4 + v7 + 16), a2 + v7 + 16);
    re::FixedArray<unsigned int>::operator=((uint64_t *)(a4 + v7 + 40), a2 + v7 + 40);
    re::FixedArray<re::GenericSRT<float>>::operator=((void *)(a4 + v7 + 64), a2 + v7 + 64);
    re::FixedArray<re::Matrix4x4<float>>::operator=((uint64_t *)(a4 + v7 + 88), a2 + v7 + 88);
    v7 += 112;
  }
  while (a2 + v7 != v6);
  return v6;
}

void re::DynamicArray<re::MeshAssetSkeleton>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 112 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = (uint64_t *)(*(void *)(a1 + 32) + v8);
      re::FixedArray<CoreIKTransform>::deinit(v10 + 11);
      re::FixedArray<CoreIKTransform>::deinit(v10 + 8);
      re::FixedArray<CoreIKTransform>::deinit(v10 + 5);
      re::FixedArray<re::StringID>::deinit(v10 + 2);
      re::StringID::destroyString((re::StringID *)v10);
      ++v9;
      v8 += 112;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::MeshAssetSkeleton>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 112 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = "";
        *(_OWORD *)(v7 + 16) = 0uLL;
        *(_OWORD *)(v7 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0uLL;
        *(_OWORD *)(v7 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0uLL;
        *(_OWORD *)(v7 + 64) = 0uLL;
        *(_OWORD *)(v7 + 80) = 0uLL;
        *(_OWORD *)(v7 + 96) = 0uLL;
        v6 += 112;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::MeshAsset::skeletonAtIndex(re::MeshAsset *this, unint64_t a2)
{
  if (*((void *)this + 117) > a2) {
    return *((void *)this + 118) + 160 * a2;
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "skeletonIndex < skeletonCount()", "skeletonAtIndex", 265);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t anonymous namespace'::makeMeshAssetPartFromMeshPart(_anonymous_namespace_ *this, const re::MeshPart *a2, re::MeshManager *a3, int a4)
{
  uint64_t v6 = a2;
  uint64_t v333 = *MEMORY[0x263EF8340];
  uint64_t v312 = 0;
  uint64_t v309 = 0;
  long long v310 = 0uLL;
  int v311 = 0;
  v313[4] = 1;
  *(_DWORD *)&v313[12] = 1;
  *(_WORD *)&v313[16] = -1;
  *(_DWORD *)&v313[24] = 0;
  *(_DWORD *)&v313[20] = 0;
  unint64_t v8 = (unint64_t)&v314;
  unint64_t v314 = 0;
  uint64_t v315 = "";
  *(void *)&long long v9 = 0x7F0000007FLL;
  *((void *)&v9 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0x7F0000007FLL;
  int32x4_t v316 = vdupq_n_s32(0x7F800000u);
  long long v317 = v9;
  char v324 = 0;
  char v326 = 0;
  memset(v328, 0, 36);
  char v322 = 0;
  long long v320 = 0u;
  long long v321 = 0u;
  long long v318 = 0u;
  long long v319 = 0u;
  *(void *)&v328[36] = 0x7FFFFFFFLL;
  uint64_t v10 = re::AttributeTable::buffers(a2);
  unint64_t v12 = v11;
  uint64_t v13 = v6;
  do
  {
    uint64_t v14 = v13;
    uint64_t v13 = (const re::MeshPart *)*((void *)v13 + 1);
  }
  while (v13 && !*((void *)v14 + 4));
  id v15 = *(id *)(*(void *)a3 + 184);
  long long v16 = (_anonymous_namespace_ *)[v15 supportsFamily:1006];
  if (v16)
  {
    long long v16 = (_anonymous_namespace_ *)[v15 supportsFamily:5001];
    int v262 = (int)v16;
  }
  else
  {
    int v262 = 0;
  }
  if (*((void *)v14 + 4) != v12 || *((void *)v6 + 43) != v12)
  {
    long long v32 = __dst[0];
    long long v33 = __dst[1];
    *(unsigned char *)this = 0;
    *((void *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 100;
    *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::AssetErrorCategory(void)::instance;
    *((_OWORD *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v32;
    *((_OWORD *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v33;
    goto LABEL_473;
  }
  float32x4_t v260 = a3;
  float32x4_t v261 = this;
  id v258 = v15;
  float v264 = v6;
  float32x4_t v280 = 0;
  v277[1] = 0;
  unint64_t v278 = 0;
  v277[0] = 0;
  int v279 = 0;
  long long v268 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)v12;
  if (v12)
  {
    re::DynamicArray<re::MeshAssetBuffer>::setCapacity(&v309, v12);
    re::DynamicArray<re::ReadOnlyCPUAccessibleBufferSliceContent>::resize((uint64_t)v277, v12);
    unint64_t v4 = 0;
    uint64_t v18 = 0;
    unint64_t v8 = (unint64_t)&v301[8];
    unint64_t v272 = v278;
    unint64_t v19 = (unint64_t)v280;
    while (1)
    {
      unint64_t v20 = *((void *)v14 + 4);
      if (v20 <= (unint64_t)v18) {
        goto LABEL_475;
      }
      if (*((unsigned char *)v4 + *((void *)v14 + 5) + 4) != 1) {
        break;
      }
      if (a4 && (long long v21 = (char *)v4 + v10, !*(_DWORD *)((char *)v4 + v10 + 12)))
      {
        id v28 = *(id *)v21;
        int v29 = *((_DWORD *)v21 + 2);
        unsigned int v30 = objc_msgSend(*(id *)v21, sel_length);
        int v31 = *((_DWORD *)v21 + 2);
        *(void *)unint64_t v329 = v28;
        *(_DWORD *)&v329[8] = v29;
        uint64_t v6 = v264;
        LODWORD(v24) = v30 - v31;
        this = v261;
      }
      else
      {
        id v22 = *(id *)((char *)v4 + v10);
        unint64_t v23 = *(void *)((char *)v4 + v10 + 8);
        if (v22) {
          id v22 = v22;
        }
        *(void *)unint64_t v329 = v22;
        unint64_t v24 = HIDWORD(v23);
        *(_DWORD *)&v329[8] = v23;
      }
      unint64_t v12 = (unint64_t)v268;
      LODWORD(v330) = v24;
      re::ReadOnlyCPUAccessibleBufferSliceContent::make(v329, (uint64_t)v301);
      unint64_t v20 = v301[0];
      if (v301[0])
      {
        if (v272 <= (unint64_t)v18) {
          goto LABEL_479;
        }
        re::ReadOnlyCPUAccessibleBufferSliceContent::operator=((uint64_t *)v19, (uint64_t *)&v301[8]);
      }
      else
      {
        long long v26 = __dst[0];
        long long v27 = __dst[1];
        *(unsigned char *)this = 0;
        *((void *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 100;
        *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::AssetErrorCategory(void)::instance;
        *((_OWORD *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v26;
        *((_OWORD *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v27;
      }
      re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(v301);
      uint64_t v17 = *(_anonymous_namespace_ **)v329;
      if (*(void *)v329) {

      }
      if (!v20) {
        goto LABEL_466;
      }
      uint64_t v18 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v18 + 1);
      v19 += 56;
      unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 16);
      if (v268 == v18) {
        goto LABEL_30;
      }
    }
    long long v58 = __dst[0];
    long long v59 = __dst[1];
    *(unsigned char *)this = 0;
    *((void *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 100;
    *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::AssetErrorCategory(void)::instance;
    *((_OWORD *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v58;
    *((_OWORD *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v59;
    goto LABEL_466;
  }
  re::DynamicArray<re::ReadOnlyCPUAccessibleBufferSliceContent>::resize((uint64_t)v277, 0);
LABEL_30:
  long long v308 = 0u;
  memset(v307, 0, sizeof(v307));
  unint64_t v281 = 0;
  if (!v12)
  {
    unsigned int v259 = *((_DWORD *)v6 + 117);
    unint64_t v257 = *((unsigned __int8 *)v6 + 477);
    if (a4) {
      goto LABEL_77;
    }
LABEL_92:
    unint64_t v49 = (id *)v260;
    goto LABEL_315;
  }
  unint64_t v8 = 0;
  unint64_t v20 = v278;
  uint64_t v18 = v280;
  unint64_t v19 = 56;
  do
  {
    unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)*((void *)v6 + 43);
    if ((unint64_t)v4 <= v8)
    {
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v8;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_475:
      *(void *)&v307[0] = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v18;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_476:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 789;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v8;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_477:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v8;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_478:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 789;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v4;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_479:
      unint64_t v281 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v307[0]) = 136315906;
      *(void *)((char *)v307 + 4) = "operator[]";
      WORD6(v307[0]) = 1024;
      *(_DWORD *)((char *)v307 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 14) = 789;
      WORD1(v307[1]) = 2048;
      *(void *)((char *)&v307[1] + 4) = v18;
      WORD6(v307[1]) = 2048;
      *(void *)((char *)&v307[1] + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 14) = v272;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_480:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 789;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v20;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v263;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_481:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v20;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_482:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v4;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_483:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v4;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v19;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_484:
      unint64_t v281 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v329 = 136315906;
      *(void *)&v329[4] = "operator[]";
      LOWORD(v330) = 1024;
      *(_DWORD *)((char *)&v330 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 476;
      WORD3(v330) = 2048;
      *((void *)&v330 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v4;
      __int16 v331 = 2048;
      unint64_t v332 = v19;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_485:
      unint64_t v281 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v8;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v19;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_486:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      unint64_t v255 = v70;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v255;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_487:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 789;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v263;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v263;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_488;
    }
    unint64_t v35 = 0;
    BOOL v36 = 1;
    do
    {
      BOOL v37 = (unsigned char *)qword_264BE26C8[2 * v35 + 1];
      int v38 = *v37;
      unint64_t v39 = *(unsigned char **)(*((void *)v6 + 44) + 16 * v8 + 8);
      if (*v37)
      {
        int v40 = v37 + 1;
        unint64_t v39 = *(unsigned char **)(*((void *)v6 + 44) + 16 * v8 + 8);
        while (*v39 && v38 == *v39)
        {
          ++v39;
          int v42 = *v40++;
          int v38 = v42;
          if (!v42) {
            goto LABEL_42;
          }
        }
      }
      else
      {
LABEL_42:
        if (!*v39) {
          break;
        }
      }
      BOOL v36 = v35++ < 8;
    }
    while (v35 != 9);
    if (v36)
    {
      if (v20 <= v8) {
        goto LABEL_476;
      }
      unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)*((void *)v14 + 4);
      if ((unint64_t)v4 <= v8) {
        goto LABEL_477;
      }
      *(void *)&__dst[0] = *((void *)v18 + 7 * v8) + *(unsigned int *)(*((void *)v14 + 5) + 16 * v8 + 8);
      if (re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::find(v307, *(unint64_t *)&__dst[0]) == -1)re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::addNew((uint64_t *)v307, (unint64_t *)__dst, &v281); {
    }
      }
    unint64_t v281 = ++v8;
  }
  while (v8 < v12);
  unsigned int v259 = *((_DWORD *)v6 + 117);
  unint64_t v257 = *((unsigned __int8 *)v6 + 477);
  if ((a4 & 1) == 0)
  {
    unint64_t v12 = 0;
    unint64_t v4 = 0;
    unint64_t v276 = 0;
    while (1)
    {
      if (v20 <= (unint64_t)v4) {
        goto LABEL_478;
      }
      long long v275 = *(char **)v18;
      uint64_t v43 = re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::find(v307, (unint64_t)v275);
      if (v43 == -1)
      {
        uint64_t v43 = re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::addNew((uint64_t *)v307, (unint64_t *)&v275, (unint64_t *)&v276);
        unint64_t v8 = v43;
      }
      else
      {
        unint64_t v8 = *((void *)&v307[0] + 1) + 16 * v43 + 8;
      }
      if (v4 == *(re::ReadOnlyCPUAccessibleBufferSliceContent **)v8)
      {
        unint64_t v8 = *((void *)v14 + 4);
        if (v8 <= (unint64_t)v4) {
          goto LABEL_482;
        }
        uint64_t v44 = *((void *)v14 + 5);
        unint64_t v8 = *((void *)v18 + 1);
        memset(v301, 0, 32);
        re::DynamicString::setCapacity(v301, 0);
        uint64_t v305 = 0;
        unint64_t v302 = 0;
        uint64_t v303 = 0;
        *(void *)&v301[32] = 0;
        int v304 = 0;
        __int16 v306 = 256;
        unint64_t v19 = *((void *)v6 + 43);
        if (v19 <= (unint64_t)v4) {
          goto LABEL_484;
        }
        unint64_t v19 = *(void *)(*((void *)v6 + 44) + v12 + 8);
        size_t v45 = strlen((const char *)v19);
        *(void *)&__dst[0] = v19;
        *((void *)&__dst[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v45;
        re::DynamicString::operator=((re::DynamicString *)v301, (uint64_t)__dst);
        LOBYTE(v306) = *(unsigned char *)(v44 + v12 + 12);
        HIBYTE(v306) = *(unsigned char *)(v44 + v12 + 5);
        if (v302 < v8) {
          re::DynamicArray<BOOL>::setCapacity(&v301[32], v8);
        }
        re::DynamicArray<REFrameAnalysisBottleneck>::copy(&v301[32], 0, *(char **)v18, v8);
        v46.n128_f64[0] = re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)&v309, (uint64_t)v301);
        uint64_t v6 = v264;
        if (*(void *)&v301[32])
        {
          if (v305) {
            (*(void (**)(double))(**(void **)&v301[32] + 40))(v46.n128_f64[0]);
          }
          uint64_t v305 = 0;
          unint64_t v302 = 0;
          uint64_t v303 = 0;
          *(void *)&v301[32] = 0;
          ++v304;
        }
        uint64_t v34 = *(void *)v301;
        if (!*(void *)v301 || (v301[8] & 1) == 0) {
          goto LABEL_74;
        }
        uint64_t v47 = *(void *)&v301[16];
      }
      else
      {
        unint64_t v19 = *((void *)v6 + 43);
        if (v19 <= (unint64_t)v4) {
          goto LABEL_483;
        }
        uint64_t v48 = *(const char **)(*((void *)v6 + 44) + v12 + 8);
        unint64_t v8 = *(void *)v8;
        unint64_t v19 = *((void *)v6 + 43);
        if (v19 <= v8) {
          goto LABEL_485;
        }
        *(void *)&__dst[0] = *(void *)(*((void *)v6 + 44) + 16 * v8 + 8);
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew<char const*>((uint64_t)v328, (re::DynamicString *)v329, (const char **)__dst);
        uint64_t v34 = *(void *)v329;
        if (!*(void *)v329 || (v329[8] & 1) == 0) {
          goto LABEL_74;
        }
        uint64_t v47 = *(void *)((char *)&v330 + 4);
      }
      uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t, __n128))(*(void *)v34 + 40))(v34, v47, v46);
LABEL_74:
      unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 1);
      unint64_t v276 = v4;
      v12 += 16;
      uint64_t v18 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v18 + 56);
      if (v4 >= v268)
      {
        this = v261;
        goto LABEL_92;
      }
    }
  }
LABEL_77:
  unint64_t v49 = (id *)v260;
  unint64_t v19 = *((unsigned __int8 *)v6 + 476);
  if (v19 == 255) {
    goto LABEL_106;
  }
  unint64_t v8 = v278;
  if (v278 <= v19) {
    goto LABEL_497;
  }
  unint64_t v8 = *((void *)v14 + 4);
  if (v8 <= v19)
  {
LABEL_498:
    *(void *)unint64_t v329 = 0;
    memset(v283, 0, sizeof(v283));
    memset(__dst, 0, sizeof(__dst));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int8x16_t v301 = 136315906;
    *(void *)&v301[4] = "operator[]";
    *(_WORD *)&v301[12] = 1024;
    *(_DWORD *)&v301[14] = 476;
    *(_WORD *)&v301[18] = 2048;
    *(void *)&v301[20] = v19;
    *(_WORD *)&v301[28] = 2048;
    *(void *)&v301[30] = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_499;
  }
  uint64_t v50 = (unsigned __int16 **)((char *)v280 + 56 * *((unsigned __int8 *)v6 + 476));
  uint64_t v51 = *((unsigned int *)v6 + 116);
  int v52 = *(unsigned __int8 *)(*((void *)v14 + 5) + 16 * v19 + 12);
  if (v52 != 36)
  {
    if (v52 == 49
      && *((void *)v280 + 7 * *((unsigned __int8 *)v6 + 476) + 1) >= (unint64_t)(2 * v51)
      && v51)
    {
      unsigned int v53 = 0;
      uint64_t v54 = *v50;
      do
      {
        unsigned int v56 = *v54++;
        unsigned int v55 = v56;
        if (v53 <= v56) {
          unsigned int v57 = v55;
        }
        else {
          unsigned int v57 = v53;
        }
        if (v55 != 0xFFFF) {
          unsigned int v53 = v57;
        }
        --v51;
      }
      while (v51);
      goto LABEL_105;
    }
LABEL_104:
    unsigned int v53 = 0;
    goto LABEL_105;
  }
  if (*((void *)v280 + 7 * *((unsigned __int8 *)v6 + 476) + 1) < (unint64_t)(4 * v51) || !v51) {
    goto LABEL_104;
  }
  unsigned int v53 = 0;
  uint64_t v60 = *v50;
  do
  {
    unsigned int v62 = *(_DWORD *)v60;
    v60 += 2;
    unsigned int v61 = v62;
    if (v53 <= v62) {
      unsigned int v63 = v61;
    }
    else {
      unsigned int v63 = v53;
    }
    if (v61 != -1) {
      unsigned int v53 = v63;
    }
    --v51;
  }
  while (v51);
LABEL_105:
  unsigned int v259 = v53 + 1;
LABEL_106:
  uint64_t v34 = useGPUFormatConversionForAttributeSerialization();
  if ((v34 & v262 & 1) == 0)
  {
    unint64_t v276 = 0;
    if (v12)
    {
      unint64_t v20 = 0;
      unint64_t v263 = v278;
      uint64_t v265 = v280;
      do
      {
        if (v263 <= v20) {
          goto LABEL_480;
        }
        unint64_t v8 = *((void *)v14 + 4);
        if (v8 <= v20) {
          goto LABEL_481;
        }
        long long v275 = (char *)(*((void *)v265 + 7 * v20) + *(unsigned int *)(*((void *)v14 + 5) + 16 * v20 + 8));
        uint64_t v64 = re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::find(v307, (unint64_t)v275);
        if (v64 == -1)
        {
          uint64_t v64 = re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::addNew((uint64_t *)v307, (unint64_t *)&v275, (unint64_t *)&v276);
          uint64_t v65 = (unint64_t *)v64;
        }
        else
        {
          uint64_t v65 = (unint64_t *)(*((void *)&v307[0] + 1) + 16 * v64 + 8);
        }
        if (*v65 == v20)
        {
          if (v20 == v19)
          {
            unint64_t v20 = v19;
          }
          else
          {
            unint64_t v8 = *((void *)v14 + 4);
            if (v8 <= v20) {
              goto LABEL_493;
            }
            uint64_t v67 = *((void *)v14 + 5);
            if (*(unsigned char *)(v67 + 16 * v20 + 5) == 1)
            {
              unint64_t v68 = *((void *)v265 + 7 * v20 + 1) / (unint64_t)*(unsigned __int16 *)(v67 + 16 * v20);
              unsigned int v69 = v259;
              if (v259 >= v68) {
                unsigned int v69 = v68;
              }
              unsigned int v259 = v69;
            }
          }
        }
        else
        {
          unint64_t v8 = *((void *)v6 + 43);
          if (v8 <= v20) {
            goto LABEL_489;
          }
          uint64_t v66 = *(const char **)(*((void *)v6 + 44) + 16 * v20 + 8);
          unint64_t v8 = *v65;
          unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)*((void *)v6 + 43);
          if ((unint64_t)v4 <= *v65) {
            goto LABEL_490;
          }
          *(void *)&__dst[0] = *(void *)(*((void *)v6 + 44) + 16 * v8 + 8);
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew<char const*>((uint64_t)v328, (re::DynamicString *)v329, (const char **)__dst);
          if (*(void *)v329 && (v329[8] & 1) != 0) {
            (*(void (**)(void))(**(void **)v329 + 40))();
          }
        }
        unint64_t v276 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)++v20;
      }
      while (v20 < v12);
      unint64_t v70 = 0;
      uint64_t v71 = *((void *)&v307[0] + 1);
      unint64_t v49 = (id *)v260;
      uint64_t v256 = *((void *)&v307[0] + 1);
      while (2)
      {
        unint64_t v8 = *((void *)v14 + 4);
        if (v8 <= v70) {
          goto LABEL_486;
        }
        if (v70 == v263) {
          goto LABEL_487;
        }
        uint64_t v72 = *((void *)v14 + 5);
        unint64_t v20 = (unint64_t)v265 + 56 * v70;
        int v273 = (unsigned __int16 *)(v72 + 16 * v70);
        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)(v273 + 4);
        unint64_t v266 = v70;
        uint64_t v34 = re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::find(v307, *(void *)v20 + *((unsigned int *)v273 + 2));
        unint64_t v74 = v266;
        if (*(void *)(v71 + 16 * v34 + 8) == v266)
        {
          unint64_t v8 = *((void *)v6 + 43);
          if (v8 <= v266) {
            goto LABEL_491;
          }
          uint64_t v75 = 0;
          char v76 = *((unsigned char *)v273 + 5);
          unint64_t v77 = *((void *)v265 + 7 * v266 + 1) / (unint64_t)*v273;
          unint64_t v12 = v77;
          uint64_t v78 = *(unsigned char **)(*((void *)v6 + 44) + 16 * v266 + 8);
          int v270 = (unsigned __int8 *)(v72 + 16 * v266 + 12);
          unsigned int v79 = *v270;
          int v80 = 105;
          while (v78[v75] && v80 == v78[v75])
          {
            int v80 = aIndextriangles[++v75];
            if (v75 == 14)
            {
              if (!v78[14])
              {
                if (v79 == 49) {
                  unsigned int v79 = 49;
                }
                else {
                  unsigned int v79 = 36;
                }
                goto LABEL_222;
              }
              break;
            }
          }
          uint64_t v82 = 0;
          int v83 = 118;
          while (v78[v82] && v83 == v78[v82])
          {
            int v83 = aVertexposition[++v82];
            if (v82 == 14)
            {
              if (!v78[14])
              {
LABEL_215:
                unsigned int v79 = 30;
                goto LABEL_222;
              }
              break;
            }
          }
          uint64_t v85 = 0;
          int v86 = 118;
          while (v78[v85] && v86 == v78[v85])
          {
            int v86 = aVertexnormal[++v85];
            if (v85 == 12)
            {
              if (!v78[12]) {
                goto LABEL_215;
              }
              break;
            }
          }
          uint64_t v88 = 0;
          int v89 = 118;
          while (v78[v88] && v89 == v78[v88])
          {
            int v89 = aVertextangent[++v88];
            if (v88 == 13)
            {
              if (!v78[13]) {
                goto LABEL_215;
              }
              break;
            }
          }
          uint64_t v91 = 0;
          int v92 = 118;
          while (v78[v91] && v92 == v78[v91])
          {
            int v92 = aVertexbitangen[++v91];
            if (v91 == 15)
            {
              if (!v78[15]) {
                goto LABEL_215;
              }
              break;
            }
          }
          uint64_t v94 = 0;
          int v95 = 118;
          while (v78[v94] && v95 == v78[v94])
          {
            int v95 = aVertexcolor[++v94];
            if (v94 == 11)
            {
              if (!v78[11])
              {
                unsigned int v79 = 31;
                goto LABEL_222;
              }
              break;
            }
          }
          uint64_t v97 = 0;
          int v98 = 118;
          while (v78[v97] && v98 == v78[v97])
          {
            int v98 = aVertexuv[++v97];
            if (v97 == 8)
            {
              if (!v78[8])
              {
LABEL_219:
                unsigned int v79 = 29;
                goto LABEL_222;
              }
              break;
            }
          }
          uint64_t v100 = 0;
          int v101 = 118;
          while (v78[v100] && v101 == v78[v100])
          {
            int v101 = aVertexuv1[++v100];
            if (v100 == 9)
            {
              if (!v78[9]) {
                goto LABEL_219;
              }
              break;
            }
          }
          uint64_t v103 = 0;
          int v104 = 118;
          while (v78[v103] && v104 == v78[v103])
          {
            int v104 = aVertexadjacenc[++v103];
            if (v103 == 17)
            {
              if (!v78[17])
              {
                unsigned int v79 = 36;
                goto LABEL_222;
              }
              break;
            }
          }
          uint64_t v106 = 0;
          int v107 = 97;
          while (v78[v106] && v107 == v78[v106])
          {
            int v107 = aAccumulatedver[++v106];
            if (v106 == 24)
            {
              if (!v78[24]) {
                unsigned int v79 = 36;
              }
              break;
            }
          }
LABEL_222:
          unint64_t v109 = (_anonymous_namespace_ *)re::sizeFromVertexFormat(v79, v73);
          unsigned int v110 = v109;
          if (v266 == *((unsigned __int8 *)v6 + 476))
          {
            unsigned int v111 = *((_DWORD *)v6 + 116);
LABEL_224:
            if (v77 >= v111) {
              unint64_t v12 = v111;
            }
            else {
              unint64_t v12 = v77;
            }
          }
          else
          {
            switch(*(unsigned char *)(v72 + 16 * v266 + 5))
            {
              case 0:
              case 2:
                unint64_t v12 = v77 != 0;
                break;
              case 1:
                unsigned int v111 = v259;
                goto LABEL_224;
              case 3:
              case 4:
                unint64_t v12 = 0;
                break;
              default:
                break;
            }
          }
          memset(v301, 0, 32);
          re::DynamicString::setCapacity(v301, 0);
          uint64_t v305 = 0;
          unint64_t v302 = 0;
          uint64_t v303 = 0;
          *(void *)&v301[32] = 0;
          int v304 = 0;
          __int16 v306 = 256;
          unint64_t v19 = *((void *)v6 + 43);
          unint64_t v112 = v266;
          if (v19 <= v266) {
            goto LABEL_492;
          }
          unint64_t v113 = v77 * (unint64_t)v110;
          size_t v114 = strlen(*(const char **)(*((void *)v6 + 44) + 16 * v266 + 8));
          *(void *)&__dst[0] = *(void *)(*((void *)v6 + 44) + 16 * v266 + 8);
          *((void *)&__dst[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v114;
          re::DynamicString::operator=((re::DynamicString *)v301, (uint64_t)__dst);
          LOBYTE(v306) = v79;
          HIBYTE(v306) = v76;
          if (v302 < v113) {
            re::DynamicArray<BOOL>::setCapacity(&v301[32], v113);
          }
          uint64_t v116 = *(void *)v20;
          unint64_t v20 = *(unsigned int *)v4;
          re::sizeFromVertexFormat(*v270, v115);
          if (v12)
          {
            uint64_t v117 = 0;
            unint64_t v118 = 0;
            uint64_t v119 = 0;
            uint64_t v269 = (char *)(v116 + v20);
            uint64_t v120 = v12;
            while (1)
            {
              unint64_t v20 = *v270;
              unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)&v269[v119];
              if (v20 == v79) {
                break;
              }
              if (v79 - 28 < 4)
              {
                uint64_t v125 = VectorSizeForVertexFormat;
                float v127 = 0.0;
                __dst[0] = xmmword_23435FBB0;
                switch((int)v20)
                {
                  case 1:
                  case 2:
                  case 3:
                  case 45:
                    if (v125)
                    {
                      uint64_t v128 = (float *)__dst;
                      do
                      {
                        unsigned int v129 = *(unsigned __int8 *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 1);
                        *v128++ = (float)v129;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 4:
                  case 5:
                  case 6:
                  case 46:
                    if (v125)
                    {
                      uint64_t v131 = (float *)__dst;
                      do
                      {
                        int v132 = *(char *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 1);
                        *v131++ = (float)v132;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 7:
                  case 8:
                  case 9:
                  case 47:
                    if (v125)
                    {
                      int v133 = (float *)__dst;
                      do
                      {
                        unsigned int v134 = *(unsigned __int8 *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 1);
                        *v133++ = (float)v134 * 0.0039216;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 10:
                  case 11:
                  case 12:
                  case 48:
                    if (v125)
                    {
                      long long v135 = (float *)__dst;
                      do
                      {
                        int v136 = *(char *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 1);
                        float v137 = (float)v136 * 0.007874;
                        if (v137 < -1.0) {
                          float v137 = -1.0;
                        }
                        *v135++ = v137;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 13:
                  case 14:
                  case 15:
                  case 49:
                    if (v125)
                    {
                      uint64_t v138 = (float *)__dst;
                      do
                      {
                        unsigned int v139 = *(unsigned __int16 *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 2);
                        *v138++ = (float)v139;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 16:
                  case 17:
                  case 18:
                  case 50:
                    if (v125)
                    {
                      uint64_t v140 = (float *)__dst;
                      do
                      {
                        int v141 = *(__int16 *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 2);
                        *v140++ = (float)v141;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 19:
                  case 20:
                  case 21:
                  case 51:
                    if (v125)
                    {
                      long long v142 = (float *)__dst;
                      do
                      {
                        unsigned int v143 = *(unsigned __int16 *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 2);
                        *v142++ = (float)v143 * 0.000015259;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 22:
                  case 23:
                  case 24:
                  case 52:
                    if (v125)
                    {
                      unint64_t v144 = (float *)__dst;
                      do
                      {
                        int v145 = *(__int16 *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 2);
                        float v146 = (float)v145 * 0.000030519;
                        if (v146 < -1.0) {
                          float v146 = -1.0;
                        }
                        *v144++ = v146;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 25:
                  case 26:
                  case 27:
                  case 53:
                    if (v125)
                    {
                      long long v147 = __dst;
                      do
                      {
                        __int16 v148 = *(_WORD *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 2);
                        _H0 = v148;
                        __asm { FCVT            S0, H0 }
                        *v147++ = _S0;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 28:
                  case 29:
                  case 30:
                  case 31:
                    if (v125)
                    {
                      unint64_t v20 = v126;
                      memcpy(__dst, v4, 4 * v125);
                      uint64_t v126 = v20;
                    }
                    goto LABEL_301;
                  case 32:
                  case 33:
                  case 34:
                  case 35:
                    if (v125)
                    {
                      unint64_t v154 = (float *)__dst;
                      do
                      {
                        int v155 = *(_DWORD *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 4);
                        *v154++ = (float)v155;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 36:
                  case 37:
                  case 38:
                  case 39:
                    if (v125)
                    {
                      unint64_t v156 = (float *)__dst;
                      do
                      {
                        unsigned int v157 = *(_DWORD *)v4;
                        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v4 + 4);
                        *v156++ = (float)v157;
                        --v125;
                      }
                      while (v125);
                    }
                    goto LABEL_301;
                  case 42:
                    if (v125)
                    {
                      for (uint64_t i = 0; i != v125; ++i)
                      {
                        LOBYTE(v127) = *((unsigned char *)v4 + i);
                        float v127 = (float)LODWORD(v127) * 0.0039216;
                        *((float *)__dst + i) = v127;
                      }
                      int v159 = DWORD2(__dst[0]);
                      int v160 = __dst[0];
                    }
                    else
                    {
                      int v160 = 0;
                      int v159 = 0;
                    }
                    DWORD2(__dst[0]) = v160;
                    LODWORD(__dst[0]) = v159;
LABEL_301:
                    size_t v123 = 4 * v126;
                    uint64_t v122 = (char *)__dst;
                    unint64_t v121 = v118;
                    goto LABEL_302;
                  default:
                    goto LABEL_303;
                }
              }
              if (v79 != 36) {
                goto LABEL_303;
              }
              if (v20 == 49)
              {
                int v130 = *(unsigned __int16 *)v4;
LABEL_248:
                LODWORD(__dst[0]) = v130;
                uint64_t v122 = (char *)__dst;
                unint64_t v121 = v118;
                size_t v123 = 4;
LABEL_302:
                re::DynamicArray<REFrameAnalysisBottleneck>::copy(&v301[32], v121, v122, v123);
                goto LABEL_303;
              }
              if (v20 == 45)
              {
                int v130 = *(unsigned __int8 *)v4;
                goto LABEL_248;
              }
LABEL_303:
              v119 += *v273;
              v118 += v110;
              if (++v117 == v120) {
                goto LABEL_304;
              }
            }
            unint64_t v121 = v118;
            uint64_t v122 = &v269[v119];
            size_t v123 = v110;
            goto LABEL_302;
          }
LABEL_304:
          v161.n128_f64[0] = re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)&v309, (uint64_t)v301);
          unint64_t v49 = (id *)v260;
          this = v261;
          unint64_t v12 = (unint64_t)v268;
          uint64_t v71 = v256;
          if (*(void *)&v301[32])
          {
            if (v305) {
              (*(void (**)(double))(**(void **)&v301[32] + 40))(v161.n128_f64[0]);
            }
            uint64_t v305 = 0;
            unint64_t v302 = 0;
            uint64_t v303 = 0;
            *(void *)&v301[32] = 0;
            ++v304;
          }
          uint64_t v34 = *(void *)v301;
          uint64_t v6 = v264;
          if (*(void *)v301 && (v301[8] & 1) != 0) {
            uint64_t v34 = (*(uint64_t (**)(__n128))(**(void **)v301 + 40))(v161);
          }
          unint64_t v74 = v266;
        }
        unint64_t v70 = v74 + 1;
        if (v70 == v12) {
          break;
        }
        continue;
      }
    }
  }
LABEL_315:
  unint64_t v12 = v257;
  if (a4)
  {
    uint64_t v34 = useGPUFormatConversionForAttributeSerialization();
    if ((v34 & v262) == 1)
    {
      memset(__dst, 0, 24);
      *((void *)&__dst[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 14;
      *(void *)&__dst[1] = v162;
      if (v162)
      {
        v162[5] = 0u;
        v162[6] = 0u;
        v162[3] = 0u;
        v162[4] = 0u;
        v162[1] = 0u;
        v162[2] = 0u;
        *unint64_t v162 = 0u;
        re::GPUAttributeFormatConverter::convertAttributes((uint64_t)__dst, v49, v6, (_anonymous_namespace_ *)&v309);
        if (*(void *)&__dst[0] && *((void *)&__dst[0] + 1))
        {
          unint64_t v164 = *(id **)&__dst[1];
          uint64_t v165 = 8 * *((void *)&__dst[0] + 1);
          do
          {
            if (*v164)
            {

              *unint64_t v164 = 0;
            }
            ++v164;
            v165 -= 8;
          }
          while (v165);
          uint64_t v34 = (*(uint64_t (**)(void, void))(**(void **)&__dst[0] + 40))(*(void *)&__dst[0], *(void *)&__dst[1]);
        }
        goto LABEL_325;
      }
LABEL_499:
      re::internal::assertLog((re::internal *)4, v163, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
  }
LABEL_325:
  unint64_t v19 = *((unsigned int *)v6 + 116);
  char v166 = *((unsigned char *)v6 + 472);
  if (*((unsigned char *)v6 + 536) == 4 && v257 != 255)
  {
    unint64_t v20 = *((unsigned __int8 *)v6 + 476);
    if (v20 != 255)
    {
      memset(v301, 0, 32);
      re::DynamicString::setCapacity(v301, 0);
      uint64_t v305 = 0;
      uint64_t v303 = 0;
      *(void *)&v301[32] = 0;
      unint64_t v302 = 0;
      int v304 = 0;
      __int16 v306 = 256;
      *(void *)&__dst[0] = "indexTriangles";
      *((void *)&__dst[0] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 14;
      re::DynamicString::operator=((re::DynamicString *)v301, (uint64_t)__dst);
      HIBYTE(v306) = 0;
      unsigned int v167 = HIWORD(v259);
      if (HIWORD(v259)) {
        char v168 = 36;
      }
      else {
        char v168 = 49;
      }
      LOBYTE(v306) = v168;
      unint64_t v8 = *((void *)&v310 + 1);
      unint64_t v19 = v20;
      if (*((void *)&v310 + 1) > v20)
      {
        unint64_t v4 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)&v301[32];
        uint64_t v169 = v312 + 80 * v20;
        uint64_t v170 = *(void *)(v169 + 64);
        unint64_t v171 = *(void *)(v169 + 48);
        int v172 = *((unsigned __int8 *)v6 + 472);
        uint64_t v303 = 0;
        ++v304;
        __int16 v271 = (void *)v20;
        if (v172)
        {
          unint64_t v173 = v171 >> 2;
          if (v167)
          {
            if (v171 >= 0xC)
            {
              char v174 = 0;
              unint64_t v19 = 0;
              unint64_t v12 = 2;
              do
              {
                unint64_t v175 = (int *)(v170 + 4 * v12);
                int v176 = *(v175 - 1);
                int v177 = *v175;
                if (*(v175 - 2) == -1 || v176 == -1 || v177 == -1)
                {
                  char v174 = 0;
                }
                else
                {
                  uint64_t v180 = 0;
                  LODWORD(__dst[0]) = *(v175 - 2);
                  do
                  {
                    v329[0] = *((unsigned char *)__dst + v180);
                    re::DynamicArray<unsigned char>::add(&v301[32], v329);
                    ++v180;
                  }
                  while (v180 != 4);
                  uint64_t v181 = 0;
                  if (v174) {
                    int v182 = v177;
                  }
                  else {
                    int v182 = v176;
                  }
                  LODWORD(__dst[0]) = v182;
                  do
                  {
                    v329[0] = *((unsigned char *)__dst + v181);
                    re::DynamicArray<unsigned char>::add(&v301[32], v329);
                    ++v181;
                  }
                  while (v181 != 4);
                  uint64_t v183 = 0;
                  if (v174) {
                    int v184 = v176;
                  }
                  else {
                    int v184 = v177;
                  }
                  LODWORD(__dst[0]) = v184;
                  do
                  {
                    v329[0] = *((unsigned char *)__dst + v183);
                    re::DynamicArray<unsigned char>::add(&v301[32], v329);
                    ++v183;
                  }
                  while (v183 != 4);
                  unint64_t v19 = (v19 + 3);
                  v174 ^= 1u;
                }
                ++v12;
              }
              while (v12 != v173);
              goto LABEL_436;
            }
LABEL_435:
            unint64_t v19 = 0;
            goto LABEL_436;
          }
          if (v171 < 0xC) {
            goto LABEL_435;
          }
          char v197 = 0;
          unint64_t v19 = 0;
          unint64_t v12 = 2;
          do
          {
            int v198 = (int *)(v170 + 4 * v12);
            int v199 = *(v198 - 1);
            int v200 = *v198;
            if (*(v198 - 2) == -1 || v199 == -1 || v200 == -1)
            {
              char v197 = 0;
            }
            else
            {
              uint64_t v203 = 0;
              LOWORD(__dst[0]) = *(v198 - 2);
              do
              {
                v329[0] = *((unsigned char *)__dst + v203);
                re::DynamicArray<unsigned char>::add(&v301[32], v329);
                ++v203;
              }
              while (v203 != 2);
              uint64_t v204 = 0;
              if (v197) {
                __int16 v205 = v200;
              }
              else {
                __int16 v205 = v199;
              }
              LOWORD(__dst[0]) = v205;
              do
              {
                v329[0] = *((unsigned char *)__dst + v204);
                re::DynamicArray<unsigned char>::add(&v301[32], v329);
                ++v204;
              }
              while (v204 != 2);
              uint64_t v206 = 0;
              if (v197) {
                __int16 v207 = v199;
              }
              else {
                __int16 v207 = v200;
              }
              LOWORD(__dst[0]) = v207;
              do
              {
                v329[0] = *((unsigned char *)__dst + v206);
                re::DynamicArray<unsigned char>::add(&v301[32], v329);
                ++v206;
              }
              while (v206 != 2);
              unint64_t v19 = (v19 + 3);
              v197 ^= 1u;
            }
            ++v12;
          }
          while (v12 != v173);
        }
        else
        {
          unint64_t v185 = v171 >> 1;
          unint64_t v274 = v171 >> 1;
          if (v167)
          {
            if (v171 < 6) {
              goto LABEL_435;
            }
            char v186 = 0;
            unint64_t v19 = 0;
            unint64_t v12 = 2;
            do
            {
              long long v187 = (unsigned __int16 *)(v170 + 2 * v12);
              int v188 = *(v187 - 1);
              int v189 = *v187;
              if (*(v187 - 2) == 0xFFFF || v188 == 0xFFFF || v189 == 0xFFFF)
              {
                char v186 = 0;
              }
              else
              {
                uint64_t v192 = 0;
                LODWORD(__dst[0]) = *(v187 - 2);
                do
                {
                  v329[0] = *((unsigned char *)__dst + v192);
                  re::DynamicArray<unsigned char>::add(&v301[32], v329);
                  ++v192;
                }
                while (v192 != 4);
                uint64_t v193 = 0;
                if (v186) {
                  int v194 = v189;
                }
                else {
                  int v194 = v188;
                }
                LODWORD(__dst[0]) = v194;
                do
                {
                  v329[0] = *((unsigned char *)__dst + v193);
                  re::DynamicArray<unsigned char>::add(&v301[32], v329);
                  ++v193;
                }
                while (v193 != 4);
                uint64_t v195 = 0;
                if (v186) {
                  int v196 = v188;
                }
                else {
                  int v196 = v189;
                }
                LODWORD(__dst[0]) = v196;
                do
                {
                  v329[0] = *((unsigned char *)__dst + v195);
                  re::DynamicArray<unsigned char>::add(&v301[32], v329);
                  ++v195;
                }
                while (v195 != 4);
                unint64_t v19 = (v19 + 3);
                v186 ^= 1u;
                unint64_t v185 = v274;
              }
              ++v12;
            }
            while (v12 != v185);
          }
          else
          {
            if (v171 < 6) {
              goto LABEL_435;
            }
            char v208 = 0;
            unint64_t v19 = 0;
            unint64_t v12 = 2;
            do
            {
              long long v209 = (unsigned __int16 *)(v170 + 2 * v12);
              int v210 = *(v209 - 1);
              int v211 = *v209;
              if (*(v209 - 2) == 0xFFFF || v210 == 0xFFFF || v211 == 0xFFFF)
              {
                char v208 = 0;
              }
              else
              {
                uint64_t v214 = 0;
                LOWORD(__dst[0]) = *(v209 - 2);
                do
                {
                  v329[0] = *((unsigned char *)__dst + v214);
                  re::DynamicArray<unsigned char>::add(&v301[32], v329);
                  ++v214;
                }
                while (v214 != 2);
                uint64_t v215 = 0;
                if (v208) {
                  __int16 v216 = v211;
                }
                else {
                  __int16 v216 = v210;
                }
                LOWORD(__dst[0]) = v216;
                do
                {
                  v329[0] = *((unsigned char *)__dst + v215);
                  re::DynamicArray<unsigned char>::add(&v301[32], v329);
                  ++v215;
                }
                while (v215 != 2);
                uint64_t v217 = 0;
                if (v208) {
                  __int16 v218 = v210;
                }
                else {
                  __int16 v218 = v211;
                }
                LOWORD(__dst[0]) = v218;
                do
                {
                  v329[0] = *((unsigned char *)__dst + v217);
                  re::DynamicArray<unsigned char>::add(&v301[32], v329);
                  ++v217;
                }
                while (v217 != 2);
                unint64_t v19 = (v19 + 3);
                v208 ^= 1u;
                unint64_t v185 = v274;
              }
              ++v12;
            }
            while (v12 != v185);
          }
        }
LABEL_436:
        unint64_t v8 = *((void *)&v310 + 1);
        unint64_t v20 = (unint64_t)v271;
        if (*((void *)&v310 + 1) > (unint64_t)v271)
        {
          unsigned int v219 = (re::DynamicString *)(v312 + 80 * v271);
          re::DynamicString::operator=(v219, (re::DynamicString *)v301);
          re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)v219 + 32, (uint64_t)&v301[32]);
          *((_WORD *)v219 + 36) = v306;
          this = v261;
          uint64_t v6 = v264;
          unint64_t v12 = v257;
          char v166 = HIWORD(v259) != 0;
          if (*(void *)&v301[32])
          {
            if (v305) {
              (*(void (**)(void))(**(void **)&v301[32] + 40))();
            }
            uint64_t v305 = 0;
            unint64_t v302 = 0;
            uint64_t v303 = 0;
            *(void *)&v301[32] = 0;
            ++v304;
          }
          uint64_t v34 = *(void *)v301;
          if (*(void *)v301 && (v301[8] & 1) != 0) {
            uint64_t v34 = (*(uint64_t (**)(void))(**(void **)v301 + 40))();
          }
          goto LABEL_444;
        }
LABEL_495:
        unint64_t v281 = 0;
        memset(v283, 0, sizeof(v283));
        memset(__dst, 0, sizeof(__dst));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v329 = 136315906;
        *(void *)&v329[4] = "operator[]";
        LOWORD(v330) = 1024;
        *(_DWORD *)((char *)&v330 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 789;
        WORD3(v330) = 2048;
        *((void *)&v330 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v20;
        __int16 v331 = 2048;
        unint64_t v332 = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_496:
        *(void *)unint64_t v329 = 0;
        memset(v283, 0, sizeof(v283));
        memset(__dst, 0, sizeof(__dst));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int8x16_t v301 = 136315906;
        *(void *)&v301[4] = "operator[]";
        *(_WORD *)&v301[12] = 1024;
        *(_DWORD *)&v301[14] = 789;
        *(_WORD *)&v301[18] = 2048;
        *(void *)&v301[20] = v12;
        *(_WORD *)&v301[28] = 2048;
        *(void *)&v301[30] = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_497:
        *(void *)unint64_t v329 = 0;
        memset(v283, 0, sizeof(v283));
        memset(__dst, 0, sizeof(__dst));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int8x16_t v301 = 136315906;
        *(void *)&v301[4] = "operator[]";
        *(_WORD *)&v301[12] = 1024;
        *(_DWORD *)&v301[14] = 789;
        *(_WORD *)&v301[18] = 2048;
        *(void *)&v301[20] = v19;
        *(_WORD *)&v301[28] = 2048;
        *(void *)&v301[30] = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_498;
      }
LABEL_494:
      unint64_t v281 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v329 = 136315906;
      *(void *)&v329[4] = "operator[]";
      LOWORD(v330) = 1024;
      *(_DWORD *)((char *)&v330 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 789;
      WORD3(v330) = 2048;
      *((void *)&v330 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v19;
      __int16 v331 = 2048;
      unint64_t v332 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_495;
    }
  }
LABEL_444:
  if (v12 == 255) {
    goto LABEL_456;
  }
  unint64_t v8 = *((void *)&v310 + 1);
  if (*((void *)&v310 + 1) <= v12) {
    goto LABEL_496;
  }
  uint64_t v220 = v312;
  if (*(unsigned char *)(v312 + 80 * v12 + 72) != 30)
  {
LABEL_456:
    *(_DWORD *)long long v313 = v19;
    v313[4] = v166;
    int v230 = *((_DWORD *)v6 + 135);
    *(_DWORD *)&v313[8] = v259;
    *(_DWORD *)&v313[12] = v230;
    *(_WORD *)&v313[16] = *((_WORD *)v6 + 237);
    *(void *)&v313[20] = *((void *)v6 + 66);
    re::StringID::operator=(&v314, (uint64_t *)v6 + 63);
    long long v231 = *((_OWORD *)v6 + 28);
    int32x4_t v316 = *((int32x4_t *)v6 + 27);
    long long v317 = v231;
    unsigned int v232 = *((_DWORD *)v6 + 136);
    char v233 = v232 & 1;
    if (!v322) {
      char v322 = 1;
    }
    char v323 = v232 & 1;
    int v234 = (v232 >> 1) & 1;
    if (!v324) {
      char v324 = 1;
    }
    BOOL v325 = (v232 & 2) != 0;
    if (!v326) {
      char v326 = 1;
    }
    int v235 = (v232 >> 17) & 3;
    char v327 = (v232 >> 17) & 3;
    uint64_t v236 = v309;
    uint64_t v309 = 0;
    ++v311;
    *(_OWORD *)((char *)v283 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_OWORD *)v313;
    *(_OWORD *)((char *)&v283[1] + 4) = *(_OWORD *)&v313[12];
    uint64_t v237 = v312;
    unint64_t v238 = v314;
    uint64_t v239 = v315;
    uint64_t v240 = *(void *)&v328[16];
    uint64_t v315 = "";
    uint64_t v312 = 0;
    unint64_t v314 = 0;
    int32x4_t v285 = v316;
    long long v286 = v317;
    long long v241 = v319;
    long long v289 = v320;
    long long v242 = v320;
    long long v290 = v321;
    int32x4_t v243 = v316;
    long long v244 = v317;
    long long v287 = v318;
    long long v245 = v318;
    long long v288 = v319;
    char v292 = v233;
    char v291 = 1;
    char v293 = 1;
    char v294 = v234;
    char v295 = 1;
    char v296 = v235;
    int v300 = 0;
    *(void *)&v328[16] = 0;
    *(unsigned char *)this = 1;
    *((void *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v236;
    *(void *)&__dst[0] = 0;
    *(_OWORD *)((char *)this + 24) = v310;
    *(_OWORD *)((char *)this + 6re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_OWORD *)&v313[12];
    *(_OWORD *)((char *)this + 56) = *(_OWORD *)v313;
    long long v310 = 0u;
    *(_OWORD *)((char *)__dst + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0u;
    *((void *)this + 6) = v237;
    *(void *)&v283[0] = 0;
    DWORD2(__dst[1]) = 2;
    *((_DWORD *)this + 10) = 1;
    *((void *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v238;
    *((void *)this + 1re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v239;
    *((void *)&v283[2] + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    int v284 = "";
    *((int32x4_t *)this + 7) = v243;
    *((_OWORD *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v244;
    long long v246 = v321;
    *((_OWORD *)this + 1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v242;
    *((_OWORD *)this + 1re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v246;
    *((_OWORD *)this + 9) = v245;
    *((_OWORD *)this + 10) = v241;
    *((unsigned char *)this + 20re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 1;
    *((unsigned char *)this + 209) = v292;
    *((unsigned char *)this + 210) = 1;
    *((unsigned char *)this + 21re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v294;
    *((unsigned char *)this + 21re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 1;
    *((unsigned char *)this + 21re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v296;
    *((_DWORD *)this + 64) = 0;
    long long v247 = *(_OWORD *)v328;
    *(_OWORD *)unsigned int v328 = 0u;
    *(_OWORD *)((char *)this + 216) = v247;
    long long v297 = 0u;
    *((void *)this + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 29) = v240;
    uint64_t v298 = 0;
    long long v248 = *(_OWORD *)&v328[24];
    *(_OWORD *)&v328[24] = xmmword_23436F740;
    *((_OWORD *)this + 15) = v248;
    long long v299 = xmmword_23436F740;
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v297);
    re::StringID::destroyString((re::StringID *)((char *)&v283[2] + 8));
    re::DynamicArray<re::MeshAssetBuffer>::deinit((uint64_t)__dst);
    goto LABEL_463;
  }
  if (*(void *)(v312 + 80 * v12 + 48) >= (unint64_t)(12 * v259))
  {
    *(void *)&v301[32] = 0;
    memset(v301, 0, 28);
    re::DynamicArray<re::Vector3<float>>::resize((uint64_t)v301, v259);
    if (v259)
    {
      unint64_t v20 = 0;
      uint64_t v224 = *(void *)(v220 + 80 * v12 + 64);
      uint64_t v225 = v224 + 12 * v259;
      while (1)
      {
        unint64_t v8 = *(void *)&v301[16];
        if (*(void *)&v301[16] <= v20) {
          break;
        }
        *(void *)&long long v223 = *(void *)v224;
        DWORD2(v22re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(_DWORD *)(v224 + 8);
        *(_OWORD *)(*(void *)&v301[32] + 16 * v20++) = v223;
        v224 += 12;
        if (v224 == v225) {
          goto LABEL_453;
        }
      }
LABEL_488:
      unint64_t v281 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v329 = 136315906;
      *(void *)&v329[4] = "operator[]";
      LOWORD(v330) = 1024;
      *(_DWORD *)((char *)&v330 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 789;
      WORD3(v330) = 2048;
      *((void *)&v330 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v20;
      __int16 v331 = 2048;
      unint64_t v332 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_489:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v20;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_490:
      unint64_t v281 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v8;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_491:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      unint64_t v19 = v74;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v19;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_492:
      unint64_t v281 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      unint64_t v8 = v112;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unint64_t v329 = 136315906;
      *(void *)&v329[4] = "operator[]";
      LOWORD(v330) = 1024;
      *(_DWORD *)((char *)&v330 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 476;
      WORD3(v330) = 2048;
      *((void *)&v330 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v8;
      __int16 v331 = 2048;
      unint64_t v332 = v19;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_493:
      *(void *)unint64_t v329 = 0;
      memset(v283, 0, sizeof(v283));
      memset(__dst, 0, sizeof(__dst));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int8x16_t v301 = 136315906;
      *(void *)&v301[4] = "operator[]";
      *(_WORD *)&v301[12] = 1024;
      *(_DWORD *)&v301[14] = 476;
      *(_WORD *)&v301[18] = 2048;
      *(void *)&v301[20] = v20;
      *(_WORD *)&v301[28] = 2048;
      *(void *)&v301[30] = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_494;
    }
LABEL_453:
    *(double *)&long long v226 = MEMORY[0x237DBD720](*(void *)&v301[16], *(void *)&v301[32]);
    long long v318 = v226;
    long long v319 = v227;
    long long v320 = v228;
    long long v321 = v229;
    if (*(void *)v301 && *(void *)&v301[32]) {
      (*(void (**)(void))(**(void **)v301 + 40))();
    }
    goto LABEL_456;
  }
  long long v221 = __dst[0];
  long long v222 = __dst[1];
  *(unsigned char *)this = 0;
  *((void *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 100;
  *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = re::AssetErrorCategory(void)::instance;
  *((_OWORD *)this + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v221;
  *((_OWORD *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v222;
LABEL_463:
  if (*((void *)&v308 + 1) && *(void *)&v307[0]) {
    (*(void (**)(void))(**((void **)&v308 + 1) + 40))();
  }
LABEL_466:
  uint64_t v249 = v277[0];
  if (v277[0])
  {
    unint64_t v250 = v280;
    if (v280)
    {
      if (v278)
      {
        uint64_t v251 = 56 * v278;
        int v252 = v280;
        do
        {
          re::ReadOnlyCPUAccessibleBufferSliceContent::~ReadOnlyCPUAccessibleBufferSliceContent(v252);
          int v252 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)(v253 + 56);
          v251 -= 56;
        }
        while (v251);
      }
      (*(void (**)(uint64_t, re::ReadOnlyCPUAccessibleBufferSliceContent *))(*(void *)v249 + 40))(v249, v250);
    }
  }
  id v15 = v258;
LABEL_473:

  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v328);
  re::StringID::destroyString((re::StringID *)&v314);
  return re::DynamicArray<re::MeshAssetBuffer>::deinit((uint64_t)&v309);
}

uint64_t *re::DynamicArray<re::MeshAssetPart>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::MeshAssetPart>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4);
  uint64_t v6 = v5 + (v4 << 8);
  *(void *)(v6 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(v6 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(v6 + 16) = 0;
  *(void *)uint64_t v6 = 0;
  *(_DWORD *)(v6 + 24) = 0;
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)uint64_t v6 = *(void *)a2;
  *(void *)(v6 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v7;
  *(void *)a2 = 0;
  *(void *)(a2 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  uint64_t v8 = *(void *)(v6 + 16);
  *(void *)(v6 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v8;
  uint64_t v9 = *(void *)(v6 + 32);
  *(void *)(v6 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v9;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v6 + 24);
  long long v10 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(v6 + 5re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(_OWORD *)(a2 + 52);
  *(_OWORD *)(v6 + 40) = v10;
  uint64_t v11 = *(void *)(a2 + 72);
  *(void *)(v6 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(void *)(v6 + 72) & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
  *(void *)(v6 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(void *)(a2 + 72) & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
  *(void *)(v6 + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  *(void *)(a2 + 80) = "";
  long long v12 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v6 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(v6 + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v12;
  long long v13 = *(_OWORD *)(a2 + 128);
  long long v14 = *(_OWORD *)(a2 + 144);
  long long v15 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(v6 + 160) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(v6 + 176) = v15;
  *(_OWORD *)(v6 + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v13;
  *(_OWORD *)(v6 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = v14;
  LODWORD(v1re::ResourceSharingManager::~ResourceSharingManager(this - 1) = *(unsigned __int8 *)(a2 + 192);
  *(unsigned char *)(v6 + 19re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v11;
  if (v11) {
    *(unsigned char *)(v6 + 19re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = *(unsigned char *)(a2 + 193);
  }
  int v16 = *(unsigned __int8 *)(a2 + 194);
  *(unsigned char *)(v6 + 194) = v16;
  if (v16) {
    *(unsigned char *)(v5 + (v4 << 8) + 195) = *(unsigned char *)(a2 + 195);
  }
  uint64_t v17 = v5 + (v4 << 8);
  int v18 = *(unsigned __int8 *)(a2 + 196);
  *(unsigned char *)(v17 + 196) = v18;
  if (v18) {
    *(unsigned char *)(v17 + 197) = *(unsigned char *)(a2 + 197);
  }
  *(_OWORD *)(v17 + 200) = 0u;
  uint64_t v19 = v17 + 200;
  *(_DWORD *)(v19 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(_OWORD *)(v19 + 16) = 0u;
  *(void *)(v19 + 36) = 0x7FFFFFFFLL;
  uint64_t result = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v19, (uint64_t *)(a2 + 200));
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::DynamicArray<re::MeshLodLevelInfo>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::MeshLodLevelInfo>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2)
    {
      uint64_t v5 = (void *)(*(void *)(a1 + 32) + 12 * v4);
      uint64_t v6 = 12 * a2 - 12 * v4;
      if (v6 >= 1) {
        bzero(v5, 12 * (v6 / 0xCuLL - ((unint64_t)v6 > 0xB)) + 12);
      }
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void **re::DynamicArray<re::MeshLodLevelInfo>::copy(void **this, char *__src, unint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = this;
    unint64_t v4 = (unint64_t)this[2];
    if (v4 == -1)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v4 >= a3)
    {
      this = (void **)memmove(this[4], __src, 12 * a3);
    }
    else
    {
      re::DynamicArray<re::MeshLodLevelInfo>::growCapacity(this, a3);
      uint64_t v7 = v3[2];
      uint64_t v8 = &__src[12 * (void)v7];
      if (v7)
      {
        memmove(v3[4], __src, 12 * (void)v7);
        uint64_t v7 = v3[2];
      }
      this = (void **)memcpy((char *)v3[4] + 12 * (void)v7, v8, &__src[12 * a3] - v8);
      v3[2] = (void *)a3;
    }
    ++*((_DWORD *)v3 + 6);
  }
  return this;
}

void *re::DynamicArray<re::MeshLodLevelInfo>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::MeshLodLevelInfo>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::MeshLodLevelInfo>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void re::DynamicArray<re::ReadOnlyCPUAccessibleBufferSliceContent>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 56 * a2;
    unint64_t v9 = a2;
    do
    {
      re::ReadOnlyCPUAccessibleBufferSliceContent::~ReadOnlyCPUAccessibleBufferSliceContent((re::ReadOnlyCPUAccessibleBufferSliceContent *)(*(void *)(a1 + 32) + v8));
      ++v9;
      v8 += 56;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::ReadOnlyCPUAccessibleBufferSliceContent>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 56 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)(v7 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
        *(_OWORD *)(v7 + 16) = 0uLL;
        *(_OWORD *)(v7 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0uLL;
        *(_OWORD *)uint64_t v7 = 0uLL;
        v6 += 56;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

uint64_t *re::ReadOnlyCPUAccessibleBufferSliceContent::operator=(uint64_t *a1, uint64_t *a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    *a1 = *a2;
    *a2 = v4;
    uint64_t v5 = a1[1];
    a1[1] = a2[1];
    a2[1] = v5;
    uint64_t v6 = (void **)(a2 + 2);
    v11[0] = (id)a1[2];
    a1[2] = 0;
    NS::SharedPtr<MTL::Texture>::operator=((void **)a1 + 2, (void **)a2 + 2);
    NS::SharedPtr<MTL::Texture>::operator=(v6, v11);
    if (v11[0]) {

    }
    uint64_t v7 = a1[3];
    a1[3] = a2[3];
    a2[3] = v7;
    uint64_t v8 = a2 + 4;
    *(_OWORD *)uint64_t v11 = *((_OWORD *)a1 + 2);
    a1[4] = 0;
    a1[5] = 0;
    uint64_t v9 = a1[6];
    a1[6] = 0;
    uint64_t v12 = v9;
    re::FixedArray<float>::operator=(a1 + 4, v8);
    re::FixedArray<float>::operator=(v8, (uint64_t *)v11);
    if (v11[0] && v11[1]) {
      (*(void (**)(void))(*(void *)v11[0] + 40))();
    }
  }
  return a1;
}

uint64_t re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::addNew(uint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v6 = re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::find(a1, *a2);
  if (v6 != -1) {
    return a1[1] + 16 * v6 + 8;
  }
  if (!a1[7])
  {
  }
  uint64_t v9 = a1[4];
  if (!v9 || (unint64_t v10 = a1[2], v10 > 8 * v9))
  {
    re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::resize(a1);
    unint64_t v10 = a1[2];
  }
  unint64_t v11 = 0xBF58476D1CE4E5B9;
  unint64_t v12 = 0x94D049BB133111EBLL;
  unint64_t v13 = 0xBF58476D1CE4E5B9 * (*a2 ^ (*a2 >> 30));
  unint64_t v14 = (0x94D049BB133111EBLL * (v13 ^ (v13 >> 27))) ^ ((0x94D049BB133111EBLL * (v13 ^ (v13 >> 27))) >> 31);
  unint64_t v15 = v10 >> 4;
  uint64_t v16 = *a1;
  unint64_t v17 = v14 % v15;
  while (1)
  {
    unint64_t v18 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v16 + 16 * v17)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
    if (v18 < 0x40) {
      break;
    }
    if (v17 + 1 == v15) {
      unint64_t v17 = 0;
    }
    else {
      ++v17;
    }
    if (v17 == v14 % v15)
    {
      re::internal::assertLog((re::internal *)4, v7, -1.79399301e-307, 4.74803907e-38, "assertion failure: '%s' (%s:line %i) Unexpected full hash-table", "blockIndex != h1(key) % blockCount()", "internalAdd", 656);
      _os_crash();
      __break(1u);
      break;
    }
  }
  unint64_t v19 = v16 + 16 * v17;
  BOOL v20 = *(unsigned __int8 *)(v19 + v18) == 255;
  *(unsigned char *)(v19 + v1re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v14 & 0x7F;
  unint64_t v21 = v18 + 16 * v17;
  unint64_t v22 = *a3;
  unint64_t v23 = (unint64_t *)(a1[1] + 16 * v21);
  *unint64_t v23 = *a2;
  v23[1] = v22;
  uint64_t v24 = a1[4] - v20;
  ++a1[3];
  a1[4] = v24;
  int v25 = (unint64_t *)(a1[1] + 16 * v21);
  unint64_t v26 = *v25;
  uint64_t result = (uint64_t)(v25 + 1);
  unint64_t v27 = (((v26 ^ (v26 >> 30)) * v11) ^ (((v26 ^ (v26 >> 30)) * v11) >> 27)) * v12;
  a1[5] ^= (v27 >> 31) ^ v27;
  return result;
}

uint64_t useGPUFormatConversionForAttributeSerialization(void)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF77040, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF77040))
  {
    re::Defaults::BOOLValue((re::Defaults *)"MeshAsset.GPUFormatConversion", v1, v3);
    if (v3[0]) {
      char v2 = v3[1];
    }
    else {
      char v2 = 1;
    }
    byte_26AF77021 = v2;
    __cxa_guard_release(&qword_26AF77040);
  }
  return byte_26AF77021;
}

uint64_t re::sizeFromVertexFormat(unsigned int a1, uint64_t a2)
{
  char v2 = a1 - 1;
  if (a1 - 1 < 0x35 && ((0x1FF27FFFFFFFFFuLL >> v2) & 1) != 0) {
    return byte_234373150[v2];
  }
  re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Wrong VertexFormat (%02hhx)", "!\"Unreachable code\"", "sizeFromVertexFormat", 301, a1);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

double re::DynamicArray<re::MeshAssetBuffer>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::MeshAssetBuffer>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 80 * v4;
  double result = 0.0;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(void *)(v5 + 24) = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)uint64_t v5 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v8 = *(void *)(a2 + 16);
  *(void *)(a2 + 24) = 0;
  uint64_t v10 = *(void *)(v5 + 8);
  uint64_t v9 = *(void *)(v5 + 16);
  *(void *)(v5 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v7;
  *(void *)(v5 + 16) = v8;
  *(void *)(a2 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v10;
  *(void *)(a2 + 16) = v9;
  *(void *)(v5 + 64) = 0;
  *(_DWORD *)(v5 + 56) = 0;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  uint64_t v11 = *(void *)(a2 + 40);
  *(void *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = *(void *)(a2 + 32);
  *(void *)(v5 + 40) = v11;
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v12 = *(void *)(v5 + 48);
  *(void *)(v5 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(void *)(a2 + 48);
  *(void *)(a2 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v12;
  uint64_t v13 = *(void *)(v5 + 64);
  *(void *)(v5 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v13;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(v5 + 56);
  *(_WORD *)(v5 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(_WORD *)(a2 + 72);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::ReadOnlyCPUAccessibleBufferSliceContent>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<re::ReadOnlyCPUAccessibleBufferSliceContent>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x38uLL))
        {
          uint64_t v2 = 56 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 56 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element int64_t size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 56, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        void v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 56 * v9;
        uint64_t v11 = v7;
        do
        {
          re::ReadOnlyCPUAccessibleBufferSliceContent::ReadOnlyCPUAccessibleBufferSliceContent(v11, (uint64_t)v8);
          re::ReadOnlyCPUAccessibleBufferSliceContent::~ReadOnlyCPUAccessibleBufferSliceContent(v8);
          uint64_t v8 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)((char *)v8 + 56);
          v11 += 7;
          v10 -= 56;
        }
        while (v10);
        uint64_t v8 = (re::ReadOnlyCPUAccessibleBufferSliceContent *)v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, re::ReadOnlyCPUAccessibleBufferSliceContent *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void *re::ReadOnlyCPUAccessibleBufferSliceContent::ReadOnlyCPUAccessibleBufferSliceContent(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  a1[1] = *(void *)(a2 + 8);
  a1[2] = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  a1[3] = *(void *)(a2 + 24);
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  unint64_t v4 = (uint64_t *)(a2 + 32);
  a1[4] = *(void *)(a2 + 32);
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  a1[5] = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  uint64_t v5 = a1[6];
  a1[6] = *(void *)(a2 + 48);
  *(void *)(a2 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v5;
  *(void *)a2 = 0;
  *(void *)(a2 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  id v7 = 0;
  NS::SharedPtr<MTL::Texture>::operator=((void **)(a2 + 16), &v7);
  if (v7) {

  }
  *(void *)(a2 + 24) = 0;
  id v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  re::FixedArray<float>::operator=(v4, (uint64_t *)&v7);
  if (v7 && v8) {
    (*(void (**)(void))(*(void *)v7 + 40))();
  }
  return a1;
}

void re::ReadOnlyCPUAccessibleBufferSliceContent::~ReadOnlyCPUAccessibleBufferSliceContent(re::ReadOnlyCPUAccessibleBufferSliceContent *this)
{
  id v5 = 0;
  uint64_t v2 = (void *)((char *)this + 16);
  NS::SharedPtr<MTL::Texture>::operator=((void **)this + 2, &v5);
  if (v5) {

  }
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4);
  uint64_t v3 = (__IOSurface *)*((void *)this + 3);
  if (v3)
  {
    IOSurfaceUnlock(v3, 1u, 0);
    CFRelease(*((CFTypeRef *)this + 3));
    *((void *)this + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = 0;
  }
  *(void *)this = 0;
  *((void *)this + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 4);
  unint64_t v4 = (void *)*((void *)this + 2);
  if (v4)
  {

    *uint64_t v2 = 0;
  }
}

uint64_t re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::find(void *a1, unint64_t a2)
{
  if (!a1[7]) {
    return -1;
  }
  unint64_t v2 = a1[2];
  if (v2 < 0x10 || !a1[3]) {
    return -1;
  }
  unint64_t v3 = v2 >> 4;
  unint64_t v4 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  unint64_t v5 = v4 ^ (v4 >> 31);
  unint64_t v6 = v5 % v3;
  int8x16_t v7 = vdupq_n_s8(v5 & 0x7F);
  v8.i64[0] = -1;
  v8.i64[1] = -1;
  unint64_t v9 = v5 % v3;
  while (1)
  {
    int8x16_t v10 = *(int8x16_t *)(*a1 + 16 * v9);
    unint64_t v11 = (unint64_t)vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v7, v10), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    unint64_t v12 = __clz(__rbit64(v11));
    if (v12 <= 0x3F) {
      break;
    }
LABEL_10:
    if (vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v10, v8), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800))
    {
      return -1;
    }
    if (v9 + 1 == v3) {
      unint64_t v9 = 0;
    }
    else {
      ++v9;
    }
    uint64_t v14 = -1;
    if (v9 == v6) {
      return v14;
    }
  }
  uint64_t v13 = 16 * v9;
  while (1)
  {
    uint64_t v14 = v12 + v13;
    if (*(void *)(a1[1] + 16 * (v12 + v13)) == a2) {
      return v14;
    }
    if (v12 <= 0x3E)
    {
      unint64_t v12 = __clz(__rbit64((-2 << v12) & v11));
      if (v12 < 0x40) {
        continue;
      }
    }
    goto LABEL_10;
  }
}

uint64_t re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::resize(uint64_t *a1)
{
  unint64_t v3 = a1[2];
  uint64_t v2 = a1[3];
  unint64_t v4 = (((unint64_t)(151 * (v2 + 1)) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  unint64_t v5 = ((3 * v3) >> 1) & 0x1FFFFFFFFFFFFFFLL;
  if (v4 > (192 * v3) >> 7) {
    unint64_t v5 = (((unint64_t)(151 * (v2 + 1)) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  }
  unint64_t v6 = (v5 << 7) / 0x97;
  uint64_t v7 = a1[7];
  long long v50 = 0u;
  *(_OWORD *)uint64_t v51 = 0u;
  if (v4 <= v3) {
    uint64_t v8 = v2 + 1;
  }
  else {
    uint64_t v8 = v6;
  }
  memset(&v51[16], 0, 32);
  unint64_t v9 = (_anonymous_namespace_ *)re::HashBrown<re::ecs2::Scene const*,unsigned long,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,void,false>::init(&v50, v7, v8);
  unint64_t v10 = a1[2];
  if (v10 >= 0x10)
  {
    uint64_t v11 = 0;
    unint64_t v12 = v10 >> 4;
    int8x16_t v13 = (int8x16_t)xmmword_2343680E0;
    while (1)
    {
      unsigned __int16 v14 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(*a1 + v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      unint64_t v15 = (unsigned __int16)~v14;
      if (v14 != 0xFFFF) {
        break;
      }
      v11 += 16;
      if (!--v12) {
        goto LABEL_12;
      }
    }
    unint64_t v16 = __clz(__rbit64(v15)) + v11;
    while (v16 != -1)
    {
      uint64_t v27 = a1[1];
      if (!*(void *)&v51[40])
      {
        int8x16_t v49 = v13;
        int8x16_t v13 = v49;
      }
      if (!*(void *)&v51[16]
        || (unint64_t v28 = *(void *)v51, *(void *)v51 > (unint64_t)(8 * *(void *)&v51[16])))
      {
        int8x16_t v48 = v13;
        unint64_t v9 = (_anonymous_namespace_ *)re::HashBrown<void const*,unsigned long,re::Hash<void const*>,re::EqualTo<void const*>,void,false>::resize(&v50);
        int8x16_t v13 = v48;
        unint64_t v28 = *(void *)v51;
      }
      int v29 = (unint64_t *)(v27 + 16 * v16);
      unint64_t v30 = 0xBF58476D1CE4E5B9 * (*v29 ^ (*v29 >> 30));
      unint64_t v31 = (0x94D049BB133111EBLL * (v30 ^ (v30 >> 27))) ^ ((0x94D049BB133111EBLL * (v30 ^ (v30 >> 27))) >> 31);
      unint64_t v32 = v28 >> 4;
      unint64_t v33 = v31 % (v28 >> 4);
      unint64_t v34 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v50 + 16 * v33)), v13)))), (int8x8_t)0x3830282018100800)));
      if (v34 >= 0x40)
      {
        do
        {
          if (v33 + 1 == v32) {
            unint64_t v33 = 0;
          }
          else {
            ++v33;
          }
          unint64_t v34 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v50 + 16 * v33)), v13)))), (int8x8_t)0x3830282018100800)));
        }
        while (v34 > 0x3F);
      }
      unint64_t v35 = (uint64_t *)(v29 + 1);
      uint64_t v36 = v50 + 16 * v33;
      uint64_t v37 = *(unsigned __int8 *)(v36 + v34) == 255;
      *(unsigned char *)(v36 + v34) = v31 & 0x7F;
      unint64_t v38 = *v29;
      uint64_t v39 = *v35;
      uint64_t v40 = *(void *)&v51[8];
      unint64_t v41 = (unint64_t *)(*((void *)&v50 + 1) + 16 * (v34 + 16 * v33));
      *unint64_t v41 = v38;
      v41[1] = v39;
      *(void *)&unsigned char v51[8] = v40 + 1;
      *(void *)&v51[16] -= v37;
      unint64_t v42 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v38 ^ (v38 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v38 ^ (v38 >> 30))) >> 27));
      *(void *)&v51[24] ^= (v42 >> 31) ^ v42;
      unint64_t v43 = v16 >> 4;
      unint64_t v10 = a1[2];
      if (v16 >> 4 >= v10 >> 4) {
        break;
      }
      unint64_t v44 = __clz(__rbit64((-2 << (v16 & 0xF)) & v15));
      if (v44 >= 0x40)
      {
        uint64_t v45 = 16 * v43;
        unint64_t v46 = ~v43 + (v10 >> 4);
        while (v46)
        {
          unint64_t v15 = (unsigned __int16)~*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(*a1 + v45 + 16)), v13)))), (int8x8_t)0x3830282018100800);
          unint64_t v47 = __clz(__rbit64(v15));
          v45 += 16;
          --v46;
          if (v47 <= 0x3F)
          {
            unint64_t v16 = v47 + v45;
            goto LABEL_32;
          }
        }
        break;
      }
      unint64_t v16 = v44 + (v16 & 0xFFFFFFFFFFFFFFF0);
LABEL_32:
      ;
    }
  }
LABEL_12:
  uint64_t v18 = *(void *)&v51[40];
  *(void *)&v51[40] = a1[7];
  uint64_t result = *(void *)&v51[40];
  long long v19 = v50;
  long long v20 = *(_OWORD *)v51;
  *(void *)uint64_t v51 = v10;
  uint64_t v21 = *a1;
  uint64_t v22 = a1[1];
  *(void *)&long long v50 = *a1;
  *((void *)&v50 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v22;
  long long v23 = *(_OWORD *)&v51[16];
  long long v24 = *(_OWORD *)(a1 + 5);
  a1[6] = *(void *)&v51[32];
  a1[7] = v18;
  *(_OWORD *)&uint8_t v51[24] = v24;
  long long v25 = *(_OWORD *)(a1 + 3);
  *(_OWORD *)a1 = v19;
  *((_OWORD *)a1 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v20;
  *((_OWORD *)a1 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v23;
  *(_OWORD *)&unsigned char v51[8] = v25;
  if (result)
  {
    if (v22) {
      *((void *)&v50 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = 0;
    }
    if (v21)
    {
      unint64_t v26 = *(uint64_t (**)(void))(*(void *)result + 40);
      return v26();
    }
  }
  return result;
}

uint64_t anonymous namespace'::getVectorSizeForVertexFormat(int a1)
{
  if ((a1 - 1) > 0x34) {
    return 0;
  }
  else {
    return qword_234373188[(char)(a1 - 1)];
  }
}

void *re::DynamicArray<re::MeshAssetBuffer>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::MeshAssetBuffer>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::MeshAssetBuffer>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::MeshAssetPart>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::MeshAssetPart>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::MeshAssetPart>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::Result<re::MeshAssetPart,re::DetailedError>::~Result(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a1 + 216));
    re::StringID::destroyString((re::StringID *)(a1 + 88));
    re::DynamicArray<re::MeshAssetBuffer>::deinit(a1 + 16);
  }
  else
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 32));
  }
  return a1;
}

_anonymous_namespace_ *re::FixedArray<re::SkinningInfluence>::operator=(_anonymous_namespace_ *a1, uint64_t a2)
{
  if (*(void *)a1) {
    goto LABEL_4;
  }
  unint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
LABEL_4:
    re::FixedArray<re::SkinningInfluence>::copy(a1, (const void **)a2);
  }
  return a1;
}

__n128 re::DynamicArray<re::MeshAssetSkinningData>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::MeshAssetSkinningData>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 144 * v4;
  *(_DWORD *)uint64_t v5 = *(_DWORD *)a2;
  *(void *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = 0;
  *(void *)(v5 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  uint64_t v6 = *(void *)(a2 + 16);
  *(void *)(v5 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(void *)(a2 + 8);
  *(void *)(v5 + 16) = v6;
  *(void *)(a2 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v7 = *(void *)(v5 + 24);
  *(void *)(v5 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v7;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
  *(void *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  uint64_t v8 = *(void *)(a2 + 40);
  *(void *)(v5 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = *(void *)(a2 + 32);
  *(void *)(v5 + 40) = v8;
  *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v9 = *(void *)(v5 + 48);
  *(void *)(v5 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(void *)(a2 + 48);
  *(void *)(a2 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v9;
  *(void *)(v5 + 56) = 0;
  *(void *)(v5 + 64) = 0;
  *(void *)(v5 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = 0;
  uint64_t v10 = *(void *)(a2 + 64);
  *(void *)(v5 + 56) = *(void *)(a2 + 56);
  *(void *)(v5 + 64) = v10;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  uint64_t v11 = *(void *)(v5 + 72);
  *(void *)(v5 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(void *)(a2 + 72);
  *(void *)(a2 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v11;
  __n128 result = *(__n128 *)(a2 + 80);
  long long v13 = *(_OWORD *)(a2 + 96);
  long long v14 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v5 + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v5 + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v14;
  *(__n128 *)(v5 + 80) = result;
  *(_OWORD *)(v5 + 96) = v13;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::FixedArray<re::SkinningInfluence>::copy(void *result, const void **a2)
{
  unint64_t v2 = (const void *)result[1];
  if (v2 == a2[1])
  {
    if (v2)
    {
      unint64_t v3 = *a2;
      unint64_t v4 = (void *)result[2];
      return memmove(v4, v3, 8 * (void)v2);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a Slice of a different size", "m_size == other.size()", "copy", 378);
    __n128 result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

void *re::DynamicArray<re::MeshAssetSkinningData>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::MeshAssetSkinningData>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::MeshAssetSkinningData>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

unsigned char *re::Result<re::DynamicArray<re::MeshAssetSkinningData>,re::DetailedError>::~Result(unsigned char *a1)
{
  if (*a1) {
    re::DynamicArray<re::MeshAssetSkinningData>::deinit((uint64_t)(a1 + 8));
  }
  else {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetBlendShapeData>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 56 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = (re::StringID *)(*(void *)(a1 + 32) + v8);
      re::FixedArray<re::BlendShapeDefinition>::deinit((void *)v10 + 2);
      re::StringID::destroyString(v10);
      ++v9;
      v8 += 56;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::MeshAssetBlendShapeData>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 56 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = "";
        *(_DWORD *)(v7 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = 0;
        *(_WORD *)(v7 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0;
        *(void *)(v7 + 24) = 0;
        *(void *)(v7 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
        *(void *)(v7 + 16) = 0;
        *(unsigned char *)(v7 + 40) = 0;
        v6 += 56;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::Result<re::BlendShapeGroupDefinition,re::DetailedError>::~Result(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    re::FixedArray<re::BlendShapeDefinition>::deinit((void *)(a1 + 24));
    re::StringID::destroyString((re::StringID *)(a1 + 8));
  }
  else
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

unsigned char *re::Result<re::DynamicArray<re::MeshAssetBlendShapeData>,re::DetailedError>::~Result(unsigned char *a1)
{
  if (*a1) {
    re::DynamicArray<re::MeshAssetBlendShapeData>::deinit((uint64_t)(a1 + 8));
  }
  else {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetContactDeformerData>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 48 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = (re::StringID *)(*(void *)(a1 + 32) + v8);
      re::FixedArray<re::MeshAssetContactDeformerTarget>::deinit((void *)v10 + 2);
      re::StringID::destroyString(v10);
      ++v9;
      v8 += 48;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::MeshAssetContactDeformerData>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 48 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = "";
        *(void *)(v7 + 24) = 0;
        *(void *)(v7 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0;
        *(void *)(v7 + 16) = 0;
        *(_WORD *)(v7 + 40) = 0;
        v6 += 48;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

unsigned char *re::Result<re::DynamicArray<re::MeshAssetContactDeformerData>,re::DetailedError>::~Result(unsigned char *a1)
{
  if (*a1) {
    re::DynamicArray<re::MeshAssetContactDeformerData>::deinit((uint64_t)(a1 + 8));
  }
  else {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetSmoothDeformerData>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 24 * a2;
    unint64_t v9 = a2;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(void *)(a1 + 32) + v8));
      ++v9;
      v8 += 24;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::MeshAssetSmoothDeformerData>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 24 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = "";
        *(_WORD *)(v7 + 16) = 0;
        v6 += 24;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

unsigned char *re::Result<re::DynamicArray<re::MeshAssetSmoothDeformerData>,re::DetailedError>::~Result(unsigned char *a1)
{
  if (*a1) {
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)(a1 + 8));
  }
  else {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

void re::DynamicArray<re::MeshAssetWrapDeformerData>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 112 * a2;
    unint64_t v9 = a2;
    do
    {
      uint64_t v10 = (uint64_t *)(*(void *)(a1 + 32) + v8);
      re::FixedArray<CoreIKTransform>::deinit(v10 + 10);
      re::FixedArray<CoreIKTransform>::deinit(v10 + 7);
      re::FixedArray<CoreIKTransform>::deinit(v10 + 4);
      re::StringID::destroyString((re::StringID *)(v10 + 2));
      re::StringID::destroyString((re::StringID *)v10);
      ++v9;
      v8 += 112;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::MeshAssetWrapDeformerData>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 112 * v4;
      do
      {
        uint64_t v7 = *(void *)(a1 + 32) + v6;
        *(void *)uint64_t v7 = 0;
        *(void *)(v7 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = "";
        *(void *)(v7 + 16) = 0;
        *(void *)(v7 + 24) = "";
        *(_OWORD *)(v7 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = 0uLL;
        *(_OWORD *)(v7 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = 0uLL;
        *(_OWORD *)(v7 + 64) = 0uLL;
        *(_OWORD *)(v7 + 80) = 0uLL;
        *(_OWORD *)(v7 + 90) = 0uLL;
        v6 += 112;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

unsigned char *re::Result<re::DynamicArray<re::MeshAssetWrapDeformerData>,re::DetailedError>::~Result(unsigned char *a1)
{
  if (*a1) {
    re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit((uint64_t)(a1 + 8));
  }
  else {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

unsigned char *re::Result<re::DynamicArray<re::MeshAssetJiggleDeformerData>,re::DetailedError>::~Result(unsigned char *a1)
{
  if (*a1) {
    re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit((uint64_t)(a1 + 8));
  }
  else {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

uint64_t re::MeshPartFlags::flattenToRenderFlags(re::MeshPartFlags *this)
{
  uint64_t result = 25172350;
  if (*(unsigned char *)this) {
    uint64_t result = *((unsigned __int8 *)this + 1) | 0x180197Eu;
  }
  if (*((unsigned char *)this + 2)) {
    uint64_t result = result & 0xFFFFFFFD | (2 * (*((unsigned char *)this + 3) == 1));
  }
  if (*((unsigned char *)this + 4)) {
    return result & 0xFFF9FFFF | ((*((unsigned char *)this + 5) & 3) << 17);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetBlendShapeData>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::MeshAssetBlendShapeData>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::MeshAssetBlendShapeData>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::MeshAssetBlendShapeData>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::MeshAssetBlendShapeData>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetSkinningData>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::MeshAssetSkinningData>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::MeshAssetSkinningData>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::MeshAssetSkinningData>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::MeshAssetSkinningData>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetPart>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::MeshAssetPart>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::MeshAssetPart>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::MeshAssetPart>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::MeshAssetPart>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshLodLevelInfo>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4) {
        re::DynamicArray<re::MeshLodLevelInfo>::copy((void **)a1, (uint64_t)a2);
      }
      else {
        *(void *)(a1 + 16) = 0;
      }
      ++*(_DWORD *)(a1 + 24);
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::MeshLodLevelInfo>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::MeshLodLevelInfo>::copy((void **)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetContactDeformerData>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::MeshAssetContactDeformerData>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::MeshAssetContactDeformerData>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::MeshAssetContactDeformerData>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::MeshAssetContactDeformerData>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetSmoothDeformerData>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::MeshAssetSmoothDeformerData>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::MeshAssetSmoothDeformerData>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::MeshAssetSmoothDeformerData>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::MeshAssetSmoothDeformerData>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetWrapDeformerData>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::MeshAssetWrapDeformerData>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::MeshAssetWrapDeformerData>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::MeshAssetWrapDeformerData>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::MeshAssetWrapDeformerData>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetJiggleDeformerData>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::MeshAssetJiggleDeformerData>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::BlendSpaceAxisDefinition>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::MeshAssetJiggleDeformerData>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::MeshAssetJiggleDeformerData>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::MeshAssetSkinningData>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = 144 * v2;
    uint64_t v4 = (uint64_t *)(*(void *)(result + 32) + 56);
    do
    {
      re::FixedArray<CoreIKTransform>::deinit(v4);
      re::FixedArray<CoreIKTransform>::deinit(v4 - 3);
      uint64_t result = re::FixedArray<CoreIKTransform>::deinit(v4 - 6);
      v4 += 18;
      v3 -= 144;
    }
    while (v3);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

uint64_t re::DynamicArray<re::MeshAssetPart>::clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = v2 << 8;
    do
    {
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v3 + 200));
      re::StringID::destroyString((re::StringID *)(v3 + 72));
      uint64_t result = re::DynamicArray<re::MeshAssetBuffer>::deinit(v3);
      v3 += 256;
      v4 -= 256;
    }
    while (v4);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

void re::DynamicArray<re::MeshAssetContactDeformerData>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(re::StringID **)(a1 + 32);
    uint64_t v4 = 48 * v2;
    do
    {
      re::FixedArray<re::MeshAssetContactDeformerTarget>::deinit((void *)v3 + 2);
      re::StringID::destroyString(v3);
      uint64_t v3 = (re::StringID *)((char *)v3 + 48);
      v4 -= 48;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void re::DynamicArray<re::MeshAssetSmoothDeformerData>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(re::StringID **)(a1 + 32);
    uint64_t v4 = 24 * v2;
    do
    {
      re::StringID::destroyString(v3);
      uint64_t v3 = (re::StringID *)((char *)v3 + 24);
      v4 -= 24;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void re::DynamicArray<re::MeshAssetWrapDeformerData>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 32);
    uint64_t v4 = 112 * v2;
    do
    {
      re::FixedArray<CoreIKTransform>::deinit(v3 + 10);
      re::FixedArray<CoreIKTransform>::deinit(v3 + 7);
      re::FixedArray<CoreIKTransform>::deinit(v3 + 4);
      re::StringID::destroyString((re::StringID *)(v3 + 2));
      re::StringID::destroyString((re::StringID *)v3);
      v3 += 14;
      v4 -= 112;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

void std::__introsort<std::_ClassicAlgPolicy,re::anonymous namespace'::combineParts(re::MeshAssetModel &,re::MeshAssetData const&,re::DynamicOverflowArray<re::DynamicOverflowArray<re::anonymous namespace'::PartInstance,64ul>,64ul> &,re::DynamicOverflowArray<re::DynamicOverflowArray<unsigned long long,64ul>,128ul> const&,unsigned int)::$_0 &,re::anonymous namespace'::PartInstance*,false>(unint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char a5)
{
  while (2)
  {
    uint64_t v11 = (unsigned int *)a2;
    uint64_t v144 = a2 - 80;
    unint64_t v12 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v12;
          uint64_t v13 = (uint64_t)v11 - v12;
          uint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * (v13 >> 4);
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0:
              case 1:
                return;
              case 2:
                uint64_t v63 = *a3;
                uint64_t v64 = (_OWORD *)(a2 - 80);
                {
                  long long v165 = *(_OWORD *)a1;
                  long long v201 = *(_OWORD *)(a1 + 48);
                  long long v213 = *(_OWORD *)(a1 + 64);
                  long long v177 = *(_OWORD *)(a1 + 16);
                  long long v189 = *(_OWORD *)(a1 + 32);
                  long long v65 = *(_OWORD *)(a2 - 16);
                  long long v67 = *(_OWORD *)(a2 - 64);
                  long long v66 = *(_OWORD *)(a2 - 48);
                  *(_OWORD *)(a1 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_OWORD *)(a2 - 32);
                  *(_OWORD *)(a1 + 64) = v65;
                  *(_OWORD *)(a1 + 16) = v67;
                  *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v66;
                  *(_OWORD *)a1 = *v64;
                  *(_OWORD *)(a2 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v201;
                  *(_OWORD *)(a2 - 16) = v213;
                  *(_OWORD *)(a2 - 64) = v177;
                  *(_OWORD *)(a2 - 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v189;
                  *uint64_t v64 = v165;
                }
                break;
              case 3:
                break;
              case 4:
                break;
              case 5:
                unint64_t v68 = (long long *)(a1 + 80);
                unsigned int v69 = (long long *)(a1 + 160);
                unint64_t v70 = (long long *)(a1 + 240);
                uint64_t v71 = (long long *)(a2 - 80);
                {
                  long long v190 = *(_OWORD *)(a1 + 272);
                  long long v202 = *(_OWORD *)(a1 + 288);
                  long long v214 = *(_OWORD *)(a1 + 304);
                  long long v166 = *v70;
                  long long v178 = *(_OWORD *)(a1 + 256);
                  long long v73 = *(_OWORD *)(a2 - 64);
                  long long v72 = *(_OWORD *)(a2 - 48);
                  long long v74 = *(_OWORD *)(a2 - 16);
                  *(_OWORD *)(a1 + 28re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_OWORD *)(a2 - 32);
                  *(_OWORD *)(a1 + 304) = v74;
                  *(_OWORD *)(a1 + 256) = v73;
                  *(_OWORD *)(a1 + 27re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v72;
                  *unint64_t v70 = *v71;
                  long long *v71 = v166;
                  *(_OWORD *)(a2 - re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v202;
                  *(_OWORD *)(a2 - 16) = v214;
                  *(_OWORD *)(a2 - 64) = v178;
                  *(_OWORD *)(a2 - 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v190;
                  {
                    long long v191 = *(_OWORD *)(a1 + 192);
                    long long v203 = *(_OWORD *)(a1 + 208);
                    long long v215 = *(_OWORD *)(a1 + 224);
                    long long v167 = *v69;
                    long long v179 = *(_OWORD *)(a1 + 176);
                    long long v75 = *(_OWORD *)(a1 + 288);
                    *(_OWORD *)(a1 + 19re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(_OWORD *)(a1 + 272);
                    *(_OWORD *)(a1 + 20re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v75;
                    *(_OWORD *)(a1 + 224) = *(_OWORD *)(a1 + 304);
                    long long v76 = *(_OWORD *)(a1 + 256);
                    *unsigned int v69 = *v70;
                    *(_OWORD *)(a1 + 176) = v76;
                    *(_OWORD *)(a1 + 28re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v203;
                    *(_OWORD *)(a1 + 304) = v215;
                    *(_OWORD *)(a1 + 256) = v179;
                    *(_OWORD *)(a1 + 27re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v191;
                    *unint64_t v70 = v167;
                    {
                      long long v192 = *(_OWORD *)(a1 + 112);
                      long long v204 = *(_OWORD *)(a1 + 128);
                      long long v216 = *(_OWORD *)(a1 + 144);
                      long long v168 = *v68;
                      long long v180 = *(_OWORD *)(a1 + 96);
                      long long v77 = *(_OWORD *)(a1 + 208);
                      *(_OWORD *)(a1 + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = *(_OWORD *)(a1 + 192);
                      *(_OWORD *)(a1 + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v77;
                      *(_OWORD *)(a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = *(_OWORD *)(a1 + 224);
                      long long v78 = *(_OWORD *)(a1 + 176);
                      long long *v68 = *v69;
                      *(_OWORD *)(a1 + 96) = v78;
                      *(_OWORD *)(a1 + 20re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v204;
                      *(_OWORD *)(a1 + 224) = v216;
                      *(_OWORD *)(a1 + 176) = v180;
                      *(_OWORD *)(a1 + 19re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v192;
                      *unsigned int v69 = v168;
                      {
                        long long v169 = *(_OWORD *)a1;
                        long long v205 = *(_OWORD *)(a1 + 48);
                        long long v217 = *(_OWORD *)(a1 + 64);
                        long long v181 = *(_OWORD *)(a1 + 16);
                        long long v193 = *(_OWORD *)(a1 + 32);
                        long long v79 = *(_OWORD *)(a1 + 144);
                        long long v80 = *(_OWORD *)(a1 + 112);
                        *(_OWORD *)(a1 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_OWORD *)(a1 + 128);
                        *(_OWORD *)(a1 + 64) = v79;
                        long long v81 = *v68;
                        *(_OWORD *)(a1 + 16) = *(_OWORD *)(a1 + 96);
                        *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v80;
                        *(_OWORD *)a1 = v81;
                        *(_OWORD *)(a1 + 12re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v205;
                        *(_OWORD *)(a1 + 1re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 44) = v217;
                        *(_OWORD *)(a1 + 96) = v181;
                        *(_OWORD *)(a1 + 11re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v193;
                        long long *v68 = v169;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v13 <= 1919)
          {
            unint64_t v82 = a1 + 80;
            BOOL v84 = (unsigned int *)a1 == v11 || v82 == (void)v11;
            if (a5)
            {
              if (!v84)
              {
                uint64_t v85 = 0;
                unint64_t v86 = a1;
                do
                {
                  unsigned int v87 = *(_DWORD *)(v86 + 80);
                  unsigned int v88 = *(_DWORD *)v86;
                  unsigned int v89 = *(_DWORD *)(v86 + 4);
                  unint64_t v86 = v82;
                  {
                    unsigned int v90 = *(_DWORD *)v86;
                    unsigned int v91 = *(_DWORD *)(v86 + 4);
                    uint64_t v218 = *(void *)(v86 + 72);
                    long long v194 = *(_OWORD *)(v86 + 40);
                    long long v206 = *(_OWORD *)(v86 + 56);
                    long long v182 = *(_OWORD *)(v86 + 24);
                    long long v170 = *(_OWORD *)(v86 + 8);
                    uint64_t v92 = v85;
                    while (1)
                    {
                      unint64_t v93 = (_OWORD *)(a1 + v92);
                      long long v94 = *(_OWORD *)(a1 + v92 + 48);
                      v93[7] = *(_OWORD *)(a1 + v92 + 32);
                      v93[8] = v94;
                      v93[9] = *(_OWORD *)(a1 + v92 + 64);
                      long long v95 = *(_OWORD *)(a1 + v92 + 16);
                      v93[5] = *(_OWORD *)(a1 + v92);
                      v93[6] = v95;
                      if (!v92) {
                        break;
                      }
                      v92 -= 80;
                      {
                        uint64_t v96 = a1 + v92 + 80;
                        goto LABEL_83;
                      }
                    }
                    uint64_t v96 = a1;
LABEL_83:
                    *(_DWORD *)uint64_t v96 = v90;
                    *(_DWORD *)(v96 + 4) = v91;
                    *(void *)(v96 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v218;
                    *(_OWORD *)(v96 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v170;
                    *(_OWORD *)(v96 + 56) = v206;
                    *(_OWORD *)(v96 + 40) = v194;
                    *(_OWORD *)(v96 + 24) = v182;
                  }
                  unint64_t v82 = v86 + 80;
                  v85 += 80;
                }
                while (v86 + 80 != a2);
              }
            }
            else if (!v84)
            {
              do
              {
                unsigned int v132 = *(_DWORD *)(a1 + 80);
                unsigned int v133 = *(_DWORD *)a1;
                unsigned int v134 = *(_DWORD *)(a1 + 4);
                a1 = v82;
                {
                  unsigned int v135 = *(_DWORD *)a1;
                  unsigned int v136 = *(_DWORD *)(a1 + 4);
                  uint64_t v221 = *(void *)(a1 + 72);
                  long long v197 = *(_OWORD *)(a1 + 40);
                  long long v209 = *(_OWORD *)(a1 + 56);
                  long long v185 = *(_OWORD *)(a1 + 24);
                  long long v173 = *(_OWORD *)(a1 + 8);
                  float v137 = (_OWORD *)a1;
                  do
                  {
                    uint64_t v138 = v137 - 5;
                    long long v139 = *(v137 - 2);
                    v137[2] = *(v137 - 3);
                    v137[3] = v139;
                    v137[4] = *(v137 - 1);
                    long long v140 = *(v137 - 4);
                    *float v137 = *(v137 - 5);
                    v137[1] = v140;
                    float v137 = v138;
                  }
                  while (v141);
                  *(_DWORD *)uint64_t v138 = v135;
                  *((_DWORD *)v138 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v136;
                  *(_OWORD *)((char *)v138 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v173;
                  *((void *)v138 + 9) = v221;
                  *(_OWORD *)((char *)v138 + 56) = v209;
                  *(_OWORD *)((char *)v138 + 40) = v197;
                  *(_OWORD *)((char *)v138 + 24) = v185;
                }
                unint64_t v82 = a1 + 80;
              }
              while (a1 + 80 != a2);
            }
            return;
          }
          if (!a4)
          {
            if ((unsigned int *)a1 != v11)
            {
              int64_t v97 = (unint64_t)(v14 - 2) >> 1;
              int64_t v145 = v97;
              do
              {
                int64_t v98 = v97;
                if (v145 >= v97)
                {
                  uint64_t v99 = (2 * v97) | 1;
                  unint64_t v100 = a1 + 80 * v99;
                  if (2 * v97 + 2 < v14
                  {
                    v100 += 80;
                    uint64_t v99 = 2 * v98 + 2;
                  }
                  unint64_t v101 = a1 + 80 * v98;
                  {
                    int64_t v142 = v98;
                    unsigned int v102 = *(_DWORD *)(v101 + 4);
                    unsigned int v143 = *(_DWORD *)v101;
                    uint64_t v219 = *(void *)(v101 + 72);
                    long long v195 = *(_OWORD *)(v101 + 40);
                    long long v207 = *(_OWORD *)(v101 + 56);
                    long long v183 = *(_OWORD *)(v101 + 24);
                    long long v171 = *(_OWORD *)(v101 + 8);
                    do
                    {
                      unint64_t v103 = v100;
                      *(_OWORD *)unint64_t v101 = *(_OWORD *)v100;
                      long long v104 = *(_OWORD *)(v100 + 16);
                      long long v105 = *(_OWORD *)(v100 + 32);
                      long long v106 = *(_OWORD *)(v100 + 64);
                      *(_OWORD *)(v101 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_OWORD *)(v100 + 48);
                      *(_OWORD *)(v101 + 64) = v106;
                      *(_OWORD *)(v101 + 16) = v104;
                      *(_OWORD *)(v101 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v105;
                      if (v145 < v99) {
                        break;
                      }
                      uint64_t v107 = (2 * v99) | 1;
                      unint64_t v100 = a1 + 80 * v107;
                      uint64_t v108 = 2 * v99 + 2;
                      if (v108 < v14
                      {
                        v100 += 80;
                        uint64_t v107 = v108;
                      }
                      unint64_t v101 = v103;
                      uint64_t v99 = v107;
                    }
                    *(_DWORD *)unint64_t v103 = v143;
                    *(_DWORD *)(v103 + 4) = v102;
                    *(void *)(v103 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v219;
                    *(_OWORD *)(v103 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v171;
                    *(_OWORD *)(v103 + 56) = v207;
                    *(_OWORD *)(v103 + 40) = v195;
                    *(_OWORD *)(v103 + 24) = v183;
                    int64_t v98 = v142;
                  }
                }
                int64_t v97 = v98 - 1;
              }
              while (v98);
              int64_t v109 = v13 / 0x50uLL;
              do
              {
                uint64_t v110 = 0;
                long long v172 = *(_OWORD *)a1;
                long long v208 = *(_OWORD *)(a1 + 48);
                long long v220 = *(_OWORD *)(a1 + 64);
                long long v184 = *(_OWORD *)(a1 + 16);
                long long v196 = *(_OWORD *)(a1 + 32);
                unsigned int v111 = (_OWORD *)a1;
                do
                {
                  uint64_t v112 = (uint64_t)&v111[5 * v110 + 5];
                  uint64_t v113 = (2 * v110) | 1;
                  uint64_t v114 = 2 * v110 + 2;
                  if (v114 < v109
                  {
                    v112 += 80;
                    uint64_t v113 = v114;
                  }
                  *unsigned int v111 = *(_OWORD *)v112;
                  long long v115 = *(_OWORD *)(v112 + 16);
                  long long v116 = *(_OWORD *)(v112 + 32);
                  long long v117 = *(_OWORD *)(v112 + 64);
                  v111[3] = *(_OWORD *)(v112 + 48);
                  v111[4] = v117;
                  v111[1] = v115;
                  id v111[2] = v116;
                  unsigned int v111 = (_OWORD *)v112;
                  uint64_t v110 = v113;
                }
                while (v113 <= (uint64_t)((unint64_t)(v109 - 2) >> 1));
                unint64_t v118 = (_OWORD *)(a2 - 80);
                BOOL v6 = v112 == a2 - 80;
                a2 -= 80;
                if (v6)
                {
                  *(_OWORD *)uint64_t v112 = v172;
                  *(_OWORD *)(v112 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v208;
                  *(_OWORD *)(v112 + 64) = v220;
                  *(_OWORD *)(v112 + 16) = v184;
                  *(_OWORD *)(v112 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v196;
                }
                else
                {
                  *(_OWORD *)uint64_t v112 = *v118;
                  long long v119 = v118[1];
                  long long v120 = v118[2];
                  long long v121 = v118[4];
                  *(_OWORD *)(v112 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v118[3];
                  *(_OWORD *)(v112 + 64) = v121;
                  *(_OWORD *)(v112 + 16) = v119;
                  *(_OWORD *)(v112 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v120;
                  v118[3] = v208;
                  v118[4] = v220;
                  v118[1] = v184;
                  _OWORD v118[2] = v196;
                  *unint64_t v118 = v172;
                  uint64_t v122 = v112 - a1 + 80;
                  if (v122 >= 81)
                  {
                    unint64_t v123 = (v122 / 0x50uLL - 2) >> 1;
                    unint64_t v124 = a1 + 80 * v123;
                    {
                      unsigned int v125 = *(_DWORD *)v112;
                      unsigned int v126 = *(_DWORD *)(v112 + 4);
                      uint64_t v161 = *(void *)(v112 + 72);
                      long long v155 = *(_OWORD *)(v112 + 40);
                      long long v158 = *(_OWORD *)(v112 + 56);
                      long long v152 = *(_OWORD *)(v112 + 24);
                      long long v149 = *(_OWORD *)(v112 + 8);
                      do
                      {
                        uint64_t v127 = v124;
                        *(_OWORD *)uint64_t v112 = *(_OWORD *)v124;
                        long long v128 = *(_OWORD *)(v124 + 16);
                        long long v129 = *(_OWORD *)(v124 + 32);
                        long long v130 = *(_OWORD *)(v124 + 64);
                        *(_OWORD *)(v112 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_OWORD *)(v124 + 48);
                        *(_OWORD *)(v112 + 64) = v130;
                        *(_OWORD *)(v112 + 16) = v128;
                        *(_OWORD *)(v112 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v129;
                        if (!v123) {
                          break;
                        }
                        unint64_t v123 = (v123 - 1) >> 1;
                        unint64_t v124 = a1 + 80 * v123;
                        uint64_t v112 = v127;
                      }
                      *(_DWORD *)uint64_t v127 = v125;
                      *(_DWORD *)(v127 + 4) = v126;
                      *(void *)(v127 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v161;
                      *(_OWORD *)(v127 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v149;
                      *(_OWORD *)(v127 + 56) = v158;
                      *(_OWORD *)(v127 + 40) = v155;
                      *(_OWORD *)(v127 + 24) = v152;
                    }
                  }
                }
              }
              while (v109-- > 2);
            }
            return;
          }
          unint64_t v15 = (unint64_t)v14 >> 1;
          unint64_t v16 = (_OWORD *)(a1 + 80 * ((unint64_t)v14 >> 1));
          if ((unint64_t)v13 < 0x2801)
          {
          }
          else
          {
            uint64_t v17 = 5 * v15;
            long long v162 = *(_OWORD *)a1;
            long long v198 = *(_OWORD *)(a1 + 48);
            long long v210 = *(_OWORD *)(a1 + 64);
            long long v174 = *(_OWORD *)(a1 + 16);
            long long v186 = *(_OWORD *)(a1 + 32);
            long long v18 = v16[4];
            long long v20 = v16[1];
            long long v19 = v16[2];
            *(_OWORD *)(a1 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v16[3];
            *(_OWORD *)(a1 + 64) = v18;
            *(_OWORD *)(a1 + 16) = v20;
            *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v19;
            *(_OWORD *)a1 = *v16;
            void v16[3] = v198;
            v16[4] = v210;
            v16[1] = v174;
            void v16[2] = v186;
            *unint64_t v16 = v162;
          }
          --a4;
          if ((a5 & 1) != 0
          {
            break;
          }
          unsigned int v45 = *(_DWORD *)a1;
          unsigned int v44 = *(_DWORD *)(a1 + 4);
          uint64_t v160 = *(void *)(a1 + 72);
          long long v154 = *(_OWORD *)(a1 + 40);
          long long v157 = *(_OWORD *)(a1 + 56);
          long long v151 = *(_OWORD *)(a1 + 24);
          long long v148 = *(_OWORD *)(a1 + 8);
          {
            unint64_t v12 = a1;
            do
            {
              unsigned int v46 = *(_DWORD *)(v12 + 80);
              unsigned int v47 = *(_DWORD *)(v12 + 84);
              v12 += 80;
            }
          }
          else
          {
            int8x16_t v48 = (unsigned int *)(a1 + 80);
            do
            {
              unint64_t v12 = (unint64_t)v48;
              if (v48 >= v11) {
                break;
              }
              int8x16_t v48 = (unsigned int *)(v12 + 80);
            }
            while (!v49);
          }
          long long v50 = v11;
          if (v12 < (unint64_t)v11)
          {
            long long v50 = v11;
            do
            {
              unsigned int v51 = *(v50 - 20);
              unsigned int v52 = *(v50 - 19);
              v50 -= 20;
            }
          }
          while (v12 < (unint64_t)v50)
          {
            long long v164 = *(_OWORD *)v12;
            long long v200 = *(_OWORD *)(v12 + 48);
            long long v212 = *(_OWORD *)(v12 + 64);
            long long v176 = *(_OWORD *)(v12 + 16);
            long long v188 = *(_OWORD *)(v12 + 32);
            long long v53 = *((_OWORD *)v50 + 4);
            long long v55 = *((_OWORD *)v50 + 1);
            long long v54 = *((_OWORD *)v50 + 2);
            *(_OWORD *)(v12 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *((_OWORD *)v50 + 3);
            *(_OWORD *)(v12 + 64) = v53;
            *(_OWORD *)(v12 + 16) = v55;
            *(_OWORD *)(v12 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v54;
            *(_OWORD *)unint64_t v12 = *(_OWORD *)v50;
            *((_OWORD *)v50 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v200;
            *((_OWORD *)v50 + 4) = v212;
            *((_OWORD *)v50 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v176;
            *((_OWORD *)v50 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v188;
            *(_OWORD *)long long v50 = v164;
            do
            {
              unsigned int v56 = *(_DWORD *)(v12 + 80);
              unsigned int v57 = *(_DWORD *)(v12 + 84);
              v12 += 80;
            }
            do
            {
              unsigned int v58 = *(v50 - 20);
              unsigned int v59 = *(v50 - 19);
              v50 -= 20;
            }
          }
          BOOL v5 = v12 - 80 >= a1;
          BOOL v6 = v12 - 80 == a1;
          if (v12 - 80 != a1)
          {
            *(_OWORD *)a1 = *(_OWORD *)(v12 - 80);
            long long v60 = *(_OWORD *)(v12 - 64);
            long long v61 = *(_OWORD *)(v12 - 48);
            long long v62 = *(_OWORD *)(v12 - 16);
            *(_OWORD *)(a1 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_OWORD *)(v12 - 32);
            *(_OWORD *)(a1 + 64) = v62;
            *(_OWORD *)(a1 + 16) = v60;
            *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v61;
          }
          a5 = 0;
          *(_DWORD *)(v12 - 80) = v45;
          *(_DWORD *)(v12 - 76) = v44;
          *(_OWORD *)(v12 - 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v148;
          *(void *)(v12 - re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v160;
          *(_OWORD *)(v12 - 24) = v157;
          *(_OWORD *)(v12 - 40) = v154;
          *(_OWORD *)(v12 - 56) = v151;
        }
        uint64_t v21 = 0;
        unsigned int v22 = *(_DWORD *)a1;
        unsigned int v23 = *(_DWORD *)(a1 + 4);
        uint64_t v159 = *(void *)(a1 + 72);
        long long v153 = *(_OWORD *)(a1 + 40);
        long long v156 = *(_OWORD *)(a1 + 56);
        long long v150 = *(_OWORD *)(a1 + 24);
        long long v147 = *(_OWORD *)(a1 + 8);
        do
        {
          v21 += 80;
        }
        while (v24);
        unint64_t v25 = a1 + v21;
        if (v21 == 80)
        {
          uint64_t v11 = (unsigned int *)a2;
          do
          {
            if (v25 >= (unint64_t)v11) {
              break;
            }
            unsigned int v28 = *(v11 - 20);
            unsigned int v29 = *(v11 - 19);
            v11 -= 20;
          }
        }
        else
        {
          do
          {
            unsigned int v26 = *(v11 - 20);
            unsigned int v27 = *(v11 - 19);
            v11 -= 20;
          }
        }
        if (v25 >= (unint64_t)v11)
        {
          uint64_t v39 = v25 - 80;
        }
        else
        {
          unint64_t v30 = a1 + v21;
          unint64_t v31 = v11;
          do
          {
            long long v163 = *(_OWORD *)v30;
            long long v199 = *(_OWORD *)(v30 + 48);
            long long v211 = *(_OWORD *)(v30 + 64);
            long long v175 = *(_OWORD *)(v30 + 16);
            long long v187 = *(_OWORD *)(v30 + 32);
            long long v32 = *((_OWORD *)v31 + 4);
            long long v34 = *((_OWORD *)v31 + 1);
            long long v33 = *((_OWORD *)v31 + 2);
            *(_OWORD *)(v30 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *((_OWORD *)v31 + 3);
            *(_OWORD *)(v30 + 64) = v32;
            *(_OWORD *)(v30 + 16) = v34;
            *(_OWORD *)(v30 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v33;
            *(_OWORD *)unint64_t v30 = *(_OWORD *)v31;
            *((_OWORD *)v31 + re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)this + 3) = v199;
            *((_OWORD *)v31 + 4) = v211;
            *((_OWORD *)v31 + re::ResourceSharingManager::~ResourceSharingManager(this - 1) = v175;
            *((_OWORD *)v31 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v187;
            *(_OWORD *)unint64_t v31 = v163;
            do
            {
              unsigned int v35 = *(_DWORD *)(v30 + 80);
              unsigned int v36 = *(_DWORD *)(v30 + 84);
              v30 += 80;
            }
            do
            {
              unsigned int v37 = *(v31 - 20);
              unsigned int v38 = *(v31 - 19);
              v31 -= 20;
            }
          }
          while (v30 < (unint64_t)v31);
          uint64_t v39 = v30 - 80;
        }
        if (v39 != a1)
        {
          *(_OWORD *)a1 = *(_OWORD *)v39;
          long long v40 = *(_OWORD *)(v39 + 16);
          long long v41 = *(_OWORD *)(v39 + 32);
          long long v42 = *(_OWORD *)(v39 + 64);
          *(_OWORD *)(a1 + 4re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = *(_OWORD *)(v39 + 48);
          *(_OWORD *)(a1 + 64) = v42;
          *(_OWORD *)(a1 + 16) = v40;
          *(_OWORD *)(a1 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32) = v41;
        }
        *(_DWORD *)uint64_t v39 = v22;
        *(_DWORD *)(v39 + 4) = v23;
        *(void *)(v39 + 7re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 2) = v159;
        *(_OWORD *)(v39 + re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 8) = v147;
        *(_OWORD *)(v39 + 56) = v156;
        *(_OWORD *)(v39 + 40) = v153;
        *(_OWORD *)(v39 + 24) = v150;
        BOOL v5 = v25 >= (unint64_t)v11;
        uint64_t v11 = (unsigned int *)a2;
        if (v5) {
          break;
        }
LABEL_33:
        a5 = 0;
        unint64_t v12 = v39 + 80;
      }
      unint64_t v12 = v39 + 80;
      {
        break;
      }
      if (!v43) {
        goto LABEL_33;
      }
    }
    a2 = v39;
    if (!v43) {
      continue;
    }
    break;
  }
}