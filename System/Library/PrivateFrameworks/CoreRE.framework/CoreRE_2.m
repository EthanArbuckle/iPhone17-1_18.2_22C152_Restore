void re::IntrospectionInfo<re::DynamicArray<re::BlendNode>>::get(re *a1)
{
  void *v1;
  re::IntrospectionBase *v2;
  int v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  long long v10;
  long long v11;
  uint64_t v12[2];
  long long v13;
  uint64_t v14;
  char v15;
  unsigned char v16[479];

  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF73F70, memory_order_acquire) & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_26AF73F70);
    if (a1)
    {
      re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_26AF74078);
      qword_26AF74078 = (uint64_t)&unk_26E6C4230;
      __cxa_guard_release(&qword_26AF73F70);
    }
  }
  if ((byte_26AF73EF3 & 1) == 0)
  {
    v1 = (void *)qword_26AF73F48;
    if (qword_26AF73F48
      || (v1 = re::allocInfo_BlendNode(a1),
          qword_26AF73F48 = (uint64_t)v1,
          re::initInfo_BlendNode((re *)v1, v2),
          (byte_26AF73EF3 & 1) == 0))
    {
      byte_26AF73EF3 = 1;
      v3 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_26AF74078, 0);
      qword_26AF74088 = 0x2800000003;
      dword_26AF74090 = v3;
      word_26AF74094 = 0;
      *(void *)&xmmword_26AF74098 = 0;
      *((void *)&xmmword_26AF74098 + 1) = 0xFFFFFFFFLL;
      qword_26AF740A8 = (uint64_t)v1;
      unk_26AF740B0 = 0;
      qword_26AF74078 = (uint64_t)&unk_26E6C4230;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)&qword_26AF74078, (const re::IntrospectionBase *)&v14);
      if (v15) {
        v6 = *(const char **)&v16[7];
      }
      else {
        v6 = v16;
      }
      if (v14 && (v15 & 1) != 0) {
        (*(void (**)(void))(*(void *)v14 + 40))();
      }
      v11 = *((_OWORD *)v1 + 2);
      v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v12);
      if (v7)
      {
        v8 = *v7;
        *((void *)&v10 + 1) = v8;
      }
      else
      {
        v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_26AF74098 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

double re::internal::defaultConstruct<re::BlendTreeDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 320) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_DWORD *)(a3 + 144) = 0;
  *(_OWORD *)(a3 + 152) = 0u;
  *(_OWORD *)(a3 + 168) = 0u;
  *(_OWORD *)(a3 + 180) = 0u;
  *(_DWORD *)(a3 + 232) = 0;
  *(_OWORD *)(a3 + 216) = 0u;
  *(_OWORD *)(a3 + 200) = 0u;
  *(_DWORD *)(a3 + 272) = 0;
  *(_OWORD *)(a3 + 240) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 280) = 0u;
  *(_OWORD *)(a3 + 296) = 0u;
  *(_DWORD *)(a3 + 312) = 0;
  return result;
}

uint64_t re::internal::defaultDestruct<re::BlendTreeDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a3 + 288);
  re::DynamicArray<unsigned long>::deinit(a3 + 248);
  re::DynamicArray<unsigned long>::deinit(a3 + 208);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a3 + 168);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a3 + 120);
  re::DynamicArray<unsigned long>::deinit(a3 + 80);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a3 + 40);
  return re::DynamicArray<unsigned long>::deinit(a3);
}

double re::internal::defaultConstructV2<re::BlendTreeDefinition>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 320) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 180) = 0u;
  *(_DWORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_DWORD *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_DWORD *)(a1 + 312) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::BlendTreeDefinition>(uint64_t a1)
{
  re::DynamicArray<unsigned long>::deinit(a1 + 288);
  re::DynamicArray<unsigned long>::deinit(a1 + 248);
  re::DynamicArray<unsigned long>::deinit(a1 + 208);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a1 + 168);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a1 + 120);
  re::DynamicArray<unsigned long>::deinit(a1 + 80);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a1 + 40);
  return re::DynamicArray<unsigned long>::deinit(a1);
}

uint64_t re::introspect_BlendTreeDefinition(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"BlendTreeDefinition", (uint64_t (*)(re::internal *))re::allocInfo_BlendTreeDefinition, (re::IntrospectionBase *(*)(void))re::initInfo_BlendTreeDefinition, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::BlendTreeDefinition>, this);
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionDynamicArray<unsigned int>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<unsigned int>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<unsigned int>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<unsigned int>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<unsigned int>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  double result = re::DynamicArray<int>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<unsigned int>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<int>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<float>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<int>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<unsigned int>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  int v10 = 0;
  re::DynamicArray<int>::add(this, &v10);
  v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 4 * *((void *)this + 2) - 4);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<unsigned int>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<unsigned int>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 4 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 4 * a3;
}

void *re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  double result = re::DynamicArray<int>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<int>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<float>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      int v10 = *(char **)(a1 + 32);
      uint64_t v11 = 4 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 4;
        v11 -= 4;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 4 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 4 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::BlendParameterInputNode>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BlendParameterInputNode>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::BlendParameterInputNode>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BlendParameterInputNode>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::BlendParameterInputNode>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::BlendParameterInputNode>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::BlendParameterInputNode>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BlendParameterInputNode>::addElement(uint64_t a1, re *a2, int a3, uint64_t a4)
{
  uint64_t v20 = 0;
  v21 = 0;
  uint64_t v22 = 0;
  v8 = re::StringID::invalid((re::StringID *)&v20);
  LODWORD(v22) = -1;
  unint64_t v9 = *(void *)(a4 + 8);
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= v9)
  {
    unint64_t v11 = v10 + 1;
    if (v9 < v10 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v12 = 2 * v9;
        BOOL v13 = v9 == 0;
        unint64_t v14 = 8;
        if (!v13) {
          unint64_t v14 = v12;
        }
        if (v14 <= v11) {
          unint64_t v15 = v11;
        }
        else {
          unint64_t v15 = v14;
        }
        re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a4, v15);
      }
      else
      {
        re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a4, v11);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v10 = *(void *)(a4 + 16);
  }
  uint64_t v16 = *(void *)(a4 + 32) + 24 * v10;
  char v17 = v20;
  *(void *)uint64_t v16 = *(void *)v16 & 0xFFFFFFFFFFFFFFFELL | v20 & 1;
  *(void *)uint64_t v16 = v20 & 0xFFFFFFFFFFFFFFFELL | v17 & 1;
  *(void *)(v16 + 8) = v21;
  uint64_t v20 = 0;
  v21 = "";
  *(_DWORD *)(v16 + 16) = v22;
  ++*(void *)(a4 + 16);
  ++*(_DWORD *)(a4 + 24);
  re::StringID::destroyString((re::StringID *)&v20);
  v18 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 24 * *(void *)(a4 + 16) - 24);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v18);
  return v18;
}

uint64_t re::IntrospectionDynamicArray<re::BlendParameterInputNode>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BlendParameterInputNode>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 24 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 24 * a3;
}

void *re::DynamicArray<re::BlendParameterInputNode>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::BlendParameterInputNode>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x18uLL))
        {
          uint64_t v2 = 24 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = &v8[3 * v9];
        unint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *unint64_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *unint64_t v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          uint64_t *v8 = 0;
          v8[1] = (uint64_t)"";
          *((_DWORD *)v11 + 4) = *((_DWORD *)v8 + 4);
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 3;
          v11 += 3;
        }
        while (v8 != v10);
        v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::DynamicArray<re::BlendParameterInputNode>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 24 * a2;
    unint64_t v9 = a2;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(void *)(a1 + 32) + v8));
      ++v9;
      v8 += 24;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 24 * v4;
      do
      {
        v7 = (re::StringID *)(*(void *)(a1 + 32) + v6);
        re::StringID::invalid(v7);
        *((_DWORD *)v7 + 4) = -1;
        v6 += 24;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    if (v8)
    {
      unint64_t v9 = *(re::StringID **)(a1 + 32);
      uint64_t v10 = 24 * v8;
      do
      {
        re::StringID::destroyString(v9);
        unint64_t v9 = (re::StringID *)((char *)v9 + 24);
        v10 -= 24;
      }
      while (v10);
    }
  }
  else
  {
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::BlendParameterInputNode>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v16);
    re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v17);
    uint64_t v12 = *(void *)(a1 + 16);
    if (v12)
    {
      BOOL v13 = *(char **)(a1 + 32);
      uint64_t v14 = 24 * v12;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v15, v13, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v15, (void **)v13, a3, 0);
        v13 += 24;
        v14 -= 24;
      }
      while (v14);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 24 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 24 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::BlendValueInputNode>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BlendValueInputNode>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::BlendValueInputNode>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BlendValueInputNode>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::BlendValueInputNode>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::BlendValueInputNode>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::BlendValueInputNode>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BlendValueInputNode>::addElement(uint64_t a1, re *a2, int a3, uint64_t a4)
{
  uint64_t v20 = 0;
  v21 = 0;
  uint64_t v22 = 0;
  uint64_t v8 = re::StringID::invalid((re::StringID *)&v20);
  LODWORD(v22) = 0;
  unint64_t v9 = *(void *)(a4 + 8);
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= v9)
  {
    unint64_t v11 = v10 + 1;
    if (v9 < v10 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v12 = 2 * v9;
        BOOL v13 = v9 == 0;
        unint64_t v14 = 8;
        if (!v13) {
          unint64_t v14 = v12;
        }
        if (v14 <= v11) {
          unint64_t v15 = v11;
        }
        else {
          unint64_t v15 = v14;
        }
        re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a4, v15);
      }
      else
      {
        re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a4, v11);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v10 = *(void *)(a4 + 16);
  }
  uint64_t v16 = *(void *)(a4 + 32) + 24 * v10;
  char v17 = v20;
  *(void *)uint64_t v16 = *(void *)v16 & 0xFFFFFFFFFFFFFFFELL | v20 & 1;
  *(void *)uint64_t v16 = v20 & 0xFFFFFFFFFFFFFFFELL | v17 & 1;
  *(void *)(v16 + 8) = v21;
  uint64_t v20 = 0;
  v21 = "";
  *(_DWORD *)(v16 + 16) = v22;
  ++*(void *)(a4 + 16);
  ++*(_DWORD *)(a4 + 24);
  re::StringID::destroyString((re::StringID *)&v20);
  v18 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 24 * *(void *)(a4 + 16) - 24);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v18);
  return v18;
}

uint64_t re::IntrospectionDynamicArray<re::BlendValueInputNode>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BlendValueInputNode>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 24 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 24 * a3;
}

void re::DynamicArray<re::BlendValueInputNode>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    uint64_t v8 = 24 * a2;
    unint64_t v9 = a2;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(void *)(a1 + 32) + v8));
      ++v9;
      v8 += 24;
    }
    while (v9 < *(void *)(a1 + 16));
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    unint64_t v5 = a2 - v4;
    if (a2 > v4)
    {
      uint64_t v6 = 24 * v4;
      do
      {
        v7 = (re::StringID *)(*(void *)(a1 + 32) + v6);
        re::StringID::invalid(v7);
        *((_DWORD *)v7 + 4) = 0;
        v6 += 24;
        --v5;
      }
      while (v5);
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    if (v8)
    {
      unint64_t v9 = *(re::StringID **)(a1 + 32);
      uint64_t v10 = 24 * v8;
      do
      {
        re::StringID::destroyString(v9);
        unint64_t v9 = (re::StringID *)((char *)v9 + 24);
        v10 -= 24;
      }
      while (v10);
    }
  }
  else
  {
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::BlendValueInputNode>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v16);
    re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v17);
    uint64_t v12 = *(void *)(a1 + 16);
    if (v12)
    {
      BOOL v13 = *(char **)(a1 + 32);
      uint64_t v14 = 24 * v12;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v15, v13, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v15, (void **)v13, a3, 0);
        v13 += 24;
        v14 -= 24;
      }
      while (v14);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 24 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 24 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::BlendNode>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BlendNode>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::BlendNode>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BlendNode>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::BlendNode>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::BlendNode>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void *re::IntrospectionDynamicArray<re::BlendNode>::resize(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v9 = result;
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    uint64_t result = re::DynamicArray<re::BlendNode>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      return re::DynamicArray<re::BlendNode>::resize((void *)a4, a5);
    }
  }
  else
  {
    uint64_t result = re::DynamicArray<re::BlendNode>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BlendNode>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(a4 + 8);
  unint64_t v9 = *(void *)(a4 + 16);
  if (v9 >= v8)
  {
    unint64_t v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(void *)a4)
      {
        uint64_t v11 = 2 * v8;
        BOOL v12 = v8 == 0;
        unint64_t v13 = 8;
        if (!v12) {
          unint64_t v13 = v11;
        }
        if (v13 <= v10) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v13;
        }
        re::DynamicArray<re::BlendNode>::setCapacity((void *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::BlendNode>::setCapacity((void *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    unint64_t v9 = *(void *)(a4 + 16);
  }
  unint64_t v15 = (void *)(*(void *)(a4 + 32) + 16 * v9);
  *unint64_t v15 = 0;
  v15[1] = 0;
  uint64_t v16 = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v16 + 1;
  ++*(_DWORD *)(a4 + 24);
  uint64_t v17 = (re::IntrospectionBase *)(*(void *)(a4 + 32) + 16 * v16);
  re::introspectionInitElement(a2, a3, a1[6], v17);
  return v17;
}

uint64_t re::IntrospectionDynamicArray<re::BlendNode>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BlendNode>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

void *re::DynamicArray<re::BlendNode>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 16 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 4);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 16 * v5[2]);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::BlendNode>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void *re::DynamicArray<re::BlendNode>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else
  {
    if (result[1] < a2)
    {
      uint64_t result = re::DynamicArray<re::BlendNode>::setCapacity(result, a2);
      unint64_t v4 = v3[2];
    }
    if (v4 < a2)
    {
      uint64_t v5 = v3[4];
      uint64_t v6 = v5 + 16 * v4;
      uint64_t v7 = v5 + 16 * a2 - v6;
      if (v7 >= 1)
      {
        unint64_t v8 = ((unint64_t)v7 >> 4) + 1;
        do
        {
          *(unsigned char *)uint64_t v6 = 0;
          *(void *)(v6 + 8) = 0;
          *(_DWORD *)(v6 + 4) = 0;
          --v8;
          v6 += 16;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::BlendNode>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::BlendNode>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  unint64_t v8 = (_anonymous_namespace_ *)re::DynamicArray<re::BlendNode>::resize((void *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 16 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 16;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 16 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

uint64_t *re::IntrospectionInfo<re::FixedArray<int>>::get(int a1, const re::IntrospectionBase *a2)
{
  {
    re::IntrospectionFixedArrayBase::IntrospectionFixedArrayBase((re::IntrospectionFixedArrayBase *)&re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info);
    re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info = (uint64_t)&unk_26E6C42C8;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    int v3 = re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3) {
      return &re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  uint64_t v6 = (re *)re::introspect_int((re *)1, a2);
  if (re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    uint64_t v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::isInitialized = 1;
    int v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info, 0);
    qword_268772420 = 0x1800000004;
    dword_268772428 = v10;
    word_26877242C = 0;
    *(void *)&xmmword_268772430 = 0;
    *((void *)&xmmword_268772430 + 1) = 0xFFFFFFFFLL;
    qword_268772440 = v9;
    unk_268772448 = 0;
    re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info = (uint64_t)&unk_26E6C42C8;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if (BYTE8(v15)) {
      unint64_t v13 = v16;
    }
    else {
      unint64_t v13 = (char *)&v15 + 9;
    }
    if (void)v15 && (BYTE8(v15)) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    long long v15 = *(_OWORD *)(v9 + 32);
    xmmword_268772430 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(int a1)
{
  {
    re::IntrospectionFixedArrayBase::IntrospectionFixedArrayBase((re::IntrospectionFixedArrayBase *)&re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info);
    re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info = (uint64_t)&unk_26E6C4360;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    int v2 = re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    if (v2) {
      return &re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info;
    }
    unint64_t v4 = re::introspectionSharedMutex(v3);
    std::__shared_mutex_base::lock(v4);
  }
  uint64_t v5 = (re *)re::introspect_Vector3F((re::IntrospectionBase **)1);
  if (re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v6 = re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(v6);
    }
  }
  else
  {
    uint64_t v8 = (uint64_t)v5;
    re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::isInitialized = 1;
    int v9 = *((_DWORD *)v5 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info, 0);
    qword_268772470 = 0x1800000004;
    dword_268772478 = v9;
    word_26877247C = 0;
    *(void *)&xmmword_268772480 = 0;
    *((void *)&xmmword_268772480 + 1) = 0xFFFFFFFFLL;
    qword_268772490 = v8;
    unk_268772498 = 0;
    re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info = (uint64_t)&unk_26E6C4360;
    re::IntrospectionRegistry::add(v10, v11);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info, (const re::IntrospectionBase *)&v14);
    if (BYTE8(v14)) {
      BOOL v12 = v15;
    }
    else {
      BOOL v12 = (char *)&v14 + 9;
    }
    if (void)v14 && (BYTE8(v14)) {
      (*(void (**)(void))(*(void *)v14 + 40))();
    }
    long long v14 = *(_OWORD *)(v8 + 32);
    xmmword_268772480 = v13;
    re::StringID::destroyString((re::StringID *)v16);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info;
}

void *re::allocInfo_DynamicRegisterTable(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74338, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF74338))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF744D8, "DynamicRegisterTable");
    __cxa_guard_release(&qword_26AF74338);
  }
  return &unk_26AF744D8;
}

void re::initInfo_DynamicRegisterTable(re *this, re::IntrospectionBase *a2)
{
  v32[0] = 0x52D273DBBD26DA18;
  v32[1] = "DynamicRegisterTable";
  re::StringID::destroyString((re::StringID *)v32);
  *((_OWORD *)this + 2) = v33;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74340, memory_order_acquire) & 1) == 0)
  {
    unint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF74340);
    if (v4)
    {
      uint64_t v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::IntrospectionInfo<re::DynamicArray<int>>::get(1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "registerInt32s";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF74370 = v8;
      int v9 = re::introspectionAllocator((re *)v8);
      uint64_t v11 = re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "registerUInt32s";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x2800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF74378 = v12;
      long long v13 = re::introspectionAllocator((re *)v12);
      long long v15 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "registerFloats";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x5000000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF74380 = v16;
      uint64_t v17 = re::introspectionAllocator((re *)v16);
      re::IntrospectionInfo<re::DynamicArray<re::Matrix3x3<float>>>::get();
      uint64_t v18 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v18 = 1;
      *(void *)(v18 + 8) = "registerMatrix3x3s";
      *(void *)(v18 + 16) = qword_26AF743B0;
      *(void *)(v18 + 24) = 0;
      *(void *)(v18 + 32) = 0x7800000004;
      *(_DWORD *)(v18 + 40) = 0;
      *(void *)(v18 + 48) = 0;
      *(void *)(v18 + 56) = 0;
      *(_DWORD *)(v18 + 64) = 0;
      qword_26AF74388 = v18;
      v19 = re::introspectionAllocator((re *)v18);
      uint64_t v20 = re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(1);
      uint64_t v21 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v19 + 32))(v19, 72, 8);
      *(_DWORD *)uint64_t v21 = 1;
      *(void *)(v21 + 8) = "registerMatrix4x4s";
      *(void *)(v21 + 16) = v20;
      *(void *)(v21 + 24) = 0;
      *(void *)(v21 + 32) = 0xA000000005;
      *(_DWORD *)(v21 + 40) = 0;
      *(void *)(v21 + 48) = 0;
      *(void *)(v21 + 56) = 0;
      *(_DWORD *)(v21 + 64) = 0;
      qword_26AF74390 = v21;
      uint64_t v22 = re::introspectionAllocator((re *)v21);
      v23 = re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(1);
      uint64_t v24 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v22 + 32))(v22, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "registerQuaternions";
      *(void *)(v24 + 16) = v23;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0xC800000006;
      *(_DWORD *)(v24 + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_26AF74398 = v24;
      v25 = re::introspectionAllocator((re *)v24);
      v26 = re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(1);
      uint64_t v27 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 72, 8);
      *(_DWORD *)uint64_t v27 = 1;
      *(void *)(v27 + 8) = "registerVector2s";
      *(void *)(v27 + 16) = v26;
      *(void *)(v27 + 24) = 0;
      *(void *)(v27 + 32) = 0xF000000007;
      *(_DWORD *)(v27 + 40) = 0;
      *(void *)(v27 + 48) = 0;
      *(void *)(v27 + 56) = 0;
      *(_DWORD *)(v27 + 64) = 0;
      qword_26AF743A0 = v27;
      v28 = re::introspectionAllocator((re *)v27);
      v29 = re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(1);
      uint64_t v30 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v28 + 32))(v28, 72, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *(void *)(v30 + 8) = "registerVector3s";
      *(void *)(v30 + 16) = v29;
      *(void *)(v30 + 24) = 0;
      *(void *)(v30 + 32) = 0x11800000008;
      *(_DWORD *)(v30 + 40) = 0;
      *(void *)(v30 + 48) = 0;
      *(void *)(v30 + 56) = 0;
      *(_DWORD *)(v30 + 64) = 0;
      qword_26AF743A8 = v30;
      __cxa_guard_release(&qword_26AF74340);
    }
  }
  *((void *)this + 2) = 0x14000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 8;
  *((void *)this + 8) = &qword_26AF74370;
  *((void *)this + 9) = re::internal::defaultConstruct<re::DynamicRegisterTable>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::DynamicRegisterTable>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::DynamicRegisterTable>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::DynamicRegisterTable>;
  re::IntrospectionRegistry::add(this, v3);
  long long v31 = v33;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<int>>::get(int a1, const re::IntrospectionBase *a2)
{
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info = (uint64_t)&unk_26E6C43F8;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    int v3 = re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3) {
      return &re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  uint64_t v6 = (re *)re::introspect_int((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    uint64_t v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::isInitialized = 1;
    int v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info, 0);
    qword_2687724C0 = 0x2800000003;
    dword_2687724C8 = v10;
    word_2687724CC = 0;
    *(void *)&xmmword_2687724D0 = 0;
    *((void *)&xmmword_2687724D0 + 1) = 0xFFFFFFFFLL;
    qword_2687724E0 = v9;
    unk_2687724E8 = 0;
    re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info = (uint64_t)&unk_26E6C43F8;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if (BYTE8(v15)) {
      long long v13 = v16;
    }
    else {
      long long v13 = (char *)&v15 + 9;
    }
    if (void)v15 && (BYTE8(v15)) {
      (*(void (**)(void))(*(void *)v15 + 40))();
    }
    long long v15 = *(_OWORD *)(v9 + 32);
    xmmword_2687724D0 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info;
}

void re::IntrospectionInfo<re::DynamicArray<re::Matrix3x3<float>>>::get()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74368, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF74368))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)qword_26AF743B0);
    qword_26AF743B0[0] = (uint64_t)&unk_26E6C4490;
    __cxa_guard_release(&qword_26AF74368);
  }
  if ((byte_26AF74332 & 1) == 0)
  {
    uint64_t v0 = re::introspect_Matrix3x3F((re::IntrospectionBase **)1);
    if ((byte_26AF74332 & 1) == 0)
    {
      uint64_t v1 = v0;
      byte_26AF74332 = 1;
      int v2 = *(_DWORD *)(v0 + 24);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)qword_26AF743B0, 0);
      unk_26AF743C0 = 0x2800000003;
      unk_26AF743C8 = v2;
      word_26AF743CC = 0;
      *(void *)&xmmword_26AF743D0 = 0;
      *((void *)&xmmword_26AF743D0 + 1) = 0xFFFFFFFFLL;
      unk_26AF743E0 = v1;
      unk_26AF743E8 = 0;
      qword_26AF743B0[0] = (uint64_t)&unk_26E6C4490;
      re::IntrospectionRegistry::add(v3, v4);
      re::getPrettyTypeName((re *)qword_26AF743B0, (const re::IntrospectionBase *)&v13);
      if (v14) {
        uint64_t v5 = *(const char **)&v15[7];
      }
      else {
        uint64_t v5 = v15;
      }
      if (v13 && (v14 & 1) != 0) {
        (*(void (**)(void))(*(void *)v13 + 40))();
      }
      long long v10 = *(_OWORD *)(v1 + 32);
      uint64_t v6 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v11);
      if (v6)
      {
        uint64_t v7 = *v6;
        *((void *)&v9 + 1) = v7;
      }
      else
      {
        long long v12 = v10;
        re::TypeBuilder::beginListType((uint64_t)&v13, v11, 1, 0x28uLL, 8uLL, &v12);
        re::TypeBuilder::setConstructor((uint64_t)&v13, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v13, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v13, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v13, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v13, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v13, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v13, v8);
      }
      xmmword_26AF743D0 = v9;
      re::StringID::destroyString((re::StringID *)v11);
    }
  }
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(int a1)
{
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info = (uint64_t)&unk_26E6C4528;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    int v2 = re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    if (v2) {
      return &re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info;
    }
    unint64_t v4 = re::introspectionSharedMutex(v3);
    std::__shared_mutex_base::lock(v4);
  }
  uint64_t v5 = (re *)re::introspect_Matrix4x4F((re::IntrospectionBase **)1);
  if (re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v6 = re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(v6);
    }
  }
  else
  {
    uint64_t v8 = (uint64_t)v5;
    re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::isInitialized = 1;
    int v9 = *((_DWORD *)v5 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info, 0);
    qword_268772510 = 0x2800000003;
    dword_268772518 = v9;
    word_26877251C = 0;
    *(void *)&xmmword_268772520 = 0;
    *((void *)&xmmword_268772520 + 1) = 0xFFFFFFFFLL;
    qword_268772530 = v8;
    unk_268772538 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info = (uint64_t)&unk_26E6C4528;
    re::IntrospectionRegistry::add(v10, v11);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info, (const re::IntrospectionBase *)&v14);
    if (BYTE8(v14)) {
      long long v12 = v15;
    }
    else {
      long long v12 = (char *)&v14 + 9;
    }
    if (void)v14 && (BYTE8(v14)) {
      (*(void (**)(void))(*(void *)v14 + 40))();
    }
    long long v14 = *(_OWORD *)(v8 + 32);
    xmmword_268772520 = v13;
    re::StringID::destroyString((re::StringID *)v16);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(int a1)
{
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info = (uint64_t)&unk_26E6C45C0;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    int v2 = re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    if (v2) {
      return &re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info;
    }
    unint64_t v4 = re::introspectionSharedMutex(v3);
    std::__shared_mutex_base::lock(v4);
  }
  uint64_t v5 = (re *)re::introspect_QuaternionF((re::IntrospectionBase **)1);
  if (re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v6 = re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(v6);
    }
  }
  else
  {
    uint64_t v8 = (uint64_t)v5;
    re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::isInitialized = 1;
    int v9 = *((_DWORD *)v5 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info, 0);
    qword_268772560 = 0x2800000003;
    dword_268772568 = v9;
    word_26877256C = 0;
    *(void *)&xmmword_268772570 = 0;
    *((void *)&xmmword_268772570 + 1) = 0xFFFFFFFFLL;
    qword_268772580 = v8;
    unk_268772588 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info = (uint64_t)&unk_26E6C45C0;
    re::IntrospectionRegistry::add(v10, v11);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info, (const re::IntrospectionBase *)&v14);
    if (BYTE8(v14)) {
      long long v12 = v15;
    }
    else {
      long long v12 = (char *)&v14 + 9;
    }
    if (void)v14 && (BYTE8(v14)) {
      (*(void (**)(void))(*(void *)v14 + 40))();
    }
    long long v14 = *(_OWORD *)(v8 + 32);
    xmmword_268772570 = v13;
    re::StringID::destroyString((re::StringID *)v16);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(int a1)
{
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info = (uint64_t)&unk_26E6C4658;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    int v2 = re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    if (v2) {
      return &re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info;
    }
    unint64_t v4 = re::introspectionSharedMutex(v3);
    std::__shared_mutex_base::lock(v4);
  }
  uint64_t v5 = (re *)re::introspect_Vector2F((re::IntrospectionBase **)1);
  if (re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v6 = re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(v6);
    }
  }
  else
  {
    uint64_t v8 = (uint64_t)v5;
    re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::isInitialized = 1;
    int v9 = *((_DWORD *)v5 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info, 0);
    qword_2687725B0 = 0x2800000003;
    dword_2687725B8 = v9;
    word_2687725BC = 0;
    *(void *)&xmmword_2687725C0 = 0;
    *((void *)&xmmword_2687725C0 + 1) = 0xFFFFFFFFLL;
    qword_2687725D0 = v8;
    unk_2687725D8 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info = (uint64_t)&unk_26E6C4658;
    re::IntrospectionRegistry::add(v10, v11);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info, (const re::IntrospectionBase *)&v14);
    if (BYTE8(v14)) {
      long long v12 = v15;
    }
    else {
      long long v12 = (char *)&v14 + 9;
    }
    if (void)v14 && (BYTE8(v14)) {
      (*(void (**)(void))(*(void *)v14 + 40))();
    }
    long long v14 = *(_OWORD *)(v8 + 32);
    xmmword_2687725C0 = v13;
    re::StringID::destroyString((re::StringID *)v16);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(int a1)
{
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info = (uint64_t)&unk_26E6C46F0;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::isInitialized) {
      return &re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    int v2 = re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v14);
    if (v2) {
      return &re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info;
    }
    unint64_t v4 = re::introspectionSharedMutex(v3);
    std::__shared_mutex_base::lock(v4);
  }
  uint64_t v5 = (re *)re::introspect_Vector3F((re::IntrospectionBase **)1);
  if (re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      uint64_t v6 = re::introspectionSharedMutex(v5);
      std::__shared_mutex_base::unlock(v6);
    }
  }
  else
  {
    uint64_t v8 = (uint64_t)v5;
    re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::isInitialized = 1;
    int v9 = *((_DWORD *)v5 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info, 0);
    qword_268772600 = 0x2800000003;
    dword_268772608 = v9;
    word_26877260C = 0;
    *(void *)&xmmword_268772610 = 0;
    *((void *)&xmmword_268772610 + 1) = 0xFFFFFFFFLL;
    qword_268772620 = v8;
    unk_268772628 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info = (uint64_t)&unk_26E6C46F0;
    re::IntrospectionRegistry::add(v10, v11);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info, (const re::IntrospectionBase *)&v14);
    if (BYTE8(v14)) {
      long long v12 = v15;
    }
    else {
      long long v12 = (char *)&v14 + 9;
    }
    if (void)v14 && (BYTE8(v14)) {
      (*(void (**)(void))(*(void *)v14 + 40))();
    }
    long long v14 = *(_OWORD *)(v8 + 32);
    xmmword_268772610 = v13;
    re::StringID::destroyString((re::StringID *)v16);
    if ((a1 & 1) == 0) {
      goto LABEL_9;
    }
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::DynamicRegisterTable>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 312) = 0;
  double result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_DWORD *)(a3 + 144) = 0;
  *(_OWORD *)(a3 + 152) = 0u;
  *(_OWORD *)(a3 + 168) = 0u;
  *(_DWORD *)(a3 + 184) = 0;
  *(_DWORD *)(a3 + 224) = 0;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_DWORD *)(a3 + 264) = 0;
  *(_OWORD *)(a3 + 248) = 0u;
  *(_OWORD *)(a3 + 232) = 0u;
  *(_DWORD *)(a3 + 304) = 0;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  return result;
}

uint64_t re::internal::defaultDestruct<re::DynamicRegisterTable>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a3 + 280);
  re::DynamicArray<unsigned long>::deinit(a3 + 240);
  re::DynamicArray<unsigned long>::deinit(a3 + 200);
  re::DynamicArray<unsigned long>::deinit(a3 + 160);
  re::DynamicArray<unsigned long>::deinit(a3 + 120);
  re::DynamicArray<unsigned long>::deinit(a3 + 80);
  re::DynamicArray<unsigned long>::deinit(a3 + 40);
  return re::DynamicArray<unsigned long>::deinit(a3);
}

double re::internal::defaultConstructV2<re::DynamicRegisterTable>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 312) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_DWORD *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::DynamicRegisterTable>(uint64_t a1)
{
  re::DynamicArray<unsigned long>::deinit(a1 + 280);
  re::DynamicArray<unsigned long>::deinit(a1 + 240);
  re::DynamicArray<unsigned long>::deinit(a1 + 200);
  re::DynamicArray<unsigned long>::deinit(a1 + 160);
  re::DynamicArray<unsigned long>::deinit(a1 + 120);
  re::DynamicArray<unsigned long>::deinit(a1 + 80);
  re::DynamicArray<unsigned long>::deinit(a1 + 40);
  return re::DynamicArray<unsigned long>::deinit(a1);
}

uint64_t re::introspect_DynamicRegisterTable(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"DynamicRegisterTable", (uint64_t (*)(re::internal *))re::allocInfo_DynamicRegisterTable, (re::IntrospectionBase *(*)(void))re::initInfo_DynamicRegisterTable, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::DynamicRegisterTable>, this);
}

uint64_t *re::introspect_EvaluationRegisterType(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74348, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF74348);
    if (v31)
    {
      v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "EvaluationRegisterTypeInt32";
      qword_26AF74480 = (uint64_t)v33;
      v34 = re::introspectionAllocator(v33);
      v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)v35 = 1;
      *((void *)v35 + 1) = 1;
      *((void *)v35 + 2) = "EvaluationRegisterTypeUInt32";
      qword_26AF74488 = (uint64_t)v35;
      v36 = re::introspectionAllocator(v35);
      v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)v37 = 1;
      *((void *)v37 + 1) = 2;
      *((void *)v37 + 2) = "EvaluationRegisterTypeFloat";
      qword_26AF74490 = (uint64_t)v37;
      v38 = re::introspectionAllocator(v37);
      v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)v39 = 1;
      *((void *)v39 + 1) = 3;
      *((void *)v39 + 2) = "EvaluationRegisterTypeMatrix3x3";
      qword_26AF74498 = (uint64_t)v39;
      v40 = re::introspectionAllocator(v39);
      v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)v41 = 1;
      *((void *)v41 + 1) = 4;
      *((void *)v41 + 2) = "EvaluationRegisterTypeMatrix4x4";
      qword_26AF744A0 = (uint64_t)v41;
      v42 = re::introspectionAllocator(v41);
      v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)v43 = 1;
      *((void *)v43 + 1) = 5;
      *((void *)v43 + 2) = "EvaluationRegisterTypeQuaternion";
      qword_26AF744A8 = (uint64_t)v43;
      v44 = re::introspectionAllocator(v43);
      v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)v45 = 1;
      *((void *)v45 + 1) = 6;
      *((void *)v45 + 2) = "EvaluationRegisterTypeVector2";
      qword_26AF744B0 = (uint64_t)v45;
      v46 = re::introspectionAllocator(v45);
      v47 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)v47 = 1;
      *((void *)v47 + 1) = 7;
      *((void *)v47 + 2) = "EvaluationRegisterTypeVector3";
      qword_26AF744B8 = (uint64_t)v47;
      v48 = re::introspectionAllocator(v47);
      v49 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v48 + 32))(v48, 24, 8);
      *(_DWORD *)v49 = 1;
      *((void *)v49 + 1) = 8;
      *((void *)v49 + 2) = "EvaluationRegisterTypeCount";
      qword_26AF744C0 = (uint64_t)v49;
      v50 = re::introspectionAllocator(v49);
      v51 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v50 + 32))(v50, 24, 8);
      *(_DWORD *)v51 = 1;
      *((void *)v51 + 1) = 255;
      *((void *)v51 + 2) = "EvaluationRegisterTypeUnknown";
      qword_26AF744C8 = (uint64_t)v51;
      v52 = re::introspectionAllocator(v51);
      uint64_t v53 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v52 + 32))(v52, 24, 8);
      *(_DWORD *)uint64_t v53 = 1;
      *(void *)(v53 + 8) = 254;
      *(void *)(v53 + 16) = "EvaluationRegisterTypeCallback";
      qword_26AF744D0 = v53;
      __cxa_guard_release(&qword_26AF74348);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74350, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF74350))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF743F0, "EvaluationRegisterType", 1, 1, 1, 1);
    qword_26AF743F0 = (uint64_t)&unk_26E715E00;
    qword_26AF74430 = (uint64_t)&re::introspect_EvaluationRegisterType(BOOL)::enumTable;
    dword_26AF74400 = 9;
    __cxa_guard_release(&qword_26AF74350);
  }
  if (v2)
  {
    if (_MergedGlobals_24) {
      return &qword_26AF743F0;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v59);
    char v3 = _MergedGlobals_24;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v59);
    if (v3) {
      return &qword_26AF743F0;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (_MergedGlobals_24)
    {
LABEL_34:
      v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF743F0;
    }
  }
  _MergedGlobals_24 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF743F0, a2);
  uint64_t v55 = 0x79BBFE2840B26BF2;
  v56 = "EvaluationRegisterType";
  v59[0] = 0x31CD534126;
  v59[1] = "uint8_t";
  uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v59);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v59);
    int v9 = (unsigned int *)qword_26AF74430;
    v58[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v59, &v55, 1, 1, (uint64_t)v58);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          long long v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                uint64_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v57.var0 = 2 * v15;
          v57.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v59, v19, &v57);
          re::StringID::destroyString((re::StringID *)&v57);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            uint64_t v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v57.var0 = 2 * v23;
            v57.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v59, v27, &v57);
            re::StringID::destroyString((re::StringID *)&v57);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v59, v28);
    xmmword_26AF74410 = (__int128)v57;
    re::StringID::destroyString((re::StringID *)&v55);
    if (v2) {
      return &qword_26AF743F0;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v59);
  re::internal::assertLog((re::internal *)5, v54, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "EvaluationRegisterType", v55, v56);
  double result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t *re::introspect_EvaluationCommand(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74358, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF74358);
    if (v31)
    {
      v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 8;
      *((void *)v33 + 2) = "AddVector3";
      qword_26AF74550 = (uint64_t)v33;
      v34 = re::introspectionAllocator(v33);
      v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)v35 = 1;
      *((void *)v35 + 1) = 9;
      *((void *)v35 + 2) = "AddVector2";
      qword_26AF74558 = (uint64_t)v35;
      v36 = re::introspectionAllocator(v35);
      v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)v37 = 1;
      *((void *)v37 + 1) = 10;
      *((void *)v37 + 2) = "ComponentLerpVector3";
      qword_26AF74560 = (uint64_t)v37;
      v38 = re::introspectionAllocator(v37);
      v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)v39 = 1;
      *((void *)v39 + 1) = 11;
      *((void *)v39 + 2) = "LerpVector3";
      qword_26AF74568 = (uint64_t)v39;
      v40 = re::introspectionAllocator(v39);
      v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)v41 = 1;
      *((void *)v41 + 1) = 12;
      *((void *)v41 + 2) = "SlerpQuaternion";
      qword_26AF74570 = (uint64_t)v41;
      v42 = re::introspectionAllocator(v41);
      v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)v43 = 1;
      *((void *)v43 + 1) = 13;
      *((void *)v43 + 2) = "ConvertIntrinsicEulerToQuaternion";
      qword_26AF74578 = (uint64_t)v43;
      v44 = re::introspectionAllocator(v43);
      v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)v45 = 1;
      *((void *)v45 + 1) = 14;
      *((void *)v45 + 2) = "ConvertQuaternionToIntrinsicEuler";
      qword_26AF74580 = (uint64_t)v45;
      v46 = re::introspectionAllocator(v45);
      v47 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)v47 = 1;
      *((void *)v47 + 1) = 15;
      *((void *)v47 + 2) = "CrossVector3";
      qword_26AF74588 = (uint64_t)v47;
      v48 = re::introspectionAllocator(v47);
      v49 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v48 + 32))(v48, 24, 8);
      *(_DWORD *)v49 = 1;
      *((void *)v49 + 1) = 16;
      *((void *)v49 + 2) = "DivideQuaternion";
      qword_26AF74590 = (uint64_t)v49;
      v50 = re::introspectionAllocator(v49);
      v51 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v50 + 32))(v50, 24, 8);
      *(_DWORD *)v51 = 1;
      *((void *)v51 + 1) = 18;
      *((void *)v51 + 2) = "ConjugateQuaternion";
      qword_26AF74598 = (uint64_t)v51;
      v52 = re::introspectionAllocator(v51);
      uint64_t v53 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v52 + 32))(v52, 24, 8);
      *(_DWORD *)uint64_t v53 = 1;
      *((void *)v53 + 1) = 19;
      *((void *)v53 + 2) = "InvertMatrix3x3";
      qword_26AF745A0 = (uint64_t)v53;
      uint64_t v54 = re::introspectionAllocator(v53);
      uint64_t v55 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v54 + 32))(v54, 24, 8);
      *(_DWORD *)uint64_t v55 = 1;
      *((void *)v55 + 1) = 20;
      *((void *)v55 + 2) = "InvertMatrix4x4";
      qword_26AF745A8 = (uint64_t)v55;
      v56 = re::introspectionAllocator(v55);
      StringID v57 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v56 + 32))(v56, 24, 8);
      *(_DWORD *)StringID v57 = 1;
      *((void *)v57 + 1) = 21;
      *((void *)v57 + 2) = "InvertQuaternion";
      qword_26AF745B0 = (uint64_t)v57;
      v58 = re::introspectionAllocator(v57);
      v59 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v58 + 32))(v58, 24, 8);
      *(_DWORD *)v59 = 1;
      *((void *)v59 + 1) = 22;
      *((void *)v59 + 2) = "DotVector3";
      qword_26AF745B8 = (uint64_t)v59;
      v60 = re::introspectionAllocator(v59);
      v61 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v60 + 32))(v60, 24, 8);
      *(_DWORD *)v61 = 1;
      *((void *)v61 + 1) = 23;
      *((void *)v61 + 2) = "DotVector2";
      qword_26AF745C0 = (uint64_t)v61;
      v62 = re::introspectionAllocator(v61);
      v63 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v62 + 32))(v62, 24, 8);
      *(_DWORD *)v63 = 1;
      *((void *)v63 + 1) = 24;
      *((void *)v63 + 2) = "MultiplyQuaternion";
      qword_26AF745C8 = (uint64_t)v63;
      v64 = re::introspectionAllocator(v63);
      v65 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v64 + 32))(v64, 24, 8);
      *(_DWORD *)v65 = 1;
      *((void *)v65 + 1) = 25;
      *((void *)v65 + 2) = "MultiplyVector3";
      qword_26AF745D0 = (uint64_t)v65;
      v66 = re::introspectionAllocator(v65);
      v67 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v66 + 32))(v66, 24, 8);
      *(_DWORD *)v67 = 1;
      *((void *)v67 + 1) = 27;
      *((void *)v67 + 2) = "MultiplyMatrix3x3";
      qword_26AF745D8 = (uint64_t)v67;
      v68 = re::introspectionAllocator(v67);
      v69 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v68 + 32))(v68, 24, 8);
      *(_DWORD *)v69 = 1;
      *((void *)v69 + 1) = 28;
      *((void *)v69 + 2) = "MultiplyMatrix4x4";
      qword_26AF745E0 = (uint64_t)v69;
      v70 = re::introspectionAllocator(v69);
      v71 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v70 + 32))(v70, 24, 8);
      *(_DWORD *)v71 = 1;
      *((void *)v71 + 1) = 29;
      *((void *)v71 + 2) = "NormalizeVector3";
      qword_26AF745E8 = (uint64_t)v71;
      v72 = re::introspectionAllocator(v71);
      v73 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v72 + 32))(v72, 24, 8);
      *(_DWORD *)v73 = 1;
      *((void *)v73 + 1) = 30;
      *((void *)v73 + 2) = "RotateQuaternionVector3";
      qword_26AF745F0 = (uint64_t)v73;
      v74 = re::introspectionAllocator(v73);
      v75 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v74 + 32))(v74, 24, 8);
      *(_DWORD *)v75 = 1;
      *((void *)v75 + 1) = 31;
      *((void *)v75 + 2) = "SubtractVector3";
      qword_26AF745F8 = (uint64_t)v75;
      v76 = re::introspectionAllocator(v75);
      v77 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v76 + 32))(v76, 24, 8);
      *(_DWORD *)v77 = 1;
      *((void *)v77 + 1) = 32;
      *((void *)v77 + 2) = "SubtractVector2";
      qword_26AF74600 = (uint64_t)v77;
      v78 = re::introspectionAllocator(v77);
      v79 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v78 + 32))(v78, 24, 8);
      *(_DWORD *)v79 = 1;
      *((void *)v79 + 1) = 33;
      *((void *)v79 + 2) = "TransposeMatrix3x3";
      qword_26AF74608 = (uint64_t)v79;
      v80 = re::introspectionAllocator(v79);
      v81 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v80 + 32))(v80, 24, 8);
      *(_DWORD *)v81 = 1;
      *((void *)v81 + 1) = 34;
      *((void *)v81 + 2) = "ExtractMinorMatrix4x4";
      qword_26AF74610 = (uint64_t)v81;
      v82 = re::introspectionAllocator(v81);
      v83 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v82 + 32))(v82, 24, 8);
      *(_DWORD *)v83 = 1;
      *((void *)v83 + 1) = 35;
      *((void *)v83 + 2) = "ExtractRotationMatrix3x3";
      qword_26AF74618 = (uint64_t)v83;
      v84 = re::introspectionAllocator(v83);
      v85 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v84 + 32))(v84, 24, 8);
      *(_DWORD *)v85 = 1;
      *((void *)v85 + 1) = 36;
      *((void *)v85 + 2) = "ExtractScaleMatrix3x3";
      qword_26AF74620 = (uint64_t)v85;
      v86 = re::introspectionAllocator(v85);
      v87 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v86 + 32))(v86, 24, 8);
      *(_DWORD *)v87 = 1;
      *((void *)v87 + 1) = 37;
      *((void *)v87 + 2) = "ExtractTranslationMatrix4x4";
      qword_26AF74628 = (uint64_t)v87;
      v88 = re::introspectionAllocator(v87);
      v89 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v88 + 32))(v88, 24, 8);
      *(_DWORD *)v89 = 1;
      *((void *)v89 + 1) = 38;
      *((void *)v89 + 2) = "MakeColumnsMatrix3x3";
      qword_26AF74630 = (uint64_t)v89;
      v90 = re::introspectionAllocator(v89);
      v91 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v90 + 32))(v90, 24, 8);
      *(_DWORD *)v91 = 1;
      *((void *)v91 + 1) = 39;
      *((void *)v91 + 2) = "MakeScaleRotationMatrix3x3";
      qword_26AF74638 = (uint64_t)v91;
      v92 = re::introspectionAllocator(v91);
      v93 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v92 + 32))(v92, 24, 8);
      *(_DWORD *)v93 = 1;
      *((void *)v93 + 1) = 40;
      *((void *)v93 + 2) = "MakeMinorTranslationMatrix4x4";
      qword_26AF74640 = (uint64_t)v93;
      v94 = re::introspectionAllocator(v93);
      v95 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v94 + 32))(v94, 24, 8);
      *(_DWORD *)v95 = 1;
      *((void *)v95 + 1) = 41;
      *((void *)v95 + 2) = "TransformDirectionMatrix3x3Vector3";
      qword_26AF74648 = (uint64_t)v95;
      v96 = re::introspectionAllocator(v95);
      v97 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v96 + 32))(v96, 24, 8);
      *(_DWORD *)v97 = 1;
      *((void *)v97 + 1) = 42;
      *((void *)v97 + 2) = "TransformDirectionMatrix4x4Vector3";
      qword_26AF74650 = (uint64_t)v97;
      v98 = re::introspectionAllocator(v97);
      v99 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v98 + 32))(v98, 24, 8);
      *(_DWORD *)v99 = 1;
      *((void *)v99 + 1) = 43;
      *((void *)v99 + 2) = "TransformPositionMatrix4x4Vector3";
      qword_26AF74658 = (uint64_t)v99;
      v100 = re::introspectionAllocator(v99);
      v101 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v100 + 32))(v100, 24, 8);
      *(_DWORD *)v101 = 1;
      *((void *)v101 + 1) = 44;
      *((void *)v101 + 2) = "DotQuaternion";
      qword_26AF74660 = (uint64_t)v101;
      v102 = re::introspectionAllocator(v101);
      v103 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v102 + 32))(v102, 24, 8);
      *(_DWORD *)v103 = 1;
      *((void *)v103 + 1) = 45;
      *((void *)v103 + 2) = "MakeAxisAngleQuaternion";
      qword_26AF74668 = (uint64_t)v103;
      v104 = re::introspectionAllocator(v103);
      v105 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v104 + 32))(v104, 24, 8);
      *(_DWORD *)v105 = 1;
      *((void *)v105 + 1) = 46;
      *((void *)v105 + 2) = "MakeVector3FloatQuaternion";
      qword_26AF74670 = (uint64_t)v105;
      v106 = re::introspectionAllocator(v105);
      v107 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v106 + 32))(v106, 24, 8);
      *(_DWORD *)v107 = 1;
      *((void *)v107 + 1) = 47;
      *((void *)v107 + 2) = "MakeVector3";
      qword_26AF74678 = (uint64_t)v107;
      v108 = re::introspectionAllocator(v107);
      v109 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v108 + 32))(v108, 24, 8);
      *(_DWORD *)v109 = 1;
      *((void *)v109 + 1) = 48;
      *((void *)v109 + 2) = "MakeVector2";
      qword_26AF74680 = (uint64_t)v109;
      v110 = re::introspectionAllocator(v109);
      v111 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v110 + 32))(v110, 24, 8);
      *(_DWORD *)v111 = 1;
      *((void *)v111 + 1) = 49;
      *((void *)v111 + 2) = "AddFloat";
      qword_26AF74688 = (uint64_t)v111;
      v112 = re::introspectionAllocator(v111);
      v113 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v112 + 32))(v112, 24, 8);
      *(_DWORD *)v113 = 1;
      *((void *)v113 + 1) = 50;
      *((void *)v113 + 2) = "SubtractFloat";
      qword_26AF74690 = (uint64_t)v113;
      v114 = re::introspectionAllocator(v113);
      v115 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v114 + 32))(v114, 24, 8);
      *(_DWORD *)v115 = 1;
      *((void *)v115 + 1) = 51;
      *((void *)v115 + 2) = "MultiplyFloat";
      qword_26AF74698 = (uint64_t)v115;
      v116 = re::introspectionAllocator(v115);
      v117 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v116 + 32))(v116, 24, 8);
      *(_DWORD *)v117 = 1;
      *((void *)v117 + 1) = 52;
      *((void *)v117 + 2) = "DivideFloat";
      qword_26AF746A0 = (uint64_t)v117;
      v118 = re::introspectionAllocator(v117);
      v119 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v118 + 32))(v118, 24, 8);
      *(_DWORD *)v119 = 1;
      *((void *)v119 + 1) = 53;
      *((void *)v119 + 2) = "SinFloat";
      qword_26AF746A8 = (uint64_t)v119;
      v120 = re::introspectionAllocator(v119);
      v121 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v120 + 32))(v120, 24, 8);
      *(_DWORD *)v121 = 1;
      *((void *)v121 + 1) = 54;
      *((void *)v121 + 2) = "CosFloat";
      qword_26AF746B0 = (uint64_t)v121;
      v122 = re::introspectionAllocator(v121);
      v123 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v122 + 32))(v122, 24, 8);
      *(_DWORD *)v123 = 1;
      *((void *)v123 + 1) = 55;
      *((void *)v123 + 2) = "TanFloat";
      qword_26AF746B8 = (uint64_t)v123;
      v124 = re::introspectionAllocator(v123);
      v125 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v124 + 32))(v124, 24, 8);
      *(_DWORD *)v125 = 1;
      *((void *)v125 + 1) = 56;
      *((void *)v125 + 2) = "AsinFloat";
      qword_26AF746C0 = (uint64_t)v125;
      v126 = re::introspectionAllocator(v125);
      v127 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v126 + 32))(v126, 24, 8);
      *(_DWORD *)v127 = 1;
      *((void *)v127 + 1) = 57;
      *((void *)v127 + 2) = "AcosFloat";
      qword_26AF746C8 = (uint64_t)v127;
      v128 = re::introspectionAllocator(v127);
      v129 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v128 + 32))(v128, 24, 8);
      *(_DWORD *)v129 = 1;
      *((void *)v129 + 1) = 58;
      *((void *)v129 + 2) = "AtanFloat";
      qword_26AF746D0 = (uint64_t)v129;
      v130 = re::introspectionAllocator(v129);
      v131 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v130 + 32))(v130, 24, 8);
      *(_DWORD *)v131 = 1;
      *((void *)v131 + 1) = 59;
      *((void *)v131 + 2) = "Atan2Float";
      qword_26AF746D8 = (uint64_t)v131;
      v132 = re::introspectionAllocator(v131);
      v133 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v132 + 32))(v132, 24, 8);
      *(_DWORD *)v133 = 1;
      *((void *)v133 + 1) = 60;
      *((void *)v133 + 2) = "SelectFloat";
      qword_26AF746E0 = (uint64_t)v133;
      v134 = re::introspectionAllocator(v133);
      v135 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v134 + 32))(v134, 24, 8);
      *(_DWORD *)v135 = 1;
      *((void *)v135 + 1) = 61;
      *((void *)v135 + 2) = "GreaterFloat";
      qword_26AF746E8 = (uint64_t)v135;
      v136 = re::introspectionAllocator(v135);
      v137 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v136 + 32))(v136, 24, 8);
      *(_DWORD *)v137 = 1;
      *((void *)v137 + 1) = 62;
      *((void *)v137 + 2) = "GreaterEqualFloat";
      qword_26AF746F0 = (uint64_t)v137;
      v138 = re::introspectionAllocator(v137);
      v139 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v138 + 32))(v138, 24, 8);
      *(_DWORD *)v139 = 1;
      *((void *)v139 + 1) = 63;
      *((void *)v139 + 2) = "LessFloat";
      qword_26AF746F8 = (uint64_t)v139;
      v140 = re::introspectionAllocator(v139);
      v141 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v140 + 32))(v140, 24, 8);
      *(_DWORD *)v141 = 1;
      *((void *)v141 + 1) = 64;
      *((void *)v141 + 2) = "LessEqualFloat";
      qword_26AF74700 = (uint64_t)v141;
      v142 = re::introspectionAllocator(v141);
      v143 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v142 + 32))(v142, 24, 8);
      *(_DWORD *)v143 = 1;
      *((void *)v143 + 1) = 65;
      *((void *)v143 + 2) = "Int32IsEqual";
      qword_26AF74708 = (uint64_t)v143;
      v144 = re::introspectionAllocator(v143);
      v145 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v144 + 32))(v144, 24, 8);
      *(_DWORD *)v145 = 1;
      *((void *)v145 + 1) = 66;
      *((void *)v145 + 2) = "UInt32IsEqual";
      qword_26AF74710 = (uint64_t)v145;
      v146 = re::introspectionAllocator(v145);
      uint64_t v147 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v146 + 32))(v146, 24, 8);
      *(_DWORD *)uint64_t v147 = 1;
      *(void *)(v147 + 8) = 67;
      *(void *)(v147 + 16) = "FloatAlmostEqual";
      qword_26AF74718 = v147;
      __cxa_guard_release(&qword_26AF74358);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74360, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF74360))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF74438, "EvaluationCommand", 4, 4, 1, 1);
    qword_26AF74438 = (uint64_t)&unk_26E715E00;
    qword_26AF74478 = (uint64_t)&re::introspect_EvaluationCommand(BOOL)::enumTable;
    dword_26AF74448 = 9;
    __cxa_guard_release(&qword_26AF74360);
  }
  if (v2)
  {
    if (byte_26AF74331) {
      return &qword_26AF74438;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v153);
    char v3 = byte_26AF74331;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v153);
    if (v3) {
      return &qword_26AF74438;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (byte_26AF74331)
    {
LABEL_34:
      v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF74438;
    }
  }
  byte_26AF74331 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF74438, a2);
  uint64_t v149 = 0x59C43F7855EEA89ELL;
  v150 = "EvaluationCommand";
  v153[0] = 0x607DD0F01DCLL;
  v153[1] = "uint32_t";
  uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v153);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v153);
    int v9 = (unsigned int *)qword_26AF74478;
    v152[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v153, &v149, 1, 1, (uint64_t)v152);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          long long v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                uint64_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v151.var0 = 2 * v15;
          v151.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v153, v19, &v151);
          re::StringID::destroyString((re::StringID *)&v151);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            uint64_t v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v151.var0 = 2 * v23;
            v151.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v153, v27, &v151);
            re::StringID::destroyString((re::StringID *)&v151);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v153, v28);
    xmmword_26AF74458 = (__int128)v151;
    re::StringID::destroyString((re::StringID *)&v149);
    if (v2) {
      return &qword_26AF74438;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v153);
  re::internal::assertLog((re::internal *)5, v148, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "EvaluationCommand", v149, v150);
  double result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

void re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  uint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    int v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x18uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionFixedArray<int>::~IntrospectionFixedArray(void *a1)
{
  *a1 = &unk_26E6C0380;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionFixedArray<int>::~IntrospectionFixedArray(void *a1)
{
  *a1 = &unk_26E6C0380;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionFixedArray<int>::construct(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

uint64_t re::IntrospectionFixedArray<int>::destroy(uint64_t a1, uint64_t *a2)
{
  return re::FixedArray<CoreIKTransform>::deinit(a2);
}

void re::IntrospectionFixedArray<int>::init(uint64_t a1, uint64_t *a2, re *a3, int a4, unint64_t a5)
{
  re::FixedArray<int>::init<>(a2, (uint64_t)a3, a5);
  if (a5)
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      if (a2[1] <= v11)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      re::introspectionInitElement(a3, a4, *(re::Allocator **)(a1 + 48), (re::IntrospectionBase *)(a2[2] + v10));
      ++v11;
      v10 += 4;
    }
    while (a5 != v11);
  }
}

uint64_t re::IntrospectionFixedArray<int>::deinit(uint64_t a1, uint64_t *a2)
{
  return re::FixedArray<CoreIKTransform>::deinit(a2);
}

uint64_t re::IntrospectionFixedArray<int>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 8);
}

BOOL re::IntrospectionFixedArray<int>::isInitialized(uint64_t a1, void *a2)
{
  return *a2 != 0;
}

uint64_t re::IntrospectionFixedArray<int>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 16) + 4 * a3;
}

{
  if (*(void *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 16) + 4 * a3;
}

void *re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(void *result, uint64_t a2, uint64_t a3)
{
  result[1] = 0;
  result[2] = 0;
  *double result = a3;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t *a1)
{
  re::FixedArray<CoreIKTransform>::deinit(a1);
  return re::FixedArray<CoreIKTransform>::deinit(a1);
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t *a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::FixedArray<CoreIKTransform>::deinit(a1);
  re::FixedArray<int>::init<>(a1, (uint64_t)a3, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = a1[1];
    if (v9)
    {
      uint64_t v10 = (char *)a1[2];
      uint64_t v11 = 4 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 4;
        v11 -= 4;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 16) + 4 * a2;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1)
{
  int v1 = a1[2];
  uint64_t v2 = *(void *)a1;
  unint64_t v3 = *(void *)(*(void *)a1 + 8);
  if (v1 < (int)v3) {
    a1[2] = ++v1;
  }
  if (v3 <= v1) {
    return 0;
  }
  else {
    return *(void *)(v2 + 16) + 4 * v1;
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  uint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    uint64_t v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x18uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionFixedArray<re::Vector3<float>>::~IntrospectionFixedArray(void *a1)
{
  *a1 = &unk_26E6C0380;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionFixedArray<re::Vector3<float>>::~IntrospectionFixedArray(void *a1)
{
  *a1 = &unk_26E6C0380;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionFixedArray<re::Vector3<float>>::construct(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

uint64_t re::IntrospectionFixedArray<re::Vector3<float>>::destroy(uint64_t a1, uint64_t *a2)
{
  return re::FixedArray<CoreIKTransform>::deinit(a2);
}

void re::IntrospectionFixedArray<re::Vector3<float>>::init(uint64_t a1, uint64_t *a2, re *a3, int a4, unint64_t a5)
{
  re::FixedArray<re::Vector3<float>>::init<>(a2, (uint64_t)a3, a5);
  if (a5)
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      if (a2[1] <= v11)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      re::introspectionInitElement(a3, a4, *(re::Allocator **)(a1 + 48), (re::IntrospectionBase *)(a2[2] + v10));
      ++v11;
      v10 += 16;
    }
    while (a5 != v11);
  }
}

uint64_t re::IntrospectionFixedArray<re::Vector3<float>>::deinit(uint64_t a1, uint64_t *a2)
{
  return re::FixedArray<CoreIKTransform>::deinit(a2);
}

uint64_t re::IntrospectionFixedArray<re::Vector3<float>>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 8);
}

BOOL re::IntrospectionFixedArray<re::Vector3<float>>::isInitialized(uint64_t a1, void *a2)
{
  return *a2 != 0;
}

uint64_t re::IntrospectionFixedArray<re::Vector3<float>>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 16) + 16 * a3;
}

{
  if (*(void *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 16) + 16 * a3;
}

void *re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(void *result, uint64_t a2, uint64_t a3)
{
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = a3;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t *a1)
{
  re::FixedArray<CoreIKTransform>::deinit(a1);
  return re::FixedArray<CoreIKTransform>::deinit(a1);
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t *a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::FixedArray<CoreIKTransform>::deinit(a1);
  re::FixedArray<re::Vector3<float>>::init<>(a1, (uint64_t)a3, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = a1[1];
    if (v9)
    {
      uint64_t v10 = (char *)a1[2];
      uint64_t v11 = 16 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 16;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 16) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1)
{
  int v1 = a1[2];
  uint64_t v2 = *(void *)a1;
  unint64_t v3 = *(void *)(*(void *)a1 + 8);
  if (v1 < (int)v3) {
    a1[2] = ++v1;
  }
  if (v3 <= v1) {
    return 0;
  }
  else {
    return *(void *)(v2 + 16) + 16 * v1;
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  uint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    uint64_t v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionDynamicArray<int>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<int>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<int>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<int>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<int>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<int>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<int>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<int>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<float>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<int>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<int>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  int v10 = 0;
  re::DynamicArray<int>::add(this, &v10);
  uint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 4 * *((void *)this + 2) - 4);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<int>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<int>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 4 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 4 * a3;
}

void *re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<int>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<int>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<float>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      int v10 = *(char **)(a1 + 32);
      uint64_t v11 = 4 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 4;
        v11 -= 4;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 4 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 4 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::IntrospectionDynamicArray<re::Matrix3x3<float>>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::Matrix3x3<float>>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::Matrix3x3<float>>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::Matrix3x3<float>>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::Matrix3x3<float>>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::Matrix3x3<float>>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::Matrix3x3<float>>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::Matrix3x3<float>>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::Matrix3x3<float>>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::Matrix3x3<float>>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::Matrix3x3<float>>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  unint64_t v8 = *((void *)this + 2);
  if (v8 >= *((void *)this + 1))
  {
    re::DynamicArray<re::Matrix3x3<float>>::growCapacity(this, v8 + 1);
    unint64_t v8 = *((void *)this + 2);
  }
  uint64_t v9 = (_OWORD *)(*((void *)this + 4) + 48 * v8);
  v9[1] = 0u;
  v9[2] = 0u;
  _OWORD *v9 = 0u;
  uint64_t v10 = *((void *)this + 2);
  *((void *)this + 2) = v10 + 1;
  ++*((_DWORD *)this + 6);
  uint64_t v11 = (re::IntrospectionBase *)(*((void *)this + 4) + 48 * v10);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v11);
  return v11;
}

uint64_t re::IntrospectionDynamicArray<re::Matrix3x3<float>>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::Matrix3x3<float>>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 48 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 48 * a3;
}

void re::DynamicArray<re::Matrix3x3<float>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::Matrix3x3<float>>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2)
    {
      uint64_t v5 = (void *)(*(void *)(a1 + 32) + 48 * v4);
      uint64_t v6 = 48 * a2 - 48 * v4;
      if (v6 >= 1) {
        bzero(v5, 48 * (v6 / 0x30uLL - ((unint64_t)v6 > 0x2F)) + 48);
      }
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::Matrix3x3<float>>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::Matrix3x3<float>>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::Matrix3x3<float>>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 48 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 48;
        v11 -= 48;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 48 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 48 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  unint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    uint64_t v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionDynamicArray<re::Matrix4x4<float>>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::Matrix4x4<float>>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::Matrix4x4<float>>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::Matrix4x4<float>>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::Matrix4x4<float>>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::Matrix4x4<float>>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::Matrix4x4<float>>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::Matrix4x4<float>>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::Matrix4x4<float>>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::Matrix4x4<float>>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::Matrix4x4<float>>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  memset(v10, 0, sizeof(v10));
  re::DynamicArray<re::Matrix4x4<float>>::add(this, (uint64_t)v10);
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + (*((void *)this + 2) << 6) - 64);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::Matrix4x4<float>>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::Matrix4x4<float>>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 6);
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + (a3 << 6);
}

void re::DynamicArray<re::Matrix4x4<float>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::Matrix4x4<float>>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2)
    {
      uint64_t v5 = (void *)(*(void *)(a1 + 32) + (v4 << 6));
      uint64_t v6 = (a2 << 6) - (v4 << 6);
      if (v6 >= 1) {
        bzero(v5, ((((unint64_t)v6 >> 6) - ((unint64_t)v6 > 0x3F)) << 6) + 64);
      }
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::Matrix4x4<float>>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::Matrix4x4<float>>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::Matrix4x4<float>>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      unint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = v9 << 6;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 64;
        v11 -= 64;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + (a2 << 6);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + ((uint64_t)v3 << 6);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  unint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    uint64_t v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionDynamicArray<re::Quaternion<float>>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::Quaternion<float>>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::Quaternion<float>>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::Quaternion<float>>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::Quaternion<float>>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::Quaternion<float>>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::Quaternion<float>>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::Quaternion<float>>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  long long v10 = xmmword_23435FBB0;
  re::DynamicArray<re::Vector3<float>>::add(this, (__n128 *)&v10);
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 16 * *((void *)this + 2) - 16);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::Quaternion<float>>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::Quaternion<float>>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

void re::DynamicArray<re::Quaternion<float>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (v4 < a2)
    {
      uint64_t v5 = (void *)(*(void *)(a1 + 32) + 16 * v4);
      uint64_t v6 = 16 * a2 - 16 * v4;
      if (v6 >= 1) {
        memset_pattern16(v5, &xmmword_23435FBB0, 16 * (((unint64_t)v6 >> 4) - ((unint64_t)v6 > 0xF)) + 16);
      }
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void *re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::Quaternion<float>>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      long long v10 = *(char **)(a1 + 32);
      uint64_t v11 = 16 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 16;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 16 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Quaternion<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  unint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    uint64_t v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionDynamicArray<re::Vector2<float>>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::Vector2<float>>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::Vector2<float>>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::Vector2<float>>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::Vector2<float>>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::Vector2<float>>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<unsigned long>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::Vector2<float>>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  uint64_t v10 = 0;
  re::DynamicArray<unsigned long>::add(this, &v10);
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 8 * *((void *)this + 2) - 8);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::Vector2<float>>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::Vector2<float>>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 8 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 8 * a3;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<unsigned long>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(char **)(a1 + 32);
      uint64_t v11 = 8 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 8;
        v11 -= 8;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 8 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 8 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Vector2<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, long long *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  unint64_t v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    uint64_t v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    long long v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

void *re::IntrospectionDynamicArray<re::Vector3<float>>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::Vector3<float>>::~IntrospectionDynamicArray(void *a1)
{
  *a1 = &unk_26E6BFB78;
  re::SerializedReference<re::IntrospectionBase const*>::reset((uint64_t)(a1 + 6));
  *a1 = &unk_26E6DECE0;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x237DBCBD0);
}

void re::IntrospectionDynamicArray<re::Vector3<float>>::construct(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::Vector3<float>>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<unsigned long>::deinit(a2);
}

void *re::IntrospectionDynamicArray<re::Vector3<float>>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<unsigned long>::deinit(a2);
  *(void *)a2 = a3;
  uint64_t result = re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::Vector3<float>>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*(void *)a4)
  {
    *(void *)a4 = a2;
    re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  unint64_t v10 = *(void *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
    {
      re::DynamicArray<re::Vector3<float>>::resize(a4, a5);
    }
  }
  else
  {
    re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a4, a5);
    for (unint64_t i = a5 - *(void *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::Vector3<float>>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  __n128 v10 = 0u;
  re::DynamicArray<re::Vector3<float>>::add(this, &v10);
  unint64_t v8 = (re::IntrospectionBase *)(*((void *)this + 4) + 16 * *((void *)this + 2) - 16);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::Vector3<float>>::size(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::Vector3<float>>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

{
  if (*(void *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a2 + 32) + 16 * a3;
}

void *re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a3;
  uint64_t result = re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  if (*(re::Allocator **)a1 == a3)
  {
    *(void *)(a1 + 16) = 0;
  }
  else
  {
    re::DynamicArray<unsigned long>::deinit(a1);
    *(void *)a1 = a3;
    re::DynamicArray<re::Quaternion<float>>::setCapacity((void *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::Vector3<float>>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(void **)a2, *(void *)(*(void *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      __n128 v10 = *(char **)(a1 + 32);
      uint64_t v11 = 16 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 16;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 16, 8);
  *(void *)uint64_t result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (a1[2] == *(_DWORD *)(*(void *)a1 + 24))
  {
    int v3 = a1[3];
    unint64_t v4 = *(void *)(v2 + 16);
    if (v3 < (int)v4) {
      a1[3] = ++v3;
    }
    if (v4 <= v3) {
      return 0;
    }
    else {
      return *(void *)(v2 + 32) + 16 * v3;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, result);
  }
  return result;
}

void *re::introspect_FillMode(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      __n128 v10 = re::introspectionAllocator(v9);
      uint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "FillNone";
      re::introspect_FillMode(BOOL)::enumAttributes = (uint64_t)v11;
      long long v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "FillForwards";
      qword_26879E170 = (uint64_t)v13;
      uint64_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *((void *)v15 + 1) = 2;
      *((void *)v15 + 2) = "FillBackwards";
      qword_26879E178 = (uint64_t)v15;
      char v16 = re::introspectionAllocator(v15);
      uint64_t v17 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 24, 8);
      *(_DWORD *)uint64_t v17 = 1;
      *(void *)(v17 + 8) = 3;
      *(void *)(v17 + 16) = "FillBoth";
      qword_26879E180 = v17;
    }
  }
  {
    int v18 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_FillMode(BOOL)::info, "FillMode", 1, 1, 1, 1);
    *(void *)int v18 = &unk_26E715E00;
    *((void *)v18 + 8) = &re::introspect_FillMode(BOOL)::enumTable;
    *((_DWORD *)v18 + 4) = 9;
  }
  if (v2)
  {
    if (re::introspect_FillMode(BOOL)::isInitialized) {
      return &re::introspect_FillMode(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    char v3 = re::introspect_FillMode(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    if (v3) {
      return &re::introspect_FillMode(BOOL)::info;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::introspect_FillMode(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::introspect_FillMode(BOOL)::info;
    }
  }
  re::introspect_FillMode(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_FillMode(BOOL)::info, a2);
  v19[0] = 0x3ADB0C51BCCLL;
  v19[1] = (uint64_t)"FillMode";
  xmmword_26879E1B0 = v20;
  re::StringID::destroyString((re::StringID *)v19);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::introspect_FillMode(BOOL)::info;
}

void re::internal::registerEnumType<re::FillMode>(re::TypeRegistry *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  v33[0] = 6104748;
  v33[1] = "char";
  unint64_t v8 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, v33);
  if (!v8)
  {
    re::StringID::destroyString((re::StringID *)v33);
    goto LABEL_29;
  }
  uint64_t v9 = *v8;
  re::StringID::destroyString((re::StringID *)v33);
  if (!a1)
  {
LABEL_29:
    re::internal::assertLog((re::internal *)5, v11, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, a3[1]);
    _os_crash();
    __break(1u);
    return;
  }
  long long v12 = *(unsigned int **)(a2 + 64);
  v32[0] = a1;
  v32[1] = v9;
  re::TypeBuilder::beginEnumType((uint64_t)v33, a3, 1, 1, (uint64_t)v32);
  unint64_t v13 = *v12;
  if (v13)
  {
    for (unint64_t i = 0; i < v13; ++i)
    {
      uint64_t v15 = *(void *)(*((void *)v12 + 1) + 8 * i);
      if (*(_DWORD *)v15 == 1)
      {
        char v16 = *(char **)(v15 + 16);
        if (v16)
        {
          uint64_t v17 = *v16;
          if (*v16)
          {
            char v18 = v16[1];
            if (v18)
            {
              uint64_t v19 = (unsigned __int8 *)(v16 + 2);
              do
              {
                uint64_t v17 = 31 * v17 + v18;
                int v20 = *v19++;
                char v18 = v20;
              }
              while (v20);
            }
          }
        }
        else
        {
          uint64_t v17 = 0;
        }
        uint64_t v21 = *(void *)(v15 + 8);
        *(void *)&v31.var0 = 2 * v17;
        v31.var1 = v16;
        re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v33, v21, &v31);
        re::StringID::destroyString((re::StringID *)&v31);
        unint64_t v13 = *v12;
      }
    }
    if (v13)
    {
      for (unint64_t j = 0; j < v13; ++j)
      {
        uint64_t v23 = *(void *)(*((void *)v12 + 1) + 8 * j);
        if (*(_DWORD *)v23 == 2)
        {
          char v24 = *(char **)(v23 + 16);
          if (v24)
          {
            uint64_t v25 = *v24;
            if (*v24)
            {
              char v26 = v24[1];
              if (v26)
              {
                uint64_t v27 = (unsigned __int8 *)(v24 + 2);
                do
                {
                  uint64_t v25 = 31 * v25 + v26;
                  int v28 = *v27++;
                  char v26 = v28;
                }
                while (v28);
              }
            }
          }
          else
          {
            uint64_t v25 = 0;
          }
          uint64_t v29 = *(void *)(v23 + 8);
          *(void *)&v31.var0 = 2 * v25;
          v31.var1 = v24;
          re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v33, v29, &v31);
          re::StringID::destroyString((re::StringID *)&v31);
          unint64_t v13 = *v12;
        }
      }
    }
  }
  re::TypeBuilder::commitTo((re::TypeBuilder *)v33, a1, a4);
  re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v33, v30);
}

void *re::introspect_LoopBehavior(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      __n128 v10 = re::introspectionAllocator(v9);
      uint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)uint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "Constant";
      re::introspect_LoopBehavior(BOOL)::enumAttributes = (uint64_t)v11;
      long long v12 = re::introspectionAllocator(v11);
      unint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)unint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "Repeat";
      qword_26879E1F0 = (uint64_t)v13;
      uint64_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *((void *)v15 + 1) = 2;
      *((void *)v15 + 2) = "RepeatCumulative";
      qword_26879E1F8 = (uint64_t)v15;
      char v16 = re::introspectionAllocator(v15);
      uint64_t v17 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 24, 8);
      *(_DWORD *)uint64_t v17 = 1;
      *(void *)(v17 + 8) = 3;
      *(void *)(v17 + 16) = "AutoReverse";
      qword_26879E200 = v17;
    }
  }
  {
    char v18 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_LoopBehavior(BOOL)::info, "LoopBehavior", 1, 1, 1, 1);
    *(void *)char v18 = &unk_26E715E00;
    *((void *)v18 + 8) = &re::introspect_LoopBehavior(BOOL)::enumTable;
    *((_DWORD *)v18 + 4) = 9;
  }
  if (v2)
  {
    if (re::introspect_LoopBehavior(BOOL)::isInitialized) {
      return &re::introspect_LoopBehavior(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    char v3 = re::introspect_LoopBehavior(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    if (v3) {
      return &re::introspect_LoopBehavior(BOOL)::info;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::introspect_LoopBehavior(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::introspect_LoopBehavior(BOOL)::info;
    }
  }
  re::introspect_LoopBehavior(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_LoopBehavior(BOOL)::info, a2);
  v19[0] = 0x3834E1F9FF309A6CLL;
  v19[1] = (uint64_t)"LoopBehavior";
  xmmword_26879E230 = v20;
  re::StringID::destroyString((re::StringID *)v19);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::introspect_LoopBehavior(BOOL)::info;
}

uint64_t *re::introspect_TimelineType(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74728, memory_order_acquire) & 1) == 0)
  {
    StringID v31 = (re *)__cxa_guard_acquire(&qword_26AF74728);
    if (v31)
    {
      v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 1;
      *((void *)v33 + 2) = "TimelineClip";
      qword_26AF74780 = (uint64_t)v33;
      v34 = re::introspectionAllocator(v33);
      v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)v35 = 1;
      *((void *)v35 + 1) = 2;
      *((void *)v35 + 2) = "TimelineGroup";
      qword_26AF74788 = (uint64_t)v35;
      v36 = re::introspectionAllocator(v35);
      v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)v37 = 1;
      *((void *)v37 + 1) = 3;
      *((void *)v37 + 2) = "FloatAnimationClip";
      qword_26AF74790 = (uint64_t)v37;
      v38 = re::introspectionAllocator(v37);
      v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)v39 = 1;
      *((void *)v39 + 1) = 4;
      *((void *)v39 + 2) = "DoubleAnimationClip";
      qword_26AF74798 = (uint64_t)v39;
      v40 = re::introspectionAllocator(v39);
      v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)v41 = 1;
      *((void *)v41 + 1) = 5;
      *((void *)v41 + 2) = "Vector2FAnimationClip";
      qword_26AF747A0 = (uint64_t)v41;
      v42 = re::introspectionAllocator(v41);
      v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)v43 = 1;
      *((void *)v43 + 1) = 6;
      *((void *)v43 + 2) = "Vector3FAnimationClip";
      qword_26AF747A8 = (uint64_t)v43;
      v44 = re::introspectionAllocator(v43);
      v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)v45 = 1;
      *((void *)v45 + 1) = 7;
      *((void *)v45 + 2) = "Vector4FAnimationClip";
      qword_26AF747B0 = (uint64_t)v45;
      v46 = re::introspectionAllocator(v45);
      v47 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)v47 = 1;
      *((void *)v47 + 1) = 8;
      *((void *)v47 + 2) = "QuaternionFAnimationClip";
      qword_26AF747B8 = (uint64_t)v47;
      v48 = re::introspectionAllocator(v47);
      v49 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v48 + 32))(v48, 24, 8);
      *(_DWORD *)v49 = 1;
      *((void *)v49 + 1) = 9;
      *((void *)v49 + 2) = "SRTAnimationClip";
      qword_26AF747C0 = (uint64_t)v49;
      v50 = re::introspectionAllocator(v49);
      v51 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v50 + 32))(v50, 24, 8);
      *(_DWORD *)v51 = 1;
      *((void *)v51 + 1) = 10;
      *((void *)v51 + 2) = "SkeletalPoseAnimationClip";
      qword_26AF747C8 = (uint64_t)v51;
      v52 = re::introspectionAllocator(v51);
      uint64_t v53 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v52 + 32))(v52, 24, 8);
      *(_DWORD *)uint64_t v53 = 1;
      *((void *)v53 + 1) = 11;
      *((void *)v53 + 2) = "FloatAnimation";
      qword_26AF747D0 = (uint64_t)v53;
      uint64_t v54 = re::introspectionAllocator(v53);
      uint64_t v55 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v54 + 32))(v54, 24, 8);
      *(_DWORD *)uint64_t v55 = 1;
      *((void *)v55 + 1) = 12;
      *((void *)v55 + 2) = "DoubleAnimation";
      qword_26AF747D8 = (uint64_t)v55;
      v56 = re::introspectionAllocator(v55);
      StringID v57 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v56 + 32))(v56, 24, 8);
      *(_DWORD *)StringID v57 = 1;
      *((void *)v57 + 1) = 13;
      *((void *)v57 + 2) = "Vector2FAnimation";
      qword_26AF747E0 = (uint64_t)v57;
      v58 = re::introspectionAllocator(v57);
      v59 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v58 + 32))(v58, 24, 8);
      *(_DWORD *)v59 = 1;
      *((void *)v59 + 1) = 14;
      *((void *)v59 + 2) = "Vector3FAnimation";
      qword_26AF747E8 = (uint64_t)v59;
      v60 = re::introspectionAllocator(v59);
      v61 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v60 + 32))(v60, 24, 8);
      *(_DWORD *)v61 = 1;
      *((void *)v61 + 1) = 15;
      *((void *)v61 + 2) = "Vector4FAnimation";
      qword_26AF747F0 = (uint64_t)v61;
      v62 = re::introspectionAllocator(v61);
      v63 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v62 + 32))(v62, 24, 8);
      *(_DWORD *)v63 = 1;
      *((void *)v63 + 1) = 16;
      *((void *)v63 + 2) = "QuaternionFAnimation";
      qword_26AF747F8 = (uint64_t)v63;
      v64 = re::introspectionAllocator(v63);
      v65 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v64 + 32))(v64, 24, 8);
      *(_DWORD *)v65 = 1;
      *((void *)v65 + 1) = 17;
      *((void *)v65 + 2) = "SRTAnimation";
      qword_26AF74800 = (uint64_t)v65;
      v66 = re::introspectionAllocator(v65);
      v67 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v66 + 32))(v66, 24, 8);
      *(_DWORD *)v67 = 1;
      *((void *)v67 + 1) = 18;
      *((void *)v67 + 2) = "SkeletalPoseAnimation";
      qword_26AF74808 = (uint64_t)v67;
      v68 = re::introspectionAllocator(v67);
      v69 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v68 + 32))(v68, 24, 8);
      *(_DWORD *)v69 = 1;
      *((void *)v69 + 1) = 19;
      *((void *)v69 + 2) = "FloatKeyframeAnimation";
      qword_26AF74810 = (uint64_t)v69;
      v70 = re::introspectionAllocator(v69);
      v71 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v70 + 32))(v70, 24, 8);
      *(_DWORD *)v71 = 1;
      *((void *)v71 + 1) = 20;
      *((void *)v71 + 2) = "DoubleKeyframeAnimation";
      qword_26AF74818 = (uint64_t)v71;
      v72 = re::introspectionAllocator(v71);
      v73 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v72 + 32))(v72, 24, 8);
      *(_DWORD *)v73 = 1;
      *((void *)v73 + 1) = 21;
      *((void *)v73 + 2) = "Vector2FKeyframeAnimation";
      qword_26AF74820 = (uint64_t)v73;
      v74 = re::introspectionAllocator(v73);
      v75 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v74 + 32))(v74, 24, 8);
      *(_DWORD *)v75 = 1;
      *((void *)v75 + 1) = 22;
      *((void *)v75 + 2) = "Vector3FKeyframeAnimation";
      qword_26AF74828 = (uint64_t)v75;
      v76 = re::introspectionAllocator(v75);
      v77 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v76 + 32))(v76, 24, 8);
      *(_DWORD *)v77 = 1;
      *((void *)v77 + 1) = 23;
      *((void *)v77 + 2) = "Vector4FKeyframeAnimation";
      qword_26AF74830 = (uint64_t)v77;
      v78 = re::introspectionAllocator(v77);
      v79 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v78 + 32))(v78, 24, 8);
      *(_DWORD *)v79 = 1;
      *((void *)v79 + 1) = 24;
      *((void *)v79 + 2) = "QuaternionFKeyframeAnimation";
      qword_26AF74838 = (uint64_t)v79;
      v80 = re::introspectionAllocator(v79);
      v81 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v80 + 32))(v80, 24, 8);
      *(_DWORD *)v81 = 1;
      *((void *)v81 + 1) = 25;
      *((void *)v81 + 2) = "SRTKeyframeAnimation";
      qword_26AF74840 = (uint64_t)v81;
      v82 = re::introspectionAllocator(v81);
      v83 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v82 + 32))(v82, 24, 8);
      *(_DWORD *)v83 = 1;
      *((void *)v83 + 1) = 26;
      *((void *)v83 + 2) = "SkeletalPoseKeyframeAnimation";
      qword_26AF74848 = (uint64_t)v83;
      v84 = re::introspectionAllocator(v83);
      v85 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v84 + 32))(v84, 24, 8);
      *(_DWORD *)v85 = 1;
      *((void *)v85 + 1) = 27;
      *((void *)v85 + 2) = "FloatSampledAnimation";
      qword_26AF74850 = (uint64_t)v85;
      v86 = re::introspectionAllocator(v85);
      v87 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v86 + 32))(v86, 24, 8);
      *(_DWORD *)v87 = 1;
      *((void *)v87 + 1) = 28;
      *((void *)v87 + 2) = "DoubleSampledAnimation";
      qword_26AF74858 = (uint64_t)v87;
      v88 = re::introspectionAllocator(v87);
      v89 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v88 + 32))(v88, 24, 8);
      *(_DWORD *)v89 = 1;
      *((void *)v89 + 1) = 29;
      *((void *)v89 + 2) = "Vector2FSampledAnimation";
      qword_26AF74860 = (uint64_t)v89;
      v90 = re::introspectionAllocator(v89);
      v91 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v90 + 32))(v90, 24, 8);
      *(_DWORD *)v91 = 1;
      *((void *)v91 + 1) = 30;
      *((void *)v91 + 2) = "Vector3FSampledAnimation";
      qword_26AF74868 = (uint64_t)v91;
      v92 = re::introspectionAllocator(v91);
      v93 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v92 + 32))(v92, 24, 8);
      *(_DWORD *)v93 = 1;
      *((void *)v93 + 1) = 31;
      *((void *)v93 + 2) = "Vector4FSampledAnimation";
      qword_26AF74870 = (uint64_t)v93;
      v94 = re::introspectionAllocator(v93);
      v95 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v94 + 32))(v94, 24, 8);
      *(_DWORD *)v95 = 1;
      *((void *)v95 + 1) = 32;
      *((void *)v95 + 2) = "QuaternionFSampledAnimation";
      qword_26AF74878 = (uint64_t)v95;
      v96 = re::introspectionAllocator(v95);
      v97 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v96 + 32))(v96, 24, 8);
      *(_DWORD *)v97 = 1;
      *((void *)v97 + 1) = 33;
      *((void *)v97 + 2) = "SRTSampledAnimation";
      qword_26AF74880 = (uint64_t)v97;
      v98 = re::introspectionAllocator(v97);
      v99 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v98 + 32))(v98, 24, 8);
      *(_DWORD *)v99 = 1;
      *((void *)v99 + 1) = 34;
      *((void *)v99 + 2) = "SkeletalPoseSampledAnimation";
      qword_26AF74888 = (uint64_t)v99;
      v100 = re::introspectionAllocator(v99);
      v101 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v100 + 32))(v100, 24, 8);
      *(_DWORD *)v101 = 1;
      *((void *)v101 + 1) = 35;
      *((void *)v101 + 2) = "SkeletalAnimation";
      qword_26AF74890 = (uint64_t)v101;
      v102 = re::introspectionAllocator(v101);
      v103 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v102 + 32))(v102, 24, 8);
      *(_DWORD *)v103 = 1;
      *((void *)v103 + 1) = 36;
      *((void *)v103 + 2) = "TransformAnimation";
      qword_26AF74898 = (uint64_t)v103;
      v104 = re::introspectionAllocator(v103);
      v105 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v104 + 32))(v104, 24, 8);
      *(_DWORD *)v105 = 1;
      *((void *)v105 + 1) = 37;
      *((void *)v105 + 2) = "OrbitAnimation";
      qword_26AF748A0 = (uint64_t)v105;
      v106 = re::introspectionAllocator(v105);
      v107 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v106 + 32))(v106, 24, 8);
      *(_DWORD *)v107 = 1;
      *((void *)v107 + 1) = 38;
      *((void *)v107 + 2) = "AudioAnimationTimeline";
      qword_26AF748A8 = (uint64_t)v107;
      v108 = re::introspectionAllocator(v107);
      v109 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v108 + 32))(v108, 24, 8);
      *(_DWORD *)v109 = 1;
      *((void *)v109 + 1) = 39;
      *((void *)v109 + 2) = "FloatAnimationBlendTree";
      qword_26AF748B0 = (uint64_t)v109;
      v110 = re::introspectionAllocator(v109);
      v111 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v110 + 32))(v110, 24, 8);
      *(_DWORD *)v111 = 1;
      *((void *)v111 + 1) = 40;
      *((void *)v111 + 2) = "DoubleAnimationBlendTree";
      qword_26AF748B8 = (uint64_t)v111;
      v112 = re::introspectionAllocator(v111);
      v113 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v112 + 32))(v112, 24, 8);
      *(_DWORD *)v113 = 1;
      *((void *)v113 + 1) = 41;
      *((void *)v113 + 2) = "Vector2FAnimationBlendTree";
      qword_26AF748C0 = (uint64_t)v113;
      v114 = re::introspectionAllocator(v113);
      v115 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v114 + 32))(v114, 24, 8);
      *(_DWORD *)v115 = 1;
      *((void *)v115 + 1) = 42;
      *((void *)v115 + 2) = "Vector3FAnimationBlendTree";
      qword_26AF748C8 = (uint64_t)v115;
      v116 = re::introspectionAllocator(v115);
      v117 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v116 + 32))(v116, 24, 8);
      *(_DWORD *)v117 = 1;
      *((void *)v117 + 1) = 43;
      *((void *)v117 + 2) = "Vector4FAnimationBlendTree";
      qword_26AF748D0 = (uint64_t)v117;
      v118 = re::introspectionAllocator(v117);
      v119 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v118 + 32))(v118, 24, 8);
      *(_DWORD *)v119 = 1;
      *((void *)v119 + 1) = 44;
      *((void *)v119 + 2) = "QuaternionFAnimationBlendTree";
      qword_26AF748D8 = (uint64_t)v119;
      v120 = re::introspectionAllocator(v119);
      v121 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v120 + 32))(v120, 24, 8);
      *(_DWORD *)v121 = 1;
      *((void *)v121 + 1) = 45;
      *((void *)v121 + 2) = "SRTAnimationBlendTree";
      qword_26AF748E0 = (uint64_t)v121;
      v122 = re::introspectionAllocator(v121);
      v123 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v122 + 32))(v122, 24, 8);
      *(_DWORD *)v123 = 1;
      *((void *)v123 + 1) = 46;
      *((void *)v123 + 2) = "SkeletalPoseAnimationBlendTree";
      qword_26AF748E8 = (uint64_t)v123;
      v124 = re::introspectionAllocator(v123);
      v125 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v124 + 32))(v124, 24, 8);
      *(_DWORD *)v125 = 1;
      *((void *)v125 + 1) = 48;
      *((void *)v125 + 2) = "EventTimeline";
      qword_26AF748F0 = (uint64_t)v125;
      v126 = re::introspectionAllocator(v125);
      v127 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v126 + 32))(v126, 24, 8);
      *(_DWORD *)v127 = 1;
      *((void *)v127 + 1) = 50;
      *((void *)v127 + 2) = "BlendShapeWeightsAnimation";
      qword_26AF748F8 = (uint64_t)v127;
      v128 = re::introspectionAllocator(v127);
      v129 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v128 + 32))(v128, 24, 8);
      *(_DWORD *)v129 = 1;
      *((void *)v129 + 1) = 59;
      *((void *)v129 + 2) = "BlendShapeWeightsSampledAnimation";
      qword_26AF74900 = (uint64_t)v129;
      v130 = re::introspectionAllocator(v129);
      v131 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v130 + 32))(v130, 24, 8);
      *(_DWORD *)v131 = 1;
      *((void *)v131 + 1) = 60;
      *((void *)v131 + 2) = "BlendShapeWeightsAnimationClip";
      qword_26AF74908 = (uint64_t)v131;
      v132 = re::introspectionAllocator(v131);
      uint64_t v133 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v132 + 32))(v132, 24, 8);
      *(_DWORD *)uint64_t v133 = 1;
      *(void *)(v133 + 8) = 61;
      *(void *)(v133 + 16) = "BlendShapeWeightsKeyframeAnimation";
      qword_26AF74910 = v133;
      __cxa_guard_release(&qword_26AF74728);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74730, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF74730))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF74738, "TimelineType", 4, 4, 1, 1);
    qword_26AF74738 = (uint64_t)&unk_26E715E00;
    qword_26AF74778 = (uint64_t)&re::introspect_TimelineType(BOOL)::enumTable;
    dword_26AF74748 = 9;
    __cxa_guard_release(&qword_26AF74730);
  }
  if (v2)
  {
    if (_MergedGlobals_25) {
      return &qword_26AF74738;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v139);
    char v3 = _MergedGlobals_25;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v139);
    if (v3) {
      return &qword_26AF74738;
    }
    uint64_t v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (_MergedGlobals_25)
    {
LABEL_34:
      uint64_t v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF74738;
    }
  }
  _MergedGlobals_25 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF74738, a2);
  uint64_t v135 = 0x3DB5CF76C26C4676;
  v136 = "TimelineType";
  v139[0] = 208862;
  v139[1] = "int";
  uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v139);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v139);
    uint64_t v9 = (unsigned int *)qword_26AF74778;
    v138[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v139, &v135, 1, 1, (uint64_t)v138);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                uint64_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v137.var0 = 2 * v15;
          v137.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v139, v19, &v137);
          re::StringID::destroyString((re::StringID *)&v137);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            uint64_t v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  uint64_t v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v137.var0 = 2 * v23;
            v137.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v139, v27, &v137);
            re::StringID::destroyString((re::StringID *)&v137);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v139, v28);
    xmmword_26AF74758 = (__int128)v137;
    re::StringID::destroyString((re::StringID *)&v135);
    if (v2) {
      return &qword_26AF74738;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v139);
  re::internal::assertLog((re::internal *)5, v134, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "TimelineType", v135, v136);
  uint64_t result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

float re::calculateNodeSRT@<S0>(float32x4_t *a1@<X0>, float32x4_t *a2@<X8>)
{
  int v4 = a1[5].u8[0];
  long long v20 = xmmword_23435FBB0;
  re::convertIntrinsicEulersToQuaternions<float>((uint64_t)&a1[2], 1, v4, (uint64_t)&v20, 1);
  _Q1 = a1[1];
  _Q3 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), vnegq_f32(_Q1)), (float32x4_t)v20, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL));
  float32x4_t v7 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q3, (int32x4_t)_Q3), _Q3, 0xCuLL), (float32x4_t)v20, _Q1, 3);
  _Q3.i32[0] = HIDWORD(v20);
  _Q2 = vmlaq_laneq_f32(v7, _Q1, (float32x4_t)v20, 3);
  __asm { FMLA            S0, S3, V1.S[3] }
  _Q5 = a1[3];
  int8x16_t v15 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q5, (int32x4_t)_Q5), (int8x16_t)_Q5, 0xCuLL), vnegq_f32(_Q2)), _Q5, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL));
  float32x4_t v16 = vmlaq_laneq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), v15, 0xCuLL), _Q5, result), _Q2, _Q5, 3);
  __asm { FMLA            S2, S0, V5.S[3] }
  v16.i32[3] = _Q2.i32[0];
  uint64_t v17 = a1[4].i64[1];
  uint64_t v18 = a1->i64[0];
  uint64_t v19 = a1->i64[1];
  a2->i64[0] = a1[4].i64[0];
  a2->i64[1] = v17;
  a2[1] = v16;
  a2[2].i64[0] = v18;
  a2[2].i64[1] = v19;
  return result;
}

void *re::DynamicArray<unsigned long>::copy(void *this, unint64_t a2, char *__src, uint64_t a4)
{
  if (!a4) {
    return this;
  }
  unint64_t v5 = a2;
  uint64_t v6 = this;
  unint64_t v7 = this[2];
  if (v7 + 1 <= a2)
  {
    uint64_t v12 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v13) = 136315906;
    *(void *)((char *)&v13 + 4) = "copy";
    WORD6(v13) = 1024;
    HIWORD(v13) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, v5, v4, v12, v13);
    _os_crash();
    __break(1u);
  }
  uint64_t v4 = a4;
  unint64_t v8 = a2 + a4;
  if (__CFADD__(a2, a4)) {
    goto LABEL_12;
  }
  if (v7 >= v8)
  {
    this = memmove((void *)(this[4] + 8 * a2), __src, 8 * a4);
  }
  else
  {
    re::DynamicArray<unsigned long>::growCapacity(this, a2 + a4);
    unint64_t v10 = v6[2] - v5;
    unint64_t v11 = &__src[8 * v10];
    if (v10)
    {
      memmove((void *)(v6[4] + 8 * v5), __src, 8 * v10);
      unint64_t v5 = v6[2];
    }
    this = memcpy((void *)(v6[4] + 8 * v5), v11, &__src[8 * v4] - v11);
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

void *re::DynamicArray<float>::copy(void *this, unint64_t a2, char *__src, uint64_t a4)
{
  if (!a4) {
    return this;
  }
  unint64_t v5 = a2;
  uint64_t v6 = this;
  unint64_t v7 = this[2];
  if (v7 + 1 <= a2)
  {
    uint64_t v12 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v13) = 136315906;
    *(void *)((char *)&v13 + 4) = "copy";
    WORD6(v13) = 1024;
    HIWORD(v13) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, v5, v4, v12, v13);
    _os_crash();
    __break(1u);
  }
  uint64_t v4 = a4;
  unint64_t v8 = a2 + a4;
  if (__CFADD__(a2, a4)) {
    goto LABEL_12;
  }
  if (v7 >= v8)
  {
    this = memmove((void *)(this[4] + 4 * a2), __src, 4 * a4);
  }
  else
  {
    re::DynamicArray<float>::growCapacity(this, a2 + a4);
    unint64_t v10 = v6[2] - v5;
    unint64_t v11 = &__src[4 * v10];
    if (v10)
    {
      memmove((void *)(v6[4] + 4 * v5), __src, 4 * v10);
      unint64_t v5 = v6[2];
    }
    this = memcpy((void *)(v6[4] + 4 * v5), v11, &__src[4 * v4] - v11);
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

void re::convertQuaternionsToIntrinsicEulers<float>(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  switch(a3)
  {
    case 0:
      if (!a2) {
        return;
      }
      uint64_t v7 = 0;
      unint64_t v8 = (float *)(a1 + 8);
      uint64_t v9 = (float *)(a4 + 4);
      float v10 = 1.0;
      while (a5 != v7)
      {
        float v11 = *(v8 - 2);
        float v12 = *(v8 - 1);
        float v13 = v11 + v11;
        float v14 = v12 + v12;
        float v15 = *v8;
        float v16 = v8[1];
        float v17 = v15 + v15;
        float v18 = v15 * (float)(v15 + v15);
        float v127 = (float)(v12 + v12) * *v8;
        float v133 = v11 * (float)(v11 + v11);
        float v19 = (float)(v11 + v11) * v16;
        float v20 = (float)(v11 + v11) * *v8;
        float v21 = (float)(v12 + v12) * v16;
        float v22 = v20 + v21;
        if ((float)(v20 + v21) <= v10) {
          float v23 = v20 + v21;
        }
        else {
          float v23 = v10;
        }
        if (v23 < -1.0) {
          float v23 = -1.0;
        }
        float *v9 = asinf(v23);
        if (fabsf(v22) >= 0.9999)
        {
          float v27 = atan2f(v127 + v19, 1.0 - (float)(v133 + v18));
          float v28 = 0.0;
        }
        else
        {
          float v24 = v13 * v12;
          float v25 = 1.0 - (float)((float)(v12 * v14) + v18);
          float v26 = v24 - (float)(v17 * v16);
          float v27 = atan2f(-(float)(v127 - v19), 1.0 - (float)(v133 + (float)(v12 * v14)));
          float v28 = atan2f(-v26, v25);
        }
        *(v9 - 1) = v27;
        v9[1] = v28;
        ++v7;
        v8 += 4;
        v9 += 4;
        float v10 = 1.0;
        if (a2 == v7) {
          return;
        }
      }
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_79;
    case 1:
      if (!a2) {
        return;
      }
      uint64_t v29 = 0;
      uint64_t v30 = (float *)(a1 + 8);
      StringID v31 = (float *)(a4 + 8);
      float v32 = 1.0;
      while (a5 != v29)
      {
        float v33 = *(v30 - 2);
        float v34 = *(v30 - 1);
        float v35 = v33 + v33;
        float v36 = v34 + v34;
        float v38 = *v30;
        float v37 = v30[1];
        float v39 = v38 + v38;
        float v40 = v34 * (float)(v34 + v34);
        float v128 = (float)(v33 + v33) * *v30;
        float v134 = v33 * (float)(v33 + v33);
        float v41 = (float)(v34 + v34) * v37;
        float v42 = (float)(v33 + v33) * v34;
        float v43 = (float)(v38 + v38) * v37;
        float v44 = v42 + v43;
        if ((float)(v42 + v43) <= v32) {
          float v45 = v42 + v43;
        }
        else {
          float v45 = v32;
        }
        if (v45 < -1.0) {
          float v45 = -1.0;
        }
        *StringID v31 = asinf(v45);
        if (fabsf(v44) >= 0.9999)
        {
          float v47 = atan2f(v128 + v41, 1.0 - (float)(v134 + v40));
          float v46 = 0.0;
        }
        else
        {
          float v46 = atan2f(-(float)((float)(v36 * v38) - (float)(v35 * v37)), 1.0 - (float)(v134 + (float)(v38 * v39)));
          float v47 = atan2f(-(float)(v128 - v41), 1.0 - (float)(v40 + (float)(v38 * v39)));
        }
        *(v31 - 2) = v46;
        *(v31 - 1) = v47;
        ++v29;
        v30 += 4;
        v31 += 4;
        float v32 = 1.0;
        if (a2 == v29) {
          return;
        }
      }
LABEL_79:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_80;
    case 2:
      if (!a2) {
        return;
      }
      uint64_t v48 = 0;
      v49 = (float *)(a1 + 8);
      v50 = (float *)(a4 + 8);
      float v51 = 1.0;
      while (a5 != v48)
      {
        float v53 = *(v49 - 2);
        float v52 = *(v49 - 1);
        float v54 = v53 + v53;
        float v55 = v52 + v52;
        float v57 = *v49;
        float v56 = v49[1];
        float v58 = v57 * (float)(v57 + v57);
        float v129 = (float)(v53 + v53) * v52;
        float v135 = v52 * (float)(v52 + v52);
        float v59 = (float)(v57 + v57) * v56;
        float v60 = (float)(v52 + v52) * *v49;
        float v61 = (float)(v53 + v53) * v56;
        float v62 = v60 + v61;
        if ((float)(v60 + v61) <= v51) {
          float v63 = v60 + v61;
        }
        else {
          float v63 = v51;
        }
        if (v63 < -1.0) {
          float v63 = -1.0;
        }
        *(v50 - 2) = asinf(v63);
        if (fabsf(v62) >= 0.9999)
        {
          float v67 = atan2f(v129 + v59, 1.0 - (float)(v135 + v58));
          float v66 = 0.0;
        }
        else
        {
          float v64 = (float)(v54 * v57) - (float)(v55 * v56);
          float v65 = 1.0 - (float)((float)(v53 * v54) + v58);
          float v66 = atan2f(-v64, 1.0 - (float)((float)(v53 * v54) + v135));
          float v67 = atan2f(-(float)(v129 - v59), v65);
        }
        *(v50 - 1) = v66;
        float *v50 = v67;
        ++v48;
        v49 += 4;
        v50 += 4;
        float v51 = 1.0;
        if (a2 == v48) {
          return;
        }
      }
LABEL_80:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_81;
    case 3:
      if (!a2) {
        return;
      }
      uint64_t v68 = 0;
      v69 = (float *)(a1 + 8);
      v70 = (float *)(a4 + 8);
      float v71 = 1.0;
      while (a5 != v68)
      {
        float v72 = *(v69 - 2);
        float v73 = *(v69 - 1);
        float v74 = v72 + v72;
        float v75 = v73 + v73;
        float v77 = *v69;
        float v76 = v69[1];
        float v78 = v77 + v77;
        float v79 = v73 * (float)(v73 + v73);
        float v130 = (float)(v73 + v73) * *v69;
        float v136 = v72 * (float)(v72 + v72);
        float v124 = (float)(v72 + v72) * v76;
        float v80 = (float)(v72 + v72) * v73;
        float v81 = (float)(v77 + v77) * v76;
        float v82 = v80 - v81;
        if ((float)(v80 - v81) > v71) {
          float v82 = v71;
        }
        if (v82 < -1.0) {
          float v82 = -1.0;
        }
        float *v70 = asinf(-v82);
        if (vabds_f32(v80, v81) >= 0.9999)
        {
          float v87 = atan2f(-(float)(v130 - v124), 1.0 - (float)(v136 + v79));
          float v88 = 0.0;
        }
        else
        {
          float v83 = v74 * v77;
          float v84 = 1.0 - (float)(v79 + (float)(v77 * v78));
          float v85 = 1.0 - (float)(v136 + (float)(v77 * v78));
          float v86 = v83 + (float)(v75 * v76);
          float v87 = atan2f(v130 + v124, v85);
          float v88 = atan2f(v86, v84);
        }
        *(v70 - 2) = v87;
        *(v70 - 1) = v88;
        ++v68;
        v69 += 4;
        v70 += 4;
        float v71 = 1.0;
        if (a2 == v68) {
          return;
        }
      }
LABEL_81:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_82;
    case 4:
      if (!a2) {
        return;
      }
      uint64_t v89 = 0;
      v90 = (float *)(a1 + 8);
      v91 = (float *)(a4 + 8);
      float v92 = 1.0;
      while (a5 != v89)
      {
        float v93 = *(v90 - 2);
        float v94 = *(v90 - 1);
        float v95 = v93 + v93;
        float v96 = *v90;
        float v97 = v90[1];
        float v98 = v96 + v96;
        float v99 = v96 * (float)(v96 + v96);
        float v131 = (float)(v93 + v93) * *v90;
        float v137 = v94 * (float)(v94 + v94);
        float v125 = (float)(v94 + v94) * v97;
        float v100 = (float)(v94 + v94) * *v90;
        float v101 = (float)(v93 + v93) * v97;
        if ((float)(v100 - v101) >= -1.0) {
          float v102 = -(float)(v100 - v101);
        }
        else {
          float v102 = v92;
        }
        if (v102 < -1.0) {
          float v102 = -1.0;
        }
        *(v91 - 2) = asinf(v102);
        if (vabds_f32(v100, v101) >= 0.9999)
        {
          float v106 = atan2f(-(float)(v131 - v125), 1.0 - (float)(v137 + v99));
          float v107 = 0.0;
        }
        else
        {
          float v103 = v93 * v95;
          float v104 = (float)(v95 * v94) + (float)(v98 * v97);
          float v105 = 1.0 - (float)((float)(v93 * v95) + v99);
          float v106 = atan2f(v131 + v125, 1.0 - (float)(v103 + v137));
          float v107 = atan2f(v104, v105);
        }
        *(v91 - 1) = v106;
        float *v91 = v107;
        ++v89;
        v90 += 4;
        v91 += 4;
        float v92 = 1.0;
        if (a2 == v89) {
          return;
        }
      }
LABEL_82:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_83;
    case 5:
      if (!a2) {
        return;
      }
      uint64_t v108 = 0;
      v109 = (float *)(a1 + 8);
      v110 = (float *)(a4 + 4);
      float v111 = 1.0;
      do
      {
        if (a5 == v108)
        {
LABEL_83:
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
          _os_crash();
          __break(1u);
LABEL_84:
          re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unknown rotation order", "!\"Unreachable code\"", "convertQuaternionsToIntrinsicEulers", 505);
          _os_crash();
          __break(1u);
          JUMPOUT(0x23327B1C0);
        }
        float v112 = *(v109 - 2);
        float v113 = *(v109 - 1);
        float v114 = v112 + v112;
        float v115 = v113 + v113;
        float v117 = *v109;
        float v116 = v109[1];
        float v118 = v117 * (float)(v117 + v117);
        float v132 = (float)(v112 + v112) * v113;
        float v138 = v112 * (float)(v112 + v112);
        float v126 = (float)(v117 + v117) * v116;
        float v119 = (float)(v112 + v112) * *v109;
        float v120 = (float)(v113 + v113) * v116;
        float v121 = v119 - v120;
        if ((float)(v119 - v120) > v111) {
          float v121 = v111;
        }
        if (v121 < -1.0) {
          float v121 = -1.0;
        }
        float *v110 = asinf(-v121);
        if (vabds_f32(v119, v120) >= 0.9999)
        {
          float v123 = atan2f(-(float)(v132 - v126), 1.0 - (float)(v138 + v118));
          float v122 = 0.0;
        }
        else
        {
          float v122 = atan2f((float)(v115 * v117) + (float)(v114 * v116), 1.0 - (float)(v138 + (float)(v113 * v115)));
          float v123 = atan2f(v132 + v126, 1.0 - (float)((float)(v113 * v115) + v118));
        }
        *(v110 - 1) = v122;
        v110[1] = v123;
        ++v108;
        v109 += 4;
        v110 += 4;
        float v111 = 1.0;
      }
      while (a2 != v108);
      return;
    default:
      goto LABEL_84;
  }
}

float re::BlendSpace::init(uint64_t a1, uint64_t a2, unint64_t *a3, re::BindNode **a4)
{
  unint64_t v5 = a3;
  unint64_t v6 = a2;
  uint64_t v59 = *MEMORY[0x263EF8340];
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)a3;
  *(void *)(a1 + 16) = a3[8];
  unint64_t v8 = a3[5];
  unint64_t v9 = a3[3];
  *((void *)&v54 + 1) = v9;
  *(void *)&long long v55 = 0;
  *(void *)&long long v54 = a2;
  if (v9)
  {
    if (v9 >= 0x555555555555556)
    {
LABEL_45:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 48, v9);
      _os_crash();
      __break(1u);
      goto LABEL_46;
    }
    float v10 = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 48 * v9, 8);
    *(void *)&long long v55 = v10;
    if (!v10)
    {
LABEL_46:
      re::internal::assertLog((re::internal *)4, v11, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_47:
      re::internal::assertLog((re::internal *)4, v11, "assertion failure: '%s' (%s:line %i) Cannot copy from a Slice of a different size", "m_size == other.size()", "copy", 378);
      _os_crash();
      __break(1u);
      goto LABEL_48;
    }
    unint64_t v12 = v9 - 1;
    if (v9 != 1)
    {
      do
      {
        *float v10 = 0;
        v10[1] = "";
        v10[2] = 0;
        v10[3] = "";
        _OWORD v10[4] = 0;
        v10[5] = 0;
        v10 += 6;
        --v12;
      }
      while (v12);
    }
    *float v10 = 0;
    v10[1] = "";
    v10[2] = 0;
    v10[3] = "";
    _OWORD v10[4] = 0;
    v10[5] = 0;
    if (*((void *)&v54 + 1) != v9) {
      goto LABEL_47;
    }
    uint64_t v13 = 0;
    unint64_t v14 = v55;
    do
    {
      uint64_t v4 = (unint64_t *)(v14 + v13);
      re::StringID::operator=((unint64_t *)(v14 + v13), (uint64_t *)(v8 + v13));
      re::StringID::operator=((unint64_t *)(v14 + v13 + 16), (uint64_t *)(v8 + v13 + 16));
      *(_OWORD *)(v14 + v13 + 32) = *(_OWORD *)(v8 + v13 + 32);
      v13 += 48;
    }
    while (48 * v9 != v13);
  }
  else
  {
    unint64_t v14 = v55;
  }
  if ((long long *)(a1 + 72) != &v54)
  {
    uint64_t v15 = *(void *)(a1 + 72);
    if (v15) {
      BOOL v16 = v15 == (void)v54;
    }
    else {
      BOOL v16 = 1;
    }
    if (!v16)
    {
LABEL_48:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
      _os_crash();
      __break(1u);
    }
    uint64_t v17 = *(void *)(a1 + 80);
    uint64_t v18 = *(void *)(a1 + 88);
    *(void *)(a1 + 72) = v54;
    *(void *)(a1 + 80) = v9;
    *(void *)&long long v54 = v15;
    *((void *)&v54 + 1) = v17;
    *(void *)(a1 + 88) = v14;
    *(void *)&long long v55 = v18;
  }
  uint64_t v34 = v6;
  re::FixedArray<re::BlendSpaceAxisDefinition>::deinit(&v54);
  re::FixedArray<re::BindPoint>::init<>(a1 + 96, *(void *)a1, v5[3]);
  re::FixedArray<int>::init<>((uint64_t *)(a1 + 120), *(void *)a1, v5[3]);
  re::FixedArray<int>::init<>((uint64_t *)(a1 + 144), *(void *)a1, *(void *)(a1 + 16));
  re::FixedArray<int>::init<>((uint64_t *)(a1 + 168), *(void *)a1, *(void *)(a1 + 16));
  unint64_t v20 = v5[3];
  if (v20)
  {
    unint64_t v21 = 0;
    unint64_t v6 = 0;
    uint64_t v4 = (unint64_t *)&v40[8];
    unint64_t v14 = 0x268771000uLL;
    do
    {
      unint64_t v9 = v5[3];
      if (v9 <= v6) {
        goto LABEL_41;
      }
      unint64_t v9 = *(void *)(a1 + 128);
      if (v9 <= v6) {
        goto LABEL_42;
      }
      unint64_t v22 = v5[5] + v21;
      *(_DWORD *)(*(void *)(a1 + 136) + 4 * v6) = *(_DWORD *)(v22 + 40);
      re::StringID::StringID((re::StringID *)v37, (const StringID *)(v22 + 16));
      {
        re::introspect<float>(void)::info = re::introspect_float(0, v25);
      }
      size_t v23 = strlen(__s);
      v36[0] = (uint64_t)__s;
      v36[1] = v23;
      re::BindNode::bindPointWithOverride(a4, (uint64_t)re::introspect<float>(void)::info, v36, (uint64_t)v40);
      unint64_t v9 = *(void *)(a1 + 104);
      if (v9 <= v6) {
        goto LABEL_43;
      }
      float v24 = (void *)(*(void *)(a1 + 112) + v21);
      *float v24 = *(void *)v40;
      re::DynamicArray<re::RigDataValue>::operator=((uint64_t)(v24 + 1), (uint64_t)&v40[8]);
      re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v40[8]);
      re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v40[8]);
      re::StringID::destroyString((re::StringID *)v37);
      ++v6;
      v21 += 48;
    }
    while (v20 != v6);
  }
  if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFD) != 1)
  {
    re::FixedArray<int>::init<>((uint64_t *)(a1 + 24), v34, v5[8]);
    re::FixedArray<int>::init<>((uint64_t *)(a1 + 48), v34, v5[3] * v5[8]);
    unint64_t v26 = v5[8];
    if (v26)
    {
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      unint64_t v21 = 0;
      unint64_t v29 = v5[10];
      unint64_t v30 = v5[3];
      while (!v30)
      {
LABEL_36:
        unint64_t v5 = *(unint64_t **)(a1 + 32);
        if ((unint64_t)v5 <= v21) {
          goto LABEL_44;
        }
        float result = *(float *)(v29 + (v21 << 6) + 16);
        *(float *)(*(void *)(a1 + 40) + 4 * v21++) = result;
        v28 += v30;
        v27 += 4 * v30;
        if (v21 == v26) {
          return result;
        }
      }
      StringID v31 = 0;
      unint64_t v32 = v29 + (v21 << 6);
      unint64_t v5 = *(unint64_t **)(v32 + 40);
      float v33 = (void *)(v32 + 56);
      while (v5 != v31)
      {
        uint64_t v4 = (unint64_t *)((char *)v31 + v28);
        unint64_t v14 = *(void *)(a1 + 56);
        if (v14 <= (unint64_t)v31 + v28) {
          goto LABEL_40;
        }
        *(_DWORD *)(*(void *)(a1 + 64) + v27 + 4 * (void)v31) = *(_DWORD *)(*v33 + 4 * (void)v31);
        StringID v31 = (unint64_t *)((char *)v31 + 1);
        if ((unint64_t *)v30 == v31) {
          goto LABEL_36;
        }
      }
      *(void *)float v47 = 0;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v54 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float v40 = 136315906;
      *(void *)&v40[4] = "operator[]";
      __int16 v41 = 1024;
      int v42 = 797;
      __int16 v43 = 2048;
      float v44 = v5;
      __int16 v45 = 2048;
      unint64_t v46 = (unint64_t)v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_40:
      *(void *)float v47 = 0;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v54 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float v40 = 136315906;
      *(void *)&v40[4] = "operator[]";
      __int16 v41 = 1024;
      int v42 = 468;
      __int16 v43 = 2048;
      float v44 = v4;
      __int16 v45 = 2048;
      unint64_t v46 = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_41:
      *(void *)float v47 = 0;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v54 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float v40 = 136315906;
      *(void *)&v40[4] = "operator[]";
      __int16 v41 = 1024;
      int v42 = 797;
      __int16 v43 = 2048;
      float v44 = (unint64_t *)v6;
      __int16 v45 = 2048;
      unint64_t v46 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_42:
      *(void *)float v47 = 0;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v54 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float v40 = 136315906;
      *(void *)&v40[4] = "operator[]";
      __int16 v41 = 1024;
      int v42 = 468;
      __int16 v43 = 2048;
      float v44 = (unint64_t *)v6;
      __int16 v45 = 2048;
      unint64_t v46 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_43:
      uint64_t v39 = 0;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v54 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float v47 = 136315906;
      *(void *)&v47[4] = "operator[]";
      __int16 v48 = 1024;
      int v49 = 468;
      __int16 v50 = 2048;
      unint64_t v51 = v6;
      __int16 v52 = 2048;
      unint64_t v53 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_44:
      *(void *)float v47 = 0;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v54 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float v40 = 136315906;
      *(void *)&v40[4] = "operator[]";
      __int16 v41 = 1024;
      int v42 = 468;
      __int16 v43 = 2048;
      float v44 = (unint64_t *)v21;
      __int16 v45 = 2048;
      unint64_t v46 = (unint64_t)v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_45;
    }
  }
  return result;
}

unint64_t re::BlendSpace::samplePosition(re::BlendSpace *this, uint64_t a2)
{
  unint64_t v2 = *((void *)this + 10) * a2;
  if (*((void *)this + 7) <= v2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *((void *)this + 8) + 4 * v2;
}

void re::BlendSpace::computeWeights(re::BlendSpace *this, double a2)
{
  if (*((void *)this + 13))
  {
    unint64_t v3 = 0;
    uint64_t v4 = 24;
    do
    {
      unint64_t v5 = (uint64_t *)(*((void *)this + 14) + v4);
      uint64_t v7 = *v5;
      unint64_t v6 = (re::BindPoint *)(v5 - 3);
      if (v7 && re::BindPoint::isAlive(v6))
      {
        unint64_t v8 = (_DWORD *)re::BindPoint::valueUntyped(v6);
        if (*((void *)this + 16) <= v3) {
          goto LABEL_66;
        }
        *(_DWORD *)(*((void *)this + 17) + 4 * v3) = *v8;
      }
      ++v3;
      v4 += 48;
    }
    while (v3 < *((void *)this + 13));
  }
  switch(*((_DWORD *)this + 2))
  {
    case 1:
      if (!*((void *)this + 10)) {
        goto LABEL_72;
      }
      if (!*((void *)this + 16)) {
        goto LABEL_73;
      }
      unint64_t v9 = (float *)*((void *)this + 11);
      LODWORD(a2) = **((_DWORD **)this + 17);
      float v10 = (void *)*((void *)this + 23);
      unint64_t v11 = *((unsigned int *)v9 + 11);
      float v12 = v9[8];
      float v13 = v9[9];
      return;
    case 2:
      if (!*((void *)this + 16)) {
        goto LABEL_74;
      }
      unint64_t v14 = (float *)*((void *)this + 17);
      uint64_t v15 = (float *)re::BlendSpace::samplePosition(this, 0);
      BOOL v16 = (float *)re::BlendSpace::samplePosition(this, *((void *)this + 2) - 1);
      float v17 = *v14;
      if (*v14 > *v16) {
        float v17 = *v16;
      }
      if (v17 >= *v15) {
        float v18 = v17;
      }
      else {
        float v18 = *v15;
      }
      uint64_t v19 = *((void *)this + 22);
      if (v19) {
        bzero(*((void **)this + 23), 4 * v19);
      }
      if (*((void *)this + 2) < 2uLL) {
        return;
      }
      for (unint64_t i = 0; v18 > *(float *)re::BlendSpace::samplePosition(this, i + 1); ++i)
      {
        unint64_t v21 = i + 2;
        if (v21 >= *((void *)this + 2)) {
          return;
        }
      }
      float v52 = *(float *)re::BlendSpace::samplePosition(this, i);
      unint64_t v53 = (float *)re::BlendSpace::samplePosition(this, i + 1);
      unint64_t v54 = *((void *)this + 22);
      if (v54 <= i + 1) {
        goto LABEL_80;
      }
      float v55 = (float)(v18 - v52) / (float)(*v53 - v52);
      uint64_t v56 = *((void *)this + 23);
      *(float *)(v56 + 4 * i + 4) = v55;
      if (v54 <= i) {
        goto LABEL_81;
      }
      *(float *)(v56 + 4 * i) = 1.0 - v55;
      return;
    case 3:
      uint64_t v22 = *((void *)this + 10);
      if (!v22) {
        goto LABEL_75;
      }
      if (v22 == 1) {
        goto LABEL_76;
      }
      if (!*((void *)this + 16)) {
        goto LABEL_77;
      }
      uint64_t v23 = *((void *)this + 11);
      unint64_t v24 = *(unsigned int *)(v23 + 44);
      unint64_t v25 = *(unsigned int *)(v23 + 92);
      unint64_t v26 = (char *)*((void *)this + 20);
      LODWORD(a2) = **((_DWORD **)this + 17);
      if (*((void *)this + 16) <= 1uLL) {
        goto LABEL_78;
      }
      if (*((void *)this + 10) <= 1uLL) {
        goto LABEL_79;
      }
      LODWORD(v27) = *(_DWORD *)(*((void *)this + 17) + 4);
      if (!v25) {
        return;
      }
      unint64_t v28 = 0;
      uint64_t v29 = 0;
      while (!v24)
      {
LABEL_38:
        ++v29;
        v28 += v24;
        if (v29 == v25) {
          return;
        }
      }
      unint64_t v30 = *((void *)this + 22);
      unint64_t v31 = v28;
      unint64_t v32 = (float *)v26;
      unint64_t v33 = v24;
      while (v30 > v31)
      {
        float v34 = *v32++;
        *(float *)(*((void *)this + 23) + 4 * v31++) = *(float *)&v26[4 * v24 + 4 * v29] * v34;
        if (!--v33) {
          goto LABEL_38;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_65;
    case 4:
      if (!*((void *)this + 2)) {
        return;
      }
      unint64_t v35 = 0;
      uint64_t v36 = *((void *)this + 10);
      break;
    default:
      return;
  }
  do
  {
    unint64_t v37 = re::BlendSpace::samplePosition(this, v35);
    if (v36)
    {
      uint64_t v38 = 0;
      float v39 = 0.0;
      while (*((void *)this + 16) != v38)
      {
        float v40 = *(float *)(v37 + 4 * v38) - *(float *)(*((void *)this + 17) + 4 * v38);
        float v39 = v39 + (float)(v40 * v40);
        if (v36 == ++v38) {
          goto LABEL_48;
        }
      }
LABEL_65:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_66:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_67:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_68:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_69:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_70:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_71:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_72:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_73:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_74:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_75:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_76:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_77:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_78:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_79:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_80:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_81:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    float v39 = 0.0;
LABEL_48:
    unint64_t v41 = *((void *)this + 19);
    if (v41 <= v35) {
      goto LABEL_67;
    }
    uint64_t v42 = *((void *)this + 20);
    *(float *)(v42 + 4 * v35++) = v39;
    unint64_t v43 = *((void *)this + 2);
  }
  while (v35 < v43);
  if (v43)
  {
    unint64_t v44 = 0;
    uint64_t v45 = *((void *)this + 4);
    float v46 = 0.0;
    do
    {
      if (v45 == v44) {
        goto LABEL_68;
      }
      if (v41 <= v44) {
        goto LABEL_69;
      }
      unint64_t v47 = *((void *)this + 22);
      if (v47 <= v44) {
        goto LABEL_70;
      }
      float v48 = *(float *)(*((void *)this + 5) + 4 * v44) * *(float *)(*((void *)this + 5) + 4 * v44);
      float v49 = expf((float)-*(float *)(v42 + 4 * v44) / (float)(v48 + v48));
      uint64_t v50 = *((void *)this + 23);
      *(float *)(v50 + 4 * v44) = v49;
      float v46 = v46 + v49;
      ++v44;
    }
    while (v43 != v44);
    uint64_t v51 = 0;
    while (v47 != v51)
    {
      *(float *)(v50 + 4 * v51) = *(float *)(v50 + 4 * v51) / v46;
      if (v43 == ++v51) {
        return;
      }
    }
    goto LABEL_71;
  }
}

void anonymous namespace'::computeWeightsForUniformAxis(void *a1, unint64_t a2, double a3, float a4, float a5)
{
  if (a5 < *(float *)&a3) {
    *(float *)&a3 = a5;
  }
  if (*(float *)&a3 < a4) {
    *(float *)&a3 = a4;
  }
  float v7 = (float)((float)(*(float *)&a3 - a4) / (float)(a5 - a4)) * (float)(a2 - 1);
  float v8 = floorf(v7);
  int v9 = (int)(float)(v8 + 1.0);
  if (a2) {
    bzero(a1, 4 * a2);
  }
  *(float *)&a3 = v7 - v8;
  if (a2 > v9) {
    *((_DWORD *)a1 + v9) = LODWORD(a3);
  }
  unint64_t v10 = v9 - 1;
  if (a2 <= v10)
  {
    re::internal::assertLog((re::internal *)6, a2, a3, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v10, a2);
    _os_crash();
    __break(1u);
  }
  else
  {
    *((float *)a1 + v10) = 1.0 - *(float *)&a3;
  }
}

uint64_t re::BlendSpaceBuilder::addAxis(re::BlendSpaceBuilder *this, const re::StringID *a2, int a3, float a4, float a5)
{
  if (re::BlendSpaceBuilder::axisIndex(this, a2) != -1) {
    return -1;
  }
  uint64_t v11 = *((void *)this + 1);
  if ((*(_DWORD *)v11 & 0xFFFFFFFD) != 1 || (uint64_t v10 = -1, a3) && (float)(a5 - a4) > 0.0)
  {
    float v12 = (_anonymous_namespace_ *)(v11 + 8);
    uint64_t v10 = *(void *)(v11 + 24);
    re::StringID::StringID((re::StringID *)&v14, (const StringID *)a2);
    v15[0] = 0;
    v15[1] = &str_7;
    float v16 = a4;
    float v17 = a5;
    int v18 = 0;
    int v19 = a3;
    re::DynamicArray<re::BlendSpaceAxisDefinition>::add(v12, &v14);
    re::StringID::destroyString((re::StringID *)v15);
    re::StringID::destroyString((re::StringID *)&v14);
  }
  return v10;
}

uint64_t re::BlendSpaceBuilder::axisIndex(re::BlendSpaceBuilder *this, const re::StringID *a2)
{
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = *(void *)(v2 + 24);
  if (!v3) {
    return -1;
  }
  uint64_t v5 = 0;
  for (unint64_t i = *(void **)(v2 + 40); !re::StringID::operator==(i, a2); i += 6)
  {
    if (v3 == ++v5) {
      return -1;
    }
  }
  return v5;
}

uint64_t re::BlendSpaceBuilder::setDefaultControlValueForAxis(uint64_t this, unint64_t a2, float a3)
{
  uint64_t v3 = *(void *)(this + 8);
  if (*(void *)(v3 + 24) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(float *)(*(void *)(v3 + 40) + 48 * a2 + 40) = a3;
  return this;
}

unint64_t *re::BlendSpaceBuilder::setControlValueBindPath(re::BlendSpaceBuilder *this, unint64_t a2, const re::StringID *a3)
{
  uint64_t v3 = *((void *)this + 1);
  if (*(void *)(v3 + 24) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v4 = (unint64_t *)(*(void *)(v3 + 40) + 48 * a2 + 16);
  return re::StringID::operator=(v4, (uint64_t *)a3);
}

uint64_t re::BlendSpaceBuilder::addSample(re::BlendSpaceBuilder *this, StringID *a2)
{
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = *(void *)(v3 + 64);
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = *(void **)(v3 + 80);
    uint64_t v7 = -v4;
    while (!re::StringID::operator==(v6, a2))
    {
      --v5;
      v6 += 8;
      if (v7 == v5) {
        goto LABEL_7;
      }
    }
    if (v5 != 1) {
      return -1;
    }
  }
LABEL_7:
  if ((*(_DWORD *)v3 & 0xFFFFFFFD) == 1) {
    return -1;
  }
  re::StringID::StringID((re::StringID *)v10, a2);
  _OWORD v10[4] = 0.0;
  uint64_t v15 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  int v14 = 0;
  float v9 = re::DynamicArray<re::BlendSpaceSampleDefinition>::add((_anonymous_namespace_ *)(v3 + 48), v10);
  if (v11)
  {
    if (v15) {
      (*(void (**)(float))(*(void *)v11 + 40))(v9);
    }
    uint64_t v15 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v11 = 0;
    ++v14;
  }
  re::StringID::destroyString((re::StringID *)v10);
  return *(void *)(v3 + 64) - 1;
}

uint64_t re::BlendSpaceBuilder::setSamplePosition(uint64_t a1, unint64_t a2, float *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (a4 != *(void *)(v4 + 24) || (*(_DWORD *)v4 & 0xFFFFFFFD) == 1) {
    return 0;
  }
  if (*(void *)(v4 + 64) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v6 = a4;
  if (a4)
  {
    float v8 = (_anonymous_namespace_ *)(*(void *)(v4 + 80) + (a2 << 6) + 24);
    do
    {
      re::DynamicArray<float>::add(v8, a3++);
      --v6;
    }
    while (v6);
  }
  return 1;
}

uint64_t re::BlendSpaceBuilder::setSampleFalloff(uint64_t this, unint64_t a2, float a3)
{
  uint64_t v3 = *(void *)(this + 8);
  if (*(void *)(v3 + 64) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(float *)(*(void *)(v3 + 80) + (a2 << 6) + 16) = a3;
  return this;
}

unint64_t re::BlendSpaceBuilder::addSampleUniform(re::BlendSpaceBuilder *this, StringID *a2, int a3, int a4)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  uint64_t v5 = *((void *)this + 1);
  if ((*(_DWORD *)v5 & 0xFFFFFFFD) != 1) {
    return -1;
  }
  uint64_t v6 = *(void *)(v5 + 24);
  if (!v6)
  {
    *(void *)unint64_t v28 = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v35 = 0u;
    unint64_t v15 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v23 = 136315906;
    *(void *)&v23[4] = "operator[]";
    *(_WORD *)&v23[12] = 1024;
    *(_DWORD *)&v23[14] = 789;
    *(_WORD *)&v23[18] = 2048;
    *(void *)unint64_t v24 = 0;
    *(_WORD *)&v24[8] = 2048;
    *(void *)&v24[10] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v11 = *(void *)(v5 + 40);
  if (v6 != 1) {
    LODWORD(v6) = *(_DWORD *)(v11 + 92);
  }
  int v12 = *(_DWORD *)(v11 + 44);
  if (!*(void *)(v5 + 64))
  {
    unint64_t v13 = (v6 * v12);
    *(void *)(v5 + 48) = *(void *)this;
    uint64_t v14 = v5 + 48;
    re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((void *)v14, v13);
    ++*(_DWORD *)(v14 + 24);
    re::DynamicArray<re::BlendSpaceSampleDefinition>::resize(*((void *)this + 1) + 48, v13);
  }
  unint64_t v15 = (a4 + v12 * a3);
  re::StringID::StringID((re::StringID *)v23, a2);
  *(_DWORD *)&v23[16] = 0;
  uint64_t v27 = 0;
  *(void *)&v24[12] = 0;
  uint64_t v25 = 0;
  *(void *)&v24[4] = 0;
  int v26 = 0;
  uint64_t v16 = *((void *)this + 1);
  unint64_t v4 = *(void *)(v16 + 64);
  if (v4 <= v15)
  {
LABEL_16:
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v35 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v28 = 136315906;
    *(void *)&v28[4] = "operator[]";
    __int16 v29 = 1024;
    int v30 = 789;
    __int16 v31 = 2048;
    unint64_t v32 = v15;
    __int16 v33 = 2048;
    unint64_t v34 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v17 = *(void *)(v16 + 80) + (v15 << 6);
  uint64_t v18 = *(void *)v23;
  uint64_t v19 = *(void *)&v23[8];
  *(void *)uint64_t v23 = 0;
  *(void *)&v23[8] = "";
  uint64_t v20 = *(void *)(v17 + 8);
  unint64_t v21 = v18 & 0xFFFFFFFFFFFFFFFELL | *(void *)v17 & 1;
  *(void *)(v17 + 8) = v19;
  *(void *)&long long v35 = v21;
  *((void *)&v35 + 1) = v20;
  *(void *)uint64_t v17 = v18;
  re::StringID::destroyString((re::StringID *)&v35);
  *(_DWORD *)(v17 + 16) = *(_DWORD *)&v23[16];
  re::DynamicArray<re::RigComponentConstraint>::operator=(v17 + 24, (uint64_t)&v24[4]);
  if (*(void *)&v24[4])
  {
    if (v27) {
      (*(void (**)(void))(**(void **)&v24[4] + 40))();
    }
    uint64_t v27 = 0;
    *(void *)&v24[12] = 0;
    uint64_t v25 = 0;
    *(void *)&v24[4] = 0;
    ++v26;
  }
  re::StringID::destroyString((re::StringID *)v23);
  return v15;
}

void re::BlendSpaceBuilder::build(re::BlendSpaceBuilder *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (int *)*((void *)this + 1);
  unint64_t v4 = *((void *)v3 + 8);
  if (v4 <= 1)
  {
    long long v5 = v31;
    uint64_t v6 = v32;
    uint64_t v7 = v33;
    *(unsigned char *)a2 = 0;
    uint64_t v8 = 8000;
LABEL_28:
    *(void *)(a2 + 8) = v8;
    *(void *)(a2 + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a2 + 24) = v5;
    *(void *)(a2 + 40) = v6;
    *(void *)(a2 + 48) = v7;
    return;
  }
  uint64_t v9 = *((void *)v3 + 3);
  if (!v9)
  {
    long long v5 = v31;
    uint64_t v6 = v32;
    uint64_t v7 = v33;
    *(unsigned char *)a2 = 0;
    uint64_t v8 = 8003;
    goto LABEL_28;
  }
  int v11 = *v3;
  if ((*v3 & 0xFFFFFFFD) == 1)
  {
    uint64_t v12 = *((void *)v3 + 5);
    uint64_t v13 = v12 + 48 * v9;
    do
    {
      re::StringID::StringID((re::StringID *)&v31, (const StringID *)v12);
      re::StringID::StringID((re::StringID *)&v32, (const StringID *)(v12 + 16));
      long long v34 = *(_OWORD *)(v12 + 32);
      if ((float)(*((float *)&v34 + 1) - *(float *)&v34) <= 0.0)
      {
        re::DynamicString::format((re::DynamicString *)"Axis range for uniform blend space not defined for axis %s.", (re::DynamicString *)&v28, *((void *)&v31 + 1));
        long long v25 = v28;
        uint64_t v26 = v29;
        uint64_t v27 = v30;
        *(unsigned char *)a2 = 0;
        *(void *)(a2 + 8) = 8001;
        *(void *)(a2 + 16) = &re::AnimationErrorCategory(void)::instance;
        *(_OWORD *)(a2 + 24) = v25;
        *(void *)(a2 + 40) = v26;
        *(void *)(a2 + 48) = v27;
        re::StringID::destroyString((re::StringID *)&v32);
        re::StringID::destroyString((re::StringID *)&v31);
        return;
      }
      re::StringID::destroyString((re::StringID *)&v32);
      re::StringID::destroyString((re::StringID *)&v31);
      v12 += 48;
    }
    while (v12 != v13);
    uint64_t v15 = *((void *)v3 + 8);
    if (!v15) {
      goto LABEL_19;
    }
    uint64_t v16 = v15 << 6;
    uint64_t v17 = (void *)(*((void *)v3 + 10) + 8);
    while (*(v17 - 1) > 1uLL || !*v17 || *(unsigned char *)*v17)
    {
      v17 += 8;
      v16 -= 64;
      if (!v16) {
        goto LABEL_19;
      }
    }
LABEL_27:
    long long v5 = v31;
    uint64_t v6 = v32;
    uint64_t v7 = v33;
    *(unsigned char *)a2 = 0;
    uint64_t v8 = 8002;
    goto LABEL_28;
  }
  uint64_t v18 = (void *)(*((void *)v3 + 10) + 40);
  unint64_t v19 = v4 << 6;
  do
  {
    if (*v18 != v9)
    {
      re::DynamicString::format((re::DynamicString *)"Blend space sample %s has an invalid position.", (re::DynamicString *)&v31, *(v18 - 4));
      goto LABEL_27;
    }
    v18 += 8;
    v19 -= 64;
  }
  while (v19);
LABEL_19:
  uint64_t v20 = *((void *)this + 1);
  if (v11 == 2)
  {
    uint64_t v21 = *(void *)(v20 + 80);
    unint64_t v22 = *(void *)(v20 + 64);
    unint64_t v23 = 126 - 2 * __clz(v22);
    if (v22) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = 0;
    }
    std::__introsort<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *,false>(v21, v21 + (v22 << 6), v24, 1);
    uint64_t v20 = *((void *)this + 1);
  }
  *(unsigned char *)a2 = 1;
  *(void *)(a2 + 8) = v20;
}

void std::__introsort<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *,false>(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    v158 = (uint64_t *)(a2 - 64);
    uint64_t v9 = (uint64_t *)a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = (uint64_t)v9;
          uint64_t v10 = a2 - (void)v9;
          unint64_t v11 = (uint64_t)(a2 - (void)v9) >> 6;
          if (!(!v5 & v4))
          {
            switch(v11)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a2 - 24), *(float **)(a2 - 8), *(void *)(a1 + 40), *(float **)(a1 + 56)))
                {
                  std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a1, v158);
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1, a1 + 64, (uint64_t)v158);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1, a1 + 64, a1 + 128, (uint64_t)v158);
                break;
              case 5uLL:
                std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *,0>(a1, a1 + 64, a1 + 128, a1 + 192, (uint64_t)v158);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v10 <= 1535)
          {
            if (a4)
            {
              if (a1 != a2)
              {
                float v61 = (void *)(a1 + 64);
                if (a1 + 64 != a2)
                {
                  uint64_t v62 = 0;
                  float v63 = (void *)a1;
                  do
                  {
                    float v64 = v61;
                    if (re::BlendSpaceBuilder::build(void)::$_0::operator()(v61[5], (float *)v61[7], v63[5], (float *)v63[7]))
                    {
                      unint64_t v65 = a2;
                      uint64_t v66 = *v64;
                      float v67 = (const char *)v64[1];
                      unint64_t v169 = *v64 & 1;
                      unint64_t v169 = *v64 & 0xFFFFFFFFFFFFFFFELL | v66 & 1;
                      v170 = v67;
                      void *v64 = 0;
                      v64[1] = "";
                      int v171 = *((_DWORD *)v63 + 20);
                      uint64_t v172 = v63[11];
                      long long v173 = *((_OWORD *)v63 + 6);
                      v63[12] = 0;
                      v63[13] = 0;
                      v63[11] = 0;
                      v175 = (float *)v63[15];
                      v63[15] = 0;
                      ++*((_DWORD *)v63 + 28);
                      int v174 = 1;
                      uint64_t v68 = v62;
                      while (1)
                      {
                        uint64_t v69 = a1 + v68;
                        uint64_t v70 = *(void *)(a1 + v68);
                        uint64_t v71 = *(void *)(a1 + v68 + 8);
                        *(void *)uint64_t v69 = 0;
                        *(void *)(v69 + 8) = "";
                        float v72 = *(const char **)(a1 + v68 + 72);
                        unint64_t v73 = v70 & 0xFFFFFFFFFFFFFFFELL | *(void *)(a1 + v68 + 64) & 1;
                        *(void *)(v69 + 72) = v71;
                        unint64_t v161 = v73;
                        v162 = v72;
                        *(void *)(v69 + 64) = v70;
                        re::StringID::destroyString((re::StringID *)&v161);
                        *(_DWORD *)(v69 + 80) = *(_DWORD *)(v69 + 16);
                        re::DynamicArray<re::RigComponentConstraint>::operator=(v69 + 88, v69 + 24);
                        if (!v68) {
                          break;
                        }
                        v68 -= 64;
                        if (!re::BlendSpaceBuilder::build(void)::$_0::operator()(*((uint64_t *)&v173 + 1), v175, *(void *)(v69 - 24), *(float **)(v69 - 8)))
                        {
                          uint64_t v74 = a1 + v68 + 64;
                          goto LABEL_76;
                        }
                      }
                      uint64_t v74 = a1;
LABEL_76:
                      unint64_t v75 = v169;
                      float v76 = v170;
                      unint64_t v169 = 0;
                      v170 = "";
                      float v77 = *(const char **)(v74 + 8);
                      unint64_t v78 = v75 & 0xFFFFFFFFFFFFFFFELL | *(void *)v74 & 1;
                      *(void *)(v74 + 8) = v76;
                      unint64_t v161 = v78;
                      v162 = v77;
                      *(void *)uint64_t v74 = v75;
                      re::StringID::destroyString((re::StringID *)&v161);
                      *(_DWORD *)(v74 + 16) = v171;
                      re::DynamicArray<re::RigComponentConstraint>::operator=(v69 + 24, (uint64_t)&v172);
                      a2 = v65;
                      if (v172)
                      {
                        if (v175) {
                          (*(void (**)(void))(*(void *)v172 + 40))();
                        }
                        v175 = 0;
                        long long v173 = 0uLL;
                        uint64_t v172 = 0;
                        ++v174;
                      }
                      re::StringID::destroyString((re::StringID *)&v169);
                    }
                    float v61 = v64 + 8;
                    v62 += 64;
                    float v63 = v64;
                  }
                  while (v64 + 8 != (void *)a2);
                }
              }
            }
            else if (a1 != a2)
            {
              v143 = (unint64_t *)(a1 + 64);
              if (a1 + 64 != a2)
              {
                do
                {
                  v144 = v143;
                  if (re::BlendSpaceBuilder::build(void)::$_0::operator()(v143[5], (float *)v143[7], *(void *)(a1 + 40), *(float **)(a1 + 56)))
                  {
                    unint64_t v145 = *v144;
                    v146 = (const char *)v144[1];
                    unint64_t v169 = *v144 & 1;
                    unint64_t v169 = *v144 & 0xFFFFFFFFFFFFFFFELL | v145 & 1;
                    v170 = v146;
                    unint64_t *v144 = 0;
                    v144[1] = (unint64_t)"";
                    int v171 = *(_DWORD *)(a1 + 80);
                    uint64_t v172 = *(void *)(a1 + 88);
                    long long v173 = *(_OWORD *)(a1 + 96);
                    *(void *)(a1 + 96) = 0;
                    *(void *)(a1 + 104) = 0;
                    *(void *)(a1 + 88) = 0;
                    v175 = *(float **)(a1 + 120);
                    *(void *)(a1 + 120) = 0;
                    ++*(_DWORD *)(a1 + 112);
                    int v174 = 1;
                    uint64_t v147 = v144;
                    do
                    {
                      uint64_t v148 = v147;
                      unint64_t v149 = *(v147 - 8);
                      v147 -= 8;
                      unint64_t v150 = *(v148 - 7);
                      *(v148 - 7) = (unint64_t)"";
                      *uint64_t v147 = 0;
                      StringID v151 = (const char *)v148[1];
                      unint64_t v152 = v149 & 0xFFFFFFFFFFFFFFFELL | *v148 & 1;
                      v148[1] = v150;
                      unint64_t v161 = v152;
                      v162 = v151;
                      *uint64_t v148 = v149;
                      re::StringID::destroyString((re::StringID *)&v161);
                      *((_DWORD *)v148 + 4) = *((_DWORD *)v148 - 12);
                      re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(v148 + 3), (uint64_t)(v148 - 5));
                    }
                    while (re::BlendSpaceBuilder::build(void)::$_0::operator()(*((uint64_t *)&v173 + 1), v175, *(v148 - 11), (float *)*(v148 - 9)));
                    unint64_t v153 = v169;
                    v154 = v170;
                    unint64_t v169 = 0;
                    v170 = "";
                    v155 = (const char *)v147[1];
                    unint64_t v156 = v153 & 0xFFFFFFFFFFFFFFFELL | *v147 & 1;
                    v147[1] = (unint64_t)v154;
                    unint64_t v161 = v156;
                    v162 = v155;
                    *uint64_t v147 = v153;
                    re::StringID::destroyString((re::StringID *)&v161);
                    *((_DWORD *)v147 + 4) = v171;
                    re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(v147 + 3), (uint64_t)&v172);
                    if (v172)
                    {
                      if (v175) {
                        (*(void (**)(void))(*(void *)v172 + 40))();
                      }
                      v175 = 0;
                      long long v173 = 0uLL;
                      uint64_t v172 = 0;
                      ++v174;
                    }
                    re::StringID::destroyString((re::StringID *)&v169);
                  }
                  v143 = v144 + 8;
                  a1 = (uint64_t)v144;
                }
                while (v144 + 8 != (unint64_t *)a2);
              }
            }
            return;
          }
          if (!a3)
          {
            if (a1 != a2)
            {
              unint64_t v157 = a2;
              int64_t v160 = (v11 - 2) >> 1;
              int64_t v79 = v160;
              do
              {
                int64_t v80 = v79;
                if (v160 >= v79)
                {
                  uint64_t v81 = (2 * v79) | 1;
                  uint64_t v82 = a1 + (v81 << 6);
                  if (2 * v79 + 2 < (uint64_t)v11)
                  {
                    BOOL v83 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(v82 + 40), *(float **)(v82 + 56), *(void *)(v82 + 104), *(float **)(v82 + 120));
                    v82 += (unint64_t)v83 << 6;
                    if (v83) {
                      uint64_t v81 = 2 * v80 + 2;
                    }
                  }
                  uint64_t v84 = a1 + (v80 << 6);
                  if (!re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(v82 + 40), *(float **)(v82 + 56), *(void *)(v84 + 40), *(float **)(v84 + 56)))
                  {
                    uint64_t v85 = *(void *)v84;
                    unint64_t v169 = *(void *)v84 & 1;
                    unint64_t v169 = *(void *)v84 & 0xFFFFFFFFFFFFFFFELL | v85 & 1;
                    v170 = *(const char **)(v84 + 8);
                    *(void *)uint64_t v84 = 0;
                    *(void *)(v84 + 8) = "";
                    uint64_t v86 = a1 + (v80 << 6);
                    int v171 = *(_DWORD *)(v86 + 16);
                    uint64_t v172 = *(void *)(v86 + 24);
                    *(void *)(v86 + 24) = 0;
                    *(void *)&long long v173 = *(void *)(v86 + 32);
                    *(void *)(v86 + 32) = 0;
                    *((void *)&v173 + 1) = *(void *)(v86 + 40);
                    *(void *)(v86 + 40) = 0;
                    v175 = *(float **)(v86 + 56);
                    *(void *)(v86 + 56) = 0;
                    ++*(_DWORD *)(v86 + 48);
                    int v174 = 1;
                    do
                    {
                      uint64_t v87 = v82;
                      uint64_t v88 = *(void *)v82;
                      uint64_t v89 = *(void *)(v82 + 8);
                      *(void *)uint64_t v82 = 0;
                      *(void *)(v82 + 8) = "";
                      v90 = *(const char **)(v84 + 8);
                      unint64_t v91 = v88 & 0xFFFFFFFFFFFFFFFELL | *(void *)v84 & 1;
                      *(void *)(v84 + 8) = v89;
                      unint64_t v161 = v91;
                      v162 = v90;
                      *(void *)uint64_t v84 = v88;
                      re::StringID::destroyString((re::StringID *)&v161);
                      *(_DWORD *)(v84 + 16) = *(_DWORD *)(v82 + 16);
                      uint64_t v92 = v82 + 24;
                      re::DynamicArray<re::RigComponentConstraint>::operator=(v84 + 24, v82 + 24);
                      if (v160 < v81) {
                        break;
                      }
                      uint64_t v93 = (2 * v81) | 1;
                      uint64_t v82 = a1 + (v93 << 6);
                      uint64_t v94 = 2 * v81 + 2;
                      if (v94 < (uint64_t)v11)
                      {
                        BOOL v95 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(v82 + 40), *(float **)(v82 + 56), *(void *)(v82 + 104), *(float **)(v82 + 120));
                        v82 += (unint64_t)v95 << 6;
                        if (v95) {
                          uint64_t v93 = v94;
                        }
                      }
                      uint64_t v84 = v87;
                      uint64_t v81 = v93;
                    }
                    while (!re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(v82 + 40), *(float **)(v82 + 56), *((uint64_t *)&v173 + 1), v175));
                    unint64_t v96 = v169;
                    float v97 = v170;
                    unint64_t v169 = 0;
                    v170 = "";
                    float v98 = *(const char **)(v87 + 8);
                    unint64_t v99 = v96 & 0xFFFFFFFFFFFFFFFELL | *(void *)v87 & 1;
                    *(void *)(v87 + 8) = v97;
                    unint64_t v161 = v99;
                    v162 = v98;
                    *(void *)uint64_t v87 = v96;
                    re::StringID::destroyString((re::StringID *)&v161);
                    *(_DWORD *)(v87 + 16) = v171;
                    re::DynamicArray<re::RigComponentConstraint>::operator=(v92, (uint64_t)&v172);
                    if (v172)
                    {
                      if (v175) {
                        (*(void (**)(void))(*(void *)v172 + 40))();
                      }
                      v175 = 0;
                      long long v173 = 0uLL;
                      uint64_t v172 = 0;
                      ++v174;
                    }
                    re::StringID::destroyString((re::StringID *)&v169);
                  }
                }
                int64_t v79 = v80 - 1;
              }
              while (v80);
              uint64_t v100 = (unint64_t)v10 >> 6;
              unint64_t v101 = v157;
              do
              {
                uint64_t v102 = 0;
                uint64_t v103 = *(void *)a1;
                float v104 = *(const char **)(a1 + 8);
                unint64_t v161 = *(void *)a1 & 1;
                unint64_t v161 = *(void *)a1 & 0xFFFFFFFFFFFFFFFELL | v103 & 1;
                v162 = v104;
                *(void *)a1 = 0;
                *(void *)(a1 + 8) = "";
                int v163 = *(_DWORD *)(a1 + 16);
                uint64_t v105 = *(void *)(a1 + 32);
                uint64_t v164 = *(void *)(a1 + 24);
                *(void *)(a1 + 24) = 0;
                uint64_t v165 = v105;
                *(void *)(a1 + 32) = 0;
                uint64_t v166 = *(void *)(a1 + 40);
                *(void *)(a1 + 40) = 0;
                uint64_t v168 = *(void *)(a1 + 56);
                *(void *)(a1 + 56) = 0;
                ++*(_DWORD *)(a1 + 48);
                int v167 = 1;
                uint64_t v106 = a1;
                do
                {
                  uint64_t v107 = v106 + (v102 << 6) + 64;
                  uint64_t v108 = (2 * v102) | 1;
                  uint64_t v109 = 2 * v102 + 2;
                  if (v109 < v100)
                  {
                    BOOL v110 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(v106 + (v102 << 6) + 104), *(float **)(v106 + (v102 << 6) + 120), *(void *)(v106 + (v102 << 6) + 168), *(float **)(v106 + (v102 << 6) + 184));
                    v107 += (unint64_t)v110 << 6;
                    if (v110) {
                      uint64_t v108 = v109;
                    }
                  }
                  uint64_t v111 = *(void *)v107;
                  uint64_t v112 = *(void *)(v107 + 8);
                  *(void *)uint64_t v107 = 0;
                  *(void *)(v107 + 8) = "";
                  float v113 = *(const char **)(v106 + 8);
                  unint64_t v114 = v111 & 0xFFFFFFFFFFFFFFFELL | *(void *)v106 & 1;
                  *(void *)(v106 + 8) = v112;
                  unint64_t v169 = v114;
                  v170 = v113;
                  *(void *)uint64_t v106 = v111;
                  re::StringID::destroyString((re::StringID *)&v169);
                  *(_DWORD *)(v106 + 16) = *(_DWORD *)(v107 + 16);
                  re::DynamicArray<re::RigComponentConstraint>::operator=(v106 + 24, v107 + 24);
                  uint64_t v106 = v107;
                  uint64_t v102 = v108;
                }
                while (v108 <= (uint64_t)((unint64_t)(v100 - 2) >> 1));
                if (v107 == v101 - 64)
                {
                  unint64_t v138 = v161;
                  v139 = v162;
                  unint64_t v161 = 0;
                  v162 = "";
                  v140 = *(const char **)(v107 + 8);
                  unint64_t v141 = v138 & 0xFFFFFFFFFFFFFFFELL | *(void *)v107 & 1;
                  *(void *)(v107 + 8) = v139;
                  unint64_t v169 = v141;
                  v170 = v140;
                  *(void *)uint64_t v107 = v138;
                  re::StringID::destroyString((re::StringID *)&v169);
                  *(_DWORD *)(v107 + 16) = v163;
                  re::DynamicArray<re::RigComponentConstraint>::operator=(v107 + 24, (uint64_t)&v164);
                }
                else
                {
                  uint64_t v115 = *(void *)(v101 - 64);
                  uint64_t v116 = *(void *)(v101 - 56);
                  *(void *)(v101 - 64) = 0;
                  *(void *)(v101 - 56) = "";
                  float v117 = *(const char **)(v107 + 8);
                  unint64_t v118 = v115 & 0xFFFFFFFFFFFFFFFELL | *(void *)v107 & 1;
                  *(void *)(v107 + 8) = v116;
                  unint64_t v169 = v118;
                  v170 = v117;
                  *(void *)uint64_t v107 = v115;
                  re::StringID::destroyString((re::StringID *)&v169);
                  *(_DWORD *)(v107 + 16) = *(_DWORD *)(v101 - 48);
                  re::DynamicArray<re::RigComponentConstraint>::operator=(v107 + 24, v101 - 40);
                  unint64_t v119 = v161;
                  float v120 = v162;
                  unint64_t v161 = 0;
                  v162 = "";
                  float v121 = *(const char **)(v101 - 56);
                  unint64_t v122 = v119 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v101 - 64) & 1;
                  *(void *)(v101 - 56) = v120;
                  unint64_t v169 = v122;
                  v170 = v121;
                  *(void *)(v101 - 64) = v119;
                  re::StringID::destroyString((re::StringID *)&v169);
                  *(_DWORD *)(v101 - 48) = v163;
                  re::DynamicArray<re::RigComponentConstraint>::operator=(v101 - 40, (uint64_t)&v164);
                  uint64_t v123 = v107 - a1 + 64;
                  if (v123 >= 65)
                  {
                    unint64_t v124 = (((unint64_t)v123 >> 6) - 2) >> 1;
                    unint64_t v125 = a1 + (v124 << 6);
                    if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(v125 + 40), *(float **)(v125 + 56), *(void *)(v107 + 40), *(float **)(v107 + 56)))
                    {
                      uint64_t v126 = *(void *)v107;
                      float v127 = *(const char **)(v107 + 8);
                      unint64_t v169 = *(void *)v107 & 1;
                      unint64_t v169 = *(void *)v107 & 0xFFFFFFFFFFFFFFFELL | v126 & 1;
                      v170 = v127;
                      *(void *)uint64_t v107 = 0;
                      *(void *)(v107 + 8) = "";
                      int v171 = *(_DWORD *)(v107 + 16);
                      uint64_t v172 = *(void *)(v107 + 24);
                      *(void *)(v107 + 24) = 0;
                      *(void *)&long long v173 = *(void *)(v107 + 32);
                      *(void *)(v107 + 32) = 0;
                      *((void *)&v173 + 1) = *(void *)(v107 + 40);
                      *(void *)(v107 + 40) = 0;
                      v175 = *(float **)(v107 + 56);
                      *(void *)(v107 + 56) = 0;
                      ++*(_DWORD *)(v107 + 48);
                      int v174 = 1;
                      do
                      {
                        uint64_t v128 = v125;
                        uint64_t v129 = *(void *)v125;
                        uint64_t v130 = *(void *)(v125 + 8);
                        *(void *)unint64_t v125 = 0;
                        *(void *)(v125 + 8) = "";
                        uint64_t v131 = *(void *)(v107 + 8);
                        unint64_t v132 = v129 & 0xFFFFFFFFFFFFFFFELL | *(void *)v107 & 1;
                        *(void *)(v107 + 8) = v130;
                        unint64_t v176 = v132;
                        uint64_t v177 = v131;
                        *(void *)uint64_t v107 = v129;
                        re::StringID::destroyString((re::StringID *)&v176);
                        *(_DWORD *)(v107 + 16) = *(_DWORD *)(v125 + 16);
                        uint64_t v133 = v125 + 24;
                        re::DynamicArray<re::RigComponentConstraint>::operator=(v107 + 24, v125 + 24);
                        if (!v124) {
                          break;
                        }
                        unint64_t v124 = (v124 - 1) >> 1;
                        unint64_t v125 = a1 + (v124 << 6);
                        uint64_t v107 = v128;
                      }
                      while (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(v125 + 40), *(float **)(v125 + 56), *((uint64_t *)&v173 + 1), v175));
                      unint64_t v134 = v169;
                      float v135 = v170;
                      unint64_t v169 = 0;
                      v170 = "";
                      uint64_t v136 = *(void *)(v128 + 8);
                      unint64_t v137 = v134 & 0xFFFFFFFFFFFFFFFELL | *(void *)v128 & 1;
                      *(void *)(v128 + 8) = v135;
                      unint64_t v176 = v137;
                      uint64_t v177 = v136;
                      *(void *)uint64_t v128 = v134;
                      re::StringID::destroyString((re::StringID *)&v176);
                      *(_DWORD *)(v128 + 16) = v171;
                      re::DynamicArray<re::RigComponentConstraint>::operator=(v133, (uint64_t)&v172);
                      if (v172)
                      {
                        if (v175) {
                          (*(void (**)(void))(*(void *)v172 + 40))();
                        }
                        v175 = 0;
                        long long v173 = 0uLL;
                        uint64_t v172 = 0;
                        ++v174;
                      }
                      re::StringID::destroyString((re::StringID *)&v169);
                    }
                  }
                }
                if (v164)
                {
                  if (v168) {
                    (*(void (**)(void))(*(void *)v164 + 40))();
                  }
                  uint64_t v168 = 0;
                  uint64_t v165 = 0;
                  uint64_t v166 = 0;
                  uint64_t v164 = 0;
                  ++v167;
                }
                re::StringID::destroyString((re::StringID *)&v161);
                v101 -= 64;
              }
              while (v100-- > 2);
            }
            return;
          }
          unint64_t v12 = v11 >> 1;
          uint64_t v13 = (uint64_t *)(a1 + (v11 >> 1 << 6));
          if ((unint64_t)v10 > 0x2000)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1, a1 + (v11 >> 1 << 6), (uint64_t)v158);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1 + 64, (uint64_t)(v13 - 8), a2 - 128);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1 + 128, a1 + 64 + (v12 << 6), a2 - 192);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>((uint64_t)(v13 - 8), (uint64_t)v13, a1 + 64 + (v12 << 6));
            std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a1, v13);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1 + (v11 >> 1 << 6), a1, (uint64_t)v158);
          }
          --a3;
          if ((a4 & 1) != 0
            || re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a1 - 24), *(float **)(a1 - 8), *(void *)(a1 + 40), *(float **)(a1 + 56)))
          {
            break;
          }
          uint64_t v40 = *(void *)a1;
          unint64_t v41 = *(const char **)(a1 + 8);
          unint64_t v169 = *(void *)a1 & 1;
          unint64_t v169 = *(void *)a1 & 0xFFFFFFFFFFFFFFFELL | v40 & 1;
          v170 = v41;
          *(void *)a1 = 0;
          *(void *)(a1 + 8) = "";
          int v171 = *(_DWORD *)(a1 + 16);
          uint64_t v172 = *(void *)(a1 + 24);
          *(void *)(a1 + 24) = 0;
          *(void *)&long long v173 = *(void *)(a1 + 32);
          *(void *)(a1 + 32) = 0;
          *((void *)&v173 + 1) = *(void *)(a1 + 40);
          *(void *)(a1 + 40) = 0;
          v175 = *(float **)(a1 + 56);
          *(void *)(a1 + 56) = 0;
          ++*(_DWORD *)(a1 + 48);
          int v174 = 1;
          if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*((uint64_t *)&v173 + 1), v175, *(void *)(a2 - 24), *(float **)(a2 - 8)))
          {
            uint64_t v42 = a1;
            do
            {
              uint64_t v9 = (uint64_t *)(v42 + 64);
              BOOL v43 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*((uint64_t *)&v173 + 1), v175, *(void *)(v42 + 104), *(float **)(v42 + 120));
              uint64_t v42 = (uint64_t)v9;
            }
            while (!v43);
          }
          else
          {
            unint64_t v44 = (uint64_t *)(a1 + 64);
            do
            {
              uint64_t v9 = v44;
              if ((unint64_t)v44 >= a2) {
                break;
              }
              BOOL v45 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*((uint64_t *)&v173 + 1), v175, v44[5], (float *)v44[7]);
              unint64_t v44 = v9 + 8;
            }
            while (!v45);
          }
          float v46 = (uint64_t *)a2;
          if ((unint64_t)v9 < a2)
          {
            unint64_t v47 = a2;
            do
            {
              float v46 = (uint64_t *)(v47 - 64);
              BOOL v48 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*((uint64_t *)&v173 + 1), v175, *(void *)(v47 - 24), *(float **)(v47 - 8));
              unint64_t v47 = (unint64_t)v46;
            }
            while (v48);
          }
          while (v9 < v46)
          {
            std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>(v9, v46);
            do
            {
              uint64_t v49 = v9[13];
              uint64_t v50 = (float *)v9[15];
              v9 += 8;
            }
            while (!re::BlendSpaceBuilder::build(void)::$_0::operator()(*((uint64_t *)&v173 + 1), v175, v49, v50));
            do
            {
              uint64_t v51 = *(v46 - 3);
              float v52 = (float *)*(v46 - 1);
              v46 -= 8;
            }
            while (re::BlendSpaceBuilder::build(void)::$_0::operator()(*((uint64_t *)&v173 + 1), v175, v51, v52));
          }
          if (v9 - 8 != (uint64_t *)a1)
          {
            uint64_t v53 = *(v9 - 8);
            uint64_t v54 = *(v9 - 7);
            *(v9 - 8) = 0;
            *(v9 - 7) = (uint64_t)"";
            float v55 = *(const char **)(a1 + 8);
            unint64_t v56 = v53 & 0xFFFFFFFFFFFFFFFELL | *(void *)a1 & 1;
            *(void *)(a1 + 8) = v54;
            unint64_t v161 = v56;
            v162 = v55;
            *(void *)a1 = v53;
            re::StringID::destroyString((re::StringID *)&v161);
            *(_DWORD *)(a1 + 16) = *((_DWORD *)v9 - 12);
            re::DynamicArray<re::RigComponentConstraint>::operator=(a1 + 24, (uint64_t)(v9 - 5));
          }
          unint64_t v57 = v169;
          long long v58 = v170;
          unint64_t v169 = 0;
          v170 = "";
          uint64_t v59 = (const char *)*(v9 - 7);
          unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFFELL | *(v9 - 8) & 1;
          *(v9 - 7) = (uint64_t)v58;
          unint64_t v161 = v60;
          v162 = v59;
          *(v9 - 8) = v57;
          re::StringID::destroyString((re::StringID *)&v161);
          *((_DWORD *)v9 - 12) = v171;
          re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(v9 - 5), (uint64_t)&v172);
          if (v172)
          {
            if (v175) {
              (*(void (**)(void))(*(void *)v172 + 40))();
            }
            v175 = 0;
            long long v173 = 0uLL;
            uint64_t v172 = 0;
            ++v174;
          }
          re::StringID::destroyString((re::StringID *)&v169);
          a4 = 0;
        }
        uint64_t v14 = 0;
        uint64_t v15 = *(void *)a1;
        uint64_t v16 = *(const char **)(a1 + 8);
        unint64_t v169 = *(void *)a1 & 1;
        unint64_t v169 = *(void *)a1 & 0xFFFFFFFFFFFFFFFELL | v15 & 1;
        v170 = v16;
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = "";
        int v17 = *(_DWORD *)(a1 + 16);
        uint64_t v172 = *(void *)(a1 + 24);
        *(void *)(a1 + 24) = 0;
        uint64_t v18 = *(void *)(a1 + 40);
        *(void *)&long long v173 = *(void *)(a1 + 32);
        *(void *)(a1 + 32) = 0;
        *((void *)&v173 + 1) = v18;
        *(void *)(a1 + 40) = 0;
        v175 = *(float **)(a1 + 56);
        ++*(_DWORD *)(a1 + 48);
        int v171 = v17;
        *(void *)(a1 + 56) = 0;
        int v174 = 1;
        do
        {
          BOOL v19 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a1 + v14 + 104), *(float **)(a1 + v14 + 120), *((uint64_t *)&v173 + 1), v175);
          v14 += 64;
        }
        while (v19);
        unint64_t v20 = a1 + v14;
        unint64_t v21 = a2;
        if (v14 == 64)
        {
          unint64_t v24 = a2;
          while (v20 < v24)
          {
            unint64_t v22 = (uint64_t *)(v24 - 64);
            BOOL v25 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(v24 - 24), *(float **)(v24 - 8), *((uint64_t *)&v173 + 1), v175);
            unint64_t v24 = (unint64_t)v22;
            if (v25) {
              goto LABEL_20;
            }
          }
          unint64_t v22 = (uint64_t *)v24;
        }
        else
        {
          do
          {
            unint64_t v22 = (uint64_t *)(v21 - 64);
            BOOL v23 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(v21 - 24), *(float **)(v21 - 8), *((uint64_t *)&v173 + 1), v175);
            unint64_t v21 = (unint64_t)v22;
          }
          while (!v23);
        }
LABEL_20:
        uint64_t v9 = (uint64_t *)(a1 + v14);
        if (v20 < (unint64_t)v22)
        {
          uint64_t v26 = v22;
          do
          {
            std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>(v9, v26);
            do
            {
              uint64_t v27 = v9[13];
              long long v28 = (float *)v9[15];
              v9 += 8;
            }
            while (re::BlendSpaceBuilder::build(void)::$_0::operator()(v27, v28, *((uint64_t *)&v173 + 1), v175));
            do
            {
              uint64_t v29 = *(v26 - 3);
              uint64_t v30 = (float *)*(v26 - 1);
              v26 -= 8;
            }
            while (!re::BlendSpaceBuilder::build(void)::$_0::operator()(v29, v30, *((uint64_t *)&v173 + 1), v175));
          }
          while (v9 < v26);
        }
        if (v9 - 8 != (uint64_t *)a1)
        {
          uint64_t v31 = *(v9 - 8);
          uint64_t v32 = *(v9 - 7);
          *(v9 - 8) = 0;
          *(v9 - 7) = (uint64_t)"";
          uint64_t v33 = *(const char **)(a1 + 8);
          unint64_t v34 = v31 & 0xFFFFFFFFFFFFFFFELL | *(void *)a1 & 1;
          *(void *)(a1 + 8) = v32;
          unint64_t v161 = v34;
          v162 = v33;
          *(void *)a1 = v31;
          re::StringID::destroyString((re::StringID *)&v161);
          *(_DWORD *)(a1 + 16) = *((_DWORD *)v9 - 12);
          re::DynamicArray<re::RigComponentConstraint>::operator=(a1 + 24, (uint64_t)(v9 - 5));
        }
        unint64_t v35 = v169;
        long long v36 = v170;
        unint64_t v169 = 0;
        v170 = "";
        long long v37 = (const char *)*(v9 - 7);
        unint64_t v38 = v35 & 0xFFFFFFFFFFFFFFFELL | *(v9 - 8) & 1;
        *(v9 - 7) = (uint64_t)v36;
        unint64_t v161 = v38;
        v162 = v37;
        *(v9 - 8) = v35;
        re::StringID::destroyString((re::StringID *)&v161);
        *((_DWORD *)v9 - 12) = v171;
        re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(v9 - 5), (uint64_t)&v172);
        if (v172)
        {
          if (v175) {
            (*(void (**)(void))(*(void *)v172 + 40))();
          }
          v175 = 0;
          long long v173 = 0uLL;
          uint64_t v172 = 0;
          ++v174;
        }
        re::StringID::destroyString((re::StringID *)&v169);
        if (v20 >= (unint64_t)v22) {
          break;
        }
LABEL_35:
        std::__introsort<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *,false>(a1, v9 - 8, a3, a4 & 1);
        a4 = 0;
      }
      char v39 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1, (uint64_t)(v9 - 8));
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>((uint64_t)v9, a2))break; {
      if ((v39 & 1) == 0)
      }
        goto LABEL_35;
    }
    a2 = (unint64_t)(v9 - 8);
    if ((v39 & 1) == 0) {
      continue;
    }
    break;
  }
}

BOOL re::BlendSpaceBuilder::build(void)::$_0::operator()(uint64_t a1, float *a2, uint64_t a3, float *a4)
{
  if (!a1)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (!a3) {
    goto LABEL_5;
  }
  return *a2 < *a4;
}

void std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1, a2, a3, a4);
  if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a5 + 40), *(float **)(a5 + 56), *(void *)(a4 + 40), *(float **)(a4 + 56)))
  {
    std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a4, (uint64_t *)a5);
    if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a4 + 40), *(float **)(a4 + 56), *(void *)(a3 + 40), *(float **)(a3 + 56)))
    {
      std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a3, (uint64_t *)a4);
      if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a3 + 40), *(float **)(a3 + 56), *(void *)(a2 + 40), *(float **)(a2 + 56)))
      {
        std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a2, (uint64_t *)a3);
        if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a2 + 40), *(float **)(a2 + 56), *(void *)(a1 + 40), *(float **)(a1 + 56)))
        {
          std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a1, (uint64_t *)a2);
        }
      }
    }
  }
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a2 + 40), *(float **)(a2 + 56), *(void *)(a1 + 40), *(float **)(a1 + 56));
  BOOL v7 = re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a3 + 40), *(float **)(a3 + 56), *(void *)(a2 + 40), *(float **)(a2 + 56));
  if (v6)
  {
    if (v7)
    {
      uint64_t v8 = (uint64_t *)a1;
    }
    else
    {
      std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a1, (uint64_t *)a2);
      if (!re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a3 + 40), *(float **)(a3 + 56), *(void *)(a2 + 40), *(float **)(a2 + 56)))return; {
      uint64_t v8 = (uint64_t *)a2;
      }
    }
    uint64_t v9 = (uint64_t *)a3;
  }
  else
  {
    if (!v7) {
      return;
    }
    std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a2, (uint64_t *)a3);
    if (!re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a2 + 40), *(float **)(a2 + 56), *(void *)(a1 + 40), *(float **)(a1 + 56)))return; {
    uint64_t v8 = (uint64_t *)a1;
    }
    uint64_t v9 = (uint64_t *)a2;
  }
  std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>(v8, v9);
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(uint64_t a1, uint64_t a2)
{
  BOOL v4 = 1;
  switch((a2 - a1) >> 6)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a2 - 24), *(float **)(a2 - 8), *(void *)(a1 + 40), *(float **)(a1 + 56)))
      {
        std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a1, (uint64_t *)(a2 - 64));
      }
      break;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1, a1 + 64, a2 - 64);
      break;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1, a1 + 64, a1 + 128, a2 - 64);
      break;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *,0>(a1, a1 + 64, a1 + 128, a1 + 192, a2 - 64);
      break;
    default:
      uint64_t v5 = a1 + 128;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1, a1 + 64, a1 + 128);
      uint64_t v6 = a1 + 192;
      BOOL v4 = 1;
      if (a1 + 192 != a2)
      {
        uint64_t v7 = 0;
        int v8 = 0;
        while (1)
        {
          if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(v6 + 40), *(float **)(v6 + 56), *(void *)(v5 + 40), *(float **)(v5 + 56)))
          {
            uint64_t v9 = *(const char **)(v6 + 8);
            uint64_t v23 = *(void *)v6;
            unint64_t v24 = v9;
            *(void *)uint64_t v6 = 0;
            *(void *)(v6 + 8) = "";
            int v25 = *(_DWORD *)(v6 + 16);
            uint64_t v26 = *(void *)(v6 + 24);
            long long v27 = *(_OWORD *)(v6 + 32);
            *(void *)(v6 + 24) = 0;
            *(void *)(v6 + 32) = 0;
            *(void *)(v6 + 40) = 0;
            uint64_t v29 = *(float **)(v6 + 56);
            *(void *)(v6 + 56) = 0;
            ++*(_DWORD *)(v6 + 48);
            uint64_t v10 = v7;
            int v28 = 1;
            while (1)
            {
              uint64_t v11 = a1 + v10;
              uint64_t v12 = *(void *)(a1 + v10 + 128);
              uint64_t v13 = *(void *)(a1 + v10 + 136);
              *(void *)(v11 + 128) = 0;
              *(void *)(v11 + 136) = "";
              uint64_t v14 = *(void *)(a1 + v10 + 192);
              uint64_t v15 = *(void *)(a1 + v10 + 200);
              *(void *)(v11 + 192) = v12;
              *(void *)(v11 + 200) = v13;
              unint64_t v30 = v12 & 0xFFFFFFFFFFFFFFFELL | v14 & 1;
              uint64_t v31 = v15;
              re::StringID::destroyString((re::StringID *)&v30);
              *(_DWORD *)(v11 + 208) = *(_DWORD *)(v11 + 144);
              uint64_t v16 = a1 + v10 + 152;
              re::DynamicArray<re::RigComponentConstraint>::operator=(v11 + 216, v11 + 152);
              if (v10 == -128) {
                break;
              }
              v10 -= 64;
              if (!re::BlendSpaceBuilder::build(void)::$_0::operator()(*((uint64_t *)&v27 + 1), v29, *(void *)(v11 + 104), *(float **)(v11 + 120)))
              {
                uint64_t v17 = a1 + v10 + 192;
                goto LABEL_12;
              }
            }
            uint64_t v17 = a1;
LABEL_12:
            uint64_t v18 = v23;
            BOOL v19 = v24;
            uint64_t v23 = 0;
            unint64_t v24 = "";
            uint64_t v20 = *(void *)v17;
            uint64_t v21 = *(void *)(v17 + 8);
            *(void *)uint64_t v17 = v18;
            *(void *)(v17 + 8) = v19;
            unint64_t v30 = v18 & 0xFFFFFFFFFFFFFFFELL | v20 & 1;
            uint64_t v31 = v21;
            re::StringID::destroyString((re::StringID *)&v30);
            *(_DWORD *)(v17 + 16) = v25;
            re::DynamicArray<re::RigComponentConstraint>::operator=(v16, (uint64_t)&v26);
            if (v26)
            {
              if (v29) {
                (*(void (**)(void))(*(void *)v26 + 40))();
              }
              uint64_t v29 = 0;
              long long v27 = 0uLL;
              uint64_t v26 = 0;
              ++v28;
            }
            ++v8;
            re::StringID::destroyString((re::StringID *)&v23);
            if (v8 == 8) {
              break;
            }
          }
          uint64_t v5 = v6;
          v7 += 64;
          v6 += 64;
          if (v6 == a2) {
            return 1;
          }
        }
        BOOL v4 = v6 + 64 == a2;
      }
      break;
  }
  return v4;
}

void std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  *a1 = 0;
  a1[1] = (uint64_t)"";
  int v15 = *((_DWORD *)a1 + 4);
  int v6 = v15;
  uint64_t v7 = (uint64_t)(a1 + 3);
  uint64_t v16 = a1[3];
  a1[3] = 0;
  long long v17 = *((_OWORD *)a1 + 2);
  a1[4] = 0;
  a1[5] = 0;
  uint64_t v19 = a1[7];
  a1[7] = 0;
  ++*((_DWORD *)a1 + 12);
  int v18 = 1;
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  uint64_t v10 = *a1;
  uint64_t v11 = a1[1];
  *a1 = v8;
  a1[1] = v9;
  unint64_t v20 = v8 & 0xFFFFFFFFFFFFFFFELL | v10 & 1;
  uint64_t v21 = v11;
  re::StringID::destroyString((re::StringID *)&v20);
  *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
  re::DynamicArray<re::RigComponentConstraint>::operator=(v7, (uint64_t)(a2 + 3));
  v14[0] = 0;
  v14[1] = "";
  uint64_t v12 = a2[1];
  unint64_t v20 = v4 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  uint64_t v21 = v12;
  *a2 = v4;
  a2[1] = v5;
  re::StringID::destroyString((re::StringID *)&v20);
  *((_DWORD *)a2 + 4) = v6;
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a2 + 3), (uint64_t)&v16);
  if (v16)
  {
    if (v19) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 40))(v16, v19, v13);
    }
    uint64_t v19 = 0;
    long long v17 = 0uLL;
    uint64_t v16 = 0;
    ++v18;
  }
  re::StringID::destroyString((re::StringID *)v14);
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::BlendSpaceBuilder::build(void)::$_0 &,re::BlendSpaceSampleDefinition *>(a1, a2, a3);
  if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a4 + 40), *(float **)(a4 + 56), *(void *)(a3 + 40), *(float **)(a3 + 56)))
  {
    std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a3, (uint64_t *)a4);
    if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a3 + 40), *(float **)(a3 + 56), *(void *)(a2 + 40), *(float **)(a2 + 56)))
    {
      std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a2, (uint64_t *)a3);
      if (re::BlendSpaceBuilder::build(void)::$_0::operator()(*(void *)(a2 + 40), *(float **)(a2 + 56), *(void *)(a1 + 40), *(float **)(a1 + 56)))
      {
        std::swap[abi:nn180100]<re::BlendSpaceSampleDefinition>((uint64_t *)a1, (uint64_t *)a2);
      }
    }
  }
}

void *re::internal::penetrationCorrectionCallback(uint64_t a1, uint64_t a2, void *a3, unint64_t a4, uint64_t a5, uint64_t a6, re::RigDataValue *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  if (!a4)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  unint64_t v9 = a4;
  if (a4 == 1)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  if (a4 <= 2)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, v9);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (a4 == 3)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  re::internal::getSRTFromRDV((re::internal *)(a3 + 108), &v55);
  if (v9 <= 4)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::getSRTFromRDV((re::internal *)(a3 + 144), &v53);
  if (!a8) {
    goto LABEL_18;
  }
  _Q7 = (int32x4_t)v56;
  _S3 = HIDWORD(v54);
  __asm { FMLA            S4, S3, V7.S[3] }
  float32x4_t v51 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q7, _Q7), v56, 0xCuLL);
  float32x4_t v52 = (float32x4_t)v56;
  float32x4_t v50 = vnegq_f32((float32x4_t)v56);
  float32x4_t v47 = v57;
  float32x4_t v48 = v55;
  __asm { FMOV            V1.4S, #-1.0 }
  CoreIKGenericSolverSetWorldToSolverTransform();
  uint64_t v23 = a3[68];
  if (v23)
  {
    unint64_t v24 = 0;
    unint64_t v9 = (unint64_t)(a3 + 36);
    _S8 = v52.i32[3];
    while (1)
    {
      uint64_t v26 = (re::RigDataValue *)re::RigDataValue::attributeValue((re::RigDataValue *)(a3 + 36), v24);
      v59[0] = 0;
      v59[1] = (unint64_t)"";
      float32x4_t v60 = 0u;
      unint64_t v27 = re::RigDataValue::attributeValue(v26, 0);
      re::StringID::operator=(v59, (uint64_t *)(v27 + 224));
      unint64_t v28 = re::RigDataValue::attributeValue(v26, 1uLL);
      float32x4_t v60 = *(float32x4_t *)re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v28, v29);
      unint64_t v30 = re::RigDataValue::attributeValue(v26, 2uLL);
      float v61 = *(float *)re::RigDataValue::getRuntimeValue<float>(v30, v31);
      uint64_t v32 = (re::internal *)re::RigDataValue::attributeValue((re::RigDataValue *)(a3 + 72), v24);
      re::internal::getSRTFromRDV(v32, v62);
      int v49 = HIDWORD(v63);
      float32x4_t v33 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v64, v64), (int8x16_t)v64, 0xCuLL), v50), (float32x4_t)v64, v51);
      int32x4_t v34 = (int32x4_t)vaddq_f32(v33, v33);
      float32x4_t v35 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v34, v34), (int8x16_t)v34, 0xCuLL);
      int32x4_t v36 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), (int8x16_t)v35, 0xCuLL), v50), v35, v51);
      float32x4_t v37 = vaddq_f32(v47, vmulq_f32(v48, vaddq_f32(vaddq_f32((float32x4_t)v64, vmulq_laneq_f32(v35, v52, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v36, v36), (int8x16_t)v36, 0xCuLL))));
      int32x4_t v38 = (int32x4_t)vmulq_f32(v60, v60);
      v38.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v38, 2), vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v38.i8, 1))).u32[0];
      float32x2_t v39 = vrsqrte_f32((float32x2_t)v38.u32[0]);
      float32x2_t v40 = vmul_f32(v39, vrsqrts_f32((float32x2_t)v38.u32[0], vmul_f32(v39, v39)));
      float32x4_t v41 = vmulq_n_f32(v60, vmul_f32(v40, vrsqrts_f32((float32x2_t)v38.u32[0], vmul_f32(v40, v40))).f32[0]);
      float32x4_t v73 = vsubq_f32(v37, vmulq_n_f32(v41, v61 * 0.5));
      float32x4_t v74 = v41;
      *(float *)&long long v75 = v61;
      re::internal::RayCaster::cast((void *)(a9 + 48), (uint64_t)&v73, (uint64_t)v62);
      unint64_t v42 = *(void *)(a9 + 176);
      if (v42 <= v24) {
        break;
      }
      _V2.S[3] = v49;
      __asm { FMLA            S0, S8, V2.S[3] }
      MEMORY[0x237DBA340](*(void *)a9, *(void *)(*(void *)(a9 + 192) + 8 * v24));
      CoreIKGenericConstraintSetTargetParameters();
      re::StringID::destroyString((re::StringID *)v59);
      if (v23 == ++v24) {
        goto LABEL_11;
      }
    }
    uint64_t v58 = 0;
    long long v76 = 0u;
    long long v77 = 0u;
    float32x4_t v74 = 0u;
    long long v75 = 0u;
    float32x4_t v73 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v65 = 136315906;
    uint64_t v66 = "operator[]";
    __int16 v67 = 1024;
    int v68 = 789;
    __int16 v69 = 2048;
    unint64_t v70 = v24;
    __int16 v71 = 2048;
    unint64_t v72 = v42;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_13;
  }
LABEL_11:
  re::internal::transferPose((re::RigDataValue *)a3, a9 + 16);
  int v45 = CoreIKGenericSolverSolve();
  return re::internal::updateOutputBasedOnSolveResult(v45, (uint64_t)a3, (_OWORD *)(a9 + 16), a7);
}

uint64_t re::internal::penetrationCorrectionCompile(re::Allocator **a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_25;
  }
  if (a3 == 1)
  {
LABEL_25:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_26;
  }
  if (a3 <= 2)
  {
LABEL_26:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_27;
  }
  if (a3 == 3)
  {
LABEL_27:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_28;
  }
  if (!a5)
  {
LABEL_28:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_29:
    if (__cxa_guard_acquire(&qword_26AF74920))
    {
      _MergedGlobals_26 = re::introspect_CollisionWorld(0);
      __cxa_guard_release(&qword_26AF74920);
    }
    goto LABEL_15;
  }
  uint64_t v5 = (uint64_t)a1;
  uint64_t v11 = a2[1];
  int v6 = *(_anonymous_namespace_ **)(*a2 + 184);
  uint64_t v8 = (re::RigDataValue *)a2[2];
  uint64_t v12 = (const re::RigDataValue *)a2[3];
  uint64_t v31 = *a4;
  uint64_t v39 = 158357486;
  float32x2_t v40 = "SRT[]";
  re::internal::makeRigDataValue(a1, (const char **)&v39, (uint64_t)v43);
  re::StringID::destroyString((re::StringID *)&v39);
  uint64_t v13 = *((void *)v8 + 32);
  if (v13)
  {
    for (unint64_t i = 0; i != v13; ++i)
    {
      unint64_t v15 = re::RigDataValue::attributeValue(v8, i);
      v38[0] = "jointName";
      v38[1] = 9;
      re::RigDataValue::attributeValue(v15, (uint64_t)v38, (uint64_t)&v39);
      uint64_t v16 = v40;
      if (!(_BYTE)v39 && v41 && (v42 & 1) != 0) {
        (*(void (**)(void))(*(void *)v41 + 40))();
      }
      re::internal::makeModelSpaceJointPoseRDV((re::Allocator **)v5, v6, *((const char **)v16 + 29), (re::RigDataValue *)&v39);
      re::DynamicArray<re::RigDataValue>::add((uint64_t)&v44, (const re::RigDataValue *)&v39);
      re::RigDataValue::~RigDataValue((re::RigDataValue *)&v39);
    }
  }
  size_t v17 = strlen(*(const char **)(v11 + 232));
  uint64_t v7 = MEMORY[0x237DBA0C0](*(void *)(v11 + 232), v17);
  re::internal::makePoseFromRig((re::Allocator **)v5, v6, v7, (uint64_t)&v39);
  uint64_t v18 = MEMORY[0x237DBA570](v7);
  re::internal::makePose((re::Allocator **)v5, v18, (uint64_t)v38);
  unint64_t v19 = re::RigHierarchy::jointName(v6, 0);
  re::internal::makeLocalSpaceJointPoseRDV((re::Allocator **)v5, v6, *(const re::RigHierarchy **)(v19 + 8), (re::RigDataValue *)v37);
  uint64_t v36 = 0;
  memset(v32, 0, sizeof(v32));
  int v33 = 0;
  memset(v34, 0, sizeof(v34));
  int v35 = 0;
  unint64_t v9 = *(re::Allocator **)v5;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v32, *(re::Allocator **)v5);
  *(void *)&v48.var0 = 0x76F1BA5D1EB6;
  v48.var1 = "InputPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v32, &v48, (const re::RigDataValue *)&v39);
  re::StringID::destroyString((re::StringID *)&v48);
  *(void *)&v48.var0 = 0x3D8860E9FFCEA9D0;
  v48.var1 = "TaskSettings";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v32, &v48, v8);
  re::StringID::destroyString((re::StringID *)&v48);
  *(void *)&v48.var0 = 0xC55D73256F227AE8;
  v48.var1 = "ModelSpaceJointTransforms";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v32, &v48, (const re::RigDataValue *)v43);
  re::StringID::destroyString((re::StringID *)&v48);
  *(void *)&v48.var0 = 0xB88303615935B0FCLL;
  v48.var1 = "ModelToWorldTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v32, &v48, v12);
  re::StringID::destroyString((re::StringID *)&v48);
  *(void *)&v48.var0 = 0xF2EC5C4DD6027FE2;
  v48.var1 = "SolverToModelTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v32, &v48, (const re::RigDataValue *)v37);
  re::StringID::destroyString((re::StringID *)&v48);
  *(void *)&v48.var0 = 0x10498EC9357CACLL;
  v48.var1 = "SolvedPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v32, &v48, (re::RigDataValue *)v38);
  re::StringID::destroyString((re::StringID *)&v48);
  uint64_t v10 = *(void *)(*(void *)(v5 + 16) + 96);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74920, memory_order_acquire) & 1) == 0) {
    goto LABEL_29;
  }
LABEL_15:
  uint64_t v20 = _MergedGlobals_26;
  re::StringID::invalid((re::StringID *)&v48);
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, StringID *))(*(void *)v10 + 16))(v10, v20, &v48);
  re::StringID::destroyString((re::StringID *)&v48);
  uint64_t v22 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 208, 16);
  *(void *)uint64_t v22 = CoreIKGenericSolverCreate();
  *(void *)(v22 + 8) = v9;
  *(void *)(v22 + 16) = 0;
  *(void *)(v22 + 24) = 0;
  *(void *)(v22 + 32) = 0;
  *(void *)(v22 + 48) = v21;
  *(void *)(v22 + 64) = 0;
  *(void *)(v22 + 72) = 0;
  *(void *)(v22 + 68) = 0xFFFFFFFF00000001;
  *(_OWORD *)(v22 + 108) = 0u;
  *(_OWORD *)(v22 + 136) = 0u;
  *(_OWORD *)(v22 + 124) = 0u;
  *(_OWORD *)(v22 + 92) = 0u;
  *(_OWORD *)(v22 + 76) = 0u;
  *(_DWORD *)(v22 + 112) = 1;
  *(void *)(v22 + 128) = 0;
  *(void *)(v22 + 136) = 0;
  *(void *)(v22 + 120) = 0;
  *(_DWORD *)(v22 + 144) = 0;
  *(void *)(v22 + 192) = 0;
  *(void *)(v22 + 160) = 0;
  *(_DWORD *)(v22 + 184) = 0;
  *(void *)(v22 + 168) = 0;
  *(void *)(v22 + 176) = 0;
  unint64_t JointCount = CoreIKGenericSolverGetJointCount();
  unint64_t v30 = v9;
  re::FixedArray<CoreIKTransform>::init<>((uint64_t *)(v22 + 16), (uint64_t)v9, JointCount);
  *(void *)(v22 + 176) = 0;
  ++*(_DWORD *)(v22 + 184);
  uint64_t v24 = *((void *)v8 + 32);
  if (v24)
  {
    for (unint64_t j = 0; j != v24; ++j)
    {
      unint64_t v26 = re::RigDataValue::attributeValue(v8, j);
      int v45 = "jointName";
      uint64_t v46 = 9;
      re::RigDataValue::attributeValue(v26, (uint64_t)&v45, (uint64_t)&v48);
      unint64_t v27 = (const char *)*((void *)v48.var1 + 29);
      if (!*(unsigned char *)&v48.var0 && v50 && (p_var1 & 1) != 0) {
        (*(void (**)(void))(*(void *)v50 + 40))();
      }
      *(void *)&v48.var0 = 0;
      strlen(v27);
      *(void *)&v48.var0 = CoreIKGenericSolverGetConstraintIndex();
      re::DynamicArray<unsigned long>::add((void *)(v22 + 160), &v48);
    }
  }
  int v45 = (const char *)&unk_26E6C4788;
  uint64_t v46 = (uint64_t)v30;
  float32x4_t v47 = &v45;
  *(void *)&v48.var0 = v22;
  p_var1 = &v48.var1;
  v48.var1 = (char *)&unk_26E6C4788;
  int v49 = v30;
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](&v45);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v32, v5, (uint64_t)re::internal::penetrationCorrectionCallback, (uint64_t *)&v48);
  double v28 = re::internal::bindCallbackOutputToNodeOutputPose(v6, (re::RigDataValue *)v38, v7, v5, v31);
  MEMORY[0x237DBA110](v7, v28);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v48);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v34 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v32 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v37);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v38);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)&v39);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v43);
  return 1;
}

void re::internal::registerPenetrationCorrectionSolverNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)"";
  v3[0] = 0;
  v3[1] = (uint64_t)"";
  v7[2] = xmmword_264BE1D38;
  v7[3] = *(_OWORD *)&off_264BE1D48;
  v7[4] = xmmword_264BE1D58;
  v7[0] = xmmword_264BE1D18;
  v7[1] = *(_OWORD *)&off_264BE1D28;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 4uLL, 1uLL, (unint64_t)re::internal::penetrationCorrectionCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((void *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_43CoreIKPenetrationCorrectionSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperINS2_14CollisionWorldEEEPKNS2_12RigDataValueEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISL_EEFvSK_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_43CoreIKPenetrationCorrectionSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperINS2_14CollisionWorldEEEPKNS2_12RigDataValueEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISL_EEFvSK_EE7__cloneEv(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *float result = &unk_26E6C4788;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_43CoreIKPenetrationCorrectionSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperINS2_14CollisionWorldEEEPKNS2_12RigDataValueEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISL_EEFvSK_EE7__cloneEPNS0_6__baseISO_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E6C4788;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_43CoreIKPenetrationCorrectionSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperINS2_14CollisionWorldEEEPKNS2_12RigDataValueEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISL_EEFvSK_EEclEOSK_(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    CoreIKGenericSolverDestroy();
    re::DynamicArray<unsigned long>::deinit(v2 + 160);
    re::BucketArray<re::CollisionCastHit,10ul>::deinit(v2 + 96);
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v2 + 96);
    re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v2 + 16));
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 40);
    return v4(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_43CoreIKPenetrationCorrectionSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperINS2_14CollisionWorldEEEPKNS2_12RigDataValueEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISL_EEFvSK_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:nn180100](a2, (uint64_t)&_ZTIZN2re8internal14makeNodeUniqueINS0_43CoreIKPenetrationCorrectionSolverNodeHelperENS_9AllocatorEJP9CoreIKRigNSt3__117reference_wrapperINS_14CollisionWorldEEEPKNS_12RigDataValueEEEEDaPT0_DpT1_EUlPvE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_43CoreIKPenetrationCorrectionSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperINS2_14CollisionWorldEEEPKNS2_12RigDataValueEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISL_EEFvSK_EE11target_typeEv()
{
  return &_ZTIZN2re8internal14makeNodeUniqueINS0_43CoreIKPenetrationCorrectionSolverNodeHelperENS_9AllocatorEJP9CoreIKRigNSt3__117reference_wrapperINS_14CollisionWorldEEEPKNS_12RigDataValueEEEEDaPT0_DpT1_EUlPvE_;
}

uint64_t re::EvaluationModelSingleThread::init(uint64_t a1)
{
  uint64_t v5 = MEMORY[0x270FA5388](a1);
  unint64_t v7 = v6;
  uint64_t v9 = (uint64_t)v8;
  uint64_t v11 = v10;
  uint64_t v145 = v5;
  uint64_t v291 = *MEMORY[0x263EF8340];
  int v12 = *(_DWORD *)(v10 + 8);
  *(void *)&long long v247 = v8;
  uint64_t v177 = v8;
  uint64_t v178 = v13;
  bzero(&v179, 0x288uLL);
  for (uint64_t i = 0; i != 3120; i += 40)
  {
    unint64_t v15 = (char *)&v177 + i;
    *((void *)v15 + 87) = 0;
    *((void *)v15 + 83) = 0;
    *((void *)v15 + 85) = 0;
    *((void *)v15 + 84) = 0;
    *((_DWORD *)v15 + 172) = 0;
  }
  uint64_t v16 = 0;
  uint64_t v210 = 0;
  uint64_t v207 = 0;
  uint64_t v208 = 0;
  uint64_t v206 = 0;
  int v209 = 0;
  int v211 = v12;
  uint64_t v212 = 0;
  unint64_t v214 = 0;
  uint64_t v213 = 0;
  int v215 = 0;
  long long v216 = 0u;
  long long v217 = 0u;
  int v218 = 0;
  long long v219 = 0u;
  long long v220 = 0u;
  int v221 = 0;
  long long v222 = 0u;
  long long v223 = 0u;
  int v224 = 0;
  int v227 = 0;
  long long v226 = 0u;
  long long v225 = 0u;
  long long v228 = 0u;
  long long v229 = 0u;
  int v230 = 0;
  int v233 = 0;
  long long v232 = 0u;
  long long v231 = 0u;
  long long v234 = 0u;
  long long v235 = 0u;
  int v236 = 0;
  unint64_t v242 = 0;
  long long v241 = 0u;
  long long v240 = 0u;
  long long v239 = 0u;
  long long v238 = 0u;
  long long v237 = 0u;
  do
  {
    v205[v16 + 2] = v9;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v205[v16 + 2], 0);
    ++LODWORD(v205[v16 + 5]);
    v16 += 5;
  }
  while (v16 != 390);
  uint64_t v206 = v9;
  re::DynamicArray<re::EvaluationCommand>::setCapacity(&v206, 0);
  ++v209;
  re::DynamicRegisterTable::initArrays<re::Allocator *&>(&v212, &v247);
  __src = 0;
  v173[1] = 0;
  unint64_t v174 = 0;
  int v175 = 0;
  v173[0] = v9;
  re::DynamicArray<re::EvaluationCommand>::setCapacity(v173, 0);
  ++v175;
  uint64_t v172 = 0;
  v169[1] = 0;
  unint64_t v170 = 0;
  int v171 = 0;
  v169[0] = v9;
  re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(v169, 0);
  ++v171;
  uint64_t v168 = 0;
  v165[1] = 0;
  unint64_t v166 = 0;
  int v167 = 0;
  v165[0] = v9;
  re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(v165, 0);
  ++v167;
  if (!v160[0])
  {
    *(unsigned char *)uint64_t v145 = 0;
    *(_OWORD *)(v145 + 8) = v161;
    *(void *)(v145 + 24) = v162;
    *(void *)(v145 + 48) = v164;
    *(_OWORD *)(v145 + 32) = v163;
    uint64_t v164 = 0;
    uint64_t v162 = 0;
    long long v163 = 0uLL;
LABEL_169:
    if (v162 && (v163 & 1) != 0) {
      (*(void (**)(void))(*(void *)v162 + 40))();
    }
    goto LABEL_172;
  }
  unint64_t v17 = v11 + 712;
  unint64_t v18 = v174;
  re::FixedArray<re::EvaluationCommand>::init<>((uint64_t *)(v11 + 712), v9, v174);
  uint64_t v21 = __src;
  if (!*(void *)(v11 + 712))
  {
    if (!v18) {
      goto LABEL_12;
    }
  }
  if (*(void *)(v11 + 720) != v18) {
    goto LABEL_292;
  }
  if (v18) {
    memmove(*(void **)(v11 + 728), v21, 4 * v18);
  }
LABEL_12:
  re::FixedArray<unsigned long>::init<>((uint64_t *)(v11 + 760), v9, v170);
  *(void *)&long long v247 = v172;
  *((void *)&v247 + 1) = v170;
  re::FixedArray<unsigned long>::operator=((_anonymous_namespace_ *)(v11 + 760), (uint64_t)&v247);
  re::FixedArray<unsigned long>::init<>((uint64_t *)(v11 + 736), v9, v166);
  *(void *)&long long v247 = v168;
  *((void *)&v247 + 1) = v166;
  re::FixedArray<unsigned long>::operator=((_anonymous_namespace_ *)(v11 + 736), (uint64_t)&v247);
  re::FixedArray<int>::init<>((uint64_t *)(v11 + 16), (uint64_t)v177, *((unint64_t *)&v237 + 1));
  uint64_t v22 = v180;
  if (v180)
  {
    unint64_t v24 = *(void *)(v11 + 24);
    uint64_t v23 = *(void *)(v11 + 32);
    unint64_t v17 = v214;
    uint64_t v25 = v216;
    unint64_t v26 = (unint64_t *)(v181 + 56);
    do
    {
      if (*((unsigned char *)v26 - 16) == 3)
      {
        unint64_t v1 = *v26;
        if (*v26 != -1)
        {
          unint64_t v7 = *(v26 - 1);
          if (v17 <= v7) {
            goto LABEL_272;
          }
          if (v24 <= v1)
          {
LABEL_273:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 468;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v1;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_274:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 797;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v7;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v17;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_275:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 468;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v1;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_276:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 797;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v7;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v17;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_277:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 468;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v1;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_278:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 797;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v17;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_279:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 468;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v24;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_280:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 797;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v17;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_281:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 468;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v24;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_282:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 797;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v17;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_283:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 468;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v24;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_284:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 797;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v17;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_285:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 468;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v24;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_286:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 797;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v17;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_287:
            v246[0] = 0;
            long long v250 = 0u;
            long long v251 = 0u;
            long long v248 = 0u;
            long long v249 = 0u;
            long long v247 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v268[0]) = 136315906;
            *(void *)((char *)v268 + 4) = "operator[]";
            WORD2(v268[1]) = 1024;
            *(_DWORD *)((char *)&v268[1] + 6) = 468;
            WORD1(v268[2]) = 2048;
            *(void *)((char *)&v268[2] + 4) = v24;
            WORD2(v268[3]) = 2048;
            *(void *)((char *)&v268[3] + 6) = v1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_288;
          }
          *(_DWORD *)(v23 + 4 * v1) = *(_DWORD *)(v25 + 4 * v7);
        }
      }
      v26 += 8;
      --v22;
    }
    while (v22);
  }
  re::FixedArray<int>::init<>((uint64_t *)(v11 + 40), (uint64_t)v177, v238);
  uint64_t v27 = v182;
  if (v182)
  {
    unint64_t v24 = *(void *)(v11 + 48);
    uint64_t v28 = *(void *)(v11 + 56);
    unint64_t v17 = *((void *)&v217 + 1);
    uint64_t v29 = v219;
    unint64_t v30 = (unint64_t *)(v183 + 56);
    do
    {
      if (*((unsigned char *)v30 - 16) == 3)
      {
        unint64_t v1 = *v30;
        if (*v30 != -1)
        {
          unint64_t v7 = *(v30 - 1);
          if (v17 <= v7) {
            goto LABEL_274;
          }
          if (v24 <= v1) {
            goto LABEL_275;
          }
          *(_DWORD *)(v28 + 4 * v1) = *(_DWORD *)(v29 + 4 * v7);
        }
      }
      v30 += 8;
      --v27;
    }
    while (v27);
  }
  re::FixedArray<int>::init<>((uint64_t *)(v11 + 64), (uint64_t)v177, *((unint64_t *)&v238 + 1));
  uint64_t v31 = v184;
  if (v184)
  {
    unint64_t v24 = *(void *)(v11 + 72);
    uint64_t v32 = *(void *)(v11 + 80);
    unint64_t v17 = *((void *)&v220 + 1);
    uint64_t v33 = v222;
    int32x4_t v34 = (unint64_t *)(v185 + 56);
    do
    {
      if (*((unsigned char *)v34 - 16) == 3)
      {
        unint64_t v1 = *v34;
        if (*v34 != -1)
        {
          unint64_t v7 = *(v34 - 1);
          if (v17 <= v7) {
            goto LABEL_276;
          }
          if (v24 <= v1) {
            goto LABEL_277;
          }
          *(_DWORD *)(v32 + 4 * v1) = *(_DWORD *)(v33 + 4 * v7);
        }
      }
      v34 += 8;
      --v31;
    }
    while (v31);
  }
  re::FixedArray<re::Matrix3x3<float>>::init<>((uint64_t *)(v11 + 88), (uint64_t)v177, v239);
  unint64_t v35 = v186;
  if (v186)
  {
    uint64_t v36 = 0;
    for (unint64_t j = 0; j < v35; ++j)
    {
      if (*(unsigned char *)(v187 + v36 + 40) == 3)
      {
        unint64_t v24 = *(void *)(v187 + v36 + 56);
        if (v24 != -1)
        {
          unint64_t v17 = *(void *)(v187 + v36 + 48);
          unint64_t v1 = *((void *)&v223 + 1);
          if (*((void *)&v223 + 1) <= v17) {
            goto LABEL_278;
          }
          unint64_t v1 = *(void *)(v11 + 96);
          if (v1 <= v24) {
            goto LABEL_279;
          }
          int32x4_t v38 = (long long *)(v225 + 48 * v17);
          uint64_t v39 = (_OWORD *)(*(void *)(v11 + 104) + 48 * v24);
          long long v40 = *v38;
          long long v41 = v38[2];
          v39[1] = v38[1];
          v39[2] = v41;
          _OWORD *v39 = v40;
          unint64_t v35 = v186;
        }
      }
      v36 += 64;
    }
  }
  re::FixedArray<re::Matrix4x4<float>>::init<>((uint64_t *)(v11 + 112), (uint64_t)v177, *((unint64_t *)&v239 + 1));
  unint64_t v42 = v188;
  if (v188)
  {
    uint64_t v43 = 0;
    for (unint64_t k = 0; k < v42; ++k)
    {
      if (*(unsigned char *)(v189 + v43 + 40) == 3)
      {
        unint64_t v24 = *(void *)(v189 + v43 + 56);
        if (v24 != -1)
        {
          unint64_t v17 = *(void *)(v189 + v43 + 48);
          unint64_t v1 = *((void *)&v226 + 1);
          if (*((void *)&v226 + 1) <= v17) {
            goto LABEL_280;
          }
          unint64_t v1 = *(void *)(v11 + 120);
          if (v1 <= v24) {
            goto LABEL_281;
          }
          int v45 = (long long *)(v228 + (v17 << 6));
          uint64_t v46 = (_OWORD *)(*(void *)(v11 + 128) + (v24 << 6));
          long long v47 = *v45;
          long long v48 = v45[1];
          long long v49 = v45[3];
          v46[2] = v45[2];
          v46[3] = v49;
          _OWORD *v46 = v47;
          v46[1] = v48;
          unint64_t v42 = v188;
        }
      }
      v43 += 64;
    }
  }
  re::FixedArray<re::Quaternion<float>>::init<>((uint64_t *)(v11 + 136), (uint64_t)v177, v240);
  unint64_t v50 = v190;
  if (v190)
  {
    uint64_t v51 = 0;
    for (unint64_t m = 0; m < v50; ++m)
    {
      if (*(unsigned char *)(v191 + v51 + 40) == 3)
      {
        unint64_t v24 = *(void *)(v191 + v51 + 56);
        if (v24 != -1)
        {
          unint64_t v17 = *(void *)(v191 + v51 + 48);
          unint64_t v1 = *((void *)&v229 + 1);
          if (*((void *)&v229 + 1) <= v17) {
            goto LABEL_282;
          }
          unint64_t v1 = *(void *)(v11 + 144);
          if (v1 <= v24) {
            goto LABEL_283;
          }
          *(_OWORD *)(*(void *)(v11 + 152) + 16 * v24) = *(_OWORD *)(v231 + 16 * v17);
          unint64_t v50 = v190;
        }
      }
      v51 += 64;
    }
  }
  re::FixedArray<re::Vector2<float>>::init<>((uint64_t *)(v11 + 160), (uint64_t)v177, *((unint64_t *)&v240 + 1));
  unint64_t v53 = v192;
  if (v192)
  {
    uint64_t v54 = 0;
    for (unint64_t n = 0; n < v53; ++n)
    {
      if (*(unsigned char *)(v193 + v54 + 40) == 3)
      {
        unint64_t v24 = *(void *)(v193 + v54 + 56);
        if (v24 != -1)
        {
          unint64_t v17 = *(void *)(v193 + v54 + 48);
          unint64_t v1 = *((void *)&v232 + 1);
          if (*((void *)&v232 + 1) <= v17) {
            goto LABEL_284;
          }
          unint64_t v1 = *(void *)(v11 + 168);
          if (v1 <= v24) {
            goto LABEL_285;
          }
          *(void *)(*(void *)(v11 + 176) + 8 * v24) = *(void *)(v234 + 8 * v17);
          unint64_t v53 = v192;
        }
      }
      v54 += 64;
    }
  }
  re::FixedArray<re::Vector3<float>>::init<>((uint64_t *)(v11 + 184), (uint64_t)v177, v241);
  unint64_t v57 = v195;
  if (v195)
  {
    uint64_t v58 = 0;
    for (iuint64_t i = 0; ii < v57; ++ii)
    {
      if (*(unsigned char *)(v196 + v58 + 40) == 3)
      {
        unint64_t v24 = *(void *)(v196 + v58 + 56);
        if (v24 != -1)
        {
          unint64_t v17 = *(void *)(v196 + v58 + 48);
          unint64_t v1 = *((void *)&v235 + 1);
          if (*((void *)&v235 + 1) <= v17) {
            goto LABEL_286;
          }
          unint64_t v1 = *(void *)(v11 + 192);
          if (v1 <= v24) {
            goto LABEL_287;
          }
          *(_OWORD *)(*(void *)(v11 + 200) + 16 * v24) = *(_OWORD *)(v237 + 16 * v17);
          unint64_t v57 = v195;
        }
      }
      v58 += 64;
    }
  }
  float32x4_t v60 = v177;
  unint64_t v17 = *((void *)&v241 + 1);
  *(void *)(v11 + 208) = v177;
  *(void *)(v11 + 216) = v17;
  if (v17)
  {
    if (v17 >= 0x92492492492493) {
      goto LABEL_293;
    }
    float v61 = (_OWORD *)(*(uint64_t (**)(_anonymous_namespace_ *, unint64_t, uint64_t))(*(void *)v60 + 32))(v60, 448 * v17, 8);
    *(void *)(v11 + 224) = v61;
    if (!v61)
    {
LABEL_294:
      re::internal::assertLog((re::internal *)4, v56, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
      goto LABEL_295;
    }
    uint64_t v62 = v61;
    if (v17 != 1)
    {
      bzero(v61, 448 * v17 - 448);
      v62 += 28 * v17 - 28;
    }
    v62[26] = 0u;
    v62[27] = 0u;
    v62[24] = 0u;
    v62[25] = 0u;
    v62[22] = 0u;
    v62[23] = 0u;
    v62[20] = 0u;
    v62[21] = 0u;
    v62[18] = 0u;
    v62[19] = 0u;
    v62[16] = 0u;
    v62[17] = 0u;
    v62[14] = 0u;
    v62[15] = 0u;
    v62[12] = 0u;
    v62[13] = 0u;
    v62[10] = 0u;
    v62[11] = 0u;
    v62[8] = 0u;
    v62[9] = 0u;
    v62[6] = 0u;
    v62[7] = 0u;
    v62[4] = 0u;
    v62[5] = 0u;
    void v62[2] = 0u;
    v62[3] = 0u;
    _OWORD *v62 = 0u;
    v62[1] = 0u;
    unint64_t v17 = *((void *)&v241 + 1);
    long long v63 = v177;
    *(void *)(v11 + 232) = v177;
    *(void *)(v11 + 240) = v17;
    if (v17)
    {
      if (v17 >= 0x97B425ED097B43)
      {
LABEL_297:
        re::internal::assertLog((re::internal *)6, v56, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 432, v17);
        _os_crash();
        __break(1u);
LABEL_298:
        re::internal::assertLog((re::internal *)4, v56, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
        _os_crash();
        __break(1u);
      }
      int32x4_t v64 = (_OWORD *)(*(uint64_t (**)(_anonymous_namespace_ *, unint64_t, uint64_t))(*(void *)v63 + 32))(v63, 432 * v17, 8);
      *(void *)(v11 + 248) = v64;
      if (!v64) {
        goto LABEL_298;
      }
      int v65 = v64;
      if (v17 != 1)
      {
        bzero(v64, 432 * v17 - 432);
        v65 += 27 * v17 - 27;
      }
      v65[25] = 0u;
      v65[26] = 0u;
      v65[23] = 0u;
      v65[24] = 0u;
      v65[21] = 0u;
      v65[22] = 0u;
      v65[19] = 0u;
      v65[20] = 0u;
      v65[17] = 0u;
      v65[18] = 0u;
      v65[15] = 0u;
      v65[16] = 0u;
      v65[13] = 0u;
      v65[14] = 0u;
      v65[11] = 0u;
      v65[12] = 0u;
      v65[9] = 0u;
      v65[10] = 0u;
      v65[7] = 0u;
      v65[8] = 0u;
      v65[5] = 0u;
      v65[6] = 0u;
      v65[3] = 0u;
      v65[4] = 0u;
      v65[1] = 0u;
      v65[2] = 0u;
      _OWORD *v65 = 0u;
    }
  }
  else
  {
    *(void *)(v11 + 232) = v60;
    *(void *)(v11 + 240) = 0;
  }
  unint64_t v66 = v198;
  uint64_t v151 = v11;
  if (v198)
  {
    uint64_t v67 = 0;
    unint64_t v1 = 0;
    unint64_t v68 = 448;
    unint64_t v2 = 432;
    do
    {
      unint64_t v3 = v199;
      unint64_t v24 = *(void *)(v199 + v67 + 896);
      if (v24 != -1)
      {
        unint64_t v17 = *(void *)(v11 + 216);
        if (v17 <= v24) {
          goto LABEL_265;
        }
        uint64_t v69 = v199 + v67;
        unint64_t v70 = (void *)(*(void *)(v11 + 224) + 448 * v24);
        void *v70 = *(void *)(v199 + v67 + 448);
        unint64_t v17 = v3 + v67 + 456;
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 1), v17);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 4), v69 + 480);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 7), v69 + 504);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 10), v69 + 528);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 13), v69 + 552);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 16), v69 + 576);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 19), v69 + 600);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 22), v69 + 624);
        re::FixedArray<re::EvaluationSRT>::operator=((uint64_t)(v70 + 25), v69 + 648);
        unint64_t v7 = v69 + 672;
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 28), v69 + 672);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 31), v69 + 696);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 34), v69 + 720);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 37), v69 + 744);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 40), v69 + 768);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 43), v69 + 792);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 46), v69 + 816);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=((uint64_t)(v70 + 49), v69 + 840);
        re::FixedArray<re::EvaluationSRT>::operator=((uint64_t)(v70 + 52), v69 + 864);
        v70[55] = *(void *)(v69 + 888);
        uint64_t v11 = v151;
        uint64_t v4 = *(uint64_t **)(v151 + 240);
        if ((unint64_t)v4 <= v24)
        {
LABEL_266:
          v246[0] = 0;
          long long v250 = 0u;
          long long v251 = 0u;
          long long v248 = 0u;
          long long v249 = 0u;
          long long v247 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v268[0]) = 136315906;
          *(void *)((char *)v268 + 4) = "operator[]";
          WORD2(v268[1]) = 1024;
          *(_DWORD *)((char *)&v268[1] + 6) = 468;
          WORD1(v268[2]) = 2048;
          *(void *)((char *)&v268[2] + 4) = v24;
          WORD2(v268[3]) = 2048;
          *(void *)((char *)&v268[3] + 6) = v4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_267:
          v246[0] = 0;
          long long v250 = 0u;
          long long v251 = 0u;
          long long v248 = 0u;
          long long v249 = 0u;
          long long v247 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v268[0]) = 136315906;
          *(void *)((char *)v268 + 4) = "operator[]";
          WORD2(v268[1]) = 1024;
          *(_DWORD *)((char *)&v268[1] + 6) = 468;
          WORD1(v268[2]) = 2048;
          *(void *)((char *)&v268[2] + 4) = v24;
          WORD2(v268[3]) = 2048;
          *(void *)((char *)&v268[3] + 6) = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_268:
          v246[0] = 0;
          long long v250 = 0u;
          long long v251 = 0u;
          long long v248 = 0u;
          long long v249 = 0u;
          long long v247 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v268[0]) = 136315906;
          *(void *)((char *)v268 + 4) = "operator[]";
          WORD2(v268[1]) = 1024;
          *(_DWORD *)((char *)&v268[1] + 6) = 468;
          WORD1(v268[2]) = 2048;
          *(void *)((char *)&v268[2] + 4) = v24;
          WORD2(v268[3]) = 2048;
          *(void *)((char *)&v268[3] + 6) = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_269:
          v246[0] = 0;
          long long v250 = 0u;
          long long v251 = 0u;
          long long v248 = 0u;
          long long v249 = 0u;
          long long v247 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v268[0]) = 136315906;
          *(void *)((char *)v268 + 4) = "operator[]";
          WORD2(v268[1]) = 1024;
          *(_DWORD *)((char *)&v268[1] + 6) = 468;
          WORD1(v268[2]) = 2048;
          *(void *)((char *)&v268[2] + 4) = v24;
          WORD2(v268[3]) = 2048;
          *(void *)((char *)&v268[3] + 6) = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_270:
          v246[0] = 0;
          long long v250 = 0u;
          long long v251 = 0u;
          long long v248 = 0u;
          long long v249 = 0u;
          long long v247 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v268[0]) = 136315906;
          *(void *)((char *)v268 + 4) = "operator[]";
          WORD2(v268[1]) = 1024;
          *(_DWORD *)((char *)&v268[1] + 6) = 476;
          WORD1(v268[2]) = 2048;
          *(void *)((char *)&v268[2] + 4) = v68;
          WORD2(v268[3]) = 2048;
          *(void *)((char *)&v268[3] + 6) = v24;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_271:
          v246[0] = 0;
          long long v250 = 0u;
          long long v251 = 0u;
          long long v248 = 0u;
          long long v249 = 0u;
          long long v247 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v268[0]) = 136315906;
          *(void *)((char *)v268 + 4) = "operator[]";
          WORD2(v268[1]) = 1024;
          *(_DWORD *)((char *)&v268[1] + 6) = 468;
          WORD1(v268[2]) = 2048;
          *(void *)((char *)&v268[2] + 4) = v3;
          WORD2(v268[3]) = 2048;
          *(void *)((char *)&v268[3] + 6) = v24;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_272:
          v246[0] = 0;
          long long v250 = 0u;
          long long v251 = 0u;
          long long v248 = 0u;
          long long v249 = 0u;
          long long v247 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v268[0]) = 136315906;
          *(void *)((char *)v268 + 4) = "operator[]";
          WORD2(v268[1]) = 1024;
          *(_DWORD *)((char *)&v268[1] + 6) = 797;
          WORD1(v268[2]) = 2048;
          *(void *)((char *)&v268[2] + 4) = v7;
          WORD2(v268[3]) = 2048;
          *(void *)((char *)&v268[3] + 6) = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_273;
        }
        re::FixedRegisterTable::initSize<re::FixedRegisterIdTable>((uint64_t *)(*(void *)(v151 + 248) + 432 * v24), (uint64_t)v177, (unint64_t *)(v3 + v67 + 456));
        unint64_t v17 = *(void *)(v151 + 240);
        if (v17 <= v24) {
          goto LABEL_267;
        }
        re::FixedArray<re::GenericSRT<float>>::init<>((void *)(*(void *)(v151 + 248) + 432 * v24 + 192), (uint64_t)v177, *(void *)(v3 + v67 + 656));
        unint64_t v17 = *(void *)(v151 + 240);
        if (v17 <= v24) {
          goto LABEL_268;
        }
        re::FixedRegisterTable::initSize<re::FixedRegisterIdTable>((uint64_t *)(*(void *)(v151 + 248) + 432 * v24 + 216), (uint64_t)v177, (unint64_t *)v7);
        unint64_t v17 = *(void *)(v151 + 240);
        if (v17 <= v24) {
          goto LABEL_269;
        }
        re::FixedArray<re::GenericSRT<float>>::init<>((void *)(*(void *)(v151 + 248) + 432 * v24 + 408), (uint64_t)v177, *(void *)(v3 + v67 + 872));
        unint64_t v66 = v198;
      }
      ++v1;
      v67 += 904;
    }
    while (v1 < v66);
  }
  __int16 v71 = v177;
  unint64_t v17 = v242;
  *(void *)(v11 + 256) = v177;
  *(void *)(v11 + 264) = v17;
  if (v17)
  {
    if (v17 < 0x8FB823EE08FB83)
    {
      unint64_t v72 = (char *)(*(uint64_t (**)(_anonymous_namespace_ *, unint64_t, uint64_t))(*(void *)v71 + 32))(v71, 456 * v17, 8);
      *(void *)(v11 + 272) = v72;
      if (v72)
      {
        float32x4_t v74 = v72;
        if (v17 != 1)
        {
          bzero(v72, 456 * v17 - 456);
          v74 += 456 * v17 - 456;
        }
        *((void *)v74 + 56) = 0;
        *((_OWORD *)v74 + 26) = 0u;
        *((_OWORD *)v74 + 27) = 0u;
        *((_OWORD *)v74 + 24) = 0u;
        *((_OWORD *)v74 + 25) = 0u;
        *((_OWORD *)v74 + 22) = 0u;
        *((_OWORD *)v74 + 23) = 0u;
        *((_OWORD *)v74 + 20) = 0u;
        *((_OWORD *)v74 + 21) = 0u;
        *((_OWORD *)v74 + 18) = 0u;
        *((_OWORD *)v74 + 19) = 0u;
        *((_OWORD *)v74 + 16) = 0u;
        *((_OWORD *)v74 + 17) = 0u;
        *((_OWORD *)v74 + 14) = 0u;
        *((_OWORD *)v74 + 15) = 0u;
        *((_OWORD *)v74 + 12) = 0u;
        *((_OWORD *)v74 + 13) = 0u;
        *((_OWORD *)v74 + 10) = 0u;
        *((_OWORD *)v74 + 11) = 0u;
        *((_OWORD *)v74 + 8) = 0u;
        *((_OWORD *)v74 + 9) = 0u;
        *((_OWORD *)v74 + 6) = 0u;
        *((_OWORD *)v74 + 7) = 0u;
        *((_OWORD *)v74 + 4) = 0u;
        *((_OWORD *)v74 + 5) = 0u;
        *((_OWORD *)v74 + 2) = 0u;
        *((_OWORD *)v74 + 3) = 0u;
        *(_OWORD *)float32x4_t v74 = 0u;
        *((_OWORD *)v74 + 1) = 0u;
        goto LABEL_105;
      }
      goto LABEL_296;
    }
LABEL_295:
    re::internal::assertLog((re::internal *)6, v56, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 456, v17);
    _os_crash();
    __break(1u);
LABEL_296:
    re::internal::assertLog((re::internal *)4, v73, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    goto LABEL_297;
  }
LABEL_105:
  unint64_t v146 = v201;
  if (v201)
  {
    unint64_t v68 = 0;
    unint64_t v7 = (unint64_t)&v258;
    unint64_t v2 = 248;
    unint64_t v17 = 456;
    do
    {
      unint64_t v24 = v201;
      if (v201 <= v68) {
        goto LABEL_270;
      }
      unint64_t v1 = (unint64_t)v202;
      v159 = (void *)re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](v178 + 1608, v68);
      unint64_t v3 = *(void *)(v1 + 248 * v68 + 240);
      if (v3 != -1)
      {
        unint64_t v24 = *(void *)(v11 + 264);
        if (v24 <= v3) {
          goto LABEL_271;
        }
        uint64_t v75 = *(void *)(v11 + 272);
        uint64_t v4 = (uint64_t *)(v75 + 456 * v3);
        unint64_t v76 = v1 + 248 * v68;
        unint64_t v2 = *(void *)(v76 + 32);
        unint64_t v157 = (unint64_t *)(v76 + 32);
        re::FixedArray<unsigned long>::init<>(v4, (uint64_t)v177, v2);
        uint64_t v78 = v177;
        v4[3] = (uint64_t)v177;
        v4[4] = v2;
        unint64_t v156 = (unint64_t *)(v4 + 4);
        unint64_t v148 = v3;
        unint64_t v149 = v68;
        unint64_t v150 = v1;
        uint64_t v147 = v75;
        if (v2)
        {
          if (v2 < 0x155555555555556)
          {
            unint64_t v24 = 192 * v2;
            int64_t v79 = (_OWORD *)(*(uint64_t (**)(_anonymous_namespace_ *, unint64_t, uint64_t))(*(void *)v78 + 32))(v78, 192 * v2, 8);
            uint64_t v81 = v75 + 456 * v3;
            *(void *)(v81 + 40) = v79;
            v154 = (void *)(v81 + 40);
            if (v79)
            {
              uint64_t v82 = v79;
              unint64_t v158 = v2;
              if (v2 != 1)
              {
                size_t v83 = v24 - 192;
                bzero(v79, v83);
                uint64_t v82 = (_OWORD *)((char *)v82 + v83);
              }
              v82[10] = 0u;
              v82[11] = 0u;
              v82[8] = 0u;
              v82[9] = 0u;
              v82[6] = 0u;
              v82[7] = 0u;
              v82[4] = 0u;
              v82[5] = 0u;
              v82[2] = 0u;
              v82[3] = 0u;
              _OWORD *v82 = 0u;
              v82[1] = 0u;
              uint64_t v84 = v75 + 456 * v3;
              uint64_t v85 = v177;
              unint64_t v24 = v2;
              *(void *)(v84 + 56) = v2;
              unint64_t v153 = (unint64_t *)(v84 + 56);
              *(void *)(v84 + 48) = v85;
              if (v2 < 0x5397829CBC14E6)
              {
                uint64_t v86 = (*(uint64_t (**)(_anonymous_namespace_ *, unint64_t, uint64_t))(*(void *)v85 + 32))(v85, 784 * v2, 8);
                uint64_t v88 = v75 + 456 * v3;
                *(void *)(v88 + 64) = v86;
                unint64_t v152 = (void *)(v88 + 64);
                if (v86)
                {
                  uint64_t v89 = v86;
                  unint64_t v90 = v2 - 1;
                  if (v2 != 1)
                  {
                    uint64_t v91 = v86;
                    do
                    {
                      *(void *)uint64_t v89 = &unk_26E6C4A78;
                      *(_DWORD *)(v89 + 8) = -1;
                      bzero((void *)(v89 + 16), 0x300uLL);
                      v89 += 784;
                      v91 += 784;
                      --v90;
                    }
                    while (v90);
                  }
                  *(void *)uint64_t v89 = &unk_26E6C4A78;
                  *(_DWORD *)(v89 + 8) = -1;
                  bzero((void *)(v89 + 16), 0x300uLL);
                  unint64_t v1 = 0;
                  unint64_t v3 = 0;
                  unint64_t v93 = 0;
                  v155 = (unint64_t *)(v150 + 248 * v68 + 40);
                  unint64_t v2 = 104;
                  while (1)
                  {
                    unint64_t v24 = *v157;
                    if (*v157 <= v93) {
                      break;
                    }
                    unint64_t v68 = *v155;
                    uint64_t v94 = (void **)re::BucketArray<re::EvaluationBranchData,8ul>::operator[]((uint64_t)v159, v93);
                    unint64_t v24 = v4[1];
                    if (v24 <= v93) {
                      goto LABEL_262;
                    }
                    BOOL v95 = v94;
                    unint64_t v96 = *v94;
                    unint64_t v24 = v68 + v2;
                    *(void *)(v4[2] + 8 * v93) = *(void *)(v68 + v2 - 104);
                    unint64_t v68 = *v156;
                    if (*v156 <= v93) {
                      goto LABEL_263;
                    }
                    unint64_t v68 = *v154 + v1;
                    re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v68, v24 - 96);
                    re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v68 + 24, v24 - 72);
                    re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v68 + 48, v24 - 48);
                    re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v68 + 72, v24 - 24);
                    re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v68 + 96, v24);
                    re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v68 + 120, v24 + 24);
                    re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v68 + 144, v24 + 48);
                    re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v68 + 168, v24 + 72);
                    uint64_t v97 = v95[8];
                    v246[0] = v95[10];
                    v246[1] = v97;
                    uint64_t v98 = v95[13];
                    v246[2] = v95[15];
                    v246[3] = v98;
                    uint64_t v99 = v95[18];
                    v246[4] = v95[20];
                    v246[5] = v99;
                    uint64_t v100 = v95[23];
                    v246[6] = v95[25];
                    v246[7] = v100;
                    uint64_t v101 = v95[28];
                    v246[8] = v95[30];
                    v246[9] = v101;
                    uint64_t v102 = v95[33];
                    v246[10] = v95[35];
                    v246[11] = v102;
                    uint64_t v103 = v95[38];
                    v246[12] = v95[40];
                    v246[13] = v103;
                    uint64_t v104 = v95[43];
                    v246[14] = v95[45];
                    v246[15] = v104;
                    long long v276 = 0u;
                    long long v277 = 0u;
                    long long v274 = 0u;
                    long long v275 = 0u;
                    long long v272 = 0u;
                    long long v273 = 0u;
                    long long v270 = 0u;
                    long long v271 = 0u;
                    long long v269 = 0u;
                    memset(v268, 0, sizeof(v268));
                    long long v105 = 0uLL;
                    long long v266 = 0u;
                    long long v267 = 0u;
                    long long v264 = 0u;
                    long long v265 = 0u;
                    long long v262 = 0u;
                    long long v263 = 0u;
                    long long v260 = 0u;
                    long long v261 = 0u;
                    long long v258 = 0u;
                    long long v259 = 0u;
                    uint64_t v106 = v96[123];
                    *(void *)&long long v247 = v96[125];
                    *((void *)&v247 + 1) = v106;
                    uint64_t v107 = v96[128];
                    *(void *)&long long v248 = v96[130];
                    *((void *)&v248 + 1) = v107;
                    uint64_t v108 = v96[133];
                    *(void *)&long long v249 = v96[135];
                    *((void *)&v249 + 1) = v108;
                    uint64_t v109 = v96[138];
                    *(void *)&long long v250 = v96[140];
                    *((void *)&v250 + 1) = v109;
                    uint64_t v110 = v96[143];
                    *(void *)&long long v251 = v96[145];
                    *((void *)&v251 + 1) = v110;
                    uint64_t v111 = v96[148];
                    uint64_t v252 = v96[150];
                    uint64_t v253 = v111;
                    uint64_t v112 = v96[153];
                    uint64_t v254 = v96[155];
                    uint64_t v255 = v112;
                    uint64_t v113 = v96[158];
                    uint64_t v256 = v96[160];
                    uint64_t v257 = v113;
                    *(void *)&long long v259 = v268[2];
                    *((void *)&v259 + 1) = v268[1];
                    *(void *)&long long v260 = v268[5];
                    *((void *)&v260 + 1) = v268[4];
                    *(void *)&long long v261 = v270;
                    *((void *)&v261 + 1) = *((void *)&v269 + 1);
                    *(void *)&long long v262 = *((void *)&v271 + 1);
                    *((void *)&v262 + 1) = v271;
                    *(void *)&long long v263 = v273;
                    *((void *)&v263 + 1) = *((void *)&v272 + 1);
                    *(void *)&long long v264 = *((void *)&v274 + 1);
                    *((void *)&v264 + 1) = v274;
                    *(void *)&long long v265 = v276;
                    *((void *)&v265 + 1) = *((void *)&v275 + 1);
                    *(void *)&long long v266 = *((void *)&v277 + 1);
                    *((void *)&v266 + 1) = v277;
                    unint64_t v24 = *v153;
                    if (*v153 <= v93) {
                      goto LABEL_264;
                    }
                    *(_DWORD *)(*v152 + v3 + 8) = v211;
                    re::EvaluationModelSingleThread::init(v243);
                    if (!v243[0] && (void)v244)
                    {
                      if (BYTE8(v244)) {
                        (*(void (**)(void))(*(void *)v244 + 40))();
                      }
                      long long v244 = 0u;
                      long long v245 = 0u;
                    }
                    if (*((void *)&v276 + 1))
                    {
                      if ((void)v277)
                      {
                        (*(void (**)(void))(**((void **)&v276 + 1) + 40))();
                        long long v277 = 0uLL;
                      }
                      *((void *)&v276 + 1) = 0;
                    }
                    if ((void)v275)
                    {
                      if (*((void *)&v275 + 1))
                      {
                        (*(void (**)(void))(*(void *)v275 + 40))();
                        *((void *)&v275 + 1) = 0;
                        *(void *)&long long v276 = 0;
                      }
                      *(void *)&long long v275 = 0;
                    }
                    if (*((void *)&v273 + 1))
                    {
                      if ((void)v274)
                      {
                        (*(void (**)(void))(**((void **)&v273 + 1) + 40))();
                        long long v274 = 0uLL;
                      }
                      *((void *)&v273 + 1) = 0;
                    }
                    if ((void)v272)
                    {
                      if (*((void *)&v272 + 1))
                      {
                        (*(void (**)(void))(*(void *)v272 + 40))();
                        *((void *)&v272 + 1) = 0;
                        *(void *)&long long v273 = 0;
                      }
                      *(void *)&long long v272 = 0;
                    }
                    if (*((void *)&v270 + 1))
                    {
                      if ((void)v271)
                      {
                        (*(void (**)(void))(**((void **)&v270 + 1) + 40))();
                        long long v271 = 0uLL;
                      }
                      *((void *)&v270 + 1) = 0;
                    }
                    if ((void)v269)
                    {
                      if (*((void *)&v269 + 1))
                      {
                        (*(void (**)(void))(*(void *)v269 + 40))();
                        *((void *)&v269 + 1) = 0;
                        *(void *)&long long v270 = 0;
                      }
                      *(void *)&long long v269 = 0;
                    }
                    if (v268[3])
                    {
                      if (v268[4])
                      {
                        (*(void (**)(void))(*(void *)v268[3] + 40))();
                        v268[4] = 0;
                        v268[5] = 0;
                      }
                      v268[3] = 0;
                    }
                    if (v268[0] && v268[1]) {
                      (*(void (**)(void))(*(void *)v268[0] + 40))();
                    }
                    ++v93;
                    v3 += 784;
                    v2 += 200;
                    v1 += 192;
                    if (v158 == v93) {
                      goto LABEL_164;
                    }
                  }
                  v246[0] = 0;
                  long long v250 = 0u;
                  long long v251 = 0u;
                  long long v248 = 0u;
                  long long v249 = 0u;
                  long long v247 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  LODWORD(v268[0]) = 136315906;
                  *(void *)((char *)v268 + 4) = "operator[]";
                  WORD2(v268[1]) = 1024;
                  *(_DWORD *)((char *)&v268[1] + 6) = 476;
                  WORD1(v268[2]) = 2048;
                  *(void *)((char *)&v268[2] + 4) = v93;
                  WORD2(v268[3]) = 2048;
                  *(void *)((char *)&v268[3] + 6) = v24;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_262:
                  v246[0] = 0;
                  long long v250 = 0u;
                  long long v251 = 0u;
                  long long v248 = 0u;
                  long long v249 = 0u;
                  long long v247 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  LODWORD(v268[0]) = 136315906;
                  *(void *)((char *)v268 + 4) = "operator[]";
                  WORD2(v268[1]) = 1024;
                  *(_DWORD *)((char *)&v268[1] + 6) = 468;
                  WORD1(v268[2]) = 2048;
                  *(void *)((char *)&v268[2] + 4) = v93;
                  WORD2(v268[3]) = 2048;
                  *(void *)((char *)&v268[3] + 6) = v24;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_263:
                  v246[0] = 0;
                  long long v250 = 0u;
                  long long v251 = 0u;
                  long long v248 = 0u;
                  long long v249 = 0u;
                  long long v247 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  LODWORD(v268[0]) = 136315906;
                  *(void *)((char *)v268 + 4) = "operator[]";
                  WORD2(v268[1]) = 1024;
                  *(_DWORD *)((char *)&v268[1] + 6) = 468;
                  WORD1(v268[2]) = 2048;
                  *(void *)((char *)&v268[2] + 4) = v93;
                  WORD2(v268[3]) = 2048;
                  *(void *)((char *)&v268[3] + 6) = v68;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_264:
                  v246[16] = 0;
                  unint64_t v17 = (unint64_t)v268;
                  long long v289 = v105;
                  long long v290 = v105;
                  long long v287 = v105;
                  long long v288 = v105;
                  long long v286 = v105;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v278 = 136315906;
                  v279 = "operator[]";
                  __int16 v280 = 1024;
                  int v281 = 468;
                  __int16 v282 = 2048;
                  unint64_t v283 = v93;
                  __int16 v284 = 2048;
                  unint64_t v285 = v24;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_265:
                  v246[0] = 0;
                  long long v250 = 0u;
                  long long v251 = 0u;
                  long long v248 = 0u;
                  long long v249 = 0u;
                  long long v247 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  LODWORD(v268[0]) = 136315906;
                  *(void *)((char *)v268 + 4) = "operator[]";
                  WORD2(v268[1]) = 1024;
                  *(_DWORD *)((char *)&v268[1] + 6) = 468;
                  WORD1(v268[2]) = 2048;
                  *(void *)((char *)&v268[2] + 4) = v24;
                  WORD2(v268[3]) = 2048;
                  *(void *)((char *)&v268[3] + 6) = v17;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_266;
                }
LABEL_291:
                re::internal::assertLog((re::internal *)4, v87, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
                _os_crash();
                __break(1u);
LABEL_292:
                re::internal::assertLog((re::internal *)4, v20, "assertion failure: '%s' (%s:line %i) Cannot copy from a Slice of a different size", "m_size == other.size()", "copy", 378);
                _os_crash();
                __break(1u);
LABEL_293:
                re::internal::assertLog((re::internal *)6, v56, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 448, v17);
                _os_crash();
                __break(1u);
                goto LABEL_294;
              }
LABEL_290:
              re::internal::assertLog((re::internal *)6, v80, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 784, v24);
              _os_crash();
              __break(1u);
              goto LABEL_291;
            }
LABEL_289:
            re::internal::assertLog((re::internal *)4, v80, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
            _os_crash();
            __break(1u);
            goto LABEL_290;
          }
LABEL_288:
          re::internal::assertLog((re::internal *)6, v77, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 192, v2);
          _os_crash();
          __break(1u);
          goto LABEL_289;
        }
        uint64_t v114 = v75 + 456 * v3;
        *(void *)(v114 + 48) = v78;
        *(void *)(v114 + 56) = 0;
LABEL_164:
        unint64_t v68 = v149;
        unint64_t v2 = 248;
        unint64_t v115 = v150 + 248 * v149;
        unint64_t v17 = 456;
        uint64_t v116 = v147 + 456 * v148;
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v116 + 72, v115 + 48);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v116 + 96, v115 + 72);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v116 + 120, v115 + 96);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v116 + 144, v115 + 120);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v116 + 168, v115 + 144);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v116 + 192, v115 + 168);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v116 + 216, v115 + 192);
        re::FixedArray<re::EvaluationRegisterId<int>>::operator=(v116 + 240, v115 + 216);
        uint64_t v117 = v159[49];
        *(void *)&long long v247 = v159[51];
        *((void *)&v247 + 1) = v117;
        re::FixedArray<int>::operator=((_anonymous_namespace_ *)(v116 + 264), (uint64_t)&v247);
        uint64_t v118 = v159[54];
        *(void *)&long long v247 = v159[56];
        *((void *)&v247 + 1) = v118;
        re::FixedArray<int>::operator=((_anonymous_namespace_ *)(v116 + 288), (uint64_t)&v247);
        uint64_t v119 = v159[59];
        *(void *)&long long v247 = v159[61];
        *((void *)&v247 + 1) = v119;
        re::FixedArray<int>::operator=((_anonymous_namespace_ *)(v116 + 312), (uint64_t)&v247);
        uint64_t v120 = v159[64];
        *(void *)&long long v247 = v159[66];
        *((void *)&v247 + 1) = v120;
        re::FixedArray<re::Matrix3x3<float>>::operator=((_anonymous_namespace_ *)(v116 + 336), (uint64_t)&v247);
        uint64_t v121 = v159[69];
        *(void *)&long long v247 = v159[71];
        *((void *)&v247 + 1) = v121;
        re::FixedArray<re::Matrix4x4<float>>::operator=((_anonymous_namespace_ *)(v116 + 360), (uint64_t)&v247);
        uint64_t v122 = v159[74];
        *(void *)&long long v247 = v159[76];
        *((void *)&v247 + 1) = v122;
        re::FixedArray<re::Quaternion<float>>::operator=((_anonymous_namespace_ *)(v116 + 384), (uint64_t)&v247);
        uint64_t v123 = v159[79];
        *(void *)&long long v247 = v159[81];
        *((void *)&v247 + 1) = v123;
        re::FixedArray<re::Vector2<float>>::operator=((_anonymous_namespace_ *)(v116 + 408), (uint64_t)&v247);
        uint64_t v124 = v159[84];
        *(void *)&long long v247 = v159[86];
        *((void *)&v247 + 1) = v124;
        re::FixedArray<re::Vector3<float>>::operator=((_anonymous_namespace_ *)(v116 + 432), (uint64_t)&v247);
        uint64_t v11 = v151;
      }
      ++v68;
    }
    while (v68 != v146);
    int v125 = v160[0];
  }
  else
  {
    int v125 = 1;
  }
  *(unsigned char *)uint64_t v145 = 1;
  if (!v125) {
    goto LABEL_169;
  }
LABEL_172:
  if (v165[0] && v168) {
    (*(void (**)(void))(*(void *)v165[0] + 40))();
  }
  if (v169[0] && v172) {
    (*(void (**)(void))(*(void *)v169[0] + 40))();
  }
  if (v173[0] && __src) {
    (*(void (**)(void))(*(void *)v173[0] + 40))();
  }
  if (*((void *)&v234 + 1))
  {
    if ((void)v237) {
      (*(void (**)(void))(**((void **)&v234 + 1) + 40))();
    }
    *(void *)&long long v237 = 0;
    long long v235 = 0uLL;
    *((void *)&v234 + 1) = 0;
    ++v236;
  }
  if (*((void *)&v231 + 1))
  {
    if ((void)v234) {
      (*(void (**)(void))(**((void **)&v231 + 1) + 40))();
    }
    *(void *)&long long v234 = 0;
    long long v232 = 0uLL;
    *((void *)&v231 + 1) = 0;
    ++v233;
  }
  if (*((void *)&v228 + 1))
  {
    if ((void)v231) {
      (*(void (**)(void))(**((void **)&v228 + 1) + 40))();
    }
    *(void *)&long long v231 = 0;
    long long v229 = 0uLL;
    *((void *)&v228 + 1) = 0;
    ++v230;
  }
  if (*((void *)&v225 + 1))
  {
    if ((void)v228) {
      (*(void (**)(void))(**((void **)&v225 + 1) + 40))();
    }
    *(void *)&long long v228 = 0;
    long long v226 = 0uLL;
    *((void *)&v225 + 1) = 0;
    ++v227;
  }
  if (*((void *)&v222 + 1))
  {
    if ((void)v225) {
      (*(void (**)(void))(**((void **)&v222 + 1) + 40))();
    }
    *(void *)&long long v225 = 0;
    long long v223 = 0uLL;
    *((void *)&v222 + 1) = 0;
    ++v224;
  }
  if (*((void *)&v219 + 1))
  {
    if ((void)v222) {
      (*(void (**)(void))(**((void **)&v219 + 1) + 40))();
    }
    *(void *)&long long v222 = 0;
    long long v220 = 0uLL;
    *((void *)&v219 + 1) = 0;
    ++v221;
  }
  if (*((void *)&v216 + 1))
  {
    if ((void)v219) {
      (*(void (**)(void))(**((void **)&v216 + 1) + 40))();
    }
    *(void *)&long long v219 = 0;
    long long v217 = 0uLL;
    *((void *)&v216 + 1) = 0;
    ++v218;
  }
  if (v212)
  {
    if ((void)v216) {
      (*(void (**)(void))(*(void *)v212 + 40))();
    }
    *(void *)&long long v216 = 0;
    uint64_t v213 = 0;
    unint64_t v214 = 0;
    uint64_t v212 = 0;
    ++v215;
  }
  if (v206)
  {
    if (v210) {
      (*(void (**)(void))(*(void *)v206 + 40))();
    }
    uint64_t v210 = 0;
    uint64_t v207 = 0;
    uint64_t v208 = 0;
    uint64_t v206 = 0;
    ++v209;
  }
  unint64_t v126 = 3120;
  do
  {
    float v127 = (_anonymous_namespace_ **)((char *)&v177 + v126);
    uint64_t v128 = *(void *)&v203[v126];
    if (v128)
    {
      if (v127[82]) {
        (*(void (**)(uint64_t))(*(void *)v128 + 40))(v128);
      }
      v127[82] = 0;
      v127[79] = 0;
      v127[80] = 0;
      v127[78] = 0;
      ++LODWORD(v205[v126 / 8]);
    }
    v126 -= 40;
  }
  while (v126);
  if (v204)
  {
    if (v205[0])
    {
      (*(void (**)(void))(*(void *)v204 + 40))();
      v205[0] = 0;
      v205[1] = 0;
    }
    uint64_t v204 = 0;
  }
  for (junint64_t j = 616; jj != 424; jj -= 24)
    re::FixedArray<CoreIKTransform>::deinit((uint64_t *)((char *)&v177 + jj));
  do
  {
    re::FixedArray<CoreIKTransform>::deinit((uint64_t *)((char *)&v177 + jj));
    jj -= 24;
  }
  while (jj != 232);
  if (v200)
  {
    if (v201)
    {
      uint64_t v130 = v202;
      uint64_t v131 = &v202[31 * v201];
      do
      {
        re::FixedArray<CoreIKTransform>::deinit(v130 + 27);
        re::FixedArray<CoreIKTransform>::deinit(v130 + 24);
        re::FixedArray<CoreIKTransform>::deinit(v130 + 21);
        re::FixedArray<CoreIKTransform>::deinit(v130 + 18);
        re::FixedArray<CoreIKTransform>::deinit(v130 + 15);
        re::FixedArray<CoreIKTransform>::deinit(v130 + 12);
        re::FixedArray<CoreIKTransform>::deinit(v130 + 9);
        re::FixedArray<CoreIKTransform>::deinit(v130 + 6);
        if (v130[3])
        {
          uint64_t v132 = v130[4];
          if (v132)
          {
            uint64_t v133 = 0;
            uint64_t v134 = v130[5];
            uint64_t v135 = 200 * v132;
            do
            {
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v134 + v133 + 176));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v134 + v133 + 152));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v134 + v133 + 128));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v134 + v133 + 104));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v134 + v133 + 80));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v134 + v133 + 56));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v134 + v133 + 32));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v134 + v133 + 8));
              v133 += 200;
            }
            while (v135 != v133);
            (*(void (**)(uint64_t, uint64_t))(*(void *)v130[3] + 40))(v130[3], v130[5]);
            v130[4] = 0;
            v130[5] = 0;
          }
          v130[3] = 0;
        }
        if (*v130)
        {
          uint64_t v136 = v130[1];
          if (v136)
          {
            uint64_t v137 = 0;
            uint64_t v138 = v130[2];
            uint64_t v139 = 200 * v136;
            do
            {
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v138 + v137 + 176));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v138 + v137 + 152));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v138 + v137 + 128));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v138 + v137 + 104));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v138 + v137 + 80));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v138 + v137 + 56));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v138 + v137 + 32));
              re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v138 + v137 + 8));
              v137 += 200;
            }
            while (v139 != v137);
            (*(void (**)(uint64_t, uint64_t))(*(void *)*v130 + 40))(*v130, v130[2]);
            v130[1] = 0;
            v130[2] = 0;
          }
          uint64_t *v130 = 0;
        }
        v130 += 31;
      }
      while (v130 != v131);
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v200 + 40))(v200, v202);
      unint64_t v201 = 0;
      v202 = 0;
    }
    uint64_t v200 = 0;
  }
  if (v197)
  {
    if (v198)
    {
      unint64_t v140 = v199;
      uint64_t v141 = 904 * v198;
      do
      {
        re::EvaluationCallbackData::~EvaluationCallbackData((re::EvaluationCallbackData *)(v140 + 448));
        re::EvaluationCallbackData::~EvaluationCallbackData((re::EvaluationCallbackData *)v140);
        v140 += 904;
        v141 -= 904;
      }
      while (v141);
      (*(void (**)(uint64_t, unint64_t))(*(void *)v197 + 40))(v197, v199);
      unint64_t v198 = 0;
      unint64_t v199 = 0;
    }
    uint64_t v197 = 0;
  }
  for (kunint64_t k = 0; kk != -192; kk -= 24)
  {
    v143 = (_anonymous_namespace_ **)((char *)&v177 + kk);
    uint64_t result = *(void *)&v194[kk];
    if (result)
    {
      if (v143[24])
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 40))(result, *(uint64_t *)((char *)&v196 + kk));
        v143[24] = 0;
        v143[25] = 0;
      }
      v143[23] = 0;
    }
  }
  return result;
}

re::Allocator *re::anonymous namespace'::RegisterMapping::processEvaluationTree(uint64_t a1, uint64_t a2, void *a3, _anonymous_namespace_ *a4, void *a5, void *a6)
{
  uint64_t v404 = *MEMORY[0x263EF8340];
  unint64_t v13 = a2 + 256;
  re::EvaluationDependencyMap::init((void *)(a2 + 256), *(re::Allocator **)a2, *(re::EvaluationTree **)(a2 + 8), (uint64_t)a3, (*(_DWORD *)(a2 + 3824) & 3) == 0, (uint64_t)v379);
  if (!v379[0])
  {
    *(unsigned char *)a1 = 0;
    *(_OWORD *)(a1 + 8) = v380;
    *(void *)(a1 + 24) = v381;
    *(void *)(a1 + 48) = v383;
    *(_OWORD *)(a1 + 32) = v382;
    uint64_t v383 = 0;
    v381 = 0;
    long long v382 = 0uLL;
LABEL_180:
    uint64_t result = v381;
    if (v381)
    {
      if (v382) {
        return (re::Allocator *)(*(uint64_t (**)(re::Allocator *, void))(*(void *)v381 + 40))(v381, *((void *)&v382 + 1));
      }
    }
    return result;
  }
  v377 = a6;
  v373 = (unsigned char *)a1;
  unint64_t v14 = *(void *)(*(void *)(a2 + 8) + 1680);
  if (v14)
  {
    unint64_t v8 = 0;
    unint64_t v7 = 0xFFFFFFFFLL;
    do
    {
      if (re::EvaluationDependencyMap::isRegisterUsed(v13, 0, v8))
      {
        unint64_t v15 = *(void **)(a2 + 24);
        if ((unint64_t)v15 <= v8) {
          goto LABEL_360;
        }
        uint64_t v16 = *(void *)(a2 + 32);
        unint64_t v17 = *(void **)(a2 + 8);
        unint64_t i = v16 + (v8 << 6);
        LODWORD(v385) = -1;
        long long v386 = 0uLL;
        *((void *)&v385 + 1) = 0;
        re::EvaluationTree::getRegister<int>(v17, v8, &v385);
        long long v18 = v386;
        *(_OWORD *)unint64_t i = v385;
        *(_OWORD *)(i + 16) = v18;
        uint64_t v19 = *(unsigned int *)i;
        if (v19 == 77)
        {
          uint64_t v31 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](*(void *)(a2 + 8) + 1608, *(void *)(i + 8));
          uint64_t v32 = *(void *)(v31 + 40);
          uint64_t v33 = (uint64_t *)(i + 32);
          if (v32)
          {
            uint64_t v34 = v31;
            for (unint64_t i = 0; i != v32; ++i)
            {
              unint64_t v35 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v34, i);
              uint64_t v36 = *v33;
              if (v35[5] != -1) {
                ++v36;
              }
              float32x4_t v37 = (void *)*v35;
              uint64_t v38 = v36 + *(void *)(*v35 + 984);
              *uint64_t v33 = v38;
              uint64_t v39 = v37[128] + v38;
              *uint64_t v33 = v39;
              uint64_t v40 = v37[133] + v39;
              *uint64_t v33 = v40;
              uint64_t v41 = v37[138] + v40;
              *uint64_t v33 = v41;
              uint64_t v42 = v37[143] + v41;
              *uint64_t v33 = v42;
              uint64_t v43 = v37[148] + v42;
              *uint64_t v33 = v43;
              uint64_t v44 = v37[153] + v43;
              *uint64_t v33 = v44;
              uint64_t v45 = v37[158] + v44;
              *uint64_t v33 = v45;
            }
          }
          else
          {
            uint64_t v45 = *v33;
          }
          unint64_t v7 = 0xFFFFFFFFLL;
          if (v45) {
            goto LABEL_18;
          }
        }
        else
        {
          if (v19 == 76)
          {
            CallbackData = (void *)re::EvaluationTree::getCallbackData(*(re::EvaluationTree **)(a2 + 8), *(void *)(i + 8));
            uint64_t v21 = v16 + (v8 << 6);
            uint64_t v22 = *(void *)(v21 + 32) + CallbackData[2];
            *(void *)(v21 + 32) = v22;
            uint64_t v23 = CallbackData[5] + v22;
            *(void *)(v21 + 32) = v23;
            uint64_t v24 = CallbackData[8] + v23;
            *(void *)(v21 + 32) = v24;
            uint64_t v25 = CallbackData[11] + v24;
            *(void *)(v21 + 32) = v25;
            uint64_t v26 = CallbackData[14] + v25;
            *(void *)(v21 + 32) = v26;
            uint64_t v27 = CallbackData[17] + v26;
            *(void *)(v21 + 32) = v27;
            uint64_t v28 = CallbackData[20] + v27;
            *(void *)(v21 + 32) = v28;
            uint64_t v29 = CallbackData[23] + v28;
            *(void *)(v21 + 32) = v29;
            uint64_t v30 = 3 * CallbackData[26] + v29;
          }
          else
          {
            uint64_t v30 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v19 + 9);
            uint64_t v21 = v16 + (v8 << 6);
          }
          *(void *)(v21 + 32) = v30;
          if (v30) {
            goto LABEL_18;
          }
        }
      }
LABEL_18:
      ++v8;
    }
    while (v8 != v14);
  }
  unint64_t v46 = *(void *)(*(void *)(a2 + 8) + 1720);
  if (v46)
  {
    unint64_t v8 = 0;
    unint64_t v7 = 0xFFFFFFFFLL;
    do
    {
      if (re::EvaluationDependencyMap::isRegisterUsed(v13, 1u, v8))
      {
        unint64_t v15 = *(void **)(a2 + 48);
        if ((unint64_t)v15 <= v8) {
          goto LABEL_361;
        }
        uint64_t v47 = *(void *)(a2 + 56);
        long long v48 = *(void **)(a2 + 8);
        unint64_t i = v47 + (v8 << 6);
        LODWORD(v385) = -1;
        long long v386 = 0uLL;
        *((void *)&v385 + 1) = 0;
        re::EvaluationTree::getRegister<unsigned int>(v48, v8, &v385);
        long long v49 = v386;
        *(_OWORD *)unint64_t i = v385;
        *(_OWORD *)(i + 16) = v49;
        uint64_t v50 = *(unsigned int *)i;
        if (v50 == 77)
        {
          uint64_t v62 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](*(void *)(a2 + 8) + 1608, *(void *)(i + 8));
          uint64_t v63 = *(void *)(v62 + 40);
          int32x4_t v64 = (uint64_t *)(i + 32);
          if (v63)
          {
            uint64_t v65 = v62;
            for (unint64_t i = 0; i != v63; ++i)
            {
              unint64_t v66 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v65, i);
              uint64_t v67 = *v64;
              if (v66[5] != -1) {
                ++v67;
              }
              unint64_t v68 = (void *)*v66;
              uint64_t v69 = v67 + *(void *)(*v66 + 984);
              uint64_t *v64 = v69;
              uint64_t v70 = v68[128] + v69;
              uint64_t *v64 = v70;
              uint64_t v71 = v68[133] + v70;
              uint64_t *v64 = v71;
              uint64_t v72 = v68[138] + v71;
              uint64_t *v64 = v72;
              uint64_t v73 = v68[143] + v72;
              uint64_t *v64 = v73;
              uint64_t v74 = v68[148] + v73;
              uint64_t *v64 = v74;
              uint64_t v75 = v68[153] + v74;
              uint64_t *v64 = v75;
              uint64_t v76 = v68[158] + v75;
              uint64_t *v64 = v76;
            }
          }
          else
          {
            uint64_t v76 = *v64;
          }
          unint64_t v7 = 0xFFFFFFFFLL;
          if (v76) {
            goto LABEL_39;
          }
        }
        else
        {
          if (v50 == 76)
          {
            uint64_t v51 = (void *)re::EvaluationTree::getCallbackData(*(re::EvaluationTree **)(a2 + 8), *(void *)(i + 8));
            uint64_t v52 = v47 + (v8 << 6);
            uint64_t v53 = *(void *)(v52 + 32) + v51[2];
            *(void *)(v52 + 32) = v53;
            uint64_t v54 = v51[5] + v53;
            *(void *)(v52 + 32) = v54;
            uint64_t v55 = v51[8] + v54;
            *(void *)(v52 + 32) = v55;
            uint64_t v56 = v51[11] + v55;
            *(void *)(v52 + 32) = v56;
            uint64_t v57 = v51[14] + v56;
            *(void *)(v52 + 32) = v57;
            uint64_t v58 = v51[17] + v57;
            *(void *)(v52 + 32) = v58;
            uint64_t v59 = v51[20] + v58;
            *(void *)(v52 + 32) = v59;
            uint64_t v60 = v51[23] + v59;
            *(void *)(v52 + 32) = v60;
            uint64_t v61 = 3 * v51[26] + v60;
          }
          else
          {
            uint64_t v61 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v50 + 9);
            uint64_t v52 = v47 + (v8 << 6);
          }
          *(void *)(v52 + 32) = v61;
          if (v61) {
            goto LABEL_39;
          }
        }
      }
LABEL_39:
      ++v8;
    }
    while (v8 != v46);
  }
  unint64_t v77 = *(void *)(*(void *)(a2 + 8) + 1760);
  if (v77)
  {
    unint64_t v8 = 0;
    unint64_t v7 = 0xFFFFFFFFLL;
    do
    {
      if (re::EvaluationDependencyMap::isRegisterUsed(v13, 2u, v8))
      {
        unint64_t v15 = *(void **)(a2 + 72);
        if ((unint64_t)v15 <= v8) {
          goto LABEL_362;
        }
        uint64_t v78 = *(void *)(a2 + 80);
        int64_t v79 = *(void **)(a2 + 8);
        unint64_t i = v78 + (v8 << 6);
        LODWORD(v385) = -1;
        long long v386 = 0uLL;
        *((void *)&v385 + 1) = 0;
        re::EvaluationTree::getRegister<float>(v79, v8, &v385);
        long long v80 = v386;
        *(_OWORD *)unint64_t i = v385;
        *(_OWORD *)(i + 16) = v80;
        uint64_t v81 = *(unsigned int *)i;
        if (v81 == 77)
        {
          uint64_t v93 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](*(void *)(a2 + 8) + 1608, *(void *)(i + 8));
          uint64_t v94 = *(void *)(v93 + 40);
          BOOL v95 = (uint64_t *)(i + 32);
          if (v94)
          {
            uint64_t v96 = v93;
            for (unint64_t i = 0; i != v94; ++i)
            {
              uint64_t v97 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v96, i);
              uint64_t v98 = *v95;
              if (v97[5] != -1) {
                ++v98;
              }
              uint64_t v99 = (void *)*v97;
              uint64_t v100 = v98 + *(void *)(*v97 + 984);
              uint64_t *v95 = v100;
              uint64_t v101 = v99[128] + v100;
              uint64_t *v95 = v101;
              uint64_t v102 = v99[133] + v101;
              uint64_t *v95 = v102;
              uint64_t v103 = v99[138] + v102;
              uint64_t *v95 = v103;
              uint64_t v104 = v99[143] + v103;
              uint64_t *v95 = v104;
              uint64_t v105 = v99[148] + v104;
              uint64_t *v95 = v105;
              uint64_t v106 = v99[153] + v105;
              uint64_t *v95 = v106;
              uint64_t v107 = v99[158] + v106;
              uint64_t *v95 = v107;
            }
          }
          else
          {
            uint64_t v107 = *v95;
          }
          unint64_t v7 = 0xFFFFFFFFLL;
          if (v107) {
            goto LABEL_60;
          }
        }
        else
        {
          if (v81 == 76)
          {
            uint64_t v82 = (void *)re::EvaluationTree::getCallbackData(*(re::EvaluationTree **)(a2 + 8), *(void *)(i + 8));
            uint64_t v83 = v78 + (v8 << 6);
            uint64_t v84 = *(void *)(v83 + 32) + v82[2];
            *(void *)(v83 + 32) = v84;
            uint64_t v85 = v82[5] + v84;
            *(void *)(v83 + 32) = v85;
            uint64_t v86 = v82[8] + v85;
            *(void *)(v83 + 32) = v86;
            uint64_t v87 = v82[11] + v86;
            *(void *)(v83 + 32) = v87;
            uint64_t v88 = v82[14] + v87;
            *(void *)(v83 + 32) = v88;
            uint64_t v89 = v82[17] + v88;
            *(void *)(v83 + 32) = v89;
            uint64_t v90 = v82[20] + v89;
            *(void *)(v83 + 32) = v90;
            uint64_t v91 = v82[23] + v90;
            *(void *)(v83 + 32) = v91;
            uint64_t v92 = 3 * v82[26] + v91;
          }
          else
          {
            uint64_t v92 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v81 + 9);
            uint64_t v83 = v78 + (v8 << 6);
          }
          *(void *)(v83 + 32) = v92;
          if (v92) {
            goto LABEL_60;
          }
        }
      }
LABEL_60:
      ++v8;
    }
    while (v8 != v77);
  }
  unint64_t v108 = *(void *)(*(void *)(a2 + 8) + 1800);
  if (v108)
  {
    unint64_t v8 = 0;
    unint64_t v7 = 0xFFFFFFFFLL;
    do
    {
      if (re::EvaluationDependencyMap::isRegisterUsed(v13, 3u, v8))
      {
        unint64_t v15 = *(void **)(a2 + 96);
        if ((unint64_t)v15 <= v8) {
          goto LABEL_363;
        }
        uint64_t v109 = *(void *)(a2 + 104);
        uint64_t v110 = *(void **)(a2 + 8);
        unint64_t i = v109 + (v8 << 6);
        LODWORD(v385) = -1;
        long long v386 = 0uLL;
        *((void *)&v385 + 1) = 0;
        re::EvaluationTree::getRegister<re::Matrix3x3<float>>(v110, v8, &v385);
        long long v111 = v386;
        *(_OWORD *)unint64_t i = v385;
        *(_OWORD *)(i + 16) = v111;
        uint64_t v112 = *(unsigned int *)i;
        if (v112 == 77)
        {
          uint64_t v124 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](*(void *)(a2 + 8) + 1608, *(void *)(i + 8));
          uint64_t v125 = *(void *)(v124 + 40);
          unint64_t v126 = (uint64_t *)(i + 32);
          if (v125)
          {
            uint64_t v127 = v124;
            for (unint64_t i = 0; i != v125; ++i)
            {
              uint64_t v128 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v127, i);
              uint64_t v129 = *v126;
              if (v128[5] != -1) {
                ++v129;
              }
              uint64_t v130 = (void *)*v128;
              uint64_t v131 = v129 + *(void *)(*v128 + 984);
              uint64_t *v126 = v131;
              uint64_t v132 = v130[128] + v131;
              uint64_t *v126 = v132;
              uint64_t v133 = v130[133] + v132;
              uint64_t *v126 = v133;
              uint64_t v134 = v130[138] + v133;
              uint64_t *v126 = v134;
              uint64_t v135 = v130[143] + v134;
              uint64_t *v126 = v135;
              uint64_t v136 = v130[148] + v135;
              uint64_t *v126 = v136;
              uint64_t v137 = v130[153] + v136;
              uint64_t *v126 = v137;
              uint64_t v138 = v130[158] + v137;
              uint64_t *v126 = v138;
            }
          }
          else
          {
            uint64_t v138 = *v126;
          }
          unint64_t v7 = 0xFFFFFFFFLL;
          if (v138) {
            goto LABEL_81;
          }
        }
        else
        {
          if (v112 == 76)
          {
            uint64_t v113 = (void *)re::EvaluationTree::getCallbackData(*(re::EvaluationTree **)(a2 + 8), *(void *)(i + 8));
            uint64_t v114 = v109 + (v8 << 6);
            uint64_t v115 = *(void *)(v114 + 32) + v113[2];
            *(void *)(v114 + 32) = v115;
            uint64_t v116 = v113[5] + v115;
            *(void *)(v114 + 32) = v116;
            uint64_t v117 = v113[8] + v116;
            *(void *)(v114 + 32) = v117;
            uint64_t v118 = v113[11] + v117;
            *(void *)(v114 + 32) = v118;
            uint64_t v119 = v113[14] + v118;
            *(void *)(v114 + 32) = v119;
            uint64_t v120 = v113[17] + v119;
            *(void *)(v114 + 32) = v120;
            uint64_t v121 = v113[20] + v120;
            *(void *)(v114 + 32) = v121;
            uint64_t v122 = v113[23] + v121;
            *(void *)(v114 + 32) = v122;
            uint64_t v123 = 3 * v113[26] + v122;
          }
          else
          {
            uint64_t v123 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v112 + 9);
            uint64_t v114 = v109 + (v8 << 6);
          }
          *(void *)(v114 + 32) = v123;
          if (v123) {
            goto LABEL_81;
          }
        }
      }
LABEL_81:
      ++v8;
    }
    while (v8 != v108);
  }
  unint64_t v139 = *(void *)(*(void *)(a2 + 8) + 1840);
  if (v139)
  {
    unint64_t v8 = 0;
    unint64_t v7 = 0xFFFFFFFFLL;
    do
    {
      if (re::EvaluationDependencyMap::isRegisterUsed(v13, 4u, v8))
      {
        unint64_t v15 = *(void **)(a2 + 120);
        if ((unint64_t)v15 <= v8) {
          goto LABEL_364;
        }
        uint64_t v140 = *(void *)(a2 + 128);
        uint64_t v141 = *(void **)(a2 + 8);
        unint64_t i = v140 + (v8 << 6);
        LODWORD(v385) = -1;
        long long v386 = 0uLL;
        *((void *)&v385 + 1) = 0;
        re::EvaluationTree::getRegister<re::Matrix4x4<float>>(v141, v8, &v385);
        long long v142 = v386;
        *(_OWORD *)unint64_t i = v385;
        *(_OWORD *)(i + 16) = v142;
        uint64_t v143 = *(unsigned int *)i;
        if (v143 == 77)
        {
          uint64_t v155 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](*(void *)(a2 + 8) + 1608, *(void *)(i + 8));
          uint64_t v156 = *(void *)(v155 + 40);
          unint64_t v157 = (uint64_t *)(i + 32);
          if (v156)
          {
            uint64_t v158 = v155;
            for (unint64_t i = 0; i != v156; ++i)
            {
              v159 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v158, i);
              uint64_t v160 = *v157;
              if (v159[5] != -1) {
                ++v160;
              }
              long long v161 = (void *)*v159;
              uint64_t v162 = v160 + *(void *)(*v159 + 984);
              *unint64_t v157 = v162;
              uint64_t v163 = v161[128] + v162;
              *unint64_t v157 = v163;
              uint64_t v164 = v161[133] + v163;
              *unint64_t v157 = v164;
              uint64_t v165 = v161[138] + v164;
              *unint64_t v157 = v165;
              uint64_t v166 = v161[143] + v165;
              *unint64_t v157 = v166;
              uint64_t v167 = v161[148] + v166;
              *unint64_t v157 = v167;
              uint64_t v168 = v161[153] + v167;
              *unint64_t v157 = v168;
              uint64_t v169 = v161[158] + v168;
              *unint64_t v157 = v169;
            }
          }
          else
          {
            uint64_t v169 = *v157;
          }
          unint64_t v7 = 0xFFFFFFFFLL;
          if (v169) {
            goto LABEL_102;
          }
        }
        else
        {
          if (v143 == 76)
          {
            v144 = (void *)re::EvaluationTree::getCallbackData(*(re::EvaluationTree **)(a2 + 8), *(void *)(i + 8));
            uint64_t v145 = v140 + (v8 << 6);
            uint64_t v146 = *(void *)(v145 + 32) + v144[2];
            *(void *)(v145 + 32) = v146;
            uint64_t v147 = v144[5] + v146;
            *(void *)(v145 + 32) = v147;
            uint64_t v148 = v144[8] + v147;
            *(void *)(v145 + 32) = v148;
            uint64_t v149 = v144[11] + v148;
            *(void *)(v145 + 32) = v149;
            uint64_t v150 = v144[14] + v149;
            *(void *)(v145 + 32) = v150;
            uint64_t v151 = v144[17] + v150;
            *(void *)(v145 + 32) = v151;
            uint64_t v152 = v144[20] + v151;
            *(void *)(v145 + 32) = v152;
            uint64_t v153 = v144[23] + v152;
            *(void *)(v145 + 32) = v153;
            uint64_t v154 = 3 * v144[26] + v153;
          }
          else
          {
            uint64_t v154 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v143 + 9);
            uint64_t v145 = v140 + (v8 << 6);
          }
          *(void *)(v145 + 32) = v154;
          if (v154) {
            goto LABEL_102;
          }
        }
      }
LABEL_102:
      ++v8;
    }
    while (v8 != v139);
  }
  unint64_t v170 = *(void *)(*(void *)(a2 + 8) + 1880);
  if (v170)
  {
    unint64_t v8 = 0;
    unint64_t v7 = 0xFFFFFFFFLL;
    do
    {
      if (re::EvaluationDependencyMap::isRegisterUsed(v13, 5u, v8))
      {
        unint64_t v15 = *(void **)(a2 + 144);
        if ((unint64_t)v15 <= v8) {
          goto LABEL_365;
        }
        uint64_t v171 = *(void *)(a2 + 152);
        uint64_t v172 = *(void **)(a2 + 8);
        unint64_t i = v171 + (v8 << 6);
        LODWORD(v385) = -1;
        long long v386 = 0uLL;
        *((void *)&v385 + 1) = 0;
        re::EvaluationTree::getRegister<re::Quaternion<float>>(v172, v8, &v385);
        long long v173 = v386;
        *(_OWORD *)unint64_t i = v385;
        *(_OWORD *)(i + 16) = v173;
        uint64_t v174 = *(unsigned int *)i;
        if (v174 == 77)
        {
          uint64_t v186 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](*(void *)(a2 + 8) + 1608, *(void *)(i + 8));
          uint64_t v187 = *(void *)(v186 + 40);
          unint64_t v188 = (uint64_t *)(i + 32);
          if (v187)
          {
            uint64_t v189 = v186;
            for (unint64_t i = 0; i != v187; ++i)
            {
              unint64_t v190 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v189, i);
              uint64_t v191 = *v188;
              if (v190[5] != -1) {
                ++v191;
              }
              unint64_t v192 = (void *)*v190;
              uint64_t v193 = v191 + *(void *)(*v190 + 984);
              *unint64_t v188 = v193;
              uint64_t v194 = v192[128] + v193;
              *unint64_t v188 = v194;
              uint64_t v195 = v192[133] + v194;
              *unint64_t v188 = v195;
              uint64_t v196 = v192[138] + v195;
              *unint64_t v188 = v196;
              uint64_t v197 = v192[143] + v196;
              *unint64_t v188 = v197;
              uint64_t v198 = v192[148] + v197;
              *unint64_t v188 = v198;
              uint64_t v199 = v192[153] + v198;
              *unint64_t v188 = v199;
              uint64_t v200 = v192[158] + v199;
              *unint64_t v188 = v200;
            }
          }
          else
          {
            uint64_t v200 = *v188;
          }
          unint64_t v7 = 0xFFFFFFFFLL;
          if (v200) {
            goto LABEL_123;
          }
        }
        else
        {
          if (v174 == 76)
          {
            int v175 = (void *)re::EvaluationTree::getCallbackData(*(re::EvaluationTree **)(a2 + 8), *(void *)(i + 8));
            uint64_t v176 = v171 + (v8 << 6);
            uint64_t v177 = *(void *)(v176 + 32) + v175[2];
            *(void *)(v176 + 32) = v177;
            uint64_t v178 = v175[5] + v177;
            *(void *)(v176 + 32) = v178;
            uint64_t v179 = v175[8] + v178;
            *(void *)(v176 + 32) = v179;
            uint64_t v180 = v175[11] + v179;
            *(void *)(v176 + 32) = v180;
            uint64_t v181 = v175[14] + v180;
            *(void *)(v176 + 32) = v181;
            uint64_t v182 = v175[17] + v181;
            *(void *)(v176 + 32) = v182;
            uint64_t v183 = v175[20] + v182;
            *(void *)(v176 + 32) = v183;
            uint64_t v184 = v175[23] + v183;
            *(void *)(v176 + 32) = v184;
            uint64_t v185 = 3 * v175[26] + v184;
          }
          else
          {
            uint64_t v185 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v174 + 9);
            uint64_t v176 = v171 + (v8 << 6);
          }
          *(void *)(v176 + 32) = v185;
          if (v185) {
            goto LABEL_123;
          }
        }
      }
LABEL_123:
      ++v8;
    }
    while (v8 != v170);
  }
  unint64_t v201 = *(void *)(*(void *)(a2 + 8) + 1920);
  if (v201)
  {
    unint64_t v8 = 0;
    unint64_t v7 = 0xFFFFFFFFLL;
    do
    {
      if (re::EvaluationDependencyMap::isRegisterUsed(v13, 6u, v8))
      {
        unint64_t v15 = *(void **)(a2 + 168);
        if ((unint64_t)v15 <= v8) {
          goto LABEL_366;
        }
        uint64_t v202 = *(void *)(a2 + 176);
        v203 = *(void **)(a2 + 8);
        unint64_t i = v202 + (v8 << 6);
        LODWORD(v385) = -1;
        long long v386 = 0uLL;
        *((void *)&v385 + 1) = 0;
        re::EvaluationTree::getRegister<re::Vector2<float>>(v203, v8, &v385);
        long long v204 = v386;
        *(_OWORD *)unint64_t i = v385;
        *(_OWORD *)(i + 16) = v204;
        uint64_t v205 = *(unsigned int *)i;
        if (v205 == 77)
        {
          uint64_t v217 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](*(void *)(a2 + 8) + 1608, *(void *)(i + 8));
          uint64_t v218 = *(void *)(v217 + 40);
          long long v219 = (uint64_t *)(i + 32);
          if (v218)
          {
            uint64_t v220 = v217;
            for (unint64_t i = 0; i != v218; ++i)
            {
              int v221 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v220, i);
              uint64_t v222 = *v219;
              if (v221[5] != -1) {
                ++v222;
              }
              long long v223 = (void *)*v221;
              uint64_t v224 = v222 + *(void *)(*v221 + 984);
              *long long v219 = v224;
              uint64_t v225 = v223[128] + v224;
              *long long v219 = v225;
              uint64_t v226 = v223[133] + v225;
              *long long v219 = v226;
              uint64_t v227 = v223[138] + v226;
              *long long v219 = v227;
              uint64_t v228 = v223[143] + v227;
              *long long v219 = v228;
              uint64_t v229 = v223[148] + v228;
              *long long v219 = v229;
              uint64_t v230 = v223[153] + v229;
              *long long v219 = v230;
              uint64_t v231 = v223[158] + v230;
              *long long v219 = v231;
            }
          }
          else
          {
            uint64_t v231 = *v219;
          }
          unint64_t v7 = 0xFFFFFFFFLL;
          if (v231) {
            goto LABEL_144;
          }
        }
        else
        {
          if (v205 == 76)
          {
            uint64_t v206 = (void *)re::EvaluationTree::getCallbackData(*(re::EvaluationTree **)(a2 + 8), *(void *)(i + 8));
            uint64_t v207 = v202 + (v8 << 6);
            uint64_t v208 = *(void *)(v207 + 32) + v206[2];
            *(void *)(v207 + 32) = v208;
            uint64_t v209 = v206[5] + v208;
            *(void *)(v207 + 32) = v209;
            uint64_t v210 = v206[8] + v209;
            *(void *)(v207 + 32) = v210;
            uint64_t v211 = v206[11] + v210;
            *(void *)(v207 + 32) = v211;
            uint64_t v212 = v206[14] + v211;
            *(void *)(v207 + 32) = v212;
            uint64_t v213 = v206[17] + v212;
            *(void *)(v207 + 32) = v213;
            uint64_t v214 = v206[20] + v213;
            *(void *)(v207 + 32) = v214;
            uint64_t v215 = v206[23] + v214;
            *(void *)(v207 + 32) = v215;
            uint64_t v216 = 3 * v206[26] + v215;
          }
          else
          {
            uint64_t v216 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v205 + 9);
            uint64_t v207 = v202 + (v8 << 6);
          }
          *(void *)(v207 + 32) = v216;
          if (v216) {
            goto LABEL_144;
          }
        }
      }
LABEL_144:
      ++v8;
    }
    while (v8 != v201);
  }
  unint64_t v232 = *(void *)(*(void *)(a2 + 8) + 1960);
  if (v232)
  {
    unint64_t v8 = 0;
    unint64_t v7 = 0xFFFFFFFFLL;
    do
    {
      if (re::EvaluationDependencyMap::isRegisterUsed(v13, 7u, v8))
      {
        unint64_t v15 = *(void **)(a2 + 192);
        if ((unint64_t)v15 <= v8) {
          goto LABEL_367;
        }
        uint64_t v234 = *(void *)(a2 + 200);
        long long v235 = *(void **)(a2 + 8);
        unint64_t i = v234 + (v8 << 6);
        LODWORD(v385) = -1;
        long long v386 = 0uLL;
        *((void *)&v385 + 1) = 0;
        re::EvaluationTree::getRegister<re::Vector3<float>>(v235, v8, &v385);
        long long v236 = v386;
        *(_OWORD *)unint64_t i = v385;
        *(_OWORD *)(i + 16) = v236;
        uint64_t v237 = *(unsigned int *)i;
        if (v237 == 77)
        {
          uint64_t v249 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](*(void *)(a2 + 8) + 1608, *(void *)(i + 8));
          uint64_t v250 = *(void *)(v249 + 40);
          long long v251 = (uint64_t *)(i + 32);
          if (v250)
          {
            uint64_t v252 = v249;
            for (unint64_t i = 0; i != v250; ++i)
            {
              uint64_t v253 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v252, i);
              uint64_t v254 = *v251;
              if (v253[5] != -1) {
                ++v254;
              }
              uint64_t v255 = (void *)*v253;
              uint64_t v256 = v254 + *(void *)(*v253 + 984);
              *long long v251 = v256;
              uint64_t v257 = v255[128] + v256;
              *long long v251 = v257;
              uint64_t v258 = v255[133] + v257;
              *long long v251 = v258;
              uint64_t v259 = v255[138] + v258;
              *long long v251 = v259;
              uint64_t v260 = v255[143] + v259;
              *long long v251 = v260;
              uint64_t v261 = v255[148] + v260;
              *long long v251 = v261;
              uint64_t v262 = v255[153] + v261;
              *long long v251 = v262;
              uint64_t v263 = v255[158] + v262;
              *long long v251 = v263;
            }
          }
          else
          {
            uint64_t v263 = *v251;
          }
          unint64_t v7 = 0xFFFFFFFFLL;
          if (v263) {
            goto LABEL_165;
          }
        }
        else
        {
          if (v237 == 76)
          {
            long long v238 = (void *)re::EvaluationTree::getCallbackData(*(re::EvaluationTree **)(a2 + 8), *(void *)(i + 8));
            uint64_t v239 = v234 + (v8 << 6);
            uint64_t v240 = *(void *)(v239 + 32) + v238[2];
            *(void *)(v239 + 32) = v240;
            uint64_t v241 = v238[5] + v240;
            *(void *)(v239 + 32) = v241;
            uint64_t v242 = v238[8] + v241;
            *(void *)(v239 + 32) = v242;
            uint64_t v243 = v238[11] + v242;
            *(void *)(v239 + 32) = v243;
            uint64_t v244 = v238[14] + v243;
            *(void *)(v239 + 32) = v244;
            uint64_t v245 = v238[17] + v244;
            *(void *)(v239 + 32) = v245;
            uint64_t v246 = v238[20] + v245;
            *(void *)(v239 + 32) = v246;
            uint64_t v247 = v238[23] + v246;
            *(void *)(v239 + 32) = v247;
            uint64_t v248 = 3 * v238[26] + v247;
          }
          else
          {
            uint64_t v248 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v237 + 9);
            uint64_t v239 = v234 + (v8 << 6);
          }
          *(void *)(v239 + 32) = v248;
          if (v248) {
            goto LABEL_165;
          }
        }
      }
LABEL_165:
      ++v8;
    }
    while (v8 != v232);
  }
  uint64_t result = *(re::Allocator **)a2;
  uint64_t v265 = *(void *)(a2 + 8);
  unint64_t v266 = *(void *)(v265 + 2000);
  *(void *)(a2 + 208) = *(void *)a2;
  *(void *)(a2 + 216) = v266;
  if (v266)
  {
    long long v267 = v377;
    uint64_t v268 = 904;
    if (v266 >= 0x487EDE0487EDE1)
    {
LABEL_397:
      re::internal::assertLog((re::internal *)6, v233, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, v268, v266);
      _os_crash();
      __break(1u);
      goto LABEL_398;
    }
    uint64_t v269 = (*(uint64_t (**)(re::Allocator *, unint64_t, uint64_t))(*(void *)result + 32))(result, 904 * v266, 8);
    *(void *)(a2 + 224) = v269;
    if (!v269)
    {
LABEL_398:
      re::internal::assertLog((re::internal *)4, v270, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
      goto LABEL_399;
    }
    long long v271 = (void *)v269;
    unint64_t v272 = v266 - 1;
    if (v266 != 1)
    {
      do
      {
        bzero(v271, 0x380uLL);
        v271[112] = -1;
        v271 += 113;
        --v272;
      }
      while (v272);
    }
    long long v273 = v271 + 112;
    bzero(v271, 0x380uLL);
    unint64_t v15 = 0;
    unint64_t v13 = 0;
    *long long v273 = -1;
    do
    {
      long long v274 = (const re::EvaluationCallbackData *)re::EvaluationTree::getCallbackData(*(re::EvaluationTree **)(a2 + 8), v13);
      unint64_t i = *(void *)(a2 + 216);
      if (i <= v13) {
        goto LABEL_359;
      }
      re::EvaluationTree::resolveAliasRegisters(*(re::EvaluationTree **)(a2 + 8), *(re::Allocator **)a2, v274, (re::EvaluationCallbackData *)((char *)v15 + *(void *)(a2 + 224)));
      ++v13;
      v15 += 113;
    }
    while (v266 != v13);
    uint64_t result = *(re::Allocator **)a2;
    uint64_t v265 = *(void *)(a2 + 8);
  }
  else
  {
    long long v267 = v377;
  }
  unint64_t i = *(void *)(v265 + 1648);
  *(void *)(a2 + 232) = result;
  *(void *)(a2 + 240) = i;
  if (!i)
  {
LABEL_209:
    if (!a3[1])
    {
LABEL_213:
      if (!a3[3])
      {
LABEL_217:
        if (!a3[5])
        {
LABEL_221:
          if (!a3[7])
          {
LABEL_225:
            if (!a3[9])
            {
LABEL_229:
              if (!a3[11])
              {
LABEL_233:
                if (!a3[13])
                {
LABEL_237:
                  if (!a3[15])
                  {
LABEL_241:
                    if (!a3[17])
                    {
LABEL_249:
                      uint64_t v311 = *(void *)(a2 + 3800);
                      if (v311)
                      {
                        unint64_t i = 40;
                        do
                        {
                          uint64_t v312 = v311 - 1;
                          int v396 = *(_DWORD *)(*(void *)(a2 + 3816) + 4 * v312);
                          unsigned int v313 = v396;
                          *(void *)(a2 + 3800) = v312;
                          ++*(_DWORD *)(a2 + 3808);
                          uint64_t v314 = a2 + 40 * v313;
                          uint64_t v315 = *(void *)(v314 + 680);
                          if (v315)
                          {
                            unint64_t v7 = v267[2];
                            v316 = (uint64_t *)(v314 + 680);
                            v317 = (void *)(a2 + 40 * v313 + 696);
                            if (v313 - 78 >= 0xFFFFFFFE)
                            {
                              v321 = (_DWORD *)(a2 + 40 * v313 + 688);
                              while (2)
                              {
                                uint64_t v322 = v315 - 1;
                                v323 = (unsigned __int8 *)(*v317 + 16 * v322);
                                uint64_t v324 = *v323;
                                unint64_t v325 = *((void *)v323 + 1);
                                uint64_t *v316 = v322;
                                ++*v321;
                                switch((int)v324)
                                {
                                  case 0:
                                    goto LABEL_267;
                                  case 1:
                                    goto LABEL_267;
                                  case 2:
                                    goto LABEL_267;
                                  case 3:
                                    goto LABEL_267;
                                  case 4:
                                    goto LABEL_267;
                                  case 5:
                                    goto LABEL_267;
                                  case 6:
                                    goto LABEL_267;
                                  case 7:
LABEL_267:
                                    uint64_t v315 = *v316;
                                    if (!*v316) {
                                      goto LABEL_268;
                                    }
                                    continue;
                                  default:
                                    goto LABEL_401;
                                }
                              }
                            }
                            switch(*(unsigned char *)(*v317 + 16 * v315 - 16))
                            {
                              case 0:
                                v318 = (_DWORD *)(a2 + 40 * v313 + 688);
                                do
                                {
                                  uint64_t v319 = v315 - 1;
                                  unint64_t v320 = *(void *)(*v317 + 16 * v319 + 8);
                                  uint64_t *v316 = v319;
                                  ++*v318;
                                  uint64_t v315 = *v316;
                                }
                                while (*v316);
                                break;
                              case 1:
                                v328 = (_DWORD *)(a2 + 40 * v313 + 688);
                                do
                                {
                                  uint64_t v329 = v315 - 1;
                                  unint64_t v330 = *(void *)(*v317 + 16 * v329 + 8);
                                  uint64_t *v316 = v329;
                                  ++*v328;
                                  uint64_t v315 = *v316;
                                }
                                while (*v316);
                                break;
                              case 2:
                                v331 = (_DWORD *)(a2 + 40 * v313 + 688);
                                do
                                {
                                  uint64_t v332 = v315 - 1;
                                  unint64_t v333 = *(void *)(*v317 + 16 * v332 + 8);
                                  uint64_t *v316 = v332;
                                  ++*v331;
                                  uint64_t v315 = *v316;
                                }
                                while (*v316);
                                break;
                              case 3:
                                v334 = (_DWORD *)(a2 + 40 * v313 + 688);
                                do
                                {
                                  uint64_t v335 = v315 - 1;
                                  unint64_t v336 = *(void *)(*v317 + 16 * v335 + 8);
                                  uint64_t *v316 = v335;
                                  ++*v334;
                                  uint64_t v315 = *v316;
                                }
                                while (*v316);
                                break;
                              case 4:
                                v337 = (_DWORD *)(a2 + 40 * v313 + 688);
                                do
                                {
                                  uint64_t v338 = v315 - 1;
                                  unint64_t v339 = *(void *)(*v317 + 16 * v338 + 8);
                                  uint64_t *v316 = v338;
                                  ++*v337;
                                  uint64_t v315 = *v316;
                                }
                                while (*v316);
                                break;
                              case 5:
                                v340 = (_DWORD *)(a2 + 40 * v313 + 688);
                                do
                                {
                                  uint64_t v341 = v315 - 1;
                                  unint64_t v342 = *(void *)(*v317 + 16 * v341 + 8);
                                  uint64_t *v316 = v341;
                                  ++*v340;
                                  uint64_t v315 = *v316;
                                }
                                while (*v316);
                                break;
                              case 6:
                                v343 = (_DWORD *)(a2 + 40 * v313 + 688);
                                do
                                {
                                  uint64_t v344 = v315 - 1;
                                  unint64_t v345 = *(void *)(*v317 + 16 * v344 + 8);
                                  uint64_t *v316 = v344;
                                  ++*v343;
                                  uint64_t v315 = *v316;
                                }
                                while (*v316);
                                break;
                              case 7:
                                v346 = (_DWORD *)(a2 + 40 * v313 + 688);
                                do
                                {
                                  uint64_t v347 = v315 - 1;
                                  unint64_t v348 = *(void *)(*v317 + 16 * v347 + 8);
                                  uint64_t *v316 = v347;
                                  ++*v346;
                                  uint64_t v315 = *v316;
                                }
                                while (*v316);
                                break;
                              default:
                                re::internal::assertLog((re::internal *)5, v233, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processEvaluationTree", 1088, *(unsigned __int8 *)(*v317 + 16 * v315 - 16));
                                _os_crash();
                                __break(1u);
                                JUMPOUT(0x233287458);
                            }
LABEL_268:
                            uint64_t v326 = v267[2];
                            uint64_t v327 = v326 - v7;
                            if (v326 != v7)
                            {
                              re::DynamicArray<re::EvaluationCommand>::add(a4, &v396);
                              *(void *)&long long v385 = v327;
                              uint64_t result = (re::Allocator *)re::DynamicArray<unsigned long>::add(a5, &v385);
                            }
                          }
                          uint64_t v311 = *(void *)(a2 + 3800);
                        }
                        while (v311);
                      }
                      goto LABEL_294;
                    }
                    unint64_t v15 = 0;
                    unint64_t v306 = 0;
                    unint64_t i = 1;
                    while (1)
                    {
                      unint64_t v13 = *(void *)((char *)v15 + a3[16]);
                      unint64_t v7 = *(void *)(a2 + 192);
                      if (v7 <= v13) {
                        goto LABEL_376;
                      }
                      *(unsigned char *)(*(void *)(a2 + 200) + (v13 << 6) + 40) = 1;
                      unint64_t v308 = a3[17];
                      if (v308 <= v306) {
                        goto LABEL_377;
                      }
                      unint64_t v13 = *(void *)((char *)v15 + a3[16] + 8);
                      unint64_t v7 = *(void *)(a2 + 144);
                      if (v7 <= v13) {
                        goto LABEL_378;
                      }
                      *(unsigned char *)(*(void *)(a2 + 152) + (v13 << 6) + 40) = 1;
                      unint64_t v310 = a3[17];
                      if (v310 <= v306) {
                        goto LABEL_379;
                      }
                      unint64_t v13 = *(void *)((char *)v15 + a3[16] + 16);
                      unint64_t v7 = *(void *)(a2 + 192);
                      if (v7 <= v13) {
                        goto LABEL_380;
                      }
                      *(unsigned char *)(*(void *)(a2 + 200) + (v13 << 6) + 40) = 1;
                      ++v306;
                      v15 += 3;
                      if (v306 >= a3[17]) {
                        goto LABEL_249;
                      }
                    }
                  }
                  uint64_t v305 = 0;
                  unint64_t i = 1;
                  while (1)
                  {
                    unint64_t v13 = *(void *)(a3[14] + 8 * v305);
                    unint64_t v15 = *(void **)(a2 + 192);
                    if ((unint64_t)v15 <= v13) {
                      break;
                    }
                    *(unsigned char *)(*(void *)(a2 + 200) + (v13 << 6) + 40) = 1;
                    if ((unint64_t)++v305 >= a3[15]) {
                      goto LABEL_241;
                    }
                  }
LABEL_375:
                  uint64_t v384 = 0;
                  long long v388 = 0u;
                  long long v389 = 0u;
                  long long v386 = 0u;
                  long long v387 = 0u;
                  long long v385 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v396 = 136315906;
                  v397 = "operator[]";
                  __int16 v398 = 1024;
                  int v399 = 468;
                  __int16 v400 = 2048;
                  unint64_t v401 = v13;
                  __int16 v402 = 2048;
                  v403 = v15;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_376:
                  uint64_t v384 = 0;
                  long long v388 = 0u;
                  long long v389 = 0u;
                  long long v386 = 0u;
                  long long v387 = 0u;
                  long long v385 = 0u;
                  unint64_t v306 = &_os_log_internal;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v396 = 136315906;
                  v397 = "operator[]";
                  __int16 v398 = 1024;
                  int v399 = 468;
                  __int16 v400 = 2048;
                  unint64_t v401 = v13;
                  __int16 v402 = 2048;
                  v403 = (void *)v7;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_377:
                  re::internal::assertLog((re::internal *)6, v307, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v306, v308);
                  _os_crash();
                  __break(1u);
LABEL_378:
                  uint64_t v384 = 0;
                  long long v388 = 0u;
                  long long v389 = 0u;
                  long long v386 = 0u;
                  long long v387 = 0u;
                  long long v385 = 0u;
                  unint64_t v306 = &_os_log_internal;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v396 = 136315906;
                  v397 = "operator[]";
                  __int16 v398 = 1024;
                  int v399 = 468;
                  __int16 v400 = 2048;
                  unint64_t v401 = v13;
                  __int16 v402 = 2048;
                  v403 = (void *)v7;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_379:
                  re::internal::assertLog((re::internal *)6, v309, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v306, v310);
                  _os_crash();
                  __break(1u);
LABEL_380:
                  uint64_t v384 = 0;
                  long long v388 = 0u;
                  long long v389 = 0u;
                  long long v386 = 0u;
                  long long v387 = 0u;
                  long long v385 = 0u;
                  unint64_t v266 = &_os_log_internal;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v396 = 136315906;
                  v397 = "operator[]";
                  __int16 v398 = 1024;
                  int v399 = 468;
                  __int16 v400 = 2048;
                  unint64_t v401 = v13;
                  __int16 v402 = 2048;
                  v403 = (void *)v7;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_381:
                  re::internal::assertLog((re::internal *)6, v365, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v367);
                  _os_crash();
                  __break(1u);
LABEL_382:
                  re::internal::assertLog((re::internal *)6, v368, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v370);
                  _os_crash();
                  __break(1u);
LABEL_383:
                  uint64_t v384 = 0;
                  long long v388 = 0u;
                  long long v389 = 0u;
                  long long v386 = 0u;
                  long long v387 = 0u;
                  long long v385 = 0u;
                  unint64_t v266 = &_os_log_internal;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v396 = 136315906;
                  v397 = "operator[]";
                  __int16 v398 = 1024;
                  int v399 = 468;
                  __int16 v400 = 2048;
                  unint64_t v401 = v7;
                  __int16 v402 = 2048;
                  v403 = v15;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_384:
                  re::internal::assertLog((re::internal *)6, v349, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v350);
                  _os_crash();
                  __break(1u);
LABEL_385:
                  re::internal::assertLog((re::internal *)6, v351, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v352);
                  _os_crash();
                  __break(1u);
LABEL_386:
                  re::internal::assertLog((re::internal *)6, v353, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v354);
                  _os_crash();
                  __break(1u);
LABEL_387:
                  re::internal::assertLog((re::internal *)6, v355, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v356);
                  _os_crash();
                  __break(1u);
LABEL_388:
                  re::internal::assertLog((re::internal *)6, v357, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v358);
                  _os_crash();
                  __break(1u);
LABEL_389:
                  re::internal::assertLog((re::internal *)6, v359, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v360);
                  _os_crash();
                  __break(1u);
LABEL_390:
                  re::internal::assertLog((re::internal *)6, v361, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v362);
                  _os_crash();
                  __break(1u);
LABEL_391:
                  re::internal::assertLog((re::internal *)6, v363, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v364);
                  _os_crash();
                  __break(1u);
LABEL_392:
                  re::internal::assertLog((re::internal *)6, v365, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v366);
                  _os_crash();
                  __break(1u);
LABEL_393:
                  re::internal::assertLog((re::internal *)6, v368, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v369);
                  _os_crash();
                  __break(1u);
LABEL_394:
                  re::internal::assertLog((re::internal *)6, v371, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v266, v372);
                  _os_crash();
                  __break(1u);
LABEL_395:
                  re::internal::assertLog((re::internal *)6, v233, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 200, i);
                  _os_crash();
                  __break(1u);
                  goto LABEL_396;
                }
                uint64_t v304 = 0;
                unint64_t i = 1;
                while (1)
                {
                  unint64_t v13 = *(void *)(a3[12] + 8 * v304);
                  unint64_t v15 = *(void **)(a2 + 168);
                  if ((unint64_t)v15 <= v13) {
                    break;
                  }
                  *(unsigned char *)(*(void *)(a2 + 176) + (v13 << 6) + 40) = 1;
                  if ((unint64_t)++v304 >= a3[13]) {
                    goto LABEL_237;
                  }
                }
LABEL_374:
                uint64_t v384 = 0;
                long long v388 = 0u;
                long long v389 = 0u;
                long long v386 = 0u;
                long long v387 = 0u;
                long long v385 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                int v396 = 136315906;
                v397 = "operator[]";
                __int16 v398 = 1024;
                int v399 = 468;
                __int16 v400 = 2048;
                unint64_t v401 = v13;
                __int16 v402 = 2048;
                v403 = v15;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_375;
              }
              uint64_t v303 = 0;
              unint64_t i = 1;
              while (1)
              {
                unint64_t v13 = *(void *)(a3[10] + 8 * v303);
                unint64_t v15 = *(void **)(a2 + 144);
                if ((unint64_t)v15 <= v13) {
                  break;
                }
                *(unsigned char *)(*(void *)(a2 + 152) + (v13 << 6) + 40) = 1;
                if ((unint64_t)++v303 >= a3[11]) {
                  goto LABEL_233;
                }
              }
LABEL_373:
              uint64_t v384 = 0;
              long long v388 = 0u;
              long long v389 = 0u;
              long long v386 = 0u;
              long long v387 = 0u;
              long long v385 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v396 = 136315906;
              v397 = "operator[]";
              __int16 v398 = 1024;
              int v399 = 468;
              __int16 v400 = 2048;
              unint64_t v401 = v13;
              __int16 v402 = 2048;
              v403 = v15;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_374;
            }
            uint64_t v302 = 0;
            unint64_t i = 1;
            while (1)
            {
              unint64_t v13 = *(void *)(a3[8] + 8 * v302);
              unint64_t v15 = *(void **)(a2 + 120);
              if ((unint64_t)v15 <= v13) {
                break;
              }
              *(unsigned char *)(*(void *)(a2 + 128) + (v13 << 6) + 40) = 1;
              if ((unint64_t)++v302 >= a3[9]) {
                goto LABEL_229;
              }
            }
LABEL_372:
            uint64_t v384 = 0;
            long long v388 = 0u;
            long long v389 = 0u;
            long long v386 = 0u;
            long long v387 = 0u;
            long long v385 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v396 = 136315906;
            v397 = "operator[]";
            __int16 v398 = 1024;
            int v399 = 468;
            __int16 v400 = 2048;
            unint64_t v401 = v13;
            __int16 v402 = 2048;
            v403 = v15;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_373;
          }
          uint64_t v301 = 0;
          unint64_t i = 1;
          while (1)
          {
            unint64_t v13 = *(void *)(a3[6] + 8 * v301);
            unint64_t v15 = *(void **)(a2 + 96);
            if ((unint64_t)v15 <= v13) {
              break;
            }
            *(unsigned char *)(*(void *)(a2 + 104) + (v13 << 6) + 40) = 1;
            if ((unint64_t)++v301 >= a3[7]) {
              goto LABEL_225;
            }
          }
LABEL_371:
          uint64_t v384 = 0;
          long long v388 = 0u;
          long long v389 = 0u;
          long long v386 = 0u;
          long long v387 = 0u;
          long long v385 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v396 = 136315906;
          v397 = "operator[]";
          __int16 v398 = 1024;
          int v399 = 468;
          __int16 v400 = 2048;
          unint64_t v401 = v13;
          __int16 v402 = 2048;
          v403 = v15;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_372;
        }
        uint64_t v300 = 0;
        unint64_t i = 1;
        while (1)
        {
          unint64_t v13 = *(void *)(a3[4] + 8 * v300);
          unint64_t v15 = *(void **)(a2 + 72);
          if ((unint64_t)v15 <= v13) {
            break;
          }
          *(unsigned char *)(*(void *)(a2 + 80) + (v13 << 6) + 40) = 1;
          if ((unint64_t)++v300 >= a3[5]) {
            goto LABEL_221;
          }
        }
LABEL_370:
        uint64_t v384 = 0;
        long long v388 = 0u;
        long long v389 = 0u;
        long long v386 = 0u;
        long long v387 = 0u;
        long long v385 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v396 = 136315906;
        v397 = "operator[]";
        __int16 v398 = 1024;
        int v399 = 468;
        __int16 v400 = 2048;
        unint64_t v401 = v13;
        __int16 v402 = 2048;
        v403 = v15;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_371;
      }
      uint64_t v299 = 0;
      unint64_t i = 1;
      while (1)
      {
        unint64_t v13 = *(void *)(a3[2] + 8 * v299);
        unint64_t v15 = *(void **)(a2 + 48);
        if ((unint64_t)v15 <= v13) {
          break;
        }
        *(unsigned char *)(*(void *)(a2 + 56) + (v13 << 6) + 40) = 1;
        if ((unint64_t)++v299 >= a3[3]) {
          goto LABEL_217;
        }
      }
LABEL_369:
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v13;
      __int16 v402 = 2048;
      v403 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_370;
    }
    uint64_t v298 = 0;
    unint64_t i = 1;
    while (1)
    {
      unint64_t v13 = *(void *)(*a3 + 8 * v298);
      unint64_t v15 = *(void **)(a2 + 24);
      if ((unint64_t)v15 <= v13) {
        break;
      }
      *(unsigned char *)(*(void *)(a2 + 32) + (v13 << 6) + 40) = 1;
      if ((unint64_t)++v298 >= a3[1]) {
        goto LABEL_213;
      }
    }
LABEL_368:
    uint64_t v384 = 0;
    long long v388 = 0u;
    long long v389 = 0u;
    long long v386 = 0u;
    long long v387 = 0u;
    long long v385 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v396 = 136315906;
    v397 = "operator[]";
    __int16 v398 = 1024;
    int v399 = 468;
    __int16 v400 = 2048;
    unint64_t v401 = v13;
    __int16 v402 = 2048;
    v403 = v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_369;
  }
  if (i >= 0x108421084210843)
  {
LABEL_399:
    re::internal::assertLog((re::internal *)6, v233, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 248, i);
    _os_crash();
    __break(1u);
    goto LABEL_400;
  }
  uint64_t v275 = (*(uint64_t (**)(re::Allocator *, unint64_t, uint64_t))(*(void *)result + 32))(result, 248 * i, 8);
  *(void *)(a2 + 248) = v275;
  if (!v275)
  {
LABEL_400:
    re::internal::assertLog((re::internal *)4, v276, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
LABEL_401:
    re::internal::assertLog((re::internal *)5, v325, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processEvaluationTree", 1097, v324);
    _os_crash();
    __break(1u);
  }
  unint64_t v277 = i - 1;
  if (i != 1)
  {
    do
    {
      *(_OWORD *)(v275 + 208) = 0uLL;
      *(_OWORD *)(v275 + 224) = 0uLL;
      *(_OWORD *)(v275 + 176) = 0uLL;
      *(_OWORD *)(v275 + 192) = 0uLL;
      *(_OWORD *)(v275 + 144) = 0uLL;
      *(_OWORD *)(v275 + 160) = 0uLL;
      *(_OWORD *)(v275 + 112) = 0uLL;
      *(_OWORD *)(v275 + 128) = 0uLL;
      *(_OWORD *)(v275 + 80) = 0uLL;
      *(_OWORD *)(v275 + 96) = 0uLL;
      *(_OWORD *)(v275 + 48) = 0uLL;
      *(_OWORD *)(v275 + 64) = 0uLL;
      *(_OWORD *)(v275 + 16) = 0uLL;
      *(_OWORD *)(v275 + 32) = 0uLL;
      *(_OWORD *)uint64_t v275 = 0uLL;
      *(void *)(v275 + 240) = -1;
      v275 += 248;
      --v277;
    }
    while (v277);
  }
  unint64_t v7 = 0;
  *(_OWORD *)(v275 + 208) = 0u;
  *(_OWORD *)(v275 + 224) = 0u;
  *(_OWORD *)(v275 + 176) = 0u;
  *(_OWORD *)(v275 + 192) = 0u;
  *(_OWORD *)(v275 + 144) = 0u;
  *(_OWORD *)(v275 + 160) = 0u;
  *(_OWORD *)(v275 + 112) = 0u;
  *(_OWORD *)(v275 + 128) = 0u;
  *(_OWORD *)(v275 + 80) = 0u;
  *(_OWORD *)(v275 + 96) = 0u;
  *(_OWORD *)(v275 + 48) = 0u;
  *(_OWORD *)(v275 + 64) = 0u;
  *(_OWORD *)(v275 + 16) = 0u;
  *(_OWORD *)(v275 + 32) = 0u;
  *(_OWORD *)uint64_t v275 = 0u;
  unint64_t v266 = 200;
  *(void *)(v275 + 240) = -1;
  unint64_t v376 = i;
  while (1)
  {
    uint64_t v278 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](*(void *)(a2 + 8) + 1608, v7);
    unint64_t v15 = *(void **)(a2 + 240);
    if ((unint64_t)v15 <= v7) {
      goto LABEL_383;
    }
    unint64_t v8 = v278;
    unint64_t v378 = v7;
    unint64_t v15 = (void *)(*(void *)(a2 + 248) + 248 * v7);
    unint64_t i = *(void *)(v278 + 40);
    uint64_t result = *(re::Allocator **)a2;
    *unint64_t v15 = *(void *)a2;
    v15[1] = i;
    if (i) {
      break;
    }
LABEL_208:
    long long v267 = v377;
    unint64_t v7 = v378 + 1;
    unint64_t i = v376;
    if (v378 + 1 == v376) {
      goto LABEL_209;
    }
  }
  if (i >= 0x147AE147AE147AFLL) {
    goto LABEL_395;
  }
  v279 = (void *)(*(uint64_t (**)(re::Allocator *, unint64_t, uint64_t))(*(void *)result + 32))(result, 200 * i, 8);
  void v15[2] = v279;
  if (!v279)
  {
LABEL_396:
    re::internal::assertLog((re::internal *)4, v280, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    goto LABEL_397;
  }
  unint64_t v281 = i - 1;
  if (i == 1)
  {
    void *v279 = -1;
    __int16 v282 = v279 + 1;
  }
  else
  {
    __int16 v282 = v279 + 1;
    do
    {
      *((void *)v282 - 1) = -1;
      *__int16 v282 = 0uLL;
      v282[1] = 0uLL;
      v282[2] = 0uLL;
      v282[3] = 0uLL;
      v282[4] = 0uLL;
      v282[5] = 0uLL;
      v282[6] = 0uLL;
      v282[7] = 0uLL;
      v282[8] = 0uLL;
      v282[9] = 0uLL;
      v282[10] = 0uLL;
      v282[11] = 0uLL;
      __int16 v282 = (_OWORD *)((char *)v282 + 200);
      --v281;
    }
    while (v281);
    *((void *)v282 - 1) = -1;
  }
  unint64_t v283 = 0;
  v282[10] = 0uLL;
  v282[11] = 0uLL;
  v282[8] = 0uLL;
  v282[9] = 0uLL;
  v282[6] = 0uLL;
  v282[7] = 0uLL;
  v282[4] = 0uLL;
  v282[5] = 0uLL;
  v282[2] = 0uLL;
  v282[3] = 0uLL;
  *__int16 v282 = 0uLL;
  v282[1] = 0uLL;
  while (1)
  {
    __int16 v284 = (void *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v8, v283);
    unint64_t v7 = v15[1];
    if (v7 <= v283)
    {
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v283;
      __int16 v402 = 2048;
      v403 = (void *)v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_359:
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v13;
      __int16 v402 = 2048;
      v403 = (void *)i;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_360:
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v8;
      __int16 v402 = 2048;
      v403 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_361:
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v8;
      __int16 v402 = 2048;
      v403 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_362:
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v8;
      __int16 v402 = 2048;
      v403 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_363:
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v8;
      __int16 v402 = 2048;
      v403 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_364:
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v8;
      __int16 v402 = 2048;
      v403 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_365:
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v8;
      __int16 v402 = 2048;
      v403 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_366:
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v8;
      __int16 v402 = 2048;
      v403 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_367:
      uint64_t v384 = 0;
      long long v388 = 0u;
      long long v389 = 0u;
      long long v386 = 0u;
      long long v387 = 0u;
      long long v385 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v396 = 136315906;
      v397 = "operator[]";
      __int16 v398 = 1024;
      int v399 = 468;
      __int16 v400 = 2048;
      unint64_t v401 = v8;
      __int16 v402 = 2048;
      v403 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_368;
    }
    uint64_t v285 = v15[2];
    uint64_t v286 = v284[5];
    if (v286 != -1) {
      break;
    }
LABEL_207:
    long long v288 = (void *)*v284;
    uint64_t v289 = *(void *)(*v284 + 1304);
    *(void *)&long long v385 = *(void *)(*v284 + 1320);
    *((void *)&v385 + 1) = v289;
    uint64_t v290 = v288[168];
    *(void *)&long long v386 = v288[170];
    *((void *)&v386 + 1) = v290;
    uint64_t v291 = v288[173];
    *(void *)&long long v387 = v288[175];
    *((void *)&v387 + 1) = v291;
    uint64_t v292 = v288[178];
    *(void *)&long long v388 = v288[180];
    *((void *)&v388 + 1) = v292;
    uint64_t v293 = v288[183];
    *(void *)&long long v389 = v288[185];
    *((void *)&v389 + 1) = v293;
    uint64_t v294 = v288[188];
    uint64_t v390 = v288[190];
    uint64_t v391 = v294;
    uint64_t v295 = v288[193];
    uint64_t v392 = v288[195];
    uint64_t v393 = v295;
    uint64_t v296 = v288[200];
    uint64_t v297 = v288[198];
    uint64_t v394 = v296;
    uint64_t v395 = v297;
    uint64_t result = (re::Allocator *)re::EvaluationTree::resolveAliasRegisters(*(void *)(a2 + 8), *(void *)a2, (uint64_t *)&v385, (void *)(v285 + 200 * v283++ + 8));
    if (v283 == i) {
      goto LABEL_208;
    }
  }
  unint64_t v7 = v286 - 0x7FFFFFFFFFFFFFFFLL;
  if (v286 - 0x7FFFFFFFFFFFFFFFLL < 0)
  {
LABEL_206:
    *(void *)(v285 + 200 * v283) = v286;
    goto LABEL_207;
  }
  uint64_t v287 = *(void *)(a2 + 8);
  unint64_t v13 = *(void *)(v287 + 704);
  while (v13 > v7)
  {
    uint64_t v286 = *(void *)(*(void *)(v287 + 720) + 8 * v7);
    unint64_t v7 = v286 - 0x7FFFFFFFFFFFFFFFLL;
    if (v286 - 0x7FFFFFFFFFFFFFFFLL < 0) {
      goto LABEL_206;
    }
  }
  uint64_t v384 = 0;
  long long v388 = 0u;
  long long v389 = 0u;
  long long v386 = 0u;
  long long v387 = 0u;
  long long v385 = 0u;
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  int v396 = 136315906;
  v397 = "operator[]";
  __int16 v398 = 1024;
  int v399 = 797;
  __int16 v400 = 2048;
  unint64_t v401 = v7;
  __int16 v402 = 2048;
  v403 = (void *)v13;
  _os_log_send_and_compose_impl();
  uint64_t result = (re::Allocator *)_os_crash_msg();
  __break(1u);
LABEL_294:
  if (a3[19])
  {
    unint64_t v266 = 0;
    do
    {
      if ((*((unsigned char *)result + 40) & 0xFE) == 2)
      {
        unint64_t v350 = a3[19];
        if (v350 <= v266) {
          goto LABEL_384;
        }
      }
      ++v266;
    }
    while (v266 < a3[19]);
  }
  if (a3[21])
  {
    unint64_t v266 = 0;
    do
    {
      if ((*((unsigned char *)result + 40) & 0xFE) == 2)
      {
        unint64_t v352 = a3[21];
        if (v352 <= v266) {
          goto LABEL_385;
        }
      }
      ++v266;
    }
    while (v266 < a3[21]);
  }
  if (a3[23])
  {
    unint64_t v266 = 0;
    do
    {
      if ((*((unsigned char *)result + 40) & 0xFE) == 2)
      {
        unint64_t v354 = a3[23];
        if (v354 <= v266) {
          goto LABEL_386;
        }
      }
      ++v266;
    }
    while (v266 < a3[23]);
  }
  if (a3[25])
  {
    unint64_t v266 = 0;
    do
    {
      if ((*((unsigned char *)result + 40) & 0xFE) == 2)
      {
        unint64_t v356 = a3[25];
        if (v356 <= v266) {
          goto LABEL_387;
        }
      }
      ++v266;
    }
    while (v266 < a3[25]);
  }
  if (a3[27])
  {
    unint64_t v266 = 0;
    do
    {
      if ((*((unsigned char *)result + 40) & 0xFE) == 2)
      {
        unint64_t v358 = a3[27];
        if (v358 <= v266) {
          goto LABEL_388;
        }
      }
      ++v266;
    }
    while (v266 < a3[27]);
  }
  if (a3[29])
  {
    unint64_t v266 = 0;
    do
    {
      if ((*((unsigned char *)result + 40) & 0xFE) == 2)
      {
        unint64_t v360 = a3[29];
        if (v360 <= v266) {
          goto LABEL_389;
        }
      }
      ++v266;
    }
    while (v266 < a3[29]);
  }
  if (a3[31])
  {
    unint64_t v266 = 0;
    do
    {
      if ((*((unsigned char *)result + 40) & 0xFE) == 2)
      {
        unint64_t v362 = a3[31];
        if (v362 <= v266) {
          goto LABEL_390;
        }
      }
      ++v266;
    }
    while (v266 < a3[31]);
  }
  if (a3[33])
  {
    unint64_t v266 = 0;
    do
    {
      if ((*((unsigned char *)result + 40) & 0xFE) == 2)
      {
        unint64_t v364 = a3[33];
        if (v364 <= v266) {
          goto LABEL_391;
        }
      }
      ++v266;
    }
    while (v266 < a3[33]);
  }
  if (a3[35])
  {
    unint64_t v15 = 0;
    unint64_t v266 = 0;
    do
    {
      {
        unint64_t v366 = a3[35];
        if (v366 <= v266) {
          goto LABEL_392;
        }
      }
      unint64_t v367 = a3[35];
      if (v367 <= v266) {
        goto LABEL_381;
      }
      {
        unint64_t v369 = a3[35];
        if (v369 <= v266) {
          goto LABEL_393;
        }
      }
      unint64_t v370 = a3[35];
      if (v370 <= v266) {
        goto LABEL_382;
      }
      if ((*((unsigned char *)result + 40) & 0xFE) == 2)
      {
        unint64_t v372 = a3[35];
        if (v372 <= v266) {
          goto LABEL_394;
        }
      }
      ++v266;
      v15 += 3;
    }
    while (v266 < a3[35]);
  }
  unsigned char *v373 = 1;
  if (!v379[0]) {
    goto LABEL_180;
  }
  return result;
}

void re::FixedArray<re::EvaluationCommand>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  if (!a3) {
    return;
  }
  if (a3 >> 62)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 4, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v5 = 4 * a3;
  unint64_t v6 = (_DWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 4 * a3, 4);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  unint64_t v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 4);
    unint64_t v8 = (_DWORD *)((char *)v8 + v5 - 4);
  }
  _DWORD *v8 = 0;
}

_anonymous_namespace_ *re::FixedArray<unsigned long>::operator=(_anonymous_namespace_ *a1, uint64_t a2)
{
  if (*(void *)a1) {
    goto LABEL_4;
  }
  unint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
LABEL_4:
    re::FixedArray<unsigned long>::copy(a1, (const void **)a2);
  }
  return a1;
}

uint64_t re::EvaluationModelSingleThread::deinit(re::EvaluationModelSingleThread *this)
{
  re::FixedRegisterTable::deinit((re::EvaluationModelSingleThread *)((char *)this + 16));
  re::FixedArray<re::EvaluationCallbackData>::deinit((void *)this + 26);
  re::FixedArray<re::EvaluationContext>::deinit((void *)this + 29);
  re::FixedArray<re::EvaluationModelSingleThread::BranchGroupExecutionData>::deinit((void *)this + 32);
  re::FixedRegisterTable::deinit((re::EvaluationModelSingleThread *)((char *)this + 280));
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 59);
  re::FixedRegisterTable::deinit((re::EvaluationModelSingleThread *)((char *)this + 496));
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 86);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 89);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 95);
  return re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 92);
}

uint64_t re::EvaluationModelSingleThread::evaluate(re::EvaluationModelSingleThread *this, re::EvaluationContextSlices *a2)
{
  unint64_t v5 = *((void *)this + 3);
  uint64_t v4 = *((void *)this + 4);
  uint64_t v110 = v4;
  uint64_t v111 = v5;
  unint64_t v7 = *((void *)this + 6);
  uint64_t v6 = *((void *)this + 7);
  uint64_t v112 = v6;
  uint64_t v113 = v7;
  unint64_t i = *((void *)this + 9);
  uint64_t v8 = *((void *)this + 10);
  uint64_t v114 = v8;
  uint64_t v115 = i;
  uint64_t v116 = *((void *)this + 13);
  uint64_t v117 = *((void *)this + 12);
  uint64_t v118 = *((void *)this + 16);
  uint64_t v119 = *((void *)this + 15);
  uint64_t v120 = *((void *)this + 19);
  uint64_t v121 = *((void *)this + 18);
  uint64_t v122 = *((void *)this + 22);
  uint64_t v123 = *((void *)this + 21);
  uint64_t v124 = *((void *)this + 25);
  uint64_t v125 = *((void *)this + 24);
  uint64_t v126 = *((void *)this + 28);
  uint64_t v127 = *((void *)this + 31);
  uint64_t v128 = *((void *)this + 34);
  uint64_t v10 = *((void *)a2 + 1);
  if (v10)
  {
    uint64_t v11 = 0;
    uint64_t v12 = *(void *)a2;
    uint64_t v13 = *((void *)this + 36);
    while (v13 != v11)
    {
      unint64_t v14 = *(void *)(*((void *)this + 37) + 8 * v11);
      if (v14 != -1)
      {
        if (v5 <= v14) {
          goto LABEL_167;
        }
        *(_DWORD *)(v4 + 4 * v14) = *(_DWORD *)(v12 + 4 * v11);
      }
      if (v10 == ++v11) {
        goto LABEL_8;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_132;
  }
LABEL_8:
  uint64_t v15 = *((void *)a2 + 3);
  if (v15)
  {
    uint64_t v16 = 0;
    uint64_t v17 = *((void *)a2 + 2);
    uint64_t v18 = *((void *)this + 39);
    while (v18 != v16)
    {
      unint64_t v19 = *(void *)(*((void *)this + 40) + 8 * v16);
      if (v19 != -1)
      {
        if (v7 <= v19) {
          goto LABEL_168;
        }
        *(_DWORD *)(v6 + 4 * v19) = *(_DWORD *)(v17 + 4 * v16);
      }
      if (v15 == ++v16) {
        goto LABEL_15;
      }
    }
LABEL_132:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_133:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_134:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_135:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_136:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_137:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_138:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_139:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_140:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_141:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_142:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_143;
  }
LABEL_15:
  uint64_t v20 = *((void *)a2 + 5);
  if (v20)
  {
    uint64_t v21 = 0;
    uint64_t v22 = *((void *)a2 + 4);
    uint64_t v23 = *((void *)this + 42);
    while (v23 != v21)
    {
      unint64_t v24 = *(void *)(*((void *)this + 43) + 8 * v21);
      if (v24 != -1)
      {
        if (i <= v24) {
          goto LABEL_169;
        }
        *(_DWORD *)(v8 + 4 * v24) = *(_DWORD *)(v22 + 4 * v21);
      }
      if (v20 == ++v21) {
        goto LABEL_22;
      }
    }
    goto LABEL_133;
  }
LABEL_22:
  unint64_t v25 = *((void *)a2 + 7);
  if (v25)
  {
    uint64_t v26 = 0;
    unint64_t i = 0;
    while (*((void *)this + 45) > i)
    {
      unint64_t v27 = *(void *)(*((void *)this + 46) + 8 * i);
      if (v27 != -1)
      {
        if (*((void *)this + 12) <= v27) {
          goto LABEL_170;
        }
        uint64_t v28 = (long long *)(*((void *)a2 + 6) + v26);
        uint64_t v29 = (_OWORD *)(*((void *)this + 13) + 48 * v27);
        long long v30 = *v28;
        long long v31 = v28[2];
        v29[1] = v28[1];
        v29[2] = v31;
        _OWORD *v29 = v30;
        unint64_t v25 = *((void *)a2 + 7);
      }
      ++i;
      v26 += 48;
      if (i >= v25) {
        goto LABEL_29;
      }
    }
    goto LABEL_134;
  }
LABEL_29:
  unint64_t v32 = *((void *)a2 + 9);
  if (v32)
  {
    uint64_t v33 = 0;
    unint64_t i = 0;
    while (*((void *)this + 48) > i)
    {
      unint64_t v34 = *(void *)(*((void *)this + 49) + 8 * i);
      if (v34 != -1)
      {
        if (*((void *)this + 15) <= v34) {
          goto LABEL_171;
        }
        unint64_t v35 = (long long *)(*((void *)a2 + 8) + v33);
        uint64_t v36 = (_OWORD *)(*((void *)this + 16) + (v34 << 6));
        long long v37 = *v35;
        long long v38 = v35[1];
        long long v39 = v35[3];
        uint64_t v36[2] = v35[2];
        v36[3] = v39;
        _OWORD *v36 = v37;
        v36[1] = v38;
        unint64_t v32 = *((void *)a2 + 9);
      }
      ++i;
      v33 += 64;
      if (i >= v32) {
        goto LABEL_36;
      }
    }
    goto LABEL_135;
  }
LABEL_36:
  unint64_t v40 = *((void *)a2 + 11);
  if (v40)
  {
    uint64_t v41 = 0;
    unint64_t i = 0;
    while (*((void *)this + 51) > i)
    {
      unint64_t v42 = *(void *)(*((void *)this + 52) + 8 * i);
      if (v42 != -1)
      {
        if (*((void *)this + 18) <= v42) {
          goto LABEL_172;
        }
        *(_OWORD *)(*((void *)this + 19) + 16 * v42) = *(_OWORD *)(*((void *)a2 + 10) + v41);
        unint64_t v40 = *((void *)a2 + 11);
      }
      ++i;
      v41 += 16;
      if (i >= v40) {
        goto LABEL_43;
      }
    }
    goto LABEL_136;
  }
LABEL_43:
  unint64_t v43 = *((void *)a2 + 13);
  if (v43)
  {
    unint64_t i = 0;
    while (*((void *)this + 54) > i)
    {
      unint64_t v44 = *(void *)(*((void *)this + 55) + 8 * i);
      if (v44 != -1)
      {
        if (*((void *)this + 21) <= v44) {
          goto LABEL_173;
        }
        *(void *)(*((void *)this + 22) + 8 * v44) = *(void *)(*((void *)a2 + 12) + 8 * i);
        unint64_t v43 = *((void *)a2 + 13);
      }
      if (++i >= v43) {
        goto LABEL_50;
      }
    }
    goto LABEL_137;
  }
LABEL_50:
  unint64_t v45 = *((void *)a2 + 15);
  if (v45)
  {
    uint64_t v46 = 0;
    unint64_t i = 0;
    while (*((void *)this + 57) > i)
    {
      unint64_t v47 = *(void *)(*((void *)this + 58) + 8 * i);
      if (v47 != -1)
      {
        if (*((void *)this + 24) <= v47) {
          goto LABEL_174;
        }
        *(_OWORD *)(*((void *)this + 25) + 16 * v47) = *(_OWORD *)(*((void *)a2 + 14) + v46);
        unint64_t v45 = *((void *)a2 + 15);
      }
      ++i;
      v46 += 16;
      if (i >= v45) {
        goto LABEL_57;
      }
    }
    goto LABEL_138;
  }
LABEL_57:
  unint64_t v48 = *((void *)this + 60);
  if (v48)
  {
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    for (unint64_t i = 0; i < v48; ++i)
    {
      unint64_t v51 = *(void *)(*((void *)this + 61) + v49);
      if (v51 != -1)
      {
        unint64_t v52 = *((void *)a2 + 17);
        if (v52 <= i) {
          goto LABEL_175;
        }
        if (*((void *)this + 24) <= v51) {
          goto LABEL_176;
        }
        *(_OWORD *)(*((void *)this + 25) + 16 * v51) = *(_OWORD *)(*((void *)a2 + 16) + v50);
        unint64_t v48 = *((void *)this + 60);
      }
      if (v48 <= i) {
        goto LABEL_141;
      }
      unint64_t v53 = *(void *)(*((void *)this + 61) + v49 + 8);
      if (v53 != -1)
      {
        unint64_t v54 = *((void *)a2 + 17);
        if (v54 <= i) {
          goto LABEL_177;
        }
        if (*((void *)this + 18) <= v53) {
          goto LABEL_178;
        }
        *(_OWORD *)(*((void *)this + 19) + 16 * v53) = *(_OWORD *)(*((void *)a2 + 16) + v50 + 16);
        unint64_t v48 = *((void *)this + 60);
      }
      if (v48 <= i) {
        goto LABEL_142;
      }
      unint64_t v55 = *(void *)(*((void *)this + 61) + v49 + 16);
      if (v55 != -1)
      {
        unint64_t v56 = *((void *)a2 + 17);
        if (v56 <= i) {
          goto LABEL_179;
        }
        if (*((void *)this + 24) <= v55) {
          goto LABEL_180;
        }
        *(_OWORD *)(*((void *)this + 25) + 16 * v55) = *(_OWORD *)(*((void *)a2 + 16) + v50 + 32);
        unint64_t v48 = *((void *)this + 60);
      }
      v50 += 48;
      v49 += 24;
    }
  }
  uint64_t v57 = *((void *)this + 90);
  if (v57)
  {
    uint64_t v58 = 0;
    unint64_t i = 0;
    while (*((void *)this + 96) > i)
    {
      if (*((void *)this + 90) <= i) {
        goto LABEL_140;
      }
      uint64_t v59 = *(void *)(*((void *)this + 97) + 8 * i) + v58;
                                                                                            + 4 * i++)])(*((void *)this + 94) + 8 * v58);
      uint64_t v58 = v59;
      if (v57 == i) {
        goto LABEL_79;
      }
    }
    goto LABEL_139;
  }
LABEL_79:
  uint64_t v60 = *((void *)this + 63);
  if (v60)
  {
    uint64_t v61 = 0;
    uint64_t v63 = *((void *)a2 + 18);
    uint64_t v62 = *((void *)a2 + 19);
    uint64_t v64 = *((void *)this + 64);
    unint64_t i = *((void *)this + 3);
    while (1)
    {
      unint64_t v65 = *(void *)(v64 + 8 * v61);
      if (i <= v65) {
        break;
      }
      if (v62 == v61) {
        goto LABEL_144;
      }
      *(_DWORD *)(v63 + 4 * v61++) = *(_DWORD *)(*((void *)this + 4) + 4 * v65);
      if (v60 == v61) {
        goto LABEL_84;
      }
    }
LABEL_143:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_144:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v62, v62, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, v120,
      v121,
      v122,
      v123,
      v124,
      v125,
      v126,
      v127,
      v128);
    _os_crash();
    __break(1u);
    goto LABEL_145;
  }
LABEL_84:
  uint64_t v66 = *((void *)this + 66);
  if (v66)
  {
    uint64_t v67 = 0;
    uint64_t v69 = *((void *)a2 + 20);
    uint64_t v68 = *((void *)a2 + 21);
    uint64_t v70 = *((void *)this + 67);
    unint64_t i = *((void *)this + 6);
    while (1)
    {
      unint64_t v71 = *(void *)(v70 + 8 * v67);
      if (i <= v71) {
        break;
      }
      if (v68 == v67) {
        goto LABEL_146;
      }
      *(_DWORD *)(v69 + 4 * v67++) = *(_DWORD *)(*((void *)this + 7) + 4 * v71);
      if (v66 == v67) {
        goto LABEL_89;
      }
    }
LABEL_145:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_146:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v68, v68);
    _os_crash();
    __break(1u);
    goto LABEL_147;
  }
LABEL_89:
  uint64_t v72 = *((void *)this + 69);
  if (v72)
  {
    uint64_t v73 = 0;
    uint64_t v75 = *((void *)a2 + 22);
    uint64_t v74 = *((void *)a2 + 23);
    uint64_t v76 = *((void *)this + 70);
    unint64_t i = *((void *)this + 9);
    while (1)
    {
      unint64_t v77 = *(void *)(v76 + 8 * v73);
      if (i <= v77) {
        break;
      }
      if (v74 == v73) {
        goto LABEL_148;
      }
      *(_DWORD *)(v75 + 4 * v73++) = *(_DWORD *)(*((void *)this + 10) + 4 * v77);
      if (v72 == v73) {
        goto LABEL_94;
      }
    }
LABEL_147:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_148:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v74, v74);
    _os_crash();
    __break(1u);
    goto LABEL_149;
  }
LABEL_94:
  if (*((void *)this + 72))
  {
    uint64_t v78 = 0;
    unint64_t v79 = 0;
    while (1)
    {
      unint64_t i = *(void *)(*((void *)this + 73) + 8 * v79);
      if (*((void *)this + 12) <= i) {
        break;
      }
      unint64_t v80 = *((void *)a2 + 25);
      if (v80 <= v79) {
        goto LABEL_150;
      }
      uint64_t v81 = (long long *)(*((void *)this + 13) + 48 * i);
      uint64_t v82 = (_OWORD *)(*((void *)a2 + 24) + v78);
      long long v83 = *v81;
      long long v84 = v81[2];
      v82[1] = v81[1];
      v82[2] = v84;
      _OWORD *v82 = v83;
      ++v79;
      v78 += 48;
      if (v79 >= *((void *)this + 72)) {
        goto LABEL_99;
      }
    }
LABEL_149:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_150:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v79, v80);
    _os_crash();
    __break(1u);
    goto LABEL_151;
  }
LABEL_99:
  if (*((void *)this + 75))
  {
    uint64_t v85 = 0;
    unint64_t v86 = 0;
    while (1)
    {
      unint64_t i = *(void *)(*((void *)this + 76) + 8 * v86);
      if (*((void *)this + 15) <= i) {
        break;
      }
      unint64_t v87 = *((void *)a2 + 27);
      if (v87 <= v86) {
        goto LABEL_152;
      }
      uint64_t v88 = (long long *)(*((void *)this + 16) + (i << 6));
      uint64_t v89 = (_OWORD *)(*((void *)a2 + 26) + v85);
      long long v90 = *v88;
      long long v91 = v88[1];
      long long v92 = v88[3];
      v89[2] = v88[2];
      v89[3] = v92;
      _OWORD *v89 = v90;
      v89[1] = v91;
      ++v86;
      v85 += 64;
      if (v86 >= *((void *)this + 75)) {
        goto LABEL_104;
      }
    }
LABEL_151:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_152:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v86, v87);
    _os_crash();
    __break(1u);
    goto LABEL_153;
  }
LABEL_104:
  if (*((void *)this + 78))
  {
    uint64_t v93 = 0;
    unint64_t v94 = 0;
    while (1)
    {
      unint64_t i = *(void *)(*((void *)this + 79) + 8 * v94);
      if (*((void *)this + 18) <= i) {
        break;
      }
      unint64_t v95 = *((void *)a2 + 29);
      if (v95 <= v94) {
        goto LABEL_154;
      }
      *(_OWORD *)(*((void *)a2 + 28) + v93) = *(_OWORD *)(*((void *)this + 19) + 16 * i);
      ++v94;
      v93 += 16;
      if (v94 >= *((void *)this + 78)) {
        goto LABEL_109;
      }
    }
LABEL_153:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_154:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v94, v95);
    _os_crash();
    __break(1u);
    goto LABEL_155;
  }
LABEL_109:
  if (*((void *)this + 81))
  {
    unint64_t v96 = 0;
    while (1)
    {
      unint64_t i = *(void *)(*((void *)this + 82) + 8 * v96);
      if (*((void *)this + 21) <= i) {
        break;
      }
      unint64_t v97 = *((void *)a2 + 31);
      if (v97 <= v96) {
        goto LABEL_156;
      }
      *(void *)(*((void *)a2 + 30) + 8 * v96++) = *(void *)(*((void *)this + 22) + 8 * i);
      if (v96 >= *((void *)this + 81)) {
        goto LABEL_114;
      }
    }
LABEL_155:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_156:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v96, v97);
    _os_crash();
    __break(1u);
    goto LABEL_157;
  }
LABEL_114:
  if (*((void *)this + 84))
  {
    uint64_t v98 = 0;
    unint64_t v99 = 0;
    while (1)
    {
      unint64_t i = *(void *)(*((void *)this + 85) + 8 * v99);
      if (*((void *)this + 24) <= i) {
        break;
      }
      unint64_t v100 = *((void *)a2 + 33);
      if (v100 <= v99) {
        goto LABEL_158;
      }
      *(_OWORD *)(*((void *)a2 + 32) + v98) = *(_OWORD *)(*((void *)this + 25) + 16 * i);
      ++v99;
      v98 += 16;
      if (v99 >= *((void *)this + 84)) {
        goto LABEL_119;
      }
    }
LABEL_157:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_158:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v99, v100);
    _os_crash();
    __break(1u);
    goto LABEL_159;
  }
LABEL_119:
  if (*((void *)this + 87))
  {
    uint64_t v101 = 0;
    uint64_t v102 = 0;
    unint64_t i = 0;
    while (1)
    {
      unint64_t v103 = *(void *)(*((void *)this + 88) + v101);
      if (*((void *)this + 24) <= v103) {
        break;
      }
      unint64_t v104 = *((void *)a2 + 35);
      if (v104 <= i) {
        goto LABEL_160;
      }
      *(_OWORD *)(*((void *)a2 + 34) + v102) = *(_OWORD *)(*((void *)this + 25) + 16 * v103);
      if (*((void *)this + 87) <= i) {
        goto LABEL_161;
      }
      unint64_t v105 = *(void *)(*((void *)this + 88) + v101 + 8);
      if (*((void *)this + 18) <= v105) {
        goto LABEL_162;
      }
      unint64_t v106 = *((void *)a2 + 35);
      if (v106 <= i) {
        goto LABEL_163;
      }
      *(_OWORD *)(*((void *)a2 + 34) + v102 + 16) = *(_OWORD *)(*((void *)this + 19) + 16 * v105);
      if (*((void *)this + 87) <= i) {
        goto LABEL_164;
      }
      unint64_t v107 = *(void *)(*((void *)this + 88) + v101 + 16);
      if (*((void *)this + 24) <= v107) {
        goto LABEL_165;
      }
      unint64_t v108 = *((void *)a2 + 35);
      if (v108 <= i) {
        goto LABEL_166;
      }
      *(_OWORD *)(*((void *)a2 + 34) + v102 + 32) = *(_OWORD *)(*((void *)this + 25) + 16 * v107);
      ++i;
      v102 += 48;
      v101 += 24;
      if (i >= *((void *)this + 87)) {
        return 1;
      }
    }
LABEL_159:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_160:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, i, v104);
    _os_crash();
    __break(1u);
LABEL_161:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_162:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_163:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, i, v106);
    _os_crash();
    __break(1u);
LABEL_164:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_165:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_166:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, i, v108);
    _os_crash();
    __break(1u);
LABEL_167:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_168:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_169:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_170:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_171:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_172:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_173:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_174:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_175:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, i, v52);
    _os_crash();
    __break(1u);
LABEL_176:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_177:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, i, v54);
    _os_crash();
    __break(1u);
LABEL_178:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_179:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, i, v56);
    _os_crash();
    __break(1u);
LABEL_180:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return 1;
}

uint64_t re::EvaluationModelSingleThread::setupEvaluationModel@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v25 = 0;
  uint64_t v24 = 0;
  uint64_t v26 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  memset(v8, 0, sizeof(v8));
  re::EvaluationTree::resolveAliasRegisters(a3, a2, a4, &v27, &v24, &v12, &v9, v8);
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  re::EvaluationModelSingleThread::init(a5);
  if (v9 && v10) {
    (*(void (**)(void))(*(void *)v9 + 40))();
  }
  if (*((void *)&v22 + 1))
  {
    if ((void)v23)
    {
      (*(void (**)(void))(**((void **)&v22 + 1) + 40))();
      long long v23 = 0uLL;
    }
    *((void *)&v22 + 1) = 0;
  }
  if ((void)v21)
  {
    if (*((void *)&v21 + 1))
    {
      (*(void (**)(void))(*(void *)v21 + 40))();
      *((void *)&v21 + 1) = 0;
      *(void *)&long long v22 = 0;
    }
    *(void *)&long long v21 = 0;
  }
  if (*((void *)&v19 + 1))
  {
    if ((void)v20)
    {
      (*(void (**)(void))(**((void **)&v19 + 1) + 40))();
      long long v20 = 0uLL;
    }
    *((void *)&v19 + 1) = 0;
  }
  if ((void)v18)
  {
    if (*((void *)&v18 + 1))
    {
      (*(void (**)(void))(*(void *)v18 + 40))();
      *((void *)&v18 + 1) = 0;
      *(void *)&long long v19 = 0;
    }
    *(void *)&long long v18 = 0;
  }
  if (*((void *)&v16 + 1))
  {
    if ((void)v17)
    {
      (*(void (**)(void))(**((void **)&v16 + 1) + 40))();
      long long v17 = 0uLL;
    }
    *((void *)&v16 + 1) = 0;
  }
  if ((void)v15)
  {
    if (*((void *)&v15 + 1))
    {
      (*(void (**)(void))(*(void *)v15 + 40))();
      *((void *)&v15 + 1) = 0;
      *(void *)&long long v16 = 0;
    }
    *(void *)&long long v15 = 0;
  }
  if (*((void *)&v13 + 1))
  {
    if ((void)v14)
    {
      (*(void (**)(void))(**((void **)&v13 + 1) + 40))();
      long long v14 = 0uLL;
    }
    *((void *)&v13 + 1) = 0;
  }
  if ((void)v12 && *((void *)&v12 + 1)) {
    (*(void (**)(void))(*(void *)v12 + 40))();
  }
  if (v24 && v25) {
    (*(void (**)(void))(*(void *)v24 + 40))();
  }
  if (*((void *)&v37 + 1))
  {
    if ((void)v38)
    {
      (*(void (**)(void, void))(**((void **)&v37 + 1) + 40))(*((void *)&v37 + 1), *((void *)&v38 + 1));
      long long v38 = 0uLL;
    }
    *((void *)&v37 + 1) = 0;
  }
  if ((void)v36)
  {
    if (*((void *)&v36 + 1))
    {
      (*(void (**)(void, void))(*(void *)v36 + 40))(v36, v37);
      *((void *)&v36 + 1) = 0;
      *(void *)&long long v37 = 0;
    }
    *(void *)&long long v36 = 0;
  }
  if (*((void *)&v34 + 1))
  {
    if ((void)v35)
    {
      (*(void (**)(void, void))(**((void **)&v34 + 1) + 40))(*((void *)&v34 + 1), *((void *)&v35 + 1));
      long long v35 = 0uLL;
    }
    *((void *)&v34 + 1) = 0;
  }
  if ((void)v33)
  {
    if (*((void *)&v33 + 1))
    {
      (*(void (**)(void, void))(*(void *)v33 + 40))(v33, v34);
      *((void *)&v33 + 1) = 0;
      *(void *)&long long v34 = 0;
    }
    *(void *)&long long v33 = 0;
  }
  if (*((void *)&v31 + 1))
  {
    if ((void)v32)
    {
      (*(void (**)(void, void))(**((void **)&v31 + 1) + 40))(*((void *)&v31 + 1), *((void *)&v32 + 1));
      long long v32 = 0uLL;
    }
    *((void *)&v31 + 1) = 0;
  }
  if ((void)v30)
  {
    if (*((void *)&v30 + 1))
    {
      (*(void (**)(void, void))(*(void *)v30 + 40))(v30, v31);
      *((void *)&v30 + 1) = 0;
      *(void *)&long long v31 = 0;
    }
    *(void *)&long long v30 = 0;
  }
  if (*((void *)&v28 + 1))
  {
    if ((void)v29)
    {
      (*(void (**)(void, void))(**((void **)&v28 + 1) + 40))(*((void *)&v28 + 1), *((void *)&v29 + 1));
      long long v29 = 0uLL;
    }
    *((void *)&v28 + 1) = 0;
  }
  uint64_t result = v27;
  if ((void)v27)
  {
    if (*((void *)&v27 + 1)) {
      return (*(uint64_t (**)(void, void))(*(void *)v27 + 40))(v27, v28);
    }
  }
  return result;
}

void *re::DynamicArray<re::EvaluationCommand>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          unint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (a2 >> 62)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 4, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 4 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 4 * a2, 4);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 4 * v5[2]);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<re::EvaluationCommand>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void *re::anonymous namespace'::RegisterMapping::finishRegisterProcessing(void *result, unsigned int a2, unint64_t a3, char a4)
{
  if (result[3 * a2 + 3] <= a3)
  {
LABEL_11:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_12:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v4 = result;
  unint64_t v5 = &result[3 * a2];
  *(unsigned char *)(v5[4] + (a3 << 6) + 40) = a4;
  if (v5[57] <= a3) {
    goto LABEL_12;
  }
  uint64_t v6 = (void *)(result[3 * a2 + 58] + 16 * a3);
  uint64_t v7 = v6[1];
  if (v7)
  {
    for (unint64_t i = (unint64_t *)(*v6 + 8); ; i += 2)
    {
      unsigned int v9 = *((unsigned __int8 *)i - 8);
      unint64_t v10 = *i;
      if (v4[3 * *((unsigned __int8 *)i - 8) + 3] <= *i) {
        break;
      }
      unint64_t v11 = v4[3 * *((unsigned __int8 *)i - 8) + 4] + (v10 << 6);
      uint64_t v12 = *(void *)(v11 + 32) - 1;
      *(void *)(v11 + 32) = v12;
      if (!v12) {
      if (!--v7)
      }
        return result;
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_11;
  }
  return result;
}

void *re::anonymous namespace'::RegisterMapping::processRegister<int>(uint64_t a1, unint64_t a2, void *a3)
{
  v61[5] = *MEMORY[0x263EF8340];
  if (*((unsigned char *)result + 40) == 2) {
    return result;
  }
  uint64_t v8 = (int *)result;
  unint64_t v9 = *(unsigned int *)result;
  if ((int)v9 > 7)
  {
    int v22 = *(_DWORD *)result;
    if (*(unsigned char *)(a1 + 3824))
    {
      memset(v61, 0, 32);
      uint64_t v24 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
      uint64_t v25 = *((unsigned __int8 *)v24 + 9);
      if (!*((unsigned char *)v24 + 9))
      {
LABEL_58:
        LODWORD(v46) = 0;
        v61[v25] = *((void *)v8 + 6);
        uint64_t v37 = *(void *)(a1 + 3848);
        *(void *)&long long v47 = *(void *)(a1 + 3864);
        *((void *)&v47 + 1) = v37;
        uint64_t v38 = *(void *)(a1 + 3888);
        *(void *)&long long v48 = *(void *)(a1 + 3904);
        *((void *)&v48 + 1) = v38;
        uint64_t v39 = *(void *)(a1 + 3928);
        *(void *)&long long v49 = *(void *)(a1 + 3944);
        *((void *)&v49 + 1) = v39;
        uint64_t v40 = *(void *)(a1 + 3968);
        *(void *)&long long v50 = *(void *)(a1 + 3984);
        *((void *)&v50 + 1) = v40;
        uint64_t v41 = *(void *)(a1 + 4008);
        *(void *)&long long v51 = *(void *)(a1 + 4024);
        *((void *)&v51 + 1) = v41;
        uint64_t v42 = *(void *)(a1 + 4048);
        uint64_t v52 = *(void *)(a1 + 4064);
        uint64_t v53 = v42;
        uint64_t v43 = *(void *)(a1 + 4088);
        uint64_t v54 = *(void *)(a1 + 4104);
        uint64_t v55 = v43;
        uint64_t v44 = *(void *)(a1 + 4128);
        uint64_t v56 = *(void *)(a1 + 4144);
        uint64_t v57 = v44;
        uint64_t v58 = 0;
        uint64_t v59 = 0;
        uint64_t v60 = 0;
      }
      uint64_t v26 = 0;
      long long v27 = (char *)v24 + 10;
      while (2)
      {
        uint64_t v28 = v27[v26];
        switch(v27[v26])
        {
          case 0:
            goto LABEL_35;
          case 1:
            goto LABEL_35;
          case 2:
            goto LABEL_35;
          case 3:
            goto LABEL_35;
          case 4:
            goto LABEL_35;
          case 5:
            goto LABEL_35;
          case 6:
            goto LABEL_35;
          case 7:
LABEL_35:
            if (*(unsigned char *)(RegisterMap + 40) != 3) {
              goto LABEL_57;
            }
            v61[v26++] = *(void *)(RegisterMap + 48);
            if (v25 == v26) {
              goto LABEL_58;
            }
            continue;
          default:
            if ((v28 - 253) >= 2)
            {
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1778, v28);
              _os_crash();
              __break(1u);
LABEL_66:
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1823, v34);
              _os_crash();
              __break(1u);
              JUMPOUT(0x23328AFA4);
            }
LABEL_57:
            if (v25 == v26) {
              goto LABEL_58;
            }
            int v22 = *v8;
            break;
        }
        break;
      }
    }
    if (v22 == 76)
    {
      {
        unint64_t v13 = *((void *)v8 + 1);
        unint64_t v9 = *(void *)(a1 + 216);
        if (v9 <= v13) {
          goto LABEL_64;
        }
        long long v23 = (void *)(*(void *)(a1 + 224) + 904 * v13 + 896);
LABEL_41:
        re::DynamicArray<unsigned long>::add(a3, v23);
      }
    }
    else
    {
      if (v22 != 77)
      {
        long long v30 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
        uint64_t v31 = *((unsigned __int8 *)v30 + 9);
        if (*((unsigned char *)v30 + 9))
        {
          long long v32 = (unint64_t *)(v8 + 2);
          long long v33 = (unsigned __int8 *)v30 + 10;
          while (2)
          {
            unsigned int v35 = *v33++;
            uint64_t v34 = v35;
            switch(v35)
            {
              case 0u:
                goto LABEL_53;
              case 1u:
                goto LABEL_53;
              case 2u:
                goto LABEL_53;
              case 3u:
                goto LABEL_53;
              case 4u:
                goto LABEL_53;
              case 5u:
                goto LABEL_53;
              case 6u:
                goto LABEL_53;
              case 7u:
LABEL_53:
                *(void *)&long long v47 = MappedRegister;
                re::DynamicArray<unsigned long>::add(a3, &v47);
                ++v32;
                if (!--v31) {
                  break;
                }
                continue;
              default:
                goto LABEL_66;
            }
            break;
          }
        }
        re::DynamicArray<unsigned long>::add(a3, &v47);
      }
      {
        unint64_t v13 = *((void *)v8 + 1);
        unint64_t v9 = *(void *)(a1 + 240);
        if (v9 <= v13)
        {
LABEL_63:
          uint64_t v46 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v61[0]) = 136315906;
          *(void *)((char *)v61 + 4) = "operator[]";
          WORD2(v61[1]) = 1024;
          *(_DWORD *)((char *)&v61[1] + 6) = 468;
          WORD1(v61[2]) = 2048;
          *(void *)((char *)&v61[2] + 4) = v13;
          WORD2(v61[3]) = 2048;
          *(void *)((char *)&v61[3] + 6) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_64:
          uint64_t v46 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v61[0]) = 136315906;
          *(void *)((char *)v61 + 4) = "operator[]";
          WORD2(v61[1]) = 1024;
          *(_DWORD *)((char *)&v61[1] + 6) = 468;
          WORD1(v61[2]) = 2048;
          *(void *)((char *)&v61[2] + 4) = v13;
          WORD2(v61[3]) = 2048;
          *(void *)((char *)&v61[3] + 6) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        long long v23 = (void *)(*(void *)(a1 + 248) + 248 * v13 + 240);
        goto LABEL_41;
      }
    }
  }
  int v45 = 0;
  unint64_t v10 = *(void **)(a1 + 8);
  unint64_t v11 = a2;
  unint64_t v12 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if ((uint64_t)(a2 - 0x7FFFFFFFFFFFFFFFLL) >= 0)
  {
    unint64_t v13 = v10[83];
    while (v13 > v12)
    {
      unint64_t v11 = *(void *)(v10[85] + 8 * v12);
      unint64_t v12 = v11 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_7;
      }
    }
    uint64_t v46 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v47 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v61[0]) = 136315906;
    *(void *)((char *)v61 + 4) = "operator[]";
    WORD2(v61[1]) = 1024;
    *(_DWORD *)((char *)&v61[1] + 6) = 797;
    WORD1(v61[2]) = 2048;
    *(void *)((char *)&v61[2] + 4) = v12;
    WORD2(v61[3]) = 2048;
    *(void *)((char *)&v61[3] + 6) = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_62;
  }
LABEL_7:
  unint64_t v14 = v10[3];
  if (v14)
  {
    long long v15 = (void *)v10[5];
    long long v16 = &v15[v14];
    long long v17 = v15;
    do
    {
      unint64_t v18 = v14 >> 1;
      long long v19 = &v17[v14 >> 1];
      unint64_t v21 = *v19;
      long long v20 = v19 + 1;
      v14 += ~(v14 >> 1);
      if (v21 < v11) {
        long long v17 = v20;
      }
      else {
        unint64_t v14 = v18;
      }
    }
    while (v14);
    if (v17 != v16 && *v17 == v11)
    {
      unint64_t v12 = v17 - v15;
      unint64_t v13 = v10[43];
      if (v13 <= v12)
      {
LABEL_62:
        uint64_t v46 = 0;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v47 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v61[0]) = 136315906;
        *(void *)((char *)v61 + 4) = "operator[]";
        WORD2(v61[1]) = 1024;
        *(_DWORD *)((char *)&v61[1] + 6) = 797;
        WORD1(v61[2]) = 2048;
        *(void *)((char *)&v61[2] + 4) = v12;
        WORD2(v61[3]) = 2048;
        *(void *)((char *)&v61[3] + 6) = v13;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_63;
      }
      int v45 = *(_DWORD *)(v10[45] + 4 * v12);
    }
  }
}

void *re::anonymous namespace'::RegisterMapping::processRegister<unsigned int>(uint64_t a1, unint64_t a2, void *a3)
{
  v61[5] = *MEMORY[0x263EF8340];
  if (*((unsigned char *)result + 40) == 2) {
    return result;
  }
  uint64_t v8 = (int *)result;
  unint64_t v9 = *(unsigned int *)result;
  if ((int)v9 > 7)
  {
    int v22 = *(_DWORD *)result;
    if (*(unsigned char *)(a1 + 3824))
    {
      memset(v61, 0, 32);
      uint64_t v24 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
      uint64_t v25 = *((unsigned __int8 *)v24 + 9);
      if (!*((unsigned char *)v24 + 9))
      {
LABEL_58:
        LODWORD(v46) = 0;
        v61[v25] = *((void *)v8 + 6);
        uint64_t v37 = *(void *)(a1 + 3848);
        *(void *)&long long v47 = *(void *)(a1 + 3864);
        *((void *)&v47 + 1) = v37;
        uint64_t v38 = *(void *)(a1 + 3888);
        *(void *)&long long v48 = *(void *)(a1 + 3904);
        *((void *)&v48 + 1) = v38;
        uint64_t v39 = *(void *)(a1 + 3928);
        *(void *)&long long v49 = *(void *)(a1 + 3944);
        *((void *)&v49 + 1) = v39;
        uint64_t v40 = *(void *)(a1 + 3968);
        *(void *)&long long v50 = *(void *)(a1 + 3984);
        *((void *)&v50 + 1) = v40;
        uint64_t v41 = *(void *)(a1 + 4008);
        *(void *)&long long v51 = *(void *)(a1 + 4024);
        *((void *)&v51 + 1) = v41;
        uint64_t v42 = *(void *)(a1 + 4048);
        uint64_t v52 = *(void *)(a1 + 4064);
        uint64_t v53 = v42;
        uint64_t v43 = *(void *)(a1 + 4088);
        uint64_t v54 = *(void *)(a1 + 4104);
        uint64_t v55 = v43;
        uint64_t v44 = *(void *)(a1 + 4128);
        uint64_t v56 = *(void *)(a1 + 4144);
        uint64_t v57 = v44;
        uint64_t v58 = 0;
        uint64_t v59 = 0;
        uint64_t v60 = 0;
      }
      uint64_t v26 = 0;
      long long v27 = (char *)v24 + 10;
      while (2)
      {
        uint64_t v28 = v27[v26];
        switch(v27[v26])
        {
          case 0:
            goto LABEL_35;
          case 1:
            goto LABEL_35;
          case 2:
            goto LABEL_35;
          case 3:
            goto LABEL_35;
          case 4:
            goto LABEL_35;
          case 5:
            goto LABEL_35;
          case 6:
            goto LABEL_35;
          case 7:
LABEL_35:
            if (*(unsigned char *)(RegisterMap + 40) != 3) {
              goto LABEL_57;
            }
            v61[v26++] = *(void *)(RegisterMap + 48);
            if (v25 == v26) {
              goto LABEL_58;
            }
            continue;
          default:
            if ((v28 - 253) >= 2)
            {
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1778, v28);
              _os_crash();
              __break(1u);
LABEL_66:
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1823, v34);
              _os_crash();
              __break(1u);
              JUMPOUT(0x23328B818);
            }
LABEL_57:
            if (v25 == v26) {
              goto LABEL_58;
            }
            int v22 = *v8;
            break;
        }
        break;
      }
    }
    if (v22 == 76)
    {
      {
        unint64_t v13 = *((void *)v8 + 1);
        unint64_t v9 = *(void *)(a1 + 216);
        if (v9 <= v13) {
          goto LABEL_64;
        }
        long long v23 = (void *)(*(void *)(a1 + 224) + 904 * v13 + 896);
LABEL_41:
        re::DynamicArray<unsigned long>::add(a3, v23);
      }
    }
    else
    {
      if (v22 != 77)
      {
        long long v30 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
        uint64_t v31 = *((unsigned __int8 *)v30 + 9);
        if (*((unsigned char *)v30 + 9))
        {
          long long v32 = (unint64_t *)(v8 + 2);
          long long v33 = (unsigned __int8 *)v30 + 10;
          while (2)
          {
            unsigned int v35 = *v33++;
            uint64_t v34 = v35;
            switch(v35)
            {
              case 0u:
                goto LABEL_53;
              case 1u:
                goto LABEL_53;
              case 2u:
                goto LABEL_53;
              case 3u:
                goto LABEL_53;
              case 4u:
                goto LABEL_53;
              case 5u:
                goto LABEL_53;
              case 6u:
                goto LABEL_53;
              case 7u:
LABEL_53:
                *(void *)&long long v47 = MappedRegister;
                re::DynamicArray<unsigned long>::add(a3, &v47);
                ++v32;
                if (!--v31) {
                  break;
                }
                continue;
              default:
                goto LABEL_66;
            }
            break;
          }
        }
        re::DynamicArray<unsigned long>::add(a3, &v47);
      }
      {
        unint64_t v13 = *((void *)v8 + 1);
        unint64_t v9 = *(void *)(a1 + 240);
        if (v9 <= v13)
        {
LABEL_63:
          uint64_t v46 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v61[0]) = 136315906;
          *(void *)((char *)v61 + 4) = "operator[]";
          WORD2(v61[1]) = 1024;
          *(_DWORD *)((char *)&v61[1] + 6) = 468;
          WORD1(v61[2]) = 2048;
          *(void *)((char *)&v61[2] + 4) = v13;
          WORD2(v61[3]) = 2048;
          *(void *)((char *)&v61[3] + 6) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_64:
          uint64_t v46 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v61[0]) = 136315906;
          *(void *)((char *)v61 + 4) = "operator[]";
          WORD2(v61[1]) = 1024;
          *(_DWORD *)((char *)&v61[1] + 6) = 468;
          WORD1(v61[2]) = 2048;
          *(void *)((char *)&v61[2] + 4) = v13;
          WORD2(v61[3]) = 2048;
          *(void *)((char *)&v61[3] + 6) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        long long v23 = (void *)(*(void *)(a1 + 248) + 248 * v13 + 240);
        goto LABEL_41;
      }
    }
  }
  int v45 = 0;
  unint64_t v10 = *(void **)(a1 + 8);
  unint64_t v11 = a2;
  unint64_t v12 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if ((uint64_t)(a2 - 0x7FFFFFFFFFFFFFFFLL) >= 0)
  {
    unint64_t v13 = v10[88];
    while (v13 > v12)
    {
      unint64_t v11 = *(void *)(v10[90] + 8 * v12);
      unint64_t v12 = v11 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_7;
      }
    }
    uint64_t v46 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v47 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v61[0]) = 136315906;
    *(void *)((char *)v61 + 4) = "operator[]";
    WORD2(v61[1]) = 1024;
    *(_DWORD *)((char *)&v61[1] + 6) = 797;
    WORD1(v61[2]) = 2048;
    *(void *)((char *)&v61[2] + 4) = v12;
    WORD2(v61[3]) = 2048;
    *(void *)((char *)&v61[3] + 6) = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_62;
  }
LABEL_7:
  unint64_t v14 = v10[8];
  if (v14)
  {
    long long v15 = (void *)v10[10];
    long long v16 = &v15[v14];
    long long v17 = v15;
    do
    {
      unint64_t v18 = v14 >> 1;
      long long v19 = &v17[v14 >> 1];
      unint64_t v21 = *v19;
      long long v20 = v19 + 1;
      v14 += ~(v14 >> 1);
      if (v21 < v11) {
        long long v17 = v20;
      }
      else {
        unint64_t v14 = v18;
      }
    }
    while (v14);
    if (v17 != v16 && *v17 == v11)
    {
      unint64_t v12 = v17 - v15;
      unint64_t v13 = v10[48];
      if (v13 <= v12)
      {
LABEL_62:
        uint64_t v46 = 0;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v47 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v61[0]) = 136315906;
        *(void *)((char *)v61 + 4) = "operator[]";
        WORD2(v61[1]) = 1024;
        *(_DWORD *)((char *)&v61[1] + 6) = 797;
        WORD1(v61[2]) = 2048;
        *(void *)((char *)&v61[2] + 4) = v12;
        WORD2(v61[3]) = 2048;
        *(void *)((char *)&v61[3] + 6) = v13;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_63;
      }
      int v45 = *(_DWORD *)(v10[50] + 4 * v12);
    }
  }
}

void *re::anonymous namespace'::RegisterMapping::processRegister<float>(uint64_t a1, unint64_t a2, void *a3)
{
  v61[5] = *MEMORY[0x263EF8340];
  if (*((unsigned char *)result + 40) == 2) {
    return result;
  }
  uint64_t v8 = (int *)result;
  unint64_t v9 = *(unsigned int *)result;
  if ((int)v9 > 7)
  {
    int v22 = *(_DWORD *)result;
    if (*(unsigned char *)(a1 + 3824))
    {
      memset(v61, 0, 32);
      uint64_t v24 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
      uint64_t v25 = *((unsigned __int8 *)v24 + 9);
      if (!*((unsigned char *)v24 + 9))
      {
LABEL_58:
        LODWORD(v46) = 0;
        v61[v25] = *((void *)v8 + 6);
        uint64_t v37 = *(void *)(a1 + 3848);
        *(void *)&long long v47 = *(void *)(a1 + 3864);
        *((void *)&v47 + 1) = v37;
        uint64_t v38 = *(void *)(a1 + 3888);
        *(void *)&long long v48 = *(void *)(a1 + 3904);
        *((void *)&v48 + 1) = v38;
        uint64_t v39 = *(void *)(a1 + 3928);
        *(void *)&long long v49 = *(void *)(a1 + 3944);
        *((void *)&v49 + 1) = v39;
        uint64_t v40 = *(void *)(a1 + 3968);
        *(void *)&long long v50 = *(void *)(a1 + 3984);
        *((void *)&v50 + 1) = v40;
        uint64_t v41 = *(void *)(a1 + 4008);
        *(void *)&long long v51 = *(void *)(a1 + 4024);
        *((void *)&v51 + 1) = v41;
        uint64_t v42 = *(void *)(a1 + 4048);
        uint64_t v52 = *(void *)(a1 + 4064);
        uint64_t v53 = v42;
        uint64_t v43 = *(void *)(a1 + 4088);
        uint64_t v54 = *(void *)(a1 + 4104);
        uint64_t v55 = v43;
        uint64_t v44 = *(void *)(a1 + 4128);
        uint64_t v56 = *(void *)(a1 + 4144);
        uint64_t v57 = v44;
        uint64_t v58 = 0;
        uint64_t v59 = 0;
        uint64_t v60 = 0;
      }
      uint64_t v26 = 0;
      long long v27 = (char *)v24 + 10;
      while (2)
      {
        uint64_t v28 = v27[v26];
        switch(v27[v26])
        {
          case 0:
            goto LABEL_35;
          case 1:
            goto LABEL_35;
          case 2:
            goto LABEL_35;
          case 3:
            goto LABEL_35;
          case 4:
            goto LABEL_35;
          case 5:
            goto LABEL_35;
          case 6:
            goto LABEL_35;
          case 7:
LABEL_35:
            if (*(unsigned char *)(RegisterMap + 40) != 3) {
              goto LABEL_57;
            }
            v61[v26++] = *(void *)(RegisterMap + 48);
            if (v25 == v26) {
              goto LABEL_58;
            }
            continue;
          default:
            if ((v28 - 253) >= 2)
            {
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1778, v28);
              _os_crash();
              __break(1u);
LABEL_66:
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1823, v34);
              _os_crash();
              __break(1u);
              JUMPOUT(0x23328C08CLL);
            }
LABEL_57:
            if (v25 == v26) {
              goto LABEL_58;
            }
            int v22 = *v8;
            break;
        }
        break;
      }
    }
    if (v22 == 76)
    {
      {
        unint64_t v13 = *((void *)v8 + 1);
        unint64_t v9 = *(void *)(a1 + 216);
        if (v9 <= v13) {
          goto LABEL_64;
        }
        long long v23 = (void *)(*(void *)(a1 + 224) + 904 * v13 + 896);
LABEL_41:
        re::DynamicArray<unsigned long>::add(a3, v23);
      }
    }
    else
    {
      if (v22 != 77)
      {
        long long v30 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
        uint64_t v31 = *((unsigned __int8 *)v30 + 9);
        if (*((unsigned char *)v30 + 9))
        {
          long long v32 = (unint64_t *)(v8 + 2);
          long long v33 = (unsigned __int8 *)v30 + 10;
          while (2)
          {
            unsigned int v35 = *v33++;
            uint64_t v34 = v35;
            switch(v35)
            {
              case 0u:
                goto LABEL_53;
              case 1u:
                goto LABEL_53;
              case 2u:
                goto LABEL_53;
              case 3u:
                goto LABEL_53;
              case 4u:
                goto LABEL_53;
              case 5u:
                goto LABEL_53;
              case 6u:
                goto LABEL_53;
              case 7u:
LABEL_53:
                *(void *)&long long v47 = MappedRegister;
                re::DynamicArray<unsigned long>::add(a3, &v47);
                ++v32;
                if (!--v31) {
                  break;
                }
                continue;
              default:
                goto LABEL_66;
            }
            break;
          }
        }
        re::DynamicArray<unsigned long>::add(a3, &v47);
      }
      {
        unint64_t v13 = *((void *)v8 + 1);
        unint64_t v9 = *(void *)(a1 + 240);
        if (v9 <= v13)
        {
LABEL_63:
          uint64_t v46 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v61[0]) = 136315906;
          *(void *)((char *)v61 + 4) = "operator[]";
          WORD2(v61[1]) = 1024;
          *(_DWORD *)((char *)&v61[1] + 6) = 468;
          WORD1(v61[2]) = 2048;
          *(void *)((char *)&v61[2] + 4) = v13;
          WORD2(v61[3]) = 2048;
          *(void *)((char *)&v61[3] + 6) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_64:
          uint64_t v46 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v61[0]) = 136315906;
          *(void *)((char *)v61 + 4) = "operator[]";
          WORD2(v61[1]) = 1024;
          *(_DWORD *)((char *)&v61[1] + 6) = 468;
          WORD1(v61[2]) = 2048;
          *(void *)((char *)&v61[2] + 4) = v13;
          WORD2(v61[3]) = 2048;
          *(void *)((char *)&v61[3] + 6) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        long long v23 = (void *)(*(void *)(a1 + 248) + 248 * v13 + 240);
        goto LABEL_41;
      }
    }
  }
  int v45 = 0;
  unint64_t v10 = *(void **)(a1 + 8);
  unint64_t v11 = a2;
  unint64_t v12 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if ((uint64_t)(a2 - 0x7FFFFFFFFFFFFFFFLL) >= 0)
  {
    unint64_t v13 = v10[93];
    while (v13 > v12)
    {
      unint64_t v11 = *(void *)(v10[95] + 8 * v12);
      unint64_t v12 = v11 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_7;
      }
    }
    uint64_t v46 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v47 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v61[0]) = 136315906;
    *(void *)((char *)v61 + 4) = "operator[]";
    WORD2(v61[1]) = 1024;
    *(_DWORD *)((char *)&v61[1] + 6) = 797;
    WORD1(v61[2]) = 2048;
    *(void *)((char *)&v61[2] + 4) = v12;
    WORD2(v61[3]) = 2048;
    *(void *)((char *)&v61[3] + 6) = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_62;
  }
LABEL_7:
  unint64_t v14 = v10[13];
  if (v14)
  {
    long long v15 = (void *)v10[15];
    long long v16 = &v15[v14];
    long long v17 = v15;
    do
    {
      unint64_t v18 = v14 >> 1;
      long long v19 = &v17[v14 >> 1];
      unint64_t v21 = *v19;
      long long v20 = v19 + 1;
      v14 += ~(v14 >> 1);
      if (v21 < v11) {
        long long v17 = v20;
      }
      else {
        unint64_t v14 = v18;
      }
    }
    while (v14);
    if (v17 != v16 && *v17 == v11)
    {
      unint64_t v12 = v17 - v15;
      unint64_t v13 = v10[53];
      if (v13 <= v12)
      {
LABEL_62:
        uint64_t v46 = 0;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v47 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v61[0]) = 136315906;
        *(void *)((char *)v61 + 4) = "operator[]";
        WORD2(v61[1]) = 1024;
        *(_DWORD *)((char *)&v61[1] + 6) = 797;
        WORD1(v61[2]) = 2048;
        *(void *)((char *)&v61[2] + 4) = v12;
        WORD2(v61[3]) = 2048;
        *(void *)((char *)&v61[3] + 6) = v13;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_63;
      }
      int v45 = *(_DWORD *)(v10[55] + 4 * v12);
    }
  }
}

void *re::anonymous namespace'::RegisterMapping::processRegister<re::Matrix3x3<float>>(uint64_t a1, unint64_t a2, void *a3)
{
  v63[5] = *MEMORY[0x263EF8340];
  if (*((unsigned char *)result + 40) == 2) {
    return result;
  }
  uint64_t v8 = (int *)result;
  unint64_t v9 = *(unsigned int *)result;
  if ((int)v9 > 7)
  {
    int v25 = *(_DWORD *)result;
    if (*(unsigned char *)(a1 + 3824))
    {
      memset(v63, 0, 32);
      long long v27 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
      uint64_t v28 = *((unsigned __int8 *)v27 + 9);
      if (!*((unsigned char *)v27 + 9))
      {
LABEL_58:
        memset(v62, 0, sizeof(v62));
        v63[v28] = *((void *)v8 + 6);
        uint64_t v40 = *(void *)(a1 + 3848);
        *(void *)&long long v48 = *(void *)(a1 + 3864);
        *((void *)&v48 + 1) = v40;
        uint64_t v41 = *(void *)(a1 + 3888);
        *(void *)&long long v49 = *(void *)(a1 + 3904);
        *((void *)&v49 + 1) = v41;
        uint64_t v42 = *(void *)(a1 + 3928);
        *(void *)&long long v50 = *(void *)(a1 + 3944);
        *((void *)&v50 + 1) = v42;
        uint64_t v43 = *(void *)(a1 + 3968);
        *(void *)&long long v51 = *(void *)(a1 + 3984);
        *((void *)&v51 + 1) = v43;
        uint64_t v44 = *(void *)(a1 + 4008);
        *(void *)&long long v52 = *(void *)(a1 + 4024);
        *((void *)&v52 + 1) = v44;
        uint64_t v45 = *(void *)(a1 + 4048);
        uint64_t v53 = *(void *)(a1 + 4064);
        uint64_t v54 = v45;
        uint64_t v46 = *(void *)(a1 + 4088);
        uint64_t v55 = *(void *)(a1 + 4104);
        uint64_t v56 = v46;
        uint64_t v47 = *(void *)(a1 + 4128);
        uint64_t v57 = *(void *)(a1 + 4144);
        uint64_t v58 = v47;
        uint64_t v60 = 0;
        uint64_t v61 = 0;
        uint64_t v59 = 0;
      }
      uint64_t v29 = 0;
      long long v30 = (char *)v27 + 10;
      while (2)
      {
        uint64_t v31 = v30[v29];
        switch(v30[v29])
        {
          case 0:
            goto LABEL_35;
          case 1:
            goto LABEL_35;
          case 2:
            goto LABEL_35;
          case 3:
            goto LABEL_35;
          case 4:
            goto LABEL_35;
          case 5:
            goto LABEL_35;
          case 6:
            goto LABEL_35;
          case 7:
LABEL_35:
            if (*(unsigned char *)(RegisterMap + 40) != 3) {
              goto LABEL_57;
            }
            v63[v29++] = *(void *)(RegisterMap + 48);
            if (v28 == v29) {
              goto LABEL_58;
            }
            continue;
          default:
            if ((v31 - 253) >= 2)
            {
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1778, v31);
              _os_crash();
              __break(1u);
LABEL_66:
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1823, v37);
              _os_crash();
              __break(1u);
              JUMPOUT(0x23328C920);
            }
LABEL_57:
            if (v28 == v29) {
              goto LABEL_58;
            }
            int v25 = *v8;
            break;
        }
        break;
      }
    }
    if (v25 == 76)
    {
      {
        unint64_t v13 = *((void *)v8 + 1);
        unint64_t v9 = *(void *)(a1 + 216);
        if (v9 <= v13) {
          goto LABEL_64;
        }
        uint64_t v26 = (void *)(*(void *)(a1 + 224) + 904 * v13 + 896);
LABEL_41:
        re::DynamicArray<unsigned long>::add(a3, v26);
      }
    }
    else
    {
      if (v25 != 77)
      {
        long long v33 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
        uint64_t v34 = *((unsigned __int8 *)v33 + 9);
        if (*((unsigned char *)v33 + 9))
        {
          unsigned int v35 = (unint64_t *)(v8 + 2);
          long long v36 = (unsigned __int8 *)v33 + 10;
          while (2)
          {
            unsigned int v38 = *v36++;
            uint64_t v37 = v38;
            switch(v38)
            {
              case 0u:
                goto LABEL_53;
              case 1u:
                goto LABEL_53;
              case 2u:
                goto LABEL_53;
              case 3u:
                goto LABEL_53;
              case 4u:
                goto LABEL_53;
              case 5u:
                goto LABEL_53;
              case 6u:
                goto LABEL_53;
              case 7u:
LABEL_53:
                *(void *)&long long v48 = MappedRegister;
                re::DynamicArray<unsigned long>::add(a3, &v48);
                ++v35;
                if (!--v34) {
                  break;
                }
                continue;
              default:
                goto LABEL_66;
            }
            break;
          }
        }
        re::DynamicArray<unsigned long>::add(a3, &v48);
      }
      {
        unint64_t v13 = *((void *)v8 + 1);
        unint64_t v9 = *(void *)(a1 + 240);
        if (v9 <= v13)
        {
LABEL_63:
          v63[0] = 0;
          long long v51 = 0u;
          long long v52 = 0u;
          long long v49 = 0u;
          long long v50 = 0u;
          long long v48 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v62[0]) = 136315906;
          *(void *)((char *)v62 + 4) = "operator[]";
          WORD6(v62[0]) = 1024;
          *(_DWORD *)((char *)v62 + 14) = 468;
          WORD1(v62[1]) = 2048;
          *(void *)((char *)&v62[1] + 4) = v13;
          WORD6(v62[1]) = 2048;
          *(void *)((char *)&v62[1] + 14) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_64:
          v63[0] = 0;
          long long v51 = 0u;
          long long v52 = 0u;
          long long v49 = 0u;
          long long v50 = 0u;
          long long v48 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v62[0]) = 136315906;
          *(void *)((char *)v62 + 4) = "operator[]";
          WORD6(v62[0]) = 1024;
          *(_DWORD *)((char *)v62 + 14) = 468;
          WORD1(v62[1]) = 2048;
          *(void *)((char *)&v62[1] + 4) = v13;
          WORD6(v62[1]) = 2048;
          *(void *)((char *)&v62[1] + 14) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v26 = (void *)(*(void *)(a1 + 248) + 248 * v13 + 240);
        goto LABEL_41;
      }
    }
  }
  memset(v62, 0, sizeof(v62));
  unint64_t v10 = *(void **)(a1 + 8);
  unint64_t v11 = a2;
  unint64_t v12 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if ((uint64_t)(a2 - 0x7FFFFFFFFFFFFFFFLL) >= 0)
  {
    unint64_t v13 = v10[98];
    while (v13 > v12)
    {
      unint64_t v11 = *(void *)(v10[100] + 8 * v12);
      unint64_t v12 = v11 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_7;
      }
    }
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v48 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v63[0]) = 136315906;
    *(void *)((char *)v63 + 4) = "operator[]";
    WORD2(v63[1]) = 1024;
    *(_DWORD *)((char *)&v63[1] + 6) = 797;
    WORD1(v63[2]) = 2048;
    *(void *)((char *)&v63[2] + 4) = v12;
    WORD2(v63[3]) = 2048;
    *(void *)((char *)&v63[3] + 6) = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_62;
  }
LABEL_7:
  unint64_t v14 = v10[18];
  if (v14)
  {
    long long v15 = (void *)v10[20];
    long long v16 = &v15[v14];
    long long v17 = v15;
    do
    {
      unint64_t v18 = v14 >> 1;
      long long v19 = &v17[v14 >> 1];
      unint64_t v21 = *v19;
      long long v20 = v19 + 1;
      v14 += ~(v14 >> 1);
      if (v21 < v11) {
        long long v17 = v20;
      }
      else {
        unint64_t v14 = v18;
      }
    }
    while (v14);
    if (v17 != v16 && *v17 == v11)
    {
      unint64_t v12 = v17 - v15;
      unint64_t v13 = v10[58];
      if (v13 <= v12)
      {
LABEL_62:
        long long v51 = 0u;
        long long v52 = 0u;
        long long v49 = 0u;
        long long v50 = 0u;
        long long v48 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v63[0]) = 136315906;
        *(void *)((char *)v63 + 4) = "operator[]";
        WORD2(v63[1]) = 1024;
        *(_DWORD *)((char *)&v63[1] + 6) = 797;
        WORD1(v63[2]) = 2048;
        *(void *)((char *)&v63[2] + 4) = v12;
        WORD2(v63[3]) = 2048;
        *(void *)((char *)&v63[3] + 6) = v13;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_63;
      }
      int v22 = (_OWORD *)(v10[60] + 48 * v12);
      long long v24 = v22[1];
      long long v23 = v22[2];
      v62[0] = *v22;
      v62[1] = v24;
      void v62[2] = v23;
    }
  }
}

int *re::anonymous namespace'::RegisterMapping::processRegister<re::Matrix4x4<float>>(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)result + 40) != 2)
  {
    uint64_t v8 = result;
    uint64_t v9 = *result;
    if ((int)v9 <= 7)
    {
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      re::EvaluationTree::getInputValue<re::Matrix4x4<float>>(*(void **)(a1 + 8), a2, &v35);
    }
    int v10 = *result;
    if ((*(unsigned char *)(a1 + 3824) & 1) == 0)
    {
LABEL_5:
      if (v10 == 76)
      {
        {
          unint64_t v11 = *((void *)v8 + 1);
          unint64_t v12 = *(void *)(a1 + 216);
          if (v12 > v11)
          {
            unint64_t v13 = (void *)(*(void *)(a1 + 224) + 904 * v11 + 896);
            goto LABEL_27;
          }
LABEL_48:
          *(void *)&v50[0] = 0;
          long long v38 = 0u;
          long long v39 = 0u;
          long long v36 = 0u;
          long long v37 = 0u;
          long long v35 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v49[0]) = 136315906;
          *(void *)((char *)v49 + 4) = "operator[]";
          WORD6(v49[0]) = 1024;
          *(_DWORD *)((char *)v49 + 14) = 468;
          WORD1(v49[1]) = 2048;
          *(void *)((char *)&v49[1] + 4) = v11;
          WORD6(v49[1]) = 2048;
          *(void *)((char *)&v49[1] + 14) = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
      else
      {
        if (v10 != 77)
        {
          long long v20 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
          uint64_t v21 = *((unsigned __int8 *)v20 + 9);
          if (*((unsigned char *)v20 + 9))
          {
            int v22 = (unint64_t *)(v8 + 2);
            long long v23 = (unsigned __int8 *)v20 + 10;
            while (2)
            {
              unsigned int v25 = *v23++;
              uint64_t v24 = v25;
              switch(v25)
              {
                case 0u:
                  goto LABEL_39;
                case 1u:
                  goto LABEL_39;
                case 2u:
                  goto LABEL_39;
                case 3u:
                  goto LABEL_39;
                case 4u:
                  goto LABEL_39;
                case 5u:
                  goto LABEL_39;
                case 6u:
                  goto LABEL_39;
                case 7u:
LABEL_39:
                  *(void *)&long long v35 = MappedRegister;
                  re::DynamicArray<unsigned long>::add(a3, &v35);
                  ++v22;
                  if (!--v21) {
                    break;
                  }
                  continue;
                default:
                  goto LABEL_50;
              }
              break;
            }
          }
          re::DynamicArray<unsigned long>::add(a3, &v35);
        }
        {
          unint64_t v11 = *((void *)v8 + 1);
          unint64_t v12 = *(void *)(a1 + 240);
          if (v12 > v11)
          {
            unint64_t v13 = (void *)(*(void *)(a1 + 248) + 248 * v11 + 240);
LABEL_27:
            re::DynamicArray<unsigned long>::add(a3, v13);
          }
          *(void *)&v50[0] = 0;
          long long v38 = 0u;
          long long v39 = 0u;
          long long v36 = 0u;
          long long v37 = 0u;
          long long v35 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v49[0]) = 136315906;
          *(void *)((char *)v49 + 4) = "operator[]";
          WORD6(v49[0]) = 1024;
          *(_DWORD *)((char *)v49 + 14) = 468;
          WORD1(v49[1]) = 2048;
          *(void *)((char *)&v49[1] + 4) = v11;
          WORD6(v49[1]) = 2048;
          *(void *)((char *)&v49[1] + 14) = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_48;
        }
      }
    }
    memset(v50, 0, sizeof(v50));
    unint64_t v14 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
    uint64_t v15 = *((unsigned __int8 *)v14 + 9);
    if (*((unsigned char *)v14 + 9))
    {
      uint64_t v16 = 0;
      long long v17 = (char *)v14 + 10;
      while (2)
      {
        uint64_t v18 = v17[v16];
        switch(v17[v16])
        {
          case 0:
            goto LABEL_21;
          case 1:
            goto LABEL_21;
          case 2:
            goto LABEL_21;
          case 3:
            goto LABEL_21;
          case 4:
            goto LABEL_21;
          case 5:
            goto LABEL_21;
          case 6:
            goto LABEL_21;
          case 7:
LABEL_21:
            if (*(unsigned char *)(RegisterMap + 40) != 3) {
              goto LABEL_43;
            }
            *((void *)v50 + v16++) = *(void *)(RegisterMap + 48);
            if (v15 == v16) {
              goto LABEL_44;
            }
            continue;
          default:
            if ((v18 - 253) >= 2)
            {
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1778, v18);
              _os_crash();
              __break(1u);
LABEL_50:
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1823, v24);
              _os_crash();
              __break(1u);
              JUMPOUT(0x23328CFA4);
            }
LABEL_43:
            if (v15 == v16) {
              goto LABEL_44;
            }
            int v10 = *v8;
            break;
        }
        goto LABEL_5;
      }
    }
LABEL_44:
    memset(v49, 0, sizeof(v49));
    *((void *)v50 + v15) = *((void *)v8 + 6);
    uint64_t v27 = *(void *)(a1 + 3848);
    *(void *)&long long v35 = *(void *)(a1 + 3864);
    *((void *)&v35 + 1) = v27;
    uint64_t v28 = *(void *)(a1 + 3888);
    *(void *)&long long v36 = *(void *)(a1 + 3904);
    *((void *)&v36 + 1) = v28;
    uint64_t v29 = *(void *)(a1 + 3928);
    *(void *)&long long v37 = *(void *)(a1 + 3944);
    *((void *)&v37 + 1) = v29;
    uint64_t v30 = *(void *)(a1 + 3968);
    *(void *)&long long v38 = *(void *)(a1 + 3984);
    *((void *)&v38 + 1) = v30;
    uint64_t v31 = *(void *)(a1 + 4008);
    *(void *)&long long v39 = *(void *)(a1 + 4024);
    *((void *)&v39 + 1) = v31;
    uint64_t v32 = *(void *)(a1 + 4048);
    uint64_t v40 = *(void *)(a1 + 4064);
    uint64_t v41 = v32;
    uint64_t v33 = *(void *)(a1 + 4088);
    uint64_t v42 = *(void *)(a1 + 4104);
    uint64_t v43 = v33;
    uint64_t v34 = *(void *)(a1 + 4128);
    uint64_t v44 = *(void *)(a1 + 4144);
    uint64_t v45 = v34;
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    uint64_t v46 = 0;
  }
  return result;
}

int *re::anonymous namespace'::RegisterMapping::processRegister<re::Quaternion<float>>(uint64_t a1, unint64_t a2, void *a3)
{
  v50[5] = *MEMORY[0x263EF8340];
  if (*((unsigned char *)result + 40) != 2)
  {
    uint64_t v8 = result;
    uint64_t v9 = *result;
    if ((int)v9 <= 7)
    {
      long long v36 = xmmword_23435FBB0;
      re::EvaluationTree::getInputValue<re::Quaternion<float>>(*(void **)(a1 + 8), a2, &v36);
    }
    int v10 = *result;
    if ((*(unsigned char *)(a1 + 3824) & 1) == 0)
    {
LABEL_5:
      if (v10 == 76)
      {
        {
          unint64_t v11 = *((void *)v8 + 1);
          unint64_t v12 = *(void *)(a1 + 216);
          if (v12 > v11)
          {
            unint64_t v13 = (void *)(*(void *)(a1 + 224) + 904 * v11 + 896);
            goto LABEL_27;
          }
LABEL_48:
          *(void *)&long long v35 = 0;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v36 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v50[0]) = 136315906;
          *(void *)((char *)v50 + 4) = "operator[]";
          WORD2(v50[1]) = 1024;
          *(_DWORD *)((char *)&v50[1] + 6) = 468;
          WORD1(v50[2]) = 2048;
          *(void *)((char *)&v50[2] + 4) = v11;
          WORD2(v50[3]) = 2048;
          *(void *)((char *)&v50[3] + 6) = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
      else
      {
        if (v10 != 77)
        {
          long long v20 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
          uint64_t v21 = *((unsigned __int8 *)v20 + 9);
          if (*((unsigned char *)v20 + 9))
          {
            int v22 = (unint64_t *)(v8 + 2);
            long long v23 = (unsigned __int8 *)v20 + 10;
            while (2)
            {
              unsigned int v25 = *v23++;
              uint64_t v24 = v25;
              switch(v25)
              {
                case 0u:
                  goto LABEL_39;
                case 1u:
                  goto LABEL_39;
                case 2u:
                  goto LABEL_39;
                case 3u:
                  goto LABEL_39;
                case 4u:
                  goto LABEL_39;
                case 5u:
                  goto LABEL_39;
                case 6u:
                  goto LABEL_39;
                case 7u:
LABEL_39:
                  *(void *)&long long v36 = MappedRegister;
                  re::DynamicArray<unsigned long>::add(a3, &v36);
                  ++v22;
                  if (!--v21) {
                    break;
                  }
                  continue;
                default:
                  goto LABEL_50;
              }
              break;
            }
          }
          re::DynamicArray<unsigned long>::add(a3, &v36);
        }
        {
          unint64_t v11 = *((void *)v8 + 1);
          unint64_t v12 = *(void *)(a1 + 240);
          if (v12 > v11)
          {
            unint64_t v13 = (void *)(*(void *)(a1 + 248) + 248 * v11 + 240);
LABEL_27:
            re::DynamicArray<unsigned long>::add(a3, v13);
          }
          *(void *)&long long v35 = 0;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          long long v36 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v50[0]) = 136315906;
          *(void *)((char *)v50 + 4) = "operator[]";
          WORD2(v50[1]) = 1024;
          *(_DWORD *)((char *)&v50[1] + 6) = 468;
          WORD1(v50[2]) = 2048;
          *(void *)((char *)&v50[2] + 4) = v11;
          WORD2(v50[3]) = 2048;
          *(void *)((char *)&v50[3] + 6) = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_48;
        }
      }
    }
    memset(v50, 0, 32);
    unint64_t v14 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
    uint64_t v15 = *((unsigned __int8 *)v14 + 9);
    if (*((unsigned char *)v14 + 9))
    {
      uint64_t v16 = 0;
      long long v17 = (char *)v14 + 10;
      while (2)
      {
        uint64_t v18 = v17[v16];
        switch(v17[v16])
        {
          case 0:
            goto LABEL_21;
          case 1:
            goto LABEL_21;
          case 2:
            goto LABEL_21;
          case 3:
            goto LABEL_21;
          case 4:
            goto LABEL_21;
          case 5:
            goto LABEL_21;
          case 6:
            goto LABEL_21;
          case 7:
LABEL_21:
            if (*(unsigned char *)(RegisterMap + 40) != 3) {
              goto LABEL_43;
            }
            v50[v16++] = *(void *)(RegisterMap + 48);
            if (v15 == v16) {
              goto LABEL_44;
            }
            continue;
          default:
            if ((v18 - 253) >= 2)
            {
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1778, v18);
              _os_crash();
              __break(1u);
LABEL_50:
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1823, v24);
              _os_crash();
              __break(1u);
              JUMPOUT(0x23328D628);
            }
LABEL_43:
            if (v15 == v16) {
              goto LABEL_44;
            }
            int v10 = *v8;
            break;
        }
        goto LABEL_5;
      }
    }
LABEL_44:
    long long v35 = xmmword_23435FBB0;
    v50[v15] = *((void *)v8 + 6);
    unint64_t v27 = *(void *)(a1 + 3848);
    *(void *)&long long v36 = *(void *)(a1 + 3864);
    *((void *)&v36 + 1) = v27;
    uint64_t v28 = *(void *)(a1 + 3888);
    *(void *)&long long v37 = *(void *)(a1 + 3904);
    *((void *)&v37 + 1) = v28;
    uint64_t v29 = *(void *)(a1 + 3928);
    *(void *)&long long v38 = *(void *)(a1 + 3944);
    *((void *)&v38 + 1) = v29;
    uint64_t v30 = *(void *)(a1 + 3968);
    *(void *)&long long v39 = *(void *)(a1 + 3984);
    *((void *)&v39 + 1) = v30;
    uint64_t v31 = *(void *)(a1 + 4008);
    *(void *)&long long v40 = *(void *)(a1 + 4024);
    *((void *)&v40 + 1) = v31;
    uint64_t v32 = *(void *)(a1 + 4048);
    uint64_t v41 = *(void *)(a1 + 4064);
    uint64_t v42 = v32;
    uint64_t v33 = *(void *)(a1 + 4088);
    uint64_t v43 = *(void *)(a1 + 4104);
    uint64_t v44 = v33;
    uint64_t v34 = *(void *)(a1 + 4128);
    uint64_t v45 = *(void *)(a1 + 4144);
    uint64_t v46 = v34;
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    uint64_t v47 = 0;
  }
  return result;
}

void *re::anonymous namespace'::RegisterMapping::processRegister<re::Vector2<float>>(uint64_t a1, unint64_t a2, void *a3)
{
  v61[5] = *MEMORY[0x263EF8340];
  if (*((unsigned char *)result + 40) == 2) {
    return result;
  }
  uint64_t v8 = (int *)result;
  unint64_t v9 = *(unsigned int *)result;
  if ((int)v9 > 7)
  {
    int v22 = *(_DWORD *)result;
    if (*(unsigned char *)(a1 + 3824))
    {
      memset(v61, 0, 32);
      uint64_t v24 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
      uint64_t v25 = *((unsigned __int8 *)v24 + 9);
      if (!*((unsigned char *)v24 + 9))
      {
LABEL_58:
        uint64_t v46 = 0;
        v61[v25] = *((void *)v8 + 6);
        uint64_t v37 = *(void *)(a1 + 3848);
        *(void *)&long long v47 = *(void *)(a1 + 3864);
        *((void *)&v47 + 1) = v37;
        uint64_t v38 = *(void *)(a1 + 3888);
        *(void *)&long long v48 = *(void *)(a1 + 3904);
        *((void *)&v48 + 1) = v38;
        uint64_t v39 = *(void *)(a1 + 3928);
        *(void *)&long long v49 = *(void *)(a1 + 3944);
        *((void *)&v49 + 1) = v39;
        uint64_t v40 = *(void *)(a1 + 3968);
        *(void *)&long long v50 = *(void *)(a1 + 3984);
        *((void *)&v50 + 1) = v40;
        uint64_t v41 = *(void *)(a1 + 4008);
        *(void *)&long long v51 = *(void *)(a1 + 4024);
        *((void *)&v51 + 1) = v41;
        uint64_t v42 = *(void *)(a1 + 4048);
        uint64_t v52 = *(void *)(a1 + 4064);
        uint64_t v53 = v42;
        uint64_t v43 = *(void *)(a1 + 4088);
        uint64_t v54 = *(void *)(a1 + 4104);
        uint64_t v55 = v43;
        uint64_t v44 = *(void *)(a1 + 4128);
        uint64_t v56 = *(void *)(a1 + 4144);
        uint64_t v57 = v44;
        uint64_t v59 = 0;
        uint64_t v60 = 0;
        uint64_t v58 = 0;
      }
      uint64_t v26 = 0;
      unint64_t v27 = (char *)v24 + 10;
      while (2)
      {
        uint64_t v28 = v27[v26];
        switch(v27[v26])
        {
          case 0:
            goto LABEL_35;
          case 1:
            goto LABEL_35;
          case 2:
            goto LABEL_35;
          case 3:
            goto LABEL_35;
          case 4:
            goto LABEL_35;
          case 5:
            goto LABEL_35;
          case 6:
            goto LABEL_35;
          case 7:
LABEL_35:
            if (*(unsigned char *)(RegisterMap + 40) != 3) {
              goto LABEL_57;
            }
            v61[v26++] = *(void *)(RegisterMap + 48);
            if (v25 == v26) {
              goto LABEL_58;
            }
            continue;
          default:
            if ((v28 - 253) >= 2)
            {
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1778, v28);
              _os_crash();
              __break(1u);
LABEL_66:
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1823, v34);
              _os_crash();
              __break(1u);
              JUMPOUT(0x23328DE9CLL);
            }
LABEL_57:
            if (v25 == v26) {
              goto LABEL_58;
            }
            int v22 = *v8;
            break;
        }
        break;
      }
    }
    if (v22 == 76)
    {
      {
        unint64_t v13 = *((void *)v8 + 1);
        unint64_t v9 = *(void *)(a1 + 216);
        if (v9 <= v13) {
          goto LABEL_64;
        }
        long long v23 = (void *)(*(void *)(a1 + 224) + 904 * v13 + 896);
LABEL_41:
        re::DynamicArray<unsigned long>::add(a3, v23);
      }
    }
    else
    {
      if (v22 != 77)
      {
        uint64_t v30 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
        uint64_t v31 = *((unsigned __int8 *)v30 + 9);
        if (*((unsigned char *)v30 + 9))
        {
          uint64_t v32 = (unint64_t *)(v8 + 2);
          uint64_t v33 = (unsigned __int8 *)v30 + 10;
          while (2)
          {
            unsigned int v35 = *v33++;
            uint64_t v34 = v35;
            switch(v35)
            {
              case 0u:
                goto LABEL_53;
              case 1u:
                goto LABEL_53;
              case 2u:
                goto LABEL_53;
              case 3u:
                goto LABEL_53;
              case 4u:
                goto LABEL_53;
              case 5u:
                goto LABEL_53;
              case 6u:
                goto LABEL_53;
              case 7u:
LABEL_53:
                *(void *)&long long v47 = MappedRegister;
                re::DynamicArray<unsigned long>::add(a3, &v47);
                ++v32;
                if (!--v31) {
                  break;
                }
                continue;
              default:
                goto LABEL_66;
            }
            break;
          }
        }
        re::DynamicArray<unsigned long>::add(a3, &v47);
      }
      {
        unint64_t v13 = *((void *)v8 + 1);
        unint64_t v9 = *(void *)(a1 + 240);
        if (v9 <= v13)
        {
LABEL_63:
          uint64_t v46 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v61[0]) = 136315906;
          *(void *)((char *)v61 + 4) = "operator[]";
          WORD2(v61[1]) = 1024;
          *(_DWORD *)((char *)&v61[1] + 6) = 468;
          WORD1(v61[2]) = 2048;
          *(void *)((char *)&v61[2] + 4) = v13;
          WORD2(v61[3]) = 2048;
          *(void *)((char *)&v61[3] + 6) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_64:
          uint64_t v46 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v47 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v61[0]) = 136315906;
          *(void *)((char *)v61 + 4) = "operator[]";
          WORD2(v61[1]) = 1024;
          *(_DWORD *)((char *)&v61[1] + 6) = 468;
          WORD1(v61[2]) = 2048;
          *(void *)((char *)&v61[2] + 4) = v13;
          WORD2(v61[3]) = 2048;
          *(void *)((char *)&v61[3] + 6) = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        long long v23 = (void *)(*(void *)(a1 + 248) + 248 * v13 + 240);
        goto LABEL_41;
      }
    }
  }
  uint64_t v45 = 0;
  int v10 = *(void **)(a1 + 8);
  unint64_t v11 = a2;
  unint64_t v12 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if ((uint64_t)(a2 - 0x7FFFFFFFFFFFFFFFLL) >= 0)
  {
    unint64_t v13 = v10[113];
    while (v13 > v12)
    {
      unint64_t v11 = *(void *)(v10[115] + 8 * v12);
      unint64_t v12 = v11 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) < 0) {
        goto LABEL_7;
      }
    }
    uint64_t v46 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v47 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v61[0]) = 136315906;
    *(void *)((char *)v61 + 4) = "operator[]";
    WORD2(v61[1]) = 1024;
    *(_DWORD *)((char *)&v61[1] + 6) = 797;
    WORD1(v61[2]) = 2048;
    *(void *)((char *)&v61[2] + 4) = v12;
    WORD2(v61[3]) = 2048;
    *(void *)((char *)&v61[3] + 6) = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_62;
  }
LABEL_7:
  unint64_t v14 = v10[33];
  if (v14)
  {
    uint64_t v15 = (void *)v10[35];
    uint64_t v16 = &v15[v14];
    long long v17 = v15;
    do
    {
      unint64_t v18 = v14 >> 1;
      long long v19 = &v17[v14 >> 1];
      unint64_t v21 = *v19;
      long long v20 = v19 + 1;
      v14 += ~(v14 >> 1);
      if (v21 < v11) {
        long long v17 = v20;
      }
      else {
        unint64_t v14 = v18;
      }
    }
    while (v14);
    if (v17 != v16 && *v17 == v11)
    {
      unint64_t v12 = v17 - v15;
      unint64_t v13 = v10[73];
      if (v13 <= v12)
      {
LABEL_62:
        uint64_t v46 = 0;
        long long v50 = 0u;
        long long v51 = 0u;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v47 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v61[0]) = 136315906;
        *(void *)((char *)v61 + 4) = "operator[]";
        WORD2(v61[1]) = 1024;
        *(_DWORD *)((char *)&v61[1] + 6) = 797;
        WORD1(v61[2]) = 2048;
        *(void *)((char *)&v61[2] + 4) = v12;
        WORD2(v61[3]) = 2048;
        *(void *)((char *)&v61[3] + 6) = v13;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_63;
      }
      uint64_t v45 = *(void *)(v10[75] + 8 * v12);
    }
  }
}

int *re::anonymous namespace'::RegisterMapping::processRegister<re::Vector3<float>>(uint64_t a1, unint64_t a2, void *a3)
{
  v50[5] = *MEMORY[0x263EF8340];
  if (*((unsigned char *)result + 40) != 2)
  {
    uint64_t v8 = result;
    uint64_t v9 = *result;
    if ((int)v9 <= 7)
    {
      __n128 v36 = 0u;
      re::EvaluationTree::getInputValue<re::Vector3<float>>(*(void **)(a1 + 8), a2, &v36);
    }
    int v10 = *result;
    if ((*(unsigned char *)(a1 + 3824) & 1) == 0)
    {
LABEL_5:
      if (v10 == 76)
      {
        {
          unint64_t v11 = *((void *)v8 + 1);
          unint64_t v12 = *(void *)(a1 + 216);
          if (v12 > v11)
          {
            unint64_t v13 = (void *)(*(void *)(a1 + 224) + 904 * v11 + 896);
            goto LABEL_27;
          }
LABEL_48:
          v35.n128_u64[0] = 0;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          __n128 v36 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v50[0]) = 136315906;
          *(void *)((char *)v50 + 4) = "operator[]";
          WORD2(v50[1]) = 1024;
          *(_DWORD *)((char *)&v50[1] + 6) = 468;
          WORD1(v50[2]) = 2048;
          *(void *)((char *)&v50[2] + 4) = v11;
          WORD2(v50[3]) = 2048;
          *(void *)((char *)&v50[3] + 6) = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
      else
      {
        if (v10 != 77)
        {
          long long v20 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
          uint64_t v21 = *((unsigned __int8 *)v20 + 9);
          if (*((unsigned char *)v20 + 9))
          {
            int v22 = (unint64_t *)(v8 + 2);
            long long v23 = (unsigned __int8 *)v20 + 10;
            while (2)
            {
              unsigned int v25 = *v23++;
              uint64_t v24 = v25;
              switch(v25)
              {
                case 0u:
                  goto LABEL_39;
                case 1u:
                  goto LABEL_39;
                case 2u:
                  goto LABEL_39;
                case 3u:
                  goto LABEL_39;
                case 4u:
                  goto LABEL_39;
                case 5u:
                  goto LABEL_39;
                case 6u:
                  goto LABEL_39;
                case 7u:
LABEL_39:
                  v36.n128_u64[0] = MappedRegister;
                  re::DynamicArray<unsigned long>::add(a3, &v36);
                  ++v22;
                  if (!--v21) {
                    break;
                  }
                  continue;
                default:
                  goto LABEL_50;
              }
              break;
            }
          }
          re::DynamicArray<unsigned long>::add(a3, &v36);
        }
        {
          unint64_t v11 = *((void *)v8 + 1);
          unint64_t v12 = *(void *)(a1 + 240);
          if (v12 > v11)
          {
            unint64_t v13 = (void *)(*(void *)(a1 + 248) + 248 * v11 + 240);
LABEL_27:
            re::DynamicArray<unsigned long>::add(a3, v13);
          }
          v35.n128_u64[0] = 0;
          long long v39 = 0u;
          long long v40 = 0u;
          long long v37 = 0u;
          long long v38 = 0u;
          __n128 v36 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v50[0]) = 136315906;
          *(void *)((char *)v50 + 4) = "operator[]";
          WORD2(v50[1]) = 1024;
          *(_DWORD *)((char *)&v50[1] + 6) = 468;
          WORD1(v50[2]) = 2048;
          *(void *)((char *)&v50[2] + 4) = v11;
          WORD2(v50[3]) = 2048;
          *(void *)((char *)&v50[3] + 6) = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_48;
        }
      }
    }
    memset(v50, 0, 32);
    unint64_t v14 = &(&re::kEvaluationCommandDescriptions)[2 * v9];
    uint64_t v15 = *((unsigned __int8 *)v14 + 9);
    if (*((unsigned char *)v14 + 9))
    {
      uint64_t v16 = 0;
      long long v17 = (char *)v14 + 10;
      while (2)
      {
        uint64_t v18 = v17[v16];
        switch(v17[v16])
        {
          case 0:
            goto LABEL_21;
          case 1:
            goto LABEL_21;
          case 2:
            goto LABEL_21;
          case 3:
            goto LABEL_21;
          case 4:
            goto LABEL_21;
          case 5:
            goto LABEL_21;
          case 6:
            goto LABEL_21;
          case 7:
LABEL_21:
            if (*(unsigned char *)(RegisterMap + 40) != 3) {
              goto LABEL_43;
            }
            v50[v16++] = *(void *)(RegisterMap + 48);
            if (v15 == v16) {
              goto LABEL_44;
            }
            continue;
          default:
            if ((v18 - 253) >= 2)
            {
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1778, v18);
              _os_crash();
              __break(1u);
LABEL_50:
              re::internal::assertLog((re::internal *)5, v7, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "processRegister", 1823, v24);
              _os_crash();
              __break(1u);
              JUMPOUT(0x23328E518);
            }
LABEL_43:
            if (v15 == v16) {
              goto LABEL_44;
            }
            int v10 = *v8;
            break;
        }
        goto LABEL_5;
      }
    }
LABEL_44:
    __n128 v35 = 0u;
    v50[v15] = *((void *)v8 + 6);
    unint64_t v27 = *(void *)(a1 + 3848);
    v36.n128_u64[0] = *(void *)(a1 + 3864);
    v36.n128_u64[1] = v27;
    uint64_t v28 = *(void *)(a1 + 3888);
    *(void *)&long long v37 = *(void *)(a1 + 3904);
    *((void *)&v37 + 1) = v28;
    uint64_t v29 = *(void *)(a1 + 3928);
    *(void *)&long long v38 = *(void *)(a1 + 3944);
    *((void *)&v38 + 1) = v29;
    uint64_t v30 = *(void *)(a1 + 3968);
    *(void *)&long long v39 = *(void *)(a1 + 3984);
    *((void *)&v39 + 1) = v30;
    uint64_t v31 = *(void *)(a1 + 4008);
    *(void *)&long long v40 = *(void *)(a1 + 4024);
    *((void *)&v40 + 1) = v31;
    uint64_t v32 = *(void *)(a1 + 4048);
    uint64_t v41 = *(void *)(a1 + 4064);
    uint64_t v42 = v32;
    uint64_t v33 = *(void *)(a1 + 4088);
    uint64_t v43 = *(void *)(a1 + 4104);
    uint64_t v44 = v33;
    uint64_t v34 = *(void *)(a1 + 4128);
    uint64_t v45 = *(void *)(a1 + 4144);
    uint64_t v46 = v34;
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    uint64_t v47 = 0;
  }
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::EvaluationCommand>::add(_anonymous_namespace_ *result, _DWORD *a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *((void *)result + 1);
  unint64_t v5 = *((void *)result + 2);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)result)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::EvaluationCommand>::setCapacity(result, v10);
      }
      else
      {
        uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<re::EvaluationCommand>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    unint64_t v5 = *((void *)v3 + 2);
  }
  *(_DWORD *)(*((void *)v3 + 4) + 4 * v5) = *a2;
  *((void *)v3 + 2) = v5 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::getRegisterMapData<re::Vector3<float>>(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 192) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 200) + (a2 << 6);
}

uint64_t re::anonymous namespace'::RegisterMapping::getMappedRegisterValue<re::Vector3<float>>(void *a1, unint64_t a2)
{
  if (a1[24] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = a1[25] + (a2 << 6);
  uint64_t v5 = *(void *)(v2 + 56);
  unint64_t v4 = (void *)(v2 + 56);
  uint64_t v3 = v5;
  if (v5 == -1)
  {
    uint64_t v3 = a1[526];
    a1[526] = v3 + 1;
    *unint64_t v4 = v3;
  }
  return v3;
}

uint64_t re::anonymous namespace'::RegisterMapping::getRegisterMapData<re::Quaternion<float>>(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 144) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 152) + (a2 << 6);
}

uint64_t re::anonymous namespace'::RegisterMapping::getMappedRegisterValue<re::Quaternion<float>>(void *a1, unint64_t a2)
{
  if (a1[18] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = a1[19] + (a2 << 6);
  uint64_t v5 = *(void *)(v2 + 56);
  unint64_t v4 = (void *)(v2 + 56);
  uint64_t v3 = v5;
  if (v5 == -1)
  {
    uint64_t v3 = a1[524];
    a1[524] = v3 + 1;
    *unint64_t v4 = v3;
  }
  return v3;
}

uint64_t re::FixedArray<re::anonymous namespace'::RegisterMapping::RegisterMapData>::init<>(uint64_t result, uint64_t a2, unint64_t a3)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  if (!a3) {
    return result;
  }
  if (a3 >> 58)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 64, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  uint64_t v4 = result;
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, a3 << 6, 8);
  *(void *)(v4 + 16) = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v6 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *(void *)uint64_t result = 0xFFFFFFFFLL;
      *(_OWORD *)(result + 8) = 0uLL;
      *(_OWORD *)(result + 24) = 0uLL;
      *(unsigned char *)(result + 40) = 0;
      *(void *)(result + 48) = -1;
      *(void *)(result + 56) = -1;
      result += 64;
      --v6;
    }
    while (v6);
  }
  *(void *)uint64_t result = 0xFFFFFFFFLL;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(unsigned char *)(result + 40) = 0;
  *(void *)(result + 48) = -1;
  *(void *)(result + 56) = -1;
  return result;
}

uint64_t re::EvaluationDependencyMap::isRegisterUsed(uint64_t a1, unsigned int a2, unint64_t a3)
{
  if (*(void *)(a1 + 24 * a2 + 8) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(unsigned __int8 *)(*(void *)(a1 + 24 * a2 + 16) + a3);
}

void *re::anonymous namespace'::RegisterMapping::enqueueRegisterForProcessing(void *result, unsigned int a2, unint64_t a3)
{
  if (result[3 * a2 + 3] <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  char v4 = a2;
  uint64_t v5 = result;
  uint64_t v6 = result[3 * a2 + 4];
  uint64_t v7 = (unsigned int *)(v6 + (a3 << 6));
  unsigned int v8 = *v7;
  unint64_t v9 = &result[5 * *v7 + 85];
  unint64_t v10 = *v9;
  if (!*v9)
  {
    uint64_t result = re::DynamicArray<re::EvaluationCommand>::add((_anonymous_namespace_ *)(result + 473), v7);
    unint64_t v10 = *v9;
  }
  unint64_t v11 = &v5[5 * v8];
  unint64_t v12 = v11[84];
  if (v10 >= v12)
  {
    unint64_t v13 = v10 + 1;
    if (v12 < v10 + 1)
    {
      unint64_t v14 = v11 + 83;
      if (v11[83])
      {
        unint64_t v15 = 2 * v12;
        if (!v12) {
          unint64_t v15 = 8;
        }
        if (v15 <= v13) {
          unint64_t v16 = v13;
        }
        else {
          unint64_t v16 = v15;
        }
        uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(v11 + 83, v16);
      }
      else
      {
        uint64_t result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(v14, v13);
        ++LODWORD(v5[5 * v8 + 86]);
      }
    }
    unint64_t v10 = *v9;
  }
  long long v17 = &v5[5 * v8];
  uint64_t v18 = v17[87] + 16 * v10;
  *(unsigned char *)uint64_t v18 = v4;
  *(void *)(v18 + 8) = a3;
  ++*v9;
  ++*((_DWORD *)v17 + 172);
  *(unsigned char *)(v6 + (a3 << 6) + 40) = 1;
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::getRegisterMapData<int>(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 24) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 32) + (a2 << 6);
}

void *re::anonymous namespace'::RegisterMapping::allocateConstRegister<int>(void *a1, _DWORD *a2, unint64_t a3)
{
  re::DynamicArray<int>::add(a1 + 479, a2);
  if (a1[3] <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(a1[4] + (a3 << 6) + 48) = a1[481] - 1;
}

BOOL re::anonymous namespace'::RegisterMapping::mapCallbackData(re::_anonymous_namespace_::RegisterMapping *this, unint64_t a2)
{
  if (*((void *)this + 27) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v3 = *((void *)this + 28);
  uint64_t v4 = v3 + 904 * a2;
  uint64_t v5 = *(void *)(v4 + 896);
  if (v5 == -1)
  {
    uint64_t v6 = (void *)(v3 + 904 * a2);
    uint64_t v7 = *((void *)this + 527);
    *((void *)this + 527) = v7 + 1;
    *(void *)(v4 + 896) = v7;
    v6[56] = *v6;
    v6[111] = v6[55];
  }
  return v5 == -1;
}

BOOL re::anonymous namespace'::RegisterMapping::mapBranchGroup(re::_anonymous_namespace_::RegisterMapping *this, unint64_t a2)
{
  unint64_t v3 = a2;
  if (*((void *)this + 30) <= a2)
  {
LABEL_61:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_62:
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 200, v2);
    _os_crash();
    __break(1u);
LABEL_63:
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = *((void *)this + 31);
  uint64_t v6 = (void *)(v5 + 248 * a2);
  unint64_t v2 = v6[30];
  if (v2 != -1) {
    return v2 == -1;
  }
  uint64_t v7 = *((void *)this + 528);
  *((void *)this + 528) = v7 + 1;
  v6[30] = v7;
  unsigned int v8 = (void *)re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[](*((void *)this + 1) + 1608, a2);
  unint64_t v2 = v8[5];
  uint64_t v64 = v5;
  uint64_t v9 = v5 + 248 * v3;
  uint64_t v10 = *(void *)this;
  *(void *)(v9 + 32) = v2;
  unint64_t v11 = (unint64_t *)(v9 + 32);
  *(v11 - 1) = v10;
  if (!v2) {
    goto LABEL_18;
  }
  if (v2 >= 0x147AE147AE147AFLL) {
    goto LABEL_62;
  }
  unint64_t v12 = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v10 + 32))(v10, 200 * v2, 8);
  unint64_t v63 = v3;
  uint64_t v14 = v5 + 248 * v3;
  *(void *)(v14 + 40) = v12;
  unint64_t v15 = (uint64_t *)(v14 + 40);
  if (!v12) {
    goto LABEL_63;
  }
  unint64_t v16 = v2 - 1;
  if (v2 == 1)
  {
    *unint64_t v12 = -1;
    long long v17 = v12 + 1;
  }
  else
  {
    long long v17 = v12 + 1;
    do
    {
      *((void *)v17 - 1) = -1;
      *long long v17 = 0uLL;
      v17[1] = 0uLL;
      uint64_t v17[2] = 0uLL;
      v17[3] = 0uLL;
      v17[4] = 0uLL;
      v17[5] = 0uLL;
      v17[6] = 0uLL;
      v17[7] = 0uLL;
      v17[8] = 0uLL;
      v17[9] = 0uLL;
      v17[10] = 0uLL;
      v17[11] = 0uLL;
      long long v17 = (_OWORD *)((char *)v17 + 200);
      --v16;
    }
    while (v16);
    *((void *)v17 - 1) = -1;
  }
  uint64_t v18 = 0;
  unint64_t v19 = 0;
  v17[10] = 0u;
  v17[11] = 0u;
  v17[8] = 0u;
  v17[9] = 0u;
  v17[6] = 0u;
  v17[7] = 0u;
  v17[4] = 0u;
  v17[5] = 0u;
  uint64_t v17[2] = 0u;
  v17[3] = 0u;
  *long long v17 = 0u;
  v17[1] = 0u;
  do
  {
    if (v6[1] <= v19)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_52:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_53:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_54:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_55:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_56:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_57:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_58:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_59:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_60:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_61;
    }
    if (*v11 <= v19) {
      goto LABEL_52;
    }
    uint64_t v20 = v6[2];
    uint64_t v21 = *v15;
    unint64_t v22 = *(void *)(v20 + v18);
    if (v22 != -1) {
    uint64_t v23 = v20 + v18 + 8;
    }
    uint64_t v24 = (void *)(v21 + v18 + 8);
    ++v19;
    v18 += 200;
  }
  while (v2 != v19);
  uint64_t v10 = *(void *)this;
  unint64_t v3 = v63;
LABEL_18:
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)(v64 + 248 * v3 + 48), v10, v8[9]);
  unint64_t v2 = -1;
  if (v8[9])
  {
    unint64_t v25 = 0;
    do
    {
      if (*(void *)(v64 + 248 * v3 + 56) <= v25) {
        goto LABEL_53;
      }
      *(void *)(*(void *)(v64 + 248 * v3 + 64) + 8 * v25++) = MappedRegister;
    }
    while (v25 < v8[9]);
  }
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)(v64 + 248 * v3 + 72), *(void *)this, v8[14]);
  if (v8[14])
  {
    unint64_t v27 = 0;
    uint64_t v28 = v64 + 248 * v3;
    uint64_t v29 = (unint64_t *)(v28 + 80);
    uint64_t v30 = (void *)(v28 + 88);
    do
    {
      if (*v29 <= v27) {
        goto LABEL_54;
      }
      *(void *)(*v30 + 8 * v27++) = v31;
    }
    while (v27 < v8[14]);
  }
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)(v64 + 248 * v3 + 96), *(void *)this, v8[19]);
  if (v8[19])
  {
    unint64_t v32 = 0;
    uint64_t v33 = v64 + 248 * v3;
    uint64_t v34 = (unint64_t *)(v33 + 104);
    __n128 v35 = (void *)(v33 + 112);
    do
    {
      if (*v34 <= v32) {
        goto LABEL_55;
      }
      *(void *)(*v35 + 8 * v32++) = v36;
    }
    while (v32 < v8[19]);
  }
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)(v64 + 248 * v3 + 120), *(void *)this, v8[24]);
  if (v8[24])
  {
    unint64_t v37 = 0;
    uint64_t v38 = v64 + 248 * v3;
    long long v39 = (unint64_t *)(v38 + 128);
    long long v40 = (void *)(v38 + 136);
    do
    {
      if (*v39 <= v37) {
        goto LABEL_56;
      }
      *(void *)(*v40 + 8 * v37++) = v41;
    }
    while (v37 < v8[24]);
  }
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)(v64 + 248 * v3 + 144), *(void *)this, v8[29]);
  if (v8[29])
  {
    unint64_t v42 = 0;
    uint64_t v43 = v64 + 248 * v3;
    uint64_t v44 = (unint64_t *)(v43 + 152);
    uint64_t v45 = (void *)(v43 + 160);
    do
    {
      if (*v44 <= v42) {
        goto LABEL_57;
      }
      *(void *)(*v45 + 8 * v42++) = v46;
    }
    while (v42 < v8[29]);
  }
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)(v64 + 248 * v3 + 168), *(void *)this, v8[34]);
  if (v8[34])
  {
    unint64_t v47 = 0;
    uint64_t v48 = v64 + 248 * v3;
    uint64_t v49 = (unint64_t *)(v48 + 176);
    long long v50 = (void *)(v48 + 184);
    do
    {
      if (*v49 <= v47) {
        goto LABEL_58;
      }
      *(void *)(*v50 + 8 * v47++) = v51;
    }
    while (v47 < v8[34]);
  }
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)(v64 + 248 * v3 + 192), *(void *)this, v8[39]);
  if (v8[39])
  {
    unint64_t v52 = 0;
    uint64_t v53 = v64 + 248 * v3;
    uint64_t v54 = (unint64_t *)(v53 + 200);
    uint64_t v55 = (void *)(v53 + 208);
    do
    {
      if (*v54 <= v52) {
        goto LABEL_59;
      }
      *(void *)(*v55 + 8 * v52++) = v56;
    }
    while (v52 < v8[39]);
  }
  re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)(v64 + 248 * v3 + 216), *(void *)this, v8[44]);
  if (v8[44])
  {
    unint64_t v57 = 0;
    uint64_t v58 = v64 + 248 * v3;
    uint64_t v59 = (unint64_t *)(v58 + 224);
    uint64_t v60 = (void *)(v58 + 232);
    while (1)
    {
      if (*v59 <= v57) {
        break;
      }
      *(void *)(*v60 + 8 * v57++) = v61;
      if (v57 >= v8[44]) {
        return v2 == -1;
      }
    }
    goto LABEL_60;
  }
  return v2 == -1;
}

uint64_t re::anonymous namespace'::RegisterMapping::getMappedRegisterValue<int>(void *a1, unint64_t a2)
{
  if (a1[3] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = a1[4] + (a2 << 6);
  uint64_t v5 = *(void *)(v2 + 56);
  uint64_t v4 = (void *)(v2 + 56);
  uint64_t v3 = v5;
  if (v5 == -1)
  {
    uint64_t v3 = a1[519];
    a1[519] = v3 + 1;
    *uint64_t v4 = v3;
  }
  return v3;
}

uint64_t re::anonymous namespace'::RegisterMapping::getRegisterMapData<unsigned int>(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 48) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 56) + (a2 << 6);
}

uint64_t re::anonymous namespace'::RegisterMapping::getRegisterMapData<float>(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 72) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 80) + (a2 << 6);
}

uint64_t re::anonymous namespace'::RegisterMapping::getRegisterMapData<re::Matrix3x3<float>>(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 96) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 104) + (a2 << 6);
}

uint64_t re::anonymous namespace'::RegisterMapping::getRegisterMapData<re::Matrix4x4<float>>(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 120) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 128) + (a2 << 6);
}

uint64_t re::anonymous namespace'::RegisterMapping::getRegisterMapData<re::Vector2<float>>(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 168) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 176) + (a2 << 6);
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisters<int,re::FixedRegisterIdTable>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3, *a1, *(void *)(a2 + 8));
  if (*(void *)(a2 + 8))
  {
    unint64_t v7 = 0;
    do
    {
      if (a3[1] <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(a3[2] + 8 * v7++) = result;
    }
    while (v7 < *(void *)(a2 + 8));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisters<unsigned int,re::FixedRegisterIdTable>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 3, *a1, *(void *)(a2 + 32));
  if (*(void *)(a2 + 32))
  {
    unint64_t v7 = 0;
    do
    {
      if (a3[4] <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(a3[5] + 8 * v7++) = result;
    }
    while (v7 < *(void *)(a2 + 32));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisters<float,re::FixedRegisterIdTable>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 6, *a1, *(void *)(a2 + 56));
  if (*(void *)(a2 + 56))
  {
    unint64_t v7 = 0;
    do
    {
      if (a3[7] <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(a3[8] + 8 * v7++) = result;
    }
    while (v7 < *(void *)(a2 + 56));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisters<re::Matrix3x3<float>,re::FixedRegisterIdTable>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 9, *a1, *(void *)(a2 + 80));
  if (*(void *)(a2 + 80))
  {
    unint64_t v7 = 0;
    do
    {
      if (a3[10] <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(a3[11] + 8 * v7++) = result;
    }
    while (v7 < *(void *)(a2 + 80));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisters<re::Matrix4x4<float>,re::FixedRegisterIdTable>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 12, *a1, *(void *)(a2 + 104));
  if (*(void *)(a2 + 104))
  {
    unint64_t v7 = 0;
    do
    {
      if (a3[13] <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(a3[14] + 8 * v7++) = result;
    }
    while (v7 < *(void *)(a2 + 104));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisters<re::Quaternion<float>,re::FixedRegisterIdTable>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 15, *a1, *(void *)(a2 + 128));
  if (*(void *)(a2 + 128))
  {
    unint64_t v7 = 0;
    do
    {
      if (a3[16] <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(a3[17] + 8 * v7++) = result;
    }
    while (v7 < *(void *)(a2 + 128));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisters<re::Vector2<float>,re::FixedRegisterIdTable>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 18, *a1, *(void *)(a2 + 152));
  if (*(void *)(a2 + 152))
  {
    unint64_t v7 = 0;
    do
    {
      if (a3[19] <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(a3[20] + 8 * v7++) = result;
    }
    while (v7 < *(void *)(a2 + 152));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisters<re::Vector3<float>,re::FixedRegisterIdTable>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 21, *a1, *(void *)(a2 + 176));
  if (*(void *)(a2 + 176))
  {
    unint64_t v7 = 0;
    do
    {
      if (a3[22] <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(a3[23] + 8 * v7++) = result;
    }
    while (v7 < *(void *)(a2 + 176));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisterArray(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationSRT>::init<>(a3, *a1, *(void *)(a2 + 8));
  if (*(void *)(a2 + 8))
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    while (1)
    {
      if (a3[1] <= v8) {
        break;
      }
      *(void *)(a3[2] + v7) = v9;
      if (*(void *)(a2 + 8) <= v8) {
        goto LABEL_11;
      }
      if (a3[1] <= v8) {
        goto LABEL_12;
      }
      *(void *)(a3[2] + v7 + 8) = v10;
      if (*(void *)(a2 + 8) <= v8) {
        goto LABEL_13;
      }
      if (a3[1] <= v8) {
        goto LABEL_14;
      }
      *(void *)(a3[2] + v7 + 16) = result;
      ++v8;
      v7 += 24;
      if (v8 >= *(void *)(a2 + 8)) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_11:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_12:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_14:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::getMappedRegisterValue<unsigned int>(void *a1, unint64_t a2)
{
  if (a1[6] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = a1[7] + (a2 << 6);
  uint64_t v5 = *(void *)(v2 + 56);
  uint64_t v4 = (void *)(v2 + 56);
  uint64_t v3 = v5;
  if (v5 == -1)
  {
    uint64_t v3 = a1[520];
    a1[520] = v3 + 1;
    *uint64_t v4 = v3;
  }
  return v3;
}

uint64_t re::anonymous namespace'::RegisterMapping::getMappedRegisterValue<float>(void *a1, unint64_t a2)
{
  if (a1[9] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = a1[10] + (a2 << 6);
  uint64_t v5 = *(void *)(v2 + 56);
  uint64_t v4 = (void *)(v2 + 56);
  uint64_t v3 = v5;
  if (v5 == -1)
  {
    uint64_t v3 = a1[521];
    a1[521] = v3 + 1;
    *uint64_t v4 = v3;
  }
  return v3;
}

uint64_t re::anonymous namespace'::RegisterMapping::getMappedRegisterValue<re::Matrix3x3<float>>(void *a1, unint64_t a2)
{
  if (a1[12] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = a1[13] + (a2 << 6);
  uint64_t v5 = *(void *)(v2 + 56);
  uint64_t v4 = (void *)(v2 + 56);
  uint64_t v3 = v5;
  if (v5 == -1)
  {
    uint64_t v3 = a1[522];
    a1[522] = v3 + 1;
    *uint64_t v4 = v3;
  }
  return v3;
}

uint64_t re::anonymous namespace'::RegisterMapping::getMappedRegisterValue<re::Matrix4x4<float>>(void *a1, unint64_t a2)
{
  if (a1[15] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = a1[16] + (a2 << 6);
  uint64_t v5 = *(void *)(v2 + 56);
  uint64_t v4 = (void *)(v2 + 56);
  uint64_t v3 = v5;
  if (v5 == -1)
  {
    uint64_t v3 = a1[523];
    a1[523] = v3 + 1;
    *uint64_t v4 = v3;
  }
  return v3;
}

uint64_t re::anonymous namespace'::RegisterMapping::getMappedRegisterValue<re::Vector2<float>>(void *a1, unint64_t a2)
{
  if (a1[21] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v2 = a1[22] + (a2 << 6);
  uint64_t v5 = *(void *)(v2 + 56);
  uint64_t v4 = (void *)(v2 + 56);
  uint64_t v3 = v5;
  if (v5 == -1)
  {
    uint64_t v3 = a1[525];
    a1[525] = v3 + 1;
    *uint64_t v4 = v3;
  }
  return v3;
}

void *re::anonymous namespace'::RegisterMapping::allocateConstRegister<unsigned int>(void *a1, _DWORD *a2, unint64_t a3)
{
  re::DynamicArray<int>::add(a1 + 484, a2);
  if (a1[6] <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(a1[7] + (a3 << 6) + 48) = a1[486] - 1;
}

void *re::anonymous namespace'::RegisterMapping::allocateConstRegister<float>(void *a1, float *a2, unint64_t a3)
{
  re::DynamicArray<float>::add((_anonymous_namespace_ *)(a1 + 489), a2);
  if (a1[9] <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(a1[10] + (a3 << 6) + 48) = a1[491] - 1;
}

void *re::anonymous namespace'::RegisterMapping::allocateConstRegister<re::Matrix3x3<float>>(void *a1, uint64_t a2, unint64_t a3)
{
  re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(a1 + 494), a2);
  if (a1[12] <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(a1[13] + (a3 << 6) + 48) = a1[496] - 1;
}

void *re::anonymous namespace'::RegisterMapping::allocateConstRegister<re::Matrix4x4<float>>(void *a1, uint64_t a2, unint64_t a3)
{
  re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(a1 + 499), a2);
  if (a1[15] <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(a1[16] + (a3 << 6) + 48) = a1[501] - 1;
}

void *re::anonymous namespace'::RegisterMapping::allocateConstRegister<re::Quaternion<float>>(void *a1, __n128 *a2, unint64_t a3)
{
  re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(a1 + 504), a2);
  if (a1[18] <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(a1[19] + (a3 << 6) + 48) = a1[506] - 1;
}

void *re::anonymous namespace'::RegisterMapping::allocateConstRegister<re::Vector2<float>>(void *a1, void *a2, unint64_t a3)
{
  re::DynamicArray<unsigned long>::add(a1 + 509, a2);
  if (a1[21] <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(a1[22] + (a3 << 6) + 48) = a1[511] - 1;
}

void *re::anonymous namespace'::RegisterMapping::allocateConstRegister<re::Vector3<float>>(void *a1, __n128 *a2, unint64_t a3)
{
  re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(a1 + 514), a2);
  if (a1[24] <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(a1[25] + (a3 << 6) + 48) = a1[516] - 1;
}

void *re::anonymous namespace'::RegisterMapping::initMappedRegisters<int>(uint64_t *a1, uint64_t *a2, void *a3)
{
  uint64_t result = re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3, *a1, a2[1]);
  if (a2[1])
  {
    unint64_t v7 = 0;
    uint64_t v8 = *a2;
    uint64_t v9 = a3[2];
    do
    {
      unint64_t v10 = *(void *)(v8 + 8 * v7);
      if (a1[3] <= v10)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (a3[1] <= v7) {
        goto LABEL_8;
      }
      *(void *)(v9 + 8 * v7++) = *(void *)(a1[4] + (v10 << 6) + 56);
    }
    while (v7 < a2[1]);
  }
  return result;
}

void *re::anonymous namespace'::RegisterMapping::initMappedRegisters<unsigned int>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 3, *a1, *(void *)(a2 + 24));
  if (*(void *)(a2 + 24))
  {
    unint64_t v7 = 0;
    uint64_t v8 = *(void *)(a2 + 16);
    uint64_t v9 = a3[5];
    do
    {
      unint64_t v10 = *(void *)(v8 + 8 * v7);
      if (a1[6] <= v10)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (a3[4] <= v7) {
        goto LABEL_8;
      }
      *(void *)(v9 + 8 * v7++) = *(void *)(a1[7] + (v10 << 6) + 56);
    }
    while (v7 < *(void *)(a2 + 24));
  }
  return result;
}

void *re::anonymous namespace'::RegisterMapping::initMappedRegisters<float>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 6, *a1, *(void *)(a2 + 40));
  if (*(void *)(a2 + 40))
  {
    unint64_t v7 = 0;
    uint64_t v8 = *(void *)(a2 + 32);
    uint64_t v9 = a3[8];
    do
    {
      unint64_t v10 = *(void *)(v8 + 8 * v7);
      if (a1[9] <= v10)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (a3[7] <= v7) {
        goto LABEL_8;
      }
      *(void *)(v9 + 8 * v7++) = *(void *)(a1[10] + (v10 << 6) + 56);
    }
    while (v7 < *(void *)(a2 + 40));
  }
  return result;
}

void *re::anonymous namespace'::RegisterMapping::initMappedRegisters<re::Matrix3x3<float>>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 9, *a1, *(void *)(a2 + 56));
  if (*(void *)(a2 + 56))
  {
    unint64_t v7 = 0;
    uint64_t v8 = *(void *)(a2 + 48);
    uint64_t v9 = a3[11];
    do
    {
      unint64_t v10 = *(void *)(v8 + 8 * v7);
      if (a1[12] <= v10)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (a3[10] <= v7) {
        goto LABEL_8;
      }
      *(void *)(v9 + 8 * v7++) = *(void *)(a1[13] + (v10 << 6) + 56);
    }
    while (v7 < *(void *)(a2 + 56));
  }
  return result;
}

void *re::anonymous namespace'::RegisterMapping::initMappedRegisters<re::Matrix4x4<float>>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 12, *a1, *(void *)(a2 + 72));
  if (*(void *)(a2 + 72))
  {
    unint64_t v7 = 0;
    uint64_t v8 = *(void *)(a2 + 64);
    uint64_t v9 = a3[14];
    do
    {
      unint64_t v10 = *(void *)(v8 + 8 * v7);
      if (a1[15] <= v10)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (a3[13] <= v7) {
        goto LABEL_8;
      }
      *(void *)(v9 + 8 * v7++) = *(void *)(a1[16] + (v10 << 6) + 56);
    }
    while (v7 < *(void *)(a2 + 72));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisters<re::Quaternion<float>>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 15, *a1, *(void *)(a2 + 88));
  if (*(void *)(a2 + 88))
  {
    unint64_t v7 = 0;
    do
    {
      if (a3[16] <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(a3[17] + 8 * v7++) = result;
    }
    while (v7 < *(void *)(a2 + 88));
  }
  return result;
}

void *re::anonymous namespace'::RegisterMapping::initMappedRegisters<re::Vector2<float>>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 18, *a1, *(void *)(a2 + 104));
  if (*(void *)(a2 + 104))
  {
    unint64_t v7 = 0;
    uint64_t v8 = *(void *)(a2 + 96);
    uint64_t v9 = a3[20];
    do
    {
      unint64_t v10 = *(void *)(v8 + 8 * v7);
      if (a1[21] <= v10)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (a3[19] <= v7) {
        goto LABEL_8;
      }
      *(void *)(v9 + 8 * v7++) = *(void *)(a1[22] + (v10 << 6) + 56);
    }
    while (v7 < *(void *)(a2 + 104));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisters<re::Vector3<float>>(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationRegisterId<int>>::init<>(a3 + 21, *a1, *(void *)(a2 + 120));
  if (*(void *)(a2 + 120))
  {
    unint64_t v7 = 0;
    do
    {
      if (a3[22] <= v7)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(void *)(a3[23] + 8 * v7++) = result;
    }
    while (v7 < *(void *)(a2 + 120));
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::initMappedRegisterArray(uint64_t *a1, uint64_t a2, unint64_t a3, void *a4)
{
  uint64_t result = (uint64_t)re::FixedArray<re::EvaluationSRT>::init<>(a4, *a1, a3);
  if (a3)
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      if (a4[1] <= v10) {
        break;
      }
      *(void *)(a4[2] + v9) = v11;
      if (a4[1] <= v10) {
        goto LABEL_9;
      }
      *(void *)(a4[2] + v9 + 8) = v12;
      if (a4[1] <= v10) {
        goto LABEL_10;
      }
      *(void *)(a4[2] + v9 + 16) = result;
      ++v10;
      v9 += 24;
      if (a3 == v10) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_9:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_10:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::RegisterMapping::getMappedRegisterValue<re::Quaternion<float>>(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 144) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 152) + (a2 << 6) + 56);
}

uint64_t re::anonymous namespace'::RegisterMapping::getMappedRegisterValue<re::Vector3<float>>(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 192) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 200) + (a2 << 6) + 56);
}

void re::FixedRegisterTable::initSize<re::FixedRegisterIdTable>(uint64_t *a1, uint64_t a2, unint64_t *a3)
{
  re::FixedArray<int>::init<>(a1, a2, a3[1]);
  re::FixedArray<int>::init<>(a1 + 3, a2, a3[4]);
  re::FixedArray<int>::init<>(a1 + 6, a2, a3[7]);
  re::FixedArray<re::Matrix3x3<float>>::init<>(a1 + 9, a2, a3[10]);
  re::FixedArray<re::Matrix4x4<float>>::init<>(a1 + 12, a2, a3[13]);
  re::FixedArray<re::Quaternion<float>>::init<>(a1 + 15, a2, a3[16]);
  re::FixedArray<re::Vector2<float>>::init<>(a1 + 18, a2, a3[19]);
  unint64_t v6 = a3[22];
  re::FixedArray<re::Vector3<float>>::init<>(a1 + 21, a2, v6);
}

uint64_t re::FixedArray<re::EvaluationSRT>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return a1;
  }
  uint64_t v4 = *(void *)a2;
  if (*(void *)a1)
  {
    if (!v4) {
      return a1;
    }
  }
  else
  {
    if (!v4) {
      return a1;
    }
    re::FixedArray<re::EvaluationSRT>::init<>((void *)a1, v4, *(void *)(a2 + 8));
  }
  uint64_t v5 = *(void *)(a2 + 8);
  if (*(void *)(a1 + 8) == v5)
  {
    if (v5) {
      memmove(*(void **)(a1 + 16), *(const void **)(a2 + 16), 24 * v5);
    }
    return a1;
  }
  re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::FixedArray<re::EvaluationRegisterId<int>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return a1;
  }
  uint64_t v4 = *(void *)a2;
  if (*(void *)a1)
  {
    if (!v4) {
      return a1;
    }
  }
  else
  {
    if (!v4) {
      return a1;
    }
    re::FixedArray<re::EvaluationRegisterId<int>>::init<>((void *)a1, v4, *(void *)(a2 + 8));
  }
  uint64_t v5 = *(void *)(a2 + 8);
  if (*(void *)(a1 + 8) == v5)
  {
    if (v5) {
      memmove(*(void **)(a1 + 16), *(const void **)(a2 + 16), 8 * v5);
    }
    return a1;
  }
  re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void re::anonymous namespace'::$_0::__invoke(uint64_t a1, uint64_t a2)
{
}

void re::anonymous namespace'::$_1::__invoke(uint64_t a1, uint64_t a2)
{
}

void re::anonymous namespace'::$_2::__invoke(uint64_t a1, uint64_t a2)
{
}

void re::anonymous namespace'::$_3::__invoke(uint64_t a1, uint64_t a2)
{
}

void re::anonymous namespace'::$_4::__invoke(uint64_t a1, uint64_t a2)
{
}

void re::anonymous namespace'::$_5::__invoke(uint64_t a1, uint64_t a2)
{
}

void re::anonymous namespace'::$_6::__invoke(uint64_t a1, uint64_t a2)
{
}

void re::anonymous namespace'::$_7::__invoke(uint64_t a1, uint64_t a2)
{
}

__n128 re::anonymous namespace'::$_8::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v10[0] = a1;
  v10[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      __n128 result = (__n128)v9;
      _OWORD *v7 = v9;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

void *re::anonymous namespace'::$_9::__invoke(void *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_10::__invoke(uint64_t result, unint64_t a2, uint64_t a3)
{
  if (a2 >= 4)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 >> 2;
    unint64_t v5 = (uint64_t *)(result + 16);
    while (a2 > v3)
    {
      unint64_t v6 = *(v5 - 2);
      unint64_t v7 = *(void *)(a3 + 120);
      if (v7 <= v6) {
        goto LABEL_14;
      }
      unint64_t v8 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_15;
      }
      unint64_t v9 = *(v5 - 1);
      if (v7 <= v9) {
        goto LABEL_16;
      }
      unint64_t v10 = v3 + 2;
      if (a2 <= v3 + 2) {
        goto LABEL_17;
      }
      uint64_t v11 = *v5;
      if (v7 <= *v5) {
        goto LABEL_18;
      }
      unint64_t v12 = v3 + 3;
      if (a2 <= v3 + 3) {
        goto LABEL_19;
      }
      unint64_t v13 = v5[1];
      if (v7 <= v13) {
        goto LABEL_20;
      }
      uint64_t v14 = *(void *)(a3 + 112);
      *(float32x4_t *)(v14 + 16 * v13) = vmlaq_f32(*(float32x4_t *)(v14 + 16 * v6), *(float32x4_t *)(v14 + 16 * v11), vsubq_f32(*(float32x4_t *)(v14 + 16 * v9), *(float32x4_t *)(v14 + 16 * v6)));
      v3 += 4;
      v5 += 4;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v6, v7);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v8, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, v7);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v7);
    _os_crash();
    __break(1u);
LABEL_19:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v12, a2);
    _os_crash();
    __break(1u);
LABEL_20:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v13, v7);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_11::__invoke(uint64_t result, unint64_t a2, void *a3, double a4)
{
  if (a2 >= 4)
  {
    unint64_t v4 = 0;
    unint64_t v5 = a2 >> 2;
    unint64_t v6 = (uint64_t *)(result + 16);
    LODWORD(a4) = 1.0;
    while (a2 > v4)
    {
      unint64_t v7 = *(v6 - 2);
      unint64_t v8 = a3[15];
      if (v8 <= v7) {
        goto LABEL_14;
      }
      unint64_t v9 = v4 + 1;
      if (a2 <= v4 + 1) {
        goto LABEL_15;
      }
      unint64_t v10 = *(v6 - 1);
      if (v8 <= v10) {
        goto LABEL_16;
      }
      unint64_t v11 = v4 + 2;
      if (a2 <= v4 + 2) {
        goto LABEL_17;
      }
      uint64_t v12 = *v6;
      unint64_t v13 = a3[5];
      if (v13 <= *v6) {
        goto LABEL_18;
      }
      unint64_t v14 = v4 + 3;
      if (a2 <= v4 + 3) {
        goto LABEL_19;
      }
      unint64_t v15 = v6[1];
      if (v8 <= v15) {
        goto LABEL_20;
      }
      float v16 = *(float *)(a3[4] + 4 * v12);
      *(float32x4_t *)(a3[14] + 16 * v15) = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(a3[14] + 16 * v10), v16), *(float32x4_t *)(a3[14] + 16 * v7), 1.0 - v16);
      v4 += 4;
      v6 += 4;
      if (!--v5) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, a4, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v4, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v7, v8);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v10, v8);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v11, a2);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v13);
    _os_crash();
    __break(1u);
LABEL_19:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v14, a2);
    _os_crash();
    __break(1u);
LABEL_20:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v15, v8);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::anonymous namespace'::$_12::__invoke(uint64_t a1, unint64_t a2, void *a3)
{
  if (a2 >= 4)
  {
    unint64_t v6 = 0;
    unint64_t v7 = a2 >> 2;
    unint64_t v8 = (uint64_t *)(a1 + 16);
    while (a2 > v6)
    {
      unint64_t v9 = *(v8 - 2);
      unint64_t v3 = a3[11];
      if (v3 <= v9) {
        goto LABEL_23;
      }
      unint64_t v10 = v6 + 1;
      if (a2 <= v6 + 1) {
        goto LABEL_24;
      }
      unint64_t v11 = *(v8 - 1);
      if (v3 <= v11) {
        goto LABEL_25;
      }
      unint64_t v12 = v6 + 2;
      if (a2 <= v6 + 2) {
        goto LABEL_26;
      }
      uint64_t v13 = *v8;
      unint64_t v14 = a3[5];
      if (v14 <= *v8) {
        goto LABEL_27;
      }
      uint64_t v15 = a3[10];
      float v16 = *(float *)(a3[4] + 4 * v13);
      float32x4_t v17 = *(float32x4_t *)(v15 + 16 * v9);
      float32x4_t v18 = *(float32x4_t *)(v15 + 16 * v11);
      float32x4_t v19 = vmulq_f32(v17, v18);
      float32x4_t v20 = (float32x4_t)vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL);
      *(float32x2_t *)v19.f32 = vadd_f32(*(float32x2_t *)v19.f32, *(float32x2_t *)v20.f32);
      v19.f32[0] = vaddv_f32(*(float32x2_t *)v19.f32);
      v20.i64[0] = 0;
      float32x4_t v21 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v19, v20)), 0), (int8x16_t)vnegq_f32(v18), (int8x16_t)v18);
      float v22 = 1.0;
      float32x4_t v23 = vsubq_f32(v17, v21);
      int8x16_t v24 = (int8x16_t)vmulq_f32(v23, v23);
      float32x4_t v53 = v21;
      float32x4_t v54 = v17;
      float32x4_t v25 = vaddq_f32(v17, v21);
      int8x16_t v26 = (int8x16_t)vmulq_f32(v25, v25);
      float v27 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL)))));
      float v28 = v27 + v27;
      float v29 = 1.0;
      if ((float)(v27 + v27) != 0.0) {
        float v29 = sinf(v27 + v27) / v28;
      }
      float v30 = (float)(1.0 - v16) * v28;
      if (v30 != 0.0)
      {
        float v51 = v29;
        float v31 = sinf((float)(1.0 - v16) * v28);
        float v29 = v51;
        float v22 = v31 / v30;
      }
      float v32 = v16 * v28;
      float v33 = 1.0;
      if (v32 != 0.0)
      {
        float v52 = v29;
        float v34 = sinf(v32);
        float v29 = v52;
        float v33 = v34 / v32;
      }
      float v35 = v29;
      float32x2_t v36 = vrecpe_f32((float32x2_t)LODWORD(v29));
      float32x2_t v37 = vmul_f32(v36, vrecps_f32((float32x2_t)LODWORD(v35), v36));
      float v38 = vmul_f32(v37, vrecps_f32((float32x2_t)LODWORD(v35), v37)).f32[0];
      v37.f32[0] = (float)(1.0 - v16) * (float)(v38 * v22);
      float32x4_t v39 = vmlaq_f32(vmulq_n_f32(v53, v16 * (float)(v38 * v33)), v54, (float32x4_t)vdupq_lane_s32((int32x2_t)v37, 0));
      int8x16_t v40 = (int8x16_t)vmulq_f32(v39, v39);
      float32x2_t v41 = vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL));
      if (vaddv_f32(v41) == 0.0)
      {
        uint64_t v42 = 0;
        uint64_t v43 = 0x3F80000000000000;
      }
      else
      {
        unsigned __int32 v44 = vadd_f32(v41, (float32x2_t)vdup_lane_s32((int32x2_t)v41, 1)).u32[0];
        float32x2_t v45 = vrsqrte_f32((float32x2_t)v44);
        float32x2_t v46 = vmul_f32(v45, vrsqrts_f32((float32x2_t)v44, vmul_f32(v45, v45)));
        float32x4_t v47 = vmulq_n_f32(v39, vmul_f32(v46, vrsqrts_f32((float32x2_t)v44, vmul_f32(v46, v46))).f32[0]);
        uint64_t v43 = v47.i64[1];
        uint64_t v42 = v47.i64[0];
      }
      unint64_t v48 = v6 + 3;
      if (a2 <= v6 + 3) {
        goto LABEL_28;
      }
      unint64_t v49 = v8[1];
      if (v3 <= v49) {
        goto LABEL_29;
      }
      long long v50 = (uint64_t *)(v15 + 16 * v49);
      uint64_t *v50 = v42;
      v50[1] = v43;
      v6 += 4;
      v8 += 4;
      if (!--v7) {
        return;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
    _os_crash();
    __break(1u);
LABEL_23:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, v3);
    _os_crash();
    __break(1u);
LABEL_24:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_25:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v3);
    _os_crash();
    __break(1u);
LABEL_26:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v12, a2);
    _os_crash();
    __break(1u);
LABEL_27:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v13, v14);
    _os_crash();
    __break(1u);
LABEL_28:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v48, a2);
    _os_crash();
    __break(1u);
LABEL_29:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v49, v3);
    _os_crash();
    __break(1u);
  }
}

void re::anonymous namespace'::$_13::__invoke(uint64_t a1, unint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    unint64_t v6 = 0;
    unint64_t v7 = a2 / 3;
    while (a2 > v6)
    {
      unint64_t v8 = *(void *)(a1 + 8 * v6);
      unint64_t v9 = a3[15];
      if (v9 <= v8) {
        goto LABEL_12;
      }
      unint64_t v10 = v6 + 1;
      if (a2 <= v6 + 1) {
        goto LABEL_13;
      }
      unint64_t v11 = *(void *)(a1 + 8 * v6 + 8);
      unint64_t v12 = a3[3];
      if (v12 <= v11) {
        goto LABEL_14;
      }
      uint64_t v13 = a3[14] + 16 * v8;
      int v14 = *(unsigned __int8 *)(a3[2] + 4 * v11);
      long long v20 = xmmword_23435FBB0;
      re::convertIntrinsicEulersToQuaternions<float>(v13, 1, v14, (uint64_t)&v20, 1);
      unint64_t v15 = v6 + 2;
      if (a2 <= v6 + 2) {
        goto LABEL_15;
      }
      unint64_t v16 = *(void *)(a1 + 8 * v6 + 16);
      unint64_t v17 = a3[11];
      if (v17 <= v16) {
        goto LABEL_16;
      }
      uint64_t v18 = *((void *)&v20 + 1);
      float32x4_t v19 = (void *)(a3[10] + 16 * v16);
      void *v19 = v20;
      v19[1] = v18;
      v6 += 3;
      if (!--v7) {
        return;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v9);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v12);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v16, v17);
    _os_crash();
    __break(1u);
  }
}

void re::anonymous namespace'::$_14::__invoke(uint64_t a1, unint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    unint64_t v6 = 0;
    unint64_t v7 = a2 / 3;
    while (a2 > v6)
    {
      unint64_t v8 = *(void *)(a1 + 8 * v6);
      unint64_t v9 = a3[11];
      if (v9 <= v8) {
        goto LABEL_12;
      }
      unint64_t v10 = v6 + 1;
      if (a2 <= v6 + 1) {
        goto LABEL_13;
      }
      unint64_t v11 = *(void *)(a1 + 8 * v6 + 8);
      unint64_t v12 = a3[3];
      if (v12 <= v11) {
        goto LABEL_14;
      }
      uint64_t v13 = a3[10] + 16 * v8;
      int v14 = *(unsigned __int8 *)(a3[2] + 4 * v11);
      long long v20 = 0u;
      re::convertQuaternionsToIntrinsicEulers<float>(v13, 1, v14, (uint64_t)&v20, 1);
      unint64_t v15 = v6 + 2;
      if (a2 <= v6 + 2) {
        goto LABEL_15;
      }
      unint64_t v16 = *(void *)(a1 + 8 * v6 + 16);
      unint64_t v17 = a3[15];
      if (v17 <= v16) {
        goto LABEL_16;
      }
      uint64_t v18 = *((void *)&v20 + 1);
      float32x4_t v19 = (void *)(a3[14] + 16 * v16);
      void *v19 = v20;
      v19[1] = v18;
      v6 += 3;
      if (!--v7) {
        return;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v9);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v12);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v16, v17);
    _os_crash();
    __break(1u);
  }
}

__n128 re::anonymous namespace'::$_15::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v12[0] = a1;
  v12[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      int32x4_t v8 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*v7, *v7), *(int8x16_t *)v7, 0xCuLL), vnegq_f32(*v6)), *(float32x4_t *)v7, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*(int32x4_t *)v6, *(int32x4_t *)v6), *(int8x16_t *)v6, 0xCuLL));
      int8x16_t v11 = vextq_s8((int8x16_t)vuzp1q_s32(v8, v8), (int8x16_t)v8, 0xCuLL);
      __n128 result = (__n128)v11;
      _OWORD *v9 = v11;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

_OWORD *re::anonymous namespace'::$_16::__invoke(_OWORD *result, unint64_t a2, uint64_t a3)
{
  v19[0] = result;
  v19[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      int8x16_t v8 = (int8x16_t)vmulq_f32(*v7, *v7);
      *(float *)v8.i32 = 1.0
                       / vaddv_f32(vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)));
      _S2 = vmuls_lane_f32(*(float *)v8.i32, *v7, 3);
      _Q0 = vmulq_n_f32(vnegq_f32(*v7), *(float *)v8.i32);
      _Q1 = *(int32x4_t *)v6;
      int32x4_t v12 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q0, (int32x4_t)_Q0), (int8x16_t)_Q0, 0xCuLL), vnegq_f32(*v6)), _Q0, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q1, _Q1), *(int8x16_t *)v6, 0xCuLL));
      float32x4_t v13 = vmlaq_n_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v12, v12), (int8x16_t)v12, 0xCuLL), _Q0, *v6, 3), *v6, _S2);
      __asm { FMLA            S0, S2, V1.S[3] }
      v13.i32[3] = _Q0.i32[0];
      float32x4_t v18 = v13;
      *__n128 result = v18;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

__n128 re::anonymous namespace'::$_17::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v10[0] = a1;
  v10[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      __n128 result = (__n128)v9;
      _OWORD *v7 = v9;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

__n128 re::anonymous namespace'::$_18::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v11[0] = a1;
  v11[1] = a2;
  if (a2 >= 2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 >> 1;
    do
    {
      float32x4_t v7 = vnegq_f32(*v6);
      v7.i32[3] = HIDWORD(*(unsigned long long *)v6);
      __n128 v10 = (__n128)v7;
      __n128 result = v10;
      _OWORD *v8 = v10;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

__n128 re::anonymous namespace'::$_19::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v9[0] = a1;
  v9[1] = a2;
  if (a2 >= 2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 >> 1;
    do
    {
      simd_float3x3 v8 = __invert_f3(v10);
      *(void *)uint64_t v6 = v8.columns[0].i64[0];
      *(_DWORD *)(v6 + 8) = v8.columns[0].i32[2];
      *(void *)(v6 + 16) = v8.columns[1].i64[0];
      *(_DWORD *)(v6 + 24) = v8.columns[1].i32[2];
      __n128 result = (__n128)v8.columns[2];
      *(void *)(v6 + 32) = v8.columns[2].i64[0];
      *(_DWORD *)(v6 + 40) = v8.columns[2].i32[2];
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

void re::anonymous namespace'::$_20::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 2)
  {
    unint64_t v6 = 0;
    unint64_t v7 = a2 >> 1;
    while (a2 > v6)
    {
      unint64_t v8 = *(void *)(a1 + 8 * v6);
      unint64_t v9 = *(void *)(a3 + 72);
      if (v9 <= v8) {
        goto LABEL_10;
      }
      simd_float4x4 v13 = __invert_f4(*(simd_float4x4 *)(*(void *)(a3 + 64) + (v8 << 6)));
      unint64_t v10 = v6 + 1;
      if (a2 <= v6 + 1) {
        goto LABEL_11;
      }
      unint64_t v11 = *(void *)(a1 + 8 * v6 + 8);
      unint64_t v12 = *(void *)(a3 + 72);
      if (v12 <= v11) {
        goto LABEL_12;
      }
      *(simd_float4x4 *)(*(void *)(a3 + 64) + (v11 << 6)) = v13;
      v6 += 2;
      if (!--v7) {
        return;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
    _os_crash();
    __break(1u);
LABEL_10:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v9);
    _os_crash();
    __break(1u);
LABEL_11:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v12);
    _os_crash();
    __break(1u);
  }
}

_OWORD *re::anonymous namespace'::$_21::__invoke(_OWORD *result, unint64_t a2, uint64_t a3)
{
  v10[0] = result;
  v10[1] = a2;
  if (a2 >= 2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 >> 1;
    do
    {
      int8x16_t v7 = (int8x16_t)vmulq_f32(*v6, *v6);
      *(float *)v7.i32 = 1.0
                       / vaddv_f32(vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL)));
      float32x4_t v8 = vmulq_n_f32(vnegq_f32(*v6), *(float *)v7.i32);
      v8.i32[3] = vmuls_lane_f32(*(float *)v7.i32, *v6, 3);
      float32x4_t v9 = v8;
      *__n128 result = v9;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_22::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 / 3;
    uint64_t v6 = a3[14];
    unint64_t v5 = a3[15];
    uint64_t v8 = a3[4];
    unint64_t v7 = a3[5];
    while (a2 > v3)
    {
      unint64_t v9 = *(void *)(result + 8 * v3);
      if (v5 <= v9) {
        goto LABEL_12;
      }
      unint64_t v10 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_13;
      }
      unint64_t v11 = *(void *)(result + 8 * v3 + 8);
      if (v5 <= v11) {
        goto LABEL_14;
      }
      unint64_t v12 = v3 + 2;
      if (a2 <= v3 + 2) {
        goto LABEL_15;
      }
      unint64_t v13 = *(void *)(result + 8 * v3 + 16);
      if (v7 <= v13) {
        goto LABEL_16;
      }
      float32x4_t v14 = vmulq_f32(*(float32x4_t *)(v6 + 16 * v9), *(float32x4_t *)(v6 + 16 * v11));
      *(_DWORD *)(v8 + 4 * v13) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).u32[0];
      v3 += 3;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, v5);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v5);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v12, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v13, v7);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_23::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 / 3;
    uint64_t v6 = a3[12];
    unint64_t v5 = a3[13];
    uint64_t v8 = a3[4];
    unint64_t v7 = a3[5];
    while (a2 > v3)
    {
      unint64_t v9 = *(void *)(result + 8 * v3);
      if (v5 <= v9) {
        goto LABEL_12;
      }
      unint64_t v10 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_13;
      }
      unint64_t v11 = *(void *)(result + 8 * v3 + 8);
      if (v5 <= v11) {
        goto LABEL_14;
      }
      unint64_t v12 = v3 + 2;
      if (a2 <= v3 + 2) {
        goto LABEL_15;
      }
      unint64_t v13 = *(void *)(result + 8 * v3 + 16);
      if (v7 <= v13) {
        goto LABEL_16;
      }
      *(float *)(v8 + 4 * v13) = vaddv_f32(vmul_f32(*(float32x2_t *)(v6 + 8 * v9), *(float32x2_t *)(v6 + 8 * v11)));
      v3 += 3;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, v5);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v5);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v12, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v13, v7);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

__n128 re::anonymous namespace'::$_24::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v20[0] = a1;
  v20[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      _Q0 = *(int32x4_t *)v6;
      int32x4_t v9 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*v7, *v7), *(int8x16_t *)v7, 0xCuLL), vnegq_f32(*v6)), *(float32x4_t *)v7, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q0, _Q0), *(int8x16_t *)v6, 0xCuLL));
      float32x4_t v10 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v9, v9), (int8x16_t)v9, 0xCuLL), *(float32x4_t *)v7, *v6, 3), *v6, *(float32x4_t *)v7, 3);
      _S1 = HIDWORD(*(unsigned long long *)v7);
      __asm { FMLA            S2, S1, V0.S[3] }
      v10.i32[3] = _S2;
      __n128 v19 = (__n128)v10;
      __n128 result = v19;
      *unint64_t v17 = v19;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

__n128 re::anonymous namespace'::$_25::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v10[0] = a1;
  v10[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      __n128 result = (__n128)v9;
      _OWORD *v7 = v9;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_26::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 / 3;
    while (a2 > v3)
    {
      unint64_t v5 = *(void *)(result + 8 * v3);
      unint64_t v6 = a3[15];
      if (v6 <= v5) {
        goto LABEL_12;
      }
      unint64_t v7 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_13;
      }
      unint64_t v8 = *(void *)(result + 8 * v3 + 8);
      unint64_t v9 = a3[5];
      if (v9 <= v8) {
        goto LABEL_14;
      }
      unint64_t v10 = v3 + 2;
      if (a2 <= v3 + 2) {
        goto LABEL_15;
      }
      unint64_t v11 = *(void *)(result + 8 * v3 + 16);
      if (v6 <= v11) {
        goto LABEL_16;
      }
      *(float32x4_t *)(a3[14] + 16 * v11) = vmulq_n_f32(*(float32x4_t *)(a3[14] + 16 * v5), *(float *)(a3[4] + 4 * v8));
      v3 += 3;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v9);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v6);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_27::__invoke(uint64_t result, unint64_t a2, uint64_t a3)
{
  if (a2 >= 3)
  {
    uint64_t v3 = 0;
    while (1)
    {
      uint64_t v4 = 3 * v3;
      if (a2 <= 3 * v3) {
        break;
      }
      unint64_t v5 = *(void *)(result + 24 * v3);
      unint64_t v6 = *(void *)(a3 + 56);
      if (v6 <= v5) {
        goto LABEL_14;
      }
      uint64_t v7 = v4 + 1;
      if (a2 <= v4 + 1) {
        goto LABEL_15;
      }
      unint64_t v8 = *(void *)(result + 8 * v7);
      if (v6 <= v8) {
        goto LABEL_16;
      }
      uint64_t v9 = 0;
      uint64_t v10 = *(void *)(a3 + 48);
      unint64_t v11 = (float32x4_t *)(v10 + 48 * v5);
      unint64_t v12 = (long long *)(v10 + 48 * v8);
      float32x4_t v13 = *v11;
      float32x4_t v14 = v11[1];
      float32x4_t v15 = v11[2];
      long long v16 = v12[1];
      long long v17 = v12[2];
      long long v24 = *v12;
      long long v25 = v16;
      long long v26 = v17;
      do
      {
        *(float32x4_t *)((char *)&v27 + v9) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v13, COERCE_FLOAT(*(long long *)((char *)&v24 + v9))), v14, *(float32x2_t *)((char *)&v24 + v9), 1), v15, *(float32x4_t *)((char *)&v24 + v9), 2);
        v9 += 16;
      }
      while (v9 != 48);
      unint64_t v18 = v4 + 2;
      if (a2 <= v18) {
        goto LABEL_17;
      }
      unint64_t v19 = *(void *)(result + 8 * v18);
      if (v6 <= v19) {
        goto LABEL_18;
      }
      int v20 = v28;
      long long v21 = v29;
      long long v22 = v30;
      uint64_t v23 = v10 + 48 * v19;
      *(void *)uint64_t v23 = v27;
      *(_DWORD *)(v23 + 8) = v20;
      *(void *)(v23 + 16) = v21;
      *(_DWORD *)(v23 + 24) = DWORD2(v21);
      *(void *)(v23 + 32) = v22;
      *(_DWORD *)(v23 + 40) = DWORD2(v22);
      if (++v3 == a2 / 3) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * v3, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6, v24, v25, v26);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v6);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v18, a2);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v19, v6);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_28::__invoke(uint64_t result, unint64_t a2, uint64_t a3)
{
  if (a2 >= 3)
  {
    uint64_t v3 = 0;
    while (1)
    {
      uint64_t v4 = 3 * v3;
      if (a2 <= 3 * v3) {
        break;
      }
      unint64_t v5 = *(void *)(result + 24 * v3);
      unint64_t v6 = *(void *)(a3 + 72);
      if (v6 <= v5) {
        goto LABEL_14;
      }
      uint64_t v7 = v4 + 1;
      if (a2 <= v4 + 1) {
        goto LABEL_15;
      }
      unint64_t v8 = *(void *)(result + 8 * v7);
      if (v6 <= v8) {
        goto LABEL_16;
      }
      unint64_t v9 = 0;
      uint64_t v10 = *(void *)(a3 + 64);
      unint64_t v11 = (float32x4_t *)(v10 + (v5 << 6));
      float32x4_t v12 = *v11;
      float32x4_t v13 = v11[1];
      float32x4_t v14 = v11[2];
      float32x4_t v15 = v11[3];
      long long v16 = (long long *)(v10 + (v8 << 6));
      long long v17 = v16[1];
      long long v18 = v16[2];
      long long v19 = v16[3];
      long long v26 = *v16;
      long long v27 = v17;
      long long v28 = v18;
      long long v29 = v19;
      do
      {
        v30[v9 / 0x10] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v12, COERCE_FLOAT(*(long long *)((char *)&v26 + v9))), v13, *(float32x2_t *)((char *)&v26 + v9), 1), v14, *(float32x4_t *)((char *)&v26 + v9), 2), v15, *(float32x4_t *)((char *)&v26 + v9), 3);
        v9 += 16;
      }
      while (v9 != 64);
      unint64_t v20 = v4 + 2;
      if (a2 <= v20) {
        goto LABEL_17;
      }
      unint64_t v21 = *(void *)(result + 8 * v20);
      if (v6 <= v21) {
        goto LABEL_18;
      }
      long long v22 = v30[1];
      long long v23 = v30[2];
      long long v24 = v30[3];
      long long v25 = (_OWORD *)(v10 + (v21 << 6));
      _OWORD *v25 = v30[0];
      v25[1] = v22;
      v25[2] = v23;
      v25[3] = v24;
      if (++v3 == a2 / 3) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * v3, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6, v26, v27, v28, v29);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v6);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v20, a2);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v21, v6);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_29::__invoke(uint64_t result, unint64_t a2, uint64_t a3)
{
  if (a2 >= 2)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 >> 1;
    while (a2 > v3)
    {
      unint64_t v5 = *(void *)(result + 8 * v3);
      unint64_t v6 = *(void *)(a3 + 120);
      if (v6 <= v5) {
        goto LABEL_10;
      }
      unint64_t v7 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_11;
      }
      unint64_t v8 = *(void *)(result + 8 * v3 + 8);
      if (v6 <= v8) {
        goto LABEL_12;
      }
      uint64_t v9 = *(void *)(a3 + 112);
      float32x4_t v10 = *(float32x4_t *)(v9 + 16 * v5);
      int32x4_t v11 = (int32x4_t)vmulq_f32(v10, v10);
      v11.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2), vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1))).u32[0];
      float32x2_t v12 = vrsqrte_f32((float32x2_t)v11.u32[0]);
      float32x2_t v13 = vmul_f32(v12, vrsqrts_f32((float32x2_t)v11.u32[0], vmul_f32(v12, v12)));
      *(float32x4_t *)(v9 + 16 * v8) = vmulq_n_f32(v10, vmul_f32(v13, vrsqrts_f32((float32x2_t)v11.u32[0], vmul_f32(v13, v13))).f32[0]);
      v3 += 2;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_10:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
    _os_crash();
    __break(1u);
LABEL_11:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v6);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_30::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 / 3;
    while (a2 > v3)
    {
      unint64_t v5 = *(void *)(result + 8 * v3);
      unint64_t v6 = a3[11];
      if (v6 <= v5) {
        goto LABEL_12;
      }
      unint64_t v7 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_13;
      }
      unint64_t v8 = *(void *)(result + 8 * v3 + 8);
      unint64_t v9 = a3[15];
      if (v9 <= v8) {
        goto LABEL_14;
      }
      unint64_t v10 = v3 + 2;
      if (a2 <= v3 + 2) {
        goto LABEL_15;
      }
      unint64_t v11 = *(void *)(result + 8 * v3 + 16);
      if (v9 <= v11) {
        goto LABEL_16;
      }
      uint64_t v12 = a3[14];
      float32x4_t v13 = *(float32x4_t *)(a3[10] + 16 * v5);
      float32x4_t v14 = *(float32x4_t *)(v12 + 16 * v8);
      float32x4_t v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v13, (int32x4_t)v13), (int8x16_t)v13, 0xCuLL);
      float32x4_t v16 = vnegq_f32(v13);
      float32x4_t v17 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL), v16), v14, v15);
      int32x4_t v18 = (int32x4_t)vaddq_f32(v17, v17);
      float32x4_t v19 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL);
      float32x4_t v20 = vaddq_f32(v14, vmulq_laneq_f32(v19, v13, 3));
      int32x4_t v21 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL), v16), v19, v15);
      *(float32x4_t *)(v12 + 16 * v11) = vaddq_f32(v20, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v21, v21), (int8x16_t)v21, 0xCuLL));
      v3 += 3;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v9);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v9);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

__n128 re::anonymous namespace'::$_31::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v10[0] = a1;
  v10[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      __n128 result = (__n128)v9;
      _OWORD *v7 = v9;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

void *re::anonymous namespace'::$_32::__invoke(void *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

__n128 re::anonymous namespace'::$_33::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v14[0] = a1;
  v14[1] = a2;
  if (a2 >= 2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 >> 1;
    do
    {
      int32x4_t v7 = *(int32x4_t *)(v6 + 16);
      long long v10 = *(_OWORD *)(v6 + 32);
      unint64_t v11 = vzip1q_s32(*(int32x4_t *)v6, v7).u64[0];
      unint64_t v12 = vtrn2q_s32(*(int32x4_t *)v6, v7).u64[0];
      int32x4_t v13 = vzip1q_s32(vdupq_laneq_s32(*(int32x4_t *)v6, 2), vdupq_laneq_s32(v7, 2));
      *(_DWORD *)(v8 + 8) = v10;
      *(void *)uint64_t v8 = v11;
      *(void *)(v8 + 16) = v12;
      *(_DWORD *)(v8 + 24) = DWORD1(v10);
      *(_DWORD *)(v8 + 40) = DWORD2(v10);
      __n128 result = (__n128)v13;
      *(void *)(v8 + 32) = v13.i64[0];
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_34::__invoke(uint64_t result, unint64_t a2, void *a3, __n128 a4, __n128 a5, __n128 a6)
{
  if (a2 >= 2)
  {
    unint64_t v6 = 0;
    unint64_t v7 = a2 >> 1;
    while (a2 > v6)
    {
      unint64_t v8 = *(void *)(result + 8 * v6);
      unint64_t v9 = a3[9];
      if (v9 <= v8) {
        goto LABEL_10;
      }
      unint64_t v10 = v6 + 1;
      if (a2 <= v6 + 1) {
        goto LABEL_11;
      }
      unint64_t v11 = *(void *)(result + 8 * v6 + 8);
      unint64_t v12 = a3[7];
      if (v12 <= v11) {
        goto LABEL_12;
      }
      uint64_t v13 = a3[8] + (v8 << 6);
      a4.n128_u64[0] = *(void *)v13;
      a5.n128_u64[0] = *(void *)(v13 + 16);
      a6.n128_u64[0] = *(void *)(v13 + 32);
      a4.n128_u32[2] = *(_DWORD *)(v13 + 8);
      a5.n128_u32[2] = *(_DWORD *)(v13 + 24);
      a6.n128_u32[2] = *(_DWORD *)(v13 + 40);
      float32x4_t v14 = (__n128 *)(a3[6] + 48 * v11);
      *float32x4_t v14 = a4;
      v14[1] = a5;
      void v14[2] = a6;
      v6 += 2;
      if (!--v7) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
    _os_crash();
    __break(1u);
LABEL_10:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v9);
    _os_crash();
    __break(1u);
LABEL_11:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v12);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_35::__invoke(uint64_t result, unint64_t a2, void *a3, double a4, double a5, double a6)
{
  if (a2 >= 2)
  {
    unint64_t v6 = 0;
    unint64_t v7 = a2 >> 1;
    LODWORD(a4) = 1.0;
    LODWORD(a5) = 2.0;
    LODWORD(a6) = 0.25;
    while (a2 > v6)
    {
      unint64_t v8 = *(void *)(result + 8 * v6);
      unint64_t v9 = a3[7];
      if (v9 <= v8) {
        goto LABEL_18;
      }
      uint64_t v10 = a3[6] + 48 * v8;
      float32x4_t v11 = *(float32x4_t *)(v10 + 16);
      int32x4_t v12 = (int32x4_t)vmulq_f32(*(float32x4_t *)v10, *(float32x4_t *)v10);
      v12.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2), vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 1))).u32[0];
      float32x2_t v13 = vrsqrte_f32((float32x2_t)v12.u32[0]);
      float32x2_t v14 = vmul_f32(v13, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v13, v13)));
      float32x4_t v15 = vmulq_n_f32(*(float32x4_t *)v10, vmul_f32(v14, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v14, v14))).f32[0]);
      float32x4_t v16 = vmulq_f32(v11, v15);
      float32x4_t v17 = vmulq_f32(v15, v15);
      float v18 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0];
      float32x4_t v19 = vsubq_f32(v11, vmulq_n_f32(v15, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0]/ v18));
      int32x4_t v20 = (int32x4_t)vmulq_f32(v19, v19);
      v20.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v20, 2), vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v20.i8, 1))).u32[0];
      *(float32x2_t *)v17.f32 = vrsqrte_f32((float32x2_t)v20.u32[0]);
      *(float32x2_t *)v17.f32 = vmul_f32(*(float32x2_t *)v17.f32, vrsqrts_f32((float32x2_t)v20.u32[0], vmul_f32(*(float32x2_t *)v17.f32, *(float32x2_t *)v17.f32)));
      float32x4_t v21 = vmulq_n_f32(v19, vmul_f32(*(float32x2_t *)v17.f32, vrsqrts_f32((float32x2_t)v20.u32[0], vmul_f32(*(float32x2_t *)v17.f32, *(float32x2_t *)v17.f32))).f32[0]);
      float32x4_t v22 = *(float32x4_t *)(v10 + 32);
      float32x4_t v23 = vmulq_f32(v15, v22);
      float32x4_t v24 = vmulq_n_f32(v15, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0]/ v18);
      float32x4_t v25 = vmulq_f32(v22, v21);
      float32x4_t v26 = vsubq_f32(v22, v24);
      v24.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0];
      float32x4_t v27 = vmulq_f32(v21, v21);
      float32x4_t v28 = vsubq_f32(v26, vmulq_n_f32(v21, v24.f32[0]/ vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]));
      int32x4_t v29 = (int32x4_t)vmulq_f32(v28, v28);
      v29.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v29, 2), vadd_f32(*(float32x2_t *)v29.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v29.i8, 1))).u32[0];
      *(float32x2_t *)v27.f32 = vrsqrte_f32((float32x2_t)v29.u32[0]);
      *(float32x2_t *)v27.f32 = vmul_f32(*(float32x2_t *)v27.f32, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(*(float32x2_t *)v27.f32, *(float32x2_t *)v27.f32)));
      int32x4_t v30 = (int32x4_t)vmulq_n_f32(v28, vmul_f32(*(float32x2_t *)v27.f32, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(*(float32x2_t *)v27.f32, *(float32x2_t *)v27.f32))).f32[0]);
      float v31 = (float)(v15.f32[0] + v21.f32[1]) + *(float *)&v30.i32[2];
      if (v31 >= 0.0)
      {
        float v46 = sqrtf(v31 + 1.0);
        float32_t v47 = v46 + v46;
        float32x2_t v48 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v46 + v46));
        float32x2_t v49 = vmul_f32(v48, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v46 + v46), v48));
        v49.i32[0] = vmul_f32(v49, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v46 + v46), v49)).u32[0];
        *(float32x2_t *)&long long v42 = vmul_n_f32(vsub_f32((float32x2_t)*(_OWORD *)&vzip2q_s32((int32x4_t)v21, vuzp1q_s32((int32x4_t)v21, v30)), (float32x2_t)*(_OWORD *)&vtrn2q_s32(v30, vzip2q_s32(v30, (int32x4_t)v15))), v49.f32[0]);
        v50.i32[0] = vsub_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)v15.f32, 1), *(float32x2_t *)v21.f32).u32[0];
        v50.f32[1] = v47;
        v49.i32[1] = 0.25;
        float32x2_t v45 = vmul_f32(v50, v49);
      }
      else if (v15.f32[0] < v21.f32[1] || v15.f32[0] < *(float *)&v30.i32[2])
      {
        float v51 = 1.0 - v15.f32[0];
        if (v21.f32[1] >= *(float *)&v30.i32[2])
        {
          float v58 = sqrtf(v21.f32[1] + (float)(v51 - *(float *)&v30.i32[2]));
          *(float *)&unsigned int v59 = v58 + v58;
          float32x2_t v60 = vrecpe_f32((float32x2_t)v59);
          float32x2_t v61 = vmul_f32(v60, vrecps_f32((float32x2_t)v59, v60));
          v62.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)v15.f32, 1), *(float32x2_t *)v21.f32).u32[0];
          v62.i32[1] = v59;
          float32x2_t v63 = (float32x2_t)vrev64_s32(*(int32x2_t *)v30.i8);
          float32x2_t v64 = (float32x2_t)vzip2q_s32((int32x4_t)v21, (int32x4_t)v15).u64[0];
          v65.i32[0] = vadd_f32(v63, v64).u32[0];
          v65.i32[1] = vsub_f32(v63, v64).i32[1];
          v63.i32[0] = vmul_f32(v61, vrecps_f32((float32x2_t)v59, v61)).u32[0];
          float32x2_t v45 = vmul_n_f32(v65, v63.f32[0]);
          v63.i32[1] = 0.25;
          *(float32x2_t *)&long long v42 = vmul_f32(v62, v63);
        }
        else
        {
          *(float32x2_t *)v30.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vzip2q_s32((int32x4_t)v15, (int32x4_t)v21), *(float32x2_t *)v30.i8);
          float32x2_t v52 = (float32x2_t)__PAIR64__(v15.u32[1], COERCE_UNSIGNED_INT(sqrtf((float)(v51 - v21.f32[1]) + *(float *)&v30.i32[2])));
          float32x2_t v53 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v21.f32, 0);
          float32x2_t v54 = vsub_f32(*(float32x2_t *)v15.f32, v53);
          v53.i32[0] = 2.0;
          v53.i32[0] = vmul_f32(v52, v53).u32[0];
          v53.i32[1] = v54.i32[1];
          float32x2_t v55 = vrecpe_f32((float32x2_t)v53.u32[0]);
          float32x2_t v56 = vmul_f32(v55, vrecps_f32((float32x2_t)v53.u32[0], v55));
          v54.i32[0] = vmul_f32(v56, vrecps_f32((float32x2_t)v53.u32[0], v56)).u32[0];
          *(float32x2_t *)&long long v42 = vmul_n_f32(*(float32x2_t *)v30.i8, v54.f32[0]);
          __asm { FMOV            V5.2S, #0.25 }
          _D5.i32[1] = v54.i32[0];
          float32x2_t v45 = vmul_f32(v53, _D5);
        }
      }
      else
      {
        float32x2_t v32 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v21.f32, 0);
        float32x2_t v33 = vadd_f32(*(float32x2_t *)v15.f32, v32);
        v32.i32[0] = 2.0;
        v32.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v15.u32[1], COERCE_UNSIGNED_INT(sqrtf(v15.f32[0] + (float)((float)(1.0 - v21.f32[1])- *(float *)&v30.i32[2])))), v32).u32[0];
        v32.i32[1] = v33.i32[1];
        float32x2_t v34 = vrecpe_f32((float32x2_t)v32.u32[0]);
        float32x2_t v35 = vmul_f32(v34, vrecps_f32((float32x2_t)v32.u32[0], v34));
        LODWORD(v36) = vmul_f32(v35, vrecps_f32((float32x2_t)v32.u32[0], v35)).u32[0];
        __asm { FMOV            V16.2S, #0.25 }
        _D16.f32[1] = v36;
        *(float32x2_t *)&long long v42 = vmul_f32(v32, _D16);
        float32x2_t v43 = (float32x2_t)vzip2q_s32((int32x4_t)v15, (int32x4_t)v21).u64[0];
        v44.i32[0] = vadd_f32(v43, *(float32x2_t *)v30.i8).u32[0];
        v44.i32[1] = vsub_f32(v43, *(float32x2_t *)&v30).i32[1];
        float32x2_t v45 = vmul_n_f32(v44, v36);
      }
      unint64_t v66 = v6 + 1;
      if (a2 <= v6 + 1) {
        goto LABEL_19;
      }
      unint64_t v67 = *(void *)(result + 8 * v6 + 8);
      unint64_t v68 = a3[11];
      if (v68 <= v67) {
        goto LABEL_20;
      }
      *((float32x2_t *)&v42 + 1) = v45;
      *(_OWORD *)(a3[10] + 16 * v67) = v42;
      v6 += 2;
      if (!--v7) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, a4, a5, a6, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v9);
    _os_crash();
    __break(1u);
LABEL_19:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v66, a2);
    _os_crash();
    __break(1u);
LABEL_20:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v67, v68);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_36::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 2)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 >> 1;
    while (a2 > v3)
    {
      unint64_t v5 = *(void *)(result + 8 * v3);
      unint64_t v6 = a3[7];
      if (v6 <= v5) {
        goto LABEL_10;
      }
      unint64_t v7 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_11;
      }
      unint64_t v8 = *(void *)(result + 8 * v3 + 8);
      unint64_t v9 = a3[15];
      if (v9 <= v8) {
        goto LABEL_12;
      }
      uint64_t v10 = (float32x4_t *)(a3[6] + 48 * v5);
      float32x4_t v11 = vmulq_f32(*v10, *v10);
      float32x4_t v12 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1)));
      v12.f32[0] = sqrtf(v12.f32[0]);
      float32x4_t v13 = vmulq_f32(v10[1], v10[1]);
      float32x4_t v14 = vmulq_f32(v10[2], v10[2]);
      v12.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0]);
      v12.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]);
      *(float32x4_t *)(a3[14] + 16 * v8) = v12;
      v3 += 2;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_10:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
    _os_crash();
    __break(1u);
LABEL_11:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v9);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_37::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 2)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 >> 1;
    while (a2 > v3)
    {
      unint64_t v5 = *(void *)(result + 8 * v3);
      unint64_t v6 = a3[9];
      if (v6 <= v5) {
        goto LABEL_10;
      }
      unint64_t v7 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_11;
      }
      unint64_t v8 = *(void *)(result + 8 * v3 + 8);
      unint64_t v9 = a3[15];
      if (v9 <= v8) {
        goto LABEL_12;
      }
      *(_OWORD *)(a3[14] + 16 * v8) = *(_OWORD *)(a3[8] + (v5 << 6) + 48);
      v3 += 2;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_10:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
    _os_crash();
    __break(1u);
LABEL_11:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v9);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_38::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 4)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 >> 2;
    unint64_t v5 = (uint64_t *)(result + 16);
    while (a2 > v3)
    {
      unint64_t v6 = *(v5 - 2);
      unint64_t v7 = a3[15];
      if (v7 <= v6) {
        goto LABEL_14;
      }
      unint64_t v8 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_15;
      }
      unint64_t v9 = *(v5 - 1);
      if (v7 <= v9) {
        goto LABEL_16;
      }
      unint64_t v10 = v3 + 2;
      if (a2 <= v3 + 2) {
        goto LABEL_17;
      }
      uint64_t v11 = *v5;
      if (v7 <= *v5) {
        goto LABEL_18;
      }
      unint64_t v12 = v3 + 3;
      if (a2 <= v3 + 3) {
        goto LABEL_19;
      }
      unint64_t v13 = v5[1];
      unint64_t v14 = a3[7];
      if (v14 <= v13) {
        goto LABEL_20;
      }
      uint64_t v15 = a3[14];
      long long v16 = *(_OWORD *)(v15 + 16 * v6);
      long long v17 = *(_OWORD *)(v15 + 16 * v9);
      long long v18 = *(_OWORD *)(v15 + 16 * v11);
      float32x4_t v19 = (_OWORD *)(a3[6] + 48 * v13);
      _OWORD *v19 = v16;
      v19[1] = v17;
      void v19[2] = v18;
      v3 += 4;
      v5 += 4;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v6, v7);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v8, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, v7);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v7);
    _os_crash();
    __break(1u);
LABEL_19:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v12, a2);
    _os_crash();
    __break(1u);
LABEL_20:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v13, v14);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_39::__invoke(uint64_t result, unint64_t a2, void *a3, double a4, double a5, float32x4_t a6, float32x4_t a7, float32x4_t a8)
{
  if (a2 >= 3)
  {
    uint64_t v8 = 0;
    LODWORD(a4) = 1.0;
    while (1)
    {
      uint64_t v9 = 3 * v8;
      if (a2 <= 3 * v8) {
        break;
      }
      unint64_t v10 = *(void *)(result + 24 * v8);
      unint64_t v11 = a3[15];
      if (v11 <= v10) {
        goto LABEL_14;
      }
      unint64_t v12 = (unsigned int *)(a3[14] + 16 * v10);
      long long v13 = *v12;
      uint64_t v14 = v9 + 1;
      if (a2 <= v9 + 1) {
        goto LABEL_15;
      }
      unint64_t v15 = *(void *)(result + 8 * v14);
      unint64_t v16 = a3[11];
      if (v16 <= v15) {
        goto LABEL_16;
      }
      uint64_t v17 = 0;
      LODWORD(v18) = 0;
      HIDWORD(v18) = 0;
      *(void *)((char *)&v18 + 4) = v12[1];
      *(void *)&long long v19 = 0;
      *((void *)&v19 + 1) = v12[2];
      int32x4_t v20 = (float *)(a3[10] + 16 * v15);
      float v21 = *v20;
      float v22 = v20[1];
      float v23 = v22 + v22;
      float v24 = v20[2];
      float v25 = v20[3];
      float v26 = v24 + v24;
      float v27 = v21 * (float)(v21 + v21);
      float v28 = v22 * (float)(v22 + v22);
      float v29 = v24 * (float)(v24 + v24);
      float v30 = (float)(v21 + v21) * v22;
      float v31 = (float)(v21 + v21) * v24;
      float v32 = v23 * v24;
      float v33 = (float)(v21 + v21) * v25;
      a6.f32[0] = 1.0 - (float)(v28 + v29);
      a6.f32[1] = v30 + (float)(v26 * v25);
      a7.f32[0] = v30 - (float)(v26 * v25);
      long long v39 = v13;
      long long v40 = v18;
      long long v41 = v19;
      do
      {
        a7.f32[2] = v32 + v33;
        a8.f32[2] = 1.0 - (float)(v27 + v28);
        a7.f32[1] = 1.0 - (float)(v27 + v29);
        a8.f32[1] = v32 - v33;
        a6.f32[2] = v31 - (float)(v23 * v25);
        a8.f32[0] = v31 + (float)(v23 * v25);
        *(float32x4_t *)((char *)&v42 + v17) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a6, COERCE_FLOAT(*(long long *)((char *)&v39 + v17))), a7, *(float32x2_t *)((char *)&v39 + v17), 1), a8, *(float32x4_t *)((char *)&v39 + v17), 2);
        v17 += 16;
      }
      while (v17 != 48);
      unint64_t v34 = v9 + 2;
      if (a2 <= v34) {
        goto LABEL_17;
      }
      unint64_t v35 = *(void *)(result + 8 * v34);
      unint64_t v36 = a3[7];
      if (v36 <= v35) {
        goto LABEL_18;
      }
      int v37 = v43;
      a6 = v44;
      a7 = v45;
      uint64_t v38 = a3[6] + 48 * v35;
      *(void *)uint64_t v38 = v42;
      *(_DWORD *)(v38 + 8) = v37;
      *(void *)(v38 + 16) = a6.i64[0];
      *(_DWORD *)(v38 + 24) = a6.i32[2];
      *(void *)(v38 + 32) = a7.i64[0];
      *(_DWORD *)(v38 + 40) = a7.i32[2];
      if (++v8 == a2 / 3) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, a4, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * v8, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v10, v11, v39, v40, v41);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v14, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v15, v16);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v34, a2);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v35, v36);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_40::__invoke(uint64_t result, unint64_t a2, void *a3, double a4)
{
  if (a2 >= 3)
  {
    unint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    LODWORD(a4) = 1.0;
    while (a2 > v4)
    {
      unint64_t v6 = *(void *)(result + 8 * v4);
      unint64_t v7 = a3[7];
      if (v7 <= v6) {
        goto LABEL_12;
      }
      unint64_t v8 = v4 + 1;
      if (a2 <= v4 + 1) {
        goto LABEL_13;
      }
      unint64_t v9 = *(void *)(result + 8 * v4 + 8);
      unint64_t v10 = a3[15];
      if (v10 <= v9) {
        goto LABEL_14;
      }
      unint64_t v11 = v4 + 2;
      if (a2 <= v4 + 2) {
        goto LABEL_15;
      }
      unint64_t v12 = *(void *)(result + 8 * v4 + 16);
      unint64_t v13 = a3[9];
      if (v13 <= v12) {
        goto LABEL_16;
      }
      uint64_t v14 = a3[6] + 48 * v6;
      *(void *)&long long v15 = *(void *)v14;
      unsigned int v16 = *(_DWORD *)(v14 + 8);
      *(void *)&long long v17 = *(void *)(v14 + 16);
      unsigned int v18 = *(_DWORD *)(v14 + 24);
      *(void *)&long long v19 = *(void *)(v14 + 32);
      unsigned int v20 = *(_DWORD *)(v14 + 40);
      float v21 = (void *)(a3[14] + 16 * v9);
      *(void *)&long long v22 = *v21;
      *((void *)&v15 + 1) = v16;
      *((void *)&v17 + 1) = v18;
      *((void *)&v19 + 1) = v20;
      DWORD2(v22) = v21[1];
      HIDWORD(v22) = 1.0;
      float v23 = (_OWORD *)(a3[8] + (v12 << 6));
      _OWORD *v23 = v15;
      v23[1] = v17;
      v23[2] = v19;
      v23[3] = v22;
      v4 += 3;
      if (!--v5) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, a4, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v4, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v6, v7);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v8, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, v10);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v11, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v13);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_41::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 / 3;
    while (a2 > v3)
    {
      unint64_t v5 = *(void *)(result + 8 * v3);
      unint64_t v6 = a3[7];
      if (v6 <= v5) {
        goto LABEL_12;
      }
      unint64_t v7 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_13;
      }
      unint64_t v8 = *(void *)(result + 8 * v3 + 8);
      unint64_t v9 = a3[15];
      if (v9 <= v8) {
        goto LABEL_14;
      }
      unint64_t v10 = v3 + 2;
      if (a2 <= v3 + 2) {
        goto LABEL_15;
      }
      unint64_t v11 = *(void *)(result + 8 * v3 + 16);
      if (v9 <= v11) {
        goto LABEL_16;
      }
      uint64_t v12 = a3[14];
      *(float32x4_t *)(v12 + 16 * v11) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)(a3[6] + 48 * v5), COERCE_FLOAT(*(_OWORD *)(v12 + 16 * v8))), *(float32x4_t *)(a3[6] + 48 * v5 + 16), *(float32x2_t *)(v12 + 16 * v8), 1), *(float32x4_t *)(a3[6] + 48 * v5 + 32), *(float32x4_t *)(v12 + 16 * v8), 2);
      v3 += 3;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v9);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v9);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

__n128 re::anonymous namespace'::$_42::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v11[0] = a1;
  v11[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      float32x4_t v10 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v6, COERCE_FLOAT(*(_OWORD *)v7->f32)), v6[1], *v7, 1), v6[2], *(float32x4_t *)v7->f32, 2);
      __n128 result = (__n128)v10;
      _OWORD *v8 = v10;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

__n128 re::anonymous namespace'::$_43::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v12[0] = a1;
  v12[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      float32x4_t v8 = vaddq_f32(v6[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v6, COERCE_FLOAT(*(_OWORD *)v7->f32)), v6[1], *v7, 1), v6[2], *(float32x4_t *)v7->f32, 2));
      float32x4_t v11 = vdivq_f32(v8, (float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 3));
      __n128 result = (__n128)v11;
      _OWORD *v9 = v11;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_44::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 / 3;
    uint64_t v6 = a3[10];
    unint64_t v5 = a3[11];
    uint64_t v8 = a3[4];
    unint64_t v7 = a3[5];
    while (a2 > v3)
    {
      unint64_t v9 = *(void *)(result + 8 * v3);
      if (v5 <= v9) {
        goto LABEL_12;
      }
      unint64_t v10 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_13;
      }
      unint64_t v11 = *(void *)(result + 8 * v3 + 8);
      if (v5 <= v11) {
        goto LABEL_14;
      }
      unint64_t v12 = v3 + 2;
      if (a2 <= v3 + 2) {
        goto LABEL_15;
      }
      unint64_t v13 = *(void *)(result + 8 * v3 + 16);
      if (v7 <= v13) {
        goto LABEL_16;
      }
      int8x16_t v14 = (int8x16_t)vmulq_f32(*(float32x4_t *)(v6 + 16 * v9), *(float32x4_t *)(v6 + 16 * v11));
      *(float *)(v8 + 4 * v13) = vaddv_f32(vadd_f32(*(float32x2_t *)v14.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL)));
      v3 += 3;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, v5);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v5);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v12, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v13, v7);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

_OWORD *re::anonymous namespace'::$_45::__invoke(_OWORD *result, unint64_t a2, uint64_t a3)
{
  v11[0] = result;
  v11[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      __float2 v7 = __sincosf_stret(v6 * 0.5);
      float32x4_t v8 = vmulq_n_f32(v9, v7.__sinval);
      v8.i32[3] = LODWORD(v7.__cosval);
      float32x4_t v10 = v8;
      *__n128 result = v10;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

__n128 re::anonymous namespace'::$_46::__invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  v12[0] = a1;
  v12[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      __n128 v8 = *v6;
      v8.n128_u32[3] = *v7;
      __n128 v11 = v8;
      __n128 result = v11;
      _OWORD *v9 = v11;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_47::__invoke(uint64_t result, unint64_t a2, void *a3, __n128 a4)
{
  if (a2 >= 4)
  {
    unint64_t v4 = 0;
    unint64_t v5 = a2 >> 2;
    float v6 = (uint64_t *)(result + 16);
    while (a2 > v4)
    {
      unint64_t v7 = *(v6 - 2);
      unint64_t v8 = a3[5];
      if (v8 <= v7) {
        goto LABEL_14;
      }
      unint64_t v9 = v4 + 1;
      if (a2 <= v4 + 1) {
        goto LABEL_15;
      }
      unint64_t v10 = *(v6 - 1);
      if (v8 <= v10) {
        goto LABEL_16;
      }
      unint64_t v11 = v4 + 2;
      if (a2 <= v4 + 2) {
        goto LABEL_17;
      }
      uint64_t v12 = *v6;
      if (v8 <= *v6) {
        goto LABEL_18;
      }
      unint64_t v13 = v4 + 3;
      if (a2 <= v4 + 3) {
        goto LABEL_19;
      }
      unint64_t v14 = v6[1];
      unint64_t v15 = a3[15];
      if (v15 <= v14) {
        goto LABEL_20;
      }
      uint64_t v16 = a3[4];
      a4.n128_u32[0] = *(_DWORD *)(v16 + 4 * v7);
      a4.n128_u32[1] = *(_DWORD *)(v16 + 4 * v10);
      a4.n128_u32[2] = *(_DWORD *)(v16 + 4 * v12);
      *(__n128 *)(a3[14] + 16 * v14) = a4;
      v4 += 4;
      v6 += 4;
      if (!--v5) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v4, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v7, v8);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v10, v8);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v11, a2);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v8);
    _os_crash();
    __break(1u);
LABEL_19:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v13, a2);
    _os_crash();
    __break(1u);
LABEL_20:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v14, v15);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_48::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 3)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 / 3;
    while (a2 > v3)
    {
      unint64_t v5 = *(void *)(result + 8 * v3);
      unint64_t v6 = a3[5];
      if (v6 <= v5) {
        goto LABEL_12;
      }
      unint64_t v7 = v3 + 1;
      if (a2 <= v3 + 1) {
        goto LABEL_13;
      }
      unint64_t v8 = *(void *)(result + 8 * v3 + 8);
      if (v6 <= v8) {
        goto LABEL_14;
      }
      unint64_t v9 = v3 + 2;
      if (a2 <= v3 + 2) {
        goto LABEL_15;
      }
      unint64_t v10 = *(void *)(result + 8 * v3 + 16);
      unint64_t v11 = a3[13];
      if (v11 <= v10) {
        goto LABEL_16;
      }
      uint64_t v12 = a3[4];
      LODWORD(v13) = *(_DWORD *)(v12 + 4 * v5);
      HIDWORD(v13) = *(_DWORD *)(v12 + 4 * v8);
      *(void *)(a3[12] + 8 * v10) = v13;
      v3 += 3;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v6);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v10, v11);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

float *re::anonymous namespace'::$_49::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      float v7 = v6
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

float *re::anonymous namespace'::$_50::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      float v7 = v6
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

float *re::anonymous namespace'::$_51::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      float v7 = v6
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

float *re::anonymous namespace'::$_52::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      float v7 = v6
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

float *re::anonymous namespace'::$_53::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 >> 1;
    do
    {
      float v7 = sinf(*v6);
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

float *re::anonymous namespace'::$_54::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 >> 1;
    do
    {
      float v7 = cosf(*v6);
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

float *re::anonymous namespace'::$_55::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 >> 1;
    do
    {
      float v7 = tanf(*v6);
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

float *re::anonymous namespace'::$_56::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 >> 1;
    do
    {
      float v7 = asinf(*v6);
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

float *re::anonymous namespace'::$_57::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 >> 1;
    do
    {
      float v7 = acosf(*v6);
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

float *re::anonymous namespace'::$_58::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 >> 1;
    do
    {
      float v7 = atanf(*v6);
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

float *re::anonymous namespace'::$_59::__invoke(float *result, unint64_t a2, uint64_t a3)
{
  v9[0] = result;
  v9[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      float v8 = atan2f(v6, *v7);
      *__n128 result = v8;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t re::anonymous namespace'::$_60::__invoke(uint64_t result, unint64_t a2, void *a3)
{
  if (a2 >= 4)
  {
    unint64_t v3 = 0;
    unint64_t v4 = a2 >> 2;
    uint64_t v6 = a3[2];
    unint64_t v5 = a3[3];
    float v7 = (unint64_t *)(result + 16);
    uint64_t v9 = a3[4];
    unint64_t v8 = a3[5];
    while (a2 > v3)
    {
      unint64_t v10 = *(v7 - 2);
      if (v5 <= v10) {
        goto LABEL_16;
      }
      if (*(_DWORD *)(v6 + 4 * v10))
      {
        unint64_t v11 = v3 + 1;
        if (a2 <= v3 + 1) {
          goto LABEL_19;
        }
        unint64_t v12 = *(v7 - 1);
        if (v8 <= v12) {
          goto LABEL_20;
        }
      }
      else
      {
        unint64_t v13 = v3 + 2;
        if (a2 <= v3 + 2) {
          goto LABEL_21;
        }
        unint64_t v12 = *v7;
        if (v8 <= *v7) {
          goto LABEL_22;
        }
      }
      unint64_t v14 = v3 + 3;
      if (a2 <= v3 + 3) {
        goto LABEL_17;
      }
      unint64_t v15 = v7[1];
      if (v8 <= v15) {
        goto LABEL_18;
      }
      *(_DWORD *)(v9 + 4 * v15) = *(_DWORD *)(v9 + 4 * v12);
      v3 += 4;
      v7 += 4;
      if (!--v4) {
        return result;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, a2);
    _os_crash();
    __break(1u);
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v10, v5);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v14, a2);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v15, v8);
    _os_crash();
    __break(1u);
LABEL_19:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v11, a2);
    _os_crash();
    __break(1u);
LABEL_20:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v8);
    _os_crash();
    __break(1u);
LABEL_21:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v13, a2);
    _os_crash();
    __break(1u);
LABEL_22:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v8);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

_DWORD *re::anonymous namespace'::$_61::__invoke(_DWORD *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

_DWORD *re::anonymous namespace'::$_62::__invoke(_DWORD *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

_DWORD *re::anonymous namespace'::$_63::__invoke(_DWORD *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

_DWORD *re::anonymous namespace'::$_64::__invoke(_DWORD *result, unint64_t a2, uint64_t a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

_DWORD *re::anonymous namespace'::$_65::__invoke(_DWORD *result, unint64_t a2, void *a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

_DWORD *re::anonymous namespace'::$_66::__invoke(_DWORD *result, unint64_t a2, void *a3)
{
  v8[0] = result;
  v8[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      *__n128 result = v7;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

_DWORD *re::anonymous namespace'::$_67::__invoke(_DWORD *result, unint64_t a2, uint64_t a3)
{
  v9[0] = result;
  v9[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = a2 / 3;
    do
    {
      BOOL v8 = v6 == v7 || vabds_f32(v6, v7) < (float)((float)((float)(fabsf(v6) + fabsf(v7)) + 1.0) * 0.00001);
      *__n128 result = v8;
      ++v4;
    }
    while (v5 != v4);
  }
  return result;
}

void re::anonymous namespace'::$_68::__invoke(BOOL a1, unint64_t a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (a2 >= 3)
  {
    uint64_t v5 = a1;
    unint64_t v6 = 0;
    for (unint64_t i = a2 / 3; i; --i)
    {
      BOOL v8 = *re::animationLogObjects((re *)a1);
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_INFO);
      if (v9)
      {
        if (a2 <= v6)
        {
          re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
          _os_crash();
          __break(1u);
LABEL_14:
          re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v16, a2);
          _os_crash();
          __break(1u);
LABEL_15:
          re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v12);
          _os_crash();
          __break(1u);
LABEL_16:
          re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v17, v18);
          _os_crash();
          __break(1u);
        }
        unint64_t v11 = *(void *)(v5 + 8 * v6);
        unint64_t v12 = a3[3];
        if (v12 <= v11) {
          goto LABEL_15;
        }
        int v13 = *(_DWORD *)(a3[2] + 4 * v11);
        *(_DWORD *)buf = 67109120;
        int v21 = v13;
        _os_log_impl(&dword_233120000, v8, OS_LOG_TYPE_INFO, "Int32 %u:", buf, 8u);
      }
      unint64_t v14 = *re::animationLogObjects((re *)v9);
      a1 = os_log_type_enabled(v14, OS_LOG_TYPE_INFO);
      if (a1)
      {
        unint64_t v16 = v6 + 1;
        if (a2 <= v6 + 1) {
          goto LABEL_14;
        }
        unint64_t v17 = *(void *)(v5 + 8 * v6 + 8);
        unint64_t v18 = a3[1];
        if (v18 <= v17) {
          goto LABEL_16;
        }
        int v19 = *(_DWORD *)(*a3 + 4 * v17);
        *(_DWORD *)buf = 67109120;
        int v21 = v19;
        _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_INFO, "%i", buf, 8u);
      }
      v6 += 3;
    }
  }
}

void re::anonymous namespace'::$_69::__invoke(BOOL a1, unint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (a2 >= 3)
  {
    uint64_t v5 = a1;
    unint64_t v6 = 0;
    for (unint64_t i = a2 / 3; i; --i)
    {
      BOOL v8 = *re::animationLogObjects((re *)a1);
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_INFO);
      if (v9)
      {
        if (a2 <= v6)
        {
          re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
          _os_crash();
          __break(1u);
LABEL_14:
          re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v16, a2);
          _os_crash();
          __break(1u);
LABEL_15:
          re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v12);
          _os_crash();
          __break(1u);
LABEL_16:
          re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v17, v18);
          _os_crash();
          __break(1u);
        }
        unint64_t v11 = *(void *)(v5 + 8 * v6);
        unint64_t v12 = *(void *)(a3 + 24);
        if (v12 <= v11) {
          goto LABEL_15;
        }
        int v13 = *(_DWORD *)(*(void *)(a3 + 16) + 4 * v11);
        *(_DWORD *)buf = 67109120;
        int v21 = v13;
        _os_log_impl(&dword_233120000, v8, OS_LOG_TYPE_INFO, "UInt32 %u:", buf, 8u);
      }
      unint64_t v14 = *re::animationLogObjects((re *)v9);
      a1 = os_log_type_enabled(v14, OS_LOG_TYPE_INFO);
      if (a1)
      {
        unint64_t v16 = v6 + 1;
        if (a2 <= v6 + 1) {
          goto LABEL_14;
        }
        unint64_t v17 = *(void *)(v5 + 8 * v6 + 8);
        unint64_t v18 = *(void *)(a3 + 24);
        if (v18 <= v17) {
          goto LABEL_16;
        }
        int v19 = *(_DWORD *)(*(void *)(a3 + 16) + 4 * v17);
        *(_DWORD *)buf = 67109120;
        int v21 = v19;
        _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_INFO, "%u", buf, 8u);
      }
      v6 += 3;
    }
  }
}

void re::anonymous namespace'::$_70::__invoke(BOOL a1, unint64_t a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (a2 >= 3)
  {
    uint64_t v5 = a1;
    unint64_t v6 = 0;
    for (unint64_t i = a2 / 3; i; --i)
    {
      BOOL v8 = *re::animationLogObjects((re *)a1);
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_INFO);
      if (v9)
      {
        if (a2 <= v6)
        {
          re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
          _os_crash();
          __break(1u);
LABEL_14:
          re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v16, a2);
          _os_crash();
          __break(1u);
LABEL_15:
          re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v12);
          _os_crash();
          __break(1u);
LABEL_16:
          re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v17, v18);
          _os_crash();
          __break(1u);
        }
        unint64_t v11 = *(void *)(v5 + 8 * v6);
        unint64_t v12 = a3[3];
        if (v12 <= v11) {
          goto LABEL_15;
        }
        int v13 = *(_DWORD *)(a3[2] + 4 * v11);
        *(_DWORD *)buf = 67109120;
        LODWORD(v21) = v13;
        _os_log_impl(&dword_233120000, v8, OS_LOG_TYPE_INFO, "Float %u:", buf, 8u);
      }
      unint64_t v14 = *re::animationLogObjects((re *)v9);
      a1 = os_log_type_enabled(v14, OS_LOG_TYPE_INFO);
      if (a1)
      {
        unint64_t v16 = v6 + 1;
        if (a2 <= v6 + 1) {
          goto LABEL_14;
        }
        unint64_t v17 = *(void *)(v5 + 8 * v6 + 8);
        unint64_t v18 = a3[5];
        if (v18 <= v17) {
          goto LABEL_16;
        }
        double v19 = *(float *)(a3[4] + 4 * v17);
        *(_DWORD *)buf = 134217984;
        double v21 = v19;
        _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_INFO, "%f", buf, 0xCu);
      }
      v6 += 3;
    }
  }
}

void re::anonymous namespace'::$_71::__invoke(BOOL a1, unint64_t a2, uint64_t a3)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  v29[0] = a1;
  v29[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v5 = a1;
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = a2 / 3;
    do
    {
      BOOL v9 = *re::animationLogObjects((re *)a1);
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_INFO);
      if (v10)
      {
        if (a2 <= v6)
        {
          re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
          _os_crash();
          __break(1u);
LABEL_16:
          re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v13);
          _os_crash();
          __break(1u);
        }
        unint64_t v12 = *(void *)(v5 + 8 * v6);
        unint64_t v13 = *(void *)(a3 + 24);
        if (v13 <= v12) {
          goto LABEL_16;
        }
        int v14 = *(_DWORD *)(*(void *)(a3 + 16) + 4 * v12);
        *(_DWORD *)buf = 67109120;
        LODWORD(v31) = v14;
        _os_log_impl(&dword_233120000, v9, OS_LOG_TYPE_INFO, "Matrix3x3 %u:", buf, 8u);
      }
      uint64_t v15 = *re::animationLogObjects((re *)v10);
      BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_INFO);
      if (v16)
      {
        *(_DWORD *)buf = 134218496;
        double v31 = v17;
        __int16 v32 = 2048;
        double v33 = v18;
        __int16 v34 = 2048;
        double v35 = v19;
        _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_INFO, "Columns[0]: %f %f %f", buf, 0x20u);
      }
      unsigned int v20 = *re::animationLogObjects((re *)v16);
      BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_INFO);
      if (v21)
      {
        *(_DWORD *)buf = 134218496;
        double v31 = v22;
        __int16 v32 = 2048;
        double v33 = v23;
        __int16 v34 = 2048;
        double v35 = v24;
        _os_log_impl(&dword_233120000, v20, OS_LOG_TYPE_INFO, "Columns[1]: %f %f %f", buf, 0x20u);
      }
      float v25 = *re::animationLogObjects((re *)v21);
      a1 = os_log_type_enabled(v25, OS_LOG_TYPE_INFO);
      if (a1)
      {
        *(_DWORD *)buf = 134218496;
        double v31 = v26;
        __int16 v32 = 2048;
        double v33 = v27;
        __int16 v34 = 2048;
        double v35 = v28;
        _os_log_impl(&dword_233120000, v25, OS_LOG_TYPE_INFO, "Columns[2]: %f %f %f", buf, 0x20u);
      }
      ++v7;
      v6 += 3;
    }
    while (v8 != v7);
  }
}

void re::anonymous namespace'::$_72::__invoke(BOOL a1, unint64_t a2, uint64_t a3)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  v38[0] = a1;
  v38[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v5 = a1;
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = a2 / 3;
    do
    {
      BOOL v9 = *re::animationLogObjects((re *)a1);
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_INFO);
      if (v10)
      {
        if (a2 <= v6)
        {
          re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
          _os_crash();
          __break(1u);
LABEL_18:
          re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v13);
          _os_crash();
          __break(1u);
        }
        unint64_t v12 = *(void *)(v5 + 8 * v6);
        unint64_t v13 = *(void *)(a3 + 24);
        if (v13 <= v12) {
          goto LABEL_18;
        }
        int v14 = *(_DWORD *)(*(void *)(a3 + 16) + 4 * v12);
        *(_DWORD *)buf = 67109120;
        LODWORD(v40) = v14;
        _os_log_impl(&dword_233120000, v9, OS_LOG_TYPE_INFO, "Matrix4x4 %u:", buf, 8u);
      }
      uint64_t v15 = *re::animationLogObjects((re *)v10);
      BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_INFO);
      if (v16)
      {
        *(_DWORD *)buf = 134218752;
        double v40 = v17;
        __int16 v41 = 2048;
        double v42 = v18;
        __int16 v43 = 2048;
        double v44 = v19;
        __int16 v45 = 2048;
        double v46 = v20;
        _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_INFO, "Columns[0]: %f %f %f %f", buf, 0x2Au);
      }
      BOOL v21 = *re::animationLogObjects((re *)v16);
      BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_INFO);
      if (v22)
      {
        *(_DWORD *)buf = 134218752;
        double v40 = v23;
        __int16 v41 = 2048;
        double v42 = v24;
        __int16 v43 = 2048;
        double v44 = v25;
        __int16 v45 = 2048;
        double v46 = v26;
        _os_log_impl(&dword_233120000, v21, OS_LOG_TYPE_INFO, "Columns[1]: %f %f %f %f", buf, 0x2Au);
      }
      double v27 = *re::animationLogObjects((re *)v22);
      BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_INFO);
      if (v28)
      {
        *(_DWORD *)buf = 134218752;
        double v40 = v29;
        __int16 v41 = 2048;
        double v42 = v30;
        __int16 v43 = 2048;
        double v44 = v31;
        __int16 v45 = 2048;
        double v46 = v32;
        _os_log_impl(&dword_233120000, v27, OS_LOG_TYPE_INFO, "Columns[2]: %f %f %f %f", buf, 0x2Au);
      }
      double v33 = *re::animationLogObjects((re *)v28);
      a1 = os_log_type_enabled(v33, OS_LOG_TYPE_INFO);
      if (a1)
      {
        *(_DWORD *)buf = 134218752;
        double v40 = v34;
        __int16 v41 = 2048;
        double v42 = v35;
        __int16 v43 = 2048;
        double v44 = v36;
        __int16 v45 = 2048;
        double v46 = v37;
        _os_log_impl(&dword_233120000, v33, OS_LOG_TYPE_INFO, "Columns[3]: %f %f %f %f", buf, 0x2Au);
      }
      ++v7;
      v6 += 3;
    }
    while (v8 != v7);
  }
}

void re::anonymous namespace'::$_73::__invoke(BOOL a1, unint64_t a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  v20[0] = a1;
  v20[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v5 = a1;
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = a2 / 3;
    do
    {
      BOOL v9 = *re::animationLogObjects((re *)a1);
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_INFO);
      if (v10)
      {
        if (a2 <= v6)
        {
          re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
          _os_crash();
          __break(1u);
LABEL_12:
          re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v13);
          _os_crash();
          __break(1u);
        }
        unint64_t v12 = *(void *)(v5 + 8 * v6);
        unint64_t v13 = *(void *)(a3 + 24);
        if (v13 <= v12) {
          goto LABEL_12;
        }
        int v14 = *(_DWORD *)(*(void *)(a3 + 16) + 4 * v12);
        *(_DWORD *)buf = 67109120;
        LODWORD(v22) = v14;
        _os_log_impl(&dword_233120000, v9, OS_LOG_TYPE_INFO, "Quaternion %u:", buf, 8u);
      }
      uint64_t v15 = *re::animationLogObjects((re *)v10);
      a1 = os_log_type_enabled(v15, OS_LOG_TYPE_INFO);
      if (a1)
      {
        *(_DWORD *)buf = 134218752;
        double v22 = v16;
        __int16 v23 = 2048;
        double v24 = v17;
        __int16 v25 = 2048;
        double v26 = v18;
        __int16 v27 = 2048;
        double v28 = v19;
        _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_INFO, "%f %f %f %f", buf, 0x2Au);
      }
      ++v7;
      v6 += 3;
    }
    while (v8 != v7);
  }
}

void re::anonymous namespace'::$_74::__invoke(BOOL a1, unint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  v18[0] = a1;
  v18[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v5 = a1;
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = a2 / 3;
    do
    {
      BOOL v9 = *re::animationLogObjects((re *)a1);
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_INFO);
      if (v10)
      {
        if (a2 <= v6)
        {
          re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
          _os_crash();
          __break(1u);
LABEL_12:
          re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v13);
          _os_crash();
          __break(1u);
        }
        unint64_t v12 = *(void *)(v5 + 8 * v6);
        unint64_t v13 = *(void *)(a3 + 24);
        if (v13 <= v12) {
          goto LABEL_12;
        }
        int v14 = *(_DWORD *)(*(void *)(a3 + 16) + 4 * v12);
        *(_DWORD *)buf = 67109120;
        LODWORD(v20) = v14;
        _os_log_impl(&dword_233120000, v9, OS_LOG_TYPE_INFO, "Vector2 %u:", buf, 8u);
      }
      uint64_t v15 = *re::animationLogObjects((re *)v10);
      a1 = os_log_type_enabled(v15, OS_LOG_TYPE_INFO);
      if (a1)
      {
        *(_DWORD *)buf = 134218240;
        double v20 = v16;
        __int16 v21 = 2048;
        double v22 = v17;
        _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_INFO, "%f %f", buf, 0x16u);
      }
      ++v7;
      v6 += 3;
    }
    while (v8 != v7);
  }
}

void re::anonymous namespace'::$_75::__invoke(BOOL a1, unint64_t a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  v19[0] = a1;
  v19[1] = a2;
  if (a2 >= 3)
  {
    uint64_t v5 = a1;
    unint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = a2 / 3;
    do
    {
      BOOL v9 = *re::animationLogObjects((re *)a1);
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_INFO);
      if (v10)
      {
        if (a2 <= v6)
        {
          re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
          _os_crash();
          __break(1u);
LABEL_12:
          re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v13);
          _os_crash();
          __break(1u);
        }
        unint64_t v12 = *(void *)(v5 + 8 * v6);
        unint64_t v13 = *(void *)(a3 + 24);
        if (v13 <= v12) {
          goto LABEL_12;
        }
        int v14 = *(_DWORD *)(*(void *)(a3 + 16) + 4 * v12);
        *(_DWORD *)buf = 67109120;
        LODWORD(v21) = v14;
        _os_log_impl(&dword_233120000, v9, OS_LOG_TYPE_INFO, "Vector3 %u:", buf, 8u);
      }
      uint64_t v15 = *re::animationLogObjects((re *)v10);
      a1 = os_log_type_enabled(v15, OS_LOG_TYPE_INFO);
      if (a1)
      {
        *(_DWORD *)buf = 134218496;
        double v21 = v16;
        __int16 v22 = 2048;
        double v23 = v17;
        __int16 v24 = 2048;
        double v25 = v18;
        _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_INFO, "%f %f %f", buf, 0x20u);
      }
      ++v7;
      v6 += 3;
    }
    while (v8 != v7);
  }
}

uint64_t re::anonymous namespace'::$_76::__invoke(uint64_t result, uint64_t a2, uint64_t *a3)
{
  if (a2)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0;
    while (1)
    {
      uint64_t v6 = *(void *)(v4 + 8 * v5);
      uint64_t v8 = a3[16];
      uint64_t v7 = a3[17];
      uint64_t v9 = v8 + 448 * v6;
      BOOL v10 = (void *)(v7 + 432 * v6);
      uint64_t v11 = *(void *)(v9 + 16);
      if (v11) {
        break;
      }
LABEL_8:
      uint64_t v19 = *(void *)(v8 + 448 * v6 + 40);
      if (v19)
      {
        uint64_t v20 = 0;
        uint64_t v21 = *(void *)(v8 + 448 * v6 + 48);
        uint64_t v23 = a3[2];
        unint64_t v22 = a3[3];
        uint64_t v25 = v10[4];
        uint64_t v24 = v10[5];
        while (1)
        {
          unint64_t v26 = *(void *)(v21 + 8 * v20);
          if (v22 <= v26) {
            break;
          }
          if (v25 == v20) {
            goto LABEL_110;
          }
          *(_DWORD *)(v24 + 4 * v20++) = *(_DWORD *)(v23 + 4 * v26);
          if (v19 == v20) {
            goto LABEL_13;
          }
        }
LABEL_109:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v26, v22);
        _os_crash();
        __break(1u);
LABEL_110:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_111;
      }
LABEL_13:
      uint64_t v27 = *(void *)(v8 + 448 * v6 + 64);
      if (v27)
      {
        uint64_t v28 = 0;
        uint64_t v29 = *(void *)(v8 + 448 * v6 + 72);
        uint64_t v31 = a3[4];
        unint64_t v30 = a3[5];
        uint64_t v33 = v10[7];
        uint64_t v32 = v10[8];
        while (1)
        {
          unint64_t v34 = *(void *)(v29 + 8 * v28);
          if (v30 <= v34) {
            break;
          }
          if (v33 == v28) {
            goto LABEL_112;
          }
          *(_DWORD *)(v32 + 4 * v28++) = *(_DWORD *)(v31 + 4 * v34);
          if (v27 == v28) {
            goto LABEL_18;
          }
        }
LABEL_111:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v34, v30);
        _os_crash();
        __break(1u);
LABEL_112:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_113;
      }
LABEL_18:
      uint64_t v35 = v8 + 448 * v6;
      uint64_t v37 = *(void *)(v35 + 88);
      double v36 = (unint64_t *)(v35 + 88);
      if (v37)
      {
        uint64_t v38 = 0;
        unint64_t v39 = 0;
        while (1)
        {
          unint64_t v40 = *(void *)(*(void *)(v8 + 448 * v6 + 96) + 8 * v39);
          unint64_t v41 = a3[7];
          if (v41 <= v40) {
            break;
          }
          if (v10[10] <= v39) {
            goto LABEL_114;
          }
          double v42 = (long long *)(a3[6] + 48 * v40);
          __int16 v43 = (_OWORD *)(v10[11] + v38);
          long long v44 = *v42;
          long long v45 = v42[2];
          v43[1] = v42[1];
          v43[2] = v45;
          _OWORD *v43 = v44;
          ++v39;
          v38 += 48;
          if (v39 >= *v36) {
            goto LABEL_23;
          }
        }
LABEL_113:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v40, v41);
        _os_crash();
        __break(1u);
LABEL_114:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_115;
      }
LABEL_23:
      uint64_t v46 = v8 + 448 * v6;
      uint64_t v48 = *(void *)(v46 + 112);
      uint64_t v47 = (unint64_t *)(v46 + 112);
      if (v48)
      {
        uint64_t v49 = 0;
        unint64_t v50 = 0;
        while (1)
        {
          unint64_t v51 = *(void *)(*(void *)(v8 + 448 * v6 + 120) + 8 * v50);
          unint64_t v52 = a3[9];
          if (v52 <= v51) {
            break;
          }
          if (v10[13] <= v50) {
            goto LABEL_116;
          }
          float32x2_t v53 = (long long *)(a3[8] + (v51 << 6));
          float32x2_t v54 = (_OWORD *)(v10[14] + v49);
          long long v55 = *v53;
          long long v56 = v53[1];
          long long v57 = v53[3];
          v54[2] = v53[2];
          v54[3] = v57;
          *float32x2_t v54 = v55;
          v54[1] = v56;
          ++v50;
          v49 += 64;
          if (v50 >= *v47) {
            goto LABEL_28;
          }
        }
LABEL_115:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v51, v52);
        _os_crash();
        __break(1u);
LABEL_116:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_117;
      }
LABEL_28:
      uint64_t v58 = v8 + 448 * v6;
      uint64_t v60 = *(void *)(v58 + 136);
      unsigned int v59 = (unint64_t *)(v58 + 136);
      if (v60)
      {
        uint64_t v61 = 0;
        unint64_t v62 = 0;
        while (1)
        {
          unint64_t v63 = *(void *)(*(void *)(v8 + 448 * v6 + 144) + 8 * v62);
          unint64_t v64 = a3[11];
          if (v64 <= v63) {
            break;
          }
          if (v10[16] <= v62) {
            goto LABEL_118;
          }
          *(_OWORD *)(v10[17] + v61) = *(_OWORD *)(a3[10] + 16 * v63);
          ++v62;
          v61 += 16;
          if (v62 >= *v59) {
            goto LABEL_33;
          }
        }
LABEL_117:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v63, v64);
        _os_crash();
        __break(1u);
LABEL_118:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_119;
      }
LABEL_33:
      uint64_t v65 = v8 + 448 * v6;
      uint64_t v67 = *(void *)(v65 + 160);
      unint64_t v66 = (unint64_t *)(v65 + 160);
      if (v67)
      {
        unint64_t v68 = 0;
        while (1)
        {
          unint64_t v69 = *(void *)(*(void *)(v8 + 448 * v6 + 168) + 8 * v68);
          unint64_t v70 = a3[13];
          if (v70 <= v69) {
            break;
          }
          if (v10[19] <= v68) {
            goto LABEL_120;
          }
          *(void *)(v10[20] + 8 * v68++) = *(void *)(a3[12] + 8 * v69);
          if (v68 >= *v66) {
            goto LABEL_38;
          }
        }
LABEL_119:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v69, v70);
        _os_crash();
        __break(1u);
LABEL_120:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_121:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v76, v77);
        _os_crash();
        __break(1u);
LABEL_122:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_123:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_124:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v103, v101);
        _os_crash();
        __break(1u);
LABEL_125:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v88, v89);
        _os_crash();
        __break(1u);
LABEL_126:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_127:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_128:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v90, v91);
        _os_crash();
        __break(1u);
LABEL_129:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_130:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_131:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v92, v93);
        _os_crash();
        __break(1u);
LABEL_132:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_133;
      }
LABEL_38:
      uint64_t v71 = v8 + 448 * v6;
      uint64_t v73 = *(void *)(v71 + 184);
      uint64_t v72 = (unint64_t *)(v71 + 184);
      if (v73)
      {
        uint64_t v74 = 0;
        unint64_t v75 = 0;
        do
        {
          unint64_t v76 = *(void *)(*(void *)(v8 + 448 * v6 + 192) + 8 * v75);
          unint64_t v77 = a3[15];
          if (v77 <= v76) {
            goto LABEL_121;
          }
          if (v10[22] <= v75) {
            goto LABEL_122;
          }
          *(_OWORD *)(v10[23] + v74) = *(_OWORD *)(a3[14] + 16 * v76);
          ++v75;
          v74 += 16;
        }
        while (v75 < *v72);
      }
      uint64_t v78 = v8 + 448 * v6;
      uint64_t v80 = *(void *)(v78 + 208);
      unint64_t v79 = (unint64_t *)(v78 + 208);
      if (v80)
      {
        uint64_t v81 = 0;
        uint64_t v82 = 0;
        unint64_t v83 = 0;
        long long v84 = (void *)(v8 + 448 * v6 + 216);
        uint64_t v85 = v7 + 432 * v6;
        unint64_t v86 = (unint64_t *)(v85 + 200);
        unint64_t v87 = (void *)(v85 + 208);
        do
        {
          unint64_t v88 = *(void *)(*v84 + v81);
          unint64_t v89 = a3[15];
          if (v89 <= v88) {
            goto LABEL_125;
          }
          if (*v86 <= v83) {
            goto LABEL_126;
          }
          *(_OWORD *)(*v87 + v82) = *(_OWORD *)(a3[14] + 16 * v88);
          if (*v79 <= v83) {
            goto LABEL_127;
          }
          unint64_t v90 = *(void *)(*v84 + v81 + 8);
          unint64_t v91 = a3[11];
          if (v91 <= v90) {
            goto LABEL_128;
          }
          if (*v86 <= v83) {
            goto LABEL_129;
          }
          *(_OWORD *)(*v87 + v82 + 16) = *(_OWORD *)(a3[10] + 16 * v90);
          if (*v79 <= v83) {
            goto LABEL_130;
          }
          unint64_t v92 = *(void *)(*v84 + v81 + 16);
          unint64_t v93 = a3[15];
          if (v93 <= v92) {
            goto LABEL_131;
          }
          if (*v86 <= v83) {
            goto LABEL_132;
          }
          *(_OWORD *)(*v87 + v82 + 32) = *(_OWORD *)(a3[14] + 16 * v92);
          ++v83;
          v82 += 48;
          v81 += 24;
        }
        while (v83 < *v79);
      }
      uint64_t v94 = v8 + 448 * v6;
      __n128 result = (*(uint64_t (**)(void *, void))v9)(v10, *(void *)(v94 + 440));
      uint64_t v95 = *(void *)(v94 + 232);
      if (v95)
      {
        uint64_t v96 = 0;
        uint64_t v97 = *(void *)(v8 + 448 * v6 + 240);
        uint64_t v98 = v7 + 432 * v6;
        uint64_t v100 = *(void *)(v98 + 224);
        uint64_t v99 = *(void *)(v98 + 232);
        uint64_t v102 = *a3;
        unint64_t v101 = a3[1];
        while (v100 != v96)
        {
          unint64_t v103 = *(void *)(v97 + 8 * v96);
          if (v101 <= v103) {
            goto LABEL_124;
          }
          *(_DWORD *)(v102 + 4 * v103) = *(_DWORD *)(v99 + 4 * v96++);
          if (v95 == v96) {
            goto LABEL_59;
          }
        }
        goto LABEL_123;
      }
LABEL_59:
      uint64_t v104 = *(void *)(v8 + 448 * v6 + 256);
      if (v104)
      {
        uint64_t v105 = 0;
        uint64_t v106 = *(void *)(v8 + 448 * v6 + 264);
        uint64_t v107 = v7 + 432 * v6;
        uint64_t v109 = *(void *)(v107 + 248);
        uint64_t v108 = *(void *)(v107 + 256);
        uint64_t v111 = a3[2];
        unint64_t v110 = a3[3];
        while (v109 != v105)
        {
          unint64_t v112 = *(void *)(v106 + 8 * v105);
          if (v110 <= v112) {
            goto LABEL_134;
          }
          *(_DWORD *)(v111 + 4 * v112) = *(_DWORD *)(v108 + 4 * v105++);
          if (v104 == v105) {
            goto LABEL_64;
          }
        }
LABEL_133:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_134:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v112, v110);
        _os_crash();
        __break(1u);
        goto LABEL_135;
      }
LABEL_64:
      uint64_t v113 = *(void *)(v8 + 448 * v6 + 280);
      if (v113)
      {
        uint64_t v114 = 0;
        uint64_t v115 = *(void *)(v8 + 448 * v6 + 288);
        uint64_t v116 = v7 + 432 * v6;
        uint64_t v118 = *(void *)(v116 + 272);
        uint64_t v117 = *(void *)(v116 + 280);
        uint64_t v120 = a3[4];
        unint64_t v119 = a3[5];
        while (v118 != v114)
        {
          unint64_t v121 = *(void *)(v115 + 8 * v114);
          if (v119 <= v121) {
            goto LABEL_136;
          }
          *(_DWORD *)(v120 + 4 * v121) = *(_DWORD *)(v117 + 4 * v114++);
          if (v113 == v114) {
            goto LABEL_69;
          }
        }
LABEL_135:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_136:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v121, v119);
        _os_crash();
        __break(1u);
        goto LABEL_137;
      }
LABEL_69:
      uint64_t v122 = v8 + 448 * v6;
      if (*(void *)(v122 + 304))
      {
        uint64_t v123 = 0;
        unint64_t v124 = 0;
        uint64_t v125 = (unint64_t *)(v122 + 304);
        uint64_t v126 = v7 + 432 * v6;
        uint64_t v127 = (unint64_t *)(v126 + 296);
        uint64_t v128 = (void *)(v126 + 304);
        while (*v127 > v124)
        {
          unint64_t v129 = *(void *)(*(void *)(v8 + 448 * v6 + 312) + 8 * v124);
          unint64_t v130 = a3[7];
          if (v130 <= v129) {
            goto LABEL_138;
          }
          uint64_t v131 = (long long *)(*v128 + v123);
          uint64_t v132 = (_OWORD *)(a3[6] + 48 * v129);
          long long v133 = *v131;
          long long v134 = v131[2];
          v132[1] = v131[1];
          v132[2] = v134;
          _OWORD *v132 = v133;
          ++v124;
          v123 += 48;
          if (v124 >= *v125) {
            goto LABEL_74;
          }
        }
LABEL_137:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_138:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v129, v130);
        _os_crash();
        __break(1u);
        goto LABEL_139;
      }
LABEL_74:
      uint64_t v135 = v8 + 448 * v6;
      if (*(void *)(v135 + 328))
      {
        uint64_t v136 = 0;
        unint64_t v137 = 0;
        uint64_t v138 = (unint64_t *)(v135 + 328);
        uint64_t v139 = v7 + 432 * v6;
        uint64_t v140 = (unint64_t *)(v139 + 320);
        uint64_t v141 = (void *)(v139 + 328);
        while (*v140 > v137)
        {
          unint64_t v142 = *(void *)(*(void *)(v8 + 448 * v6 + 336) + 8 * v137);
          unint64_t v143 = a3[9];
          if (v143 <= v142) {
            goto LABEL_140;
          }
          v144 = (long long *)(*v141 + v136);
          uint64_t v145 = (_OWORD *)(a3[8] + (v142 << 6));
          long long v146 = *v144;
          long long v147 = v144[1];
          long long v148 = v144[3];
          v145[2] = v144[2];
          v145[3] = v148;
          _OWORD *v145 = v146;
          v145[1] = v147;
          ++v137;
          v136 += 64;
          if (v137 >= *v138) {
            goto LABEL_79;
          }
        }
LABEL_139:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_140:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v142, v143);
        _os_crash();
        __break(1u);
        goto LABEL_141;
      }
LABEL_79:
      uint64_t v149 = v8 + 448 * v6;
      if (*(void *)(v149 + 352))
      {
        uint64_t v150 = 0;
        unint64_t v151 = 0;
        uint64_t v152 = (unint64_t *)(v149 + 352);
        uint64_t v153 = v7 + 432 * v6;
        uint64_t v154 = (unint64_t *)(v153 + 344);
        uint64_t v155 = (void *)(v153 + 352);
        while (*v154 > v151)
        {
          unint64_t v156 = *(void *)(*(void *)(v8 + 448 * v6 + 360) + 8 * v151);
          unint64_t v157 = a3[11];
          if (v157 <= v156) {
            goto LABEL_142;
          }
          *(_OWORD *)(a3[10] + 16 * v156) = *(_OWORD *)(*v155 + v150);
          ++v151;
          v150 += 16;
          if (v151 >= *v152) {
            goto LABEL_84;
          }
        }
LABEL_141:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_142:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v156, v157);
        _os_crash();
        __break(1u);
        goto LABEL_143;
      }
LABEL_84:
      uint64_t v158 = v8 + 448 * v6;
      if (*(void *)(v158 + 376))
      {
        unint64_t v159 = 0;
        uint64_t v160 = (unint64_t *)(v158 + 376);
        uint64_t v161 = v7 + 432 * v6;
        uint64_t v162 = (unint64_t *)(v161 + 368);
        uint64_t v163 = (void *)(v161 + 376);
        while (*v162 > v159)
        {
          unint64_t v164 = *(void *)(*(void *)(v8 + 448 * v6 + 384) + 8 * v159);
          unint64_t v165 = a3[13];
          if (v165 <= v164) {
            goto LABEL_144;
          }
          *(void *)(a3[12] + 8 * v164) = *(void *)(*v163 + 8 * v159++);
          if (v159 >= *v160) {
            goto LABEL_89;
          }
        }
LABEL_143:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_144:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v164, v165);
        _os_crash();
        __break(1u);
        goto LABEL_145;
      }
LABEL_89:
      uint64_t v166 = v8 + 448 * v6;
      if (*(void *)(v166 + 400))
      {
        uint64_t v167 = 0;
        unint64_t v168 = 0;
        uint64_t v169 = (unint64_t *)(v166 + 400);
        uint64_t v170 = v7 + 432 * v6;
        uint64_t v171 = (unint64_t *)(v170 + 392);
        uint64_t v172 = (void *)(v170 + 400);
        while (*v171 > v168)
        {
          unint64_t v173 = *(void *)(*(void *)(v8 + 448 * v6 + 408) + 8 * v168);
          unint64_t v174 = a3[15];
          if (v174 <= v173) {
            goto LABEL_146;
          }
          *(_OWORD *)(a3[14] + 16 * v173) = *(_OWORD *)(*v172 + v167);
          ++v168;
          v167 += 16;
          if (v168 >= *v169) {
            goto LABEL_94;
          }
        }
LABEL_145:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_146:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v173, v174);
        _os_crash();
        __break(1u);
LABEL_147:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_148:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v184, v185);
        _os_crash();
        __break(1u);
LABEL_149:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_150:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_151:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v186, v187);
        _os_crash();
        __break(1u);
LABEL_152:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_153:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_154:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v188, v189);
        _os_crash();
        __break(1u);
      }
LABEL_94:
      uint64_t v175 = v8 + 448 * v6;
      if (*(void *)(v175 + 424))
      {
        uint64_t v176 = 0;
        uint64_t v177 = 0;
        unint64_t v178 = 0;
        uint64_t v179 = (unint64_t *)(v175 + 424);
        uint64_t v180 = (void *)(v8 + 448 * v6 + 432);
        uint64_t v181 = v7 + 432 * v6;
        uint64_t v182 = (unint64_t *)(v181 + 416);
        uint64_t v183 = (void *)(v181 + 424);
        while (*v182 > v178)
        {
          unint64_t v184 = *(void *)(*v180 + v176);
          unint64_t v185 = a3[15];
          if (v185 <= v184) {
            goto LABEL_148;
          }
          *(_OWORD *)(a3[14] + 16 * v184) = *(_OWORD *)(*v183 + v177);
          if (*v179 <= v178) {
            goto LABEL_149;
          }
          if (*v182 <= v178) {
            goto LABEL_150;
          }
          unint64_t v186 = *(void *)(*v180 + v176 + 8);
          unint64_t v187 = a3[11];
          if (v187 <= v186) {
            goto LABEL_151;
          }
          *(_OWORD *)(a3[10] + 16 * v186) = *(_OWORD *)(*v183 + v177 + 16);
          if (*v179 <= v178) {
            goto LABEL_152;
          }
          if (*v182 <= v178) {
            goto LABEL_153;
          }
          unint64_t v188 = *(void *)(*v180 + v176 + 16);
          unint64_t v189 = a3[15];
          if (v189 <= v188) {
            goto LABEL_154;
          }
          *(_OWORD *)(a3[14] + 16 * v188) = *(_OWORD *)(*v183 + v177 + 32);
          ++v178;
          v177 += 48;
          v176 += 24;
          if (v178 >= *v179) {
            goto LABEL_105;
          }
        }
        goto LABEL_147;
      }
LABEL_105:
      if (++v5 == a2) {
        return result;
      }
    }
    uint64_t v12 = 0;
    uint64_t v13 = *(void *)(v8 + 448 * v6 + 24);
    uint64_t v15 = *a3;
    unint64_t v14 = a3[1];
    uint64_t v17 = v10[1];
    uint64_t v16 = v10[2];
    while (1)
    {
      unint64_t v18 = *(void *)(v13 + 8 * v12);
      if (v14 <= v18) {
        break;
      }
      if (v17 == v12) {
        goto LABEL_108;
      }
      *(_DWORD *)(v16 + 4 * v12++) = *(_DWORD *)(v15 + 4 * v18);
      if (v11 == v12) {
        goto LABEL_8;
      }
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, *(void *)(v13 + 8 * v12), v14);
    _os_crash();
    __break(1u);
LABEL_108:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_109;
  }
  return result;
}

void re::anonymous namespace'::$_77::__invoke(_anonymous_namespace_ *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v162 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v5 = a2;
    unint64_t j = (unint64_t)a1;
    uint64_t v7 = 0;
    unint64_t i = 456;
    do
    {
      uint64_t v9 = a3[18];
      uint64_t v10 = *(void *)(j + 8 * v7);
      uint64_t v11 = v9 + 456 * v10;
      uint64_t v12 = *(void *)(v11 + 8);
      if (v12)
      {
        uint64_t v13 = 0;
        unint64_t v14 = 0;
        uint64_t v15 = *(void *)(v11 + 16);
        uint64_t v16 = 184;
        unint64_t v17 = a3[3];
        while (1)
        {
          unint64_t v18 = *(void *)(v15 + 8 * v14);
          if (v18 == -1) {
            break;
          }
          if (v17 <= v18) {
            goto LABEL_93;
          }
          if (*(_DWORD *)(a3[2] + 4 * v18)) {
            break;
          }
          ++v14;
          v13 += 784;
          v16 += 192;
          if (v12 == v14) {
            goto LABEL_9;
          }
        }
        long long v19 = 0uLL;
        memset(v134, 0, sizeof(v134));
        memset(v133, 0, sizeof(v133));
        long long v131 = 0u;
        memset(v132, 0, sizeof(v132));
        long long v129 = 0u;
        long long v130 = 0u;
        long long v127 = 0u;
        long long v128 = 0u;
        long long v125 = 0u;
        long long v126 = 0u;
        long long v123 = 0u;
        long long v124 = 0u;
        long long v121 = 0u;
        long long v122 = 0u;
        long long v119 = 0u;
        long long v120 = 0u;
        long long v117 = 0u;
        long long v118 = 0u;
        long long v115 = 0u;
        long long v116 = 0u;
        uint64_t v20 = v9 + 456 * v10;
        long long v114 = 0u;
        uint64_t v21 = *(uint64_t **)(v20 + 32);
        unint64_t j = v20 + 32;
        unint64_t v3 = v21;
        if ((unint64_t)v21 <= v14) {
          goto LABEL_97;
        }
        uint64_t v111 = v7;
        uint64_t v22 = v9 + 456 * v10;
        uint64_t v23 = *(void *)(v22 + 40) + v16;
        unint64_t v24 = *(void *)(v23 - 176);
        unint64_t v112 = (uint64_t *)(v22 + 40);
        uint64_t v113 = v9;
        unint64_t v25 = *(void *)(v22 + 80);
        if (v24)
        {
          unint64_t v30 = 0;
          unint64_t i = *(void *)(v23 - 176);
          uint64_t v31 = *(void *)(v23 - 168);
          uint64_t v33 = *a3;
          unint64_t v32 = a3[1];
          unint64_t v3 = (uint64_t *)*((void *)&v114 + 1);
          uint64_t v34 = v115;
          while ((uint64_t *)i != v30)
          {
            unint64_t v35 = *(void *)(v31 + 8 * (void)v30);
            if (v32 <= v35) {
              goto LABEL_73;
            }
            if (v3 == v30) {
              goto LABEL_74;
            }
            *(_DWORD *)(v34 + 4 * (void)v30) = *(_DWORD *)(v33 + 4 * v35);
            unint64_t v30 = (uint64_t *)((char *)v30 + 1);
            if ((uint64_t *)v24 == v30) {
              goto LABEL_17;
            }
          }
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 476;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = i;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_73:
          re::internal::assertLog((re::internal *)6, v29, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v35, v32);
          _os_crash();
          __break(1u);
LABEL_74:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = (unint64_t)v3;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_75:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 476;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = i;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_76:
          re::internal::assertLog((re::internal *)6, v41, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v47, v44);
          _os_crash();
          __break(1u);
LABEL_77:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = (unint64_t)v3;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_78:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 476;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = i;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_79:
          re::internal::assertLog((re::internal *)6, v53, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v59, v56);
          _os_crash();
          __break(1u);
LABEL_80:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = (unint64_t)v3;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_81:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 476;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_82:
          re::internal::assertLog((re::internal *)6, v64, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v66, v67);
          _os_crash();
          __break(1u);
LABEL_83:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_84:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 476;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_85:
          re::internal::assertLog((re::internal *)6, v76, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v78, v79);
          _os_crash();
          __break(1u);
LABEL_86:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_87:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 476;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_88:
          re::internal::assertLog((re::internal *)6, v89, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v91, v92);
          _os_crash();
          __break(1u);
LABEL_89:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_90:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 476;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_91:
          re::internal::assertLog((re::internal *)6, v97, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v98, v99);
          _os_crash();
          __break(1u);
LABEL_92:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = i;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_93:
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v18, v17);
          _os_crash();
          __break(1u);
LABEL_94:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 476;
          __int16 v140 = 2048;
          unint64_t v141 = j;
          __int16 v142 = 2048;
          unint64_t v143 = i;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_95:
          re::internal::assertLog((re::internal *)6, v104, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v106, v107);
          _os_crash();
          __break(1u);
LABEL_96:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = j;
          __int16 v142 = 2048;
          unint64_t v143 = i;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_97:
          uint64_t v135 = 0;
          long long v147 = v19;
          long long v148 = v19;
          long long v145 = v19;
          long long v146 = v19;
          long long v144 = v19;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = v14;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_98:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = v14;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_99:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = v14;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_100:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = v14;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_101:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = v14;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_102:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = v14;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_103:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = v14;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_104:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = v14;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_105:
          uint64_t v135 = 0;
          long long v147 = 0u;
          long long v148 = 0u;
          long long v145 = 0u;
          long long v146 = 0u;
          long long v144 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v136 = 136315906;
          unint64_t v137 = "operator[]";
          __int16 v138 = 1024;
          int v139 = 468;
          __int16 v140 = 2048;
          unint64_t v141 = v14;
          __int16 v142 = 2048;
          unint64_t v143 = (unint64_t)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_17:
        unint64_t v3 = *(uint64_t **)j;
        if (*(void *)j <= v14) {
          goto LABEL_98;
        }
        uint64_t v36 = *v112 + v16;
        unint64_t v37 = *(void *)(v36 - 152);
        unint64_t v38 = *(void *)(v113 + 456 * v10 + 104);
        if (v37)
        {
          double v42 = 0;
          unint64_t i = *(void *)(v36 - 152);
          uint64_t v43 = *(void *)(v36 - 144);
          uint64_t v45 = a3[2];
          unint64_t v44 = a3[3];
          uint64_t v46 = *((void *)&v116 + 1);
          unint64_t v3 = (uint64_t *)v116;
          while ((uint64_t *)i != v42)
          {
            unint64_t v47 = *(void *)(v43 + 8 * (void)v42);
            if (v44 <= v47) {
              goto LABEL_76;
            }
            if (v3 == v42) {
              goto LABEL_77;
            }
            *(_DWORD *)(v46 + 4 * (void)v42) = *(_DWORD *)(v45 + 4 * v47);
            double v42 = (uint64_t *)((char *)v42 + 1);
            if ((uint64_t *)v37 == v42) {
              goto LABEL_24;
            }
          }
          goto LABEL_75;
        }
LABEL_24:
        unint64_t v3 = *(uint64_t **)j;
        if (*(void *)j <= v14) {
          goto LABEL_99;
        }
        uint64_t v48 = *v112 + v16;
        unint64_t v49 = *(void *)(v48 - 128);
        unint64_t v50 = *(void *)(v113 + 456 * v10 + 128);
        if (v49)
        {
          float32x2_t v54 = 0;
          unint64_t i = *(void *)(v48 - 128);
          uint64_t v55 = *(void *)(v48 - 120);
          uint64_t v57 = a3[4];
          unint64_t v56 = a3[5];
          unint64_t v3 = (uint64_t *)*((void *)&v117 + 1);
          uint64_t v58 = v118;
          while ((uint64_t *)i != v54)
          {
            unint64_t v59 = *(void *)(v55 + 8 * (void)v54);
            if (v56 <= v59) {
              goto LABEL_79;
            }
            if (v3 == v54) {
              goto LABEL_80;
            }
            *(_DWORD *)(v58 + 4 * (void)v54) = *(_DWORD *)(v57 + 4 * v59);
            float32x2_t v54 = (uint64_t *)((char *)v54 + 1);
            if ((uint64_t *)v49 == v54) {
              goto LABEL_31;
            }
          }
          goto LABEL_78;
        }
LABEL_31:
        unint64_t v3 = *(uint64_t **)j;
        if (*(void *)j <= v14) {
          goto LABEL_100;
        }
        unint64_t v26 = (uint64_t *)(*v112 + v16);
        unint64_t v60 = *(v26 - 13);
        unint64_t v61 = *(void *)(v113 + 456 * v10 + 152);
        if (v60)
        {
          uint64_t v65 = 0;
          for (unint64_t i = 0; i != v60; ++i)
          {
            unint64_t v3 = (uint64_t *)*(v26 - 13);
            if ((unint64_t)v3 <= i) {
              goto LABEL_81;
            }
            unint64_t v66 = *(void *)(*(v26 - 12) + 8 * i);
            unint64_t v67 = a3[7];
            if (v67 <= v66) {
              goto LABEL_82;
            }
            unint64_t v3 = (uint64_t *)v119;
            if ((unint64_t)v119 <= i) {
              goto LABEL_83;
            }
            unint64_t v68 = (long long *)(a3[6] + 48 * v66);
            unint64_t v69 = (_OWORD *)(*((void *)&v119 + 1) + v65);
            long long v70 = *v68;
            long long v71 = v68[2];
            v69[1] = v68[1];
            v69[2] = v71;
            _OWORD *v69 = v70;
            v65 += 48;
          }
        }
        unint64_t v3 = *(uint64_t **)j;
        if (*(void *)j <= v14) {
          goto LABEL_101;
        }
        unint64_t v26 = (uint64_t *)(*v112 + v16);
        unint64_t v72 = *(v26 - 10);
        unint64_t v73 = *(void *)(v113 + 456 * v10 + 176);
        if (v72)
        {
          uint64_t v77 = 0;
          for (unint64_t i = 0; i != v72; ++i)
          {
            unint64_t v3 = (uint64_t *)*(v26 - 10);
            if ((unint64_t)v3 <= i) {
              goto LABEL_84;
            }
            unint64_t v78 = *(void *)(*(v26 - 9) + 8 * i);
            unint64_t v79 = a3[9];
            if (v79 <= v78) {
              goto LABEL_85;
            }
            unint64_t v3 = (uint64_t *)*((void *)&v120 + 1);
            if (*((void *)&v120 + 1) <= i) {
              goto LABEL_86;
            }
            uint64_t v80 = (long long *)(a3[8] + (v78 << 6));
            uint64_t v81 = (_OWORD *)(v121 + v77);
            long long v82 = *v80;
            long long v83 = v80[1];
            long long v84 = v80[3];
            v81[2] = v80[2];
            v81[3] = v84;
            _OWORD *v81 = v82;
            v81[1] = v83;
            v77 += 64;
          }
        }
        unint64_t v3 = *(uint64_t **)j;
        if (*(void *)j <= v14) {
          goto LABEL_102;
        }
        unint64_t v3 = (uint64_t *)(*v112 + v16);
        unint64_t v85 = *(v3 - 7);
        unint64_t v86 = *(void *)(v113 + 456 * v10 + 200);
        if (v85)
        {
          uint64_t v90 = 0;
          for (unint64_t i = 0; i != v85; ++i)
          {
            unint64_t v26 = (uint64_t *)*(v3 - 7);
            if ((unint64_t)v26 <= i) {
              goto LABEL_87;
            }
            unint64_t v91 = *(void *)(*(v3 - 6) + 8 * i);
            unint64_t v92 = a3[11];
            if (v92 <= v91) {
              goto LABEL_88;
            }
            unint64_t v26 = (uint64_t *)v122;
            if ((unint64_t)v122 <= i) {
              goto LABEL_89;
            }
            *(_OWORD *)(*((void *)&v122 + 1) + v90) = *(_OWORD *)(a3[10] + 16 * v91);
            v90 += 16;
          }
        }
        unint64_t v3 = *(uint64_t **)j;
        if (*(void *)j <= v14) {
          goto LABEL_103;
        }
        unint64_t v3 = (uint64_t *)(*v112 + v16);
        unint64_t v93 = *(v3 - 4);
        unint64_t v94 = *(void *)(v113 + 456 * v10 + 224);
        if (v93)
        {
          for (unint64_t i = 0; i != v93; *(void *)(v124 + 8 * i++) = *(void *)(a3[12] + 8 * v98))
          {
            unint64_t v26 = (uint64_t *)*(v3 - 4);
            if ((unint64_t)v26 <= i) {
              goto LABEL_90;
            }
            unint64_t v98 = *(void *)(*(v3 - 3) + 8 * i);
            unint64_t v99 = a3[13];
            if (v99 <= v98) {
              goto LABEL_91;
            }
            unint64_t v26 = (uint64_t *)*((void *)&v123 + 1);
            if (*((void *)&v123 + 1) <= i) {
              goto LABEL_92;
            }
          }
        }
        unint64_t v3 = *(uint64_t **)j;
        if (*(void *)j <= v14) {
          goto LABEL_104;
        }
        uint64_t v100 = *v112;
        unint64_t v3 = (uint64_t *)(*v112 + v16);
        unint64_t v101 = *(v3 - 1);
        unint64_t v102 = *(void *)(v113 + 456 * v10 + 248);
        if (v101)
        {
          uint64_t v105 = 0;
          for (unint64_t j = 0; j != v101; ++j)
          {
            unint64_t i = *(v3 - 1);
            if (i <= j) {
              goto LABEL_94;
            }
            unint64_t v106 = *(void *)(*(void *)(v100 + v16) + 8 * j);
            unint64_t v107 = a3[15];
            if (v107 <= v106) {
              goto LABEL_95;
            }
            unint64_t i = v125;
            if ((unint64_t)v125 <= j) {
              goto LABEL_96;
            }
            *(_OWORD *)(*((void *)&v125 + 1) + v105) = *(_OWORD *)(a3[14] + 16 * v106);
            v105 += 16;
          }
        }
        unint64_t i = 456;
        unint64_t v3 = *(uint64_t **)(v113 + 456 * v10 + 56);
        if ((unint64_t)v3 <= v14) {
          goto LABEL_105;
        }
        uint64_t v108 = *(void *)(v113 + 456 * v10 + 64) + v13;
        long long v160 = 0u;
        long long v161 = 0u;
        long long v158 = 0u;
        long long v159 = 0u;
        long long v156 = 0u;
        long long v157 = 0u;
        long long v154 = 0u;
        long long v155 = 0u;
        long long v152 = 0u;
        long long v153 = 0u;
        long long v150 = 0u;
        long long v151 = 0u;
        long long v148 = 0u;
        long long v149 = 0u;
        long long v146 = 0u;
        long long v147 = 0u;
        long long v144 = 0u;
        long long v145 = 0u;
        re::EvaluationContextSlices::init((re::EvaluationContextSlices *)&v144, (re::EvaluationContext *)&v114);
        if ((*(unsigned int (**)(uint64_t, long long *))(*(void *)v108 + 16))(v108, &v144))
        {
          unint64_t v3 = (uint64_t *)&v127 + 1;
          unint64_t i = 456;
        }
        re::EvaluationContext::~EvaluationContext((re::EvaluationContext *)&v114);
        unint64_t j = (unint64_t)a1;
        uint64_t v5 = a2;
        uint64_t v7 = v111;
      }
      else
      {
LABEL_9:
        unint64_t v3 = (uint64_t *)(v9 + 456 * v10);
        unint64_t i = 456;
      }
      ++v7;
    }
    while (v7 != v5);
  }
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Vector3<float>,re::Vector3<float>,re::Vector3<float>,void,void>::input1(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 <= 3 * a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3, v3);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v4 = *(void *)(*a1 + 24 * a3);
    unint64_t v5 = *(void *)(a2 + 120);
    if (v5 > v4) {
      return *(void *)(a2 + 112) + 16 * v4;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, v5);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Vector3<float>,re::Vector3<float>,re::Vector3<float>,void,void>::input2<re::Vector3<float>>(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 1;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 1, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 120);
    if (v6 > v5) {
      return *(void *)(a2 + 112) + 16 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Vector3<float>,re::Vector3<float>,re::Vector3<float>,void,void>::output(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 2;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 2, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 120);
    if (v6 > v5) {
      return *(void *)(a2 + 112) + 16 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Vector2<float>,re::Vector2<float>,re::Vector2<float>,void,void>::input1(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 <= 3 * a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3, v3);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v4 = *(void *)(*a1 + 24 * a3);
    unint64_t v5 = *(void *)(a2 + 104);
    if (v5 > v4) {
      return *(void *)(a2 + 96) + 8 * v4;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, v5);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Vector2<float>,re::Vector2<float>,re::Vector2<float>,void,void>::input2<re::Vector2<float>>(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 1;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 1, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 104);
    if (v6 > v5) {
      return *(void *)(a2 + 96) + 8 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Vector2<float>,re::Vector2<float>,re::Vector2<float>,void,void>::output(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 2;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 2, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 104);
    if (v6 > v5) {
      return *(void *)(a2 + 96) + 8 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Quaternion<float>,re::Quaternion<float>,re::Quaternion<float>,void,void>::input1(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 <= 3 * a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3, v3);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v4 = *(void *)(*a1 + 24 * a3);
    unint64_t v5 = *(void *)(a2 + 88);
    if (v5 > v4) {
      return *(void *)(a2 + 80) + 16 * v4;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, v5);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Quaternion<float>,re::Quaternion<float>,re::Quaternion<float>,void,void>::input2<re::Quaternion<float>>(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 1;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 1, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 88);
    if (v6 > v5) {
      return *(void *)(a2 + 80) + 16 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Quaternion<float>,re::Quaternion<float>,re::Quaternion<float>,void,void>::output(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 2;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 2, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 88);
    if (v6 > v5) {
      return *(void *)(a2 + 80) + 16 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Quaternion<float>,re::Quaternion<float>,void,void,void>::input1(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 <= 2 * a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2 * a3, v3);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v4 = *(void *)(*a1 + 16 * a3);
    unint64_t v5 = *(void *)(a2 + 88);
    if (v5 > v4) {
      return *(void *)(a2 + 80) + 16 * v4;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, v5);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Quaternion<float>,re::Quaternion<float>,void,void,void>::output(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = (2 * a3) | 1;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, (2 * a3) | 1, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 88);
    if (v6 > v5) {
      return *(void *)(a2 + 80) + 16 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Matrix3x3<float>,re::Matrix3x3<float>,void,void,void>::input1(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 <= 2 * a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2 * a3, v3);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v4 = *(void *)(*a1 + 16 * a3);
    unint64_t v5 = *(void *)(a2 + 56);
    if (v5 > v4) {
      return *(void *)(a2 + 48) + 48 * v4;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, v5);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Matrix3x3<float>,re::Matrix3x3<float>,void,void,void>::output(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = (2 * a3) | 1;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, (2 * a3) | 1, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 56);
    if (v6 > v5) {
      return *(void *)(a2 + 48) + 48 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Vector3<float>,re::Matrix4x4<float>,re::Vector3<float>,void,void>::input1(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 <= 3 * a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3, v3);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v4 = *(void *)(*a1 + 24 * a3);
    unint64_t v5 = *(void *)(a2 + 72);
    if (v5 > v4) {
      return *(void *)(a2 + 64) + (v4 << 6);
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, v5);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<re::Quaternion<float>,re::Vector3<float>,float,void,void>::input2<float>(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 1;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 1, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 40);
    if (v6 > v5) {
      return *(void *)(a2 + 32) + 4 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<float,float,float,void,void>::input1(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 <= 3 * a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3, v3);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v4 = *(void *)(*a1 + 24 * a3);
    unint64_t v5 = *(void *)(a2 + 40);
    if (v5 > v4) {
      return *(void *)(a2 + 32) + 4 * v4;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, v5);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<float,float,float,void,void>::output(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 2;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 2, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 40);
    if (v6 > v5) {
      return *(void *)(a2 + 32) + 4 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<float,float,void,void,void>::input1(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 <= 2 * a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2 * a3, v3);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v4 = *(void *)(*a1 + 16 * a3);
    unint64_t v5 = *(void *)(a2 + 40);
    if (v5 > v4) {
      return *(void *)(a2 + 32) + 4 * v4;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, v5);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<float,float,void,void,void>::output(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = (2 * a3) | 1;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, (2 * a3) | 1, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 40);
    if (v6 > v5) {
      return *(void *)(a2 + 32) + 4 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<unsigned int,float,float,void,void>::output(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 2;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 2, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 24);
    if (v6 > v5) {
      return *(void *)(a2 + 16) + 4 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<unsigned int,int,int,void,void>::input1(void *a1, void *a2, uint64_t a3)
{
  unint64_t v3 = a1[1];
  if (v3 <= 3 * a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3, v3);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v4 = *(void *)(*a1 + 24 * a3);
    unint64_t v5 = a2[1];
    if (v5 > v4) {
      return *a2 + 4 * v4;
    }
  }
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, v5);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<unsigned int,int,int,void,void>::input2<int>(void *a1, void *a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 1;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 1, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = a2[1];
    if (v6 > v5) {
      return *a2 + 4 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<unsigned int,unsigned int,re::Matrix3x3<float>,void,void>::input2<re::Matrix3x3<float>>(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 1;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 1, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 56);
    if (v6 > v5) {
      return *(void *)(a2 + 48) + 48 * v5;
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::RegisterTableReader<unsigned int,unsigned int,re::Matrix4x4<float>,void,void>::input2<re::Matrix4x4<float>>(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 3 * a3 + 1;
  unint64_t v4 = a1[1];
  if (v4 <= v3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3 * a3 + 1, v4);
    _os_crash();
    __break(1u);
  }
  else
  {
    unint64_t v5 = *(void *)(*a1 + 8 * v3);
    unint64_t v6 = *(void *)(a2 + 72);
    if (v6 > v5) {
      return *(void *)(a2 + 64) + (v5 << 6);
    }
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::mapBranchOutputs<int>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (result == i)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v7, a6);
        _os_crash();
        __break(1u);
      }
      unint64_t v7 = *(void *)(a4 + 8 * i);
      if (v7 >= a6) {
        goto LABEL_8;
      }
      *(_DWORD *)(a5 + 4 * v7) = *(_DWORD *)(a2 + 4 * i);
    }
  }
  return result;
}

float re::anonymous namespace'::mapBranchOutputs<float>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (a1 == i)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v7, a6);
        _os_crash();
        __break(1u);
      }
      unint64_t v7 = *(void *)(a4 + 8 * i);
      if (v7 >= a6) {
        goto LABEL_8;
      }
      float result = *(float *)(a2 + 4 * i);
      *(float *)(a5 + 4 * v7) = result;
    }
  }
  return result;
}

__n128 re::anonymous namespace'::mapBranchOutputs<re::Matrix3x3<float>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 80);
  if (v3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    while (*(void *)(a2 + 80) > v5)
    {
      if (*(void *)(a1 + 80) <= v5) {
        goto LABEL_9;
      }
      unint64_t v6 = *(void *)(*(void *)(a2 + 88) + 8 * v5);
      unint64_t v7 = *(void *)(a3 + 56);
      if (v7 <= v6) {
        goto LABEL_10;
      }
      uint64_t v8 = *(void *)(a1 + 88) + v4;
      uint64_t v9 = *(void *)(a3 + 48) + 48 * v6;
      __n128 result = *(__n128 *)v8;
      long long v11 = *(_OWORD *)(v8 + 32);
      *(_OWORD *)(v9 + 16) = *(_OWORD *)(v8 + 16);
      *(_OWORD *)(v9 + 32) = v11;
      *(__n128 *)uint64_t v9 = result;
      ++v5;
      v4 += 48;
      if (v3 == v5) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_9:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_10:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v6, v7);
    _os_crash();
    __break(1u);
  }
  return result;
}

__n128 re::anonymous namespace'::mapBranchOutputs<re::Matrix4x4<float>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 104);
  if (v3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    while (*(void *)(a2 + 104) > v5)
    {
      if (*(void *)(a1 + 104) <= v5) {
        goto LABEL_9;
      }
      unint64_t v6 = *(void *)(*(void *)(a2 + 112) + 8 * v5);
      unint64_t v7 = *(void *)(a3 + 72);
      if (v7 <= v6) {
        goto LABEL_10;
      }
      uint64_t v8 = *(void *)(a1 + 112) + v4;
      uint64_t v9 = *(void *)(a3 + 64) + (v6 << 6);
      __n128 result = *(__n128 *)v8;
      long long v11 = *(_OWORD *)(v8 + 16);
      long long v12 = *(_OWORD *)(v8 + 48);
      *(_OWORD *)(v9 + 32) = *(_OWORD *)(v8 + 32);
      *(_OWORD *)(v9 + 48) = v12;
      *(__n128 *)uint64_t v9 = result;
      *(_OWORD *)(v9 + 16) = v11;
      ++v5;
      v4 += 64;
      if (v3 == v5) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_9:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_10:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v6, v7);
    _os_crash();
    __break(1u);
  }
  return result;
}

__n128 re::anonymous namespace'::mapBranchOutputs<re::Quaternion<float>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 128);
  if (v3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    while (*(void *)(a2 + 128) > v5)
    {
      if (*(void *)(a1 + 128) <= v5) {
        goto LABEL_9;
      }
      unint64_t v6 = *(void *)(*(void *)(a2 + 136) + 8 * v5);
      unint64_t v7 = *(void *)(a3 + 88);
      if (v7 <= v6) {
        goto LABEL_10;
      }
      __n128 result = *(__n128 *)(*(void *)(a1 + 136) + v4);
      *(__n128 *)(*(void *)(a3 + 80) + 16 * v6) = result;
      ++v5;
      v4 += 16;
      if (v3 == v5) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_9:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_10:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v6, v7);
    _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::anonymous namespace'::mapBranchOutputs<re::Vector2<float>>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 152);
  if (v3)
  {
    unint64_t v4 = 0;
    while (*(void *)(a2 + 152) > v4)
    {
      if (*(void *)(result + 152) <= v4) {
        goto LABEL_9;
      }
      unint64_t v5 = *(void *)(*(void *)(a2 + 160) + 8 * v4);
      unint64_t v6 = *(void *)(a3 + 104);
      if (v6 <= v5) {
        goto LABEL_10;
      }
      *(void *)(*(void *)(a3 + 96) + 8 * v5) = *(void *)(*(void *)(result + 160) + 8 * v4++);
      if (v3 == v4) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_9:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_10:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v5, v6);
    _os_crash();
    __break(1u);
  }
  return result;
}

__n128 re::anonymous namespace'::mapBranchOutputs<re::Vector3<float>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 176);
  if (v3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    while (*(void *)(a2 + 176) > v5)
    {
      if (*(void *)(a1 + 176) <= v5) {
        goto LABEL_9;
      }
      unint64_t v6 = *(void *)(*(void *)(a2 + 184) + 8 * v5);
      unint64_t v7 = *(void *)(a3 + 120);
      if (v7 <= v6) {
        goto LABEL_10;
      }
      __n128 result = *(__n128 *)(*(void *)(a1 + 184) + v4);
      *(__n128 *)(*(void *)(a3 + 112) + 16 * v6) = result;
      ++v5;
      v4 += 16;
      if (v3 == v5) {
        return result;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_9:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_10:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v6, v7);
    _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::animationLogObjects(re *this)
{
  {
    re::animationLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Animation");
  }
  return &re::animationLogObjects(void)::logObjects;
}

uint64_t re::ServiceLocator::serviceOrNull<re::ecs2::ECSService>(uint64_t a1)
{
  {
    re::introspect<re::ecs2::ECSService>(void)::info = re::ecs2::introspect_ECSService(0);
  }
  uint64_t v2 = re::introspect<re::ecs2::ECSService>(void)::info;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

uint64_t re::ServiceLocator::serviceOrNull<re::EventBus>(uint64_t a1)
{
  {
    re::introspect<re::EventBus>(void)::info = re::introspect_EventBus(0);
  }
  uint64_t v2 = re::introspect<re::EventBus>(void)::info;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

uint64_t re::EventBus::subscribe<re::ecs2::Scene,RESceneDidAddEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v14[8] = *MEMORY[0x263EF8340];
  uint64_t Type = re::EventBus::getTypeId<RESceneDidAddEvent>();
  unint64_t EventInfo = re::EventBus::addOrGetEventInfo(a1, Type);
  re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(a3, a5, v14);
  uint64_t v12 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v14, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v14);
  return v12;
}

uint64_t re::EventBus::subscribe<re::ecs2::Scene,RESceneWillRemoveEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v14[8] = *MEMORY[0x263EF8340];
  uint64_t v10 = re::EventBus::getTypeId<RESceneWillRemoveEvent>();
  unint64_t EventInfo = re::EventBus::addOrGetEventInfo(a1, v10);
  re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(a3, a5, v14);
  uint64_t v12 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v14, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v14);
  return v12;
}

uint64_t re::PeerAttributionService::getOrCreateContextForPeerId(re::PeerAttributionService *this, uint64_t a2)
{
  uint64_t v11 = a2;
  uint64_t v3 = (char *)this + 96;
  uint64_t v4 = (void *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 96, &v11);
  if (v4) {
    return *v4;
  }
  unint64_t v5 = re::globalAllocators(0);
  unint64_t v6 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 24, 8);
  v6[1] = 0;
  v6[2] = 0;
  *((_WORD *)v6 + 8) = -1;
  uint64_t v10 = v6;
  *unint64_t v6 = v11;
  v6[1] = *((void *)this + 56);
  unsigned int v7 = re::PeerAttributionService::acquireAttributionIndex(this);
  if (v7 == 0xFFFF)
  {
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)this + 400, &v11);
    LOWORD(v7) = 0;
    goto LABEL_6;
  }
  if (v7 < 0x20)
  {
    *((void *)this + v7 + 18) = v6;
LABEL_6:
    *((_WORD *)v6 + 8) = v7;
    uint64_t v4 = &v10;
    re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::PeerAttributionContext *&>((uint64_t)v3, &v11, &v10);
    return *v4;
  }
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, v7, 32, v10);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(void *)(v6 + 32 * v4 + 16) != v2)
  {
    while (1)
    {
      uint64_t v4 = *(_DWORD *)(v6 + 32 * v4 + 8) & 0x7FFFFFFF;
      if (v4 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v6 + 32 * v4 + 16) == v2) {
        return v6 + 32 * v4 + 24;
      }
    }
    return 0;
  }
  return v6 + 32 * v4 + 24;
}

uint64_t re::PeerAttributionService::acquireAttributionIndex(re::PeerAttributionService *this)
{
  uint64_t v1 = *((void *)this + 9);
  if (v1)
  {
    uint64_t v2 = v1 - 1;
    unsigned __int16 v7 = *(_WORD *)(*((void *)this + 11) + 2 * v2);
    int v3 = v7;
    *((void *)this + 9) = v2;
    ++*((_DWORD *)this + 20);
    uint64_t v4 = 0xFFFFLL;
    if (v3 == 0xFFFF) {
      return v4;
    }
  }
  else
  {
    unsigned int v5 = *(unsigned __int16 *)this;
    if (v5 > 0x1F) {
      return 0xFFFFLL;
    }
    *(_WORD *)this = v5 + 1;
    unsigned __int16 v7 = v5;
  }
  re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addNew((uint64_t)this + 8, &v7);
  return v7;
}

uint64_t re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(void *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::PeerAttributionContext *&>(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<re::PeerAttributionContext *&>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 32 * v10;
  return v12 + 24;
}

re::PeerAttributionService *re::PeerAttributionService::destroyContext(re::PeerAttributionService *this, uint64_t a2)
{
  if (a2)
  {
    int v3 = this;
    uint64_t v4 = *(unsigned __int16 *)(a2 + 16);
    if (v4)
    {
      if (v4 >= 0x20)
      {
        re::internal::assertLog((re::internal *)6, v4, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, v4, 32);
        this = (re::PeerAttributionService *)_os_crash();
        __break(1u);
        return this;
      }
      *((void *)this + v4 + 18) = 0;
      re::PeerAttributionService::releaseAttributionIndex(this, v4);
    }
    else
    {
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this + 400, (uint64_t *)a2);
    }
    unint64_t v5 = (re *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v3 + 96, (uint64_t *)a2);
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)re::globalAllocators(v5)[2] + 40);
    return (re::PeerAttributionService *)v6();
  }
  return this;
}

uint64_t re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31)) % v2;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (*(void *)(v9 + 24 * v7 + 16) != v3)
  {
    while (1)
    {
      unsigned int v10 = v7;
      LODWORD(v7) = *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
      if (v7 == 0x7FFFFFFF) {
        return 0;
      }
      if (*(void *)(v9 + 24 * v7 + 16) == v3)
      {
        *(_DWORD *)(v9 + 24 * v10 + 8) = *(_DWORD *)(v9 + 24 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = v11 + 24 * v7;
  int v15 = *(_DWORD *)(v12 + 8);
  unint64_t v14 = (int *)(v12 + 8);
  int v13 = v15;
  if (v15 < 0)
  {
    *unint64_t v14 = v13 & 0x7FFFFFFF;
    uint64_t v11 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v11 + 24 * v7 + 8);
  }
  int v16 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v11 + 24 * v7 + 8) = *(_DWORD *)(a1 + 36) | v13 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v16 + 1;
  return 1;
}

void *re::PeerAttributionService::releaseAttributionIndex(re::PeerAttributionService *this, unsigned __int16 a2)
{
  unsigned __int16 v4 = a2;
  uint64_t result = (void *)re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::remove((uint64_t)this + 8, &v4);
  if (result) {
    return re::DynamicArray<unsigned short>::add((void *)this + 7, &v4);
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v4 = ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(v5 + 4 * v4);
  if (v6 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = v8 + 32 * v6;
  if (*(void *)(v9 + 16) != v2)
  {
    while (1)
    {
      unsigned int v10 = v6;
      uint64_t v6 = *(_DWORD *)(v8 + 32 * v6 + 8) & 0x7FFFFFFF;
      if (v6 == 0x7FFFFFFF) {
        return 0;
      }
      uint64_t v11 = v8 + 32 * v6;
      if (*(void *)(v11 + 16) == v2)
      {
        *(_DWORD *)(v8 + 32 * v10 + 8) = *(_DWORD *)(v8 + 32 * v10 + 8) & 0x80000000 | *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v13 = v12 + 32 * v6;
  int v16 = *(_DWORD *)(v13 + 8);
  int v15 = (int *)(v13 + 8);
  int v14 = v16;
  if (v16 < 0)
  {
    *int v15 = v14 & 0x7FFFFFFF;
    uint64_t v12 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v12 + 32 * v6 + 8);
  }
  int v17 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v12 + 32 * v6 + 8) = *(_DWORD *)(a1 + 36) | v14 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v6;
  *(_DWORD *)(a1 + 40) = v17 + 1;
  return 1;
}

uint64_t re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addNew(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = (unsigned __int16)*a2;
  unint64_t v5 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v4) ^ ((0xBF58476D1CE4E5B9 * v4) >> 27));
  unint64_t v6 = v5 ^ (v5 >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 16 * v12;
    return v11 + 12;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(unsigned __int16 *)(v10 + 16 * v9 + 12) != v4)
  {
    uint64_t v9 = *(_DWORD *)(v10 + 16 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 16 * v9;
  return v11 + 12;
}

uint64_t re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::remove(uint64_t a1, unsigned __int16 *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v3) ^ ((0xBF58476D1CE4E5B9 * v3) >> 27));
  unint64_t v5 = (v4 ^ (v4 >> 31)) % v2;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = v9 + 16 * v7;
  if (*(unsigned __int16 *)(v10 + 12) != v3)
  {
    while (1)
    {
      unsigned int v11 = v7;
      uint64_t v7 = *(_DWORD *)(v9 + 16 * v7 + 8) & 0x7FFFFFFF;
      if (v7 == 0x7FFFFFFF) {
        return 0;
      }
      uint64_t v12 = v9 + 16 * v7;
      if (*(unsigned __int16 *)(v12 + 12) == v3)
      {
        *(_DWORD *)(v9 + 16 * v11 + 8) = *(_DWORD *)(v9 + 16 * v11 + 8) & 0x80000000 | *(_DWORD *)(v12 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v10 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v13 = *(void *)(a1 + 16);
  uint64_t v14 = v13 + 16 * v7;
  int v17 = *(_DWORD *)(v14 + 8);
  int v16 = (int *)(v14 + 8);
  int v15 = v17;
  if (v17 < 0)
  {
    *int v16 = v15 & 0x7FFFFFFF;
    uint64_t v13 = *(void *)(a1 + 16);
    int v15 = *(_DWORD *)(v13 + 16 * v7 + 8);
  }
  int v18 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v13 + 16 * v7 + 8) = *(_DWORD *)(a1 + 36) | v15 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v18 + 1;
  return 1;
}

void *re::DynamicArray<unsigned short>::add(void *this, _WORD *a2)
{
  uint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<unsigned short>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  *(_WORD *)(v3[4] + 2 * v4) = *a2;
  uint64_t v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v14[8] = *MEMORY[0x263EF8340];
  uint64_t Type = re::EventBus::getTypeId<RESceneEntityDidActivateEvent>();
  unint64_t EventInfo = re::EventBus::addOrGetEventInfo(a1, Type);
  re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(a3, a5, v14);
  uint64_t v12 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v14, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v14);
  return v12;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,REComponentDidActivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v14[8] = *MEMORY[0x263EF8340];
  uint64_t Type = re::EventBus::getTypeId<REComponentDidActivateEvent>();
  unint64_t EventInfo = re::EventBus::addOrGetEventInfo(a1, Type);
  re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(a3, a5, v14);
  uint64_t v12 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v14, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v14);
  return v12;
}

void *re::allocInfo_PeerAttributionService(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_27, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_27))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF74930, "PeerAttributionService");
    __cxa_guard_release(&_MergedGlobals_27);
  }
  return &unk_26AF74930;
}

void re::initInfo_PeerAttributionService(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0xA3B5877921502CB0;
  v5[1] = "PeerAttributionService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x21800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 8) = &re::initInfo_PeerAttributionService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_PeerAttributionService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"PeerAttributionService", (uint64_t (*)(re::internal *))re::allocInfo_PeerAttributionService, (re::IntrospectionBase *(*)(void))re::initInfo_PeerAttributionService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::PeerAttributionService>, this);
}

double re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 16 * v3;
      do
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 16;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t (***re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(uint64_t a1))(void)
{
  double result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    double result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      double result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t (***re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::destroyCallable(uint64_t a1))(void)
{
  double result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    double result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      double result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t (***re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::destroyCallable(uint64_t a1))(void)
{
  double result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    double result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      double result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t (***re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable(uint64_t a1))(void)
{
  double result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    double result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      double result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t re::EventBus::EventInfo::addSubscription(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)(a1 + 8) + 1;
  *(void *)(a1 + 8) = v7;
  *(void *)&long long v14 = a3;
  *((void *)&v14 + 1) = a4;
  uint64_t v8 = *(void *)(a2 + 48);
  v21.n128_u64[0] = a1;
  uint64_t v22 = v8;
  uint64_t v23 = 0;
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<48ul>((uint64_t)&v21.n128_i64[1], a2);
  *(void *)unint64_t v24 = v7;
  *(_OWORD *)&v24[8] = v14;
  v15[0] = *(void *)a1;
  v15[1] = v7;
  if (!(a3 | a4))
  {
    uint64_t v10 = a1 + 88;
    goto LABEL_5;
  }
  uint64_t v9 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)(a1 + 216), &v14);
  if (v9 != -1)
  {
    uint64_t v10 = *(void *)(a1 + 224) + 144 * v9 + 16;
LABEL_5:
    if (!*(_DWORD *)(a1 + 16) || *(void *)(v10 + 96)) {
      goto LABEL_7;
    }
LABEL_9:
    unint64_t v16 = v21.n128_u64[0];
    v17[6] = v22;
    v17[7] = 0;
    unsigned int v11 = (re *)re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<48ul>((uint64_t)v17, (uint64_t)&v21.n128_i64[1]);
    long long v18 = *(_OWORD *)v24;
    uint64_t v19 = *(void *)&v24[16];
    uint64_t v12 = re::globalAllocators(v11);
    re::FunctionBase<24ul,void ()(void)>::FunctionBase<re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(void)#1},void,void>((uint64_t)v20, (uint64_t *)&v16, v12[2]);
    re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::addNew((uint64_t *)(a1 + 280), v15, (uint64_t)v20);
    re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v20);
    re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v17);
    goto LABEL_10;
  }
  if (*(_DWORD *)(a1 + 16)) {
    goto LABEL_9;
  }
  uint64_t v10 = 0;
LABEL_7:
  re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(re::EventBus::Subscriptions *)#1}::operator()(&v21, v10);
LABEL_10:
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)&v21.n128_i64[1]);
  return v15[0];
}

uint64_t (***re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>@<X0>(uint64_t a1@<X2>, char a2@<W4>, void *a3@<X8>))(void)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v6 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v6)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C4C10;
  }
  else
  {
    uint64_t v4 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v4)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C4C78;
  }
  *a3 = v5;
  a3[4] = v9;
  a3[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v8);
  a3[7] = a3;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)v8);
}

uint64_t re::EventBus::getTypeId<RESceneDidAddEvent>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::EventBus::getTypeId<RESceneDidAddEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"18RESceneDidAddEvent" & 0x7FFFFFFFFFFFFFFFLL), v3);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[212];
}

uint64_t re::EventBus::addOrGetEventInfo(re::EventBus *this, uint64_t a2)
{
  v13[4] = *MEMORY[0x263EF8340];
  uint64_t v10 = a2;
  uint64_t v11 = a2;
  uint64_t v4 = (re::EventBus *)((char *)this + 24);
  uint64_t v5 = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find((void *)this + 3, &v11);
  if (v5 == -1 || (uint64_t v6 = *(void *)(*((void *)this + 4) + 48 * v5 + 8)) == 0)
  {
    uint64_t v7 = re::globalAllocators((re *)v5);
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7[2] + 32))(v7[2], 344, 8);
    *(void *)uint64_t v8 = a2;
    *(_OWORD *)(v8 + 120) = 0u;
    *(_OWORD *)(v8 + 136) = 0u;
    *(_DWORD *)(v8 + 152) = 0;
    *(_OWORD *)(v8 + 160) = 0u;
    *(_OWORD *)(v8 + 176) = 0u;
    *(_DWORD *)(v8 + 192) = 0;
    *(_OWORD *)(v8 + 8) = 0u;
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 40) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    *(_OWORD *)(v8 + 100) = 0u;
    *(_OWORD *)(v8 + 88) = 0u;
    *(_OWORD *)(v8 + 72) = 0u;
    *(_OWORD *)(v8 + 200) = 0u;
    *(_OWORD *)(v8 + 232) = 0u;
    *(_OWORD *)(v8 + 248) = 0u;
    *(_OWORD *)(v8 + 264) = 0u;
    *(_OWORD *)(v8 + 280) = 0u;
    *(_OWORD *)(v8 + 296) = 0u;
    *(_OWORD *)(v8 + 312) = 0u;
    *(_OWORD *)(v8 + 328) = 0u;
    *(_OWORD *)(v8 + 216) = 0u;
    v13[3] = v13;
    v12[3] = v12;
    v13[0] = &unk_26E6C4B18;
    uint64_t v11 = v8;
    v12[0] = &unk_26E6C4B18;
    std::__function::__value_func<void ()(re::EventBus::EventInfo *)>::~__value_func[abi:nn180100](v13);
    uint64_t v6 = *re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::addNew(v4, &v10, &v11);
    std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>::~unique_ptr[abi:nn180100](&v11);
  }
  return v6;
}

unint64_t re::EventBus::typeStringToId(re::EventBus *this, const char *a2)
{
  std::string::basic_string[abi:nn180100]<0>(__p, (char *)this);
  if ((v7 & 0x80u) == 0) {
    int v2 = (uint64_t *)__p;
  }
  else {
    int v2 = (uint64_t *)__p[0];
  }
  if ((v7 & 0x80u) == 0) {
    unint64_t v3 = v7;
  }
  else {
    unint64_t v3 = (unint64_t)__p[1];
  }
  unint64_t v4 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v8, v2, v3);
  if ((char)v7 < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      uint64_t v4 = *(uint64_t *)((char *)a2 + a3 - 48);
      uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 40);
      uint64_t v6 = *(uint64_t *)((char *)a2 + a3 - 24);
      uint64_t v8 = *(uint64_t *)((char *)a2 + a3 - 64);
      uint64_t v7 = *(uint64_t *)((char *)a2 + a3 - 56);
      uint64_t v9 = *(uint64_t *)((char *)a2 + a3 - 16);
      uint64_t v10 = *(uint64_t *)((char *)a2 + a3 - 8);
      unint64_t v11 = v7 + v9;
      unint64_t v12 = 0x9DDFEA08EB382D69
          * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))));
      unint64_t v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      unint64_t v14 = v4 + v7 + v8 + a3;
      uint64_t v15 = v14 + v5;
      unint64_t v16 = __ROR8__(v14, 44) + v8 + a3 + __ROR8__(v8 + a3 + v5 - 0x622015F714C7D297 * (v12 ^ (v12 >> 47)), 21);
      uint64_t v17 = v7 + v9 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      uint64_t v18 = v6 + v9 + v17;
      uint64_t v19 = __ROR8__(v18, 44);
      uint64_t v20 = v18 + v10;
      uint64_t v21 = v19 + v17 + __ROR8__(v17 + v5 + v10, 21);
      uint64_t v23 = *a2;
      uint64_t v22 = a2 + 4;
      unint64_t v24 = v23 - 0x4B6D499041670D8DLL * v5;
      uint64_t v25 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        uint64_t v26 = *(v22 - 3);
        uint64_t v27 = v24 + v15 + v11 + v26;
        uint64_t v28 = v22[2];
        uint64_t v29 = v22[3];
        uint64_t v30 = v22[1];
        unint64_t v11 = v30 + v15 - 0x4B6D499041670D8DLL * __ROR8__(v11 + v16 + v28, 42);
        uint64_t v31 = v13 + v20;
        uint64_t v32 = *(v22 - 2);
        uint64_t v33 = *(v22 - 1);
        uint64_t v34 = *(v22 - 4) - 0x4B6D499041670D8DLL * v16;
        uint64_t v35 = v34 + v20 + v33;
        uint64_t v36 = v34 + v26 + v32;
        uint64_t v15 = v36 + v33;
        uint64_t v37 = __ROR8__(v36, 44) + v34;
        unint64_t v38 = (0xB492B66FBE98F273 * __ROR8__(v27, 37)) ^ v21;
        unint64_t v24 = 0xB492B66FBE98F273 * __ROR8__(v31, 33);
        unint64_t v16 = v37 + __ROR8__(v35 + v38, 21);
        unint64_t v39 = v24 + v21 + *v22;
        uint64_t v20 = v30 + v28 + v39 + v29;
        uint64_t v21 = __ROR8__(v30 + v28 + v39, 44) + v39 + __ROR8__(v11 + v32 + v39 + v29, 21);
        v22 += 8;
        unint64_t v13 = v38;
        v25 += 64;
      }
      while (v25);
      unint64_t v40 = v24
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) >> 47));
      unint64_t v41 = 0x9DDFEA08EB382D69
          * (v40 ^ (v38
                  - 0x4B6D499041670D8DLL * (v11 ^ (v11 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) ^ ((0x9DDFEA08EB382D69 * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
    }
    else
    {
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:nn180100](a2, a3);
    }
  }
  else if (a3 > 0x10)
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100](a2, a3);
  }
  else
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:nn180100](a2, a3);
  }
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:nn180100](_DWORD *a1, unint64_t a2)
{
  if (a2 < 9)
  {
    if (a2 < 4)
    {
      unint64_t result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        unint64_t v8 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      uint64_t v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v7 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }
  else
  {
    uint64_t v3 = *(void *)((char *)a1 + a2 - 8);
    uint64_t v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)))) >> 47))) ^ v3;
  }
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100](void *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  unint64_t v3 = 0xB492B66FBE98F273 * *a1;
  uint64_t v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  unint64_t v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8);
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((v4 - 0x3C5A37A36834CED9 * *(void *)((char *)a1 + a2 - 16)) ^ v5);
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:nn180100](void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)((char *)a1 + a2 - 16);
  uint64_t v3 = *a1 - 0x3C5A37A36834CED9 * (v2 + a2);
  uint64_t v5 = a1[2];
  uint64_t v4 = a1[3];
  uint64_t v6 = __ROR8__(v3 + v4, 52);
  uint64_t v7 = v3 + a1[1];
  uint64_t v8 = __ROR8__(v7, 7);
  uint64_t v9 = v7 + v5;
  uint64_t v10 = *(void *)((char *)a1 + a2 - 32) + v5;
  uint64_t v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  uint64_t v12 = *(void *)((char *)a1 + a2 - 24) + v10 + v2;
  unint64_t v13 = 0xC3A5C85C97CB3127 * (v12 + *(void *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(void *)((char *)a1 + a2 - 24) + v10, 7)
       + __ROR8__(*(void *)((char *)a1 + a2 - 8) + v4 + v10, 52)
       + __ROR8__(v12, 31));
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) >> 47));
}

void *re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::addNew(_anonymous_namespace_ *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find(a1, a2);
  if (v6 != -1) {
    return (void *)(*((void *)a1 + 1) + 48 * v6 + 8);
  }
  return re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::internalAdd(a1, a2, a3);
}

uint64_t re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find(void *a1, uint64_t *a2)
{
  if (!a1[7]) {
    return -1;
  }
  unint64_t v2 = a1[2];
  if (v2 < 0x10 || !a1[3]) {
    return -1;
  }
  unint64_t v3 = v2 >> 4;
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = v6 % v3;
  int8x16_t v8 = vdupq_n_s8(v6 & 0x7F);
  v9.i64[0] = -1;
  v9.i64[1] = -1;
  unint64_t v10 = v6 % v3;
  while (1)
  {
    int8x16_t v11 = *(int8x16_t *)(*a1 + 16 * v10);
    unint64_t v12 = (unint64_t)vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v8, v11), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    unint64_t v13 = __clz(__rbit64(v12));
    if (v13 <= 0x3F) {
      break;
    }
LABEL_10:
    if (vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v11, v9), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800))
    {
      return -1;
    }
    if (v10 + 1 == v3) {
      unint64_t v10 = 0;
    }
    else {
      ++v10;
    }
    uint64_t v15 = -1;
    if (v10 == v7) {
      return v15;
    }
  }
  uint64_t v14 = 16 * v10;
  while (1)
  {
    uint64_t v15 = v13 + v14;
    if (v4 == *(void *)(a1[1] + 48 * (v13 + v14))) {
      return v15;
    }
    if (v13 <= 0x3E)
    {
      unint64_t v13 = __clz(__rbit64((-2 << v13) & v12));
      if (v13 < 0x40) {
        continue;
      }
    }
    goto LABEL_10;
  }
}

void *re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::internalAdd(_anonymous_namespace_ *a1, uint64_t *a2, uint64_t *a3)
{
  v27[4] = *MEMORY[0x263EF8340];
  if (!*((void *)a1 + 7))
  {
  }
  uint64_t v6 = *((void *)a1 + 4);
  if (!v6 || (unint64_t v7 = *((void *)a1 + 2), v7 > 8 * v6))
  {
    re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::resize((uint64_t *)a1, 1);
    unint64_t v7 = *((void *)a1 + 2);
  }
  unint64_t v8 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v9 = (0x94D049BB133111EBLL * (v8 ^ (v8 >> 27))) ^ ((0x94D049BB133111EBLL * (v8 ^ (v8 >> 27))) >> 31);
  unint64_t v10 = v7 >> 4;
  unint64_t v11 = v9 % (v7 >> 4);
  uint64_t v12 = *(void *)a1;
  unint64_t v13 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(*(void *)a1 + 16 * v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
  if (v13 >= 0x40)
  {
    do
    {
      if (v11 + 1 == v10) {
        unint64_t v11 = 0;
      }
      else {
        ++v11;
      }
      unint64_t v13 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v12 + 16 * v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
    }
    while (v13 > 0x3F);
  }
  uint64_t v14 = v12 + 16 * v11;
  BOOL v15 = *(unsigned __int8 *)(v14 + v13) == 255;
  *(unsigned char *)(v14 + v13) = v9 & 0x7F;
  uint64_t v16 = *a2;
  uint64_t v17 = *a3;
  *a3 = 0;
  unint64_t v18 = v13 + 16 * v11;
  uint64_t v25 = v16;
  uint64_t v26 = v17;
  std::__function::__value_func<void ()(re::EventBus::EventInfo *)>::__value_func[abi:nn180100]((uint64_t)v27, (uint64_t)(a3 + 1));
  uint64_t v19 = (void *)(*((void *)a1 + 1) + 48 * v18);
  void *v19 = v25;
  std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>::operator=[abi:nn180100](v19 + 1, &v26);
  std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>::~unique_ptr[abi:nn180100](&v26);
  uint64_t v20 = *((void *)a1 + 4) - v15;
  ++*((void *)a1 + 3);
  *((void *)a1 + 4) = v20;
  uint64_t v21 = (unint64_t *)(*((void *)a1 + 1) + 48 * v18);
  unint64_t v23 = *v21;
  unint64_t result = v21 + 1;
  unint64_t v24 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v23 ^ (v23 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v23 ^ (v23 >> 30))) >> 27));
  *((void *)a1 + 5) ^= (v24 >> 31) ^ v24;
  return result;
}

double re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::resize(uint64_t *a1, int a2)
{
  unint64_t v2 = a1[2];
  unint64_t v3 = a1[3] + a2;
  unint64_t v4 = (((151 * v3) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  if (v4 > v2)
  {
    unint64_t v5 = 3 * v2;
    unint64_t v6 = v5 << 6;
    uint64_t v7 = (v5 >> 1) & 0x1FFFFFFFFFFFFFFLL;
    if (v4 <= v6 >> 7) {
      unint64_t v4 = v7;
    }
    unint64_t v3 = (v4 << 7) / 0x97;
  }
  return re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::doResize(a1, v3);
}

void *re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::init(void *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = result;
  result[7] = a2;
  unint64_t v4 = 151 * a3;
  unint64_t v5 = ((unint64_t)(151 * a3) >> 7) + 15;
  unint64_t v6 = v5 & 0x3FFFFFFFFFFFFF0;
  result[2] = v5 & 0x3FFFFFFFFFFFFF0;
  if ((v5 & 0x3FFFFFFFFFFFFF0) != 0)
  {
    unint64_t v7 = v5 >> 4;
    unint64_t result = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 49 * v6, 16);
    *unint64_t v3 = result;
    if (v4 >= 0x80)
    {
      uint64_t v8 = 0;
      *(void *)&long long v9 = -1;
      *((void *)&v9 + 1) = -1;
      do
        *(_OWORD *)(*v3 + 16 * v8++) = v9;
      while (v7 != v8);
      unint64_t result = (void *)*v3;
    }
    v3[1] = &result[2 * v7];
    unint64_t v6 = v3[2];
    if (v6)
    {
      uint64_t v10 = 0;
      for (unint64_t i = 0; i < v6; ++i)
      {
        uint64_t v12 = (void *)(v3[1] + v10);
        v12[5] = 0;
        *uint64_t v12 = 0;
        v12[1] = 0;
        unint64_t v6 = v3[2];
        v10 += 48;
      }
    }
  }
  else
  {
    *unint64_t result = 0;
    result[1] = 0;
  }
  v3[5] = 0;
  v3[6] = 0;
  v3[3] = 0;
  v3[4] = v6;
  return result;
}

double re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::doResize(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  memset(v22, 0, sizeof(v22));
  re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::init(v22, v4, a2);
  v20[0] = a1;
  unint64_t v6 = a1[2];
  if (v6 >= 0x10)
  {
    uint64_t v7 = 0;
    uint64_t v8 = *a1;
    unint64_t v9 = v6 >> 4;
    __n128 v10 = (__n128)xmmword_2343680E0;
    v5.n128_u64[0] = 0x3830282018100800;
    while (1)
    {
      unsigned __int16 v11 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v8 + v7)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      v20[1] = (unsigned __int16)~v11;
      if (v11 != 0xFFFF) {
        break;
      }
      v7 += 16;
      if (!--v9) {
        goto LABEL_9;
      }
    }
    uint64_t v12 = __clz(__rbit64((unsigned __int16)~v11)) + v7;
    uint64_t v21 = v12;
    if (v12 != -1)
    {
      do
      {
        re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::internalAdd(v22, *(void *)(v20[0] + 8) + 48 * v12, *(void *)(v20[0] + 8) + 48 * v12 + 8, v10, v5);
        re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v20);
        uint64_t v12 = v21;
      }
      while (v21 != -1);
      unint64_t v6 = a1[2];
    }
  }
LABEL_9:
  uint64_t v13 = *((void *)&v22[3] + 1);
  *((void *)&v22[3] + 1) = a1[7];
  long long v14 = v22[0];
  long long v15 = v22[1];
  v22[0] = *(_OWORD *)a1;
  *(void *)&v22[1] = v6;
  long long v16 = v22[2];
  long long v17 = *(_OWORD *)(a1 + 5);
  a1[6] = *(void *)&v22[3];
  a1[7] = v13;
  *(_OWORD *)((char *)&v22[2] + 8) = v17;
  long long v18 = *(_OWORD *)(a1 + 3);
  *(_OWORD *)a1 = v14;
  *((_OWORD *)a1 + 1) = v15;
  *((_OWORD *)a1 + 2) = v16;
  *(_OWORD *)((char *)&v22[1] + 8) = v18;
  return re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)v22);
}

void *re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(void *result)
{
  unint64_t v1 = result[2];
  unint64_t v2 = v1 >> 4;
  unint64_t v3 = (void *)*result;
  unint64_t v4 = *(void *)(*result + 16);
  if (v1 >> 4 >= v4 >> 4)
  {
LABEL_8:
    uint64_t v6 = -1;
    goto LABEL_9;
  }
  unint64_t v5 = __clz(__rbit64(result[1] & (-2 << (v1 & 0xF))));
  if (v5 >= 0x40)
  {
    unint64_t v7 = ~v2 + (v4 >> 4);
    uint64_t v8 = 16 * v2;
    while (v7)
    {
      unint64_t v9 = (unsigned __int16)~*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(*v3 + v8 + 16)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
      result[1] = v9;
      unint64_t v10 = __clz(__rbit64(v9));
      --v7;
      v8 += 16;
      if (v10 <= 0x3F)
      {
        uint64_t v6 = v10 + v8;
        goto LABEL_9;
      }
    }
    goto LABEL_8;
  }
  uint64_t v6 = v5 + (v1 & 0xFFFFFFFFFFFFFFF0);
LABEL_9:
  result[2] = v6;
  return result;
}

double re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 16);
      if (v3)
      {
        uint64_t v4 = 48 * v3;
        unint64_t v5 = (uint64_t *)(v2 + 8);
        do
        {
          unint64_t v5 = std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>::~unique_ptr[abi:nn180100](v5)
             + 6;
          v4 -= 48;
        }
        while (v4);
      }
      *(void *)(a1 + 8) = 0;
    }
    if (*(void *)a1)
    {
      (*(void (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56));
      *(void *)a1 = 0;
    }
    double result = 0.0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

uint64_t std::__function::__value_func<void ()(re::EventBus::EventInfo *)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = v3;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t *std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>::operator=[abi:nn180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *a1;
  *a1 = v4;
  if (v5) {
    std::function<void ()(re::EventBus::EventInfo *)>::operator()((uint64_t)(a1 + 1), v5);
  }
  std::__function::__value_func<void ()(re::EventBus::EventInfo *)>::operator=[abi:nn180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

uint64_t std::function<void ()(re::EventBus::EventInfo *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__value_func<void ()(re::EventBus::EventInfo *)>::operator=[abi:nn180100](v4);
}

void *std::__function::__value_func<void ()(re::EventBus::EventInfo *)>::operator=[abi:nn180100](void *a1, uint64_t a2)
{
  std::__function::__value_func<void ()(re::EventBus::EventInfo *)>::operator=[abi:nn180100](a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(re::EventBus::EventInfo *)>::operator=[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::init(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  result[7] = a2;
  unint64_t v4 = 151 * a3;
  unint64_t v5 = ((unint64_t)(151 * a3) >> 7) + 15;
  result[2] = v5 & 0x3FFFFFFFFFFFFF0;
  if ((v5 & 0x3FFFFFFFFFFFFF0) != 0)
  {
    unint64_t v6 = v5 >> 4;
    double result = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 145 * (v5 & 0x3FFFFFFFFFFFFF0), 16);
    *uint64_t v3 = result;
    if (v4 >= 0x80)
    {
      uint64_t v7 = 0;
      *(void *)&long long v8 = -1;
      *((void *)&v8 + 1) = -1;
      do
        *(_OWORD *)(*v3 + 16 * v7++) = v8;
      while (v6 != v7);
      double result = (void *)*v3;
    }
    v3[1] = &result[2 * v6];
    if (v3[2])
    {
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      do
      {
        unsigned __int16 v11 = (_OWORD *)(v3[1] + v9);
        v11[7] = 0uLL;
        v11[8] = 0uLL;
        v11[5] = 0uLL;
        v11[6] = 0uLL;
        v11[3] = 0uLL;
        v11[4] = 0uLL;
        v11[1] = 0uLL;
        void v11[2] = 0uLL;
        *unsigned __int16 v11 = 0uLL;
        ++v10;
        unint64_t v12 = v3[2];
        v9 += 144;
      }
      while (v10 < v12);
    }
    else
    {
      unint64_t v12 = 0;
    }
  }
  else
  {
    unint64_t v12 = 0;
    *double result = 0;
    result[1] = 0;
  }
  v3[5] = 0;
  v3[6] = 0;
  v3[3] = 0;
  v3[4] = v12;
  return result;
}

void std::__function::__func<std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1},std::allocator<std::allocator>,void ()(std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1})>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1},std::allocator<std::allocator>,void ()(std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1})>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_26E6C4B18;
  return result;
}

void std::__function::__func<std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1},std::allocator<std::allocator>,void ()(std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1})>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4B18;
}

re *std::__function::__func<std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1},std::allocator<std::allocator>,void ()(std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1})>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::EventBus::EventInfo>((re *)"operator()", 36, *a2);
}

uint64_t std::__function::__func<std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1},std::allocator<std::allocator>,void ()(std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1})>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1},std::allocator<std::allocator>,void ()(std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>> re::makeDefaultUniquePtr<re::EventBus::EventInfo,unsigned long long &>(unsigned long long &)::{lambda(re::EventBus::EventInfo*)#1})>::target_type()
{
}

re *re::internal::destroyPersistent<re::EventBus::EventInfo>(re *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::deinit(a3 + 280);
    re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::deinit(a3 + 216);
    re::DynamicArray<unsigned long>::deinit(a3 + 168);
    re::DynamicArray<unsigned long>::deinit(a3 + 128);
    re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::deinit(a3 + 88);
    v5.n128_f64[0] = re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(a3 + 24);
    unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, __n128))(*(void *)v4 + 40);
    return (re *)v6(v4, a3, v5);
  }
  return result;
}

double re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::deinit(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 16);
      if (v3)
      {
        uint64_t v4 = 56 * v3;
        uint64_t v5 = v2 + 16;
        do
        {
          re::FunctionBase<24ul,void ()(void)>::destroyCallable(v5);
          v5 += 56;
          v4 -= 56;
        }
        while (v4);
      }
      *(void *)(a1 + 8) = 0;
    }
    if (*(void *)a1)
    {
      (*(void (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56));
      *(void *)a1 = 0;
    }
    double result = 0.0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

uint64_t (***re::FunctionBase<24ul,void ()(void)>::destroyCallable(uint64_t a1))(void)
{
  double result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    double result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      double result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

double re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::deinit(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 16);
      if (v3)
      {
        uint64_t v4 = 144 * v3;
        uint64_t v5 = v2 + 56;
        do
        {
          re::DynamicArray<unsigned long>::deinit(v5 + 40);
          re::DynamicArray<unsigned long>::deinit(v5);
          re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::deinit(v5 - 40);
          v5 += 144;
          v4 -= 144;
        }
        while (v4);
      }
      *(void *)(a1 + 8) = 0;
    }
    if (*(void *)a1)
    {
      (*(void (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56));
      *(void *)a1 = 0;
    }
    double result = 0.0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

uint64_t re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = v4 << 6;
        do
        {
          re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable(v3);
          v3 += 64;
          v5 -= 64;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

double re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {
    if (*(void *)(a1 + 8)) {
      *(void *)(a1 + 8) = 0;
    }
    if (*(void *)a1)
    {
      (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
      *(void *)a1 = 0;
    }
    double result = 0.0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

void *std::__function::__value_func<void ()(re::EventBus::EventInfo *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    std::function<void ()(re::EventBus::EventInfo *)>::operator()((uint64_t)(a1 + 1), v2);
  }
  std::__function::__value_func<void ()(re::EventBus::EventInfo *)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

uint64_t re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::addNew(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::find(a1, a2);
  if (v6 != -1) {
    return a1[1] + 56 * v6 + 16;
  }
  return re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::internalAdd((_anonymous_namespace_ *)a1, a2, a3);
}

uint64_t (***re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(re::EventBus::Subscriptions *)#1}::operator()(__n128 *a1, uint64_t a2))(void)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v4 = a1 + 5;
  unint64_t v5 = a1->n128_u64[0];
  re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::addNew((_anonymous_namespace_ *)(a1->n128_u64[0] + 24), &a1[4].n128_i64[1], (long long *)&a1[5]);
  if (!a2)
  {
    if (v4->n128_u64[0] || a1[5].n128_u64[1])
    {
      uint64_t v6 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)(v5 + 216), v4);
      if (v6 == -1)
      {
        long long v18 = 0u;
        long long v19 = 0u;
        long long v16 = 0u;
        long long v17 = 0u;
        long long v14 = 0u;
        long long v15 = 0u;
        memset(v13, 0, sizeof(v13));
        a2 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::addNew((uint64_t *)(v5 + 216), v4, (uint64_t)v13);
        if ((void)v17)
        {
          if ((void)v19) {
            (*(void (**)(void))(*(void *)v17 + 40))();
          }
          *(void *)&long long v19 = 0;
          *(void *)&long long v18 = 0;
          long long v17 = 0uLL;
          ++DWORD2(v18);
        }
        if (*((void *)&v14 + 1))
        {
          if (*((void *)&v16 + 1)) {
            (*(void (**)(void))(**((void **)&v14 + 1) + 40))();
          }
          *((void *)&v16 + 1) = 0;
          long long v15 = 0uLL;
          *((void *)&v14 + 1) = 0;
          LODWORD(v16) = v16 + 1;
        }
        re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::deinit((uint64_t)v13);
      }
      else
      {
        a2 = *(void *)(v5 + 224) + 144 * v6 + 16;
      }
    }
    else
    {
      a2 = v5 + 88;
    }
  }
  uint64_t v7 = a1[4].n128_i64[1];
  unint64_t v21 = a1[3].n128_u64[1];
  uint64_t v22 = 0;
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<48ul>((uint64_t)v20, (uint64_t)&a1->n128_i64[1]);
  re::EventBus::Subscriptions::add(a2, v7, (uint64_t)v20);
  double result = re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v20);
  if (*(unsigned char *)(v5 + 20))
  {
    BOOL v9 = 1;
  }
  else if (v4->n128_u64[0])
  {
    BOOL v9 = 0;
  }
  else
  {
    BOOL v9 = a1[5].n128_u64[1] == 0;
  }
  *(unsigned char *)(v5 + 20) = v9;
  if (*(unsigned char *)(v5 + 21)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = v4->n128_u64[0] != 0;
  }
  *(unsigned char *)(v5 + 21) = v10;
  if (*(unsigned char *)(v5 + 22)) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = a1[5].n128_u64[1] != 0;
  }
  *(unsigned char *)(v5 + 22) = v11;
  if (*(unsigned char *)(v5 + 23))
  {
    LOBYTE(v12) = 1;
  }
  else
  {
    unint64_t v12 = v4->n128_u64[0];
    if (v4->n128_u64[0]) {
      LOBYTE(v12) = a1[5].n128_u64[1] != 0;
    }
  }
  *(unsigned char *)(v5 + 23) = v12;
  return result;
}

uint64_t re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<48ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 56);
    if (*(void *)(a1 + 48) == *(void *)(a2 + 48))
    {
      uint64_t v5 = a2;
      if (v4 != a2)
      {
        *(void *)(a1 + 56) = v4;
        *(void *)(a2 + 56) = 0;
        return a1;
      }
    }
    else
    {
      uint64_t v5 = *(void *)(a2 + 56);
      if (!v4) {
        return a1;
      }
    }
    unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
    uint64_t v7 = a1;
    if (v6 >= 0x31)
    {
      unint64_t v8 = v6;
      uint64_t v9 = *(void *)(a1 + 48);
      if (v9) {
        uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v9 + 32))(v9, v8, 0);
      }
      else {
        uint64_t v7 = 0;
      }
    }
    *(void *)(a1 + 56) = v7;
    (*(void (**)(void))(**(void **)(a2 + 56) + 32))(*(void *)(a2 + 56));
    re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable(a2);
  }
  return a1;
}

{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  if (a1 != a2)
  {
    re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 56);
    if (v4)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      unint64_t v6 = a1;
      if (v5 >= 0x31)
      {
        uint64_t v7 = v5;
        unint64_t v8 = *(void *)(a1 + 48);
        if (v8) {
          unint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          unint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 56) = v6;
      (*(void (**)(void))(**(void **)(a2 + 56) + 24))(*(void *)(a2 + 56));
    }
  }
  return a1;
}

uint64_t (***re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable(uint64_t a1))(void)
{
  double result = *(uint64_t (****)(void))(a1 + 56);
  if (result)
  {
    double result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 56) != a1) {
      double result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
    }
    *(void *)(a1 + 56) = 0;
  }
  return result;
}

uint64_t re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find(uint64_t *a1, void *a2)
{
  if (!a1[7] || (unint64_t)a1[2] < 0x10 || !a1[3]) {
    return -1;
  }
  unint64_t v4 = re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v18, a2) % ((unint64_t)a1[2] >> 4);
  while (1)
  {
    uint64_t v5 = *a1;
    char v6 = re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v19, a2);
    int8x16_t v7 = *(int8x16_t *)(v5 + 16 * v4);
    unint64_t v8 = (unint64_t)vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(vdupq_n_s8(v6 & 0x7F), v7), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    unint64_t v9 = __clz(__rbit64(v8));
    v10.i64[0] = -1;
    v10.i64[1] = -1;
    if (v9 <= 0x3F) {
      break;
    }
LABEL_13:
    if (vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v7, v10), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800))
    {
      return -1;
    }
    if (++v4 == (unint64_t)a1[2] >> 4) {
      unint64_t v4 = 0;
    }
    unint64_t v17 = re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v20, a2)
        % ((unint64_t)a1[2] >> 4);
    uint64_t result = -1;
    if (v4 == v17) {
      return result;
    }
  }
  uint64_t v11 = 16 * v4;
  while (1)
  {
    uint64_t result = v9 + v11;
    uint64_t v13 = (uint64_t *)(a1[1] + 144 * (v9 + v11));
    uint64_t v15 = *v13;
    uint64_t v14 = v13[1];
    if (*a2 == v15 && a2[1] == v14) {
      return result;
    }
    if (v9 <= 0x3E)
    {
      unint64_t v9 = __clz(__rbit64((-2 << v9) & v8));
      if (v9 < 0x40) {
        continue;
      }
    }
    goto LABEL_13;
  }
}

unint64_t re::Hash<re::Pair<void const*,void const*,true>>::operator()(uint64_t a1, void *a2)
{
  unint64_t v2 = 0xBF58476D1CE4E5B9 * (*a2 ^ (*a2 >> 30));
  unint64_t v3 = (0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31);
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (a2[1] ^ (a2[1] >> 30));
  return (((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
        + (v3 << 6)
        + (v3 >> 2)
        - 0x61C8864680B583E9) ^ v3;
}

uint64_t re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::find(uint64_t *a1, void *a2)
{
  if (!a1[7] || (unint64_t)a1[2] < 0x10 || !a1[3]) {
    return -1;
  }
  unint64_t v4 = re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v18, a2) % ((unint64_t)a1[2] >> 4);
  while (1)
  {
    uint64_t v5 = *a1;
    char v6 = re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v19, a2);
    int8x16_t v7 = *(int8x16_t *)(v5 + 16 * v4);
    unint64_t v8 = (unint64_t)vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(vdupq_n_s8(v6 & 0x7F), v7), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    unint64_t v9 = __clz(__rbit64(v8));
    v10.i64[0] = -1;
    v10.i64[1] = -1;
    if (v9 <= 0x3F) {
      break;
    }
LABEL_13:
    if (vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v7, v10), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800))
    {
      return -1;
    }
    if (++v4 == (unint64_t)a1[2] >> 4) {
      unint64_t v4 = 0;
    }
    unint64_t v17 = re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v20, a2)
        % ((unint64_t)a1[2] >> 4);
    uint64_t result = -1;
    if (v4 == v17) {
      return result;
    }
  }
  uint64_t v11 = 16 * v4;
  while (1)
  {
    uint64_t result = v9 + v11;
    uint64_t v13 = (uint64_t *)(a1[1] + 56 * (v9 + v11));
    uint64_t v15 = *v13;
    uint64_t v14 = v13[1];
    if (*a2 == v15 && a2[1] == v14) {
      return result;
    }
    if (v9 <= 0x3E)
    {
      unint64_t v9 = __clz(__rbit64((-2 << v9) & v8));
      if (v9 < 0x40) {
        continue;
      }
    }
    goto LABEL_13;
  }
}

uint64_t re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::internalAdd(_anonymous_namespace_ *a1, void *a2, uint64_t a3)
{
  v18[5] = *MEMORY[0x263EF8340];
  if (!*((void *)a1 + 7))
  {
  }
  uint64_t v6 = *((void *)a1 + 4);
  if (!v6 || *((void *)a1 + 2) > (unint64_t)(8 * v6)) {
    re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::resize(a1, 1);
  }
  unint64_t v7 = re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v17, a2) % (*((void *)a1 + 2) >> 4);
  while (1)
  {
    uint64_t v8 = *(void *)a1;
    char v9 = re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v17, a2);
    unint64_t v10 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v8 + 16 * v7)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
    if (v10 < 0x40) {
      break;
    }
    if (v7 + 1 == *((void *)a1 + 2) >> 4) {
      unint64_t v7 = 0;
    }
    else {
      ++v7;
    }
  }
  uint64_t v11 = v8 + 16 * v7;
  BOOL v12 = *(unsigned __int8 *)(v11 + v10) == 255;
  *(unsigned char *)(v11 + v10) = v9 & 0x7F;
  unint64_t v13 = v10 + 16 * v7;
  long long v17 = *(_OWORD *)a2;
  v18[3] = *(void *)(a3 + 24);
  v18[4] = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v18, a3);
  uint64_t v14 = (_OWORD *)(*((void *)a1 + 1) + 56 * v13);
  *uint64_t v14 = v17;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)(v14 + 1), (uint64_t)v18);
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v18);
  uint64_t v15 = *((void *)a1 + 4) - v12;
  ++*((void *)a1 + 3);
  *((void *)a1 + 4) = v15;
  *((void *)a1 + 5) ^= re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v17, (void *)(*((void *)a1 + 1) + 56 * v13));
  return *((void *)a1 + 1) + 56 * v13 + 16;
}

double re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::resize(uint64_t *a1, int a2)
{
  unint64_t v2 = a1[2];
  unint64_t v3 = a1[3] + a2;
  unint64_t v4 = (((151 * v3) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  if (v4 > v2)
  {
    unint64_t v5 = 3 * v2;
    unint64_t v6 = v5 << 6;
    uint64_t v7 = (v5 >> 1) & 0x1FFFFFFFFFFFFFFLL;
    if (v4 <= v6 >> 7) {
      unint64_t v4 = v7;
    }
    unint64_t v3 = (v4 << 7) / 0x97;
  }
  return re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::doResize(a1, v3);
}

uint64_t *re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::init(uint64_t *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = (uint64_t **)result;
  result[7] = a2;
  unint64_t v4 = 151 * a3;
  unint64_t v5 = ((unint64_t)(151 * a3) >> 7) + 15;
  unint64_t v6 = v5 & 0x3FFFFFFFFFFFFF0;
  result[2] = v5 & 0x3FFFFFFFFFFFFF0;
  if ((v5 & 0x3FFFFFFFFFFFFF0) != 0)
  {
    unint64_t v7 = v5 >> 4;
    uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 57 * v6, 16);
    *unint64_t v3 = result;
    if (v4 >= 0x80)
    {
      uint64_t v8 = 0;
      *(void *)&long long v9 = -1;
      *((void *)&v9 + 1) = -1;
      do
        *(_OWORD *)&(*v3)[2 * v8++] = v9;
      while (v7 != v8);
      uint64_t result = *v3;
    }
    v3[1] = &result[2 * v7];
    unint64_t v6 = (unint64_t)v3[2];
    if (v6)
    {
      uint64_t v10 = 0;
      for (unint64_t i = 0; i < v6; ++i)
      {
        BOOL v12 = &v3[1][v10];
        v12[6] = 0;
        *((_OWORD *)v12 + 1) = 0u;
        *((_OWORD *)v12 + 2) = 0u;
        *(_OWORD *)BOOL v12 = 0u;
        uint64_t result = re::globalAllocators((re *)result);
        v12[5] = result[2];
        v12[6] = 0;
        unint64_t v6 = (unint64_t)v3[2];
        v10 += 7;
      }
    }
  }
  else
  {
    *uint64_t result = 0;
    result[1] = 0;
  }
  v3[5] = 0;
  v3[6] = 0;
  v3[3] = 0;
  v3[4] = (uint64_t *)v6;
  return result;
}

double re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::doResize(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  memset(v20, 0, sizeof(v20));
  re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::init((uint64_t *)v20, v4, a2);
  v18[0] = a1;
  unint64_t v5 = a1[2];
  if (v5 >= 0x10)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *a1;
    unint64_t v8 = v5 >> 4;
    while (1)
    {
      unsigned __int16 v9 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v7 + v6)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      v18[1] = (unsigned __int16)~v9;
      if (v9 != 0xFFFF) {
        break;
      }
      v6 += 16;
      if (!--v8) {
        goto LABEL_9;
      }
    }
    uint64_t v10 = __clz(__rbit64((unsigned __int16)~v9)) + v6;
    uint64_t v19 = v10;
    if (v10 != -1)
    {
      do
      {
        re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::internalAdd((_anonymous_namespace_ *)v20, (void *)(*(void *)(v18[0] + 8) + 56 * v10), *(void *)(v18[0] + 8) + 56 * v10 + 16);
        re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v18);
        uint64_t v10 = v19;
      }
      while (v19 != -1);
      unint64_t v5 = a1[2];
    }
  }
LABEL_9:
  uint64_t v11 = *((void *)&v20[3] + 1);
  *((void *)&v20[3] + 1) = a1[7];
  long long v12 = v20[0];
  long long v13 = v20[1];
  v20[0] = *(_OWORD *)a1;
  *(void *)&v20[1] = v5;
  long long v14 = v20[2];
  long long v15 = *(_OWORD *)(a1 + 5);
  a1[6] = *(void *)&v20[3];
  a1[7] = v11;
  *(_OWORD *)((char *)&v20[2] + 8) = v15;
  long long v16 = *(_OWORD *)(a1 + 3);
  *(_OWORD *)a1 = v12;
  *((_OWORD *)a1 + 1) = v13;
  *((_OWORD *)a1 + 2) = v14;
  *(_OWORD *)((char *)&v20[1] + 8) = v16;
  return re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::deinit((uint64_t)v20);
}

uint64_t re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(void)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (*(void *)(a1 + 24) == *(void *)(a2 + 24))
    {
      uint64_t v5 = a2;
      if (v4 != a2)
      {
        *(void *)(a1 + 32) = v4;
        *(void *)(a2 + 32) = 0;
        return a1;
      }
    }
    else
    {
      uint64_t v5 = *(void *)(a2 + 32);
      if (!v4) {
        return a1;
      }
    }
    unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
    uint64_t v7 = a1;
    if (v6 >= 0x19)
    {
      unint64_t v8 = v6;
      uint64_t v9 = *(void *)(a1 + 24);
      if (v9) {
        uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v9 + 32))(v9, v8, 0);
      }
      else {
        uint64_t v7 = 0;
      }
    }
    *(void *)(a1 + 32) = v7;
    (*(void (**)(void))(**(void **)(a2 + 32) + 32))(*(void *)(a2 + 32));
    re::FunctionBase<24ul,void ()(void)>::destroyCallable(a2);
  }
  return a1;
}

{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(void)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      unint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        uint64_t v7 = v5;
        unint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          unint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          unint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t re::FunctionBase<24ul,void ()(void)>::FunctionBase<re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(void)#1},void,void>(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = 0;
  if (a3) {
    uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a3 + 32))(a3, 104, 0);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *a2;
  *(void *)uint64_t v5 = &unk_26E6C4BA8;
  *(void *)(v5 + 8) = v6;
  *(void *)(v5 + 64) = a2[7];
  *(void *)(v5 + 72) = 0;
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<48ul>(v5 + 16, (uint64_t)(a2 + 1));
  uint64_t v7 = a2[11];
  *(_OWORD *)(v5 + 80) = *(_OWORD *)(a2 + 9);
  *(void *)(v5 + 96) = v7;
  *(void *)(a1 + 32) = v5;
  return a1;
}

void *re::internal::Callable<re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(void)#1},void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4BA8;
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)(a1 + 2));
  return a1;
}

void re::internal::Callable<re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(void)#1},void ()(void)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4BA8;
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)(a1 + 2));
  JUMPOUT(0x237DBCBD0);
}

uint64_t (***re::internal::Callable<re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(void)#1},void ()(void)>::operator()(uint64_t a1))(void)
{
  return re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(re::EventBus::Subscriptions *)#1}::operator()((__n128 *)(a1 + 8), 0);
}

uint64_t re::internal::Callable<re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(void)#1},void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C4BA8;
  *(void *)(a2 + 8) = v4;
  *(void *)(a2 + 64) = *(void *)(a1 + 64);
  *(void *)(a2 + 72) = 0;
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<48ul>(a2 + 16, a1 + 16);
  uint64_t v5 = *(void *)(a1 + 96);
  *(_OWORD *)(a2 + 80) = *(_OWORD *)(a1 + 80);
  *(void *)(a2 + 96) = v5;
  return a2;
}

uint64_t re::internal::Callable<re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(void)#1},void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C4BA8;
  *(void *)(a2 + 8) = v4;
  *(void *)(a2 + 64) = *(void *)(a1 + 64);
  *(void *)(a2 + 72) = 0;
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<48ul>(a2 + 16, a1 + 16);
  uint64_t v5 = *(void *)(a1 + 96);
  *(_OWORD *)(a2 + 80) = *(_OWORD *)(a1 + 80);
  *(void *)(a2 + 96) = v5;
  return a2;
}

uint64_t re::internal::Callable<re::EventBus::EventInfo::addSubscription(re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> &&,void const*,void const*)::{lambda(void)#1},void ()(void)>::size()
{
  return 104;
}

void *re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::addNew(_anonymous_namespace_ *a1, uint64_t *a2, long long *a3)
{
  uint64_t v6 = re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find(a1, a2);
  if (v6 != -1) {
    return (void *)(*((void *)a1 + 1) + 24 * v6 + 8);
  }
  return re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::internalAdd(a1, a2, a3);
}

uint64_t re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::addNew(uint64_t *a1, __n128 *a2, uint64_t a3)
{
  uint64_t v6 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find(a1, a2);
  if (v6 != -1) {
    return a1[1] + 144 * v6 + 16;
  }
  return re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::internalAdd((_anonymous_namespace_ *)a1, a2, a3);
}

uint64_t re::EventBus::Subscriptions::add(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v10 = a2;
  uint64_t v5 = *(void *)(a1 + 96);
  if (!v5)
  {
    re::DynamicArray<re::TransitionCondition *>::add((void *)(a1 + 40), &v10);
    uint64_t result = re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::add((_anonymous_namespace_ *)a1, a3);
    goto LABEL_6;
  }
  uint64_t v6 = v5 - 1;
  unint64_t v7 = *(void *)(*(void *)(a1 + 112) + 8 * v6);
  *(void *)(a1 + 96) = v6;
  ++*(_DWORD *)(a1 + 104);
  unint64_t v8 = *(void *)(a1 + 56);
  if (v8 <= v7)
  {
    uint64_t v11 = 0;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v12 = 136315906;
    long long v13 = "operator[]";
    __int16 v14 = 1024;
    int v15 = 789;
    __int16 v16 = 2048;
    unint64_t v17 = v7;
    __int16 v18 = 2048;
    unint64_t v19 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_8:
    uint64_t v11 = 0;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v12 = 136315906;
    long long v13 = "operator[]";
    __int16 v14 = 1024;
    int v15 = 789;
    __int16 v16 = 2048;
    unint64_t v17 = v7;
    __int16 v18 = 2048;
    unint64_t v19 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(void *)(*(void *)(a1 + 72) + 8 * v7) = a2;
  unint64_t v8 = *(void *)(a1 + 16);
  if (v8 <= v7) {
    goto LABEL_8;
  }
  uint64_t result = re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<48ul>(*(void *)(a1 + 32) + (v7 << 6), a3);
LABEL_6:
  ++*(void *)(a1 + 120);
  return result;
}

uint64_t re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find(void *a1, uint64_t *a2)
{
  if (!a1[7]) {
    return -1;
  }
  unint64_t v2 = a1[2];
  if (v2 < 0x10 || !a1[3]) {
    return -1;
  }
  unint64_t v3 = v2 >> 4;
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = v6 % v3;
  int8x16_t v8 = vdupq_n_s8(v6 & 0x7F);
  v9.i64[0] = -1;
  v9.i64[1] = -1;
  unint64_t v10 = v6 % v3;
  while (1)
  {
    int8x16_t v11 = *(int8x16_t *)(*a1 + 16 * v10);
    unint64_t v12 = (unint64_t)vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v8, v11), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    unint64_t v13 = __clz(__rbit64(v12));
    if (v13 <= 0x3F) {
      break;
    }
LABEL_10:
    if (vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v11, v9), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800))
    {
      return -1;
    }
    if (v10 + 1 == v3) {
      unint64_t v10 = 0;
    }
    else {
      ++v10;
    }
    uint64_t v15 = -1;
    if (v10 == v7) {
      return v15;
    }
  }
  uint64_t v14 = 16 * v10;
  while (1)
  {
    uint64_t v15 = v13 + v14;
    if (v4 == *(void *)(a1[1] + 24 * (v13 + v14))) {
      return v15;
    }
    if (v13 <= 0x3E)
    {
      unint64_t v13 = __clz(__rbit64((-2 << v13) & v12));
      if (v13 < 0x40) {
        continue;
      }
    }
    goto LABEL_10;
  }
}

void *re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::internalAdd(_anonymous_namespace_ *a1, void *a2, long long *a3)
{
  if (!*((void *)a1 + 7))
  {
  }
  uint64_t v6 = *((void *)a1 + 4);
  if (!v6 || (unint64_t v7 = *((void *)a1 + 2), v7 > 8 * v6))
  {
    re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::resize((uint64_t *)a1, 1);
    unint64_t v7 = *((void *)a1 + 2);
  }
  unint64_t v8 = 0xBF58476D1CE4E5B9;
  unint64_t v9 = 0x94D049BB133111EBLL;
  unint64_t v10 = 0xBF58476D1CE4E5B9 * (*a2 ^ (*a2 >> 30));
  unint64_t v11 = (0x94D049BB133111EBLL * (v10 ^ (v10 >> 27))) ^ ((0x94D049BB133111EBLL * (v10 ^ (v10 >> 27))) >> 31);
  unint64_t v12 = v7 >> 4;
  uint64_t v13 = *(void *)a1;
  unint64_t v14 = v11 % v12;
  while (1)
  {
    unint64_t v15 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v13 + 16 * v14)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
    if (v15 < 0x40) {
      break;
    }
    if (v14 + 1 == v12) {
      unint64_t v14 = 0;
    }
    else {
      ++v14;
    }
    if (v14 == v11 % v12)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, -1.79399301e-307, 4.74803907e-38, "assertion failure: '%s' (%s:line %i) Unexpected full hash-table", "blockIndex != h1(key) % blockCount()", "internalAdd", 656);
      _os_crash();
      __break(1u);
      break;
    }
  }
  uint64_t v16 = v13 + 16 * v14;
  BOOL v17 = *(unsigned __int8 *)(v16 + v15) == 255;
  *(unsigned char *)(v16 + v15) = v11 & 0x7F;
  long long v18 = *a3;
  uint64_t v19 = 3 * (v15 + 16 * v14);
  uint64_t v20 = *((void *)a1 + 1) + 24 * (v15 + 16 * v14);
  *(void *)uint64_t v20 = *a2;
  *(_OWORD *)(v20 + 8) = v18;
  uint64_t v21 = *((void *)a1 + 4) - v17;
  ++*((void *)a1 + 3);
  *((void *)a1 + 4) = v21;
  long long v22 = (unint64_t *)(*((void *)a1 + 1) + 8 * v19);
  unint64_t v24 = *v22;
  uint64_t result = v22 + 1;
  unint64_t v25 = (((v24 ^ (v24 >> 30)) * v8) ^ (((v24 ^ (v24 >> 30)) * v8) >> 27)) * v9;
  *((void *)a1 + 5) ^= (v25 >> 31) ^ v25;
  return result;
}

{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  BOOL v15;
  long long v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  void *result;
  unint64_t v22;
  unint64_t v23;

  if (!*((void *)a1 + 7))
  {
  }
  uint64_t v6 = *((void *)a1 + 4);
  if (!v6 || (unint64_t v7 = *((void *)a1 + 2), v7 > 8 * v6))
  {
    re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::resize(a1, 1);
    unint64_t v7 = *((void *)a1 + 2);
  }
  unint64_t v8 = 0xBF58476D1CE4E5B9 * (*a2 ^ (*a2 >> 30));
  unint64_t v9 = (0x94D049BB133111EBLL * (v8 ^ (v8 >> 27))) ^ ((0x94D049BB133111EBLL * (v8 ^ (v8 >> 27))) >> 31);
  unint64_t v10 = v7 >> 4;
  unint64_t v11 = v9 % (v7 >> 4);
  unint64_t v12 = *(void *)a1;
  uint64_t v13 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(*(void *)a1 + 16 * v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
  if (v13 >= 0x40)
  {
    do
    {
      if (v11 + 1 == v10) {
        unint64_t v11 = 0;
      }
      else {
        ++v11;
      }
      uint64_t v13 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v12 + 16 * v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
    }
    while (v13 > 0x3F);
  }
  unint64_t v14 = v12 + 16 * v11;
  unint64_t v15 = *(unsigned __int8 *)(v14 + v13) == 255;
  *(unsigned char *)(v14 + v13) = v9 & 0x7F;
  uint64_t v16 = *a3;
  BOOL v17 = 3 * (v13 + 16 * v11);
  long long v18 = *((void *)a1 + 1) + 8 * v17;
  *(void *)long long v18 = *a2;
  *(_OWORD *)(v18 + 8) = v16;
  uint64_t v19 = *((void *)a1 + 4) - v15;
  ++*((void *)a1 + 3);
  *((void *)a1 + 4) = v19;
  uint64_t v20 = (unint64_t *)(*((void *)a1 + 1) + 8 * v17);
  long long v22 = *v20;
  uint64_t result = v20 + 1;
  long long v23 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v22 ^ (v22 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v22 ^ (v22 >> 30))) >> 27));
  *((void *)a1 + 5) ^= (v23 >> 31) ^ v23;
  return result;
}

uint64_t re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::resize(uint64_t *a1, int a2)
{
  unint64_t v2 = a1[2];
  unint64_t v3 = a1[3] + a2;
  unint64_t v4 = (((151 * v3) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  if (v4 > v2)
  {
    unint64_t v5 = 3 * v2;
    unint64_t v6 = v5 << 6;
    uint64_t v7 = (v5 >> 1) & 0x1FFFFFFFFFFFFFFLL;
    if (v4 <= v6 >> 7) {
      unint64_t v4 = v7;
    }
    unint64_t v3 = (v4 << 7) / 0x97;
  }
  return re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::doResize(a1, v3);
}

void *re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::init(void *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = result;
  result[7] = a2;
  unint64_t v4 = 151 * a3;
  unint64_t v5 = ((unint64_t)(151 * a3) >> 7) + 15;
  unint64_t v6 = v5 & 0x3FFFFFFFFFFFFF0;
  result[2] = v5 & 0x3FFFFFFFFFFFFF0;
  if ((v5 & 0x3FFFFFFFFFFFFF0) != 0)
  {
    unint64_t v7 = v5 >> 4;
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 25 * v6, 16);
    *unint64_t v3 = result;
    if (v4 >= 0x80)
    {
      uint64_t v8 = 0;
      *(void *)&long long v9 = -1;
      *((void *)&v9 + 1) = -1;
      do
        *(_OWORD *)(*v3 + 16 * v8++) = v9;
      while (v7 != v8);
      uint64_t result = (void *)*v3;
    }
    v3[1] = &result[2 * v7];
    unint64_t v6 = v3[2];
    if (v6)
    {
      uint64_t v10 = 0;
      for (unint64_t i = 0; i < v6; ++i)
      {
        unint64_t v12 = (void *)(v3[1] + v10);
        *unint64_t v12 = 0;
        v12[1] = 0;
        void v12[2] = 0;
        unint64_t v6 = v3[2];
        v10 += 24;
      }
    }
  }
  else
  {
    *uint64_t result = 0;
    result[1] = 0;
  }
  v3[5] = 0;
  v3[6] = 0;
  v3[3] = 0;
  v3[4] = v6;
  return result;
}

uint64_t re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::doResize(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  memset(v22, 0, sizeof(v22));
  re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::init(v22, v4, a2);
  v20[0] = a1;
  unint64_t v5 = a1[2];
  if (v5 >= 0x10)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *a1;
    unint64_t v8 = v5 >> 4;
    while (1)
    {
      unsigned __int16 v9 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v7 + v6)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      v20[1] = (unsigned __int16)~v9;
      if (v9 != 0xFFFF) {
        break;
      }
      v6 += 16;
      if (!--v8) {
        goto LABEL_9;
      }
    }
    uint64_t v10 = __clz(__rbit64((unsigned __int16)~v9)) + v6;
    uint64_t v21 = v10;
    if (v10 != -1)
    {
      do
      {
        re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::internalAdd((_anonymous_namespace_ *)v22, (void *)(*(void *)(v20[0] + 8) + 24 * v10), (long long *)(*(void *)(v20[0] + 8) + 24 * v10 + 8));
        re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v20);
        uint64_t v10 = v21;
      }
      while (v21 != -1);
      unint64_t v5 = a1[2];
    }
  }
LABEL_9:
  uint64_t v12 = *((void *)&v22[3] + 1);
  *((void *)&v22[3] + 1) = a1[7];
  uint64_t result = *((void *)&v22[3] + 1);
  long long v13 = v22[0];
  long long v14 = v22[1];
  *(void *)&v22[1] = v5;
  uint64_t v15 = *a1;
  uint64_t v16 = a1[1];
  *(void *)&v22[0] = *a1;
  *((void *)&v22[0] + 1) = v16;
  long long v17 = v22[2];
  long long v18 = *(_OWORD *)(a1 + 5);
  a1[6] = *(void *)&v22[3];
  a1[7] = v12;
  *(_OWORD *)((char *)&v22[2] + 8) = v18;
  long long v19 = *(_OWORD *)(a1 + 3);
  *(_OWORD *)a1 = v13;
  *((_OWORD *)a1 + 1) = v14;
  *((_OWORD *)a1 + 2) = v17;
  *(_OWORD *)((char *)&v22[1] + 8) = v19;
  if (result)
  {
    if (v16) {
      *((void *)&v22[0] + 1) = 0;
    }
    if (v15) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
    }
  }
  return result;
}

uint64_t re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::internalAdd(_anonymous_namespace_ *a1, __n128 *a2, uint64_t a3)
{
  if (!*((void *)a1 + 7))
  {
  }
  uint64_t v6 = *((void *)a1 + 4);
  if (!v6 || *((void *)a1 + 2) > (unint64_t)(8 * v6)) {
    re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::resize((uint64_t *)a1, 1);
  }
  unint64_t v7 = re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v17, a2) % (*((void *)a1 + 2) >> 4);
  while (1)
  {
    uint64_t v8 = *(void *)a1;
    char v9 = re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v17, a2);
    unint64_t v10 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v8 + 16 * v7)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
    if (v10 <= 0x3F) {
      break;
    }
    if (v7 + 1 == *((void *)a1 + 2) >> 4) {
      unint64_t v7 = 0;
    }
    else {
      ++v7;
    }
  }
  uint64_t v11 = v8 + 16 * v7;
  int v12 = *(unsigned __int8 *)(v11 + v10);
  *(unsigned char *)(v11 + v10) = v9 & 0x7F;
  unint64_t v13 = v10 + 16 * v7;
  re::KeyValuePair<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions>::KeyValuePair<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions>(&v17, a2, a3);
  long long v14 = (__n128 *)(*((void *)a1 + 1) + 144 * v13);
  *long long v14 = v17;
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=((uint64_t)&v14[1], (uint64_t)v18);
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=((uint64_t)&v14[3].n128_i64[1], (uint64_t)v19);
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=((uint64_t)&v14[6], (uint64_t)v22);
  v14[8].n128_u64[1] = v25;
  if (v22[0])
  {
    if (v24) {
      (*(void (**)(void))(*(void *)v22[0] + 40))();
    }
    uint64_t v24 = 0;
    memset(v22, 0, sizeof(v22));
    ++v23;
  }
  if (v19[0])
  {
    if (v21) {
      (*(void (**)(void))(*(void *)v19[0] + 40))();
    }
    uint64_t v21 = 0;
    memset(v19, 0, sizeof(v19));
    ++v20;
  }
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::deinit((uint64_t)v18);
  uint64_t v15 = *((void *)a1 + 4) - (v12 == 255);
  ++*((void *)a1 + 3);
  *((void *)a1 + 4) = v15;
  *((void *)a1 + 5) ^= re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v17, (void *)(*((void *)a1 + 1) + 144 * v13));
  return *((void *)a1 + 1) + 144 * v13 + 16;
}

double re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::resize(uint64_t *a1, int a2)
{
  unint64_t v2 = a1[2];
  unint64_t v3 = a1[3] + a2;
  unint64_t v4 = (((151 * v3) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  if (v4 > v2)
  {
    unint64_t v5 = 3 * v2;
    unint64_t v6 = v5 << 6;
    uint64_t v7 = (v5 >> 1) & 0x1FFFFFFFFFFFFFFLL;
    if (v4 <= v6 >> 7) {
      unint64_t v4 = v7;
    }
    unint64_t v3 = (v4 << 7) / 0x97;
  }
  return re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::doResize(a1, v3);
}

double re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::doResize(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  memset(v22, 0, sizeof(v22));
  re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::init(v22, v4, a2);
  v20[0] = a1;
  unint64_t v6 = a1[2];
  if (v6 >= 0x10)
  {
    uint64_t v7 = 0;
    uint64_t v8 = *a1;
    unint64_t v9 = v6 >> 4;
    __n128 v10 = (__n128)xmmword_2343680E0;
    v5.n128_u64[0] = 0x3830282018100800;
    while (1)
    {
      unsigned __int16 v11 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v8 + v7)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      v20[1] = (unsigned __int16)~v11;
      if (v11 != 0xFFFF) {
        break;
      }
      v7 += 16;
      if (!--v9) {
        goto LABEL_9;
      }
    }
    uint64_t v12 = __clz(__rbit64((unsigned __int16)~v11)) + v7;
    uint64_t v21 = v12;
    if (v12 != -1)
    {
      do
      {
        re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::internalAdd(v22, *(void *)(v20[0] + 8) + 144 * v12, *(void *)(v20[0] + 8) + 144 * v12 + 16, v10, v5);
        re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v20);
        uint64_t v12 = v21;
      }
      while (v21 != -1);
      unint64_t v6 = a1[2];
    }
  }
LABEL_9:
  uint64_t v13 = *((void *)&v22[3] + 1);
  *((void *)&v22[3] + 1) = a1[7];
  long long v14 = v22[0];
  long long v15 = v22[1];
  v22[0] = *(_OWORD *)a1;
  *(void *)&v22[1] = v6;
  long long v16 = v22[2];
  long long v17 = *(_OWORD *)(a1 + 5);
  a1[6] = *(void *)&v22[3];
  a1[7] = v13;
  *(_OWORD *)((char *)&v22[2] + 8) = v17;
  long long v18 = *(_OWORD *)(a1 + 3);
  *(_OWORD *)a1 = v14;
  *((_OWORD *)a1 + 1) = v15;
  *((_OWORD *)a1 + 2) = v16;
  *(_OWORD *)((char *)&v22[1] + 8) = v18;
  return re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::deinit((uint64_t)v22);
}

__n128 re::KeyValuePair<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions>::KeyValuePair<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  __n128 result = *a2;
  *a1 = *a2;
  a1[3].n128_u64[0] = 0;
  a1[2].n128_u32[2] = 0;
  a1[1].n128_u64[1] = 0;
  a1[2].n128_u64[0] = 0;
  a1[1].n128_u64[0] = 0;
  unint64_t v4 = *(void *)(a3 + 8);
  a1[1].n128_u64[0] = *(void *)a3;
  a1[1].n128_u64[1] = v4;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  unint64_t v5 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = *(void *)(a3 + 16);
  *(void *)(a3 + 16) = v5;
  unint64_t v6 = a1[3].n128_u64[0];
  a1[3].n128_u64[0] = *(void *)(a3 + 32);
  *(void *)(a3 + 32) = v6;
  ++*(_DWORD *)(a3 + 24);
  ++a1[2].n128_u32[2];
  a1[5].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  a1[4].n128_u64[1] = 0;
  a1[3].n128_u64[1] = 0;
  a1[5].n128_u32[0] = 0;
  unint64_t v7 = *(void *)(a3 + 48);
  a1[3].n128_u64[1] = *(void *)(a3 + 40);
  a1[4].n128_u64[0] = v7;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  unint64_t v8 = a1[4].n128_u64[1];
  a1[4].n128_u64[1] = *(void *)(a3 + 56);
  *(void *)(a3 + 56) = v8;
  unint64_t v9 = a1[5].n128_u64[1];
  a1[5].n128_u64[1] = *(void *)(a3 + 72);
  *(void *)(a3 + 72) = v9;
  ++*(_DWORD *)(a3 + 64);
  ++a1[5].n128_u32[0];
  a1[8].n128_u64[0] = 0;
  a1[6].n128_u64[1] = 0;
  a1[7].n128_u64[0] = 0;
  a1[6].n128_u64[0] = 0;
  a1[7].n128_u32[2] = 0;
  unint64_t v10 = *(void *)(a3 + 88);
  a1[6].n128_u64[0] = *(void *)(a3 + 80);
  a1[6].n128_u64[1] = v10;
  *(void *)(a3 + 80) = 0;
  *(void *)(a3 + 88) = 0;
  unint64_t v11 = a1[7].n128_u64[0];
  a1[7].n128_u64[0] = *(void *)(a3 + 96);
  *(void *)(a3 + 96) = v11;
  unint64_t v12 = a1[8].n128_u64[0];
  unint64_t v13 = *(void *)(a3 + 120);
  a1[8].n128_u64[0] = *(void *)(a3 + 112);
  *(void *)(a3 + 112) = v12;
  ++*(_DWORD *)(a3 + 104);
  ++a1[7].n128_u32[2];
  a1[8].n128_u64[1] = v13;
  return result;
}

uint64_t re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)a2;
    if (*(void *)result) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4 || v2 == v3)
    {
      uint64_t v6 = *(void *)(result + 8);
      uint64_t v7 = *(void *)(a2 + 8);
      *(void *)__n128 result = v3;
      *(void *)(result + 8) = v7;
      *(void *)a2 = v2;
      *(void *)(a2 + 8) = v6;
      uint64_t v8 = *(void *)(result + 16);
      *(void *)(result + 16) = *(void *)(a2 + 16);
      *(void *)(a2 + 16) = v8;
      uint64_t v9 = *(void *)(result + 32);
      *(void *)(result + 32) = *(void *)(a2 + 32);
      *(void *)(a2 + 32) = v9;
      ++*(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(result + 24);
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      __n128 result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + (v4 << 6);
  *(void *)(v5 + 48) = *(void *)(a2 + 48);
  *(void *)(v5 + 56) = 0;
  uint64_t result = re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<48ul>(v5, a2);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 58)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 64, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          unint64_t v2 = a2 << 6;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, a2 << 6, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v9 << 6;
        uint64_t v11 = (uint64_t)v7;
        do
        {
          *(void *)(v11 + 48) = *(void *)(v8 + 48);
          *(void *)(v11 + 56) = 0;
          re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<48ul>(v11, v8);
          re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable(v8);
          v8 += 64;
          v11 += 64;
          v10 -= 64;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4C10;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4C10;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
  return 1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4C10;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4C10;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4C78;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4C78;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  return (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4C78;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4C78;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneDidAddEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

uint64_t (***re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>@<X0>(uint64_t a1@<X2>, char a2@<W4>, void *a3@<X8>))(void)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v6 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v6)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C4CD0;
  }
  else
  {
    uint64_t v4 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v4)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C4D28;
  }
  *a3 = v5;
  a3[4] = v9;
  a3[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v8);
  a3[7] = a3;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::destroyCallable((uint64_t)v8);
}

uint64_t re::EventBus::getTypeId<RESceneWillRemoveEvent>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::EventBus::getTypeId<RESceneWillRemoveEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"22RESceneWillRemoveEvent" & 0x7FFFFFFFFFFFFFFFLL), v3);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[214];
}

uint64_t re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4CD0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4CD0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
  return 1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4CD0;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4CD0;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4D28;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4D28;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  return (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4D28;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4D28;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Scene,RESceneWillRemoveEvent>(re::ecs2::Scene *,re::Function<REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

uint64_t re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  uint64_t v12 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(v12 + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)unint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    long long v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_68, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 601);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addEmplace<re::PeerAttributionContext *&>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(void *)&v25[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v25, v4, a2);
      uint64_t v5 = *(void *)a1;
      uint64_t v6 = *(void *)(a1 + 8);
      *(void *)a1 = *(void *)v25;
      uint64_t v7 = *(void *)(a1 + 16);
      long long v8 = *(_OWORD *)&v25[8];
      *(void *)&v25[16] = v7;
      *(_OWORD *)(a1 + 8) = v8;
      long long v10 = *(_OWORD *)&v25[24];
      *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
      unsigned int v9 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + 24) = v10;
      uint64_t v11 = v9;
      if (!v9)
      {
        if (!v5) {
          return;
        }
        goto LABEL_28;
      }
      int v12 = DWORD1(v10);
      uint64_t v13 = v8;
      long long v14 = (void *)(v7 + 16);
      uint64_t v15 = v9;
      do
      {
        if ((*(_DWORD *)(v14 - 1) & 0x80000000) != 0)
        {
          unint64_t v16 = *(v14 - 2);
          unint64_t v17 = *(unsigned int *)(a1 + 24);
          unint64_t v18 = v16 % v17;
          uint64_t v19 = *(unsigned int *)(a1 + 36);
          if (v19 == 0x7FFFFFFF)
          {
            uint64_t v19 = *(unsigned int *)(a1 + 32);
            int v20 = v19;
            if (v19 == v17)
            {
              re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * v12));
              unint64_t v18 = v16 % *(unsigned int *)(a1 + 24);
              int v20 = *(_DWORD *)(a1 + 32);
              uint64_t v13 = *(void *)(a1 + 8);
            }
            *(_DWORD *)(a1 + 32) = v20 + 1;
            uint64_t v21 = *(void *)(a1 + 16);
            int v22 = *(_DWORD *)(v21 + 32 * v19 + 8);
          }
          else
          {
            uint64_t v21 = *(void *)(a1 + 16);
            int v22 = *(_DWORD *)(v21 + 32 * v19 + 8);
            *(_DWORD *)(a1 + 36) = v22 & 0x7FFFFFFF;
          }
          *(_DWORD *)(v21 + 32 * v19 + 8) = v22 | 0x80000000;
          *(_DWORD *)(*(void *)(a1 + 16) + 32 * v19 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v19 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v18);
          *(void *)(*(void *)(a1 + 16) + 32 * v19) = v16;
          *(void *)(*(void *)(a1 + 16) + 32 * v19 + 16) = *v14;
          *(void *)(*(void *)(a1 + 16) + 32 * v19 + 24) = v14[1];
          uint64_t v13 = *(void *)(a1 + 8);
          *(_DWORD *)(v13 + 4 * v18) = v19;
          int v12 = *(_DWORD *)(a1 + 28) + 1;
          *(_DWORD *)(a1 + 28) = v12;
        }
        v14 += 4;
        --v15;
      }
      while (v15);
      if (v5)
      {
        int v23 = (_DWORD *)(v7 + 8);
        do
        {
          if ((*v23 & 0x80000000) != 0) {
            *v23 &= ~0x80000000;
          }
          v23 += 8;
          --v11;
        }
        while (v11);
LABEL_28:
        (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 40))(v5, v6);
      }
    }
  }
  else
  {
    if (a2) {
      signed int v24 = a2;
    }
    else {
      signed int v24 = 3;
    }
  }
}

void re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    long long v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_68, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _WORD *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 16 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 16 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 16 * v8 + 8) = v11 | 0x80000000;
  uint64_t v12 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 16 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 16 * v8 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 16 * v8) = a3;
  *(_WORD *)(*(void *)(a1 + 16) + 16 * v8 + 12) = *a5;
  *(_DWORD *)(v12 + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 12, *(void *)&v13[16] + v10 + 12);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 16;
        }
        while (v11 < v9);
      }
      re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 16 * v10, 16);
  if (v12)
  {
    long long v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_68, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 601);
    _os_crash();
    __break(1u);
  }
}

void *re::DynamicArray<unsigned short>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<unsigned short>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<unsigned short>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<unsigned short>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          unint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if ((a2 & 0x8000000000000000) != 0)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 2, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 2 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 2 * a2, 2);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 2 * v5[2]);
            uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        uint64_t result = (void *)re::DynamicArray<unsigned short>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t (***re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>@<X0>(uint64_t a1@<X2>, char a2@<W4>, void *a3@<X8>))(void)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v6 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v6)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C4D80;
  }
  else
  {
    unint64_t v4 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v4)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C4DD8;
  }
  *a3 = v5;
  a3[4] = v9;
  a3[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v8);
  a3[7] = a3;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::destroyCallable((uint64_t)v8);
}

uint64_t re::EventBus::getTypeId<RESceneEntityDidActivateEvent>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::EventBus::getTypeId<RESceneEntityDidActivateEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"29RESceneEntityDidActivateEvent" & 0x7FFFFFFFFFFFFFFFLL), v3);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[216];
}

uint64_t re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4D80;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4D80;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
  return 1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4D80;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4D80;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4DD8;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4DD8;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  return (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4DD8;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4DD8;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

uint64_t (***re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>@<X0>(uint64_t a1@<X2>, char a2@<W4>, void *a3@<X8>))(void)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v6 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v6)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C4E30;
  }
  else
  {
    uint64_t v4 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v4)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C4E88;
  }
  *a3 = v5;
  a3[4] = v9;
  a3[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v8);
  a3[7] = a3;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable((uint64_t)v8);
}

uint64_t re::EventBus::getTypeId<REComponentDidActivateEvent>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::EventBus::getTypeId<REComponentDidActivateEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"27REComponentDidActivateEvent" & 0x7FFFFFFFFFFFFFFFLL), v3);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[218];
}

uint64_t re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4E30;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4E30;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
  return 1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4E30;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4E30;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4E88;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C4E88;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  return (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4E88;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4E88;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidActivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

uint64_t re::EventBus::getTypeId<REOwnershipChangedEvent>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::EventBus::getTypeId<REOwnershipChangedEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"23REOwnershipChangedEvent" & 0x7FFFFFFFFFFFFFFFLL), v3);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[220];
}

void *re::allocInfo_FrameAnalysisService(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_28, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_28))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF749B0, "FrameAnalysisService");
    __cxa_guard_release(&_MergedGlobals_28);
  }
  return &unk_26AF749B0;
}

void re::initInfo_FrameAnalysisService(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x8825A5C357582E58;
  v5[1] = "FrameAnalysisService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((void *)this + 11) = re::internal::defaultRetain<re::FrameAnalysisService>(void)::{lambda(void *)#1}::__invoke;
  *((void *)this + 12) = re::internal::defaultRelease<re::FrameAnalysisService>(void)::{lambda(void *)#1}::__invoke;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = &re::initInfo_FrameAnalysisService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_FrameAnalysisService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"FrameAnalysisService", (uint64_t (*)(re::internal *))re::allocInfo_FrameAnalysisService, (re::IntrospectionBase *(*)(void))re::initInfo_FrameAnalysisService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::FrameAnalysisService>, this);
}

id re::internal::defaultRetain<re::FrameAnalysisService>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::FrameAnalysisService>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
}

void anonymous namespace'::SharedEngineContext::instance(_anonymous_namespace_::SharedEngineContext *this)
{
  {
    qword_26879E280 = 0;
    dword_26879E288 = 0;
  }
}

void anonymous namespace'::SharedEngineContext::retainOrInit(_anonymous_namespace_::SharedEngineContext *this, unsigned int a2, int a3)
{
  int v5 = (int)this;
  os_unfair_lock_lock((os_unfair_lock_t)&dword_26879E288);
  if ((unint64_t)++qword_26879E280 <= 1)
  {
    dword_26879E28C = v5;
    unk_26879E290 = a2;
    dword_26879E294 = a3;
    if (re::ecs2::dispatchOnceInitECSComponents(void)::onceToken != -1) {
      dispatch_once(&re::ecs2::dispatchOnceInitECSComponents(void)::onceToken, &__block_literal_global_13);
    }
    re::initCollision(v6);
    re::RenderGraphNodeRegistry::init(v8);
    re::RenderGraphEmitterRegistry::init(v9);
    uint64_t v10 = re::RenderGraphNodeRegistry::m_instance;
    re::RenderGraphNodeRegistry::registerNode(re::RenderGraphNodeRegistry::m_instance, (uint64_t)_MergedGlobals_7);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71188);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71190);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71198);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711A0);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711A8);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711B0);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711B8);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711C0);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711C8);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711D0);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711D8);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711E0);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711E8);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711F0);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF711F8);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71200);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71208);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71210);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71218);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71220);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71228);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71230);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)&re::renderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>(void)::item);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)re::renderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>(void)::item);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)re::renderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>(void)::item);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71238);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71240);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71248);
    re::RenderGraphNodeRegistry::registerNode(v10, (uint64_t)off_26AF71250);
    uint64_t v11 = re::RenderGraphEmitterRegistry::m_instance;
    re::RenderGraphEmitterRegistry::registerEmitter(re::RenderGraphEmitterRegistry::m_instance, (uint64_t)off_26AF71258);
    re::RenderGraphEmitterRegistry::registerEmitter(v11, (uint64_t)off_26AF71260);
    re::RenderGraphEmitterRegistry::registerEmitter(v11, (uint64_t)&off_26AF71268);
    if ((v5 & 8) == 0)
    {
      signed int v12 = (re *)[MEMORY[0x263F08B88] isMainThread];
      if (v12) {
        re::initInputManagement(v12);
      }
      else {
        dispatch_async(MEMORY[0x263EF83A0], &__block_literal_global);
      }
    }
    unsigned int v13 = std::thread::hardware_concurrency();
    if ((v5 & 2) != 0)
    {
      LODWORD(v15) = 2;
    }
    else if ((v5 & 4) != 0)
    {
      LODWORD(v15) = 3;
    }
    else if ((v5 & 0x20) != 0)
    {
      LODWORD(v15) = 1;
    }
    else
    {
      LODWORD(v15) = 2;
    }
    if (a2 <= 1) {
      unsigned int v16 = 1;
    }
    else {
      unsigned int v16 = a2;
    }
    if (v5) {
      unsigned int v17 = 16;
    }
    else {
      unsigned int v17 = a3;
    }
    if (v5) {
      unsigned int v16 = 1;
    }
    if (v13 >= v16) {
      LODWORD(v18) = v16;
    }
    else {
      LODWORD(v18) = v13;
    }
    if ((int)v18 + 1 > v17) {
      unsigned int v19 = v18 + 1;
    }
    else {
      unsigned int v19 = v17;
    }
    char v20 = (v5 & 0x10) == 0;
    re::Defaults::intValue((re::Defaults *)"threading.threads", v14, (uint64_t)v30);
    if (v30[0]) {
      uint64_t v18 = v31;
    }
    else {
      uint64_t v18 = v18;
    }
    re::Defaults::intValue((re::Defaults *)"threading.fibers", v21, (uint64_t)v30);
    if (v30[0]) {
      unsigned int v19 = v31;
    }
    re::Defaults::intValue((re::Defaults *)"threading.fiberStackSize", v22, (uint64_t)v30);
    int v23 = v30[0];
    unint64_t v24 = v31;
    re::Defaults::intValue((re::Defaults *)"threading.jobSystem", v25, (uint64_t)v30);
    if (v30[0]) {
      unint64_t v15 = v31;
    }
    else {
      unint64_t v15 = v15;
    }
    if (v23) {
      unint64_t v27 = v24;
    }
    else {
      unint64_t v27 = 0x80000;
    }
    uint64_t v29 = re::globalAllocators(v28);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_26879E288);
}

void RESharedEngineContextRelease(_anonymous_namespace_::SharedEngineContext *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&dword_26879E288);
  if (!--qword_26879E280)
  {
    re::internal::destroyPersistent<re::JobService>((re *)"sharedJobServiceDeinit", 585, (void (***)(void))g_jobService);
    g_jobService = 0;
    if ((dword_26879E28C & 8) == 0)
    {
      unint64_t v1 = (re *)[MEMORY[0x263F08B88] isMainThread];
      if (v1) {
        re::deinitInputManagement(v1);
      }
      else {
        dispatch_async(MEMORY[0x263EF83A0], &__block_literal_global_100);
      }
    }
    re::internal::destroyPersistent<re::RenderGraphNodeRegistry>((re *)"deinit", 62, (re::RenderGraphNodeRegistry *)re::RenderGraphNodeRegistry::m_instance);
    re::RenderGraphNodeRegistry::m_instance = 0;
    re::internal::destroyPersistent<re::RenderGraphEmitterRegistry>((re *)"deinit", 42, (re::RenderGraphEmitterRegistry *)re::RenderGraphEmitterRegistry::m_instance);
    re::RenderGraphEmitterRegistry::m_instance = 0;
    re::internal::destroyPersistent<re::PhysicsFactory>((re *)"deinit", 23, (void (***)(void))re::PhysicsFactory::m_defaultFactory);
    re::PhysicsFactory::m_defaultFactory = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_26879E288);
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268796FB0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268796FB0))
  {
    _MergedGlobals_109 = re::introspect_RenderGraphCameraSetupNode(0);
    __cxa_guard_release(&qword_268796FB0);
  }
  return _MergedGlobals_109;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::typeName()
{
  return "CameraSetup";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C4F48;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C4F48;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C4F48;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphCameraSetupNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphCameraSetupNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 280, 8);
  long long v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *(void *)long long v6 = &unk_26E71ECD8;
  *((_WORD *)v6 + 128) = 0;
  *((void *)v6 + 33) = 0;
  *((void *)v6 + 34) = -1;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268796FC0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268796FC0))
  {
    qword_268796FB8 = re::introspect_RenderGraphMultiViewCameraSetupNode(0);
    __cxa_guard_release(&qword_268796FC0);
  }
  return qword_268796FB8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::typeName()
{
  return "MultiViewCameraSetup";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5010;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5010;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5010;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  long long v6 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 280, 8);
  uint64_t v7 = re::RenderGraphNode::RenderGraphNode(v6, v4);
  *((_WORD *)v7 + 128) = 0;
  *((void *)v7 + 33) = 0;
  *((void *)v7 + 34) = -1;
  *(void *)uint64_t v7 = &unk_26E71ED68;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewCameraSetupNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268796FD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268796FD0))
  {
    qword_268796FC8 = re::introspect_RenderGraphComputeNode(0);
    __cxa_guard_release(&qword_268796FD0);
  }
  return qword_268796FC8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::typeName()
{
  return "Compute";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C50D8;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C50D8;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C50D8;
}

re::RenderGraphComputeNodeBase *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphComputeNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphComputeNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphComputeNodeBase *re::RenderGraph::addNode<re::RenderGraphComputeNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphComputeNodeBase *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 480, 16);
  long long v6 = re::RenderGraphComputeNodeBase::RenderGraphComputeNodeBase(v5, a2);
  *(void *)long long v6 = &unk_26E718DE8;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268796FE0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268796FE0))
  {
    qword_268796FD8 = re::introspect_RenderGraphDebugNode(0);
    __cxa_guard_release(&qword_268796FE0);
  }
  return qword_268796FD8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::typeName()
{
  return "Debug";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C51A0;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C51A0;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C51A0;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphDebugNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphDebugNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 264, 8);
  long long v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *((_DWORD *)v6 + 64) = 1;
  *(void *)long long v6 = &unk_26E71FBC0;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268796FF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268796FF0))
  {
    qword_268796FE8 = re::introspect_RenderGraphDebugMaterialsNode(0);
    __cxa_guard_release(&qword_268796FF0);
  }
  return qword_268796FE8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::typeName()
{
  return "DebugMaterials";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5268;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5268;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5268;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphDebugMaterialsNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDebugMaterialsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphDebugMaterialsNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 264, 8);
  long long v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *((_DWORD *)v6 + 64) = 1;
  *(void *)long long v6 = &unk_26E6C6A10;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

void re::RenderGraphDebugMaterialsNode::~RenderGraphDebugMaterialsNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphMeshNodeBase::getPerFrameValidationCode(re::RenderGraphMeshNodeBase *this)
{
  return 0x118068043200229;
}

uint64_t re::RenderGraphNodeBase::getGraphBuildValidationCode(re::RenderGraphNodeBase *this)
{
  return 0;
}

uint64_t re::RenderGraphNode::bufferReads(re::RenderGraphNode *this)
{
  return *((void *)this + 16);
}

uint64_t re::RenderGraphNode::bufferWrites(re::RenderGraphNode *this)
{
  return *((void *)this + 21);
}

uint64_t re::RenderGraphNode::targetReads(re::RenderGraphNode *this)
{
  return *((void *)this + 26);
}

uint64_t re::RenderGraphNode::targetWrites(re::RenderGraphNode *this)
{
  return *((void *)this + 31);
}

uint64_t re::RenderGraphNode::typeInfo(re::RenderGraphNode *this)
{
  return re::introspect_RenderGraphNode(0);
}

void re::RenderGraphNode::~RenderGraphNode(id *this)
{
  *this = &unk_26E71A5C8;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(this + 27));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(this + 22));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(this + 17));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(this + 12));
  *this = &unk_26E6C6978;

  re::StringID::destroyString((re::StringID *)(this + 1));
}

{
  uint64_t vars8;

  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphNodeBase::getPerFrameValidationCode(re::RenderGraphNodeBase *this)
{
  return 0;
}

uint64_t re::RenderGraphNodeBase::bufferReads(re::RenderGraphNodeBase *this)
{
  return 0;
}

uint64_t re::RenderGraphNodeBase::bufferWrites(re::RenderGraphNodeBase *this)
{
  return 0;
}

uint64_t re::RenderGraphNodeBase::targetReads(re::RenderGraphNodeBase *this)
{
  return 0;
}

uint64_t re::RenderGraphNodeBase::targetWrites(re::RenderGraphNodeBase *this)
{
  return 0;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797000, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797000))
  {
    qword_268796FF8 = re::introspect_RenderGraphGenerateMipmapsNode(0);
    __cxa_guard_release(&qword_268797000);
  }
  return qword_268796FF8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::typeName()
{
  return "GenerateMipmaps";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5330;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5330;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5330;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphGenerateMipmapsNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphGenerateMipmapsNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphGenerateMipmapsNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 256, 8);
  long long v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *(void *)long long v6 = &unk_26E71F4E8;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797010, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797010))
  {
    qword_268797008 = re::introspect_RenderGraphMaterialReplaceNode(0);
    __cxa_guard_release(&qword_268797010);
  }
  return qword_268797008;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::typeName()
{
  return "MaterialReplace";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C53F8;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C53F8;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C53F8;
}

re::RenderGraphMaterialReplaceNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphMaterialReplaceNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMaterialReplaceNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphMaterialReplaceNode *re::RenderGraph::addNode<re::RenderGraphMaterialReplaceNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphMaterialReplaceNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2]
                                                                                                  + 32))(v4[2], 368, 8);
  uint64_t v9 = re::RenderGraphMaterialReplaceNode::RenderGraphMaterialReplaceNode(v5, a2);
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v9);
  uint64_t v6 = *((void *)a1 + 12);
  uint64_t v7 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v6;
  *((void *)v5 + 6) = v7;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797020, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797020))
  {
    qword_268797018 = re::introspect_RenderGraphMeshNode(0);
    __cxa_guard_release(&qword_268797020);
  }
  return qword_268797018;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::typeName()
{
  return "Mesh";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C54C0;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C54C0;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C54C0;
}

re::RenderGraphMeshNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphMeshNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphMeshNode *re::RenderGraph::addNode<re::RenderGraphMeshNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphMeshNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 344, 8);
  uint64_t v9 = re::RenderGraphMeshNode::RenderGraphMeshNode(v5, a2);
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v9);
  uint64_t v6 = *((void *)a1 + 12);
  uint64_t v7 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v6;
  *((void *)v5 + 6) = v7;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797030, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797030))
  {
    qword_268797028 = re::introspect_RenderGraphMultiPassMeshNode(0);
    __cxa_guard_release(&qword_268797030);
  }
  return qword_268797028;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::typeName()
{
  return "MultiPassMesh";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5588;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5588;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5588;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 440, 8);
  uint64_t v7 = re::RenderGraphNode::RenderGraphNode(v6, v4);
  *((_DWORD *)v7 + 64) = 1;
  *(void *)uint64_t v7 = &unk_26E71FA10;
  *(_OWORD *)((char *)v7 + 264) = 0u;
  *(_OWORD *)((char *)v7 + 280) = 0u;
  *((_DWORD *)v7 + 74) = 0;
  *(void *)((char *)v7 + 300) = 0x7FFFFFFFLL;
  *((void *)v7 + 40) = 0;
  *((void *)v7 + 41) = 0;
  *((void *)v7 + 39) = 0;
  *((_DWORD *)v7 + 84) = 0;
  *((void *)v7 + 53) = 0;
  *(_OWORD *)((char *)v7 + 344) = 0u;
  *(_OWORD *)((char *)v7 + 360) = 0u;
  *((_DWORD *)v7 + 94) = 0;
  *((_OWORD *)v7 + 24) = 0u;
  *((_OWORD *)v7 + 25) = 0u;
  *((_DWORD *)v7 + 104) = 0;
  *((unsigned char *)v7 + 432) = 2;
  *((unsigned char *)v7 + 437) = 0;
  *(_DWORD *)((char *)v7 + 433) = 0;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiPassMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797040, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797040))
  {
    qword_268797038 = re::introspect_RenderGraphMultiViewMeshNode(0);
    __cxa_guard_release(&qword_268797040);
  }
  return qword_268797038;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::typeName()
{
  return "MultiViewMesh";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5650;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5650;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5650;
}

re::RenderGraphMeshNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphMeshNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 344, 8);
  uint64_t v7 = re::RenderGraphMeshNode::RenderGraphMeshNode(v6, v4);
  *(void *)uint64_t v7 = &unk_26E71FAA0;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMultiViewMeshNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797050, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797050))
  {
    qword_268797048 = re::introspect_RenderGraphMRCNode(0);
    __cxa_guard_release(&qword_268797050);
  }
  return qword_268797048;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::typeName()
{
  return "MidRenderCompute";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5718;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5718;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5718;
}

re::RenderGraphMRCNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphMRCNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 448, 16);
  uint64_t v10 = re::RenderGraphMRCNode::RenderGraphMRCNode(v6, v4);
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v10);
  uint64_t v7 = a2[12];
  uint64_t v8 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v7;
  *((void *)v6 + 6) = v8;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMRCNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797060, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797060))
  {
    qword_268797058 = re::introspect_RenderGraphSynchronizeBufferNode(0);
    __cxa_guard_release(&qword_268797060);
  }
  return qword_268797058;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::typeName()
{
  return "SynchronizeBuffer";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C57E0;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C57E0;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C57E0;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 256, 8);
  uint64_t v7 = re::RenderGraphNode::RenderGraphNode(v6, v4);
  *(void *)uint64_t v7 = &unk_26E71F728;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797070, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797070))
  {
    qword_268797068 = re::introspect_RenderGraphSynchronizeTargetNode(0);
    __cxa_guard_release(&qword_268797070);
  }
  return qword_268797068;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::typeName()
{
  return "SynchronizeTarget";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C58A8;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C58A8;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C58A8;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphSynchronizeTargetNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphSynchronizeTargetNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphSynchronizeTargetNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 272, 8);
  uint64_t v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *(void *)uint64_t v6 = &unk_26E71F698;
  *((void *)v6 + 32) = 0;
  *((void *)v6 + 33) = 0;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797080, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797080))
  {
    qword_268797078 = re::introspect_RenderGraphFillBufferNode(0);
    __cxa_guard_release(&qword_268797080);
  }
  return qword_268797078;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::typeName()
{
  return "FillBuffer";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5970;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5970;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5970;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 264, 8);
  uint64_t v7 = re::RenderGraphNode::RenderGraphNode(v6, v4);
  *(void *)uint64_t v7 = &unk_26E71F7B8;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFillBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797090, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797090))
  {
    qword_268797088 = re::introspect_RenderGraphTargetCopyNode(0);
    __cxa_guard_release(&qword_268797090);
  }
  return qword_268797088;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::typeName()
{
  return "TargetCopy";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5A38;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5A38;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5A38;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphTargetCopyNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTargetCopyNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphTargetCopyNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 368, 8);
  uint64_t v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *(void *)uint64_t v6 = &unk_26E71F578;
  *((_OWORD *)v6 + 16) = 0u;
  *((_OWORD *)v6 + 17) = 0u;
  *((void *)v6 + 36) = 0;
  *((void *)v6 + 37) = -1;
  *((void *)v6 + 38) = -1;
  *((void *)v6 + 39) = -1;
  *((_OWORD *)v6 + 20) = 0u;
  *((_OWORD *)v6 + 21) = 0u;
  *(_OWORD *)((char *)v6 + 345) = 0u;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2687970A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2687970A0))
  {
    qword_268797098 = re::introspect_RenderGraphCopyEntityAttributeBufferNode(0);
    __cxa_guard_release(&qword_2687970A0);
  }
  return qword_268797098;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::typeName()
{
  return "CopyEntityAttributeBuffer";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5B00;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5B00;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5B00;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphCopyEntityAttributeBufferNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCopyEntityAttributeBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphCopyEntityAttributeBufferNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 280, 8);
  uint64_t v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *(void *)uint64_t v6 = &unk_26E71F608;
  *((void *)v6 + 32) = 0;
  *((void *)v6 + 33) = 0;
  *((void *)v6 + 34) = "";
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2687970B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2687970B0))
  {
    qword_2687970A8 = re::introspect_RenderGraphTextNode(0);
    __cxa_guard_release(&qword_2687970B0);
  }
  return qword_2687970A8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::typeName()
{
  return "Text";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5BC8;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5BC8;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5BC8;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphTextNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphTextNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphTextNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 264, 8);
  uint64_t v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *((_DWORD *)v6 + 64) = 1;
  *(void *)uint64_t v6 = &unk_26E71FB30;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::introspectionInfo()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::introspect<re::RenderGraphFullscreenNode>(void)::info = re::introspect_RenderGraphFullscreenNode(0);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[222];
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::typeName()
{
  return "Fullscreen";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5C90;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5C90;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5C90;
}

re::RenderGraphFullscreenNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphFullscreenNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphFullscreenNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphFullscreenNode *re::RenderGraph::addNode<re::RenderGraphFullscreenNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphFullscreenNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 456, 8);
  uint64_t v9 = re::RenderGraphFullscreenNode::RenderGraphFullscreenNode(v5, a2);
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v9);
  uint64_t v6 = *((void *)a1 + 12);
  uint64_t v7 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v6;
  *((void *)v5 + 6) = v7;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2687970C0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2687970C0))
  {
    qword_2687970B8 = re::introspect_RenderGraphResolveNode(0);
    __cxa_guard_release(&qword_2687970C0);
  }
  return qword_2687970B8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::typeName()
{
  return "Resolve";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5D58;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5D58;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5D58;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphResolveNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphResolveNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphResolveNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 256, 8);
  uint64_t v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *(void *)uint64_t v6 = &unk_26E71F0E8;
  *((unsigned char *)v6 + 66) = 1;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2687970D0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2687970D0))
  {
    qword_2687970C8 = re::introspect_RenderGraphProfilerOverlayNode(0);
    __cxa_guard_release(&qword_2687970D0);
  }
  return qword_2687970C8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::typeName()
{
  return "ProfilerOverlay";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5E20;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5E20;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5E20;
}

re::RenderGraphProfilerOverlayNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphProfilerOverlayNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphProfilerOverlayNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphProfilerOverlayNode *re::RenderGraph::addNode<re::RenderGraphProfilerOverlayNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphProfilerOverlayNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2]
                                                                                                  + 32))(v4[2], 416, 16);
  re::RenderGraphProfilerOverlayNode::RenderGraphProfilerOverlayNode(v5, a2);
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2687970E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2687970E0))
  {
    qword_2687970D8 = re::introspect_RenderGraphCommitCommandBufferNode(0);
    __cxa_guard_release(&qword_2687970E0);
  }
  return qword_2687970D8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::typeName()
{
  return "CommitCommandBuffer";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5EE8;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5EE8;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5EE8;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 256, 8);
  uint64_t v7 = re::RenderGraphNode::RenderGraphNode(v6, v4);
  *(void *)uint64_t v7 = &unk_26E71DF88;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphCommitCommandBufferNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_2687970F0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_2687970F0))
  {
    qword_2687970E8 = re::introspect_RenderGraphVFXNode(0);
    __cxa_guard_release(&qword_2687970F0);
  }
  return qword_2687970E8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::typeName()
{
  return "VFX";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C5FB0;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C5FB0;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C5FB0;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphVFXNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVFXNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphVFXNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 264, 8);
  uint64_t v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *(void *)uint64_t v6 = &unk_26E71B3D0;
  *((unsigned char *)v6 + 256) = 0;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797100, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797100))
  {
    qword_2687970F8 = re::introspect_RenderGraphDummyNigiriNode(0);
    __cxa_guard_release(&qword_268797100);
  }
  return qword_2687970F8;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::typeName()
{
  return "Nigiri";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C6078;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C6078;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6078;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 256, 8);
  uint64_t v7 = re::RenderGraphNode::RenderGraphNode(v6, v4);
  *(void *)uint64_t v7 = &unk_26E6C60E8;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphDummyNigiriNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraphNode::RenderGraphNode(re::RenderGraphNode *this, const char *a2)
{
  *(void *)this = &unk_26E6C6978;
  *((void *)this + 1) = 0;
  long long v4 = (re::RenderGraphNode *)((char *)this + 8);
  *((void *)this + 2) = "";
  *((void *)this + 7) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 16) = 1;
  *((void *)this + 9) = 0;
  *((unsigned char *)this + 80) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *(void *)this = &unk_26E71A5C8;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 31) = 0;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 40) = 0;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((_DWORD *)this + 50) = 0;
  *((_DWORD *)this + 60) = 0;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  return this;
}

void re::RenderGraphDummyNigiriNode::~RenderGraphDummyNigiriNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::introspectionInfo()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::introspect<re::RenderGraphVRRUnwarpNode>(void)::info = re::introspect_RenderGraphVRRUnwarpNode(0);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[228];
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::typeName()
{
  return "VRRUnwarp";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C68F8;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C68F8;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C68F8;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphVRRUnwarpNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphVRRUnwarpNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphVRRUnwarpNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 336, 8);
  uint64_t v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *(void *)uint64_t v6 = &unk_26E71B328;
  *((void *)v6 + 32) = 0;
  *((void *)v6 + 33) = -1;
  *((void *)v6 + 34) = 0;
  *((void *)v6 + 35) = -1;
  *((void *)v6 + 36) = 0;
  *((void *)v6 + 37) = -1;
  *((unsigned char *)v6 + 67) = 0;
  *((_OWORD *)v6 + 19) = 0u;
  *((_OWORD *)v6 + 20) = 0u;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::introspectionInfo()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::introspect<re::RenderGraphMPSImageAreaMaxNode>(void)::info = re::introspect_RenderGraphMPSImageAreaMaxNode(0);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[224];
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::typeName()
{
  return "RenderGraphMPSImageAreaMax";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C6768;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C6768;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6768;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphMPSImageAreaMaxNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageAreaMaxNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphMPSImageAreaMaxNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 272, 8);
  uint64_t v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *(void *)uint64_t v6 = &unk_26E71E030;
  *((unsigned char *)v6 + 260) = 0;
  *((void *)v6 + 33) = 0;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::introspectionInfo()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::introspect<re::RenderGraphMPSImageGaussianBlurNode>(void)::info = re::introspect_RenderGraphMPSImageGaussianBlurNode(0);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[226];
}

uint64_t re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::typeName()
{
  return "RenderGraphMPSImageGaussianBlur";
}

void re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C6830;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C6830;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6830;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(uint64_t a1, re *a2, const char **a3)
{
  return re::RenderGraph::addNode<re::RenderGraphMPSImageGaussianBlurNode>(a2, *a3);
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::RenderGraphMPSImageGaussianBlurNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

re::RenderGraphNode *re::RenderGraph::addNode<re::RenderGraphMPSImageGaussianBlurNode>(re *a1, const char *a2)
{
  long long v4 = re::globalAllocators(a1);
  int v5 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 280, 8);
  uint64_t v6 = re::RenderGraphNode::RenderGraphNode(v5, a2);
  *(void *)uint64_t v6 = &unk_26E718668;
  *((_WORD *)v6 + 130) = 0;
  *((void *)v6 + 33) = 0;
  *((void *)v6 + 34) = 0;
  uint64_t v10 = v6;
  re::DynamicArray<re::TransitionCondition *>::add(a1, &v10);
  uint64_t v7 = *((void *)a1 + 12);
  uint64_t v8 = *((void *)a1 + 13);
  *((void *)v5 + 3) = *((void *)a1 + 10);
  *((void *)v5 + 4) = v7;
  *((void *)v5 + 6) = v8;
  return v5;
}

uint64_t re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797110, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797110))
  {
    qword_268797108 = re::introspect_StencilPtInjectionNode(0);
    __cxa_guard_release(&qword_268797110);
  }
  return qword_268797108;
}

uint64_t re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::typeName()
{
  return "StencilPtInjection";
}

void re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C61E8;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C61E8;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C61E8;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 312, 8);
  uint64_t v7 = re::RenderGraphNode::RenderGraphNode(v6, v4);
  *(void *)uint64_t v7 = &unk_26E71EAE0;
  *((unsigned char *)v7 + 256) = 1;
  *((void *)v7 + 37) = 0;
  *((void *)v7 + 34) = 0;
  *((void *)v7 + 35) = 0;
  *((void *)v7 + 33) = 0;
  *((_DWORD *)v7 + 72) = 0;
  *((_WORD *)v7 + 152) = 0;
  *((unsigned char *)v7 + 306) = 1;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::StencilPtInjectionNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

uint64_t re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797120, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797120))
  {
    qword_268797118 = re::introspect_DummyEnvironmentNode(0);
    __cxa_guard_release(&qword_268797120);
  }
  return qword_268797118;
}

uint64_t re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::typeName()
{
  return "ImportEnvironment";
}

void re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C62B0;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C62B0;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C62B0;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 256, 8);
  uint64_t v7 = re::RenderGraphNode::RenderGraphNode(v6, v4);
  *(void *)uint64_t v7 = &unk_26E6C6320;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DummyEnvironmentNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

void re::DummyEnvironmentNode::~DummyEnvironmentNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797130, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797130))
  {
    qword_268797128 = re::introspect_BtStencilPrepassNode(0);
    __cxa_guard_release(&qword_268797130);
  }
  return qword_268797128;
}

uint64_t re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::typeName()
{
  return "BtStencilPrepass";
}

void re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C6420;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C6420;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6420;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 264, 8);
  uint64_t v7 = re::RenderGraphNode::RenderGraphNode(v6, v4);
  *(void *)uint64_t v7 = &unk_26E6C6490;
  *((unsigned char *)v7 + 256) = 0;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::BtStencilPrepassNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

void re::BtStencilPrepassNode::~BtStencilPrepassNode(id *this)
{
  re::RenderGraphNode::~RenderGraphNode(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797140, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797140))
  {
    qword_268797138 = re::introspect_DepthPatchNode(0);
    __cxa_guard_release(&qword_268797140);
  }
  return qword_268797138;
}

uint64_t re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::typeName()
{
  return "DepthPatch";
}

void re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void *a1@<X8>)
{
  *a1 = &unk_26E6C6590;
  a1[3] = a1;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::~__func()
{
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26E6C6590;
  return result;
}

void std::__function::__func<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6590;
}

re::RenderGraphNode *std::__function::__func<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::operator()(re *a1, void *a2, const char **a3)
{
  long long v4 = *a3;
  int v5 = re::globalAllocators(a1);
  uint64_t v6 = (re::RenderGraphNode *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 32))(v5[2], 288, 8);
  uint64_t v7 = re::RenderGraphNode::RenderGraphNode(v6, v4);
  *((_DWORD *)v7 + 64) = 1;
  *(void *)uint64_t v7 = &unk_26E71EF28;
  *((unsigned char *)v7 + 260) = 0;
  *((void *)v7 + 34) = 0;
  *((void *)v7 + 35) = 0;
  *((void *)v7 + 33) = 0;
  uint64_t v11 = v7;
  re::DynamicArray<re::TransitionCondition *>::add(a2, &v11);
  uint64_t v8 = a2[12];
  uint64_t v9 = a2[13];
  *((void *)v6 + 3) = a2[10];
  *((void *)v6 + 4) = v8;
  *((void *)v6 + 6) = v9;
  return v6;
}

uint64_t std::__function::__func<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1},std::allocator<re::RenderGraphNodeRegistryItem<re::DepthPatchNode>::makeCreateFunction(void)::{lambda(re::RenderGraph &,char const*)#1}>,re::RenderGraphNode & ()(re::RenderGraph &,char const*)>::target_type()
{
}

uint64_t re::RenderGraphEmitterRegistryItem<re::RenderGraphSimpleForwardEmitter>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797150, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797150))
  {
    qword_268797148 = re::introspect_RenderGraphSimpleForwardEmitter(0);
    __cxa_guard_release(&qword_268797150);
  }
  return qword_268797148;
}

uint64_t re::RenderGraphEmitterRegistryItem<re::RenderGraphSimpleForwardEmitter>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphEmitterRegistryItem<re::RenderGraphSimpleForwardEmitter>::typeName()
{
  return "SimpleForwardEmitter";
}

uint64_t re::RenderGraphEmitterRegistryItem<re::RenderGraphAREmitter>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797160, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797160))
  {
    qword_268797158 = re::introspect_RenderGraphAREmitter(0);
    __cxa_guard_release(&qword_268797160);
  }
  return qword_268797158;
}

uint64_t re::RenderGraphEmitterRegistryItem<re::RenderGraphAREmitter>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphEmitterRegistryItem<re::RenderGraphAREmitter>::typeName()
{
  return "AREmitter";
}

uint64_t re::RenderGraphEmitterRegistryItem<re::RenderGraphSelectionEmitter>::introspectionInfo()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_268797170, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_268797170))
  {
    qword_268797168 = re::introspect_RenderGraphSelectionEmitter(0);
    __cxa_guard_release(&qword_268797170);
  }
  return qword_268797168;
}

uint64_t re::RenderGraphEmitterRegistryItem<re::RenderGraphSelectionEmitter>::dataOffset()
{
  return 0;
}

const char *re::RenderGraphEmitterRegistryItem<re::RenderGraphSelectionEmitter>::typeName()
{
  return "SelectionEmitter";
}

uint64_t *re::appLogObjects(re *this)
{
  {
    re::appLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "App");
  }
  return &re::appLogObjects(void)::logObjects;
}

void REStartup(_anonymous_namespace_::SharedEngineContext *a1, uint64_t a2)
{
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) REStartup called too many times", "false", "REStartup", 25);
    _os_crash();
    __break(1u);
  }
  else
  {
    if (v2 <= 0)
    {
      std::thread::hardware_concurrency();
      long long v4 = (re *)std::thread::hardware_concurrency();
      re::initGlobalAllocators(v4);
      inited = re::ecs2::initECSCore(v5);
      uint64_t v7 = (_anonymous_namespace_::SharedEngineContext *)re::ecs2::initECSComponents(inited);
    }
  }
}

void REStartupPrivate(re *a1, uint64_t a2)
{
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) REStartup called too many times", "false", "REStartupPrivate", 54);
    _os_crash();
    __break(1u);
  }
  else
  {
    if (v2 <= 0)
    {
      int v3 = a2;
      unsigned int v4 = a1;
      re::initGlobalAllocators(a1);
      inited = re::ecs2::initECSCore(v5);
      uint64_t v7 = (_anonymous_namespace_::SharedEngineContext *)re::ecs2::initECSComponents(inited);
    }
  }
}

void REShutdown(_anonymous_namespace_::SharedEngineContext *a1, uint64_t a2)
{
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) REShutdown called before REStartup", "false", "REShutdown", 75);
    _os_crash();
    __break(1u);
  }
  else
  {
    if (v2 == 1)
    {
      RESharedEngineContextRelease(a1);
      re::ecs2::deinitECSComponents(v3);
      re::ecs2::deinitECSCore(v4);
      re::deinitGlobalAllocators(v5);
    }
  }
}

void *re::FrameAnalysisProfilerProcessor::process(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = *(void **)a4;
  int v5 = *(void **)(a4 + 8);
  if (*(void **)a4 != v5)
  {
    uint64_t v6 = result[2];
    uint64_t v7 = result[3];
    uint64_t v8 = result[4];
    do
    {
      uint64_t v9 = (void *)*v4++;
      v6 += v9[266];
      v7 += v9[250];
      v8 += v9[242];
    }
    while (v4 != v5);
    result[2] = v6;
    result[3] = v7;
    result[4] = v8;
  }
  return result;
}

void re::FrameAnalysisManager::init(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 128) = 1;
  *(unsigned char *)(a1 + 130) = 0;
  *(_WORD *)(a1 + 132) = 0;
  int v3 = (const void *)re::ServiceLocator::serviceOrNull<re::DrawableQueueService>(a2);
  if (v3) {
  unsigned int v4 = (_anonymous_namespace_ *)re::ServiceLocator::serviceOrNull<re::VideoService>(*(void *)(a1 + 24));
  }
  if (v4) {
    *(void *)(a1 + 48) = v4;
  }
  int v5 = (re *)re::ServiceLocator::serviceOrNull<re::EventBus>(*(void *)(a1 + 24));
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = re::globalAllocators(v5)[2];
    uint64_t v23 = v7;
    uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v7 + 32))(v7, 32, 0);
    void *v8 = &unk_26E6C6C00;
    v8[1] = a1;
    void v8[2] = re::FrameAnalysisManager::processSceneDidAdd;
    v8[3] = 0;
    unint64_t v24 = v8;
    uint64_t v26 = v7;
    uint64_t v27 = 0;
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v25, (uint64_t)v22);
    uint64_t v9 = re::EventBus::subscribe<re::ecs2::Scene,RESceneDidAddEvent>(v6, 0, (uint64_t)v25, 0, 0);
    uint64_t v11 = v10;
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)v25);
    signed int v12 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(a1 + 136);
    *signed int v12 = v9;
    v12[1] = v11;
    unsigned int v13 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)v22);
    uint64_t v20 = re::globalAllocators(v13)[2];
    long long v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v20 + 32))(v20, 32, 0);
    *long long v14 = &unk_26E6C6C58;
    v14[1] = a1;
    void v14[2] = re::FrameAnalysisManager::processSceneWillRemove;
    v14[3] = 0;
    uint64_t v21 = v14;
    uint64_t v15 = re::EventBus::subscribe<re::ecs2::Scene,RESceneWillRemoveEvent>(v6, (uint64_t)v19, 0, 0);
    uint64_t v17 = v16;
    uint64_t v18 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(a1 + 136);
    void *v18 = v15;
    v18[1] = v17;
    int v5 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::destroyCallable((uint64_t)v19);
  }
}

uint64_t re::ServiceLocator::serviceOrNull<re::DrawableQueueService>(uint64_t a1)
{
  {
    re::introspect<re::DrawableQueueService>(void)::info = re::introspect_DrawableQueueService(0);
  }
  uint64_t v2 = re::introspect<re::DrawableQueueService>(void)::info;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

uint64_t re::ServiceLocator::serviceOrNull<re::VideoService>(uint64_t a1)
{
  {
    re::introspect<re::VideoService>(void)::info = re::introspect_VideoService(0);
  }
  uint64_t v2 = re::introspect<re::VideoService>(void)::info;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

uint64_t *re::BucketArray<RESubscriptionHandle,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<RESubscriptionHandle,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::FrameAnalysisManager::processSceneDidAdd(uint64_t a1, uint64_t a2)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  uint64_t v36 = a2;
  uint64_t v35 = 0;
  long long v32 = 0u;
  long long v33 = 1uLL;
  long long v34 = 0uLL;
  uint64_t v3 = re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::addNew(a1 + 192, &v36, (uint64_t)&v32);
  re::BucketArray<RESubscriptionHandle,8ul>::deinit((uint64_t)&v32);
  unsigned int v4 = (_anonymous_namespace_ *)v32;
  if ((void)v32 && (v33 & 1) == 0) {
    unsigned int v4 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v32 + 40))();
  }
  uint64_t v6 = *(re::EventBus **)(v36 + 288);
  if (v6)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)_MergedGlobals_29, memory_order_acquire) & 1) == 0)
    {
      int v5 = (uint64_t *)__cxa_guard_acquire(_MergedGlobals_29);
      if (v5)
      {
        qword_26AF74A30 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::AccessibilityComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74A38 = re::ecs2::ComponentImpl<re::ecs2::AcousticMeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74A40 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::AmbientAudioComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74A48 = re::ecs2::ComponentImpl<re::ecs2::AnimationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74A50 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::AnimationLibraryComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74A58 = re::ecs2::ComponentImpl<re::ecs2::SpatialSceneClassificationComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        qword_26AF74A60 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::AudioAnimationComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74A68 = re::ecs2::ComponentImpl<re::ecs2::AudioDebugComponent,(re::ecs2::ComponentTypeBase::Flags)1>::s_componentType;
        qword_26AF74A70 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::AudioGeneratorComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74A78 = re::ecs2::ComponentImpl<re::ecs2::AudioMixGroupsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74A80 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::AudioMixerComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74A88 = re::ecs2::ComponentImpl<re::ecs2::ReverbComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74A90 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::AudioPlayerComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        unk_26AF74A98 = re::ecs2::ComponentImpl<re::ecs2::AudioSessionComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        qword_26AF74AA0 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::AudioTransientComponent,(re::ecs2::ComponentTypeBase::Flags)1>::s_componentType;
        unk_26AF74AA8 = re::ecs2::ComponentImpl<re::ecs2::BodyTrackingComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74AB0 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::ChannelAudioComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74AB8 = re::ecs2::ComponentImpl<re::ecs2::CharacterControllerComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74AC0 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::CharacterControllerStateComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74AC8 = re::ecs2::ComponentImpl<re::ecs2::ColliderComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74AD0 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::ConstraintListComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74AD8 = re::ecs2::ComponentImpl<re::ecs2::DeferredActivationComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        qword_26AF74AE0 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::ListenerComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74AE8 = re::ecs2::ComponentImpl<re::ecs2::LoadTraceComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        qword_26AF74AF0 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::MotionStateComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74AF8 = re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        qword_26AF74B00 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74B08 = re::ecs2::ComponentImpl<re::ecs2::PhysicsConstraintsComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74B10 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::PhysicsOriginComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        unk_26AF74B18 = re::ecs2::ComponentImpl<re::ecs2::PinComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74B20 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::PrimitiveBoxComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        unk_26AF74B28 = re::ecs2::ComponentImpl<re::ecs2::PrimitiveBoxWithRoundedCornersComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        qword_26AF74B30 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::PrimitiveCapsuleComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        unk_26AF74B38 = re::ecs2::ComponentImpl<re::ecs2::PrimitiveConeComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        qword_26AF74B40 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::PrimitiveCylinderComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        unk_26AF74B48 = re::ecs2::ComponentImpl<re::ecs2::PrimitivePlaneComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        qword_26AF74B50 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::PrimitivePyramidComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        unk_26AF74B58 = re::ecs2::ComponentImpl<re::ecs2::PrimitiveSphereComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        qword_26AF74B60 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::PrimitiveTetrahedronComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        unk_26AF74B68 = re::ecs2::ComponentImpl<re::ecs2::PrimitiveTubeComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        qword_26AF74B70 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::RayCastComponent,(re::ecs2::ComponentTypeBase::Flags)1>::s_componentType;
        unk_26AF74B78 = re::ecs2::ComponentImpl<re::ecs2::RayCastResultComponent,(re::ecs2::ComponentTypeBase::Flags)1>::s_componentType;
        qword_26AF74B80 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::RigComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74B88 = re::ecs2::ComponentImpl<re::ecs2::RigidBodyComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74B90 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::SpatialAudioComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        unk_26AF74B98 = re::ecs2::ComponentImpl<re::ecs2::StateMachineComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType;
        qword_26AF74BA0 = (uint64_t)re::ecs2::ComponentImpl<re::ecs2::TimebaseComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
        __cxa_guard_release(_MergedGlobals_29);
      }
    }
    uint64_t v7 = re::ecs2::ComponentTypeRegistry::instance((re::ecs2::ComponentTypeRegistry *)v5);
    uint64_t v8 = *((void *)v7 + 3);
    if (v8)
    {
      uint64_t v9 = (uint64_t)v7;
      for (unint64_t i = 0; i != v8; ++i)
      {
        uint64_t v11 = re::ecs2::ComponentTypeRegistry::operator[](v9, i);
        signed int v12 = (re *)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 8))(v11);
        if ((v12 & 1) == 0)
        {
          uint64_t v13 = 1u;
          while (_MergedGlobals_29[v13] != v11)
          {
            if (++v13 == 48)
            {
              uint64_t v44 = re::globalAllocators(v12)[2];
              uint64_t v45 = 0;
              long long v14 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v44 + 32))(v44, 32, 0);
              *long long v14 = &unk_26E6C6CB0;
              v14[1] = a1;
              void v14[2] = re::FrameAnalysisManager::processFrameComponentModified<REComponentDidChangeEvent>;
              v14[3] = 0;
              uint64_t v45 = v14;
              uint64_t v15 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidChangeEvent>(v6, (uint64_t)v43, v11, 0);
              uint64_t v17 = v16;
              uint64_t v18 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(v3);
              void *v18 = v15;
              v18[1] = v17;
              unsigned int v19 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable((uint64_t)v43);
              uint64_t v41 = re::globalAllocators(v19)[2];
              double v42 = 0;
              uint64_t v20 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v41 + 32))(v41, 32, 0);
              *uint64_t v20 = &unk_26E6C6D18;
              v20[1] = a1;
              void v20[2] = re::FrameAnalysisManager::processFrameComponentModified<REComponentDidActivateEvent>;
              v20[3] = 0;
              double v42 = v20;
              uint64_t v21 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidActivateEvent>(v6, (uint64_t)v40, v11, 0);
              uint64_t v23 = v22;
              unint64_t v24 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(v3);
              *unint64_t v24 = v21;
              v24[1] = v23;
              unint64_t v25 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable((uint64_t)v40);
              uint64_t v38 = re::globalAllocators(v25)[2];
              unint64_t v39 = 0;
              uint64_t v26 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v38 + 32))(v38, 32, 0);
              void *v26 = &unk_26E6C6D70;
              v26[1] = a1;
              v26[2] = re::FrameAnalysisManager::processFrameComponentModified<REComponentWillDeactivateEvent>;
              v26[3] = 0;
              unint64_t v39 = v26;
              uint64_t v27 = re::EventBus::subscribe<re::ecs2::Entity,REComponentWillDeactivateEvent>(v6, (uint64_t)v37, v11, 0);
              uint64_t v29 = v28;
              uint64_t v30 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(v3);
              *uint64_t v30 = v27;
              v30[1] = v29;
              re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable((uint64_t)v37);
              break;
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t re::EventBus::subscribe<re::ecs2::Scene,RESceneWillRemoveEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, char a4)
{
  v9[5] = *MEMORY[0x263EF8340];
  v9[3] = *(void *)(a2 + 24);
  v9[4] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::operator=<24ul>((uint64_t)v9, a2);
  uint64_t v7 = re::EventBus::subscribe<re::ecs2::Scene,RESceneWillRemoveEvent>(a1, 0, (uint64_t)v9, a3, a4);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::destroyCallable((uint64_t)v9);
  return v7;
}

uint64_t re::FrameAnalysisManager::processSceneWillRemove(uint64_t a1, unint64_t a2)
{
  unint64_t v14 = a2;
  uint64_t v3 = *(void *)(a2 + 288);
  if (v3)
  {
    LODWORD(v4) = 0x7FFFFFFF;
    if (*(void *)(a1 + 192))
    {
      unint64_t v5 = 0x94D049BB133111EBLL
         * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
      uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 200) + 4 * ((v5 ^ (v5 >> 31)) % *(unsigned int *)(a1 + 216)));
      if (v6 != 0x7FFFFFFF)
      {
        uint64_t v7 = *(void *)(a1 + 208);
        if (*(void *)(v7 + 80 * v6 + 16) == a2)
        {
          LODWORD(v4) = v6;
        }
        else
        {
          uint64_t v4 = v6;
          while (1)
          {
            LODWORD(v4) = *(_DWORD *)(v7 + 80 * v4 + 8) & 0x7FFFFFFF;
            if (v4 == 0x7FFFFFFF) {
              break;
            }
            if (*(void *)(v7 + 80 * v4 + 16) == a2) {
              goto LABEL_11;
            }
          }
          LODWORD(v4) = 0x7FFFFFFF;
        }
      }
    }
LABEL_11:
    uint64_t v8 = *(void *)(a1 + 208) + 80 * v4;
    uint64_t v9 = *(void *)(v8 + 64);
    if (v9)
    {
      unint64_t v10 = 0;
      uint64_t v11 = v8 + 24;
      do
      {
        uint64_t v12 = re::BucketArray<RESubscriptionHandle,8ul>::operator[](v11, v10);
        re::EventBus::unsubscribe(v3, *(void *)v12, *(void *)(v12 + 8));
        ++v10;
      }
      while (v9 != v10);
    }
  }
  re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::remove(a1 + 192, (uint64_t *)&v14);
  return 0;
}

void re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  unint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    uint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      unint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  uint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 80 * v10, 16);
  if (v12)
  {
    unint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

double re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 80;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::BucketArray<RESubscriptionHandle,8ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
      re::BucketArray<RESubscriptionHandle,8ul>::operator[](a1, i);
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::FrameAnalysisManager::beginNewFrame(void *this)
{
  this[15] = this[14];
  *((_WORD *)this + 64) = 1;
  *((unsigned char *)this + 130) = 0;
  *((_WORD *)this + 66) = 0;
  this[48] = 0;
  ++*((_DWORD *)this + 98);
  unint64_t v1 = (void *)this[4];
  if (v1)
  {
    uint64_t v2 = this;
    uint64_t v3 = this + 46;
    unint64_t v4 = this[30];
    unint64_t v5 = v1[2] - this[43];
    unint64_t v6 = v1[3] - this[44];
    unint64_t v7 = v1[4] - this[45];
    this[30] = v4 + 1;
    unint64_t v8 = (unint64_t)&this[v4 % 6 + 30];
    *(void *)(v8 + 8) = v5;
    *(void *)(v8 + 56) = v6 + v5 + v7;
    uint64_t v9 = v1[4];
    *(_OWORD *)(this + 43) = *((_OWORD *)v1 + 1);
    this[45] = v9;
    if (v4 + 1 < 6) {
      unint64_t v10 = v4 + 1;
    }
    else {
      unint64_t v10 = 6;
    }
    if (v10)
    {
      unint64_t v11 = 0;
      unint64_t v12 = 0;
      uint64_t v13 = this + 37;
      unint64_t v14 = v10;
      do
      {
        v12 += *(v13 - 6);
        uint64_t v15 = *v13++;
        v11 += v15;
        --v14;
      }
      while (v14);
    }
    else
    {
      unint64_t v12 = 0;
      unint64_t v11 = 0;
    }
    float v16 = (float)v6;
    float v17 = (float)v7 + (float)v7;
    if ((float)((float)(v11 / v10) * 0.7) >= (float)(v12 / v10))
    {
      if (v17 >= v16) {
        return this;
      }
      LOBYTE(__len) = 1;
      p_leunint64_t n = &__len;
    }
    else
    {
      uint64_t v18 = re::ServiceLocator::serviceOrNull<re::ecs2::ThrottleService>(this[3]);
      if ((!v18 || (*(unsigned int (**)(uint64_t))(*(void *)v18 + 120))(v18))
        && (uint64_t v20 = re::ServiceLocator::serviceOrNull<re::ecs2::ECSService>(v2[3])) != 0
        && (v21 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 104))(v20), (uint64_t v22 = *(void *)(v21 + 24)) != 0))
      {
        uint64_t v23 = *(void *)(v21 + 40);
        unint64_t v24 = *((unsigned __int16 *)re::ecs2::ComponentImpl<re::ecs2::SkeletalPoseComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
              + 8);
        uint64_t v25 = 8 * v22;
        while (1)
        {
          if (*(void *)(*(void *)v23 + 224) > v24)
          {
            uint64_t v26 = *(void *)(*(void *)(*(void *)v23 + 240) + 8 * v24);
            if (v26)
            {
              if (*(void *)(v26 + 24)) {
                break;
              }
            }
          }
          v23 += 8;
          v25 -= 8;
          if (!v25) {
            goto LABEL_20;
          }
        }
        re::DynamicInlineArray<REFrameAnalysisBottleneck,2ul>::ensureCapacity(0, v19);
        v35[0] = 3;
        int v28 = 2;
        unint64_t v27 = 1;
      }
      else
      {
LABEL_20:
        unint64_t v27 = 0;
        int v28 = 1;
      }
      re::DynamicInlineArray<REFrameAnalysisBottleneck,2ul>::ensureCapacity(v27, v19);
      *(unsigned char *)((unint64_t)v35 | v27) = 2;
      size_t v29 = v27 + 1;
      __leunint64_t n = v27 + 1;
      int v34 = v28;
      if (v17 >= v16)
      {
        unint64_t v30 = v2[48];
        return re::DynamicArray<REFrameAnalysisBottleneck>::copy(v3, v30, v35, v29);
      }
      if (v5 <= v6)
      {
        char v32 = 1;
        re::DynamicArray<BOOL>::add(v3, &v32);
        unint64_t v30 = v2[48];
        size_t v29 = __len;
        return re::DynamicArray<REFrameAnalysisBottleneck>::copy(v3, v30, v35, v29);
      }
      re::DynamicArray<REFrameAnalysisBottleneck>::copy(v3, v2[48], v35, v29);
      char v32 = 1;
      p_leunint64_t n = (size_t *)&v32;
    }
    return re::DynamicArray<BOOL>::add(v3, p_len);
  }
  return this;
}

uint64_t re::ServiceLocator::serviceOrNull<re::ecs2::ThrottleService>(uint64_t a1)
{
  {
    re::introspect<re::ecs2::ThrottleService>(void)::info = re::ecs2::introspect_ThrottleService(0);
  }
  uint64_t v2 = re::introspect<re::ecs2::ThrottleService>(void)::info;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

void *re::DynamicArray<REFrameAnalysisBottleneck>::copy(void *this, unint64_t a2, char *__src, size_t __len)
{
  if (!__len) {
    return this;
  }
  unint64_t v5 = a2;
  unint64_t v6 = this;
  size_t v7 = this[2];
  if (v7 + 1 <= a2)
  {
    uint64_t v12 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v13) = 136315906;
    *(void *)((char *)&v13 + 4) = "copy";
    WORD6(v13) = 1024;
    HIWORD(v13) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, v5, v4, v12, v13);
    _os_crash();
    __break(1u);
  }
  size_t v4 = __len;
  size_t v8 = a2 + __len;
  if (__CFADD__(a2, __len)) {
    goto LABEL_12;
  }
  if (v7 >= v8)
  {
    this = memmove((void *)(this[4] + a2), __src, __len);
  }
  else
  {
    re::DynamicArray<BOOL>::growCapacity(this, a2 + __len);
    uint64_t v10 = v6[2];
    unint64_t v11 = &__src[v10 - v5];
    if (v10 != v5)
    {
      memmove((void *)(v6[4] + v5), __src, v10 - v5);
      unint64_t v5 = v6[2];
    }
    this = memcpy((void *)(v6[4] + v5), v11, &__src[v4] - v11);
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

uint64_t re::FrameAnalysisManager::afterFrameUpdate(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 40);
  if (v1) {
    *(unsigned char *)(this + 131) = *(unsigned char *)(v1 + 72);
  }
  uint64_t v2 = *(void *)(this + 48);
  if (v2) {
    *(_WORD *)(this + 129) = *(_WORD *)(v2 + 144);
  }
  return this;
}

uint64_t re::FrameAnalysisManager::hierarchyHasComponentThatRenders(re::FrameAnalysisManager *this, re::ecs2::Entity *a2, uint64_t a3, uint64_t a4, BOOL *a5)
{
  *(_WORD *)unsigned int v31 = 0;
  re::ecs2::RenderOptionsComponent::mixVisibility(this, (const re::ecs2::Entity *)1, &v31[1], v31, a5);
  if (!v31[1]) {
    return 0;
  }
  uint64_t v7 = *((unsigned __int16 *)this + 41);
  if (*((_WORD *)this + 41))
  {
    size_t v8 = (const __int16 *)((char *)re::ecs2::ComponentImpl<re::ecs2::MeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                         + 16);
    int16x8_t v9 = vld1q_dup_s16(v8);
    uint64_t v10 = (int16x8_t *)*((void *)this + 11);
    int v11 = 1;
    uint64_t v12 = v10;
    uint64_t v13 = *((unsigned __int16 *)this + 41);
    while (1)
    {
      uint16x8_t v14 = (uint16x8_t)vandq_s8((int8x16_t)vceqq_s16(v9, *v12), (int8x16_t)xmmword_23436BBD0);
      v14.i16[0] = vmaxvq_u16(v14);
      if (v14.i32[0]) {
        break;
      }
      v11 -= 8;
      ++v12;
      if (!--v13) {
        goto LABEL_8;
      }
    }
    if (v14.u16[0] - v11 < *((unsigned __int16 *)this + 40)) {
      return 1;
    }
LABEL_8:
    uint64_t v15 = (const __int16 *)((char *)re::ecs2::ComponentImpl<re::ecs2::VFXSceneComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                          + 16);
    int16x8_t v16 = vld1q_dup_s16(v15);
    int v17 = 1;
    uint64_t v18 = (int16x8_t *)*((void *)this + 11);
    uint64_t v19 = *((unsigned __int16 *)this + 41);
    while (1)
    {
      uint16x8_t v20 = (uint16x8_t)vandq_s8((int8x16_t)vceqq_s16(v16, *v18), (int8x16_t)xmmword_23436BBD0);
      v20.i16[0] = vmaxvq_u16(v20);
      if (v20.i32[0]) {
        break;
      }
      v17 -= 8;
      ++v18;
      if (!--v19) {
        goto LABEL_13;
      }
    }
    if (v20.u16[0] - v17 < *((unsigned __int16 *)this + 40)) {
      return 1;
    }
LABEL_13:
    uint64_t v21 = (const __int16 *)((char *)re::ecs2::ComponentImpl<re::ecs2::VFXEmitterComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType
                          + 16);
    int16x8_t v22 = vld1q_dup_s16(v21);
    int v23 = 1;
    while (1)
    {
      uint16x8_t v24 = (uint16x8_t)vandq_s8((int8x16_t)vceqq_s16(v22, *v10), (int8x16_t)xmmword_23436BBD0);
      v24.i16[0] = vmaxvq_u16(v24);
      if (v24.i32[0]) {
        break;
      }
      v23 -= 8;
      ++v10;
      if (!--v7) {
        goto LABEL_19;
      }
    }
    if (v24.u16[0] - v23 < *((unsigned __int16 *)this + 40)) {
      return 1;
    }
  }
LABEL_19:
  if (!v31[0]) {
    return 0;
  }
  uint64_t v26 = *((void *)this + 41);
  if (!v26) {
    return 0;
  }
  unint64_t v27 = (re::FrameAnalysisManager **)*((void *)this + 43);
  uint64_t v28 = 8 * v26 - 8;
  do
  {
    size_t v29 = *v27++;
    uint64_t result = re::FrameAnalysisManager::hierarchyHasComponentThatRenders(v29, v6);
    if (result) {
      break;
    }
    uint64_t v30 = v28;
    v28 -= 8;
  }
  while (v30);
  return result;
}

uint64_t re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::addNew(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 80 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 80 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 80 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 80 * v10;
  return v12 + 24;
}

uint64_t re::ecs2::ComponentTypeRegistry::operator[](uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 24) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 40) + 8 * a2);
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,REComponentDidChangeEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, char a4)
{
  v9[5] = *MEMORY[0x263EF8340];
  v9[3] = *(void *)(a2 + 24);
  v9[4] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator=<24ul>((uint64_t)v9, a2);
  uint64_t v7 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidChangeEvent>(a1, 0, (uint64_t)v9, a3, a4);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable((uint64_t)v9);
  return v7;
}

uint64_t re::FrameAnalysisManager::processFrameComponentModified<REComponentDidChangeEvent>(void *a1, re::FrameAnalysisManager *a2)
{
  unint64_t v8 = a2;
  if (!re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains((uint64_t)(a1 + 7), (uint64_t *)&v8))
  {
    if (a1[15] == a1[14]
      && re::FrameAnalysisManager::hierarchyHasComponentThatRenders(v8, v3, v4, v5, v6))
    {
      ++a1[14];
    }
    if (a1[13])
    {
      re::FrameAnalysisManager::hierarchyHasComponentThatRenders(v8, v3, v4, v5, v6);
      (*(void (**)(void))(a1[13] + 16))();
    }
  }
  return 0;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,REComponentDidActivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, char a4)
{
  v9[5] = *MEMORY[0x263EF8340];
  v9[3] = *(void *)(a2 + 24);
  v9[4] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator=<24ul>((uint64_t)v9, a2);
  uint64_t v7 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidActivateEvent>(a1, 0, (uint64_t)v9, a3, a4);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable((uint64_t)v9);
  return v7;
}

uint64_t re::FrameAnalysisManager::processFrameComponentModified<REComponentDidActivateEvent>(void *a1, re::FrameAnalysisManager *a2)
{
  unint64_t v8 = a2;
  if (!re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains((uint64_t)(a1 + 7), (uint64_t *)&v8))
  {
    if (a1[15] == a1[14]
      && re::FrameAnalysisManager::hierarchyHasComponentThatRenders(v8, v3, v4, v5, v6))
    {
      ++a1[14];
    }
    if (a1[13])
    {
      re::FrameAnalysisManager::hierarchyHasComponentThatRenders(v8, v3, v4, v5, v6);
      (*(void (**)(void))(a1[13] + 16))();
    }
  }
  return 0;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, char a4)
{
  v9[5] = *MEMORY[0x263EF8340];
  v9[3] = *(void *)(a2 + 24);
  v9[4] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)v9, a2);
  uint64_t v7 = re::EventBus::subscribe<re::ecs2::Entity,REComponentWillDeactivateEvent>(a1, 0, (uint64_t)v9, a3, a4);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable((uint64_t)v9);
  return v7;
}

uint64_t re::FrameAnalysisManager::processFrameComponentModified<REComponentWillDeactivateEvent>(void *a1, re::FrameAnalysisManager *a2)
{
  unint64_t v8 = a2;
  if (!re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains((uint64_t)(a1 + 7), (uint64_t *)&v8))
  {
    if (a1[15] == a1[14]
      && re::FrameAnalysisManager::hierarchyHasComponentThatRenders(v8, v3, v4, v5, v6))
    {
      ++a1[14];
    }
    if (a1[13])
    {
      re::FrameAnalysisManager::hierarchyHasComponentThatRenders(v8, v3, v4, v5, v6);
      (*(void (**)(void))(a1[13] + 16))();
    }
  }
  return 0;
}

uint64_t re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (*(void *)(v9 + 80 * v7 + 16) != v3)
  {
    while (1)
    {
      unsigned int v10 = v7;
      int v11 = *(_DWORD *)(v9 + 80 * v7 + 8);
      uint64_t v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF) {
        return 0;
      }
      if (*(void *)(v9 + 80 * v7 + 16) == v3)
      {
        *(_DWORD *)(v9 + 80 * v10 + 8) = *(_DWORD *)(v9 + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 80 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 80 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::EntryWithHash::free(*(void *)(a1 + 16) + 80 * v7);
  int v12 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(*(void *)(a1 + 16) + 80 * v7 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 80 * v7 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v12 + 1;
  return 1;
}

void *re::FrameAnalysisManager::modifiedRenderFrameDataSetDebugBlock(uint64_t a1, void *aBlock)
{
  unint64_t v4 = *(const void **)(a1 + 104);
  if (v4) {
    _Block_release(v4);
  }
  if (aBlock) {
    uint64_t result = _Block_copy(aBlock);
  }
  else {
    uint64_t result = 0;
  }
  *(void *)(a1 + 104) = result;
  return result;
}

void re::FrameAnalysisManager::~FrameAnalysisManager(re::FrameAnalysisManager *this)
{
  re::FrameAnalysisManager::~FrameAnalysisManager(this);
  JUMPOUT(0x237DBCBD0);
}

{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t i;
  uint64_t v22;
  const void *v23;
  uint64_t v24;

  *(void *)this = &unk_26E6C6AC8;
  uint64_t v2 = (uint64_t *)((char *)this + 192);
  uint64_t v3 = *((unsigned int *)this + 56);
  if (v3)
  {
    unint64_t v4 = 0;
    unint64_t v5 = (int *)(*((void *)this + 26) + 8);
    while (1)
    {
      uint64_t v6 = *v5;
      v5 += 20;
      if (v6 < 0) {
        break;
      }
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 56);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if (v3 != v4)
  {
    uint64_t v7 = v4;
    unint64_t v8 = *((_DWORD *)this + 56);
    do
    {
      uint64_t v9 = *((void *)this + 26);
      unsigned int v10 = v9 + 80 * v7;
      int v11 = *(void *)(*(void *)(v10 + 16) + 288);
      if (v11)
      {
        int v12 = *(void *)(v9 + 80 * v7 + 64);
        if (v12)
        {
          unsigned int v13 = 0;
          uint16x8_t v14 = v10 + 24;
          do
          {
            uint64_t v15 = re::BucketArray<RESubscriptionHandle,8ul>::operator[](v14, v13);
            re::EventBus::unsubscribe(v11, *(void *)v15, *(void *)(v15 + 8));
            ++v13;
          }
          while (v12 != v13);
          unint64_t v8 = *((_DWORD *)this + 56);
        }
      }
      if (v8 <= (int)v4 + 1) {
        int16x8_t v16 = v4 + 1;
      }
      else {
        int16x8_t v16 = v8;
      }
      while (1)
      {
        uint64_t v7 = (v4 + 1);
        if (v16 - 1 == v4) {
          break;
        }
        LODWORD(v4) = v4 + 1;
        int v17 = v7;
        if ((*(_DWORD *)(*((void *)this + 26) + 80 * v7 + 8) & 0x80000000) != 0) {
          goto LABEL_21;
        }
      }
      int v17 = v16;
LABEL_21:
      LODWORD(v4) = v17;
    }
    while (v3 != v17);
  }
  re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(v2);
  uint64_t v18 = re::ServiceLocator::serviceOrNull<re::EventBus>(*((void *)this + 3));
  if (v18)
  {
    uint64_t v19 = *((void *)this + 22);
    if (v19)
    {
      uint16x8_t v20 = v18;
      for (unint64_t i = 0; i != v19; ++i)
      {
        int16x8_t v22 = re::BucketArray<RESubscriptionHandle,8ul>::operator[]((uint64_t)this + 136, i);
        re::EventBus::unsubscribe(v20, *(void *)v22, *(void *)(v22 + 8));
      }
    }
  }
  re::BucketArray<RESubscriptionHandle,8ul>::deinit((uint64_t)this + 136);
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((_WORD *)this + 64) = 1;
  *((unsigned char *)this + 130) = 0;
  *((_WORD *)this + 66) = 0;
  int v23 = (const void *)*((void *)this + 13);
  if (v23)
  {
    _Block_release(v23);
    *((void *)this + 13) = 0;
  }
  *((void *)this + 3) = 0;
  uint16x8_t v24 = *((void *)this + 46);
  if (v24)
  {
    if (*((void *)this + 50)) {
      (*(void (**)(uint64_t))(*(void *)v24 + 40))(v24);
    }
    *((void *)this + 50) = 0;
    *((void *)this + 47) = 0;
    *((void *)this + 48) = 0;
    *((void *)this + 46) = 0;
    ++*((_DWORD *)this + 98);
  }
  re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(v2);
  re::BucketArray<RESubscriptionHandle,8ul>::deinit((uint64_t)this + 136);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 136);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 7);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

uint64_t re::FrameAnalysisManager::services(re::FrameAnalysisManager *this)
{
  return *((void *)this + 3);
}

BOOL re::FrameAnalysisManager::hasModifiedRenderFrameData(re::FrameAnalysisManager *this)
{
  uint64_t v2 = *((void *)this + 13);
  if (v2)
  {
    uint64_t v4 = 1;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    LOBYTE(v5) = (*((void *)this + 15) != *((void *)this + 14)) | (2 * *((unsigned char *)this + 128)) | (4 * *((unsigned char *)this + 129)) | (8 * *((unsigned char *)this + 131)) | (16 * *((unsigned char *)this + 132)) | (32 * *((unsigned char *)this + 133));
    (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
  }
  return *((void *)this + 15) != *((void *)this + 14)
      || *((unsigned char *)this + 128)
      || *((unsigned char *)this + 129)
      || *((unsigned char *)this + 131)
      || *((unsigned char *)this + 132)
      || *((unsigned char *)this + 133) != 0;
}

uint64_t re::FrameAnalysisManager::hasModifiedEnvironmentLayerRenderFrameData(re::FrameAnalysisManager *this)
{
  return *((unsigned __int8 *)this + 130);
}

uint64_t re::FrameAnalysisManager::overrideRenderFrameDataModified(uint64_t this)
{
  return this;
}

uint64_t re::FrameAnalysisManager::currentBottlenecks(re::FrameAnalysisManager *this)
{
  return *((void *)this + 50);
}

uint64_t re::FrameAnalysisManager::modifiedRenderFrameDataAddIgnoredEntity(re::FrameAnalysisManager *this, re::ecs2::Entity *a2)
{
  uint64_t v3 = a2;
  return re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::add((uint64_t)this + 56, (uint64_t *)&v3);
}

uint64_t re::FrameAnalysisManager::modifiedRenderFrameDataRemoveIgnoredEntity(re::FrameAnalysisManager *this, re::ecs2::Entity *a2)
{
  uint64_t v3 = a2;
  return re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)this + 56, (uint64_t *)&v3);
}

void re::FrameAnalysisManager::modifiedRenderFrameDataClearIgnoredEntities(re::FrameAnalysisManager *this)
{
}

void re::FrameAnalysisProfilerProcessor::~FrameAnalysisProfilerProcessor(re::FrameAnalysisProfilerProcessor *this)
{
}

uint64_t re::FrameAnalysisProfilerProcessor::willNeedEvents(re::FrameAnalysisProfilerProcessor *this)
{
  return 0;
}

uint64_t re::FrameAnalysisProfilerProcessor::willNeedStatistics(re::FrameAnalysisProfilerProcessor *this)
{
  return 1;
}

uint64_t re::FrameAnalysisProfilerProcessor::willNeedAttributions(re::FrameAnalysisProfilerProcessor *this)
{
  return 0;
}

uint64_t re::FrameAnalysisProfilerProcessor::willNeedMemoryStatistics(re::FrameAnalysisProfilerProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerProcessor::updateInterval(re::ProfilerProcessor *this)
{
  return 1;
}

void re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Scene *,RESceneDidAddEvent const&),REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Scene *,RESceneDidAddEvent const&),REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Scene *,RESceneDidAddEvent const&),REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C6C00;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Scene *,RESceneDidAddEvent const&),REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C6C00;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Scene *,RESceneDidAddEvent const&),REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::size()
{
  return 32;
}

void re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Scene *,RESceneWillRemoveEvent const&),REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Scene *,RESceneWillRemoveEvent const&),REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Scene *,RESceneWillRemoveEvent const&),REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C6C58;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Scene *,RESceneWillRemoveEvent const&),REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C6C58;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Scene *,RESceneWillRemoveEvent const&),REEventHandlerResult ()(re::ecs2::Scene *,RESceneWillRemoveEvent const&)>::size()
{
  return 32;
}

void re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C6CB0;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C6CB0;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::size()
{
  return 32;
}

uint64_t (***re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C6D18;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C6D18;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::size()
{
  return 32;
}

void re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C6D70;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C6D70;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::FrameAnalysisManager,REEventHandlerResult (re::FrameAnalysisManager::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::size()
{
  return 32;
}

uint64_t (***re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(void *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)unsigned int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31)) % v2;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 4 * v5);
  if (v7 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (*(void *)(v9 + 24 * v7 + 16) != v3)
  {
    while (1)
    {
      unsigned int v10 = v7;
      LODWORD(v7) = *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
      if (v7 == 0x7FFFFFFF) {
        return 0;
      }
      if (*(void *)(v9 + 24 * v7 + 16) == v3)
      {
        *(_DWORD *)(v9 + 24 * v10 + 8) = *(_DWORD *)(v9 + 24 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 24 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = v11 + 24 * v7;
  int v15 = *(_DWORD *)(v12 + 8);
  uint16x8_t v14 = (int *)(v12 + 8);
  int v13 = v15;
  if (v15 < 0)
  {
    *uint16x8_t v14 = v13 & 0x7FFFFFFF;
    uint64_t v11 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v11 + 24 * v7 + 8);
  }
  int v16 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v11 + 24 * v7 + 8) = *(_DWORD *)(a1 + 36) | v13 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v16 + 1;
  return 1;
}

void re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 24 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t *re::BucketArray<RESubscriptionHandle,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 128, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add(uint64_t a1, void *a2)
{
  uint64_t result = re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::ensureCapacity((_anonymous_namespace_ *)a1);
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v5 = a1 + 24;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 32);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  *(void *)(v5 + 8 * v6) = *a2;
  *(void *)(a1 + 8) = v6 + 1;
  *(_DWORD *)(a1 + 16) += 2;
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::ensureCapacity(_anonymous_namespace_ *result)
{
  uint64_t v1 = result;
  if (*(void *)result)
  {
    unint64_t v2 = *((void *)result + 1);
    if (*((unsigned char *)result + 16)) {
      unint64_t v3 = 2;
    }
    else {
      unint64_t v3 = *((void *)result + 3);
    }
    if (v2 >= v3)
    {
      return re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::growCapacity(result, v2 + 1);
    }
  }
  else
  {
    unint64_t v4 = *((void *)v1 + 1) + 1;
    uint64_t result = (_anonymous_namespace_ *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v1, v4);
    *((_DWORD *)v1 + 4) += 2;
  }
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::growCapacity(_anonymous_namespace_ *result, unint64_t a2)
{
  unint64_t v2 = a2;
  unint64_t v3 = result;
  if (!*(void *)result)
  {
    uint64_t result = (_anonymous_namespace_ *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v2);
    *((_DWORD *)v3 + 4) += 2;
    return result;
  }
  if (*((unsigned char *)result + 16))
  {
    if (a2 <= 2) {
      return result;
    }
    unint64_t v5 = 4;
  }
  else
  {
    unint64_t v4 = *((void *)result + 3);
    if (v4 >= a2) {
      return result;
    }
    unint64_t v5 = 2 * v4;
  }
  if (v5 > a2) {
    a2 = v5;
  }
  return (_anonymous_namespace_ *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(result, a2);
}

uint64_t re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 8 * v3)
  {
    re::BucketArray<RESubscriptionHandle,8ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 8) >> 3);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 16 * (v2 & 7);
}

uint64_t re::BucketArray<RESubscriptionHandle,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 3) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 3)) + 16 * (a2 & 7);
}

uint64_t re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(result + 8) = v1 & 0x7FFFFFFF;
    uint64_t v2 = result + 24;
    re::BucketArray<RESubscriptionHandle,8ul>::deinit(result + 24);
    return re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v2);
  }
  return result;
}

unint64_t re::DynamicInlineArray<REFrameAnalysisBottleneck,2ul>::ensureCapacity(unint64_t result, uint64_t a2)
{
  if (result > 1)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Capacity limit reached. DynamicInlineArray<T,N> cannot be resized.", "false", "ensureCapacity", 277, v2, v3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 80 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 80 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 80 * v10) = a3;
  *(void *)(*(void *)(a1 + 16) + 80 * v10 + 16) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + 80 * v10;
  *(void *)(v14 + 24) = 0;
  *(void *)(v14 + 32) = 0;
  v14 += 24;
  *(_DWORD *)(v14 + 16) = 1;
  *(void *)(v14 + 32) = 0;
  *(void *)(v14 + 40) = 0;
  *(void *)(v14 + 24) = 0;
  *(_DWORD *)(v14 + 48) = 0;
  re::BucketArray<RESubscriptionHandle,8ul>::swap(v14, a5);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::BucketArray<RESubscriptionHandle,8ul>::swap(uint64_t a1, uint64_t a2)
{
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::DynamicOverflowArray((uint64_t)v6, a1);
  re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::operator=(a1, a2);
  re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::operator=(a2, (uint64_t)v6);
  uint64_t result = v6[0];
  if (v6[0] && (v7 & 1) == 0) {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)v6[0] + 40))();
  }
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v5;
  ++*(_DWORD *)(a1 + 48);
  ++*(_DWORD *)(a2 + 48);
  return result;
}

uint64_t re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    if (*(void *)a1)
    {
      if (*(void *)a2 && *(void *)a1 != *(void *)a2)
      {
        re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 527);
        uint64_t result = _os_crash();
        __break(1u);
        return result;
      }
    }
    if (*(unsigned char *)(a2 + 16))
    {
      if (*(void *)(a2 + 8))
      {
        re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::move(a1, a2);
      }
      else
      {
        re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
        *(void *)a1 = *(void *)a2;
        *(_DWORD *)(a2 + 16) += 2;
        *(_DWORD *)(a1 + 16) += 2;
      }
    }
    else
    {
      *(void *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 16) += 2;
      re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::swap((uint64_t *)a1, (uint64_t *)a2);
    }
  }
  return a1;
}

void re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 24);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 80;
        }
        while (v11 < v9);
      }
      re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

BOOL re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  unint64_t v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
                        % v2));
  if (v5 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  if (*(void *)(v7 + 24 * v5 + 16) == v3) {
    return 1;
  }
  do
  {
    LODWORD(v5) = *(_DWORD *)(v7 + 24 * v5 + 8) & 0x7FFFFFFF;
    BOOL result = v5 != 0x7FFFFFFF;
  }
  while (v5 != 0x7FFFFFFF && *(void *)(v7 + 24 * v5 + 16) != v3);
  return result;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,REComponentDidChangeEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v14[8] = *MEMORY[0x263EF8340];
  uint64_t v10 = re::EventBus::getTypeId<REComponentDidChangeEvent>();
  unint64_t EventInfo = re::EventBus::addOrGetEventInfo(a1, v10);
  re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(a3, a5, v14);
  uint64_t v12 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v14, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v14);
  return v12;
}

{
  uint64_t v10;
  re *EventInfo;
  uint64_t v12;
  uint64_t v13;
  void v15[5];
  void v16[9];

  unsigned char v16[8] = *MEMORY[0x263EF8340];
  uint64_t v10 = re::EventBus::getTypeId<REComponentDidChangeEvent>();
  unint64_t EventInfo = (re *)re::EventBus::addOrGetEventInfo(a1, v10);
  uint64_t v12 = re::globalAllocators(EventInfo)[2];
  v15[0] = &unk_26E6FA188;
  v15[1] = a3;
  v15[3] = v12;
  v15[4] = v15;
  re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>((uint64_t)v15, a5, v16);
  int v13 = re::EventBus::EventInfo::addSubscription((unint64_t)EventInfo, (uint64_t)v16, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v16);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable((uint64_t)v15);
  return v13;
}

uint64_t (***re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>@<X0>(uint64_t a1@<X2>, char a2@<W4>, void *a3@<X8>))(void)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v6 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v6)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C6DD8;
  }
  else
  {
    unint64_t v4 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v4)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C6E30;
  }
  *a3 = v5;
  a3[4] = v9;
  a3[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v8);
  a3[7] = a3;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable((uint64_t)v8);
}

uint64_t re::EventBus::getTypeId<REComponentDidChangeEvent>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::EventBus::getTypeId<REComponentDidChangeEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"25REComponentDidChangeEvent" & 0x7FFFFFFFFFFFFFFFLL), v3);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[236];
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C6DD8;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C6DD8;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
  return 1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6DD8;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6DD8;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C6E30;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C6E30;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  return (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6E30;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6E30;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentDidChangeEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

uint64_t re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v14[8] = *MEMORY[0x263EF8340];
  uint64_t Type = re::EventBus::getTypeId<REComponentWillDeactivateEvent>();
  unint64_t EventInfo = re::EventBus::addOrGetEventInfo(a1, Type);
  re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(a3, a5, v14);
  uint64_t v12 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v14, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v14);
  return v12;
}

{
  uint64_t Type;
  re *EventInfo;
  uint64_t v12;
  uint64_t v13;
  void v15[5];
  void v16[9];

  unsigned char v16[8] = *MEMORY[0x263EF8340];
  uint64_t Type = re::EventBus::getTypeId<REComponentWillDeactivateEvent>();
  unint64_t EventInfo = (re *)re::EventBus::addOrGetEventInfo(a1, Type);
  uint64_t v12 = re::globalAllocators(EventInfo)[2];
  v15[0] = &unk_26E702F48;
  v15[1] = a3;
  v15[3] = v12;
  v15[4] = v15;
  re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>((uint64_t)v15, a5, v16);
  int v13 = re::EventBus::EventInfo::addSubscription((unint64_t)EventInfo, (uint64_t)v16, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v16);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable((uint64_t)v15);
  return v13;
}

uint64_t (***re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>@<X0>(uint64_t a1@<X2>, char a2@<W4>, void *a3@<X8>))(void)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v6 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v6)[2];
    a3[7] = 0;
    unint64_t v5 = &unk_26E6C6E88;
  }
  else
  {
    uint64_t v4 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v4)[2];
    a3[7] = 0;
    unint64_t v5 = &unk_26E6C6EE0;
  }
  *a3 = v5;
  a3[4] = v9;
  a3[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v8);
  a3[7] = a3;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable((uint64_t)v8);
}

uint64_t re::EventBus::getTypeId<REComponentWillDeactivateEvent>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::EventBus::getTypeId<REComponentWillDeactivateEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"30REComponentWillDeactivateEvent" & 0x7FFFFFFFFFFFFFFFLL), v3);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[289];
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C6E88;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C6E88;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
  return 1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6E88;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6E88;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C6EE0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C6EE0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  return (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6EE0;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C6EE0;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,REComponentWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

uint64_t re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t re::internal::engineExecutePhase(int *a1, uint64_t a2)
{
  if (a1[300] >= 1)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid nested engine tick", "!engine->isInsideTick()", "engineExecutePhase", 190);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    return re::Engine::executePhase((re::Engine *)a1, a2);
  }
  return result;
}

uint64_t re::Engine::executePhase(re::Engine *this, unsigned int a2)
{
  ++*((_DWORD *)this + 300);
  uint64_t v4 = (re::ecs2::ECSManager *)*((void *)this + 83);
  if (v4) {
    re::ecs2::ECSManager::setActiveRealityRendererSceneGroup(v4, 0);
  }
  if (*((unsigned __int8 *)this + 688) >= a2)
  {
    re::Engine::checkForConfigureSystemChanges(this, 0);
    unint64_t v5 = (re::Scheduler *)*((void *)this + 85);
    double v6 = 0.0;
    if (a2 == 1) {
      double v6 = (*(float (**)(void, double))(**((void **)this + 115) + 56))(*((void *)this + 115), 0.0);
    }
    re::Scheduler::beginPhaseExecution(v5, v6, 0.00277777785);
  }
  uint64_t result = re::Scheduler::executePhase(*((re::Scheduler **)this + 85), *((void *)this + a2 + 4));
  *((unsigned char *)this + 688) = a2;
  if (a2 == 5)
  {
    if (*((unsigned char *)this + 409))
    {
      if (*((unsigned char *)this + 408))
      {
        *((unsigned char *)this + 408) = 0;
        uint64_t result = *((void *)this + 85);
        if (result) {
          uint64_t result = re::Scheduler::setEnabled(result, (uint64_t)this + 336, 0);
        }
      }
    }
  }
  --*((_DWORD *)this + 300);
  return result;
}

uint64_t re::internal::engineEnterFrameWithTimeDelta(re::internal *this, re::Engine *a2, float a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*((int *)this + 300) >= 1)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid nested engine tick", "!engine->isInsideTick()", "engineEnterFrameWithTimeDelta", 196);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = (*(uint64_t (**)(void, re::Engine *))(**((void **)this + 115) + 120))(*((void *)this + 115), a2);
  *(void *)&long long v9 = this;
  *((void *)&v9 + 1) = re::Engine::timeDidChange;
  uint64_t v10 = 0;
  uint64_t v11 = re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::createSubscription<re::Engine>(re::Engine *,REEventHandlerResult (re::Engine::*)(re::SimulationTimer*,re::SimulationTimerEventArgs const&))::{lambda(re::SimulationTimer*,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription const&,re::SimulationTimerEventArgs const&)#1}::__invoke;
  re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::removeSubscription(v5, &v9);
  re::ManualClock::update(*((void *)this + 114), a3, v6);
  unint64_t v7 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**((void **)this + 115) + 120))(*((void *)this + 115));
  *(void *)&long long v9 = this;
  *((void *)&v9 + 1) = re::Engine::timeDidChange;
  uint64_t v10 = 0;
  uint64_t v11 = re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::createSubscription<re::Engine>(re::Engine *,REEventHandlerResult (re::Engine::*)(re::SimulationTimer*,re::SimulationTimerEventArgs const&))::{lambda(re::SimulationTimer*,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription const&,re::SimulationTimerEventArgs const&)#1}::__invoke;
  re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::addSubscription(v7, (uint64_t)&v9);
  return re::Engine::executePhase(this, 1u);
}

id re::internal::coreREBundleVersionString(re::internal *this)
{
  re::Bundle::coreREFramework(&v4);
  id v1 = v4;

  int v2 = [v1 objectForInfoDictionaryKey:*MEMORY[0x263EFFB70]];

  return v2;
}

void *re::allocInfo_RealityRendererSystemArrayManager(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_30, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_30))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF74C20, "RealityRendererSystemArrayManager");
    __cxa_guard_release(&_MergedGlobals_30);
  }
  return &unk_26AF74C20;
}

void re::initInfo_RealityRendererSystemArrayManager(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x52D0909F144886ACLL;
  v5[1] = "RealityRendererSystemArrayManager";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x100000008;
  *((_DWORD *)this + 6) = 1;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = &re::initInfo_RealityRendererSystemArrayManager(re::IntrospectionBase *)::structureAttributes;
  *((void *)this + 9) = re::internal::defaultConstruct<re::RealityRendererSystemArrayManager>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::RealityRendererSystemArrayManager>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::RealityRendererSystemArrayManager>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::RealityRendererSystemArrayManager>;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

re::Engine *re::Engine::Engine(re::Engine *this)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  uint64_t v2 = re::globalAllocators(this)[2];
  ArcSharedObject::ArcSharedObject(this, 0);
  *((void *)this + 2) = v2;
  *(void *)this = &unk_26E6C6F38;
  *((unsigned char *)this + 24) = 0;
  *((_WORD *)this + 160) = 259;
  *((_DWORD *)this + 81) = 1023969417;
  *((unsigned char *)this + 328) = 0;
  *((void *)this + 42) = 0;
  *((void *)this + 43) = 0;
  *((_DWORD *)this + 88) = 1;
  *((void *)this + 45) = 0;
  *((void *)this + 46) = 0;
  *((void *)this + 50) = 0;
  *((_WORD *)this + 204) = 1;
  uint64_t v3 = re::EngineConfiguration::EngineConfiguration((re::Engine *)((char *)this + 416));
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 40) = 0u;
  *((unsigned char *)this + 688) = 8;
  *(_OWORD *)((char *)this + 696) = 0u;
  *(_OWORD *)((char *)this + 712) = 0u;
  *(_OWORD *)((char *)this + 728) = 0u;
  *(_OWORD *)((char *)this + 744) = 0u;
  *(_OWORD *)((char *)this + 760) = 0u;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *(_OWORD *)((char *)this + 8re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0u;
  *(_OWORD *)((char *)this + 872) = 0u;
  *(_OWORD *)((char *)this + 888) = 0u;
  *((_DWORD *)this + 226) = 0;
  *((_DWORD *)this + 292) = 0;
  *((_OWORD *)this + 72) = 0u;
  *((_OWORD *)this + 71) = 0u;
  *((_OWORD *)this + 70) = 0u;
  *((_OWORD *)this + 69) = 0u;
  *((_OWORD *)this + 68) = 0u;
  *((_OWORD *)this + 67) = 0u;
  *((_OWORD *)this + 66) = 0u;
  *((_OWORD *)this + 65) = 0u;
  *((_OWORD *)this + 63) = 0u;
  *((_OWORD *)this + 64) = 0u;
  *((_OWORD *)this + 61) = 0u;
  *((_OWORD *)this + 62) = 0u;
  *((_OWORD *)this + 59) = 0u;
  *((_OWORD *)this + 60) = 0u;
  *((_OWORD *)this + 57) = 0u;
  *((_OWORD *)this + 58) = 0u;
  *((void *)this + 148) = 0xBFF0000000000000;
  *((void *)this + 149) = 0;
  *((_DWORD *)this + 300) = 0;
  *((void *)this + 151) = 0;
  *((void *)this + 153) = 0;
  *((void *)this + 152) = 0;
  *((_DWORD *)this + 308) = 0;
  *((void *)this + 160) = 0;
  *((_DWORD *)this + 322) = 0;
  *(_OWORD *)((char *)this + 1240) = 0u;
  *(_OWORD *)((char *)this + 12re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0u;
  *((_DWORD *)this + 318) = 0;
  *((void *)this + 162) = 0;
  *((void *)this + 164) = 0;
  *((void *)this + 163) = 0;
  *((_DWORD *)this + 330) = 0;
  *((void *)this + 171) = 0;
  *((_DWORD *)this + 344) = 0;
  *((_DWORD *)this + 340) = 0;
  *((_OWORD *)this + 84) = 0u;
  *((_OWORD *)this + 83) = 0u;
  *(_OWORD *)((char *)this + 1384) = 0u;
  *(_OWORD *)((char *)this + 1400) = 0u;
  *((unsigned char *)this + 1416) = 0;
  if ((int)atomic_fetch_add_explicit(re::Engine::s_instanceCount, 1u, memory_order_relaxed) >= 8)
  {
    re::internal::assertLog((re::internal *)5, v4, "assertion failure: '%s' (%s:line %i) Exceeded max Engine count (%d)", "oldCount < kMaxInstanceCount", "Engine", 256, 8);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = re::internal::coreREBundleVersionString(v3);
  re::Bundle::realityKitFramework((uint64_t)buf);
  if (buf[0]) {
    long long v6 = *(void **)&v35[4];
  }
  else {
    long long v6 = 0;
  }
  id v7 = v6;
  if (buf[0]) {

  }
  uint64_t v8 = [v7 objectForInfoDictionaryKey:*MEMORY[0x263EFFB70]];

  uint64_t v10 = *re::appLogObjects(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    log = v10;
    uint64_t v11 = re::internal::coreREBundleVersionString(log);
    int v12 = [v11 intValue];

    if (v12) {
      BOOL v13 = v12 == 0xFFFF;
    }
    else {
      BOOL v13 = 1;
    }
    uint64_t v14 = "Localbuild";
    if (!v13) {
      uint64_t v14 = "Official Tag";
    }
    unint64_t v27 = v14;
    size_t v29 = v5;
    uint64_t v26 = [v5 UTF8String];
    uint64_t v25 = (re::internal *)[v8 UTF8String];
    int v15 = re::internal::coreREBundleVersionString(v25);
    int v16 = [v15 componentsSeparatedByString:@"."];
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    uint64_t v17 = [v16 countByEnumeratingWithState:&v30 objects:buf count:16];
    if (v17)
    {
      uint64_t v18 = v17;
      uint64_t v19 = 0;
      uint64_t v20 = *(void *)v31;
      unint64_t v21 = 1000000000000;
      do
      {
        for (uint64_t i = 0; i != v18; ++i)
        {
          if (*(void *)v31 != v20) {
            objc_enumerationMutation(v16);
          }
          v21 /= 0x3E8uLL;
          v19 += v21 * (int)[*(id *)(*((void *)&v30 + 1) + 8 * i) intValue];
        }
        uint64_t v18 = [v16 countByEnumeratingWithState:&v30 objects:buf count:16];
      }
      while (v18);
    }
    else
    {
      uint64_t v19 = 0;
    }

    *(_DWORD *)buf = 136315906;
    *(void *)uint64_t v35 = v27;
    *(_WORD *)&v35[8] = 2080;
    *(void *)&v35[10] = v26;
    __int16 v36 = 2080;
    uint64_t v37 = v25;
    __int16 v38 = 2048;
    uint64_t v39 = v19;
    _os_log_impl(&dword_233120000, (os_log_t)log, OS_LOG_TYPE_DEFAULT, "Booting the engine (%s) with CoreVersion : %s RealityKit %s, ver = %llu", buf, 0x2Au);

    uint64_t v5 = v29;
  }
  *(void *)&long long v23 = -1;
  *((void *)&v23 + 1) = -1;
  *((_OWORD *)this + 18) = v23;
  *((_OWORD *)this + 19) = v23;
  *((_OWORD *)this + 16) = v23;
  *((_OWORD *)this + 17) = v23;
  *((_OWORD *)this + 14) = v23;
  *((_OWORD *)this + 15) = v23;
  *((_OWORD *)this + 12) = v23;
  *((_OWORD *)this + 13) = v23;
  *((_OWORD *)this + 10) = v23;
  *((_OWORD *)this + 11) = v23;
  *((_OWORD *)this + 8) = v23;
  *((_OWORD *)this + 9) = v23;
  *((_OWORD *)this + 6) = v23;
  *((_OWORD *)this + 7) = v23;
  *((_OWORD *)this + 4) = v23;
  *((_OWORD *)this + 5) = v23;
  *((_OWORD *)this + 2) = v23;
  *((_OWORD *)this + 3) = v23;

  return this;
}

void re::Engine::~Engine(id *this)
{
  *this = &unk_26E6C6F38;
  re::Engine::deinit((uint64_t)this);
  if ((int)atomic_fetch_add_explicit(re::Engine::s_instanceCount, 0xFFFFFFFF, memory_order_relaxed) <= 0)
  {
    re::internal::assertLog((re::internal *)4, v2, "assertion failure: '%s' (%s:line %i) Engine count is 0", "oldCount > 0", "~Engine", 272);
    _os_crash();
    __break(1u);
  }
  else
  {

    uint64_t v3 = (char *)this[173];
    if (v3)
    {

      this[173] = 0;
    }
    re::Event<re::Engine>::~Event((uint64_t)(this + 162));
    re::Event<re::Engine>::~Event((uint64_t)(this + 151));
    uint64_t v4 = (char *)this[144];
    if (v4)
    {

      this[144] = 0;
    }
    uint64_t v5 = (std::__shared_weak_count *)this[143];
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    }
    long long v6 = (char *)this[141];
    if (v6)
    {

      this[141] = 0;
    }
    id v7 = (char *)this[116];
    if (v7)
    {

      this[116] = 0;
    }
    uint64_t v8 = (char *)this[110];
    if (v8)
    {

      this[110] = 0;
    }
    long long v9 = (char *)this[106];
    if (v9)
    {

      this[106] = 0;
    }

    uint64_t v10 = (char *)this[83];
    if (v10)
    {

      this[83] = 0;
    }

    re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)(this + 61));
    re::DynamicString::deinit((re::DynamicString *)(this + 55));

    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)(this + 42));
    *this = &unk_26E6DECE0;
    objc_destructInstance(this + 1);
  }
}

{
  uint64_t vars8;

  re::Engine::~Engine(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::Engine::deinit(uint64_t this)
{
  uint64_t v180 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(this + 24))
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)(this + 840);
    if (v2)
    {
      uint64_t v3 = *(re::DrawingManager **)(v2 + 104);
      if (v3) {
        re::DrawingManager::prepareForDeinit(v3);
      }
    }
    dispatch_block_cancel(*(dispatch_block_t *)(v1 + 1408));
    (*(void (**)(void))(**(void **)(v1 + 912) + 72))(*(void *)(v1 + 912));
    (*(void (**)(void))(**(void **)(v1 + 920) + 136))(*(void *)(v1 + 920));
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(v1 + 920) + 120))(*(void *)(v1 + 920));
    *(void *)&long long v177 = v1;
    *((void *)&v177 + 1) = re::Engine::timeDidChange;
    uint64_t v178 = 0;
    uint64_t v179 = re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::createSubscription<re::Engine>(re::Engine *,REEventHandlerResult (re::Engine::*)(re::SimulationTimer*,re::SimulationTimerEventArgs const&))::{lambda(re::SimulationTimer*,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription const&,re::SimulationTimerEventArgs const&)#1}::__invoke;
    re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::removeSubscription(v4, &v177);
    uint64_t v5 = (re::TextureAsset *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 40))(v1);
    if (*(void *)(v1 + 1208)) {
      uint64_t v5 = (re::TextureAsset *)re::DynamicArray<unsigned long>::deinit(v1 + 1208);
    }
    if (*(void *)(v1 + 1296)) {
      uint64_t v5 = (re::TextureAsset *)re::DynamicArray<unsigned long>::deinit(v1 + 1296);
    }
    uint64_t v6 = *(void *)(v1 + 880);
    if (v6)
    {

      *(void *)(v1 + 880) = 0;
    }
    uint64_t v7 = *(void *)(v1 + 928);
    if (v7)
    {

      *(void *)(v1 + 928) = 0;
    }
    uint64_t v8 = *(void *)(v1 + 744);
    if (v8)
    {
      long long v9 = re::TextureAsset::assetType(v5);
      uint64_t v10 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(void *)(v8 + 1040), (unint64_t)v9);
      *(void *)(v10 + 72) = 0;
      *(_OWORD *)(v10 + 8) = 0u;
      *(_OWORD *)(v10 + 24) = 0u;
    }
    if (*(void *)(v1 + 792))
    {
      uint64_t v11 = *(void *)(v1 + 648);
      re::StringID::invalid((re::StringID *)&v175);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74C08, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF74C08))
      {
        qword_26AF74C00 = re::internal::getOrCreateInfo((re::internal *)"RealityRendererSystemArrayManager", (uint64_t (*)(re::internal *))re::allocInfo_RealityRendererSystemArrayManager, (re::IntrospectionBase *(*)(void))re::initInfo_RealityRendererSystemArrayManager, (void (*)(re::IntrospectionBase *))&unk_26AF74BB0, 0);
        __cxa_guard_release(&qword_26AF74C08);
      }
      uint64_t v12 = qword_26AF74C00;
      re::StringID::StringID((re::StringID *)&v176, &v175);
      *(void *)&long long v177 = v12;
      re::StringID::StringID((re::StringID *)((char *)&v177 + 8), &v176);
      re::StringID::destroyString((re::StringID *)&v176);
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(v11 + 16, (uint64_t *)&v177);
      re::StringID::destroyString((re::StringID *)((char *)&v177 + 8));
      re::StringID::destroyString((re::StringID *)&v175);
      uint64_t v14 = *(void *)(v1 + 792);
      if (v14)
      {
        int v15 = re::globalAllocators(v13);
        (*(void (**)(uint64_t, uint64_t))(*(void *)v15[2] + 40))(v15[2], v14);
      }
      *(void *)(v1 + 792) = 0;
    }
    int v16 = *(re::FrameProfiler **)(v1 + 936);
    if (v16 && *((unsigned char *)v16 + 204) && !*((unsigned char *)v16 + 17))
    {
      re::FrameProfiler::setOverlayEnabled(v16, 0);
      uint64_t v17 = *(void *)(v1 + 664);
      if (v17)
      {
        uint64_t v18 = *(void *)(v1 + 1128);
        uint64_t v174 = v18;
        if (v18) {
          id v19 = (id)(v18 + 8);
        }
        re::ecs2::ECSManager::removeSystem(v17, &v174, 0);
        if (v174)
        {

          uint64_t v174 = 0;
        }
      }
      uint64_t v20 = *(void *)(v1 + 1128);
      if (v20)
      {

        *(void *)(v1 + 1128) = 0;
      }
    }
    uint64_t v21 = *(void *)(v1 + 664);
    if (v21)
    {

      *(void *)(v1 + 664) = 0;
    }
    int16x8_t v22 = *(re::DrawableQueueManager **)(v1 + 768);
    if (v22)
    {
      uint64_t v23 = re::globalAllocators(v16)[2];
      re::DrawableQueueManager::~DrawableQueueManager(v22);
      int v16 = (re::FrameProfiler *)(*(uint64_t (**)(uint64_t, re::DrawableQueueManager *))(*(void *)v23 + 40))(v23, v22);
    }
    *(void *)(v1 + 768) = 0;
    uint16x8_t v24 = *(void ***)(v1 + 824);
    if (v24)
    {
      uint64_t v25 = re::globalAllocators(v16)[2];
      re::ResourceSharingManager::~ResourceSharingManager(v24);
      (*(void (**)(uint64_t, void **))(*(void *)v25 + 40))(v25, v24);
    }
    *(void *)(v1 + 824) = 0;
    uint64_t v26 = *(void *)(v1 + 752);
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v26 + 16))(v26);
    }
    unint64_t v27 = *(re::AssetManager **)(v1 + 744);
    if (v27)
    {
      re::AssetManager::deinit(v27);
      uint64_t v28 = *(re::AssetManager **)(v1 + 744);
      if (v28)
      {
        uint64_t v29 = re::globalAllocators(v27)[2];
        re::AssetManager::~AssetManager(v28);
        unint64_t v27 = (re::AssetManager *)(*(uint64_t (**)(uint64_t, re::AssetManager *))(*(void *)v29 + 40))(v29, v28);
      }
      *(void *)(v1 + 744) = 0;
    }
    uint64_t v30 = *(void *)(v1 + 760);
    if (v30)
    {
      long long v31 = re::globalAllocators(v27);
      unint64_t v27 = (re::AssetManager *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v31[2] + 40))(v31[2], v30);
      *(void *)(v1 + 760) = 0;
    }
    uint64_t v32 = *(void *)(v1 + 808);
    if (v32)
    {
      *(_OWORD *)(v32 + 24) = 0u;
      *(_OWORD *)(v32 + 8) = 0u;
      uint64_t v33 = *(void *)(v1 + 808);
      if (v33)
      {
        uint64_t v34 = re::globalAllocators(v27)[2];
        (*(void (**)(uint64_t))(*(void *)v33 + 16))(v33);
        (*(void (**)(uint64_t, uint64_t))(*(void *)v34 + 40))(v34, v33);
      }
      *(void *)(v1 + 808) = 0;
    }
    uint64_t v35 = *(re::NetworkAssetManager **)(v1 + 816);
    if (v35)
    {
      re::NetworkAssetManager::deinit(v35);
      __int16 v36 = *(uint64_t **)(v1 + 816);
      if (v36)
      {
        uint64_t v37 = re::globalAllocators(v35)[2];
        uint64_t *v36 = (uint64_t)&unk_26E6C9048;
        re::StringID::destroyString((re::StringID *)(v36 + 25));
        uint64_t v38 = v36[23];
        if (v38)
        {

          v36[23] = 0;
        }
        re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v36 + 16);
        re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v36 + 10);
        v39.n128_f64[0] = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v36 + 4);
        uint64_t v40 = v36[3];
        if (v40)
        {

          v36[3] = 0;
        }
        uint64_t v35 = (re::NetworkAssetManager *)(*(uint64_t (**)(uint64_t, uint64_t *, __n128))(*(void *)v37 + 40))(v37, v36, v39);
      }
      *(void *)(v1 + 816) = 0;
    }
    uint64_t v41 = *(void **)(v1 + 752);
    if (v41)
    {
      uint64_t v42 = re::globalAllocators(v35)[2];
      void *v41 = &unk_26E6CA038;
      double v43 = re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit(v41 + 9);
      (*(void (**)(uint64_t, void *, double))(*(void *)v42 + 40))(v42, v41, v43);
      *(void *)(v1 + 752) = 0;
    }
    if (*(void *)(v1 + 784))
    {
      uint64_t v44 = *(void *)(v1 + 648);
      re::StringID::invalid((re::StringID *)&v173);
      {
        re::introspect<re::DirectResourceAssetTracker>(void)::info = re::introspect_DirectResourceAssetTracker(0);
      }
      uint64_t v45 = re::introspect<re::DirectResourceAssetTracker>(void)::info;
      re::StringID::StringID((re::StringID *)&v176, &v173);
      *(void *)&long long v177 = v45;
      re::StringID::StringID((re::StringID *)((char *)&v177 + 8), &v176);
      re::StringID::destroyString((re::StringID *)&v176);
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(v44 + 16, (uint64_t *)&v177);
      re::StringID::destroyString((re::StringID *)((char *)&v177 + 8));
      re::StringID::destroyString((re::StringID *)&v173);
      unint64_t v47 = *(re::DirectResourceAssetTracker **)(v1 + 784);
      if (v47)
      {
        uint64_t v48 = re::globalAllocators(v46)[2];
        re::DirectResourceAssetTracker::~DirectResourceAssetTracker(v47);
        (*(void (**)(uint64_t, re::DirectResourceAssetTracker *))(*(void *)v48 + 40))(v48, v47);
      }
      *(void *)(v1 + 784) = 0;
    }
    if (*(void *)(v1 + 776))
    {
      uint64_t v49 = *(void *)(v1 + 648);
      re::StringID::invalid((re::StringID *)&v172);
      {
        re::introspect<re::DRContextService>(void)::info = re::introspect_DRContextService(0);
      }
      uint64_t v50 = re::introspect<re::DRContextService>(void)::info;
      re::StringID::StringID((re::StringID *)&v176, &v172);
      *(void *)&long long v177 = v50;
      re::StringID::StringID((re::StringID *)((char *)&v177 + 8), &v176);
      re::StringID::destroyString((re::StringID *)&v176);
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(v49 + 16, (uint64_t *)&v177);
      re::StringID::destroyString((re::StringID *)((char *)&v177 + 8));
      re::StringID::destroyString((re::StringID *)&v172);
      unint64_t v51 = *(void **)(v1 + 776);
      *(void *)(v1 + 776) = 0;
    }
    uint64_t v52 = *(void *)(v1 + 1136);
    if (v52) {
      (*(void (**)(uint64_t))(*(void *)v52 + 144))(v52);
    }
    uint64_t v53 = *(std::__shared_weak_count **)(v1 + 1144);
    *(_OWORD *)(v1 + 1136) = 0u;
    if (v53) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v53);
    }
    float32x2_t v54 = *(void ***)(v1 + 832);
    if (v54)
    {
      uint64_t v55 = re::globalAllocators((re *)v53)[2];
      re::ResourceFetchManager::~ResourceFetchManager(v54);
      (*(void (**)(uint64_t, void **))(*(void *)v55 + 40))(v55, v54);
    }
    *(void *)(v1 + 832) = 0;
    if (*(void *)(v1 + 1056))
    {
      uint64_t v56 = *(void *)(v1 + 648);
      re::StringID::invalid((re::StringID *)&v171);
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74BE8, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_26AF74BE8))
      {
        qword_26AF74BE0 = re::ecs2::introspect_CARESortingService(0);
        __cxa_guard_release(&qword_26AF74BE8);
      }
      uint64_t v57 = qword_26AF74BE0;
      re::StringID::StringID((re::StringID *)&v176, &v171);
      *(void *)&long long v177 = v57;
      re::StringID::StringID((re::StringID *)((char *)&v177 + 8), &v176);
      re::StringID::destroyString((re::StringID *)&v176);
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(v56 + 16, (uint64_t *)&v177);
      re::StringID::destroyString((re::StringID *)((char *)&v177 + 8));
      re::StringID::destroyString((re::StringID *)&v171);
      unint64_t v59 = *(void (****)(void))(v1 + 1056);
      if (v59)
      {
        uint64_t v60 = re::globalAllocators(v58)[2];
        (**v59)(v59);
        (*(void (**)(uint64_t, void (***)(void)))(*(void *)v60 + 40))(v60, v59);
      }
      *(void *)(v1 + 10re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0;
    }
    if (*(void *)(v1 + 1064))
    {
      uint64_t v61 = *(void *)(v1 + 648);
      re::StringID::invalid((re::StringID *)&v170);
      {
        re::introspect<re::ecs2::RemoteEffectsService>(void)::info = re::ecs2::introspect_RemoteEffectsService(0);
      }
      uint64_t v62 = re::introspect<re::ecs2::RemoteEffectsService>(void)::info;
      re::StringID::StringID((re::StringID *)&v176, &v170);
      *(void *)&long long v177 = v62;
      re::StringID::StringID((re::StringID *)((char *)&v177 + 8), &v176);
      re::StringID::destroyString((re::StringID *)&v176);
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(v61 + 16, (uint64_t *)&v177);
      re::StringID::destroyString((re::StringID *)((char *)&v177 + 8));
      re::StringID::destroyString((re::StringID *)&v170);
      uint64_t v64 = *(void *)(v1 + 1064);
      if (v64)
      {
        uint64_t v65 = re::globalAllocators(v63)[2];
        re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit((uint64_t *)(v64 + 128));
        re::HashTable<re::SharedPtr<re::ecs2::Entity>,re::ecs2::RemoteEffectHoverData,re::Hash<re::SharedPtr<re::ecs2::Entity>>,re::EqualTo<re::SharedPtr<re::ecs2::Entity>>,true,false>::deinit((uint64_t *)(v64 + 80));
        re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit(v64 + 40);
        re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit(v64);
        (*(void (**)(uint64_t, uint64_t))(*(void *)v65 + 40))(v65, v64);
      }
      *(void *)(v1 + 1064) = 0;
    }
    unint64_t v66 = *(re **)(v1 + 944);
    if (v66)
    {
      unint64_t v66 = (re *)(*(uint64_t (**)(re *))(*(void *)v66 + 24))(v66);
      unint64_t v67 = *(void (****)(void))(v1 + 944);
      if (v67)
      {
        uint64_t v68 = re::globalAllocators(v66)[2];
        (**v67)(v67);
        unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v68 + 40))(v68, v67);
      }
      *(void *)(v1 + 944) = 0;
    }
    uint64_t v69 = *(void *)(v1 + 1152);
    if (v69)
    {

      *(void *)(v1 + 1152) = 0;
    }
    long long v70 = *(id **)(v1 + 1160);
    if (v70)
    {
      uint64_t v71 = re::globalAllocators(v66)[2];
      re::SharedClockManager::~SharedClockManager(v70);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, id *))(*(void *)v71 + 40))(v71, v70);
      *(void *)(v1 + 1160) = 0;
    }
    unint64_t v72 = *(void (****)(void))(v1 + 960);
    if (v72)
    {
      uint64_t v73 = re::globalAllocators(v66)[2];
      (**v72)(v72);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v73 + 40))(v73, v72);
    }
    *(void *)(v1 + 960) = 0;
    if (*(void *)(v1 + 856))
    {
      uint64_t v74 = *(void *)(v1 + 648);
      re::StringID::invalid((re::StringID *)&v169);
      {
        re::introspect<re::NetworkSystem>(void)::info = re::introspect_NetworkSystem(0);
      }
      uint64_t v75 = re::introspect<re::NetworkSystem>(void)::info;
      re::StringID::StringID((re::StringID *)&v176, &v169);
      *(void *)&long long v177 = v75;
      re::StringID::StringID((re::StringID *)((char *)&v177 + 8), &v176);
      re::StringID::destroyString((re::StringID *)&v176);
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(v74 + 16, (uint64_t *)&v177);
      re::StringID::destroyString((re::StringID *)((char *)&v177 + 8));
      re::StringID::destroyString((re::StringID *)&v169);
      uint64_t v76 = *(re::NetworkSystem **)(v1 + 856);
      if (v76)
      {
        uint64_t v77 = re::globalAllocators(v66)[2];
        re::NetworkSystem::~NetworkSystem(v76);
        unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, re::NetworkSystem *))(*(void *)v77 + 40))(v77, v76);
      }
      *(void *)(v1 + 8re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0;
    }
    if (*(void *)(v1 + 864))
    {
      uint64_t v78 = *(void *)(v1 + 648);
      re::StringID::invalid((re::StringID *)&v168);
      {
        re::introspect<re::VideoService>(void)::info = re::introspect_VideoService(0);
      }
      uint64_t v79 = re::introspect<re::VideoService>(void)::info;
      re::StringID::StringID((re::StringID *)&v176, &v168);
      *(void *)&long long v177 = v79;
      re::StringID::StringID((re::StringID *)((char *)&v177 + 8), &v176);
      re::StringID::destroyString((re::StringID *)&v176);
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(v78 + 16, (uint64_t *)&v177);
      re::StringID::destroyString((re::StringID *)((char *)&v177 + 8));
      re::StringID::destroyString((re::StringID *)&v168);
      uint64_t v80 = *(re::VideoManager **)(v1 + 864);
      if (v80)
      {
        uint64_t v81 = re::globalAllocators(v66)[2];
        re::VideoManager::~VideoManager(v80);
        unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, re::VideoManager *))(*(void *)v81 + 40))(v81, v80);
      }
      *(void *)(v1 + 864) = 0;
    }
    if (*(void *)(v1 + 872))
    {
      uint64_t v82 = *(void *)(v1 + 648);
      re::StringID::invalid((re::StringID *)&v167);
      {
        re::introspect<re::MaterialParametersService>(void)::info = re::introspect_MaterialParametersService(0);
      }
      uint64_t v83 = re::introspect<re::MaterialParametersService>(void)::info;
      re::StringID::StringID((re::StringID *)&v176, &v167);
      *(void *)&long long v177 = v83;
      re::StringID::StringID((re::StringID *)((char *)&v177 + 8), &v176);
      re::StringID::destroyString((re::StringID *)&v176);
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(v82 + 16, (uint64_t *)&v177);
      re::StringID::destroyString((re::StringID *)((char *)&v177 + 8));
      re::StringID::destroyString((re::StringID *)&v167);
      long long v84 = *(re::MaterialParametersManager **)(v1 + 872);
      if (v84)
      {
        uint64_t v85 = re::globalAllocators(v66)[2];
        re::MaterialParametersManager::~MaterialParametersManager(v84);
        unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, re::MaterialParametersManager *))(*(void *)v85 + 40))(v85, v84);
      }
      *(void *)(v1 + 872) = 0;
    }
    unint64_t v86 = *(void (****)(void))(v1 + 920);
    if (v86)
    {
      uint64_t v87 = re::globalAllocators(v66)[2];
      (**v86)(v86);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v87 + 40))(v87, v86);
    }
    *(void *)(v1 + 920) = 0;
    uint64_t v88 = *(void *)(v1 + 1384);
    if (v88)
    {

      *(void *)(v1 + 1384) = 0;
    }
    uint64_t v89 = *(void (****)(void))(v1 + 912);
    if (v89)
    {
      uint64_t v90 = re::globalAllocators(v66)[2];
      (**v89)(v89);
      (*(void (**)(uint64_t, void (***)(void)))(*(void *)v90 + 40))(v90, v89);
      *(void *)(v1 + 912) = 0;
      uint64_t v91 = *(void *)(v1 + 648);
      re::StringID::invalid((re::StringID *)&v166);
      {
        re::introspect<re::SimulationClock>(void)::info = re::introspect_SimulationClock(0);
      }
      uint64_t v92 = re::introspect<re::SimulationClock>(void)::info;
      re::StringID::StringID((re::StringID *)&v176, &v166);
      *(void *)&long long v177 = v92;
      re::StringID::StringID((re::StringID *)((char *)&v177 + 8), &v176);
      re::StringID::destroyString((re::StringID *)&v176);
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(v91 + 16, (uint64_t *)&v177);
      re::StringID::destroyString((re::StringID *)((char *)&v177 + 8));
      re::StringID::destroyString((re::StringID *)&v166);
    }
    unint64_t v93 = *(re::InputManager **)(v1 + 896);
    if (v93)
    {
      uint64_t v94 = re::globalAllocators(v66)[2];
      re::InputManager::unsubscribe(v93, v95);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, re::InputManager *))(*(void *)v94 + 40))(v94, v93);
    }
    *(void *)(v1 + 896) = 0;
    uint64_t v96 = *(re::BackgroundTaskManager **)(v1 + 672);
    if (v96)
    {
      uint64_t v97 = re::globalAllocators(v66)[2];
      re::BackgroundTaskManager::~BackgroundTaskManager(v96);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, re::BackgroundTaskManager *))(*(void *)v97 + 40))(v97, v96);
    }
    *(void *)(v1 + 672) = 0;
    unint64_t v98 = *(void (****)(void))(v1 + 1112);
    if (v98)
    {
      uint64_t v99 = re::globalAllocators(v66)[2];
      (**v98)(v98);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v99 + 40))(v99, v98);
      *(void *)(v1 + 1++*(void *)(this + 112) = 0;
    }
    uint64_t v100 = *(void (****)(void))(v1 + 968);
    if (v100)
    {
      uint64_t v101 = re::globalAllocators(v66)[2];
      (**v100)(v100);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v101 + 40))(v101, v100);
      *(void *)(v1 + 968) = 0;
    }
    unint64_t v102 = *(void (****)(void))(v1 + 984);
    if (v102)
    {
      uint64_t v103 = re::globalAllocators(v66)[2];
      (**v102)(v102);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v103 + 40))(v103, v102);
      *(void *)(v1 + 984) = 0;
    }
    uint64_t v104 = *(void (****)(void))(v1 + 992);
    if (v104)
    {
      uint64_t v105 = re::globalAllocators(v66)[2];
      (**v104)(v104);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v105 + 40))(v105, v104);
      *(void *)(v1 + 992) = 0;
    }
    unint64_t v106 = *(void (****)(void))(v1 + 1000);
    if (v106)
    {
      uint64_t v107 = re::globalAllocators(v66)[2];
      (**v106)(v106);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v107 + 40))(v107, v106);
      *(void *)(v1 + 1000) = 0;
    }
    uint64_t v108 = *(void (****)(void))(v1 + 1080);
    if (v108)
    {
      uint64_t v109 = re::globalAllocators(v66)[2];
      (**v108)(v108);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v109 + 40))(v109, v108);
      *(void *)(v1 + 1080) = 0;
    }
    unint64_t v110 = *(void (****)(void))(v1 + 1072);
    if (v110)
    {
      uint64_t v111 = re::globalAllocators(v66)[2];
      (**v110)(v110);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v111 + 40))(v111, v110);
      *(void *)(v1 + 1072) = 0;
    }
    unint64_t v112 = *(void (****)(void))(v1 + 1016);
    if (v112)
    {
      uint64_t v113 = re::globalAllocators(v66)[2];
      (**v112)(v112);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v113 + 40))(v113, v112);
      *(void *)(v1 + 1016) = 0;
    }
    long long v114 = *(void (****)(void))(v1 + 1008);
    if (v114)
    {
      uint64_t v115 = re::globalAllocators(v66)[2];
      (**v114)(v114);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v115 + 40))(v115, v114);
      *(void *)(v1 + 1008) = 0;
    }
    long long v116 = *(void (****)(void))(v1 + 1024);
    if (v116)
    {
      uint64_t v117 = re::globalAllocators(v66)[2];
      (**v116)(v116);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v117 + 40))(v117, v116);
      *(void *)(v1 + 1024) = 0;
    }
    long long v118 = *(void (****)(void))(v1 + 1032);
    if (v118)
    {
      uint64_t v119 = re::globalAllocators(v66)[2];
      (**v118)(v118);
      unint64_t v66 = (re *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v119 + 40))(v119, v118);
      *(void *)(v1 + 1032) = 0;
    }
    long long v120 = *(void (****)(void))(v1 + 1040);
    if (v120)
    {
      uint64_t v121 = re::globalAllocators(v66)[2];
      (**v120)(v120);
      (*(void (**)(uint64_t, void (***)(void)))(*(void *)v121 + 40))(v121, v120);
      *(void *)(v1 + 1040) = 0;
    }
    long long v122 = *(re::ColorManager **)(v1 + 1088);
    if (v122)
    {
      long long v122 = (re::ColorManager *)re::ColorManager::deinit(v122);
      uint64_t v123 = *(void *)(v1 + 1088);
      if (v123)
      {
        long long v124 = re::globalAllocators(v122);
        long long v122 = (re::ColorManager *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v124[2] + 40))(v124[2], v123);
      }
      *(void *)(v1 + 1088) = 0;
    }
    long long v125 = *(id **)(v1 + 1096);
    if (v125)
    {
      uint64_t v126 = re::globalAllocators(v122)[2];
      re::DynamicArray<unsigned long>::deinit((uint64_t)(v125 + 10));
      re::DynamicArray<unsigned long>::deinit((uint64_t)(v125 + 5));

      long long v122 = (re::ColorManager *)(*(uint64_t (**)(uint64_t, id *))(*(void *)v126 + 40))(v126, v125);
      *(void *)(v1 + 1096) = 0;
    }
    long long v127 = *(void (****)(void))(v1 + 976);
    if (v127)
    {
      uint64_t v128 = re::globalAllocators(v122)[2];
      (**v127)(v127);
      long long v122 = (re::ColorManager *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v128 + 40))(v128, v127);
      *(void *)(v1 + 976) = 0;
    }
    long long v129 = *(void (****)(void))(v1 + 1048);
    if (v129)
    {
      uint64_t v130 = re::globalAllocators(v122)[2];
      (**v129)(v129);
      (*(void (**)(uint64_t, void (***)(void)))(*(void *)v130 + 40))(v130, v129);
      *(void *)(v1 + 1048) = 0;
    }
    long long v131 = *(re::ImportGraphicsResources **)(v1 + 800);
    if (v131)
    {
      uint64_t v132 = re::ImportGraphicsResources::deinit(v131);
      long long v133 = *(re::ImportGraphicsResources **)(v1 + 800);
      if (v133)
      {
        uint64_t v134 = re::globalAllocators((re *)v132)[2];
        re::ImportGraphicsResources::~ImportGraphicsResources(v133);
        (*(void (**)(uint64_t, re::ImportGraphicsResources *))(*(void *)v134 + 40))(v134, v133);
      }
      *(void *)(v1 + 800) = 0;
    }
    uint64_t v135 = *(re::RenderManager **)(v1 + 840);
    if (v135)
    {
      uint64_t v135 = (re::RenderManager *)re::RenderManager::deinit(v135);
      int v136 = *(re::RenderManager **)(v1 + 840);
      if (v136)
      {
        uint64_t v137 = re::globalAllocators(v135)[2];
        re::RenderManager::~RenderManager(v136);
        uint64_t v135 = (re::RenderManager *)(*(uint64_t (**)(uint64_t, re::RenderManager *))(*(void *)v137 + 40))(v137, v136);
      }
      *(void *)(v1 + 840) = 0;
    }
    uint64_t v138 = *(void *)(v1 + 952);
    if (v138)
    {
      uint64_t v139 = re::globalAllocators(v135)[2];
      re::ProfilerManager::~ProfilerManager(v138);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v139 + 40))(v139, v138);
    }
    *(void *)(v1 + 952) = 0;
    *(void *)(v1 + 936) = 0;
    re::FrameManager::deinit(*(re::FrameManager **)(v1 + 848));
    uint64_t v141 = *(void *)(v1 + 848);
    if (v141)
    {

      *(void *)(v1 + 848) = 0;
    }
    uint64_t v142 = *(void *)(v1 + 888);
    if (v142)
    {
      uint64_t v143 = re::globalAllocators(v140)[2];
      re::ecs2::PhysicsSimulationManager::deinit((re::ecs2::PhysicsSimulationManager *)v142);
      re::ecs2::PhysicsSimulationTracking::~PhysicsSimulationTracking((re::ecs2::PhysicsSimulationTracking *)(v142 + 16));
      (*(void (**)(uint64_t, uint64_t))(*(void *)v143 + 40))(v143, v142);
    }
    *(void *)(v1 + 888) = 0;
    long long v144 = *(CFTypeRef **)(v1 + 728);
    if (v144)
    {
      re::AnimationManager::deinit(v144);
      long long v144 = (CFTypeRef *)re::internal::destroyPersistent<re::AnimationManager>((re *)"deinit", 1541, *(re::AnimationManager **)(v1 + 728));
      *(void *)(v1 + 728) = 0;
    }
    long long v145 = *(void (****)(void))(v1 + 736);
    if (v145)
    {
      uint64_t v146 = re::globalAllocators((re *)v144)[2];
      (**v145)(v145);
      long long v144 = (CFTypeRef *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v146 + 40))(v146, v145);
      *(void *)(v1 + 736) = 0;
    }
    long long v147 = *(void (****)(void))(v1 + 696);
    if (v147)
    {
      uint64_t v148 = re::globalAllocators((re *)v144)[2];
      (**v147)(v147);
      long long v144 = (CFTypeRef *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v148 + 40))(v148, v147);
      *(void *)(v1 + 696) = 0;
    }
    long long v149 = *(void (****)(void))(v1 + 704);
    if (v149)
    {
      uint64_t v150 = re::globalAllocators((re *)v144)[2];
      (**v149)(v149);
      long long v144 = (CFTypeRef *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v150 + 40))(v150, v149);
      *(void *)(v1 + 704) = 0;
    }
    long long v151 = *(void (****)(void))(v1 + 712);
    if (v151)
    {
      uint64_t v152 = re::globalAllocators((re *)v144)[2];
      (**v151)(v151);
      long long v144 = (CFTypeRef *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v152 + 40))(v152, v151);
      *(void *)(v1 + 712) = 0;
    }
    long long v153 = *(void (****)(void))(v1 + 720);
    if (v153)
    {
      uint64_t v154 = re::globalAllocators((re *)v144)[2];
      (**v153)(v153);
      long long v144 = (CFTypeRef *)(*(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v154 + 40))(v154, v153);
      *(void *)(v1 + 720) = 0;
    }
    long long v155 = *(void (****)(void))(v1 + 1104);
    if (v155)
    {
      uint64_t v156 = re::globalAllocators((re *)v144)[2];
      (**v155)(v155);
      (*(void (**)(uint64_t, void (***)(void)))(*(void *)v156 + 40))(v156, v155);
      *(void *)(v1 + 1104) = 0;
    }
    *(void *)(v1 + 6re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0;
    long long v157 = *(re::EntitlementManager **)(v1 + 1120);
    if (v157)
    {
      re::EntitlementManager::deinit(v157);
      long long v158 = *(re::EntitlementManager **)(v1 + 1120);
      if (v158)
      {
        uint64_t v159 = re::globalAllocators(v157)[2];
        re::EntitlementManager::~EntitlementManager(v158);
        long long v157 = (re::EntitlementManager *)(*(uint64_t (**)(uint64_t, re::EntitlementManager *))(*(void *)v159 + 40))(v159, v158);
      }
      *(void *)(v1 + 1120) = 0;
    }
    uint64_t v160 = *(void *)(v1 + 648);
    if (v160)
    {
      uint64_t v161 = re::globalAllocators(v157)[2];
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit((uint64_t *)(v160 + 16));
      double v162 = re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit((uint64_t *)(v160 + 16));
      long long v157 = (re::EntitlementManager *)(*(uint64_t (**)(uint64_t, uint64_t, double))(*(void *)v161 + 40))(v161, v160, v162);
    }
    *(void *)(v1 + 648) = 0;
    uint64_t v163 = *(uint64_t **)(v1 + 680);
    if (v163)
    {
      uint64_t v164 = re::globalAllocators(v157)[2];
      re::FixedArray<CoreIKTransform>::deinit(v163 + 101);
      re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit(v163 + 98);
      re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit(v163 + 95);
      re::DynamicArray<unsigned long>::deinit((uint64_t)(v163 + 88));
      re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit(v163 + 85);
      re::FixedArray<CoreIKTransform>::deinit(v163 + 82);
      re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit(v163 + 79);
      re::FixedArray<CoreIKTransform>::deinit(v163 + 76);
      re::FixedArray<CoreIKTransform>::deinit(v163 + 73);
      re::FixedArray<CoreIKTransform>::deinit(v163 + 70);
      re::FixedArray<CoreIKTransform>::deinit(v163 + 67);
      re::FixedArray<re::Function<void ()(float)>>::deinit(v163 + 64);
      re::FixedArray<CoreIKTransform>::deinit(v163 + 61);
      re::FixedArray<CoreIKTransform>::deinit(v163 + 58);
      re::FixedArray<CoreIKTransform>::deinit(v163 + 55);
      re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit(v163 + 52);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)(v163 + 43));
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)(v163 + 34));
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)(v163 + 25));
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)(v163 + 16));
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)(v163 + 7));
      re::FixedArray<re::StringID>::deinit(v163 + 4);
      re::FixedArray<re::StringID>::deinit(v163 + 1);
      long long v157 = (re::EntitlementManager *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v164 + 40))(v164, v163);
    }
    *(void *)(v1 + 680) = 0;
    *(void *)&long long v165 = -1;
    *((void *)&v165 + 1) = -1;
    *(_OWORD *)(v1 + 32) = v165;
    *(_OWORD *)(v1 + 48) = v165;
    *(_OWORD *)(v1 + 64) = v165;
    *(_OWORD *)(v1 + 80) = v165;
    *(_OWORD *)(v1 + 96) = v165;
    *(_OWORD *)(v1 + ++*(void *)(this + 112) = v165;
    *(_OWORD *)(v1 + 128) = v165;
    *(_OWORD *)(v1 + 144) = v165;
    *(_OWORD *)(v1 + 160) = v165;
    *(_OWORD *)(v1 + 176) = v165;
    *(_OWORD *)(v1 + 192) = v165;
    *(_OWORD *)(v1 + 208) = v165;
    *(_OWORD *)(v1 + 224) = v165;
    *(_OWORD *)(v1 + 240) = v165;
    *(_OWORD *)(v1 + 2re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = v165;
    *(_OWORD *)(v1 + 272) = v165;
    *(_OWORD *)(v1 + 288) = v165;
    *(_OWORD *)(v1 + 304) = v165;
    *(unsigned char *)(v1 + 24) = 0;
    RESharedEngineContextRelease(v157);
    if (re::Engine::s_sharedEngine == v1) {
      re::Engine::s_sharedEngine = 0;
    }
    this = re::internal::enableSignposts(0, 0);
    if (this) {
      return kdebug_trace();
    }
  }
  return this;
}

void re::Engine::init(re::Engine *this, const re::EngineConfiguration *a2)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  uint64_t v4 = re::internal::enableSignposts(0, 0);
  if (v4) {
    uint64_t v4 = kdebug_trace();
  }
  uint64_t v5 = (_anonymous_namespace_::SharedEngineContext *)*((unsigned int *)a2 + 15);
  uint64_t v6 = *(void *)a2;
  *((_DWORD *)this + 106) = *((_DWORD *)a2 + 2);
  *((void *)this + 52) = v6;
  re::ObjCObject::operator=((id *)this + 54, (id *)a2 + 2);
  re::DynamicString::operator=((re::Engine *)((char *)this + 440), (const re::EngineConfiguration *)((char *)a2 + 24));
  *((void *)this + 59) = *((void *)a2 + 7);
  re::ObjCObject::operator=((id *)this + 60, (id *)a2 + 8);
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)this + 488, (uint64_t)a2 + 72);
  long long v8 = *((_OWORD *)a2 + 7);
  long long v7 = *((_OWORD *)a2 + 8);
  *(_OWORD *)((char *)this + 5re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = *(_OWORD *)((char *)a2 + 140);
  *((_OWORD *)this + 33) = v8;
  *((_OWORD *)this + 34) = v7;
  *((_OWORD *)this + 36) = *((_OWORD *)a2 + 10);
  long long v9 = re::ObjCObject::operator=((id *)this + 74, (id *)a2 + 22);
  long long v10 = *(_OWORD *)((char *)a2 + 184);
  long long v11 = *(_OWORD *)((char *)a2 + 200);
  *((unsigned char *)this + 632) = *((unsigned char *)a2 + 216);
  *(_OWORD *)((char *)this + 616) = v11;
  *(_OWORD *)((char *)this + 600) = v10;
  *((unsigned char *)this + 24) = 1;
  uint64_t v12 = re::globalAllocators((re *)v9);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12[2] + 32))(v12[2], 64, 8);
  *(_OWORD *)(v13 + 16) = 0u;
  *(void *)uint64_t v13 = &unk_26E721018;
  *(void *)(v13 + 8) = 0;
  *(_OWORD *)(v13 + 32) = 0u;
  *(_DWORD *)(v13 + 48) = 0;
  *(void *)(v13 + 52) = 0x7FFFFFFFLL;
  *((void *)this + 81) = v13;
  re::StringID::invalid((re::StringID *)&v79);
  {
    re::introspect<re::ServiceRegistry>(void)::info = re::introspect_ServiceRegistry(0);
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::ServiceRegistry>(void)::info, &v79, (void *)v13);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v13 + 16, (uint64_t *)&__str);
  re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
  re::StringID::destroyString((re::StringID *)&v79);
  uint64_t v14 = *((void *)this + 81);
  re::StringID::invalid((re::StringID *)&v79);
  {
    re::introspect<re::Engine>(void)::info = re::internal::getOrCreateInfo((re::internal *)"Engine", (uint64_t (*)(re::internal *))re::allocInfo_Engine, (re::IntrospectionBase *(*)(void))re::initInfo_Engine, (void (*)(re::IntrospectionBase *))&unk_26AF74BC0, 0);
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::Engine>(void)::info, &v79, this);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v14 + 16, (uint64_t *)&__str);
  re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
  re::StringID::destroyString((re::StringID *)&v79);
  int v16 = re::globalAllocators(v15);
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16[2] + 32))(v16[2], 216, 8);
  *(void *)uint64_t v17 = &unk_26E6C9338;
  *(unsigned char *)(v17 + 8) = 0;
  *(_OWORD *)(v17 + 16) = 0u;
  *(_OWORD *)(v17 + 32) = 0u;
  *(_DWORD *)(v17 + 48) = 0;
  *(void *)(v17 + 52) = 0x7FFFFFFFLL;
  *(_OWORD *)(v17 + 64) = 0u;
  *(_OWORD *)(v17 + 80) = 0u;
  *(_DWORD *)(v17 + 96) = 0;
  *(void *)(v17 + 100) = 0x7FFFFFFFLL;
  *(_DWORD *)(v17 + 144) = 0;
  *(_OWORD *)(v17 + ++*(void *)(this + 112) = 0u;
  *(_OWORD *)(v17 + 128) = 0u;
  *(void *)(v17 + 148) = 0x7FFFFFFFLL;
  *(_OWORD *)(v17 + 160) = 0u;
  *(_OWORD *)(v17 + 176) = 0u;
  *(_DWORD *)(v17 + 192) = 0;
  *(void *)(v17 + 196) = 0x7FFFFFFFLL;
  *(void *)(v17 + 208) = 0;
  *((void *)this + 140) = v17;
  __str.__r_.__value_.__r.__words[0] = *((void *)this + 81);
  re::EntitlementManager::init(v17, &__str);
  uint64_t v18 = *((void *)this + 81);
  id v19 = (void *)*((void *)this + 140);
  re::StringID::invalid((re::StringID *)&v79);
  {
    re::introspect<re::EntitlementService>(void)::info = re::introspect_EntitlementService(0);
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::EntitlementService>(void)::info, &v79, v19);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v18 + 16, (uint64_t *)&__str);
  re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
  re::StringID::destroyString((re::StringID *)&v79);
  uint64_t v20 = (void *)g_jobService;
  *((void *)this + 82) = g_jobService;
  uint64_t v21 = *((void *)this + 81);
  re::StringID::invalid((re::StringID *)&v79);
  {
    re::introspect<re::JobService>(void)::info = re::introspect_JobService(0);
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::JobService>(void)::info, &v79, v20);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v21 + 16, (uint64_t *)&__str);
  re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
  re::StringID::destroyString((re::StringID *)&v79);
  re::make::shared::object<re::EventBus>(v22, &__str);
  std::string::size_type v23 = *((void *)this + 173);
  uint16x8_t v24 = (void *)__str.__r_.__value_.__r.__words[0];
  *((void *)this + 173) = __str.__r_.__value_.__r.__words[0];
  __str.__r_.__value_.__r.__words[0] = v23;
  if (v23)
  {

    uint16x8_t v24 = (void *)*((void *)this + 173);
  }
  uint64_t v25 = *((void *)this + 81);
  re::StringID::invalid((re::StringID *)&__str);
  re::ServiceRegistry::add<re::EventBus>(v25, v24, (StringID *)&__str);
  re::StringID::destroyString((re::StringID *)&__str);
  unint64_t v27 = re::globalAllocators(v26);
  uint64_t v28 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v27[2] + 32))(v27[2], 864, 8);
  bzero(v28, 0x350uLL);
  *((_DWORD *)v28 + 18) = 1;
  v28[10] = 0;
  v28[11] = 0;
  v28[16] = 0;
  v28[17] = 0;
  v28[15] = 0;
  *((_DWORD *)v28 + 36) = 1;
  v28[19] = 0;
  v28[20] = 0;
  v28[25] = 0;
  v28[26] = 0;
  v28[24] = 0;
  *((_DWORD *)v28 + 54) = 1;
  v28[28] = 0;
  v28[29] = 0;
  v28[33] = 0;
  v28[34] = 0;
  v28[35] = 0;
  *((_DWORD *)v28 + 72) = 1;
  v28[37] = 0;
  v28[38] = 0;
  v28[43] = 0;
  v28[44] = 0;
  v28[42] = 0;
  *((_DWORD *)v28 + 90) = 1;
  v28[46] = 0;
  v28[47] = 0;
  *(_OWORD *)(v28 + 51) = 0u;
  *(_OWORD *)(v28 + 53) = 0u;
  *(_OWORD *)(v28 + 55) = 0u;
  *(_OWORD *)(v28 + 57) = 0u;
  *(_OWORD *)(v28 + 59) = 0u;
  *(_OWORD *)(v28 + 61) = 0u;
  *(_OWORD *)(v28 + 63) = 0u;
  *(_OWORD *)(v28 + 65) = 0u;
  *(_OWORD *)(v28 + 67) = 0u;
  *(_OWORD *)(v28 + 69) = 0u;
  *(_OWORD *)(v28 + 71) = 0u;
  *(_OWORD *)(v28 + 73) = 0u;
  *(_OWORD *)(v28 + 75) = 0u;
  *(_OWORD *)(v28 + 77) = 0u;
  *(_OWORD *)(v28 + 79) = 0u;
  *(_OWORD *)(v28 + 81) = 0u;
  *(_OWORD *)(v28 + 83) = 0u;
  *(_OWORD *)(v28 + 85) = 0u;
  *(_OWORD *)(v28 + 87) = 0u;
  *(_OWORD *)(v28 + 89) = 0u;
  *((_DWORD *)v28 + 182) = 0;
  v28[93] = 0;
  v28[92] = 0;
  v28[94] = 0x7F7FFFFF00000000;
  *(_OWORD *)(v28 + 95) = 0u;
  *(_OWORD *)(v28 + 97) = 0u;
  *(_OWORD *)(v28 + 99) = 0u;
  *(_OWORD *)(v28 + 101) = 0u;
  *(_OWORD *)(v28 + 103) = 0u;
  *(void *)((char *)v28 + 837) = 0;
  v28[106] = -1;
  v28[107] = -1;
  *((void *)this + 85) = v28;
  long long v31 = re::globalAllocators(v30);
  uint64_t v32 = (re::NetworkOPACKSerializer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v31[2] + 32))(v31[2], 480, 8);
  *((void *)this + 87) = re::NetworkOPACKSerializer::NetworkOPACKSerializer(v32);
  uint64_t v33 = *((void *)this + 81);
  re::StringID::invalid((re::StringID *)&v79);
  {
    re::introspect<re::NetworkOPACKSerializer>(void)::info = re::introspect_NetworkOPACKSerializer(0);
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::NetworkOPACKSerializer>(void)::info, &v79, v32);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v33 + 16, (uint64_t *)&__str);
  re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
  re::StringID::destroyString((re::StringID *)&v79);
  uint64_t v35 = re::globalAllocators(v34);
  __int16 v36 = (re::NetworkOPACKDeserializer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35[2] + 32))(v35[2], 480, 8);
  *((void *)this + 88) = re::NetworkOPACKDeserializer::NetworkOPACKDeserializer(v36);
  uint64_t v37 = *((void *)this + 81);
  re::StringID::invalid((re::StringID *)&v79);
  {
    re::introspect<re::NetworkOPACKDeserializer>(void)::info = re::introspect_NetworkOPACKDeserializer(0);
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::NetworkOPACKDeserializer>(void)::info, &v79, v36);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v37 + 16, (uint64_t *)&__str);
  re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
  re::StringID::destroyString((re::StringID *)&v79);
  __n128 v39 = re::globalAllocators(v38);
  uint64_t v40 = (re::NetworkCompatSerializer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v39[2] + 32))(v39[2], 464, 8);
  *((void *)this + 89) = re::NetworkCompatSerializer::NetworkCompatSerializer(v40);
  uint64_t v41 = *((void *)this + 81);
  re::StringID::invalid((re::StringID *)&v79);
  {
    re::introspect<re::NetworkCompatSerializer>(void)::info = re::introspect_NetworkCompatSerializer(0);
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::NetworkCompatSerializer>(void)::info, &v79, v40);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v41 + 16, (uint64_t *)&__str);
  re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
  re::StringID::destroyString((re::StringID *)&v79);
  double v43 = re::globalAllocators(v42);
  uint64_t v44 = (re::NetworkCompatDeserializer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v43[2] + 32))(v43[2], 464, 8);
  *((void *)this + 90) = re::NetworkCompatDeserializer::NetworkCompatDeserializer(v44);
  uint64_t v45 = *((void *)this + 81);
  re::StringID::invalid((re::StringID *)&v79);
  {
    re::introspect<re::NetworkCompatDeserializer>(void)::info = re::introspect_NetworkCompatDeserializer(0);
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::NetworkCompatDeserializer>(void)::info, &v79, v44);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v45 + 16, (uint64_t *)&__str);
  re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
  re::StringID::destroyString((re::StringID *)&v79);
  re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&__str);
  re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&__str);
  int v47 = *((_DWORD *)this + 105);
  if ((v47 & 0x104) != 0)
  {
    *((void *)this + 145) = 0;
    uint64_t v48 = re::globalAllocators(v46);
    uint64_t v49 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v48[2] + 32))(v48[2], 352, 8);
    uint64_t v50 = re::TimebaseManager::TimebaseManager((uint64_t)v49, *((void *)this + 145));
    uint64_t v51 = *((void *)this + 144);
    *((void *)this + 144) = v50;
    if (v51)
    {

      uint64_t v49 = (void *)*((void *)this + 144);
    }
    uint64_t v52 = *((void *)this + 81);
    re::StringID::invalid((re::StringID *)&v79);
    {
      re::introspect<re::TimebaseService>(void)::info = re::introspect_TimebaseService(0);
    }
    re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::TimebaseService>(void)::info, &v79, v49);
    re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v52 + 16, (uint64_t *)&__str);
    re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
    re::StringID::destroyString((re::StringID *)&v79);
    int v47 = *((_DWORD *)this + 105);
  }
  if ((v47 & 4) != 0)
  {
    uint64_t v53 = re::globalAllocators(v46);
    float32x2_t v54 = (re::AnimationManager *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v53[2] + 32))(v53[2], 512, 8);
    re::AnimationManager::AnimationManager(v54);
    *((void *)this + 91) = v55;
    re::AnimationManager::init(v55, *(CFTypeRef *)(*((void *)this + 144) + 232), 0);
    uint64_t v56 = *((void *)this + 81);
    uint64_t v57 = (void *)*((void *)this + 91);
    re::StringID::invalid((re::StringID *)&v79);
    {
      re::introspect<re::AnimationService>(void)::info = re::introspect_AnimationService(0);
    }
    re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::AnimationService>(void)::info, &v79, v57);
    re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v56 + 16, (uint64_t *)&__str);
    re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
    re::StringID::destroyString((re::StringID *)&v79);
    int v47 = *((_DWORD *)this + 105);
  }
  if ((v47 & 2) != 0)
  {
    uint64_t v58 = re::globalAllocators(v46);
    unint64_t v59 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v58[2] + 32))(v58[2], 464, 8);
    *(void *)unint64_t v59 = &unk_26E6F9CE8;
    *((void *)v59 + 1) = &unk_26E6F9C98;
    *((void *)v59 + 2) = v59;
    *((void *)v59 + 3) = 0;
    *((void *)v59 + 4) = 0;
    *((_DWORD *)v59 + 10) = 1;
    *((_OWORD *)v59 + 3) = 0u;
    *((_OWORD *)v59 + 4) = 0u;
    *((_OWORD *)v59 + 5) = 0u;
    *(_OWORD *)(v59 + 92) = 0u;
    *(void *)(v59 + 108) = 0x7FFFFFFFLL;
    *((void *)v59 + 16) = 0;
    *((void *)v59 + 17) = 0;
    *((void *)v59 + 15) = 0;
    *((_DWORD *)v59 + 36) = 0;
    *(_OWORD *)(v59 + 152) = 0u;
    *(_OWORD *)(v59 + 168) = 0u;
    *(_OWORD *)(v59 + 180) = 0u;
    *(void *)(v59 + 196) = 0x7FFFFFFFLL;
    *((void *)v59 + 26) = 0;
    *((void *)v59 + 27) = 0;
    *((_DWORD *)v59 + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 1;
    *((void *)v59 + 30) = 0;
    *((void *)v59 + 31) = 0;
    *((_DWORD *)v59 + 64) = 0;
    *((void *)v59 + 29) = 0;
    *((_WORD *)v59 + 132) = 259;
    *((_DWORD *)v59 + 67) = 1023969417;
    v59[272] = 0;
    *((void *)v59 + 35) = 0;
    *((void *)v59 + 36) = 0;
    *((_DWORD *)v59 + 74) = 1;
    *((void *)v59 + 38) = 0;
    *((void *)v59 + 39) = 0;
    *((void *)this + 92) = v59;
    uint64_t v60 = *((void *)this + 81);
    re::StringID::invalid((re::StringID *)&v79);
    {
      re::introspect<re::ecs2::AnimationSceneService>(void)::info = re::ecs2::introspect_AnimationSceneService(0);
    }
    re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::ecs2::AnimationSceneService>(void)::info, &v79, v59);
    re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v60 + 16, (uint64_t *)&__str);
    re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
    re::StringID::destroyString((re::StringID *)&v79);
  }
  if (!*((unsigned char *)a2 + 210) && (physx::shdfnd::g_alwaysUseLocking & 1) == 0) {
    physx::shdfnd::g_alwaysUseLocking = 1;
  }
  if ((*((unsigned char *)this + 420) & 0x20) != 0)
  {
    uint64_t v61 = re::globalAllocators(v46);
    uint64_t v62 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v61[2] + 32))(v61[2], 624, 16);
    bzero(v62, 0x270uLL);
    void *v62 = &unk_26E6C7640;
    re::ecs2::PhysicsSimulationTracking::PhysicsSimulationTracking((re::ecs2::PhysicsSimulationTracking *)(v62 + 2));
    *((unsigned char *)v62 + 616) = 0;
    v62[76] = 0;
    *((_OWORD *)v62 + 37) = 0u;
    *((void *)this + 111) = v62;
    re::ecs2::PhysicsSimulationManager::init((uint64_t)v62, *((void *)this + 81), *((unsigned char *)a2 + 209));
    uint64_t v63 = *((void *)this + 81);
    uint64_t v64 = (void *)*((void *)this + 111);
    re::StringID::invalid((re::StringID *)&v79);
    {
      re::introspect<re::ecs2::PhysicsSimulationService>(void)::info = re::ecs2::introspect_PhysicsSimulationService(0);
    }
    re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::ecs2::PhysicsSimulationService>(void)::info, &v79, v64);
    re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v63 + 16, (uint64_t *)&__str);
    re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
    re::StringID::destroyString((re::StringID *)&v79);
  }
  uint64_t v65 = re::globalAllocators(v46);
  unint64_t v66 = (re::FrameManager *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v65[2] + 32))(v65[2], 320, 8);
  unint64_t v67 = re::FrameManager::FrameManager(v66);
  uint64_t v68 = *((void *)this + 106);
  *((void *)this + 106) = v67;
  if (v68)
  {

    unint64_t v67 = (re::FrameManager *)*((void *)this + 106);
  }
  re::FrameManager::init(v67);
  uint64_t v69 = *((void *)this + 81);
  long long v70 = (void *)*((void *)this + 106);
  re::StringID::invalid((re::StringID *)&v79);
  {
    re::introspect<re::FrameManager>(void)::info = re::introspect_FrameManager(0);
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::FrameManager>(void)::info, &v79, v70);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v69 + 16, (uint64_t *)&__str);
  re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
  re::StringID::destroyString((re::StringID *)&v79);
  unsigned int v71 = g_jobService;
  if (g_jobService) {
    unsigned int v71 = (*(uint64_t (**)(uint64_t))(*(void *)g_jobService + 16))(g_jobService);
  }
  unint64_t v72 = v71 + 14;
  uint64_t v73 = (re *)std::thread::hardware_concurrency();
  unint64_t v74 = v73;
  if (v72 > v73) {
    unint64_t v74 = v72;
  }
  if (v74 >= 0x20) {
    uint64_t v75 = 32;
  }
  else {
    uint64_t v75 = v74;
  }
  uint64_t v76 = re::globalAllocators(v73);
  uint64_t v77 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v76[2] + 32))(v76[2], 536, 8);
  *(void *)uint64_t v77 = atomic_fetch_add(&qword_26AF74BC8, 1uLL) + 1;
  *((void *)v77 + 1) = 0;
  *((_DWORD *)v77 + 4) = 0;
  *((void *)v77 + 3) = v75;
  *((_OWORD *)v77 + 2) = 0u;
  *((_OWORD *)v77 + 3) = 0u;
  *((_OWORD *)v77 + 4) = 0u;
  *((_OWORD *)v77 + 5) = 0u;
  *((void *)v77 + 12) = 0;
  *((_DWORD *)v77 + 26) = 1065353216;
  *((_OWORD *)v77 + 7) = 0u;
  *((_OWORD *)v77 + 8) = 0u;
  *((_OWORD *)v77 + 9) = 0u;
  *((_OWORD *)v77 + 10) = 0u;
  *((_OWORD *)v77 + 11) = 0u;
  *((_DWORD *)v77 + 48) = 1065353216;
  *(_OWORD *)(v77 + 216) = 0u;
  *(_OWORD *)(v77 + 232) = 0u;
  *(_OWORD *)(v77 + 248) = 0u;
  *(_OWORD *)(v77 + 200) = 0u;
  *(_OWORD *)(v77 + 264) = 0u;
  *((_DWORD *)v77 + 70) = 1065353216;
  *((_OWORD *)v77 + 18) = 0u;
  *((_OWORD *)v77 + 19) = 0u;
  *((_OWORD *)v77 + 20) = 0u;
  *((_OWORD *)v77 + 21) = 0u;
  *((_OWORD *)v77 + 22) = 0u;
  *((_OWORD *)v77 + 23) = 0u;
  *((_OWORD *)v77 + 24) = 0u;
  *((_OWORD *)v77 + 25) = 0u;
  *((_OWORD *)v77 + 26) = 0u;
  *((_OWORD *)v77 + 27) = 0u;
  *((_OWORD *)v77 + 28) = 0u;
  *((_OWORD *)v77 + 29) = 0u;
  *((_OWORD *)v77 + 30) = 0u;
  *((_OWORD *)v77 + 31) = 0u;
  *((_DWORD *)v77 + 128) = 1065353216;
  *(_OWORD *)(v77 + 520) = 0u;
  *((void *)v77 + 65) = mach_absolute_time();
  *((void *)this + 119) = v77;
  uint64_t v78 = *((void *)this + 81);
  re::StringID::invalid((re::StringID *)&v79);
  {
    {
      re::introspect<re::ProfilerManager>(void)::info = re::introspect_ProfilerManager(0);
    }
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&__str, (const re::IntrospectionBase *)re::introspect<re::ProfilerManager>(void)::info, &v79, v77);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(v78 + 16, (uint64_t *)&__str);
  re::StringID::destroyString((re::StringID *)&__str.__r_.__value_.__r.__words[1]);
  re::StringID::destroyString((re::StringID *)&v79);
  os_unfair_lock_lock((os_unfair_lock_t)(*((void *)this + 119) + 16));
  re::ProfilerManager::getProcessorId<re::FrameProfiler>();
  operator new();
}

void re::ServiceRegistry::add<re::EventBus>(uint64_t a1, void *a2, StringID *a3)
{
  uint64_t v3 = a2;
  uint64_t v5 = &qword_268772000;
  {
    long long v7 = a3;
    uint64_t v5 = &qword_268772000;
    a3 = v7;
    uint64_t v3 = a2;
    if (v6)
    {
      re::introspect<re::EventBus>(void)::info = re::introspect_EventBus(0);
      uint64_t v5 = &qword_268772000;
      a3 = v7;
      uint64_t v3 = a2;
    }
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&v9, (const re::IntrospectionBase *)v5[210], a3, v3);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(a1 + 16, &v9);
  re::StringID::destroyString((re::StringID *)&v10);
}

uint64_t re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 208) = a2;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 224);
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFuncs((void *)a1);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  *(_DWORD *)(a1 + 216) = *(_DWORD *)(*(void *)(a1 + 208) + 24);
  return result;
}

uint64_t re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 208) = a2;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 224);
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFuncs((void *)a1);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  *(_DWORD *)(a1 + 216) = *(_DWORD *)(*(void *)(a1 + 208) + 24);
  return result;
}

uint64_t re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 192) = a2;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 208);
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFuncs((void *)a1);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(*(void *)(a1 + 192) + 24);
  return result;
}

uint64_t re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 192) = a2;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 208);
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFuncs((void *)a1);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(*(void *)(a1 + 192) + 24);
  return result;
}

uint64_t re::ProfilerManager::getProcessor<re::FrameProfiler,void>(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  uint64_t v6 = re::ProfilerManager::getProcessorId<re::FrameProfiler>();
  uint64_t v3 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((void *)(a1 + 480), (unint64_t *)&v6);
  if (v3) {
    uint64_t v4 = v3[3];
  }
  else {
    uint64_t v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

void re::ProfilerManager::setProcessorEnabled<re::FrameProfiler,void>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  *(_DWORD *)(a1 + 532) = 0;
  uint64_t isStatisticCollectionEnabled = re::ProfilerManager::getProcessorId<re::FrameProfiler>();
  uint64_t v6 = *(void **)(a1 + 496);
  if (v6)
  {
    uint64_t v7 = isStatisticCollectionEnabled;
    do
    {
      long long v8 = (unsigned char *)v6[3];
      if (v6[2] == v7)
      {
        v8[8] = a2;
        uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *, uint64_t))(*(void *)v8 + 64))(v8, a2);
      }
      if (v8[8])
      {
        if (*(unsigned char *)(a1 + 532)) {
          char v9 = 1;
        }
        else {
          char v9 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 24))(v8);
        }
        *(unsigned char *)(a1 + 532) = v9;
        if (*(unsigned char *)(a1 + 533)) {
          char v10 = 1;
        }
        else {
          char v10 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 32))(v8);
        }
        *(unsigned char *)(a1 + 533) = v10;
        if (*(unsigned char *)(a1 + 534)) {
          char v11 = 1;
        }
        else {
          char v11 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 40))(v8);
        }
        *(unsigned char *)(a1 + 534) = v11;
        if (*(unsigned char *)(a1 + 535)) {
          uint64_t isStatisticCollectionEnabled = 1;
        }
        else {
          uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 48))(v8);
        }
        *(unsigned char *)(a1 + 535) = isStatisticCollectionEnabled;
      }
      uint64_t v6 = (void *)*v6;
    }
    while (v6);
  }
  if (*(unsigned char *)(a1 + 532))
  {
    uint64_t v12 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Processor needs events but event collection is disabled.", buf, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 533))
  {
    uint64_t isStatisticCollectionEnabled = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)isStatisticCollectionEnabled);
    if ((isStatisticCollectionEnabled & 1) == 0)
    {
      uint64_t v13 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
      uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (isStatisticCollectionEnabled)
      {
        *(_WORD *)uint64_t v18 = 0;
        _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "Processor needs statistics but statistic collection is disabled.", v18, 2u);
      }
    }
  }
  if (*(unsigned char *)(a1 + 534))
  {
    uint64_t v14 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_DEFAULT, "Processor needs attributions but attribution collection is disabled.", v17, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 535))
  {
    int v15 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v16 = 0;
      _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "Processor needs memory statistics but memory statistic collection is disabled.", v16, 2u);
    }
  }
  os_unfair_lock_unlock(v4);
}

void re::ProfilerManager::setProcessorEnabled<re::ProfilerLogProcessor,void>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  *(_DWORD *)(a1 + 532) = 0;
  uint64_t isStatisticCollectionEnabled = re::ProfilerManager::getProcessorId<re::ProfilerLogProcessor>();
  uint64_t v6 = *(void **)(a1 + 496);
  if (v6)
  {
    uint64_t v7 = isStatisticCollectionEnabled;
    do
    {
      long long v8 = (unsigned char *)v6[3];
      if (v6[2] == v7)
      {
        v8[8] = a2;
        uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *, uint64_t))(*(void *)v8 + 64))(v8, a2);
      }
      if (v8[8])
      {
        if (*(unsigned char *)(a1 + 532)) {
          char v9 = 1;
        }
        else {
          char v9 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 24))(v8);
        }
        *(unsigned char *)(a1 + 532) = v9;
        if (*(unsigned char *)(a1 + 533)) {
          char v10 = 1;
        }
        else {
          char v10 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 32))(v8);
        }
        *(unsigned char *)(a1 + 533) = v10;
        if (*(unsigned char *)(a1 + 534)) {
          char v11 = 1;
        }
        else {
          char v11 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 40))(v8);
        }
        *(unsigned char *)(a1 + 534) = v11;
        if (*(unsigned char *)(a1 + 535)) {
          uint64_t isStatisticCollectionEnabled = 1;
        }
        else {
          uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 48))(v8);
        }
        *(unsigned char *)(a1 + 535) = isStatisticCollectionEnabled;
      }
      uint64_t v6 = (void *)*v6;
    }
    while (v6);
  }
  if (*(unsigned char *)(a1 + 532))
  {
    uint64_t v12 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Processor needs events but event collection is disabled.", buf, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 533))
  {
    uint64_t isStatisticCollectionEnabled = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)isStatisticCollectionEnabled);
    if ((isStatisticCollectionEnabled & 1) == 0)
    {
      uint64_t v13 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
      uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (isStatisticCollectionEnabled)
      {
        *(_WORD *)uint64_t v18 = 0;
        _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "Processor needs statistics but statistic collection is disabled.", v18, 2u);
      }
    }
  }
  if (*(unsigned char *)(a1 + 534))
  {
    uint64_t v14 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_DEFAULT, "Processor needs attributions but attribution collection is disabled.", v17, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 535))
  {
    int v15 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v16 = 0;
      _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "Processor needs memory statistics but memory statistic collection is disabled.", v16, 2u);
    }
  }
  os_unfair_lock_unlock(v4);
}

void re::ProfilerManager::setProcessorEnabled<re::ProfilerFlameChartProcessor,void>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  *(_DWORD *)(a1 + 532) = 0;
  uint64_t isStatisticCollectionEnabled = re::ProfilerManager::getProcessorId<re::ProfilerFlameChartProcessor>();
  uint64_t v6 = *(void **)(a1 + 496);
  if (v6)
  {
    uint64_t v7 = isStatisticCollectionEnabled;
    do
    {
      long long v8 = (unsigned char *)v6[3];
      if (v6[2] == v7)
      {
        v8[8] = a2;
        uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *, uint64_t))(*(void *)v8 + 64))(v8, a2);
      }
      if (v8[8])
      {
        if (*(unsigned char *)(a1 + 532)) {
          char v9 = 1;
        }
        else {
          char v9 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 24))(v8);
        }
        *(unsigned char *)(a1 + 532) = v9;
        if (*(unsigned char *)(a1 + 533)) {
          char v10 = 1;
        }
        else {
          char v10 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 32))(v8);
        }
        *(unsigned char *)(a1 + 533) = v10;
        if (*(unsigned char *)(a1 + 534)) {
          char v11 = 1;
        }
        else {
          char v11 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 40))(v8);
        }
        *(unsigned char *)(a1 + 534) = v11;
        if (*(unsigned char *)(a1 + 535)) {
          uint64_t isStatisticCollectionEnabled = 1;
        }
        else {
          uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 48))(v8);
        }
        *(unsigned char *)(a1 + 535) = isStatisticCollectionEnabled;
      }
      uint64_t v6 = (void *)*v6;
    }
    while (v6);
  }
  if (*(unsigned char *)(a1 + 532))
  {
    uint64_t v12 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Processor needs events but event collection is disabled.", buf, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 533))
  {
    uint64_t isStatisticCollectionEnabled = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)isStatisticCollectionEnabled);
    if ((isStatisticCollectionEnabled & 1) == 0)
    {
      uint64_t v13 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
      uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (isStatisticCollectionEnabled)
      {
        *(_WORD *)uint64_t v18 = 0;
        _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "Processor needs statistics but statistic collection is disabled.", v18, 2u);
      }
    }
  }
  if (*(unsigned char *)(a1 + 534))
  {
    uint64_t v14 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_DEFAULT, "Processor needs attributions but attribution collection is disabled.", v17, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 535))
  {
    int v15 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v16 = 0;
      _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "Processor needs memory statistics but memory statistic collection is disabled.", v16, 2u);
    }
  }
  os_unfair_lock_unlock(v4);
}

void re::ProfilerManager::setProcessorEnabled<re::ProfilerDetailedHUDProcessor,void>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  *(_DWORD *)(a1 + 532) = 0;
  uint64_t isStatisticCollectionEnabled = re::ProfilerManager::getProcessorId<re::ProfilerDetailedHUDProcessor>();
  uint64_t v6 = *(void **)(a1 + 496);
  if (v6)
  {
    uint64_t v7 = isStatisticCollectionEnabled;
    do
    {
      long long v8 = (unsigned char *)v6[3];
      if (v6[2] == v7)
      {
        v8[8] = a2;
        uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *, uint64_t))(*(void *)v8 + 64))(v8, a2);
      }
      if (v8[8])
      {
        if (*(unsigned char *)(a1 + 532)) {
          char v9 = 1;
        }
        else {
          char v9 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 24))(v8);
        }
        *(unsigned char *)(a1 + 532) = v9;
        if (*(unsigned char *)(a1 + 533)) {
          char v10 = 1;
        }
        else {
          char v10 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 32))(v8);
        }
        *(unsigned char *)(a1 + 533) = v10;
        if (*(unsigned char *)(a1 + 534)) {
          char v11 = 1;
        }
        else {
          char v11 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 40))(v8);
        }
        *(unsigned char *)(a1 + 534) = v11;
        if (*(unsigned char *)(a1 + 535)) {
          uint64_t isStatisticCollectionEnabled = 1;
        }
        else {
          uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 48))(v8);
        }
        *(unsigned char *)(a1 + 535) = isStatisticCollectionEnabled;
      }
      uint64_t v6 = (void *)*v6;
    }
    while (v6);
  }
  if (*(unsigned char *)(a1 + 532))
  {
    uint64_t v12 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Processor needs events but event collection is disabled.", buf, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 533))
  {
    uint64_t isStatisticCollectionEnabled = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)isStatisticCollectionEnabled);
    if ((isStatisticCollectionEnabled & 1) == 0)
    {
      uint64_t v13 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
      uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (isStatisticCollectionEnabled)
      {
        *(_WORD *)uint64_t v18 = 0;
        _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "Processor needs statistics but statistic collection is disabled.", v18, 2u);
      }
    }
  }
  if (*(unsigned char *)(a1 + 534))
  {
    uint64_t v14 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_DEFAULT, "Processor needs attributions but attribution collection is disabled.", v17, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 535))
  {
    int v15 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v16 = 0;
      _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "Processor needs memory statistics but memory statistic collection is disabled.", v16, 2u);
    }
  }
  os_unfair_lock_unlock(v4);
}

void re::ProfilerManager::setProcessorEnabled<re::ProfilerMiniHUDProcessor,void>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  *(_DWORD *)(a1 + 532) = 0;
  uint64_t isStatisticCollectionEnabled = re::ProfilerManager::getProcessorId<re::ProfilerMiniHUDProcessor>();
  uint64_t v6 = *(void **)(a1 + 496);
  if (v6)
  {
    uint64_t v7 = isStatisticCollectionEnabled;
    do
    {
      long long v8 = (unsigned char *)v6[3];
      if (v6[2] == v7)
      {
        v8[8] = a2;
        uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *, uint64_t))(*(void *)v8 + 64))(v8, a2);
      }
      if (v8[8])
      {
        if (*(unsigned char *)(a1 + 532)) {
          char v9 = 1;
        }
        else {
          char v9 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 24))(v8);
        }
        *(unsigned char *)(a1 + 532) = v9;
        if (*(unsigned char *)(a1 + 533)) {
          char v10 = 1;
        }
        else {
          char v10 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 32))(v8);
        }
        *(unsigned char *)(a1 + 533) = v10;
        if (*(unsigned char *)(a1 + 534)) {
          char v11 = 1;
        }
        else {
          char v11 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 40))(v8);
        }
        *(unsigned char *)(a1 + 534) = v11;
        if (*(unsigned char *)(a1 + 535)) {
          uint64_t isStatisticCollectionEnabled = 1;
        }
        else {
          uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 48))(v8);
        }
        *(unsigned char *)(a1 + 535) = isStatisticCollectionEnabled;
      }
      uint64_t v6 = (void *)*v6;
    }
    while (v6);
  }
  if (*(unsigned char *)(a1 + 532))
  {
    uint64_t v12 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Processor needs events but event collection is disabled.", buf, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 533))
  {
    uint64_t isStatisticCollectionEnabled = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)isStatisticCollectionEnabled);
    if ((isStatisticCollectionEnabled & 1) == 0)
    {
      uint64_t v13 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
      uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (isStatisticCollectionEnabled)
      {
        *(_WORD *)uint64_t v18 = 0;
        _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "Processor needs statistics but statistic collection is disabled.", v18, 2u);
      }
    }
  }
  if (*(unsigned char *)(a1 + 534))
  {
    uint64_t v14 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_DEFAULT, "Processor needs attributions but attribution collection is disabled.", v17, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 535))
  {
    int v15 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v16 = 0;
      _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "Processor needs memory statistics but memory statistic collection is disabled.", v16, 2u);
    }
  }
  os_unfair_lock_unlock(v4);
}

void re::ProfilerManager::setProcessorEnabled<re::ProfilerCsvProcessor,void>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  *(_DWORD *)(a1 + 532) = 0;
  uint64_t isStatisticCollectionEnabled = re::ProfilerManager::getProcessorId<re::ProfilerCsvProcessor>();
  uint64_t v6 = *(void **)(a1 + 496);
  if (v6)
  {
    uint64_t v7 = isStatisticCollectionEnabled;
    do
    {
      long long v8 = (unsigned char *)v6[3];
      if (v6[2] == v7)
      {
        v8[8] = a2;
        uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *, uint64_t))(*(void *)v8 + 64))(v8, a2);
      }
      if (v8[8])
      {
        if (*(unsigned char *)(a1 + 532)) {
          char v9 = 1;
        }
        else {
          char v9 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 24))(v8);
        }
        *(unsigned char *)(a1 + 532) = v9;
        if (*(unsigned char *)(a1 + 533)) {
          char v10 = 1;
        }
        else {
          char v10 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 32))(v8);
        }
        *(unsigned char *)(a1 + 533) = v10;
        if (*(unsigned char *)(a1 + 534)) {
          char v11 = 1;
        }
        else {
          char v11 = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 40))(v8);
        }
        *(unsigned char *)(a1 + 534) = v11;
        if (*(unsigned char *)(a1 + 535)) {
          uint64_t isStatisticCollectionEnabled = 1;
        }
        else {
          uint64_t isStatisticCollectionEnabled = (*(uint64_t (**)(unsigned char *))(*(void *)v8 + 48))(v8);
        }
        *(unsigned char *)(a1 + 535) = isStatisticCollectionEnabled;
      }
      uint64_t v6 = (void *)*v6;
    }
    while (v6);
  }
  if (*(unsigned char *)(a1 + 532))
  {
    uint64_t v12 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Processor needs events but event collection is disabled.", buf, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 533))
  {
    uint64_t isStatisticCollectionEnabled = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)isStatisticCollectionEnabled);
    if ((isStatisticCollectionEnabled & 1) == 0)
    {
      uint64_t v13 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
      uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if (isStatisticCollectionEnabled)
      {
        *(_WORD *)uint64_t v18 = 0;
        _os_log_impl(&dword_233120000, v13, OS_LOG_TYPE_DEFAULT, "Processor needs statistics but statistic collection is disabled.", v18, 2u);
      }
    }
  }
  if (*(unsigned char *)(a1 + 534))
  {
    uint64_t v14 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    uint64_t isStatisticCollectionEnabled = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    if (isStatisticCollectionEnabled)
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_DEFAULT, "Processor needs attributions but attribution collection is disabled.", v17, 2u);
    }
  }
  if (*(unsigned char *)(a1 + 535))
  {
    int v15 = *re::foundationProfilingLogObjects((re *)isStatisticCollectionEnabled);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v16 = 0;
      _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "Processor needs memory statistics but memory statistic collection is disabled.", v16, 2u);
    }
  }
  os_unfair_lock_unlock(v4);
}

uint64_t re::ProfilerManager::getProcessor<re::ProfilerMiniHUDProcessor,void>(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  uint64_t v6 = re::ProfilerManager::getProcessorId<re::ProfilerMiniHUDProcessor>();
  uint64_t v3 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((void *)(a1 + 480), (unint64_t *)&v6);
  if (v3) {
    uint64_t v4 = v3[3];
  }
  else {
    uint64_t v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

void re::ServiceRegistry::add<re::DrawableQueueService>(uint64_t a1, void *a2, StringID *a3)
{
  uint64_t v3 = a2;
  uint64_t v5 = &qword_268772000;
  {
    uint64_t v7 = a3;
    uint64_t v5 = &qword_268772000;
    a3 = v7;
    uint64_t v3 = a2;
    if (v6)
    {
      re::introspect<re::DrawableQueueService>(void)::info = re::introspect_DrawableQueueService(0);
      uint64_t v5 = &qword_268772000;
      a3 = v7;
      uint64_t v3 = a2;
    }
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&v9, (const re::IntrospectionBase *)v5[230], a3, v3);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(a1 + 16, &v9);
  re::StringID::destroyString((re::StringID *)&v10);
}

void ___ZN2re6Engine4initERKNS_19EngineConfigurationE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 824);
  id v2 = (id)DRResourcesCommitCopyToXPC();
  re::ResourceSharingManager::pushDirectCommit(v1, v2);
}

void ___ZN2re6Engine4initERKNS_19EngineConfigurationE_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (DRResourcesCommitHasEvent())
  {
    uint64_t v5 = (void *)DRResourcesCommitCopyEventWithDevice();
    id v6 = v5;

    uint64_t Id = DRResourcesCommitGetId();
    long long v8 = *(NSObject **)(a1 + 32);
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3321888768;
    block[2] = ___ZN2re6Engine4initERKNS_19EngineConfigurationE_block_invoke_3;
    block[3] = &__block_descriptor_56_a8_32c34_ZTSN2re10ArcWeakPtrINS_6EngineEEE40c40_ZTSN2NS9SharedPtrIN3MTL11SharedEventEEE_e5_v8__0l;
    id v10 = 0;
    objc_copyWeak(&v10, (id *)(a1 + 48));
    id v11 = v5;
    uint64_t v12 = Id;
    dispatch_async(v8, block);
    if (v11)
    {

      id v11 = 0;
    }
    objc_destroyWeak(&v10);
    id v10 = 0;
    if (v5) {
  }
    }
}

void ___ZN2re6Engine4initERKNS_19EngineConfigurationE_block_invoke_3(id *a1)
{
  id WeakRetained = objc_loadWeakRetained(a1 + 4);
  if (WeakRetained)
  {
    uint64_t v3 = WeakRetained;
    uint64_t v4 = *(void *)(*((void *)WeakRetained + 104) + 104);
    id v5 = a1[5];
    id v6 = v5;
    re::DrawingManager::addFrameBeganSignal(v4, &v6, a1[6]);
    if (v5) {
  }
    }
}

id __copy_helper_block_a8_32c34_ZTSN2re10ArcWeakPtrINS_6EngineEEE40c40_ZTSN2NS9SharedPtrIN3MTL11SharedEventEEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = 0;
  uint64_t v3 = a1 + 32;
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  id result = *(id *)(a2 + 40);
  *(void *)(v3 + 8) = result;
  return result;
}

void __destroy_helper_block_a8_32c34_ZTSN2re10ArcWeakPtrINS_6EngineEEE40c40_ZTSN2NS9SharedPtrIN3MTL11SharedEventEEE(uint64_t a1)
{
  id v2 = *(void **)(a1 + 40);
  if (v2)
  {

    *(void *)(a1 + 40) = 0;
  }
  objc_destroyWeak((id *)(a1 + 32));
  *(void *)(a1 + 32) = 0;
}

void __copy_helper_block_a8_40c34_ZTSN2NS9SharedPtrIN3MTL6DeviceEEE48c34_ZTSN2re10ArcWeakPtrINS_6EngineEEE(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)(a2 + 40);
  *(void *)(a1 + 48) = 0;
  id v5 = (id *)(a1 + 48);
  *(v5 - 1) = v4;
  objc_copyWeak(v5, (id *)(a2 + 48));
}

void __destroy_helper_block_a8_40c34_ZTSN2NS9SharedPtrIN3MTL6DeviceEEE48c34_ZTSN2re10ArcWeakPtrINS_6EngineEEE(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 48));
  *(void *)(a1 + 48) = 0;
  id v2 = *(void **)(a1 + 40);
  if (v2)
  {

    *(void *)(a1 + 40) = 0;
  }
}

void re::Engine::setAcceptingInput(re::Engine *this, re::InputManager *a2)
{
  uint64_t v2 = *((void *)this + 112);
  if (v2)
  {
    if (a2)
    {
      id v4 = *((id *)this + 54);
      re::InputManager::subscribe(v2, &v4);
    }
    else
    {
      uint64_t v3 = (re::InputManager *)*((void *)this + 112);
      re::InputManager::unsubscribe(v3, a2);
    }
  }
}

uint64_t re::Engine::timeDidChange(re::Engine *a1, uint64_t a2)
{
  uint64_t v4 = *((void *)a1 + 117);
  if (v4)
  {
    *(void *)(v4 + 248) = 0;
    *(void *)(v4 + 2re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0;
    *(unsigned char *)(v4 + 264) = 0;
    *(std::chrono::steady_clock::time_point *)(v4 + 248) = std::chrono::steady_clock::now();
    *(unsigned char *)(v4 + 264) = 1;
  }
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v11, 1504, (uint64_t)a1);
  unsigned int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  if (v5 >= (*(unsigned int (**)(uint64_t))(*(void *)a2 + 64))(a2) - 1)
  {
    re::Engine::executePhase(a1, 1u);
    re::Engine::executePhase(a1, 2u);
  }
  re::Engine::executePhase(a1, 3u);
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a2 + 104))(a2))
  {
    re::Engine::executePhase(a1, 4u);
    re::Engine::executePhase(a1, 5u);
    re::Engine::executePhase(a1, 6u);
    re::Engine::executePhase(a1, 7u);
  }
  uint64_t v6 = *((void *)a1 + 117);
  if (v6)
  {
    v7.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    double v8 = 0.0;
    if (*(unsigned char *)(v6 + 264)) {
      double v8 = 1.0;
    }
    float v9 = (*(double *)(v6 + 256) + (double)(v7.__d_.__rep_ - *(void *)(v6 + 248)) / 1000000000.0 * v8) * 1000.0;
    *(float *)(v6 + 236) = v9;
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v11);
  return 0;
}

void ___ZN2re6Engine4initERKNS_19EngineConfigurationE_block_invoke_45(uint64_t a1)
{
  uint64_t v1 = *(re::Engine **)(a1 + 32);
  uint64_t v2 = (void *)MEMORY[0x237DBDCF0]();
  re::Engine::tick(v1);
}

uint64_t re::Engine::tick(re::Engine *this)
{
  CFTimeInterval v3 = CACurrentMediaTime();
  float v4 = v3 - *((double *)this + 147);
  *((CFTimeInterval *)this + 147) = v3;
  float v5 = 3600.0;
  if (v4 <= 3600.0) {
    float v5 = v4;
  }
  if (v4 < 0.0) {
    float v5 = 0.0;
  }
  return re::Engine::tick(this, v5, v2);
}

uint64_t re::Engine::configurePhases(uint64_t this)
{
  if (*(unsigned char *)(this + 24))
  {
    uint64_t v1 = this;
    memset(v3, 0, sizeof(v3));
    int v4 = 0;
    uint64_t v7 = 0;
    memset(v5, 0, sizeof(v5));
    int v6 = 0;
    re::Engine::configureEnterFramePhase(this, (uint64_t)v3);
    re::Engine::configurePreparePhase(v1, (uint64_t)v3);
    re::Engine::configureSimulatePhase(v1, (uint64_t)v3);
    re::Engine::configureCommitPhase(v1, (uint64_t)v3);
    re::Engine::configureRenderPhase(v1, (uint64_t)v3);
    re::Engine::configureEndTickPhase(v1, (uint64_t)v3);
    re::Engine::configureExitFramePhase((void *)v1, (uint64_t)v3);
    re::Scheduler::configure(*(_anonymous_namespace_ **)(v1 + 680), (unint64_t)v3);
    re::Engine::updateRaiseUpdateEventScheduleState((re::Engine *)v1);
    re::Engine::updateOutputDeviceFrameTaskSet(v1);
    uint64_t v2 = *(void *)(v1 + 680);
    if (v2) {
      re::Scheduler::setEnabled(v2, v1 + 336, *(unsigned __int8 *)(v1 + 408));
    }
    re::DynamicArray<re::Scheduler::TaskDescriptor>::deinit((uint64_t)v5 + 8);
    return re::DynamicArray<re::StringID>::deinit((uint64_t)v3);
  }
  return this;
}

re *re::internal::destroyPersistent<re::AnimationManager>(re *result, uint64_t a2, re::AnimationManager *a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    re::AnimationManager::~AnimationManager(a3);
    float v5 = *(uint64_t (**)(uint64_t, re::AnimationManager *))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

void re::Engine::configureEnterFramePhase(uint64_t a1, uint64_t a2)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v17 = 0x1A73B3E1A79F3CALL;
  uint64_t v18 = "Enter Frame";
  uint64_t v4 = re::Scheduler::ScheduleDescriptor::addPhase(a2, &v17);
  re::StringID::destroyString((re::StringID *)&v17);
  uint64_t v15 = v4;
  *(void *)(a1 + 40) = v4;
  uint64_t v17 = 0xBBDDDE49C7E29768;
  uint64_t v18 = "Enter Frame Profiling Begin";
  __int16 v19 = 1;
  int v20 = 0;
  char v21 = 0;
  __int16 v22 = 260;
  int v23 = 1023969417;
  char v24 = 0;
  uint64_t v28 = re::globalAllocators(v5)[2];
  uint64_t v29 = &v25;
  uint64_t v25 = &unk_26E6C7DB8;
  uint64_t v26 = a1;
  uint64_t v30 = v4;
  uint64_t v31 = 0;
  uint64_t v35 = 0;
  int v34 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v17);
  if (v31)
  {
    if (v35) {
      (*(void (**)(void))(*(void *)v31 + 40))();
    }
    uint64_t v35 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    uint64_t v31 = 0;
    ++v34;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v25);
  re::StringID::destroyString((re::StringID *)&v17);
  uint64_t v6 = *(void *)(a1 + 848);
  uint64_t v17 = 0xEEA8176B5CA41DF0;
  uint64_t v18 = "Increment Frame Counter";
  __int16 v19 = 1;
  int v20 = 0;
  char v21 = 0;
  __int16 v22 = 260;
  int v23 = 1023969417;
  char v24 = 0;
  uint64_t v8 = re::globalAllocators(v7)[2];
  uint64_t v27 = a1 + 1192;
  uint64_t v28 = v8;
  uint64_t v25 = &unk_26E6C7E10;
  uint64_t v26 = v6;
  uint64_t v29 = &v25;
  uint64_t v30 = v4;
  uint64_t v35 = 0;
  int v34 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v31 = 0;
  *(void *)(a1 + 104) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v17);
  if (v31)
  {
    if (v35) {
      (*(void (**)(void))(*(void *)v31 + 40))();
    }
    uint64_t v35 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    uint64_t v31 = 0;
    ++v34;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v25);
  re::StringID::destroyString((re::StringID *)&v17);
  int v10 = *(_DWORD *)(a1 + 424);
  if ((v10 & 0x100000) != 0)
  {
    uint64_t v11 = *(void *)(a1 + 928);
    uint64_t v17 = 0xA8BB4F263E93A12ALL;
    uint64_t v18 = "Notify Frame Analysis Frame Start";
    __int16 v19 = 1;
    int v20 = 0;
    char v21 = 0;
    __int16 v22 = 260;
    int v23 = 1023969417;
    char v24 = 0;
    uint64_t v28 = re::globalAllocators(v9)[2];
    uint64_t v29 = &v25;
    uint64_t v25 = &unk_26E6C7E68;
    uint64_t v26 = v11;
    uint64_t v30 = v4;
    uint64_t v31 = 0;
    uint64_t v35 = 0;
    int v34 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    *(void *)(a1 + ++*(void *)(this + 112) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v17);
    if (v31)
    {
      if (v35) {
        (*(void (**)(void))(*(void *)v31 + 40))();
      }
      uint64_t v35 = 0;
      uint64_t v32 = 0;
      uint64_t v33 = 0;
      uint64_t v31 = 0;
      ++v34;
    }
    re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v25);
    re::StringID::destroyString((re::StringID *)&v17);
    int v10 = *(_DWORD *)(a1 + 424);
  }
  if ((v10 & 0x100) != 0)
  {
    uint64_t v12 = *(void *)(a1 + 1136);
    v16[0] = &unk_26E6C8AC8;
    v16[1] = a1;
    uint64_t v16[2] = a2;
    v16[3] = v16;
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v12 + 72))(v12, &v15, v16);
    float v9 = (re *)std::__function::__value_func<void ()(re::Scheduler::TaskDescriptor)>::~__value_func[abi:nn180100](v16);
  }
  uint64_t v13 = *(void *)(a1 + 848);
  uint64_t v17 = 0x8120BAF859FB454CLL;
  uint64_t v18 = "Enter Frame Profiling End";
  __int16 v19 = 1;
  int v20 = 0;
  char v21 = 0;
  __int16 v22 = 260;
  int v23 = 1023969417;
  char v24 = 0;
  uint64_t v14 = re::globalAllocators(v9)[2];
  uint64_t v27 = a1;
  uint64_t v28 = v14;
  uint64_t v25 = &unk_26E6C7EC0;
  uint64_t v26 = v13;
  uint64_t v35 = 0;
  int v34 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v29 = &v25;
  uint64_t v30 = v15;
  uint64_t v31 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v17);
  if (v31)
  {
    if (v35) {
      (*(void (**)(void))(*(void *)v31 + 40))();
    }
    uint64_t v35 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    uint64_t v31 = 0;
    ++v34;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v25);
  re::StringID::destroyString((re::StringID *)&v17);
}

void re::Engine::configurePreparePhase(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  uint64_t v29 = 0x22A07D49CELL;
  uint64_t v30 = "Prepare";
  uint64_t v4 = re::Scheduler::ScheduleDescriptor::addPhase(a2, &v29);
  re::StringID::destroyString((re::StringID *)&v29);
  *(void *)(a1 + 48) = v4;
  uint64_t v29 = 0x7B2E133A3B21656CLL;
  uint64_t v30 = "Prepare Profiling Begin";
  __int16 v31 = 1;
  int v32 = 0;
  char v33 = 0;
  LOWORD(v34) = 260;
  HIDWORD(v34) = 1023969417;
  char v35 = 0;
  uint64_t v39 = re::globalAllocators(v5)[2];
  uint64_t v40 = &v36;
  uint64_t v36 = &unk_26E6C7F18;
  uint64_t v37 = a1;
  uint64_t v41 = v4;
  uint64_t v42 = 0;
  uint64_t v46 = 0;
  int v45 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v29);
  if (v42)
  {
    if (v46) {
      (*(void (**)(void))(*(void *)v42 + 40))();
    }
    uint64_t v46 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v42 = 0;
    ++v45;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v36);
  re::StringID::destroyString((re::StringID *)&v29);
  int v7 = *(_DWORD *)(a1 + 424);
  if ((v7 & 0x40) != 0)
  {
    uint64_t v8 = *(void *)(a1 + 896);
    uint64_t v29 = 0x3611AC122B14243ELL;
    uint64_t v30 = "Input Update";
    __int16 v31 = 1;
    int v32 = 0;
    char v33 = 0;
    LOWORD(v34) = 260;
    HIDWORD(v34) = 1023969417;
    char v35 = 0;
    uint64_t v39 = re::globalAllocators(v6)[2];
    uint64_t v40 = &v36;
    uint64_t v36 = &unk_26E6C7F70;
    uint64_t v37 = v8;
    uint64_t v41 = v4;
    uint64_t v42 = 0;
    uint64_t v46 = 0;
    int v45 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    *(void *)(a1 + 128) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v29);
    if (v42)
    {
      if (v46) {
        (*(void (**)(void))(*(void *)v42 + 40))();
      }
      uint64_t v46 = 0;
      uint64_t v43 = 0;
      uint64_t v44 = 0;
      uint64_t v42 = 0;
      ++v45;
    }
    re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v36);
    re::StringID::destroyString((re::StringID *)&v29);
    int v7 = *(_DWORD *)(a1 + 424);
  }
  if ((v7 & 0x104) != 0 && (v7 & 2) != 0)
  {
    uint64_t v9 = *(void *)(a1 + 1160);
    if (v9)
    {
      uint64_t v29 = 0x4005877381F5E22CLL;
      uint64_t v30 = "Shared Clock Update";
      __int16 v31 = 1;
      int v32 = 0;
      char v33 = 0;
      LOWORD(v34) = 260;
      HIDWORD(v34) = 1023969417;
      char v35 = 0;
      uint64_t v39 = re::globalAllocators(v6)[2];
      uint64_t v40 = &v36;
      uint64_t v36 = &unk_26E6C7FC8;
      uint64_t v37 = v9;
      uint64_t v41 = v4;
      uint64_t v42 = 0;
      uint64_t v46 = 0;
      int v45 = 0;
      uint64_t v43 = 0;
      uint64_t v44 = 0;
      *(void *)(a1 + 136) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v29);
      if (v42)
      {
        if (v46) {
          (*(void (**)(void))(*(void *)v42 + 40))();
        }
        uint64_t v46 = 0;
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        uint64_t v42 = 0;
        ++v45;
      }
      re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v36);
      re::StringID::destroyString((re::StringID *)&v29);
    }
    uint64_t v10 = *(void *)(a1 + 1152);
    if (v10)
    {
      uint64_t v29 = 0x874A02CC4DB88436;
      uint64_t v30 = "Timebase Before Frame Update";
      __int16 v31 = 1;
      int v32 = 0;
      char v33 = 0;
      LOWORD(v34) = 260;
      HIDWORD(v34) = 1023969417;
      char v35 = 0;
      uint64_t v39 = re::globalAllocators(v6)[2];
      uint64_t v40 = &v36;
      uint64_t v36 = &unk_26E6C8020;
      uint64_t v37 = v10;
      uint64_t v41 = v4;
      uint64_t v42 = 0;
      uint64_t v46 = 0;
      int v45 = 0;
      uint64_t v43 = 0;
      uint64_t v44 = 0;
      *(void *)(a1 + 144) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v29);
      if (v42)
      {
        if (v46) {
          (*(void (**)(void))(*(void *)v42 + 40))();
        }
        uint64_t v46 = 0;
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        uint64_t v42 = 0;
        ++v45;
      }
      re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v36);
      re::StringID::destroyString((re::StringID *)&v29);
    }
  }
  if ((*(unsigned char *)(a1 + 424) & 0x80) != 0)
  {
    uint64_t v11 = *(void *)(a1 + 856);
    if (v11)
    {
      uint64_t v29 = 0x691970AE8D5439D6;
      uint64_t v30 = "Network Before Frame Update";
      __int16 v31 = 1;
      int v32 = 0;
      char v33 = 0;
      LOWORD(v34) = 260;
      HIDWORD(v34) = 1023969417;
      char v35 = 0;
      uint64_t v39 = re::globalAllocators(v6)[2];
      uint64_t v40 = &v36;
      uint64_t v36 = &unk_26E6C8078;
      uint64_t v37 = v11;
      uint64_t v41 = v4;
      uint64_t v42 = 0;
      uint64_t v46 = 0;
      int v45 = 0;
      uint64_t v43 = 0;
      uint64_t v44 = 0;
      *(void *)(a1 + 152) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v29);
      if (v42)
      {
        if (v46) {
          (*(void (**)(void))(*(void *)v42 + 40))();
        }
        uint64_t v46 = 0;
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        uint64_t v42 = 0;
        ++v45;
      }
      re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v36);
      re::StringID::destroyString((re::StringID *)&v29);
    }
  }
  uint64_t v12 = *(void *)(a1 + 672);
  uint64_t v29 = 0x5D0715B967600FE4;
  uint64_t v30 = "Background Task Update";
  __int16 v31 = 1;
  int v32 = 0;
  char v33 = 0;
  LOWORD(v34) = 260;
  HIDWORD(v34) = 1023969417;
  char v35 = 0;
  uint64_t v39 = re::globalAllocators(v6)[2];
  uint64_t v40 = &v36;
  uint64_t v36 = &unk_26E6C80D0;
  uint64_t v37 = v12;
  uint64_t v41 = v4;
  uint64_t v42 = 0;
  uint64_t v46 = 0;
  int v45 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  *(void *)(a1 + 160) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v29);
  if (v42)
  {
    if (v46) {
      (*(void (**)(void))(*(void *)v42 + 40))();
    }
    uint64_t v46 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v42 = 0;
    ++v45;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v36);
  re::StringID::destroyString((re::StringID *)&v29);
  int v14 = *(_DWORD *)(a1 + 424);
  if ((v14 & 8) != 0)
  {
    uint64_t v17 = *(void *)(a1 + 744);
    uint64_t v29 = 0x308AF400B2139072;
    uint64_t v30 = "Asset Update";
    __int16 v31 = 1;
    int v32 = 0;
    char v33 = 0;
    uint64_t v34 = *(void *)(v17 + 1688);
    char v35 = *(unsigned char *)(v17 + 1696);
    uint64_t v39 = re::globalAllocators(v13)[2];
    uint64_t v40 = &v36;
    uint64_t v36 = &unk_26E6C8128;
    uint64_t v37 = v17;
    uint64_t v41 = v4;
    uint64_t v42 = 0;
    uint64_t v46 = 0;
    int v45 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v18 = re::Scheduler::ScheduleDescriptor::addTask(a2, &v29);
    if (v42)
    {
      if (v46) {
        (*(void (**)(void))(*(void *)v42 + 40))();
      }
      uint64_t v46 = 0;
      uint64_t v43 = 0;
      uint64_t v44 = 0;
      uint64_t v42 = 0;
      ++v45;
    }
    re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v36);
    re::StringID::destroyString((re::StringID *)&v29);
    *(void *)(a1 + 168) = v18;
    uint64_t v19 = *(void *)(a1 + 744);
    *(void *)(v19 + 1664) = *(void *)(a1 + 680);
    *(void *)(v19 + 1672) = v18;
    int v14 = *(_DWORD *)(a1 + 424);
    if ((v14 & 4) == 0)
    {
LABEL_38:
      if ((v14 & 2) == 0) {
        goto LABEL_40;
      }
      goto LABEL_39;
    }
  }
  else if ((v14 & 4) == 0)
  {
    goto LABEL_38;
  }
  uint64_t v20 = *(void *)(a1 + 664);
  uint64_t v21 = *(void *)(a1 + 728);
  uint64_t v29 = 0x1D1930259178F24ALL;
  uint64_t v30 = "Animation Update";
  uint64_t v22 = 112;
  do
  {
    int v23 = *(_DWORD *)(v21 + v22);
    if (v23) {
      break;
    }
    BOOL v24 = v22 == 176;
    v22 += 64;
  }
  while (!v24);
  __int16 v31 = v23 != 0;
  int v32 = 0;
  char v33 = 0;
  uint64_t v25 = *(void *)(v21 + 16);
  char v35 = *(unsigned char *)(v21 + 24);
  uint64_t v34 = v25;
  uint64_t v26 = re::globalAllocators(v13)[2];
  uint64_t v38 = v21;
  uint64_t v39 = v26;
  uint64_t v36 = &unk_26E6C8180;
  uint64_t v37 = v20;
  uint64_t v40 = &v36;
  uint64_t v41 = v4;
  uint64_t v46 = 0;
  int v45 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v42 = 0;
  uint64_t v27 = re::Scheduler::ScheduleDescriptor::addTask(a2, &v29);
  if (v42)
  {
    if (v46) {
      (*(void (**)(void))(*(void *)v42 + 40))();
    }
    uint64_t v46 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v42 = 0;
    ++v45;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v36);
  re::StringID::destroyString((re::StringID *)&v29);
  *(void *)(a1 + 176) = v27;
  uint64_t v28 = *(void *)(a1 + 728);
  *(void *)(v28 + 8) = *(void *)(a1 + 680);
  *(void *)(v28 + 32) = v27;
  if ((*(_DWORD *)(a1 + 424) & 2) != 0) {
LABEL_39:
  }
    re::ecs2::ECSManager::configurePreparePhase(*(re **)(a1 + 664), a2, v4);
LABEL_40:
  uint64_t v15 = *(void *)(a1 + 848);
  uint64_t v29 = 0x2239DAB9BBDDC450;
  uint64_t v30 = "Prepare Profiling End";
  __int16 v31 = 1;
  int v32 = 0;
  char v33 = 0;
  LOWORD(v34) = 260;
  HIDWORD(v34) = 1023969417;
  char v35 = 0;
  uint64_t v16 = re::globalAllocators(v13)[2];
  uint64_t v38 = a1;
  uint64_t v39 = v16;
  uint64_t v36 = &unk_26E6C81D8;
  uint64_t v37 = v15;
  uint64_t v40 = &v36;
  uint64_t v41 = v4;
  uint64_t v46 = 0;
  int v45 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v42 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v29);
  if (v42)
  {
    if (v46) {
      (*(void (**)(void))(*(void *)v42 + 40))();
    }
    uint64_t v46 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v42 = 0;
    ++v45;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v36);
  re::StringID::destroyString((re::StringID *)&v29);
}

void re::Engine::configureSimulatePhase(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v16 = 0x4544226CC88;
  uint64_t v17 = "Simulate";
  uint64_t v4 = re::Scheduler::ScheduleDescriptor::addPhase(a2, &v16);
  re::StringID::destroyString((re::StringID *)&v16);
  *(void *)(a1 + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = v4;
  uint64_t v16 = 0xD57EE63E48F23426;
  uint64_t v17 = "Simulate Profiling Begin";
  __int16 v18 = 1;
  int v19 = 0;
  char v20 = 0;
  __int16 v21 = 260;
  int v22 = 1023969417;
  char v23 = 0;
  uint64_t v27 = re::globalAllocators(v5)[2];
  uint64_t v28 = &v24;
  BOOL v24 = &unk_26E6C8230;
  uint64_t v25 = a1;
  uint64_t v29 = v4;
  uint64_t v30 = 0;
  uint64_t v34 = 0;
  int v33 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v16);
  if (v30)
  {
    if (v34) {
      (*(void (**)(void))(*(void *)v30 + 40))();
    }
    uint64_t v34 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v30 = 0;
    ++v33;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v24);
  re::StringID::destroyString((re::StringID *)&v16);
  uint64_t v16 = 0xAAFBCE219D0498AELL;
  uint64_t v17 = "Raise Update Event";
  __int16 v18 = 1;
  int v19 = 0;
  char v20 = 0;
  __int16 v21 = 260;
  int v22 = 1023969417;
  char v23 = 0;
  uint64_t v27 = re::globalAllocators(v6)[2];
  uint64_t v28 = &v24;
  BOOL v24 = &unk_26E6C8288;
  uint64_t v25 = a1;
  uint64_t v29 = v4;
  uint64_t v30 = 0;
  uint64_t v34 = 0;
  int v33 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  *(void *)(a1 + 200) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v16);
  if (v30)
  {
    if (v34) {
      (*(void (**)(void))(*(void *)v30 + 40))();
    }
    uint64_t v34 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v30 = 0;
    ++v33;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v24);
  re::StringID::destroyString((re::StringID *)&v16);
  int v8 = *(_DWORD *)(a1 + 424);
  if ((v8 & 0x8000) != 0)
  {
    uint64_t v9 = *(void *)(a1 + 880);
    uint64_t v16 = 0xD275FE6FB8A1FF7ELL;
    uint64_t v17 = "Throttle Service";
    __int16 v18 = 1;
    int v19 = 0;
    char v20 = 0;
    __int16 v21 = 260;
    int v22 = 1023969417;
    char v23 = 0;
    uint64_t v27 = re::globalAllocators(v7)[2];
    uint64_t v28 = &v24;
    BOOL v24 = &unk_26E6C82E0;
    uint64_t v25 = v9;
    uint64_t v29 = v4;
    uint64_t v30 = 0;
    uint64_t v34 = 0;
    int v33 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    *(void *)(a1 + 208) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v16);
    if (v30)
    {
      if (v34) {
        (*(void (**)(void))(*(void *)v30 + 40))();
      }
      uint64_t v34 = 0;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      uint64_t v30 = 0;
      ++v33;
    }
    re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v24);
    re::StringID::destroyString((re::StringID *)&v16);
    int v8 = *(_DWORD *)(a1 + 424);
  }
  if ((v8 & 2) != 0)
  {
    re::ecs2::ECSManager::configureSimulatePhase(*(void *)(a1 + 664), a2, v4);
    if ((*(unsigned char *)(a1 + 424) & 0x20) != 0 && !*(unsigned char *)(a1 + 625))
    {
      uint64_t v10 = *(void **)(a1 + 664);
      uint64_t v11 = *(void **)(a1 + 888);
      uint64_t v16 = 0x494D4D6493EA9B80;
      uint64_t v17 = "Physics Simulation";
      __int16 v18 = 1;
      int v19 = 0;
      char v20 = 1;
      __int16 v21 = 260;
      int v22 = 1023969417;
      char v23 = 0;
      uint64_t v27 = re::globalAllocators(v7)[2];
      uint64_t v12 = (void **)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v27 + 32))(v27, 32, 0);
      *uint64_t v12 = &unk_26E6C8338;
      v12[1] = v10;
      void v12[2] = v11;
      v12[3] = (void *)a1;
      uint64_t v28 = v12;
      uint64_t v29 = v4;
      uint64_t v34 = 0;
      int v33 = 0;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      uint64_t v30 = 0;
      uint64_t v13 = re::Scheduler::ScheduleDescriptor::addTask(a2, &v16);
      if (v30)
      {
        if (v34) {
          (*(void (**)(void))(*(void *)v30 + 40))();
        }
        uint64_t v34 = 0;
        uint64_t v31 = 0;
        uint64_t v32 = 0;
        uint64_t v30 = 0;
        ++v33;
      }
      re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v24);
      re::StringID::destroyString((re::StringID *)&v16);
      *(void *)(a1 + 216) = v13;
    }
  }
  uint64_t v14 = *(void *)(a1 + 848);
  uint64_t v16 = 0x8C9BF83F7726F98ALL;
  uint64_t v17 = "Simulate Profiling End";
  __int16 v18 = 1;
  int v19 = 0;
  char v20 = 0;
  __int16 v21 = 260;
  int v22 = 1023969417;
  char v23 = 0;
  uint64_t v15 = re::globalAllocators(v7)[2];
  uint64_t v26 = a1;
  uint64_t v27 = v15;
  BOOL v24 = &unk_26E6C8390;
  uint64_t v25 = v14;
  uint64_t v28 = &v24;
  uint64_t v29 = v4;
  uint64_t v34 = 0;
  int v33 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v30 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v16);
  if (v30)
  {
    if (v34) {
      (*(void (**)(void))(*(void *)v30 + 40))();
    }
    uint64_t v34 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v30 = 0;
    ++v33;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v24);
  re::StringID::destroyString((re::StringID *)&v16);
}

void re::Engine::configureCommitPhase(uint64_t a1, uint64_t a2)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  uint64_t v22 = 4048038574;
  char v23 = "Commit";
  uint64_t v4 = re::Scheduler::ScheduleDescriptor::addPhase(a2, &v22);
  re::StringID::destroyString((re::StringID *)&v22);
  uint64_t v20 = v4;
  *(void *)(a1 + 64) = v4;
  uint64_t v22 = 0x62A8C35CEECE864CLL;
  char v23 = "Commit Profiling Begin";
  __int16 v24 = 1;
  int v25 = 0;
  char v26 = 0;
  LOWORD(v27) = 260;
  HIDWORD(v27) = 1023969417;
  char v28 = 0;
  uint64_t v32 = re::globalAllocators(v5)[2];
  int v33 = &v29;
  uint64_t v29 = &unk_26E6C83E8;
  uint64_t v30 = a1;
  uint64_t v34 = v4;
  uint64_t v35 = 0;
  uint64_t v39 = 0;
  int v38 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v22);
  if (v35)
  {
    if (v39) {
      (*(void (**)(void))(*(void *)v35 + 40))();
    }
    uint64_t v39 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v35 = 0;
    ++v38;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v29);
  re::StringID::destroyString((re::StringID *)&v22);
  if (*(unsigned char *)(a1 + 576) && (*(unsigned char *)(a1 + 420) & 0x10) != 0 && (*(unsigned char *)(a1 + 424) & 8) != 0)
  {
    id v7 = *(id *)(a1 + 776);
    uint64_t v22 = 0x1AF7B461BE06DD12;
    char v23 = "DirectResource After Frame Update";
    __int16 v24 = 1;
    int v25 = 0;
    char v26 = 0;
    LOWORD(v27) = 260;
    HIDWORD(v27) = 1023969417;
    char v28 = 0;
    int v8 = (re *)v7;
    uint64_t v9 = re::globalAllocators(v8)[2];
    uint64_t v31 = v8;
    uint64_t v32 = v9;
    uint64_t v29 = &unk_26E6C8440;
    uint64_t v30 = a1;
    int v33 = &v29;
    uint64_t v34 = v4;
    uint64_t v39 = 0;
    int v38 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v35 = 0;
    *(void *)(a1 + 232) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v22);
    if (v35)
    {
      if (v39) {
        (*(void (**)(void))(*(void *)v35 + 40))();
      }
      uint64_t v39 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      uint64_t v35 = 0;
      ++v38;
    }
    re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v29);
    re::StringID::destroyString((re::StringID *)&v22);
  }
  int v10 = *(_DWORD *)(a1 + 424);
  if ((v10 & 2) != 0)
  {
    re::ecs2::ECSManager::configureCommitPhase(*(re **)(a1 + 664), a2, v4);
    int v10 = *(_DWORD *)(a1 + 424);
  }
  if ((~v10 & 0x18) != 0)
  {
    if ((v10 & 8) == 0) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 768);
    uint64_t v22 = 0xB6A9C34D18D9D762;
    char v23 = "Drawable Queue After Frame Update";
    __int16 v24 = 1;
    int v25 = 0;
    char v26 = 0;
    LOWORD(v27) = 260;
    HIDWORD(v27) = 1023969417;
    char v28 = 0;
    uint64_t v32 = re::globalAllocators(v6)[2];
    int v33 = &v29;
    uint64_t v29 = &unk_26E6C8498;
    uint64_t v30 = v11;
    uint64_t v34 = v4;
    uint64_t v35 = 0;
    uint64_t v39 = 0;
    int v38 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    *(void *)(a1 + 224) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v22);
    if (v35)
    {
      if (v39) {
        (*(void (**)(void))(*(void *)v35 + 40))();
      }
      uint64_t v39 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      uint64_t v35 = 0;
      ++v38;
    }
    re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v29);
    re::StringID::destroyString((re::StringID *)&v22);
    int v10 = *(_DWORD *)(a1 + 424);
    if ((v10 & 8) == 0)
    {
LABEL_17:
      if ((v10 & 0x80) == 0) {
        goto LABEL_36;
      }
      goto LABEL_29;
    }
  }
  uint64_t v12 = *(void *)(a1 + 744);
  uint64_t v22 = 0xFBA855DF8D4C94A0;
  char v23 = "Asset After Frame Update";
  __int16 v24 = 1;
  int v25 = 0;
  char v26 = 0;
  uint64_t v27 = *(void *)(v12 + 1688);
  char v28 = *(unsigned char *)(v12 + 1696);
  uint64_t v32 = re::globalAllocators(v6)[2];
  int v33 = &v29;
  uint64_t v29 = &unk_26E6C84F0;
  uint64_t v30 = v12;
  uint64_t v34 = v4;
  uint64_t v35 = 0;
  uint64_t v39 = 0;
  int v38 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v13 = re::Scheduler::ScheduleDescriptor::addTask(a2, &v22);
  if (v35)
  {
    if (v39) {
      (*(void (**)(void))(*(void *)v35 + 40))();
    }
    uint64_t v39 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v35 = 0;
    ++v38;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v29);
  re::StringID::destroyString((re::StringID *)&v22);
  *(void *)(a1 + 240) = v13;
  *(void *)(*(void *)(a1 + 744) + 1680) = v13;
  int v10 = *(_DWORD *)(a1 + 424);
  if ((v10 & 0x80) != 0)
  {
LABEL_29:
    uint64_t v14 = *(void *)(a1 + 856);
    if (v14 && *(void *)(v14 + 2416))
    {
      uint64_t v22 = 0xB96777787FFDBCA4;
      char v23 = "Network After Frame Update";
      __int16 v24 = 1;
      int v25 = 0;
      char v26 = 0;
      LOWORD(v27) = 260;
      HIDWORD(v27) = 1023969417;
      char v28 = 0;
      uint64_t v32 = re::globalAllocators(v6)[2];
      int v33 = &v29;
      uint64_t v29 = &unk_26E6C8548;
      uint64_t v30 = v14;
      uint64_t v34 = v4;
      uint64_t v35 = 0;
      uint64_t v39 = 0;
      int v38 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      *(void *)(a1 + 248) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v22);
      if (v35)
      {
        if (v39) {
          (*(void (**)(void))(*(void *)v35 + 40))();
        }
        uint64_t v39 = 0;
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        uint64_t v35 = 0;
        ++v38;
      }
      re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v29);
      re::StringID::destroyString((re::StringID *)&v22);
      int v10 = *(_DWORD *)(a1 + 424);
    }
  }
LABEL_36:
  if ((v10 & 0x104) != 0 && (v10 & 2) != 0)
  {
    uint64_t v15 = *(void *)(a1 + 1152);
    if (v15)
    {
      uint64_t v22 = 0xB21EB5FD96B6A644;
      char v23 = "Timebase After Frame Update";
      __int16 v24 = 1;
      int v25 = 0;
      char v26 = 0;
      LOWORD(v27) = 260;
      HIDWORD(v27) = 1023969417;
      char v28 = 0;
      uint64_t v32 = re::globalAllocators(v6)[2];
      int v33 = &v29;
      uint64_t v29 = &unk_26E6C85A0;
      uint64_t v30 = v15;
      uint64_t v34 = v4;
      uint64_t v35 = 0;
      uint64_t v39 = 0;
      int v38 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      *(void *)(a1 + 2re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v22);
      if (v35)
      {
        if (v39) {
          (*(void (**)(void))(*(void *)v35 + 40))();
        }
        uint64_t v39 = 0;
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        uint64_t v35 = 0;
        ++v38;
      }
      re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v29);
      re::StringID::destroyString((re::StringID *)&v22);
      int v10 = *(_DWORD *)(a1 + 424);
    }
  }
  if ((v10 & 0x100) != 0)
  {
    uint64_t v16 = *(void *)(a1 + 1136);
    v21[0] = &unk_26E6C8B58;
    v21[1] = a1;
    v21[2] = a2;
    v21[3] = v21;
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 80))(v16, &v20, v21);
    uint64_t v6 = (re *)std::__function::__value_func<void ()(re::Scheduler::TaskDescriptor)>::~__value_func[abi:nn180100](v21);
    int v10 = *(_DWORD *)(a1 + 424);
  }
  if ((~v10 & 0x100010) == 0)
  {
    uint64_t v17 = *(void *)(a1 + 928);
    if (v17)
    {
      uint64_t v22 = 0xC8CF523D8AC5AC22;
      char v23 = "Frame Analysis after frame Update";
      __int16 v24 = 1;
      int v25 = 0;
      char v26 = 0;
      LOWORD(v27) = 260;
      HIDWORD(v27) = 1023969417;
      char v28 = 0;
      uint64_t v32 = re::globalAllocators(v6)[2];
      int v33 = &v29;
      uint64_t v29 = &unk_26E6C85F8;
      uint64_t v30 = v17;
      uint64_t v34 = v20;
      uint64_t v35 = 0;
      uint64_t v39 = 0;
      int v38 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      *(void *)(a1 + 272) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v22);
      if (v35)
      {
        if (v39) {
          (*(void (**)(void))(*(void *)v35 + 40))();
        }
        uint64_t v39 = 0;
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        uint64_t v35 = 0;
        ++v38;
      }
      re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v29);
      re::StringID::destroyString((re::StringID *)&v22);
      int v10 = *(_DWORD *)(a1 + 424);
    }
  }
  if ((v10 & 0x12) != 0)
  {
    uint64_t v22 = 0xCA668105099A87ECLL;
    char v23 = "ColorManager After Frame Update";
    __int16 v24 = 1;
    int v25 = 0;
    char v26 = 0;
    LOWORD(v27) = 260;
    HIDWORD(v27) = 1023969417;
    char v28 = 0;
    uint64_t v32 = re::globalAllocators(v6)[2];
    int v33 = &v29;
    uint64_t v29 = &unk_26E6C8650;
    uint64_t v30 = a1;
    uint64_t v34 = v20;
    uint64_t v35 = 0;
    uint64_t v39 = 0;
    int v38 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    *(void *)(a1 + 280) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v22);
    if (v35)
    {
      if (v39) {
        (*(void (**)(void))(*(void *)v35 + 40))();
      }
      uint64_t v39 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      uint64_t v35 = 0;
      ++v38;
    }
    re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v29);
    re::StringID::destroyString((re::StringID *)&v22);
  }
  uint64_t v18 = *(void *)(a1 + 848);
  uint64_t v22 = 0xBFA2F07C801D9D30;
  char v23 = "Commit Profiling End";
  __int16 v24 = 1;
  int v25 = 0;
  char v26 = 0;
  LOWORD(v27) = 260;
  HIDWORD(v27) = 1023969417;
  char v28 = 0;
  uint64_t v19 = re::globalAllocators(v6)[2];
  uint64_t v31 = (re *)a1;
  uint64_t v32 = v19;
  uint64_t v29 = &unk_26E6C86A8;
  uint64_t v30 = v18;
  uint64_t v39 = 0;
  int v38 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  int v33 = &v29;
  uint64_t v34 = v20;
  uint64_t v35 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v22);
  if (v35)
  {
    if (v39) {
      (*(void (**)(void))(*(void *)v35 + 40))();
    }
    uint64_t v39 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v35 = 0;
    ++v38;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v29);
  re::StringID::destroyString((re::StringID *)&v22);
}

void re::Engine::configureRenderPhase(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v8 = 0x123605B6CLL;
  uint64_t v9 = "Render";
  uint64_t v4 = re::Scheduler::ScheduleDescriptor::addPhase(a2, &v8);
  re::StringID::destroyString((re::StringID *)&v8);
  *(void *)(a1 + 72) = v4;
  uint64_t v5 = *(void *)(a1 + 952);
  uint64_t v8 = 0xF32E3A1A8997B0ALL;
  uint64_t v9 = "Render Profiling Begin";
  __int16 v10 = 1;
  int v11 = 0;
  char v12 = 0;
  __int16 v13 = 260;
  int v14 = 1023969417;
  char v15 = 0;
  uint64_t v18 = re::globalAllocators(v6)[2];
  uint64_t v19 = &v16;
  uint64_t v16 = &unk_26E6C8700;
  uint64_t v17 = v5;
  uint64_t v20 = v4;
  uint64_t v21 = 0;
  uint64_t v25 = 0;
  int v24 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v8);
  if (v21)
  {
    if (v25) {
      (*(void (**)(void))(*(void *)v21 + 40))();
    }
    uint64_t v25 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v21 = 0;
    ++v24;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v16);
  re::StringID::destroyString((re::StringID *)&v8);
  if ((*(unsigned char *)(a1 + 424) & 0x10) != 0)
  {
    uint64_t v8 = 0x39632A79442;
    uint64_t v9 = "DoRender";
    __int16 v10 = 1;
    int v11 = 0;
    char v12 = 0;
    __int16 v13 = 260;
    int v14 = 1023969417;
    char v15 = 0;
    uint64_t v18 = re::globalAllocators(v7)[2];
    uint64_t v19 = &v16;
    uint64_t v16 = &unk_26E6C8758;
    uint64_t v17 = a1;
    uint64_t v20 = v4;
    uint64_t v21 = 0;
    uint64_t v25 = 0;
    int v24 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    *(void *)(a1 + 288) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v8);
    if (v21)
    {
      if (v25) {
        (*(void (**)(void))(*(void *)v21 + 40))();
      }
      uint64_t v25 = 0;
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      uint64_t v21 = 0;
      ++v24;
    }
    re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v16);
    re::StringID::destroyString((re::StringID *)&v8);
  }
  uint64_t v8 = 0xF32E3A1A8997B0ALL;
  uint64_t v9 = "Render Profiling Begin";
  __int16 v10 = 1;
  int v11 = 0;
  char v12 = 0;
  __int16 v13 = 260;
  int v14 = 1023969417;
  char v15 = 0;
  uint64_t v18 = re::globalAllocators(v7)[2];
  uint64_t v19 = &v16;
  uint64_t v16 = &unk_26E6C87B0;
  uint64_t v25 = 0;
  int v24 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v20 = v4;
  uint64_t v21 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v8);
  if (v21)
  {
    if (v25) {
      (*(void (**)(void))(*(void *)v21 + 40))();
    }
    uint64_t v25 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v21 = 0;
    ++v24;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v16);
  re::StringID::destroyString((re::StringID *)&v8);
}

void re::Engine::configureEndTickPhase(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v7 = 0x3A2CE5BC404;
  uint64_t v8 = "End Tick";
  uint64_t v4 = re::Scheduler::ScheduleDescriptor::addPhase(a2, &v7);
  re::StringID::destroyString((re::StringID *)&v7);
  *(void *)(a1 + 80) = v4;
  uint64_t v7 = 0xC9DEE6B0E4A0B3A2;
  uint64_t v8 = "End Tick Profiling Begin";
  __int16 v9 = 1;
  int v10 = 0;
  char v11 = 0;
  __int16 v12 = 260;
  int v13 = 1023969417;
  char v14 = 0;
  uint64_t v17 = re::globalAllocators(v5)[2];
  uint64_t v18 = &v15;
  char v15 = &unk_26E6C8808;
  uint64_t v16 = a1;
  uint64_t v19 = v4;
  uint64_t v20 = 0;
  uint64_t v24 = 0;
  int v23 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v7);
  if (v20)
  {
    if (v24) {
      (*(void (**)(void))(*(void *)v20 + 40))();
    }
    uint64_t v24 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v20 = 0;
    ++v23;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v15);
  re::StringID::destroyString((re::StringID *)&v7);
  if (*(_DWORD *)(a1 + 472) == 1)
  {
    uint64_t v7 = 0x50005DFB508F214ALL;
    uint64_t v8 = "Schedule Continuous Tick";
    __int16 v9 = 1;
    int v10 = 0;
    char v11 = 0;
    __int16 v12 = 259;
    int v13 = 1023969417;
    char v14 = 0;
    uint64_t v17 = re::globalAllocators(v6)[2];
    uint64_t v18 = &v15;
    char v15 = &unk_26E6C8860;
    uint64_t v16 = a1;
    uint64_t v19 = v4;
    uint64_t v20 = 0;
    uint64_t v24 = 0;
    int v23 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    *(void *)(a1 + 296) = re::Scheduler::ScheduleDescriptor::addTask(a2, &v7);
    if (v20)
    {
      if (v24) {
        (*(void (**)(void))(*(void *)v20 + 40))();
      }
      uint64_t v24 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64_t v20 = 0;
      ++v23;
    }
    re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v15);
    re::StringID::destroyString((re::StringID *)&v7);
  }
  uint64_t v7 = 0x7D9AB786E06D5540;
  uint64_t v8 = "Exit Tick Profiling End";
  __int16 v9 = 1;
  int v10 = 0;
  char v11 = 0;
  __int16 v12 = 260;
  int v13 = 1023969417;
  char v14 = 0;
  uint64_t v17 = re::globalAllocators(v6)[2];
  uint64_t v18 = &v15;
  char v15 = &unk_26E6C88B8;
  uint64_t v16 = a1;
  uint64_t v19 = v4;
  uint64_t v20 = 0;
  uint64_t v24 = 0;
  int v23 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v7);
  if (v20)
  {
    if (v24) {
      (*(void (**)(void))(*(void *)v20 + 40))();
    }
    uint64_t v24 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v20 = 0;
    ++v23;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v15);
  re::StringID::destroyString((re::StringID *)&v7);
}

void re::Engine::configureExitFramePhase(void *a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v9 = 0xDB60E4C7127D6;
  int v10 = "Exit Frame";
  uint64_t v4 = re::Scheduler::ScheduleDescriptor::addPhase(a2, &v9);
  re::StringID::destroyString((re::StringID *)&v9);
  a1[11] = v4;
  uint64_t v9 = 0x260FC32374E83374;
  int v10 = "Exit Frame Profiling Begin";
  __int16 v11 = 1;
  int v12 = 0;
  char v13 = 0;
  __int16 v14 = 260;
  int v15 = 1023969417;
  char v16 = 0;
  uint64_t v19 = re::globalAllocators(v5)[2];
  uint64_t v20 = &v17;
  uint64_t v17 = &unk_26E6C8910;
  uint64_t v18 = a1;
  uint64_t v21 = v4;
  uint64_t v22 = 0;
  uint64_t v26 = 0;
  int v25 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v9);
  if (v22)
  {
    if (v26) {
      (*(void (**)(void))(*(void *)v22 + 40))();
    }
    uint64_t v26 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = 0;
    ++v25;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v17);
  re::StringID::destroyString((re::StringID *)&v9);
  uint64_t v7 = (void *)a1[117];
  if (v7)
  {
    uint64_t v9 = 0x47C2C45EE134F02;
    int v10 = "End Frame Profiler";
    __int16 v11 = 1;
    int v12 = 0;
    char v13 = 0;
    __int16 v14 = 260;
    int v15 = 1023969417;
    char v16 = 0;
    uint64_t v19 = re::globalAllocators(v6)[2];
    uint64_t v20 = &v17;
    uint64_t v17 = &unk_26E6C8968;
    uint64_t v18 = v7;
    uint64_t v21 = v4;
    uint64_t v22 = 0;
    uint64_t v26 = 0;
    int v25 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    a1[38] = re::Scheduler::ScheduleDescriptor::addTask(a2, &v9);
    if (v22)
    {
      if (v26) {
        (*(void (**)(void))(*(void *)v22 + 40))();
      }
      uint64_t v26 = 0;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      uint64_t v22 = 0;
      ++v25;
    }
    re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v17);
    re::StringID::destroyString((re::StringID *)&v9);
  }
  if (a1[83])
  {
    uint64_t v9 = 0x9027F98B17907458;
    int v10 = "Exit Frame Profiling End";
    __int16 v11 = 1;
    int v12 = 0;
    char v13 = 0;
    __int16 v14 = 260;
    int v15 = 1023969417;
    char v16 = 0;
    uint64_t v19 = re::globalAllocators(v6)[2];
    uint64_t v20 = &v17;
    uint64_t v17 = &unk_26E6C89C0;
    uint64_t v18 = a1;
    uint64_t v21 = v4;
    uint64_t v22 = 0;
    uint64_t v26 = 0;
    int v25 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    a1[39] = re::Scheduler::ScheduleDescriptor::addTask(a2, &v9);
  }
  else
  {
    uint64_t v9 = 0x9027F98B17907458;
    int v10 = "Exit Frame Profiling End";
    __int16 v11 = 1;
    int v12 = 0;
    char v13 = 0;
    __int16 v14 = 260;
    int v15 = 1023969417;
    char v16 = 0;
    uint64_t v19 = re::globalAllocators(v6)[2];
    uint64_t v20 = &v17;
    uint64_t v17 = &unk_26E6C8A18;
    uint64_t v18 = a1;
    uint64_t v21 = v4;
    uint64_t v22 = 0;
    uint64_t v26 = 0;
    int v25 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    re::Scheduler::ScheduleDescriptor::addTask(a2, &v9);
  }
  if (v22)
  {
    if (v26) {
      (*(void (**)(void))(*(void *)v22 + 40))();
    }
    uint64_t v26 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = 0;
    ++v25;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v17);
  re::StringID::destroyString((re::StringID *)&v9);
  uint64_t v9 = 0x966E2F48F8574292;
  int v10 = "Reset Target Display Time";
  __int16 v11 = 1;
  int v12 = 0;
  char v13 = 0;
  __int16 v14 = 260;
  int v15 = 1023969417;
  char v16 = 0;
  uint64_t v19 = re::globalAllocators(v8)[2];
  uint64_t v20 = &v17;
  uint64_t v17 = &unk_26E6C8A70;
  uint64_t v18 = a1;
  uint64_t v21 = v4;
  uint64_t v22 = 0;
  uint64_t v26 = 0;
  int v25 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  re::Scheduler::ScheduleDescriptor::addTask(a2, &v9);
  if (v22)
  {
    if (v26) {
      (*(void (**)(void))(*(void *)v22 + 40))();
    }
    uint64_t v26 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = 0;
    ++v25;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)&v17);
  re::StringID::destroyString((re::StringID *)&v9);
}

re::EventBus::EventInfo *re::Engine::updateRaiseUpdateEventScheduleState(re::Engine *this)
{
  id result = (re::EventBus::EventInfo *)*((void *)this + 85);
  if (result)
  {
    unint64_t v3 = *((void *)this + 25);
    BOOL v4 = re::Scheduler::taskScheduleType(result, v3) == 4;
    uint64_t v5 = *((void *)this + 153);
    uint64_t v6 = *((void *)this + 173);
    updated = re::EventBus::subscriptionCountInternal<re::Engine,REEngineDoUpdateEvent>(v6, (unint64_t)this, 0);
    id result = re::EventBus::subscriptionCountInternal<re::Engine,REEngineDoUpdateEvent>(v6, 0, 0);
    if (((v4 ^ ((re::EventBus::EventInfo *)((char *)result + (void)updated + v5) != 0)) & 1) == 0)
    {
      uint64_t v8 = -((uint64_t)result + (void)updated);
      uint64_t v9 = (re::Scheduler *)*((void *)this + 85);
      if (v5 == v8)
      {
        return re::Scheduler::updateTaskSchedule(v9, v3, 4);
      }
      else
      {
        return (re::EventBus::EventInfo *)re::Scheduler::setTaskOptions(v9, v3, (float *)this + 80);
      }
    }
  }
  return result;
}

uint64_t re::Engine::updateOutputDeviceFrameTaskSet(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = this + 336;
  int v3 = *(_DWORD *)(this + 352);
  if (v3) {
    BOOL v4 = (void *)(this + 360);
  }
  else {
    BOOL v4 = *(void **)(this + 368);
  }
  uint64_t v5 = *(void *)(this + 344);
  uint64_t v6 = this + 360;
  while (1)
  {
    uint64_t v7 = this + 360;
    if ((v3 & 1) == 0) {
      uint64_t v7 = *(void *)(this + 368);
    }
    if (v4 == (void *)(v7 + 8 * v5)) {
      break;
    }
    *v4++ = 0;
    int v3 = *(_DWORD *)(this + 352);
  }
  uint64_t v8 = *(void *)(this + 680);
  if (v8)
  {
    unint64_t v9 = *(void *)(v8 + 40);
    unint64_t v10 = *(void *)(this + 400);
    if ((v9 & 0x3F) != 0) {
      unint64_t v11 = (v9 >> 6) + 1;
    }
    else {
      unint64_t v11 = v9 >> 6;
    }
    *(void *)(this + 400) = v9;
    v19[0] = 0;
    re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)(this + 336), v11, v19);
    if (v9) {
      BOOL v12 = v10 > v9;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12)
    {
      uint64_t v13 = 63;
      uint64_t v14 = *(void *)(v1 + 400) & 0x3FLL;
      if (v14)
      {
        BOOL v15 = v14 == 63;
        uint64_t v16 = -1 << v14;
        if (!v15) {
          uint64_t v13 = ~v16;
        }
      }
      if ((*(unsigned char *)(v1 + 352) & 1) == 0) {
        uint64_t v6 = *(void *)(v1 + 368);
      }
      *(void *)(v6 + 8 * *(void *)(v1 + 344) - 8) &= v13;
    }
    for (uint64_t i = 0; i != 7; ++i)
    {
      unint64_t v18 = *(void *)(v1 + 8 * re::Engine::kOutputDeviceFrameTasks[i] + 104);
      if (v18 < v9) {
        re::DynamicBitset<unsigned long long,256ul>::setBit(v2, v18);
      }
    }
    this = *(void *)(v1 + 664);
    if (this)
    {
      re::ecs2::ECSManager::outputDeviceSystemTasks(this, (uint64_t)v19);
      re::DynamicBitset<unsigned long long,256ul>::orWithBitSet(v2, (uint64_t)v19);
      this = v19[0];
      if (v19[0])
      {
        if ((v20 & 1) == 0) {
          return (*(uint64_t (**)(void))(*(void *)v19[0] + 40))();
        }
      }
    }
  }
  return this;
}

uint64_t re::Engine::tick(re::Engine *this, float a2, uint64_t a3)
{
  if (*((int *)this + 300) >= 1)
  {
    re::internal::assertLog((re::internal *)4, a3, "assertion failure: '%s' (%s:line %i) Invalid nested engine tick", "!isInsideTick()", "tick", 1661);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v3 = *((void *)this + 114);
    return re::ManualClock::update(v3, a2, a3);
  }
  return result;
}

uint64_t re::Engine::setPreferredFramesPerSecond(uint64_t this, float a2)
{
  *(float *)(this + 1168) = a2;
  if (!*(_DWORD *)(this + 472))
  {
    uint64_t v2 = this;
    uint64_t v3 = *(void *)(this + 912);
    if (a2 <= 0.0)
    {
      this = [*(id *)(v3 + 144) setPreferredFramesPerSecond:60];
      if ((*(unsigned char *)(v2 + 424) & 0x10) == 0) {
        return this;
      }
      uint64_t v4 = *(void *)(*(void *)(v2 + 840) + 104);
      if (!v4) {
        return this;
      }
      float v5 = 60.0;
    }
    else
    {
      this = [*(id *)(v3 + 144) setPreferredFramesPerSecond:llroundf(a2)];
      if ((*(unsigned char *)(v2 + 424) & 0x10) == 0) {
        return this;
      }
      uint64_t v4 = *(void *)(*(void *)(v2 + 840) + 104);
      if (!v4) {
        return this;
      }
      float v5 = roundf(*(float *)(v2 + 1168));
    }
    *(float *)(v4 + 1760) = v5;
  }
  return this;
}

void re::Engine::doUpdate(re::EventBus **this, float a2)
{
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)this);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v6 = re::profilerThreadContext(isStatisticCollectionEnabled);
    if (*(void *)(v6 + 152)) {
      uint64_t v2 = mach_absolute_time();
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v15, 1510, (uint64_t)this);
  re::Event<re::Engine>::raise((uint64_t)(this + 151), (uint64_t)this);
  uint64_t v7 = this[173];
  float v14 = a2;
  uint64_t Type = re::EventBus::getTypeId<REEngineDoUpdateEvent>();
  re::EventBus::publish(v7, (uint64_t)this, Type, (uint64_t)&v14, 4uLL, 0);
  re::Engine::updateRaiseUpdateEventScheduleState((re::Engine *)this);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v15);
  if (v6)
  {
    if (*(void *)(v6 + 152))
    {
      uint64_t v9 = mach_absolute_time();
      unint64_t v10 = *(int64x2_t **)(v6 + 152);
      if (v10)
      {
        uint64_t v11 = v10[76].u64[0];
        if (v11 >= v9 - v2) {
          uint64_t v11 = v9 - v2;
        }
        v10[76].i64[0] = v11;
        uint64_t v12 = v10[76].u64[1];
        if (v12 <= v9 - v2) {
          uint64_t v12 = v9 - v2;
        }
        v10[76].i64[1] = v12;
        int64x2_t v13 = vdupq_n_s64(1uLL);
        v13.i64[0] = v9 - v2;
        v10[77] = vaddq_s64(v10[77], v13);
        *(unsigned char *)(v6 + 184) = 0;
      }
    }
  }
}

void re::Event<re::Engine>::raise(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(void *)(a1 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 32 * v5 + 24))(a2) == 1) {
        re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((void *)a1, v5);
      }
      else {
        ++v5;
      }
    }
    while (v5 < *(void *)(a1 + 16));
    int v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    uint64_t v6 = *(void *)(a1 + 56);
    if (v6)
    {
      uint64_t v7 = 0;
      for (unint64_t i = 0; i != v6; ++i)
      {
        unint64_t v9 = *(void *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v15 = 136315906;
          uint64_t v16 = "operator[]";
          __int16 v17 = 1024;
          int v18 = 789;
          __int16 v19 = 2048;
          unint64_t v20 = i;
          __int16 v21 = 2048;
          unint64_t v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v10 = *(void *)(a1 + 72) + v7;
        uint64_t v11 = *(void *)(v10 + 32);
        long long v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        uint64_t v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf(a1, (void *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0])) {
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
          }
        }
        else
        {
          re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStable((void *)a1, (void *)v13 + 1);
        }
        v7 += 40;
      }
    }
  }
}

int64x2_t re::Engine::doRender(re::Engine *this)
{
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(this);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v4 = re::profilerThreadContext(isStatisticCollectionEnabled);
    if (*(void *)(v4 + 152)) {
      uint64_t v1 = mach_absolute_time();
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v14, 5000, *((void *)this + 105));
  *(unsigned char *)(*((void *)this + 117) + 296) = 1;
  re::Event<re::Engine>::raise((uint64_t)this + 1296, (uint64_t)this);
  unint64_t v5 = (re::EventBus *)*((void *)this + 173);
  float v13 = (*(float (**)(void))(**((void **)this + 115) + 56))(*((void *)this + 115));
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74C18, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF74C18))
  {
    qword_26AF74C10 = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"21REEngineDoRenderEvent" & 0x7FFFFFFFFFFFFFFFLL), v12);
    __cxa_guard_release(&qword_26AF74C18);
  }
  re::EventBus::publish(v5, (uint64_t)this, qword_26AF74C10, (uint64_t)&v13, 4uLL, 0);
  *(unsigned char *)(*((void *)this + 117) + 296) = 0;
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v14);
  if (v4)
  {
    if (*(void *)(v4 + 152))
    {
      uint64_t v7 = mach_absolute_time();
      uint64_t v8 = *(int64x2_t **)(v4 + 152);
      if (v8)
      {
        uint64_t v9 = v8[40].u64[0];
        if (v9 >= v7 - v1) {
          uint64_t v9 = v7 - v1;
        }
        v8[40].i64[0] = v9;
        uint64_t v10 = v8[40].u64[1];
        if (v10 <= v7 - v1) {
          uint64_t v10 = v7 - v1;
        }
        v8[40].i64[1] = v10;
        int64x2_t v11 = vdupq_n_s64(1uLL);
        v11.i64[0] = v7 - v1;
        int64x2_t result = vaddq_s64(v8[41], v11);
        v8[41] = result;
        *(unsigned char *)(v4 + 184) = 0;
      }
    }
  }
  return result;
}

uint64_t re::Scheduler::ScheduleDescriptor::addPhase(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  unint64_t v5 = *(void *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 16);
  if (v6 >= v5)
  {
    unint64_t v7 = v6 + 1;
    if (v5 < v6 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v8 = 2 * v5;
        BOOL v9 = v5 == 0;
        unint64_t v10 = 8;
        if (!v9) {
          unint64_t v10 = v8;
        }
        if (v10 <= v7) {
          unint64_t v11 = v7;
        }
        else {
          unint64_t v11 = v10;
        }
        re::DynamicArray<re::StringID>::setCapacity((void *)a1, v11);
      }
      else
      {
        re::DynamicArray<re::StringID>::setCapacity((void *)a1, v7);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v6 = *(void *)(a1 + 16);
  }
  long long v12 = (void *)(*(void *)(a1 + 32) + 16 * v6);
  *long long v12 = v4;
  v12[1] = v3;
  v15[0] = 0;
  v15[1] = "";
  uint64_t v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v13 + 1;
  ++*(_DWORD *)(a1 + 24);
  re::StringID::destroyString((re::StringID *)v15);
  return v13;
}

uint64_t re::Scheduler::ScheduleDescriptor::addTask(uint64_t a1, uint64_t *a2)
{
  if (a2[9])
  {
    re::DynamicArray<re::Scheduler::TaskDescriptor>::add((_anonymous_namespace_ *)(a1 + 40), a2);
    return *(void *)(a1 + 56) - 1;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Task Descriptor does not contain an update function", "taskDescriptor.taskFunction", "addTask", 148);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::Engine::enableHackedAutoDisableOutputSystemsCode(uint64_t this)
{
  *(unsigned char *)(this + 409) = 1;
  if (*(unsigned char *)(this + 408))
  {
    *(unsigned char *)(this + 408) = 0;
    if (*(void *)(this + 680)) {
      return re::Scheduler::setEnabled(*(void *)(this + 680), this + 336, 0);
    }
  }
  return this;
}

re::Scheduler *re::Engine::setRaiseUpdateEventFrameTaskOptions(uint64_t a1, float *a2)
{
  uint64_t result = *(re::Scheduler **)(a1 + 680);
  if (result)
  {
    unint64_t v5 = *(void *)(a1 + 200);
    uint64_t result = (re::Scheduler *)re::Scheduler::taskScheduleType(result, v5);
    if (result == *(unsigned __int8 *)(a1 + 320)) {
      uint64_t result = (re::Scheduler *)re::Scheduler::setTaskOptions(*(re::Scheduler **)(a1 + 680), v5, a2);
    }
  }
  uint64_t v6 = *(void *)a2;
  *(unsigned char *)(a1 + 328) = *((unsigned char *)a2 + 8);
  *(void *)(a1 + 320) = v6;
  return result;
}

uint64_t re::Scheduler::taskScheduleType(re::Scheduler *this, unint64_t a2)
{
  if (*((void *)this + 56) <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(unsigned __int8 *)(*((void *)this + 57) + a2);
}

uint64_t re::DynamicBitset<unsigned long long,256ul>::setBit(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 8) <= a2 >> 6)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(result + 16)) {
    uint64_t v2 = result + 24;
  }
  else {
    uint64_t v2 = *(void *)(result + 32);
  }
  *(void *)(v2 + 8 * (a2 >> 6)) |= 1 << a2;
  return result;
}

uint64_t re::DynamicBitset<unsigned long long,256ul>::orWithBitSet(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 64);
  if (v4 > *(void *)(a1 + 64))
  {
    if ((v4 & 0x3F) != 0) {
      unint64_t v5 = (v4 >> 6) + 1;
    }
    else {
      unint64_t v5 = v4 >> 6;
    }
    *(void *)(a1 + 64) = v4;
    uint64_t v11 = 0;
    re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)a1, v5, &v11);
  }
  unint64_t v6 = *(void *)(a2 + 8);
  if (v6 >= *(void *)(a1 + 8)) {
    unint64_t v6 = *(void *)(a1 + 8);
  }
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 32);
      if (*(unsigned char *)(a2 + 16)) {
        uint64_t v8 = a2 + 24;
      }
      uint64_t v9 = a1 + 24;
      if ((*(unsigned char *)(a1 + 16) & 1) == 0) {
        uint64_t v9 = *(void *)(a1 + 32);
      }
      *(void *)(v9 + 8 * i) |= *(void *)(v8 + 8 * i);
    }
  }
  return a1;
}

void re::Engine::checkForConfigureSystemChanges(re::Engine *this, char a2)
{
  unint64_t v4 = (re::ecs2::ECSManager *)*((void *)this + 83);
  if (v4 && re::ecs2::ECSManager::hasPendingSystemChanges(v4))
  {
    re::ecs2::ECSManager::configureSystemChanges(*((re::ecs2::ECSManager **)this + 83));
    *((unsigned char *)this + 1416) = 1;
  }
  if ((a2 & 1) == 0)
  {
    if (*((unsigned char *)this + 1416))
    {
      re::Engine::configurePhases((uint64_t)this);
      *((unsigned char *)this + 1416) = 0;
    }
  }
}

uint64_t re::Engine::start(uint64_t this)
{
  uint64_t v1 = (re::Engine *)this;
  int v2 = *(_DWORD *)(this + 904);
  if (!v2)
  {
    uint64_t v3 = re::ServiceLocator::service<re::SimulationClock>(*(void *)(this + 648));
    this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 64))(v3);
    int v2 = *((_DWORD *)v1 + 226);
  }
  *((_DWORD *)v1 + 226) = v2 + 1;
  if (*((_DWORD *)v1 + 118) == 1)
  {
    return re::Engine::tick(v1);
  }
  return this;
}

uint64_t re::ServiceLocator::service<re::SimulationClock>(uint64_t a1)
{
  uint64_t result = re::ServiceLocator::serviceOrNull<re::SimulationClock>(a1);
  if (!result)
  {
    int v2 = (re::internal *)re::introspect<re::SimulationClock>();
    re::StringID::invalid((re::StringID *)v6);
    re::internal::missingServiceErrorMessage(v2, (const re::IntrospectionBase *)v6, (re::DynamicString *)v7);
    re::DynamicString::~DynamicString((re::DynamicString *)v7);
    re::StringID::~StringID((re::StringID *)v6);
    uint64_t v3 = (re::internal *)re::introspect<re::SimulationClock>();
    re::StringID::invalid((re::StringID *)v6);
    re::internal::missingServiceErrorMessage(v3, (const re::IntrospectionBase *)v6, (re::DynamicString *)v7);
    if (v7[8]) {
      unint64_t v5 = *(unsigned char **)&v8[7];
    }
    else {
      unint64_t v5 = v8;
    }
    re::internal::assertLog((re::internal *)5, v4, "assertion failure: '%s' (%s:line %i) %s", "service", "service", 69, v5);
    re::DynamicString::~DynamicString((re::DynamicString *)v7);
    re::StringID::~StringID((re::StringID *)v6);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::Engine::stop(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 904);
  if (!v1 || (int v2 = v1 - 1, (*(_DWORD *)(this + 904) = v2) == 0))
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)re::ServiceLocator::service<re::SimulationClock>(*(void *)(this + 648))
                             + 72);
    return v3();
  }
  return this;
}

uint64_t re::Engine::isRunning(re::Engine *this)
{
  uint64_t result = re::ServiceLocator::serviceOrNull<re::SimulationClock>(*((void *)this + 81));
  if (result)
  {
    int v2 = *(uint64_t (**)(void))(*(void *)result + 16);
    return v2();
  }
  return result;
}

uint64_t re::ServiceLocator::serviceOrNull<re::SimulationClock>(uint64_t a1)
{
  {
    re::introspect<re::SimulationClock>(void)::info = re::introspect_SimulationClock(0);
  }
  uint64_t v2 = re::introspect<re::SimulationClock>(void)::info;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

BOOL re::Engine::createDrawingManager(re::Engine *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 105) + 104);
  uint64_t v3 = *re::appLogObjects(this);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)&v24.var0 = 0;
      unint64_t v5 = "CreateDrawingManager was called, but drawing manager already exists";
      unint64_t v6 = v3;
LABEL_23:
      _os_log_impl(&dword_233120000, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v24, 2u);
    }
  }
  else
  {
    if (v4)
    {
      *(_WORD *)&v24.var0 = 0;
      _os_log_impl(&dword_233120000, v3, OS_LOG_TYPE_DEFAULT, "Enter CreateDrawingManager", (uint8_t *)&v24, 2u);
    }
    DrawingManager = re::RenderManager::createDrawingManager(*((re::RenderManager **)this + 105));
    uint64_t v8 = *(void *)(*((void *)this + 105) + 104);
    if (v8) {
      uint64_t v9 = *(re **)(v8 + 296);
    }
    else {
      uint64_t v9 = 0;
    }
    unint64_t v10 = re::globalAllocators(DrawingManager);
    uint64_t v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10[2] + 32))(v10[2], 8, 8);
    *uint64_t v11 = &unk_26E6C7740;
    long long v12 = re::RenderGraphManager::setDataPipeFactory(v9, (uint64_t)v11);
    uint64_t v13 = *(void *)(*((void *)this + 105) + 104);
    if (v13)
    {
      long long v12 = (re *)*((void *)this + 119);
      *(void *)(v13 + 1664) = v12;
      if (v12)
      {
        long long v12 = (re *)re::ProfilerManager::getProcessor<re::FrameProfiler,void>((uint64_t)v12);
        *(void *)(v13 + 1648) = v12;
      }
    }
    if (*((void *)this + 93))
    {
      uint64_t v14 = *((void *)this + 105);
      if (v14)
      {
        if (*(void *)(v14 + 104) && !*((void *)this + 96))
        {
          int v15 = re::globalAllocators(v12);
          uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15[2] + 32))(v15[2], 104, 8);
          *(void *)uint64_t v16 = &unk_26E6CE008;
          *(_OWORD *)(v16 + 16) = 0u;
          *(_OWORD *)(v16 + 32) = 0u;
          *(_DWORD *)(v16 + 48) = 0;
          *(void *)(v16 + 52) = 0x7FFFFFFFLL;
          *(void *)(v16 + 64) = 0;
          *(unsigned char *)(v16 + 72) = 0;
          *(void *)(v16 + 88) = 0;
          *(void *)(v16 + 96) = 0;
          *(void *)(v16 + 80) = 0;
          *((void *)this + 96) = v16;
          uint64_t v17 = *((void *)this + 105);
          *(void *)(v16 + 88) = re::ServiceLocator::serviceOrNull<re::ecs2::ECSService>(*((void *)this + 81));
          *(void *)(v16 + 8) = v17;
          uint64_t v18 = *((void *)this + 81);
          __int16 v19 = (void *)*((void *)this + 96);
          re::StringID::invalid((re::StringID *)&v24);
          re::ServiceRegistry::add<re::DrawableQueueService>(v18, v19, &v24);
          re::StringID::destroyString((re::StringID *)&v24);
        }
      }
    }
    *((_DWORD *)this + 106) |= 0x10u;
    unint64_t v20 = *re::appLogObjects(v12);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)&v24.var0 = 0;
      _os_log_impl(&dword_233120000, v20, OS_LOG_TYPE_DEFAULT, "CreateDrawingManager: about to call remove/add scenes", (uint8_t *)&v24, 2u);
    }
    __int16 v21 = (re *)*((void *)this + 83);
    if (v21) {
      __int16 v21 = (re *)re::ecs2::ECSManager::removeAndAddScenes(v21);
    }
    *((unsigned char *)this + 1416) = 1;
    unint64_t v22 = *re::appLogObjects(v21);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)&v24.var0 = 0;
      unint64_t v5 = "Exit CreateDrawingManager";
      unint64_t v6 = v22;
      goto LABEL_23;
    }
  }
  return v2 == 0;
}

BOOL re::Engine::createRealityRendererSystemArrayManager(re::Engine *this)
{
  uint64_t v1 = *((void *)this + 99);
  if (!v1)
  {
    uint64_t v3 = re::globalAllocators(this);
    *((void *)this + 99) = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 1, 1);
    uint64_t v4 = re::ServiceLocator::serviceOrNull<re::ecs2::ECSService>(*((void *)this + 81));
    uint64_t v11 = 0;
    v8.var1 = 0;
    uint64_t v9 = 0;
    *(void *)&v8.var0 = 0;
    int v10 = 0;
    re::ecs2::ComponentHelper::addRealityRendererDefaultSystems((re *)&v8, v4);
    re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)&v8);
    uint64_t v5 = *((void *)this + 81);
    unint64_t v6 = (void *)*((void *)this + 99);
    re::StringID::invalid((re::StringID *)&v8);
    re::ServiceRegistry::add<re::RealityRendererSystemArrayManager>(v5, v6, &v8);
    re::StringID::destroyString((re::StringID *)&v8);
  }
  return v1 == 0;
}

void re::ServiceRegistry::add<re::RealityRendererSystemArrayManager>(uint64_t a1, void *a2, StringID *a3)
{
  uint64_t v3 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74C08, memory_order_acquire) & 1) == 0)
  {
    unint64_t v6 = a3;
    int v7 = __cxa_guard_acquire(&qword_26AF74C08);
    a3 = v6;
    uint64_t v3 = a2;
    if (v7)
    {
      qword_26AF74C00 = re::internal::getOrCreateInfo((re::internal *)"RealityRendererSystemArrayManager", (uint64_t (*)(re::internal *))re::allocInfo_RealityRendererSystemArrayManager, (re::IntrospectionBase *(*)(void))re::initInfo_RealityRendererSystemArrayManager, (void (*)(re::IntrospectionBase *))&unk_26AF74BB0, 0);
      __cxa_guard_release(&qword_26AF74C08);
      a3 = v6;
      uint64_t v3 = a2;
    }
  }
  re::ServiceRegistration::ServiceRegistration((re::ServiceRegistration *)&v8, (const re::IntrospectionBase *)qword_26AF74C00, a3, v3);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(a1 + 16, &v8);
  re::StringID::destroyString((re::StringID *)&v9);
}

void re::Engine::executeInlinePhase(re::FrameManager **this, float a2, int a3)
{
  switch(a3)
  {
    case 1:
      re::Engine::executeInlineEnterFramePhase(this, a2);
      break;
    case 2:
      re::Engine::executeInlinePreparePhase((re::Engine *)this, a2);
      break;
    case 3:
      re::Engine::executeInlineSimulatePhase(this, a2);
      break;
    case 4:
      re::Engine::executeInlineCommitPhase((re::Engine *)this, a2);
      break;
    case 5:
      if (((_BYTE)this[53] & 0x10) != 0) {
        (*((void (**)(float))*this + 7))(a2);
      }
      break;
    default:
      return;
  }
}

uint64_t re::Engine::executeInlineEnterFramePhase(re::FrameManager **this, float a2)
{
  uint64_t result = re::FrameManager::nextFrame(this[106]);
  if ((*((unsigned char *)this + 426) & 0x10) != 0)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)this[116] + 40);
    return v4();
  }
  return result;
}

void re::Engine::executeInlinePreparePhase(re::Engine *this, float a2)
{
  v13[4] = *MEMORY[0x263EF8340];
  int v4 = *((_DWORD *)this + 106) & 0x104;
  int v5 = *((_DWORD *)this + 106) & 2;
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    int v7 = (os_unfair_lock_s *)*((void *)this + 145);
    if (v7)
    {
      re::SharedClockManager::update(v7);
      int v4 = *((_DWORD *)this + 106) & 0x104;
      int v5 = *((_DWORD *)this + 106) & 2;
    }
    else
    {
      int v5 = 1;
      int v4 = 1;
    }
  }
  if (v5) {
    BOOL v8 = v4 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    uint64_t v9 = (re::TimebaseManager *)*((void *)this + 144);
    if (v9) {
      re::TimebaseManager::beforeFrameUpdate(v9, a2);
    }
  }
  re::BackgroundTaskManager::update(*((re::BackgroundTaskManager **)this + 84));
  int v10 = *((_DWORD *)this + 106);
  if ((v10 & 8) != 0)
  {
    uint64_t v11 = *((void *)this + 93);
    v13[0] = &unk_26E6C9DD8;
    v13[1] = v11;
    _OWORD v13[2] = 257;
    v13[3] = v13;
    re::runInLocalAutoreleasePool((uint64_t)v13);
    std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v13);
    int v10 = *((_DWORD *)this + 106);
  }
  if ((v10 & 2) != 0)
  {
    long long v12 = (re::ecs2::ECSManager *)*((void *)this + 83);
    re::ecs2::ECSManager::executeInlinePhaseByGroup(v12, 0);
  }
}

void re::Engine::executeInlineSimulatePhase(re::ecs2::ECSManager **this, float a2)
{
  (*((void (**)(re::ecs2::ECSManager **))*this + 6))(this);
  if (((_BYTE)this[53] & 2) != 0)
  {
    re::ecs2::ECSManager::executeInlinePhaseByGroup(this[83], 1);
    if (((_BYTE)this[53] & 0x20) != 0 && !*((unsigned char *)this + 625))
    {
      int v4 = this[83];
      if (!*((unsigned char *)v4 + 356))
      {
        uint64_t v5 = *((void *)v4 + 28);
        if (v5)
        {
          BOOL v6 = (uint64_t *)*((void *)v4 + 30);
          int v7 = &v6[v5];
          do
          {
            BOOL v8 = this[111];
            uint64_t v16 = *v6;
            uint64_t v9 = re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet((uint64_t)v8 + 432, &v16);
            if (v9)
            {
              uint64_t v10 = v9;
              re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v16, v9, 0);
              BOOL v11 = v10 == v16 && (unsigned __int16)v17 == 0xFFFFLL;
              if (!v11 || (v17 & 0xFFFF0000) != 4294901760)
              {
                do
                {
                  uint64_t v13 = *(re::PhysicsSimulation **)(re::DataArray<re::ecs2::PhysicsSimulationData>::DataArrayIterator<re::ecs2::PhysicsSimulationData,re::ecs2::PhysicsSimulationData&>::operator*((unsigned __int16 *)&v16)
                                                  + 8);
                  if (v13) {
                    re::PhysicsSimulation::update(v13, a2);
                  }
                  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v16);
                }
                while (v16 != v10 || (unsigned __int16)v17 != 0xFFFF || WORD1(v17) != 0xFFFF);
              }
            }
            ++v6;
          }
          while (v6 != v7);
        }
      }
    }
  }
}

void re::Engine::executeInlineCommitPhase(re::Engine *this, float a2)
{
  int v3 = *((_DWORD *)this + 106);
  if ((v3 & 2) != 0)
  {
    re::ecs2::ECSManager::executeInlinePhaseByGroup(*((re::ecs2::ECSManager **)this + 83), 2);
    int v3 = *((_DWORD *)this + 106);
  }
  if ((~v3 & 0x18) == 0)
  {
    re::DrawableQueueManager::afterFrameUpdate(*((re::DrawableQueueManager **)this + 96));
    int v3 = *((_DWORD *)this + 106);
  }
  if ((v3 & 8) != 0)
  {
    re::AssetManager::afterFrameUpdate(*((re::AssetManager **)this + 93));
    int v3 = *((_DWORD *)this + 106);
  }
  if ((v3 & 0x104) != 0 && (v3 & 2) != 0)
  {
    uint64_t v5 = (os_unfair_lock_s *)*((void *)this + 144);
    if (v5)
    {
      re::TimebaseManager::afterFrameUpdate(v5);
      int v3 = *((_DWORD *)this + 106);
    }
  }
  if ((v3 & 0x12) != 0)
  {
    re::Engine::performColorManagerAfterFrameUpdate(this);
  }
}

uint64_t re::ecs2::PhysicsSimulationManager::physicsSimulationsForScene(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(a1 + 432, &v3);
}

uint64_t re::DataArray<re::ecs2::PhysicsSimulationData>::DataArrayIterator<re::ecs2::PhysicsSimulationData,re::ecs2::PhysicsSimulationData&>::operator*(unsigned __int16 *a1)
{
  unint64_t v1 = a1[5];
  if (*(void *)(*(void *)a1 + 16) <= v1)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(*(void *)a1 + 32) + 16 * v1) + 272 * a1[4];
}

void re::Engine::performColorManagerAfterFrameUpdate(re::Engine *this)
{
  uint64_t v2 = re::ServiceLocator::serviceOrNull<re::ecs2::ECSService>(*((void *)this + 81));
  uint64_t v3 = re::ServiceLocator::serviceOrNull<re::ColorManager>(*((void *)this + 81));
  uint64_t v4 = v3;
  float v5 = 1.0;
  if (v2) {
    BOOL v6 = v3 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    goto LABEL_13;
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 104))(v2);
  uint64_t v8 = *(void *)(v7 + 24);
  if (!v8) {
    goto LABEL_13;
  }
  uint64_t v9 = *(uint64_t **)(v7 + 40);
  uint64_t v10 = 8 * v8;
  while (1)
  {
    uint64_t v11 = *v9;
    v15[0] = 0;
    SceneDataEntity = makeSceneDataEntity(v11, (uint64_t)v15, 0, re::ecs2::Scene::kLocalSceneDataEntityID, 0);
    if (SceneDataEntity)
    {
      uint64_t v13 = re::ecs2::EntityComponentCollection::get((re::ecs2::Entity *)((char *)SceneDataEntity + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::EDRColorManagementComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
      if (v13) {
        break;
      }
    }
    ++v9;
    v10 -= 8;
    if (!v10) {
      goto LABEL_13;
    }
  }
  uint64_t v14 = *(void *)(v13 + 32);
  if (v14)
  {
    float v5 = (*(float (**)(void))(v14 + 16))();
LABEL_13:
    *(float *)(v4 + 12492) = v5;
  }
}

uint64_t re::ServiceLocator::serviceOrNull<re::ColorManager>(uint64_t a1)
{
  {
    re::introspect<re::ColorManager>(void)::info = re::introspect_ColorManager(0);
  }
  uint64_t v2 = re::introspect<re::ColorManager>(void)::info;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

uint64_t re::EngineOverlay::init(re::EngineOverlay *this, re::Engine *a2)
{
  *((void *)this + 3) = a2;
  uint64_t v3 = re::globalAllocators(this);
  uint64_t v4 = (re::ManualClock *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 128, 8);
  float v5 = re::ManualClock::ManualClock(v4);
  *((void *)this + 4) = v5;
  BOOL v6 = re::globalAllocators(v5);
  uint64_t v7 = (re::VariableStepTimer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6[2] + 32))(v6[2], 248, 8);
  uint64_t v8 = re::VariableStepTimer::VariableStepTimer(v7);
  *((void *)this + 5) = v8;
  re::VariableStepTimer::setClock((uint64_t)v8, *((void *)this + 4));
  *(unsigned char *)(*((void *)this + 5) + 24) = 1;
  uint64_t v9 = *((void *)this + 3);
  *(unsigned char *)(*((void *)this + 4) + 8) = 1;
  uint64_t result = re::ServiceLocator::serviceOrNull<re::RealityRendererSystemArrayManager>(*(void *)(v9 + 648));
  if (!result)
  {
    uint64_t v11 = (re::Engine *)*((void *)this + 3);
    return re::Engine::createRealityRendererSystemArrayManager(v11);
  }
  return result;
}

uint64_t re::ServiceLocator::serviceOrNull<re::RealityRendererSystemArrayManager>(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74C08, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF74C08))
  {
    qword_26AF74C00 = re::internal::getOrCreateInfo((re::internal *)"RealityRendererSystemArrayManager", (uint64_t (*)(re::internal *))re::allocInfo_RealityRendererSystemArrayManager, (re::IntrospectionBase *(*)(void))re::initInfo_RealityRendererSystemArrayManager, (void (*)(re::IntrospectionBase *))&unk_26AF74BB0, 0);
    __cxa_guard_release(&qword_26AF74C08);
  }
  uint64_t v2 = qword_26AF74C00;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

void re::EngineOverlay::~EngineOverlay(re::EngineOverlay *this)
{
  *(void *)this = &unk_26E6C6FF0;
  uint64_t v2 = *((void *)this + 5);
  *(unsigned char *)(*((void *)this + 4) + 8) = 0;
  *(unsigned char *)(v2 + 24) = 0;
  *(void *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 48) = 0;
  uint64_t v3 = re::globalAllocators(this)[2];
  re::VariableStepTimer::~VariableStepTimer((re::VariableStepTimer *)v2);
  uint64_t v4 = (re *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 40))(v3, v2);
  *((void *)this + 5) = 0;
  float v5 = (void (***)(void))*((void *)this + 4);
  if (v5)
  {
    uint64_t v6 = re::globalAllocators(v4)[2];
    (**v5)(v5);
    (*(void (**)(uint64_t, void (***)(void)))(*(void *)v6 + 40))(v6, v5);
  }
  *((void *)this + 4) = 0;
  uint64_t v7 = *((void *)this + 6);
  if (v7)
  {

    *((void *)this + 6) = 0;
  }
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  re::EngineOverlay::~EngineOverlay(this);
  JUMPOUT(0x237DBCBD0);
}

void re::EngineOverlay::executePhase(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = re::ServiceLocator::serviceOrNull<re::ecs2::ECSService>(*(void *)(*(void *)(a1 + 24) + 648));
  if (v4) {
    (*(void (**)(uint64_t, void))(*(void *)v4 + 216))(v4, *(void *)(a1 + 48));
  }
  if (*(unsigned __int8 *)(a1 + 56) >= a2) {
    re::Engine::checkForConfigureSystemChanges(*(re::Engine **)(a1 + 24), 1);
  }
  re::Engine::executeInlinePhase(*(re::FrameManager ***)(a1 + 24), *(float *)(*(void *)(a1 + 40) + 40), a2);
  *(unsigned char *)(a1 + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = a2;
}

void re::EngineOverlay::setRealityRendererSceneGroup(uint64_t a1, uint64_t a2)
{
  if (a2) {
    id v4 = (id)(a2 + 8);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = a2;
  if (v5)
  {
  }
}

void *re::allocInfo_Engine(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74BB8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF74BB8))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF74C98, "Engine");
    __cxa_guard_release(&qword_26AF74BB8);
  }
  return &unk_26AF74C98;
}

void re::initInfo_Engine(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 4160343236;
  v5[1] = "Engine";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x59000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((void *)this + 11) = re::internal::defaultRetain<re::Engine>(void)::{lambda(void *)#1}::__invoke;
  *((void *)this + 12) = re::internal::defaultRelease<re::Engine>(void)::{lambda(void *)#1}::__invoke;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = &re::initInfo_Engine(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_Engine(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Engine", (uint64_t (*)(re::internal *))re::allocInfo_Engine, (re::IntrospectionBase *(*)(void))re::initInfo_Engine, (void (*)(re::IntrospectionBase *))&unk_26AF74BC0, this);
}

re::EngineConfiguration *re::EngineConfiguration::EngineConfiguration(re::EngineConfiguration *this)
{
  *(unsigned char *)this = 0;
  *(void *)((char *)this + 4) = -65537;
  uint64_t v2 = MEMORY[0x263EF83A0];
  uint64_t v3 = (_anonymous_namespace_ *)MEMORY[0x263EF83A0];
  *((void *)this + 2) = v2;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  long long v4 = (re *)re::DynamicString::setCapacity((void *)this + 3, 0);
  *((void *)this + 13) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0u;
  *((void *)this + 12) = re::globalAllocators(v4)[2];
  *((void *)this + 13) = 0;
  *((_OWORD *)this + 7) = xmmword_23436C450;
  *((void *)this + 16) = 0x101010101010101;
  *((void *)this + 17) = 0x101010101010101;
  *((_DWORD *)this + 36) = 257;
  *((unsigned char *)this + 148) = 1;
  *(_DWORD *)((char *)this + 149) = 0;
  *(_WORD *)((char *)this + 153) = 1;
  *((unsigned char *)this + 155) = 0;
  *((unsigned char *)this + 160) = 1;
  *((unsigned char *)this + 184) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  re::Defaults::BOOLValue((re::Defaults *)"shareAssetStates", v5, &v19);
  if (v19) {
    BOOL v7 = v20 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  char v8 = !v7;
  *((unsigned char *)this + 185) = v8;
  re::Defaults::BOOLValue((re::Defaults *)"calculateAssetRuntimeSize", v6, &v19);
  if (v19) {
    BOOL v10 = v20 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  char v11 = !v10;
  *((unsigned char *)this + 186) = v11;
  re::Defaults::uint64Value((re::Defaults *)"assetRuntimeSizeLimit", v9, (uint64_t)&v19);
  if (v19) {
    uint64_t v13 = v21;
  }
  else {
    uint64_t v13 = -1;
  }
  *((void *)this + 24) = v13;
  re::Defaults::uint64Value((re::Defaults *)"assetRuntimeUpdateTimeoutNanoseconds", v12, (uint64_t)&v19);
  if (v19) {
    uint64_t v14 = v21;
  }
  else {
    uint64_t v14 = 0;
  }
  *((void *)this + 25) = v14;
  *((unsigned char *)this + 208) = 0;
  *((unsigned char *)this + 209) = _os_feature_enabled_impl() ^ 1;
  *((unsigned char *)this + 210) = _os_feature_enabled_impl();
  *(_WORD *)((char *)this + 211) = 257;
  *((unsigned char *)this + 213) = 0;
  re::Defaults::BOOLValue((re::Defaults *)"preloadEngineAssets", v15, &v19);
  if (v19) {
    BOOL v16 = v20 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  char v17 = !v16;
  *((unsigned char *)this + 214) = v17;
  *(_WORD *)((char *)this + 215) = 0;
  return this;
}

re::NetworkOPACKSerializer *re::NetworkOPACKSerializer::NetworkOPACKSerializer(re::NetworkOPACKSerializer *this)
{
  *(void *)&v4.var0 = 0xD66B7D4190E6B598;
  v4.var1 = "NetworkOPACKSerializer";
  uint64_t v2 = re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SerializerV2((uint64_t)this, &v4);
  *(void *)uint64_t v2 = &unk_26E6C70E8;
  *(_OWORD *)(v2 + 448) = 0u;
  *(_OWORD *)(v2 + 464) = 0u;
  *(void *)(v2 + 200) = v2 + 456;
  re::StringID::destroyString((re::StringID *)&v4);
  *(void *)this = &unk_26E6C7050;
  return this;
}

void re::NetworkOPACKSerializer::~NetworkOPACKSerializer(re::NetworkOPACKSerializer *this)
{
  *(void *)this = &unk_26E6C8CF8;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)this + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 360);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272);
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6C8CF8;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)this + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 360);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272);
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)this);
  JUMPOUT(0x237DBCBD0);
}

void re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::doClose(uint64_t a1)
{
  re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::serializeSharedObjects(a1);
  re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
  *(void *)(a1 + 288) = 0;
  ++*(_DWORD *)(a1 + 296);
  re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1 + 312);
  *(void *)(a1 + 376) = 0;
  ++*(_DWORD *)(a1 + 384);
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(a1 + 400);
}

void re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v11 = 6059476;
  long long v12 = "BOOL";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 6104748;
  long long v12 = "char";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x172E117BCLL;
  long long v12 = "int8_t";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93A4A92;
  long long v12 = "int16_t";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93BFE06;
  long long v12 = "int32_t";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93EC744;
  long long v12 = "int64_t";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 6655224;
  long long v12 = "long";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x31CD534126;
  long long v12 = "uint8_t";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD0D4E68;
  long long v12 = "uint16_t";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD0F01DCLL;
  long long v12 = "uint32_t";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD11CB1ALL;
  long long v12 = "uint64_t";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x1947BDF6CLL;
  long long v12 = "size_t";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 195052728;
  long long v12 = "float";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x161EEF7A2;
  long long v12 = "double";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 189247272;
  long long v12 = "char*";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2686EB529B3EE220;
  long long v12 = "DynamicString";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x458DDB01A18;
  long long v12 = "StringID";
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v2 = *(void *)(a1 + 208);
  uint64_t v11 = 0x258C98EAAF29A10ALL;
  long long v12 = "CallbackSerializerAttribute";
  uint64_t v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    uint64_t v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      uint64_t v5 = *(void *)(a1 + 208);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        uint64_t v6 = a1 + 224;
        BOOL v7 = (uint64_t *)(v14 + 24);
        uint64_t v8 = 48 * v13;
        do
        {
          uint64_t v9 = *v7;
          v7 += 6;
          BOOL v16 = re::serializeIntrospectionCallbackSerializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>;
          unint64_t v15 = v9 | 0xFFFFFFFF00000000;
          re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v6, &v15, &v16);
          v8 -= 48;
        }
        while (v8);
      }
      if (v11)
      {
        if (v14) {
          (*(void (**)(void))(*(void *)v11 + 40))();
        }
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a4;
  uint64_t v26 = a4;
  if (!*(void *)(a1 + 288))
  {
    if (*(_DWORD *)(a1 + 136) == 2)
    {
      uint64_t v22 = a4;
      re::TypeInfo::TypeInfo((uint64_t)v23, (uint64_t)a5);
      re::TypeInfo::TypeInfo((uint64_t)v24, a6);
      __int16 v25 = 0;
      re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject>::add((_anonymous_namespace_ *)(a1 + 272), (uint64_t)&v22);
      LODWORD(v22) = 0;
      re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::addNew<int>(a1 + 312, &v26, &v22);
      a3 = 10;
      uint64_t v10 = v26;
    }
    else
    {
      uint64_t v22 = 0;
      re::TypeInfo::TypeInfo((uint64_t)v23, (uint64_t)a5);
      re::TypeInfo::TypeInfo((uint64_t)v24, a6);
      __int16 v25 = 0;
      re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject>::add((_anonymous_namespace_ *)(a1 + 272), (uint64_t)&v22);
    }
  }
  uint64_t v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(void *)a1 + 80))(a1, a5);
  if (v14) {
    return v14(a1, a2, a3, v10, a5, a6, a7);
  }
  BOOL v16 = re::TypeInfo::name(a5);
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
  return 0;
}

uint64_t (*re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(unsigned char *a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v2 = re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::serializePointer;
  if (*(unsigned char *)(a2 + 12) != 9)
  {
    if (*(void *)a2 == *(void *)(a1 + 208))
    {
      LODWORD(v5) = **(void **)(a2 + 16);
      HIDWORD(v5) = -1;
      uint64_t v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 224, &v5);
      uint64_t v2 = re::serializeType<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>;
      if (v3) {
        return *(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, unsigned __int8 *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
      }
    }
    else
    {
      return re::serializeType<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>;
    }
  }
  return (uint64_t (*)(unsigned char *, const char *, const re::TypeInfo *, unsigned __int8 *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v2;
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SerializerV2(uint64_t a1, const StringID *a2)
{
  *(void *)a1 = &unk_26E6C8D60;
  re::StringID::StringID((re::StringID *)(a1 + 8), a2);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::Encoder(a1 + 24, 13);
  *(void *)(a1 + 2re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0x7FFFFFFF00000000;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(void *)a1 = &unk_26E6C8CF8;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 332) = 0u;
  *(void *)(a1 + 348) = 0x7FFFFFFFLL;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
  *(_DWORD *)(a1 + 384) = 0;
  *(void *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 420) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 436) = 0x7FFFFFFFLL;
  return a1;
}

uint64_t re::NetworkSerializerBase<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>>::~NetworkSerializerBase(void *a1)
{
  *a1 = &unk_26E6C8CF8;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(a1 + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 45));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 34));
  return re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)a1);
}

void re::NetworkSerializerBase<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>>::~NetworkSerializerBase(void *a1)
{
  *a1 = &unk_26E6C8CF8;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(a1 + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 45));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 34));
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~SerializerV2(void *a1)
{
  *a1 = &unk_26E6C8CF8;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(a1 + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 45));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 34));
  return re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)a1);
}

void re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~SerializerV2(void *a1)
{
  *a1 = &unk_26E6C8CF8;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(a1 + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 45));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 34));
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::doOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(void *)(a1 + 288) = 0;
  ++*(_DWORD *)(a1 + 296);
  re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1 + 312);
  *(void *)(a1 + 376) = 0;
  ++*(_DWORD *)(a1 + 384);
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(a1 + 400);
  uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginObject(a1 + 24, "container", 0, 0);
  if ((result & 1) == 0 && !*(unsigned char *)(a1 + 64))
  {
    return re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, "container", "Failed to open container.", v11, v12, v13, v14, v15, a9);
  }
  return result;
}

void re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer(a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(void *)a1 + 80))(a1, a5);
  if (v14)
  {
    return v14(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    BOOL v16 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
    return 0;
  }
}

uint64_t (*re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(unsigned char *a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a2 == *(void *)(a1 + 208)
    && (LODWORD(v4) = **(void **)(a2 + 16),
        HIDWORD(v4) = -1,
        (uint64_t v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 224, &v4)) != 0))
  {
    return *(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, unsigned __int8 *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>;
  }
}

uint64_t re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::Encoder(uint64_t result, int a2)
{
  *(void *)(result + 128) = 0;
  *(void *)(result + 104) = 0;
  *(void *)(result + ++*(void *)(this + 112) = 0;
  *(void *)(result + 96) = 0;
  *(_DWORD *)(result + 120) = 0;
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(unsigned char *)(result + 40) = 0;
  *(_DWORD *)(result + 136) = a2;
  *(unsigned char *)(result + 140) = 0;
  *(void *)(result + 152) = 1024;
  uint64_t v2 = &qword_268772000;
  {
    uint64_t v8 = result;
    uint64_t v2 = &qword_268772000;
    int v6 = v4;
    uint64_t result = v8;
    if (v6)
    {
      re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v5, (uint64_t)v9);
      uint64_t v7 = v10;
      if (!v9[0]) {
        uint64_t v7 = 0;
      }
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::Encoder(int)::s_maxSerializationDepth = v7;
      uint64_t v2 = &qword_268772000;
      uint64_t result = v8;
    }
  }
  uint64_t v3 = v2[371];
  if (v3) {
    *(void *)(result + 152) = v3;
  }
  return result;
}

uint64_t re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::~Serializer(uint64_t a1)
{
  *(void *)a1 = &unk_26E6C8D60;
  uint64_t v2 = (re::StringID *)(a1 + 8);
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::deinit((void *)a1);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 224));
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::~Encoder((unsigned char *)(a1 + 24));
  re::StringID::destroyString(v2);
  return a1;
}

void re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::deinit(void *a1)
{
  if (a1[26])
  {
    (*(void (**)(void *))(*a1 + 40))(a1);
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
    a1[26] = 0;
  }
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 24 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16);
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0) {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
        }
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

double re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 24 * v3;
      do
      {
        uint64_t v6 = a1[2];
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0) {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
        }
        v4 += 24;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

unsigned char *re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::~Encoder(unsigned char *a1)
{
  if (a1[40]) {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 64));
  }
  return a1;
}

_anonymous_namespace_ *re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::close(_anonymous_namespace_ *result)
{
  if (*(void *)result)
  {
    unint64_t v1 = result;
    if (!*((unsigned char *)result + 40)) {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 0);
    }
    double result = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::deinit((uint64_t)v1 + 96);
    if (*((int *)v1 + 4) >= 1)
    {
      double result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)v1 + 24))();
      *((void *)v1 + 1) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *(void *)unint64_t v1 = 0;
    *((void *)v1 + 3) = 0;
    *((void *)v1 + 4) = 0;
  }
  return result;
}

_anonymous_namespace_ *re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(_anonymous_namespace_ *result, int a2)
{
  uint64_t v3 = (uint64_t)result;
  uint64_t v4 = *((void *)result + 14);
  if (!v4)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v3, (uint64_t)&v6);
    double result = v6;
    if (v6 && (v7 & 1) != 0) {
      double result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v6 + 40))();
    }
    uint64_t v4 = *(void *)(v3 + 112);
  }
  uint64_t v5 = v4 - 1;
  if (*(unsigned __int8 *)(*(void *)(v3 + 128) + 48 * v5) != a2)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v3, (uint64_t)&v6);
    double result = v6;
    if (v6 && (v7 & 1) != 0) {
      double result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v6 + 40))();
    }
    uint64_t v5 = *(void *)(v3 + 112) - 1;
  }
  *(void *)(v3 + ++*(void *)(this + 112) = v5;
  ++*(_DWORD *)(v3 + 120);
  return result;
}

uint64_t re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(uint64_t a1, uint64_t a2)
{
  *(void *)&long long v3 = 400;
  *((void *)&v3 + 1) = re::FoundationErrorCategory(void)::instance;
  uint64_t v4 = *(void *)a2;
  uint64_t v6 = *(void *)(a2 + 24);
  long long v5 = *(_OWORD *)(a2 + 8);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1, &v3);
  uint64_t result = v4;
  if (v4)
  {
    if (v5) {
      return (*(uint64_t (**)(void))(*(void *)v4 + 40))();
    }
  }
  return result;
}

uint64_t re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(uint64_t a1, long long *a2)
{
  v4[0] = 1;
  long long v5 = *a2;
  re::DynamicString::DynamicString((re::DynamicString *)&v6, (const re::DynamicString *)(a2 + 1));
  uint64_t result = re::Optional<re::DetailedError>::operator=(a1 + 40, v4);
  if (v4[0])
  {
    uint64_t result = v6;
    if (v6)
    {
      if (v7) {
        return (*(uint64_t (**)(void))(*(void *)v6 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::Optional<re::DetailedError>::operator=(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  if (*(unsigned char *)a1) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = v3 == 0;
  }
  if (!v4)
  {
    if (*(unsigned char *)a1) {
      BOOL v5 = v3 == 0;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
      *(unsigned char *)a1 = 0;
    }
    else
    {
      uint64_t v6 = (_OWORD *)(a1 + 8);
      if (*(unsigned char *)a1) {
        BOOL v7 = 1;
      }
      else {
        BOOL v7 = v3 == 0;
      }
      if (v7)
      {
        *uint64_t v6 = *(_OWORD *)(a2 + 8);
        re::DynamicString::operator=((re::DynamicString *)(a1 + 24), (re::DynamicString *)(a2 + 24));
      }
      else
      {
        *(unsigned char *)a1 = 1;
        *uint64_t v6 = *(_OWORD *)(a2 + 8);
        *(_OWORD *)(a1 + 40) = 0u;
        *(_OWORD *)(a1 + 24) = 0u;
        *(void *)(a1 + 48) = *((void *)a2 + 6);
        uint64_t v8 = *((void *)a2 + 4);
        *(void *)(a1 + 24) = *((void *)a2 + 3);
        *((void *)a2 + 3) = 0;
        uint64_t v9 = *((void *)a2 + 5);
        *((void *)a2 + 6) = 0;
        uint64_t v11 = *(void *)(a1 + 32);
        uint64_t v10 = *(void *)(a1 + 40);
        *(void *)(a1 + 32) = v8;
        *(void *)(a1 + 40) = v9;
        *((void *)a2 + 4) = v11;
        *((void *)a2 + 5) = v10;
      }
    }
  }
  return a1;
}

uint64_t re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v24 = 0;
  __int16 v25 = 0;
  uint64_t v26 = 0;
  re::DynamicString::setCapacity(&v23, 0);
  uint64_t v22 = &a9;
  re::DynamicString::vassignf((re::DynamicString *)&v23, a3, &a9);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)(a1 + 24), a2, (re::DynamicString *)&v15);
  if (v16) {
    uint64_t v12 = *(unsigned char **)&v17[7];
  }
  else {
    uint64_t v12 = v17;
  }
  if (v24) {
    uint64_t v13 = v25;
  }
  else {
    uint64_t v13 = (char *)&v24 + 1;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: %s", (re::DynamicString *)&v18, "serialize", v12, v13);
  *(void *)&v21[0] = 400;
  *((void *)&v21[0] + 1) = re::FoundationErrorCategory(void)::instance;
  *(void *)&v21[1] = v18;
  *((void *)&v21[2] + 1) = v20;
  *(long long *)((char *)&v21[1] + 8) = v19;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1 + 24, v21);
  if (*(void *)&v21[1])
  {
    if (BYTE8(v21[1])) {
      (*(void (**)(void))(**(void **)&v21[1] + 40))();
    }
    memset(&v21[1], 0, 32);
  }
  if (v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t result = (uint64_t)v23;
  if (v23)
  {
    if (v24) {
      return (*(uint64_t (**)(void))(*v23 + 40))();
    }
  }
  return result;
}

void *re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels@<X0>(_anonymous_namespace_ *a1@<X0>, const char *a2@<X1>, re::DynamicString *a3@<X8>)
{
  uint64_t v5 = *((void *)a1 + 16);
  unint64_t v6 = *((void *)a1 + 14);
  *((void *)a3 + 2) = 0;
  *((void *)a3 + 3) = 0;
  *((void *)a3 + 1) = 0;
  uint64_t result = re::DynamicString::setCapacity(a3, 0);
  if (v6 >= 2)
  {
    unint64_t v8 = v6 - 1;
    uint64_t v9 = v5 + 48;
    do
    {
      unsigned int v10 = *(unsigned __int8 *)(v9 - 48);
      BOOL v11 = v10 > 0xA;
      int v12 = (1 << v10) & 0x608;
      if (v11 || v12 == 0)
      {
        uint64_t v14 = *(unsigned char **)(v9 + 8);
        if (v14 && *v14)
        {
          char __src = 47;
          re::DynamicString::append(a3, &__src, 1uLL);
          size_t v15 = strlen(*(const char **)(v9 + 8));
          uint64_t result = re::DynamicString::append(a3, *(const char **)(v9 + 8), v15);
        }
        if (*(unsigned char *)v9 == 5) {
          uint64_t result = (void *)re::DynamicString::appendf(a3, "/%lld", *(void *)(v9 + 32));
        }
      }
      v9 += 48;
      --v8;
    }
    while (v8);
  }
  if (a2 && *a2)
  {
    char v18 = 47;
    re::DynamicString::append(a3, &v18, 1uLL);
    size_t v16 = strlen(a2);
    return re::DynamicString::append(a3, a2, v16);
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (*a2 % (unint64_t)*(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + 24 * v3 + 4) != v2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 24 * v3) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v5 + 24 * v3 + 4) == v2) {
        return v5 + 24 * v3 + 16;
      }
    }
    return 0;
  }
  return v5 + 24 * v3 + 16;
}

uint64_t re::serializeType<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (this == (re::TypeInfo *)a6) {
    goto LABEL_19;
  }
  if (*(void *)this != *(void *)a6)
  {
    if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, a3)) {
      goto LABEL_19;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      uint64_t v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
      if (v19) {
        int v20 = *(_DWORD *)(v19 + 16);
      }
      else {
        int v20 = -1;
      }
      uint64_t v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
      if (v21) {
        int v22 = *(_DWORD *)(v21 + 16);
      }
      else {
        int v22 = -1;
      }
      if (v20 == v22) {
        goto LABEL_19;
      }
      uint64_t v24 = re::TypeInfo::name(this)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
      re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "Cannot serialize type \"%s\" version %u as version %u. Downgrading versions is not supported.", v30, v31, v32, v33, v34, v24);
    }
    else
    {
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, this, (re::TypeInfo *)a6);
    }
    return 0;
  }
  uint64_t v15 = **((void **)this + 2);
  uint64_t v16 = **(void **)(a6 + 16);
  if ((unsigned __int16)v15 != (unsigned __int16)v16) {
    goto LABEL_10;
  }
  BOOL v18 = WORD1(v15) == WORD1(v16);
  uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
  BOOL v18 = v18 && v17 == 0;
  if (!v18) {
    goto LABEL_10;
  }
LABEL_19:
  switch(*((unsigned char *)this + 12))
  {
    case 1:
      uint64_t result = re::serializeBasic<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 2:
      uint64_t result = re::serializeEnum<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, (re::TypeInfo *)a4, (uint64_t)this, a6, a7);
      break;
    case 3:
      uint64_t result = re::serializeOptional<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 4:
      uint64_t result = re::serializeArray<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 5:
      uint64_t result = re::serializeList<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 6:
      uint64_t result = re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 7:
      uint64_t result = re::serializeUnion<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, (char *)a4, this, (re::TypeInfo *)a6, a7);
      break;
    case 8:
      uint64_t result = re::serializeObject<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)a4, this, a6, a7);
      break;
    case 9:
      uint64_t v35 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "Pointer type (\"%s\") needs to be handled explicitly by the serializer.", v25, v26, v27, v28, v29, v35);
      return 0;
    default:
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "Invalid type category. Value = %d", (uint64_t)a4, (uint64_t)this, a6, a7, a8, *((unsigned char *)this + 12));
      return 0;
  }
  return result;
}

BOOL re::areSameVersion(re *this, const re::TypeInfo *a2, const re::TypeInfo *a3)
{
  if (this == a2) {
    return 1;
  }
  if (*(void *)this != *(void *)a2) {
    return re::areSameTranslatedVersion(this, a2, a3);
  }
  uint64_t v4 = **((void **)this + 2);
  uint64_t v5 = **((void **)a2 + 2);
  if ((unsigned __int16)v4 == (unsigned __int16)v5
    && ((v7 = WORD1(v4) == WORD1(v5), uint64_t v6 = (v5 ^ v4) & 0xFFFFFF00000000, v7) ? (v7 = v6 == 0) : (v7 = 0), v7))
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, re::TypeInfo *this, re::TypeInfo *a4)
{
  uint64_t v7 = re::TypeInfo::name(this)[1];
  re::TypeInfo::name(a4);
  return re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Type mismatch. Runtime type \"%s\" and serialized type \"%s\" are different.", v8, v9, v10, v11, v12, v7);
}

uint64_t re::serializeBasic<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  int v10 = (int)a3;
  if (this != a6)
  {
    if (*(void *)this != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3)) {
        goto LABEL_4;
      }
LABEL_21:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, this, a6);
      return 0;
    }
    uint64_t v18 = **((void **)this + 2);
    uint64_t v19 = **((void **)a6 + 2);
    if ((unsigned __int16)v18 != (unsigned __int16)v19) {
      goto LABEL_21;
    }
    BOOL v21 = WORD1(v18) == WORD1(v19);
    uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
    BOOL v21 = v21 && v20 == 0;
    if (!v21) {
      goto LABEL_21;
    }
  }
LABEL_4:
  uint64_t v14 = re::TypeInfo::name(this);
  unint64_t v15 = (unint64_t)*v14 >> 1;
  if (v15 > 0xCA3DEFB5)
  {
    if ((unint64_t)*v14 >> 1 > 0x18E6A9A092)
    {
      if ((unint64_t)*v14 >> 1 <= 0x303EE8780EDLL)
      {
        if (v15 == 0x18E6A9A093)
        {
          return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v10, a4, a7);
        }
        else
        {
          if (v15 != 0x303EE86A734) {
            goto LABEL_69;
          }
          return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v10, (unsigned __int16 *)a4, a7);
        }
      }
      if (v15 == 0x303EE8780EELL)
      {
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v10, (unsigned int *)a4, a7);
      }
      if (v15 != 0x303EE88E58DLL) {
        goto LABEL_69;
      }
    }
    else
    {
      if ((unint64_t)*v14 >> 1 > 0x16749DFF02)
      {
        if (v15 == 0x16749DFF03)
        {
LABEL_54:
          return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<int>(a1 + 24, a2, v10, (int *)a4, a7);
        }
        uint64_t v22 = 0x16749F63A2;
LABEL_40:
        if (v15 == v22)
        {
          return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v10, (uint64_t *)a4, a7);
        }
LABEL_69:
        uint64_t v23 = re::TypeInfo::name(this);
        re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Unsupported basic type \"%s\".", v24, v25, v26, v27, v28, v23[1]);
        return 0;
      }
      if (v15 != 3393056694)
      {
        uint64_t v17 = 0x16749D2549;
LABEL_26:
        if (v15 != v17) {
          goto LABEL_69;
        }
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<short>(a1 + 24, a2, v10, (__int16 *)a4, a7);
      }
    }
    return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v10, (uint64_t *)a4, a7);
  }
  if ((unint64_t)*v14 >> 1 <= 0x5D0225B)
  {
    if ((unint64_t)*v14 >> 1 <= 0x2E9355)
    {
      if (v15 != 104431)
      {
        if (v15 == 3029738)
        {
          return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeBool(a1 + 24, a2, v10, a4, a7);
        }
        goto LABEL_69;
      }
      goto LABEL_54;
    }
    if (v15 != 3052374)
    {
      uint64_t v22 = 3327612;
      goto LABEL_40;
    }
    goto LABEL_46;
  }
  if ((unint64_t)*v14 >> 1 <= 0xB0F77BD0)
  {
    if (v15 == 97526364)
    {
      return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeFloat(a1 + 24, a2, v10, (char *)a4, a7);
    }
    uint64_t v17 = 109413500;
    goto LABEL_26;
  }
  if (v15 != 2969009105)
  {
    if (v15 != 3111160798) {
      goto LABEL_69;
    }
LABEL_46:
    return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v10, (char *)a4, a7);
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeDouble(a1 + 24, a2, v10, (char *)a4, a7);
}

uint64_t re::serializeEnum<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, re::TypeInfo *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **(void **)(a5 + 16);
      uint64_t v15 = **(void **)(a6 + 16);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_12;
        }
      }
    }
    else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
    {
      goto LABEL_12;
    }
    if (*(unsigned __int8 *)(a5 + 12) != *(unsigned __int8 *)(a6 + 12)
      || (uint64_t v18 = re::TypeInfo::name((re::TypeInfo *)a5),
          uint64_t v19 = re::TypeInfo::name((re::TypeInfo *)a6),
          !re::StringID::operator==(v18, v19)))
    {
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
      return 0;
    }
  }
LABEL_12:
  return re::internal::serializeEnumAsBinary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::TypeInfo *)a6, a7);
}

BOOL re::serializeOptional<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11 = (int)a3;
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v23[0] = 0;
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginOptional(a1 + 24, a2, v11, v23, 0);
    if (v23[0])
    {
      uint64_t v18 = *(re::internal **)(a1 + 208);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v25);
      re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)&v26);
      re::internal::translateType(v18, (const re::TypeRegistry *)v24, (uint64_t)v25);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, 0, 0, v25, v25, 1);
      }
    }
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), v25);
    re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)&v26);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v25);
    re::TypeInfo::TypeInfo((uint64_t)v23, (uint64_t)&v26);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)a5);
    BOOL v22 = (*(uint64_t (**)(uint64_t))(v27 + 80))(a4) != 0;
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginOptional(a1 + 24, a2, v11, &v22, 0);
    if (v22)
    {
      uint64_t v20 = (*(uint64_t (**)(uint64_t))(v27 + 80))(a4);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, uint64_t, unsigned char *, unsigned char *, void))(*(void *)a1 + 72))(a1, a2, 0, v20, v24, v23, 0);
      }
    }
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endOptional(v19);
  return *(unsigned char *)(a1 + 64) == 0;
}

uint64_t re::serializeArray<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11 = (int)a3;
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned char *)a6 + 12) != 4) {
    goto LABEL_69;
  }
  uint64_t v18 = (void *)*((void *)a5 + 2);
  uint64_t v19 = (void *)*((void *)a6 + 2);
  int v20 = *((_DWORD *)v19 + 21) & 0xFFFFFF;
  if ((*((_DWORD *)v18 + 21) & 0xFFFFFF) != 0)
  {
    if (v20) {
      goto LABEL_13;
    }
LABEL_69:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a5, a6);
    return 0;
  }
  if (v20 || *((_DWORD *)v18 + 22) != *((_DWORD *)v19 + 22)) {
    goto LABEL_69;
  }
LABEL_13:
  if (a7)
  {
    BOOL v21 = (re::internal *)*((void *)a1 + 26);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v64);
    re::TypeInfo::TypeInfo((uint64_t)v60, (uint64_t)v65);
    re::internal::translateType(v21, (const re::TypeRegistry *)v60, (uint64_t)v61);
    uint64_t v22 = (*(uint64_t (**)(unsigned char *, unsigned char *))(*(void *)a1 + 80))(a1, v61);
    if (v22)
    {
      uint64_t v23 = (void (*)(unsigned char *, void, void, void, unsigned char *, unsigned char *, uint64_t))v22;
      uint64_t v24 = (void *)*((void *)a6 + 2);
      int v25 = *((_DWORD *)v24 + 21) & 0xFFFFFF;
      if (v25) {
        unint64_t v26 = 0;
      }
      else {
        unint64_t v26 = *((int *)v24 + 22);
      }
      unint64_t v64 = v26;
      if (v62 == 1)
      {
        v60[0] = v26 * *(unsigned int *)(v63 + 8);
        int v50 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginBLOB((uint64_t)(a1 + 24), a2, v11, v60, 0);
        uint64_t result = 0;
        if (!v50) {
          return result;
        }
        if (v60[0]) {
          re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeBLOB((uint64_t)(a1 + 24), 0, 1);
        }
        uint64_t v34 = (_anonymous_namespace_ *)(a1 + 24);
        goto LABEL_48;
      }
      if (v25) {
        int v51 = 8;
      }
      else {
        int v51 = 4;
      }
      uint64_t v43 = (_anonymous_namespace_ *)(a1 + 24);
      uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginArray((uint64_t)(a1 + 24), a2, v11, &v64, v51);
      if (result)
      {
        unint64_t v52 = v64;
        if (v25) {
          BOOL v53 = v64 == 0;
        }
        else {
          BOOL v53 = 1;
        }
        char v54 = v53;
        if (!v53)
        {
          v59[0] = 0;
          v59[1] = 0xFFFFFFFFLL;
          (*(void (**)(unsigned char *, void, void *))(*(void *)a1 + 16))(a1, 0, v59);
          unint64_t v52 = v64;
        }
        if (v52)
        {
          unint64_t v55 = 0;
          do
          {
            v23(a1, 0, 0, 0, v61, v61, 1);
            ++v55;
          }
          while (v55 < v64);
        }
        if (v54) {
          goto LABEL_41;
        }
        goto LABEL_40;
      }
      return result;
    }
    goto LABEL_23;
  }
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v64);
  re::TypeInfo::TypeInfo((uint64_t)v61, (uint64_t)v65);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v64);
  re::TypeInfo::TypeInfo((uint64_t)v60, (uint64_t)v65);
  re::TypeInfo::TypeInfo((uint64_t)&v64, (uint64_t)a5);
  uint64_t v27 = (*(uint64_t (**)(unsigned char *, unsigned char *))(*(void *)a1 + 80))(a1, v61);
  if (!v27)
  {
LABEL_23:
    uint64_t v35 = re::TypeInfo::name((re::TypeInfo *)v61);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v36, v37, v38, v39, v40, v35[1]);
    return 0;
  }
  uint64_t v28 = (void (*)(unsigned char *, void, void, uint64_t, unsigned char *, unint64_t *, void))v27;
  uint64_t v29 = re::ArrayAccessor::size((re::ArrayAccessor *)&v64, a4);
  unint64_t v58 = v29;
  if (v62 == 1)
  {
    uint64_t v30 = v29;
    uint64_t v57 = v29 * *(unsigned int *)(v63 + 8);
    int v31 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginBLOB((uint64_t)(a1 + 24), a2, v11, (unint64_t *)&v57, 0);
    uint64_t result = 0;
    if (!v31) {
      return result;
    }
    if (v30)
    {
      uint64_t v33 = (char *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v64, a4, 0);
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeBLOB((uint64_t)(a1 + 24), v33, 0);
    }
    uint64_t v34 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_48:
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endBLOB(v34);
    return a1[64] == 0;
  }
  int v41 = *(_DWORD *)(*((void *)a5 + 2) + 84) & 0xFFFFFF;
  if (v41) {
    int v42 = 8;
  }
  else {
    int v42 = 4;
  }
  uint64_t v43 = (_anonymous_namespace_ *)(a1 + 24);
  uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginArray((uint64_t)(a1 + 24), a2, v11, &v58, v42);
  if (result)
  {
    unint64_t v44 = v58;
    if (v41) {
      BOOL v45 = v58 == 0;
    }
    else {
      BOOL v45 = 1;
    }
    char v46 = v45;
    if (!v45)
    {
      uint64_t v47 = *(void *)a4;
      v56[0] = 0;
      v56[1] = 0xFFFFFFFFLL;
      (*(void (**)(unsigned char *, uint64_t, void *))(*(void *)a1 + 16))(a1, v47, v56);
      unint64_t v44 = v58;
    }
    if (v44)
    {
      unint64_t v48 = 0;
      do
      {
        uint64_t v49 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v64, a4, v48);
        v28(a1, 0, 0, v49, v61, v60, 0);
        ++v48;
      }
      while (v48 < v58);
    }
    if (v46) {
      goto LABEL_41;
    }
LABEL_40:
    (*(void (**)(unsigned char *))(*(void *)a1 + 24))(a1);
LABEL_41:
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endArray(v43);
    return a1[64] == 0;
  }
  return result;
}

BOOL re::serializeList<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11 = (int)a3;
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v58);
    re::TypeInfo::TypeInfo((uint64_t)v55, (uint64_t)&v59);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v58);
    re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)&v59);
    re::TypeInfo::TypeInfo((uint64_t)&v58, (uint64_t)a5);
    uint64_t v23 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v55);
    if (!v23) {
      goto LABEL_27;
    }
    uint64_t v24 = (void (*)(uint64_t, void, void, uint64_t, unsigned char *, unint64_t *, void))v23;
    uint64_t v25 = (*(uint64_t (**)(uint64_t))(v60 + 80))(a4);
    unint64_t v53 = v25;
    if (*((unsigned char *)a5 + 12) == 5 && (*(unsigned char *)(*((void *)a5 + 2) + 48) & 8) != 0 && v56 == 1)
    {
      uint64_t v26 = v25;
      v52[0] = v25 * *(unsigned int *)(v57 + 8);
      int v27 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginBLOB(a1 + 24, a2, v11, v52, 0);
      BOOL result = 0;
      if (!v27) {
        return result;
      }
      if (v26)
      {
        uint64_t v28 = (char *)(*(uint64_t (**)(uint64_t, void))(v60 + 96))(a4, 0);
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeBLOB(a1 + 24, v28, 0);
      }
      uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_26;
    }
    int v34 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginArray(a1 + 24, a2, v11, &v53, 0);
    BOOL result = 0;
    if (!v34) {
      return result;
    }
    if (*(void *)(v60 + 96))
    {
      if (v53)
      {
        for (unint64_t i = 0; i < v53; ++i)
        {
          uint64_t v36 = (*(uint64_t (**)(uint64_t, unint64_t))(v60 + 96))(a4, i);
          v24(a1, 0, 0, v36, v55, v54, 0);
        }
      }
LABEL_36:
      uint64_t v37 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_42:
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endArray(v37);
      return *(unsigned char *)(a1 + 64) == 0;
    }
    int v41 = *(uint64_t (**)(uint64_t, void))(v60 + 104);
    if (v41 && *(void *)(v60 + 112) && *(void *)(v60 + 120))
    {
      uint64_t v42 = v41(a4, *(void *)(a1 + 56));
      uint64_t v43 = (*(uint64_t (**)(void))(v60 + 112))();
      if (v43)
      {
        uint64_t v44 = v43;
        do
        {
          v24(a1, 0, 0, v44, v55, v54, 0);
          uint64_t v44 = (*(uint64_t (**)(uint64_t))(v60 + 112))(v42);
        }
        while (v44);
      }
      (*(void (**)(uint64_t, void))(v60 + 120))(v42, *(void *)(a1 + 56));
      goto LABEL_36;
    }
    re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)&v58);
    uint64_t v51 = re::TypeInfo::name((re::TypeInfo *)v52)[1];
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "List type \"%s\" does not provide an indexer or iterator.", v45, v46, v47, v48, v49, v51);
    return 0;
  }
  uint64_t v18 = *(re::internal **)(a1 + 208);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v58);
  re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)&v59);
  re::internal::translateType(v18, (const re::TypeRegistry *)v54, (uint64_t)v55);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v55);
  if (!v19)
  {
LABEL_27:
    uint64_t v50 = re::TypeInfo::name((re::TypeInfo *)v55)[1];
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v29, v30, v31, v32, v33, v50);
    return 0;
  }
  unint64_t v58 = 0;
  if (v56 != 1)
  {
    uint64_t v38 = (void (*)(uint64_t, void, void, void, unsigned char *, unsigned char *, uint64_t))v19;
    int v39 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginArray(a1 + 24, a2, v11, &v58, 0);
    BOOL result = 0;
    if (!v39) {
      return result;
    }
    if (v58)
    {
      for (unint64_t j = 0; j < v58; ++j)
        v38(a1, 0, 0, 0, v55, v55, 1);
    }
    uint64_t v37 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_42;
  }
  v54[0] = 0;
  int v20 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginBLOB(a1 + 24, a2, v11, v54, 0);
  BOOL result = 0;
  if (!v20) {
    return result;
  }
  if (v54[0]) {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeBLOB(a1 + 24, 0, 1);
  }
  uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_26:
  re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endBLOB(v22);
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11 = (int)a3;
  uint64_t v90 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v85);
    re::TypeInfo::TypeInfo((uint64_t)v75, (uint64_t)&v85.n128_i64[1]);
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v85);
    re::TypeInfo::TypeInfo((uint64_t)v74, (uint64_t)&v85.n128_i64[1]);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v85);
    re::TypeInfo::TypeInfo((uint64_t)v73, (uint64_t)&v85.n128_i64[1]);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v85);
    re::TypeInfo::TypeInfo((uint64_t)v72, (uint64_t)&v85.n128_i64[1]);
    re::TypeInfo::TypeInfo((uint64_t)v70, (uint64_t)a5);
    uint64_t v29 = (*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 80))(a1, v75);
    if (!v29)
    {
      uint64_t v51 = (re::TypeInfo *)v75;
      goto LABEL_45;
    }
    uint64_t v30 = (void (*)(uint64_t, const char *, void, uint64_t, void *, unsigned char *, void, double))v29;
    uint64_t v31 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v74);
    if (!v31)
    {
      uint64_t v51 = (re::TypeInfo *)v74;
      goto LABEL_45;
    }
    uint64_t v32 = (void (*)(uint64_t, const char *, void, uint64_t, unsigned char *, unsigned char *, void))v31;
    unint64_t v69 = (*(uint64_t (**)(uint64_t))(v71 + 88))(a4);
    int v33 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionary(a1 + 24, a2, v11, &v69, 0);
    BOOL result = 0;
    if (!v33) {
      return result;
    }
    if (v69)
    {
      uint64_t v34 = *(void *)a5;
      v85.n128_u64[0] = 0x449AD97C4B77BED4;
      v85.n128_u64[1] = (unint64_t)"_CompareFunc";
      uint64_t v35 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v34 + 200, &v85);
      if (v35)
      {
        unint64_t v36 = *v35;
        re::StringID::destroyString((re::StringID *)&v85);
        if (v34)
        {
          unint64_t v37 = *(void *)v75[2];
          v85.n128_u64[0] = v36;
          v85.n128_u64[1] = v37;
          LODWORD(v86) = -1;
          uint64_t v38 = (unint64_t *)re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v75[0] + 768, (uint64_t *)&v85);
          if (v38)
          {
            unint64_t v39 = *v38;
            if (*v38)
            {
              uint64_t v68 = 0;
              v65[1] = 0;
              unint64_t v66 = 0;
              int v67 = 0;
              v65[0] = *(void *)(a1 + 56);
              re::DynamicArray<re::RigNodeConstraint>::setCapacity(v65, v69);
              ++v67;
              uint64_t v40 = (*(uint64_t (**)(uint64_t, void))(v71 + 112))(a4, *(void *)(a1 + 56));
              if ((*(unsigned int (**)(void))(v71 + 120))())
              {
                do
                {
                  uint64_t v41 = (*(uint64_t (**)(uint64_t))(v71 + 128))(v40);
                  uint64_t v42 = (*(uint64_t (**)(uint64_t))(v71 + 136))(v40);
                  v85.n128_u64[0] = v41;
                  v85.n128_u64[1] = v42;
                  __n128 v43 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)v65, &v85);
                }
                while (((*(uint64_t (**)(uint64_t, __n128))(v71 + 120))(v40, v43) & 1) != 0);
              }
              (*(void (**)(uint64_t, void))(v71 + 144))(v40, *(void *)(a1 + 56));
              v85.n128_u64[0] = v39;
              unint64_t v45 = 126 - 2 * __clz(v66);
              if (v66) {
                uint64_t v46 = v45;
              }
              else {
                uint64_t v46 = 0;
              }
              std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(v68, (char *)&v68[2 * v66], (uint64_t (**)(unint64_t, unint64_t))&v85, v46, 1, v44);
              if (v69)
              {
                uint64_t v47 = 0;
                for (unint64_t i = 0; i < v69; ++i)
                {
                  double v49 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
                  if (v66 <= i)
                  {
                    uint64_t v76 = 0;
                    long long v88 = 0u;
                    long long v89 = 0u;
                    long long v86 = 0u;
                    long long v87 = 0u;
                    __n128 v85 = 0u;
                    unint64_t v63 = v66;
                    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                    int v77 = 136315906;
                    uint64_t v78 = "operator[]";
                    __int16 v79 = 1024;
                    int v80 = 789;
                    __int16 v81 = 2048;
                    unint64_t v82 = i;
                    __int16 v83 = 2048;
                    unint64_t v84 = v63;
                    _os_log_send_and_compose_impl();
                    _os_crash_msg();
                    __break(1u);
LABEL_56:
                    uint64_t v76 = 0;
                    long long v88 = 0u;
                    long long v89 = 0u;
                    long long v86 = 0u;
                    long long v87 = 0u;
                    __n128 v85 = 0u;
                    unint64_t v64 = v50;
                    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                    int v77 = 136315906;
                    uint64_t v78 = "operator[]";
                    __int16 v79 = 1024;
                    int v80 = 789;
                    __int16 v81 = 2048;
                    unint64_t v82 = i;
                    __int16 v83 = 2048;
                    unint64_t v84 = v64;
                    _os_log_send_and_compose_impl();
                    _os_crash_msg();
                    __break(1u);
                  }
                  v30(a1, "key", 0, v68[v47], v75, v73, 0, v49);
                  unint64_t v50 = v66;
                  if (v66 <= i) {
                    goto LABEL_56;
                  }
                  v32(a1, "value", 0, v68[v47 + 1], v74, v72, 0);
                  re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
                  v47 += 2;
                }
              }
              if (v65[0] && v68) {
                (*(void (**)(void))(*(void *)v65[0] + 40))();
              }
              goto LABEL_53;
            }
          }
        }
      }
      else
      {
        re::StringID::destroyString((re::StringID *)&v85);
      }
      uint64_t v58 = (*(uint64_t (**)(uint64_t, void))(v71 + 112))(a4, *(void *)(a1 + 56));
      (*(void (**)(void))(v71 + 120))();
      if (v69)
      {
        for (unint64_t j = 0; j < v69; ++j)
        {
          double v60 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
          uint64_t v61 = (*(uint64_t (**)(uint64_t, double))(v71 + 128))(v58, v60);
          ((void (*)(uint64_t, const char *, void, uint64_t, void *, unsigned char *, void))v30)(a1, "key", 0, v61, v75, v73, 0);
          uint64_t v62 = (*(uint64_t (**)(uint64_t))(v71 + 136))(v58);
          v32(a1, "value", 0, v62, v74, v72, 0);
          re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
          (*(void (**)(uint64_t))(v71 + 120))(v58);
        }
      }
      (*(void (**)(uint64_t, void))(v71 + 144))(v58, *(void *)(a1 + 56));
    }
LABEL_53:
    uint64_t v28 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_54:
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endDictionary(v28);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  uint64_t v18 = *(re::internal **)(a1 + 208);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v85);
  re::TypeInfo::TypeInfo((uint64_t)&v77, (uint64_t)&v85.n128_i64[1]);
  re::internal::translateType(v18, (const re::TypeRegistry *)&v77, (uint64_t)v65);
  uint64_t v19 = *(re::internal **)(a1 + 208);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v85);
  re::TypeInfo::TypeInfo((uint64_t)v75, (uint64_t)&v85.n128_i64[1]);
  re::internal::translateType(v19, (const re::TypeRegistry *)v75, (uint64_t)&v77);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 80))(a1, v65);
  if (!v20)
  {
    uint64_t v51 = (re::TypeInfo *)v65;
LABEL_45:
    unint64_t v52 = re::TypeInfo::name(v51);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v53, v54, v55, v56, v57, v52[1]);
    return 0;
  }
  BOOL v21 = (void (*)(uint64_t, const char *, void, void, void *, void *, uint64_t, double))v20;
  uint64_t v22 = (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 80))(a1, &v77);
  if (!v22)
  {
    uint64_t v51 = (re::TypeInfo *)&v77;
    goto LABEL_45;
  }
  uint64_t v23 = (void (*)(uint64_t, const char *, void, void, int *, int *, uint64_t))v22;
  v85.n128_u64[0] = 0;
  int v24 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionary(a1 + 24, a2, v11, v85.n128_u64, 0);
  BOOL result = 0;
  if (v24)
  {
    if (v85.n128_u64[0])
    {
      unint64_t v26 = 0;
      do
      {
        double v27 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 1);
        v21(a1, "key", 0, 0, v65, v65, 1, v27);
        v23(a1, "value", 0, 0, &v77, &v77, 1);
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
        ++v26;
      }
      while (v26 < v85.n128_u64[0]);
    }
    uint64_t v28 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_54;
  }
  return result;
}

uint64_t re::serializeUnion<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  int v11 = (int)a3;
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v15 = **((void **)a5 + 2);
    uint64_t v16 = **((void **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      BOOL v18 = WORD1(v15) == WORD1(v16);
      uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      BOOL v18 = v18 && v17 == 0;
      if (v18) {
        goto LABEL_4;
      }
    }
LABEL_19:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_19;
  }
LABEL_4:
  uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginObject((uint64_t)(a1 + 24), a2, v11, 16);
  if (a7)
  {
    if (!result) {
      return result;
    }
    v19[0] = 0;
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned long long>((uint64_t)(a1 + 24), "tag", 0, (uint64_t *)v19, 0);
    if (v19[0] < *(unsigned int *)(*((void *)a6 + 2) + 88))
    {
      re::TypeInfo::unionMember(a6, v19[0], (uint64_t)v21);
      if (!a1[64]) {
        (*(void (**)(unsigned char *, const char *, void, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, "value", 0, 0, v21, v21, 1);
      }
    }
  }
  else
  {
    if (!result) {
      return result;
    }
    re::TypeInfo::TypeInfo((uint64_t)v21, (uint64_t)a5);
    unint64_t Tag = re::UnionAccessor::readTag((re::UnionAccessor *)v21, a4);
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned long long>((uint64_t)(a1 + 24), "tag", 0, (uint64_t *)&Tag, 0);
    if (Tag < *(unsigned int *)(*((void *)a5 + 2) + 88))
    {
      re::TypeInfo::unionMember(a5, Tag, (uint64_t)v19);
      if (!a1[64]) {
        (*(void (**)(unsigned char *, const char *, void, char *, unint64_t *, unint64_t *, void))(*(void *)a1 + 72))(a1, "value", 0, a4, v19, v19, 0);
      }
    }
  }
  re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
  return a1[64] == 0;
}

uint64_t re::serializeObject<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  if (a7)
  {
    if (*(unsigned char *)(*((void *)this + 2) + 49))
    {
      uint64_t v19 = *(re::TypeRegistry **)(a1 + 208);
      v35[0] = 0x2686EB529B3EE220;
      v35[1] = "DynamicString";
      re::TypeRegistry::typeInfo(v19, (const re::StringID *)v35, v36);
      re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v37);
      re::StringID::destroyString((re::StringID *)v35);
      uint64_t v20 = (re *)v38;
      BOOL v21 = (const re::TypeInfo *)v38;
      uint64_t v22 = a1;
      uint64_t v23 = a2;
      int v24 = (const re::TypeInfo *)a3;
    }
    else
    {
      uint64_t v14 = re::TypeInfo::name(this);
      if ((unint64_t)*v14 >> 1 != 0x134375A94D9F7110) {
        goto LABEL_6;
      }
      uint64_t v15 = (const char *)v14[1];
      if (v15 != "DynamicString")
      {
        if (strcmp(v15, "DynamicString")) {
          goto LABEL_6;
        }
      }
      uint64_t v22 = a1;
      uint64_t v23 = a2;
      int v24 = (const re::TypeInfo *)a3;
      uint64_t v20 = this;
      BOOL v21 = this;
    }
    re::serializeDynamicString<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(v22, v23, v24, 0, v20, v21, 1);
    return *(unsigned char *)(a1 + 64) == 0;
  }
LABEL_6:
  if ((*(unsigned char *)(*((void *)this + 2) + 48) & 4) == 0)
  {
    int v17 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginObject(a1 + 24, a2, a3, 0);
    uint64_t result = 0;
    if (!v17) {
      return result;
    }
    if (this == (re::TypeInfo *)a6) {
      goto LABEL_11;
    }
    if (*(void *)this == *(void *)a6)
    {
      uint64_t v25 = **((void **)this + 2);
      uint64_t v26 = **(void **)(a6 + 16);
      if ((unsigned __int16)v25 == (unsigned __int16)v26)
      {
        BOOL v28 = WORD1(v25) == WORD1(v26);
        uint64_t v27 = (v26 ^ v25) & 0xFFFFFF00000000;
        BOOL v28 = v28 && v27 == 0;
        if (v28) {
          goto LABEL_11;
        }
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v16))
    {
LABEL_11:
      re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((unsigned char *)a1, a4, (uint64_t *)this, a7);
LABEL_26:
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(unsigned char *)(a1 + 64) == 0;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    }
    else
    {
      uint64_t v29 = re::TypeInfo::name(this)[1];
      re::TypeInfo::name((re::TypeInfo *)a6);
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v30, v31, v32, v33, v34, v29);
    }
    goto LABEL_26;
  }
  return re::internal::serializeObjectWithOneMember<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((unsigned char *)a1, a2, a3, a4, (uint64_t *)this, (uint64_t *)a6, a7);
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeBool(uint64_t a1, const char *a2, int a3, unsigned char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    if (*a4) {
      char v10 = 1;
    }
    else {
      char v10 = 2;
    }
    char __src = v10;
    if (!*(unsigned char *)(a1 + 40)
      && (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, &__src, 1uLL) & 1) == 0)
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Boolean");
    }
    if ((a5 & 2) == 0)
    {
      uint64_t v11 = *(void *)(a1 + 128);
      uint64_t v12 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v11 + 48 * v12) != 2) {
        ++*(void *)(v11 + 48 * v12 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeFloat(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    char __src = 53;
    if (!*(unsigned char *)(a1 + 40))
    {
      if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, &__src, 1uLL) & 1) == 0)re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Float"); {
      if (!*(unsigned char *)(a1 + 40)
      }
        && (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, a4, 4uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Float");
      }
    }
    if ((a5 & 2) == 0)
    {
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v10 + 48 * v11) != 2) {
        ++*(void *)(v10 + 48 * v11 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeDouble(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    char __src = 54;
    if (!*(unsigned char *)(a1 + 40))
    {
      if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, &__src, 1uLL) & 1) == 0)re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Double"); {
      if (!*(unsigned char *)(a1 + 40)
      }
        && (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, a4, 8uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Double");
      }
    }
    if ((a5 & 2) == 0)
    {
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v10 + 48 * v11) != 2) {
        ++*(void *)(v10 + 48 * v11 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(uint64_t a1, const char *a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 128);
  uint64_t v4 = *(void *)(a1 + 112) - 1;
  if (*(unsigned char *)(v3 + 48 * v4) == 2 && (*(unsigned char *)(v3 + 48 * v4 + 4) & 0x40) == 0) {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(a1, a2, a3);
  }
  return 1;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(uint64_t result, const char *a2, uint64_t a3)
{
  uint64_t v5 = (unsigned __int8 *)result;
  if ((unint64_t)(a3 + 1) > 0x28)
  {
    if (a3 == (char)a3)
    {
      LOBYTE(__src) = 48;
      if (!*(unsigned char *)(result + 40))
      {
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
        if ((result & 1) == 0) {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"8-Bit Signed Integer");
        }
        int v7 = v5[40];
        LOBYTE(__src) = a3;
        if (!v7)
        {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, (char *)&__src, 1uLL);
          if ((result & 1) == 0)
          {
            uint64_t v6 = "8-Bit Signed Integer";
            return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
          }
        }
      }
    }
    else
    {
      LOBYTE(__src) = 51;
      if (!*(unsigned char *)(result + 40))
      {
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
        if ((result & 1) == 0) {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"64-Bit Signed Integer");
        }
        int v8 = v5[40];
        uint64_t __src = a3;
        if (!v8)
        {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, (char *)&__src, 8uLL);
          if ((result & 1) == 0)
          {
            uint64_t v6 = "64-Bit Signed Integer";
            return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
          }
        }
      }
    }
  }
  else
  {
    LOBYTE(__src) = a3 + 8;
    if (!*(unsigned char *)(result + 40))
    {
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
      if ((result & 1) == 0)
      {
        uint64_t v6 = "Small Signed Integer";
        return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
      }
    }
  }
  return result;
}

uint64_t re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(void *a1, char *__src, size_t __n)
{
  uint64_t v5 = (int *)(a1 + 2);
  uint64_t v6 = (void **)(a1 + 1);
  if (__src)
  {
    int v7 = __src;
    while (1)
    {
      size_t v8 = *v5;
      if (__n <= v8) {
        break;
      }
      if ((int)v8 >= 1)
      {
        memcpy(*v6, v7, v8);
        uint64_t v9 = *v5;
        v7 += v9;
        __n -= v9;
        *uint64_t v6 = 0;
        int *v5 = 0;
      }
      if (((*(uint64_t (**)(void, void **, int *))(*(void *)*a1 + 16))(*a1, v6, v5) & 1) == 0) {
        return 0;
      }
    }
    memcpy(*v6, v7, __n);
  }
  else
  {
    while (1)
    {
      size_t v12 = *v5;
      if (__n <= v12) {
        break;
      }
      if ((int)v12 >= 1)
      {
        bzero(*v6, v12);
        __n -= *v5;
        *uint64_t v6 = 0;
        int *v5 = 0;
      }
      char v11 = (*(uint64_t (**)(void, void **, int *))(*(void *)*a1 + 16))(*a1, v6, v5);
      uint64_t result = 0;
      if ((v11 & 1) == 0) {
        return result;
      }
    }
    bzero(*v6, __n);
  }
  *uint64_t v6 = (char *)*v6 + __n;
  *v5 -= __n;
  return 1;
}

uint64_t re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(_anonymous_namespace_ *a1, const char *a2, uint64_t a3)
{
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v7);
  if (v8) {
    uint64_t v5 = *(unsigned char **)&v9[7];
  }
  else {
    uint64_t v5 = v9;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: Error %s type %s.", (re::DynamicString *)v10, "serialize", v5, "writing", a3);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v10);
  if (*(void *)&v10[0])
  {
    if (BYTE8(v10[0])) {
      (*(void (**)(void))(**(void **)&v10[0] + 40))();
    }
    memset(v10, 0, sizeof(v10));
  }
  uint64_t result = v7;
  if (v7)
  {
    if (v8) {
      return (*(uint64_t (**)(void))(*(void *)v7 + 40))();
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject(uint64_t result)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  uint64_t v1 = result;
  unsigned __int8 __src = 0;
  uint64_t v2 = *(void *)(result + 168);
  if (v2)
  {
    uint64_t v3 = v2 - 1;
    int v4 = *(unsigned __int8 *)(result + v3 + 160);
    unsigned __int8 __src = v4;
    *(void *)(v1 + 168) = v3;
  }
  else
  {
    if (!re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL))
    {
      size_t v12 = "Member";
      uint64_t v13 = (_anonymous_namespace_ *)v1;
      return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v13, "unknown", (uint64_t)v12);
    }
    int v4 = __src;
  }
  uint64_t result = (uint64_t)re::OPACK::toString(v4);
  uint64_t v5 = result;
  unsigned __int8 v6 = __src;
  if (__src > 0x2Fu)
  {
    switch(__src)
    {
      case '0':
LABEL_20:
        if (*(unsigned char *)(v1 + 40)) {
          return result;
        }
        uint64_t v10 = (void *)v1;
        size_t v11 = 1;
        goto LABEL_73;
      case '1':
LABEL_30:
        if (*(unsigned char *)(v1 + 40)) {
          return result;
        }
        unint64_t v15 = *(void *)(v1 + 168);
        if (!v15)
        {
          size_t v11 = 2;
          goto LABEL_72;
        }
        uint64_t v8 = 2;
        if (v15 >= 2) {
          uint64_t v9 = 2;
        }
        else {
          uint64_t v9 = *(void *)(v1 + 168);
        }
        *(void *)(v1 + 168) = v15 - v9;
        if (v15 != 1) {
          return result;
        }
        goto LABEL_48;
      case '2':
      case '5':
LABEL_23:
        if (*(unsigned char *)(v1 + 40)) {
          return result;
        }
        unint64_t v14 = *(void *)(v1 + 168);
        if (!v14)
        {
          size_t v11 = 4;
          goto LABEL_72;
        }
        uint64_t v8 = 4;
        if (v14 >= 4) {
          uint64_t v9 = 4;
        }
        else {
          uint64_t v9 = *(void *)(v1 + 168);
        }
        *(void *)(v1 + 168) = v14 - v9;
        if (v14 > 3) {
          return result;
        }
        goto LABEL_48;
      case '3':
      case '6':
        goto LABEL_12;
      case '4':
        goto LABEL_37;
      default:
        switch(__src)
        {
          case 0xC1u:
            goto LABEL_20;
          case 0xC2u:
            goto LABEL_30;
          case 0xC3u:
            if (*(unsigned char *)(v1 + 40)) {
              return result;
            }
            unint64_t v18 = *(void *)(v1 + 168);
            if (!v18)
            {
              size_t v11 = 3;
              goto LABEL_72;
            }
            uint64_t v19 = 3;
            if (v18 < 3) {
              uint64_t v19 = *(void *)(v1 + 168);
            }
            *(void *)(v1 + 168) = v18 - v19;
            size_t v11 = v19 ^ 3;
            if (v19 == 3) {
              return result;
            }
            goto LABEL_72;
          case 0xC4u:
            goto LABEL_23;
          default:
            goto LABEL_37;
        }
    }
  }
  if (__src - 1 >= 4)
  {
    if (__src == 5)
    {
      if (*(unsigned char *)(v1 + 40)) {
        return result;
      }
      unint64_t v17 = *(void *)(v1 + 168);
      if (!v17)
      {
        size_t v11 = 16;
        goto LABEL_72;
      }
      uint64_t v8 = 16;
      if (v17 >= 0x10) {
        uint64_t v9 = 16;
      }
      else {
        uint64_t v9 = *(void *)(v1 + 168);
      }
      *(void *)(v1 + 168) = v17 - v9;
      if (v17 > 0xF) {
        return result;
      }
    }
    else
    {
      if (__src != 6)
      {
LABEL_37:
        if (__src - 7 < 0x29) {
          return result;
        }
        if (__src - 64 > 0x24)
        {
          if (__src - 112 > 0x24)
          {
            if ((__src + 96) >= 0x21u)
            {
              if ((__src + 48) > 0xEu)
              {
                if (__src == 223)
                {
                  uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readTag(v1, "unknown", (char *)&__src, (uint64_t)"Array value/terminator");
                  if (result)
                  {
                    do
                    {
                      unsigned __int8 v23 = __src;
                      if (__src == 3) {
                        break;
                      }
                      unint64_t v24 = *(void *)(v1 + 168);
                      if (v24 <= 7)
                      {
                        *(void *)(v1 + 168) = v24 + 1;
                        *(unsigned char *)(v1 + v24 + 160) = v23;
                      }
                      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject(v1);
                      uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readTag(v1, "unknown", (char *)&__src, (uint64_t)"Array value/terminator");
                    }
                    while ((result & 1) != 0);
                  }
                }
                else if ((__src + 32) > 0xEu)
                {
                  if (__src == 239)
                  {
                    for (uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readTag(v1, "unknown", (char *)&__src, (uint64_t)"Dictionary key/value/terminator");
                          result;
                          uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readTag(v1, "unknown", (char *)&__src, (uint64_t)"Dictionary key/value/terminator"))
                    {
                      unsigned __int8 v28 = __src;
                      if (__src == 3) {
                        break;
                      }
                      unint64_t v29 = *(void *)(v1 + 168);
                      if (v29 <= 7)
                      {
                        *(void *)(v1 + 168) = v29 + 1;
                        *(unsigned char *)(v1 + v29 + 160) = v28;
                      }
                      uint64_t v30 = -2;
                      do
                      {
                        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject(v1);
                        BOOL v27 = __CFADD__(v30++, 1);
                      }
                      while (!v27);
                    }
                  }
                  else
                  {
                    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)v1, 0, (re::DynamicString *)&v32);
                    if (v33) {
                      uint64_t v31 = *(unsigned char **)&v34[7];
                    }
                    else {
                      uint64_t v31 = v34;
                    }
                    re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Found unsupported tag while skipping over data.", (re::DynamicString *)&v35, v31);
                    __n[0] = 400;
                    __n[1] = (size_t)re::FoundationErrorCategory(void)::instance;
                    __n[2] = v35;
                    __n[5] = v37;
                    *(_OWORD *)&__n[3] = v36;
                    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (long long *)__n);
                    if (__n[2])
                    {
                      if (__n[3]) {
                        (*(void (**)(void))(*(void *)__n[2] + 40))();
                      }
                      memset(&__n[2], 0, 32);
                    }
                    uint64_t result = v32;
                    if (v32 && (v33 & 1) != 0) {
                      return (*(uint64_t (**)(void))(*(void *)v32 + 40))();
                    }
                  }
                }
                else
                {
                  unint64_t v25 = *(void *)(v1 + 168);
                  if (v25 <= 7)
                  {
                    *(void *)(v1 + 168) = v25 + 1;
                    *(unsigned char *)(v1 + v25 + 160) = v6;
                  }
                  __n[0] = 0;
                  uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readDictionaryTag(v1, "unknown", (char *)__n);
                  if (2 * __n[0])
                  {
                    size_t v26 = -2 * __n[0];
                    do
                    {
                      uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject(v1);
                      BOOL v27 = __CFADD__(v26++, 1);
                    }
                    while (!v27);
                  }
                }
              }
              else
              {
                unint64_t v21 = *(void *)(v1 + 168);
                if (v21 <= 7)
                {
                  *(void *)(v1 + 168) = v21 + 1;
                  *(unsigned char *)(v1 + v21 + 160) = v6;
                }
                __n[0] = 0;
                uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readArrayTag(v1, "unknown", (char *)__n);
                for (i = __n[0]; i; uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject(v1))
                  --i;
              }
            }
            return result;
          }
          unint64_t v20 = *(void *)(v1 + 168);
          if (v20 <= 7)
          {
            *(void *)(v1 + 168) = v20 + 1;
            *(unsigned char *)(v1 + v20 + 160) = v6;
          }
          __n[0] = 0;
          re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readDataTag(v1, "unknown", (uint64_t *)__n);
        }
        else
        {
          unint64_t v16 = *(void *)(v1 + 168);
          if (v16 <= 7)
          {
            *(void *)(v1 + 168) = v16 + 1;
            *(unsigned char *)(v1 + v16 + 160) = v6;
          }
          __n[0] = 0;
          re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readStringTag(v1, "unknown", (uint64_t *)__n);
        }
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readRaw(v1, "unknown", 0, __n[0], v5, 1);
      }
LABEL_12:
      if (*(unsigned char *)(v1 + 40)) {
        return result;
      }
      unint64_t v7 = *(void *)(v1 + 168);
      if (!v7)
      {
        size_t v11 = 8;
        goto LABEL_72;
      }
      uint64_t v8 = 8;
      if (v7 >= 8) {
        uint64_t v9 = 8;
      }
      else {
        uint64_t v9 = *(void *)(v1 + 168);
      }
      *(void *)(v1 + 168) = v7 - v9;
      if (v7 > 7) {
        return result;
      }
    }
LABEL_48:
    size_t v11 = v8 - v9;
LABEL_72:
    uint64_t v10 = (void *)v1;
LABEL_73:
    uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v10, 0, v11);
    if ((result & 1) == 0)
    {
      uint64_t v13 = (_anonymous_namespace_ *)v1;
      size_t v12 = (const char *)v5;
      return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v13, "unknown", (uint64_t)v12);
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readTag(uint64_t a1, const char *a2, char *__src, uint64_t a4)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    uint64_t v6 = *(void *)(a1 + 168);
    if (v6)
    {
      uint64_t v7 = v6 - 1;
      void *__src = *(unsigned char *)(a1 + v7 + 160);
      *(void *)(a1 + 168) = v7;
      return 1;
    }
    uint64_t v4 = 1;
    if (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, __src, 1uLL))return v4; {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a4);
    }
  }
  return 0;
}

const char *re::OPACK::toString(int a1)
{
  if (a1 <= 96)
  {
    uint64_t result = "Invalid";
    switch(a1)
    {
      case 0:
        return result;
      case 1:
        uint64_t result = "Boolean(True)";
        break;
      case 2:
        uint64_t result = "Boolean(False)";
        break;
      case 3:
        uint64_t result = "Terminator";
        break;
      case 4:
        uint64_t result = "Null";
        break;
      case 5:
        uint64_t result = "UUID";
        break;
      case 6:
        uint64_t result = "Date";
        break;
      default:
        switch(a1)
        {
          case '0':
            uint64_t result = "8-Bit Signed Integer";
            break;
          case '1':
            uint64_t result = "16-Bit Signed Integer";
            break;
          case '2':
            uint64_t result = "32-Bit Signed Integer";
            break;
          case '3':
            uint64_t result = "64-Bit Signed Integer";
            break;
          case '5':
            uint64_t result = "32-Bit Floating Point";
            break;
          case '6':
            uint64_t result = "64-Bit Floating Point";
            break;
          default:
            goto LABEL_35;
        }
        break;
    }
  }
  else if (a1 > 158)
  {
    if (a1 > 222)
    {
      if (a1 == 223)
      {
        return "Array";
      }
      else if (a1 == 239)
      {
        return "Dictionary";
      }
      else
      {
LABEL_35:
        if (a1 >= 0x30)
        {
          if ((a1 - 64) >= 0x21)
          {
            if ((a1 - 112) >= 0x21)
            {
              if ((a1 + 96) >= 0x21u)
              {
                if ((a1 + 48) >= 0xFu)
                {
                  if ((a1 + 32) >= 0xFu) {
                    return "Unknown Tag";
                  }
                  else {
                    return "Small Dictionary";
                  }
                }
                else
                {
                  return "Small Array";
                }
              }
              else
              {
                return "Small UID";
              }
            }
            else
            {
              return "Small Data";
            }
          }
          else
          {
            return "Small String";
          }
        }
        else
        {
          return "Small Signed Integer";
        }
      }
    }
    else
    {
      switch(a1)
      {
        case 193:
          uint64_t result = "8-Bit UID";
          break;
        case 194:
          uint64_t result = "16-Bit UID";
          break;
        case 195:
          uint64_t result = "24-Bit UID";
          break;
        case 196:
          uint64_t result = "32-Bit UID";
          break;
        default:
          if (a1 != 159) {
            goto LABEL_35;
          }
          uint64_t result = "Data(Chunked)";
          break;
      }
    }
  }
  else
  {
    switch(a1)
    {
      case 'a':
        uint64_t result = "String(8-Bit Length)";
        break;
      case 'b':
        uint64_t result = "String(16-Bit Length)";
        break;
      case 'c':
        uint64_t result = "String(32-Bit Length)";
        break;
      case 'd':
        uint64_t result = "String(64-Bit Length)";
        break;
      default:
        JUMPOUT(0);
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readRaw(uint64_t a1, const char *a2, unsigned char *a3, size_t __n, uint64_t a5, char a6)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  size_t v10 = *(void *)(a1 + 168);
  if (v10)
  {
    if (v10 >= __n) {
      size_t v11 = __n;
    }
    else {
      size_t v11 = *(void *)(a1 + 168);
    }
    int64_t v12 = v10 - v11;
    if ((uint64_t)(v10 - 1) >= (uint64_t)(v10 - v11))
    {
      do
      {
        *a3++ = *(unsigned char *)(a1 + 159 + v10);
        int64_t v13 = v10 - 2;
        --v10;
      }
      while (v13 >= v12);
    }
    *(void *)(a1 + 168) = v12;
    __n -= v11;
  }
  if (__n)
  {
    unint64_t v14 = (a6 & 1) != 0 ? 0 : a3;
    if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, v14, __n) & 1) == 0)
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
      return 0;
    }
  }
  return 1;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readStringTag(uint64_t result, const char *a2, uint64_t *a3)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  uint64_t v5 = result;
  unsigned __int8 __src = 0;
  uint64_t v6 = *(void *)(result + 168);
  if (v6)
  {
    uint64_t v7 = v6 - 1;
    uint64_t result = *(unsigned __int8 *)(result + v7 + 160);
    unsigned __int8 __src = *(unsigned char *)(v5 + v7 + 160);
    *(void *)(v5 + 168) = v7;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL) & 1) == 0)return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String"); {
    uint64_t result = __src;
    }
  }
  if ((result - 64) > 0x20)
  {
    switch((int)result)
    {
      case 'a':
        LOBYTE(v32) = 0;
        if (!*(unsigned char *)(v5 + 40))
        {
          uint64_t v8 = *(void *)(v5 + 168);
          if (v8)
          {
            uint64_t v9 = v8 - 1;
            LODWORD(v8) = *(unsigned __int8 *)(v5 + v8 - 1 + 160);
            *(void *)(v5 + 168) = v9;
          }
          else
          {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)v5, (char *)&v32, 1uLL);
            if (!result) {
              return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
            }
            LODWORD(v8) = v32;
          }
          uint64_t v8 = v8;
          goto LABEL_8;
        }
        return result;
      case 'b':
        LOWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v11 = *(void *)(v5 + 168);
        if (v11)
        {
          uint64_t v12 = 2;
          if (v11 < 2) {
            uint64_t v12 = *(void *)(v5 + 168);
          }
          int64_t v13 = v11 - v12;
          if ((uint64_t)(v11 - 1) >= (uint64_t)(v11 - v12))
          {
            unint64_t v14 = (char *)&v32;
            uint64_t v26 = *(void *)(v5 + 168);
            do
            {
              *v14++ = *(unsigned char *)(v5 + 159 + v26);
              int64_t v27 = v26 - 2;
              --v26;
            }
            while (v27 >= v13);
          }
          else
          {
            unint64_t v14 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v13;
          if (v11 > 1)
          {
LABEL_43:
            uint64_t v8 = (unsigned __int16)v32;
            goto LABEL_8;
          }
          size_t v25 = 2 - v12;
        }
        else
        {
          unint64_t v14 = (char *)&v32;
          size_t v25 = 2;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)v5, v14, v25);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
        }
        goto LABEL_43;
      case 'c':
        LODWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v15 = *(void *)(v5 + 168);
        if (v15)
        {
          uint64_t v16 = 4;
          if (v15 < 4) {
            uint64_t v16 = *(void *)(v5 + 168);
          }
          int64_t v17 = v15 - v16;
          if ((uint64_t)(v15 - 1) >= (uint64_t)(v15 - v16))
          {
            unint64_t v18 = (char *)&v32;
            uint64_t v28 = *(void *)(v5 + 168);
            do
            {
              *v18++ = *(unsigned char *)(v5 + 159 + v28);
              int64_t v29 = v28 - 2;
              --v28;
            }
            while (v29 >= v17);
          }
          else
          {
            unint64_t v18 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v17;
          if (v15 > 3) {
            goto LABEL_49;
          }
          size_t v23 = 4 - v16;
        }
        else
        {
          unint64_t v18 = (char *)&v32;
          size_t v23 = 4;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)v5, v18, v23);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
        }
LABEL_49:
        uint64_t v8 = v32;
        goto LABEL_8;
      case 'd':
        uint64_t v32 = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v19 = *(void *)(v5 + 168);
        if (v19)
        {
          uint64_t v20 = 8;
          if (v19 < 8) {
            uint64_t v20 = *(void *)(v5 + 168);
          }
          int64_t v21 = v19 - v20;
          if ((uint64_t)(v19 - 1) >= (uint64_t)(v19 - v20))
          {
            uint64_t v22 = (char *)&v32;
            uint64_t v30 = *(void *)(v5 + 168);
            do
            {
              *v22++ = *(unsigned char *)(v5 + 159 + v30);
              int64_t v31 = v30 - 2;
              --v30;
            }
            while (v31 >= v21);
          }
          else
          {
            uint64_t v22 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v21;
          if (v19 > 7) {
            goto LABEL_55;
          }
          size_t v24 = 8 - v20;
        }
        else
        {
          uint64_t v22 = (char *)&v32;
          size_t v24 = 8;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)v5, v22, v24);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
        }
LABEL_55:
        uint64_t v8 = v32;
        goto LABEL_8;
      default:
        size_t v10 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"String", (uint64_t)v10);
    }
  }
  uint64_t v8 = result - 64;
LABEL_8:
  *a3 = v8;
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readDataTag(uint64_t result, const char *a2, uint64_t *a3)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  uint64_t v5 = result;
  unsigned __int8 __src = 0;
  uint64_t v6 = *(void *)(result + 168);
  if (v6)
  {
    uint64_t v7 = v6 - 1;
    uint64_t result = *(unsigned __int8 *)(result + v7 + 160);
    unsigned __int8 __src = *(unsigned char *)(v5 + v7 + 160);
    *(void *)(v5 + 168) = v7;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL) & 1) == 0)return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB"); {
    uint64_t result = __src;
    }
  }
  if ((result - 112) > 0x20)
  {
    switch((int)result)
    {
      case 145:
        LOBYTE(v32) = 0;
        if (!*(unsigned char *)(v5 + 40))
        {
          uint64_t v8 = *(void *)(v5 + 168);
          if (v8)
          {
            uint64_t v9 = v8 - 1;
            LODWORD(v8) = *(unsigned __int8 *)(v5 + v8 - 1 + 160);
            *(void *)(v5 + 168) = v9;
          }
          else
          {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)v5, (char *)&v32, 1uLL);
            if (!result) {
              return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
            }
            LODWORD(v8) = v32;
          }
          uint64_t v8 = v8;
          goto LABEL_8;
        }
        return result;
      case 146:
        LOWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v11 = *(void *)(v5 + 168);
        if (v11)
        {
          uint64_t v12 = 2;
          if (v11 < 2) {
            uint64_t v12 = *(void *)(v5 + 168);
          }
          int64_t v13 = v11 - v12;
          if ((uint64_t)(v11 - 1) >= (uint64_t)(v11 - v12))
          {
            unint64_t v14 = (char *)&v32;
            uint64_t v26 = *(void *)(v5 + 168);
            do
            {
              *v14++ = *(unsigned char *)(v5 + 159 + v26);
              int64_t v27 = v26 - 2;
              --v26;
            }
            while (v27 >= v13);
          }
          else
          {
            unint64_t v14 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v13;
          if (v11 > 1)
          {
LABEL_43:
            uint64_t v8 = (unsigned __int16)v32;
            goto LABEL_8;
          }
          size_t v25 = 2 - v12;
        }
        else
        {
          unint64_t v14 = (char *)&v32;
          size_t v25 = 2;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)v5, v14, v25);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
        }
        goto LABEL_43;
      case 147:
        LODWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v15 = *(void *)(v5 + 168);
        if (v15)
        {
          uint64_t v16 = 4;
          if (v15 < 4) {
            uint64_t v16 = *(void *)(v5 + 168);
          }
          int64_t v17 = v15 - v16;
          if ((uint64_t)(v15 - 1) >= (uint64_t)(v15 - v16))
          {
            unint64_t v18 = (char *)&v32;
            uint64_t v28 = *(void *)(v5 + 168);
            do
            {
              *v18++ = *(unsigned char *)(v5 + 159 + v28);
              int64_t v29 = v28 - 2;
              --v28;
            }
            while (v29 >= v17);
          }
          else
          {
            unint64_t v18 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v17;
          if (v15 > 3) {
            goto LABEL_49;
          }
          size_t v23 = 4 - v16;
        }
        else
        {
          unint64_t v18 = (char *)&v32;
          size_t v23 = 4;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)v5, v18, v23);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
        }
LABEL_49:
        uint64_t v8 = v32;
        goto LABEL_8;
      case 148:
        uint64_t v32 = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v19 = *(void *)(v5 + 168);
        if (v19)
        {
          uint64_t v20 = 8;
          if (v19 < 8) {
            uint64_t v20 = *(void *)(v5 + 168);
          }
          int64_t v21 = v19 - v20;
          if ((uint64_t)(v19 - 1) >= (uint64_t)(v19 - v20))
          {
            uint64_t v22 = (char *)&v32;
            uint64_t v30 = *(void *)(v5 + 168);
            do
            {
              *v22++ = *(unsigned char *)(v5 + 159 + v30);
              int64_t v31 = v30 - 2;
              --v30;
            }
            while (v31 >= v21);
          }
          else
          {
            uint64_t v22 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v21;
          if (v19 > 7) {
            goto LABEL_55;
          }
          size_t v24 = 8 - v20;
        }
        else
        {
          uint64_t v22 = (char *)&v32;
          size_t v24 = 8;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)v5, v22, v24);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
        }
LABEL_55:
        uint64_t v8 = v32;
        goto LABEL_8;
      default:
        size_t v10 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"BLOB", (uint64_t)v10);
    }
  }
  uint64_t v8 = result - 112;
LABEL_8:
  *a3 = v8;
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readArrayTag(uint64_t result, const char *a2, char *__src)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v5 = (void *)result;
    unsigned __int8 __srca = 0;
    uint64_t v6 = *(void *)(result + 168);
    if (v6)
    {
      uint64_t v7 = v6 - 1;
      uint64_t result = *(unsigned __int8 *)(result + v7 + 160);
      unsigned __int8 __srca = *((unsigned char *)v5 + v7 + 160);
      v5[21] = v7;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__srca, 1uLL) & 1) == 0)return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Array"); {
      uint64_t result = __srca;
      }
    }
    if ((result + 48) > 0xEu)
    {
      if (result == 223)
      {
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readUint64((uint64_t)v5, a2, __src);
      }
      else
      {
        uint64_t v8 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"Array", (uint64_t)v8);
      }
    }
    else
    {
      *(void *)unsigned __int8 __src = result - 208;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readDictionaryTag(uint64_t result, const char *a2, char *__src)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v5 = result;
    unsigned __int8 __srca = 0;
    uint64_t v6 = *(void *)(result + 168);
    if (v6)
    {
      uint64_t v7 = v6 - 1;
      uint64_t result = *(unsigned __int8 *)(result + v7 + 160);
      unsigned __int8 __srca = *(unsigned char *)(v5 + v7 + 160);
      *(void *)(v5 + 168) = v7;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__srca, 1uLL) & 1) == 0)return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Dictionary"); {
      uint64_t result = __srca;
      }
    }
    if ((result + 32) <= 0xEu)
    {
      *(void *)unsigned __int8 __src = result - 224;
      return result;
    }
    if (result != 210) {
      goto LABEL_17;
    }
    uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readUint64(v5, a2, __src);
    if (!result || *(unsigned char *)(v5 + 40)) {
      return result;
    }
    uint64_t v8 = *(void *)(v5 + 168);
    if (v8)
    {
      uint64_t v9 = v8 - 1;
      uint64_t result = *(unsigned __int8 *)(v5 + v9 + 160);
      unsigned __int8 __srca = *(unsigned char *)(v5 + v9 + 160);
      *(void *)(v5 + 168) = v9;
      goto LABEL_16;
    }
    if (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)v5, (char *)&__srca, 1uLL))
    {
      uint64_t result = __srca;
LABEL_16:
      if (result == 239) {
        return result;
      }
LABEL_17:
      size_t v10 = re::OPACK::toString(result);
      return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"Dictionary", (uint64_t)v10);
    }
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Dictionary");
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, 0, (re::DynamicString *)&v8);
  if (v9) {
    uint64_t v6 = *(unsigned char **)&v10[7];
  }
  else {
    uint64_t v6 = v10;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Expected type: \"%s\". Actual type: \"%s\".", (re::DynamicString *)&v11, v6, a2, a3);
  *(void *)&v14[0] = 400;
  *((void *)&v14[0] + 1) = re::FoundationErrorCategory(void)::instance;
  *(void *)&v14[1] = v11;
  *((void *)&v14[2] + 1) = v13;
  *(long long *)((char *)&v14[1] + 8) = v12;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, v14);
  if (*(void *)&v14[1])
  {
    if (BYTE8(v14[1])) {
      (*(void (**)(void))(**(void **)&v14[1] + 40))();
    }
    memset(&v14[1], 0, 32);
  }
  uint64_t result = v8;
  if (v8)
  {
    if (v9) {
      return (*(uint64_t (**)(void))(*(void *)v8 + 40))();
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readUint64(uint64_t a1, const char *a2, char *__src)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  unsigned __int8 __srca = 0;
  uint64_t v7 = *(void *)(a1 + 168);
  if (v7)
  {
    uint64_t v8 = v7 - 1;
    int v9 = *(unsigned __int8 *)(a1 + v7 - 1 + 160);
    unsigned __int8 __srca = v9;
    *(void *)(a1 + 168) = v8;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, (char *)&__srca, 1uLL) & 1) == 0)
    {
LABEL_25:
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"UInt64");
      return 0;
    }
    int v9 = __srca;
  }
  if (v9 != 120)
  {
    unint64_t v16 = *(void *)(a1 + 168);
    if (v16 <= 7)
    {
      *(void *)(a1 + 168) = v16 + 1;
      *(unsigned char *)(a1 + v16 + 160) = v9;
    }
    uint64_t v18 = 0;
    if ((re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readInteger(a1, a2, (char *)&v18, (uint64_t)"Int64") & 1) == 0) {
      return 0;
    }
    *(void *)unsigned __int8 __src = v18;
    return 1;
  }
  if (!*(unsigned char *)(a1 + 40))
  {
    unint64_t v10 = *(void *)(a1 + 168);
    if (v10)
    {
      uint64_t v11 = 8;
      if (v10 < 8) {
        uint64_t v11 = *(void *)(a1 + 168);
      }
      int64_t v12 = v10 - v11;
      if ((uint64_t)(v10 - 1) >= (uint64_t)(v10 - v11))
      {
        uint64_t v13 = *(void *)(a1 + 168);
        do
        {
          *__src++ = *(unsigned char *)(a1 + 159 + v13);
          int64_t v14 = v13 - 2;
          --v13;
        }
        while (v14 >= v12);
      }
      *(void *)(a1 + 168) = v12;
      if (v10 > 7) {
        return 1;
      }
      size_t v15 = 8 - v11;
    }
    else
    {
      size_t v15 = 8;
    }
    if (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, __src, v15))return 1; {
    goto LABEL_25;
    }
  }
  return 0;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::readInteger(uint64_t a1, const char *a2, char *__src, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  unsigned __int8 __srca = 0;
  uint64_t v9 = *(void *)(a1 + 168);
  if (v9)
  {
    uint64_t v10 = v9 - 1;
    unsigned int v11 = *(unsigned __int8 *)(a1 + v10 + 160);
    unsigned __int8 __srca = *(unsigned char *)(a1 + v10 + 160);
    *(void *)(a1 + 168) = v10;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, (char *)&__srca, 1uLL) & 1) == 0)
    {
      int64_t v14 = (_anonymous_namespace_ *)a1;
      size_t v15 = a2;
      unint64_t v16 = (const char *)a4;
      goto LABEL_17;
    }
    unsigned int v11 = __srca;
  }
  if (v11 - 7 > 0x28)
  {
    switch(v11)
    {
      case '0':
        uint64_t result = 0;
        char v40 = 0;
        if (*(unsigned char *)(a1 + 40)) {
          return result;
        }
        uint64_t v12 = *(void *)(a1 + 168);
        if (v12)
        {
          uint64_t v13 = v12 - 1;
          LOBYTE(v12) = *(unsigned char *)(a1 + v12 - 1 + 160);
          *(void *)(a1 + 168) = v13;
LABEL_46:
          uint64_t v12 = (char)v12;
          goto LABEL_10;
        }
        if (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, &v40, 1uLL))
        {
          LOBYTE(v12) = v40;
          goto LABEL_46;
        }
        unint64_t v16 = "8-Bit Signed Integer";
        goto LABEL_63;
      case '1':
        uint64_t result = 0;
        __int16 v39 = 0;
        if (*(unsigned char *)(a1 + 40)) {
          return result;
        }
        unint64_t v18 = *(void *)(a1 + 168);
        if (v18)
        {
          uint64_t v19 = 2;
          if (v18 < 2) {
            uint64_t v19 = *(void *)(a1 + 168);
          }
          int64_t v20 = v18 - v19;
          if ((uint64_t)(v18 - 1) >= (uint64_t)(v18 - v19))
          {
            int64_t v21 = (char *)&v39;
            uint64_t v34 = *(void *)(a1 + 168);
            do
            {
              *v21++ = *(unsigned char *)(a1 + 159 + v34);
              int64_t v35 = v34 - 2;
              --v34;
            }
            while (v35 >= v20);
          }
          else
          {
            int64_t v21 = (char *)&v39;
          }
          *(void *)(a1 + 168) = v20;
          if (v18 > 1) {
            goto LABEL_53;
          }
          size_t v33 = 2 - v19;
        }
        else
        {
          int64_t v21 = (char *)&v39;
          size_t v33 = 2;
        }
        if (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, v21, v33))
        {
LABEL_53:
          uint64_t v12 = v39;
          goto LABEL_10;
        }
        unint64_t v16 = "16-Bit Signed Integer";
        goto LABEL_63;
      case '2':
        uint64_t result = 0;
        int v38 = 0;
        if (*(unsigned char *)(a1 + 40)) {
          return result;
        }
        unint64_t v22 = *(void *)(a1 + 168);
        if (v22)
        {
          uint64_t v23 = 4;
          if (v22 < 4) {
            uint64_t v23 = *(void *)(a1 + 168);
          }
          int64_t v24 = v22 - v23;
          if ((uint64_t)(v22 - 1) >= (uint64_t)(v22 - v23))
          {
            size_t v25 = (char *)&v38;
            uint64_t v36 = *(void *)(a1 + 168);
            do
            {
              *v25++ = *(unsigned char *)(a1 + 159 + v36);
              int64_t v37 = v36 - 2;
              --v36;
            }
            while (v37 >= v24);
          }
          else
          {
            size_t v25 = (char *)&v38;
          }
          *(void *)(a1 + 168) = v24;
          if (v22 > 3) {
            goto LABEL_60;
          }
          size_t v32 = 4 - v23;
        }
        else
        {
          size_t v25 = (char *)&v38;
          size_t v32 = 4;
        }
        if (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, v25, v32))
        {
LABEL_60:
          uint64_t v12 = v38;
          goto LABEL_10;
        }
        unint64_t v16 = "32-Bit Signed Integer";
LABEL_63:
        int64_t v14 = (_anonymous_namespace_ *)a1;
        size_t v15 = a2;
        break;
      case '3':
        if (*(unsigned char *)(a1 + 40)) {
          return 0;
        }
        unint64_t v26 = *(void *)(a1 + 168);
        if (v26)
        {
          uint64_t v27 = 8;
          if (v26 < 8) {
            uint64_t v27 = *(void *)(a1 + 168);
          }
          int64_t v28 = v26 - v27;
          if ((uint64_t)(v26 - 1) >= (uint64_t)(v26 - v27))
          {
            uint64_t v29 = *(void *)(a1 + 168);
            do
            {
              *__src++ = *(unsigned char *)(a1 + 159 + v29);
              int64_t v30 = v29 - 2;
              --v29;
            }
            while (v30 >= v28);
          }
          *(void *)(a1 + 168) = v28;
          if (v26 > 7) {
            return 1;
          }
          size_t v31 = 8 - v27;
        }
        else
        {
          size_t v31 = 8;
        }
        if (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, __src, v31))return 1; {
        unint64_t v16 = "64-Bit Signed Integer";
        }
        goto LABEL_63;
      default:
        int64_t v17 = re::OPACK::toString(v11);
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, a4, (uint64_t)v17);
        return 0;
    }
LABEL_17:
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v14, v15, (uint64_t)v16);
    return 0;
  }
  uint64_t v12 = v11 - 8;
LABEL_10:
  *(void *)unsigned __int8 __src = v12;
  return 1;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<signed char>(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(a1, a2, *a4);
    if ((a5 & 2) == 0)
    {
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v10 + 48 * v11) != 2) {
        ++*(void *)(v10 + 48 * v11 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<short>(uint64_t a1, const char *a2, int a3, __int16 *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(a1, a2, *a4);
    if ((a5 & 2) == 0)
    {
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v10 + 48 * v11) != 2) {
        ++*(void *)(v10 + 48 * v11 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<int>(uint64_t a1, const char *a2, int a3, int *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(a1, a2, *a4);
    if ((a5 & 2) == 0)
    {
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v10 + 48 * v11) != 2) {
        ++*(void *)(v10 + 48 * v11 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<long long>(uint64_t a1, const char *a2, int a3, uint64_t *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(a1, a2, *a4);
    if ((a5 & 2) == 0)
    {
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v10 + 48 * v11) != 2) {
        ++*(void *)(v10 + 48 * v11 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned char>(uint64_t a1, const char *a2, int a3, unsigned __int8 *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(a1, a2, *a4);
    if ((a5 & 2) == 0)
    {
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v10 + 48 * v11) != 2) {
        ++*(void *)(v10 + 48 * v11 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned short>(uint64_t a1, const char *a2, int a3, unsigned __int16 *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(a1, a2, *a4);
    if ((a5 & 2) == 0)
    {
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v10 + 48 * v11) != 2) {
        ++*(void *)(v10 + 48 * v11 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned int>(uint64_t a1, const char *a2, int a3, unsigned int *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(a1, a2, *a4);
    if ((a5 & 2) == 0)
    {
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v10 + 48 * v11) != 2) {
        ++*(void *)(v10 + 48 * v11 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned long long>(uint64_t a1, const char *a2, int a3, uint64_t *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v5 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v5)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeUint64(a1, a2, *a4);
    if ((a5 & 2) == 0)
    {
      uint64_t v10 = *(void *)(a1 + 128);
      uint64_t v11 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v10 + 48 * v11) != 2) {
        ++*(void *)(v10 + 48 * v11 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeUint64(uint64_t a1, const char *a2, uint64_t a3)
{
  if (a3 < 0)
  {
    uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeDataTag(a1, a2, 8uLL);
    uint64_t __src = a3;
    if (!*(unsigned char *)(a1 + 40))
    {
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, (char *)&__src, 8uLL);
      if ((result & 1) == 0) {
        return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"UInt64");
      }
    }
  }
  else
  {
    return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(a1, a2, a3);
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeDataTag(uint64_t result, const char *a2, unint64_t a3)
{
  uint64_t v5 = (unsigned __int8 *)result;
  if (a3 > 0x20)
  {
    if (a3 <= 0xFF)
    {
      LOBYTE(__src) = -111;
      if (!*(unsigned char *)(result + 40))
      {
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
        if ((result & 1) == 0) {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Data(8-Bit Length)");
        }
        int v8 = v5[40];
        LOBYTE(__src) = a3;
        if (!v8)
        {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, (char *)&__src, 1uLL);
          if ((result & 1) == 0)
          {
            uint64_t v6 = "Data(8-Bit Length)";
            return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
          }
        }
      }
    }
    else if (a3 >> 16)
    {
      if (HIDWORD(a3))
      {
        LOBYTE(__src) = -108;
        if (!*(unsigned char *)(result + 40))
        {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
          if ((result & 1) == 0) {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Data(64-Bit Length)");
          }
          int v7 = v5[40];
          unint64_t __src = a3;
          if (!v7)
          {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, (char *)&__src, 8uLL);
            if ((result & 1) == 0)
            {
              uint64_t v6 = "Data(64-Bit Length)";
              return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
            }
          }
        }
      }
      else
      {
        LOBYTE(__src) = -109;
        if (!*(unsigned char *)(result + 40))
        {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
          if ((result & 1) == 0) {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Data(32-Bit Length)");
          }
          int v10 = v5[40];
          LODWORD(__src) = a3;
          if (!v10)
          {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, (char *)&__src, 4uLL);
            if ((result & 1) == 0)
            {
              uint64_t v6 = "Data(32-Bit Length)";
              return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
            }
          }
        }
      }
    }
    else
    {
      LOBYTE(__src) = -110;
      if (!*(unsigned char *)(result + 40))
      {
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
        if ((result & 1) == 0) {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Data(16-Bit Length)");
        }
        int v9 = v5[40];
        LOWORD(__src) = a3;
        if (!v9)
        {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, (char *)&__src, 2uLL);
          if ((result & 1) == 0)
          {
            uint64_t v6 = "Data(16-Bit Length)";
            return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
          }
        }
      }
    }
  }
  else
  {
    LOBYTE(__src) = a3 + 112;
    if (!*(unsigned char *)(result + 40))
    {
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
      if ((result & 1) == 0)
      {
        uint64_t v6 = "Small Data";
        return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeEnumAsBinary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, re::TypeInfo *a4, re::internal *a5, re::TypeInfo *a6, int a7)
{
  if (a7)
  {
    uint64_t v11 = (re::internal *)*((void *)a1 + 26);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v25);
    re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)v26);
    re::internal::translateType(v11, (const re::TypeRegistry *)v24, (uint64_t)v25);
    if (!a1[64]) {
      return (*(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, 0, v25, v25, 1);
    }
    return 0;
  }
  size_t v15 = *(void **)a5;
  if (a5 == a6) {
    goto LABEL_8;
  }
  if (v15 == *(void **)a6)
  {
    uint64_t v19 = **((void **)a5 + 2);
    uint64_t v20 = **((void **)a6 + 2);
    if ((unsigned __int16)v19 == (unsigned __int16)v20)
    {
      BOOL v22 = WORD1(v19) == WORD1(v20);
      uint64_t v21 = (v20 ^ v19) & 0xFFFFFF00000000;
      BOOL v22 = v22 && v21 == 0;
      if (v22) {
        goto LABEL_8;
      }
    }
LABEL_15:
    uint64_t result = re::internal::findEnumConstantToSerialize<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a4, a5, a6, 1);
    if (!result) {
      return result;
    }
    a4 = (re::TypeInfo *)result;
    uint64_t v23 = (re::internal *)*((void *)a1 + 26);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v25);
    re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)v26);
    re::internal::translateType(v23, (const re::TypeRegistry *)v24, (uint64_t)v25);
    if (a1[64]) {
      return 0;
    }
    unint64_t v16 = *(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, re::TypeInfo *, unsigned char *, unsigned char *, void))(*(void *)a1 + 72);
    int64_t v17 = v25;
    unint64_t v18 = v25;
    return v16(a1, a2, a3, a4, v17, v18, 0);
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_15;
  }
  size_t v15 = *(void **)a5;
LABEL_8:
  re::TypeRegistry::typeInfo(v15, *(void *)(*((void *)a5 + 2) + 72), v25);
  re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)v26);
  if (a1[64]) {
    return 0;
  }
  unint64_t v16 = *(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, re::TypeInfo *, unsigned char *, unsigned char *, void))(*(void *)a1 + 72);
  int64_t v17 = v24;
  unint64_t v18 = v24;
  return v16(a1, a2, a3, a4, v17, v18, 0);
}

uint64_t re::internal::findEnumConstantToSerialize<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, re::TypeInfo *a3, re::internal *this, re::TypeInfo *a5, int a6)
{
  if (*(_DWORD *)(*((void *)this + 2) + 8) >= 9u)
  {
    uint64_t v38 = re::TypeInfo::name(this)[1];
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Enum type \"%s\" has invalid size: %zu bytes", v9, v10, v11, v12, v13, v38);
    return 0;
  }
  unsigned int EnumConstantIndex = re::internal::getEnumConstantIndex(this, a3, a3);
  if ((EnumConstantIndex & 0x80000000) != 0)
  {
    uint64_t __dst = 0;
    memcpy(&__dst, a3, *(unsigned int *)(*((void *)this + 2) + 8));
    char v30 = __dst;
    re::TypeInfo::name(this);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v31, v32, v33, v34, v35, v30);
    return 0;
  }
  unsigned int v18 = EnumConstantIndex;
  if (!a6)
  {
    uint64_t v36 = re::TypeInfo::enumConstants(this);
    if (v37 > v18) {
      return v36 + 24 * v18;
    }
    re::internal::assertLog((re::internal *)6, v37, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v18, v37);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  uint64_t v19 = *(re::internal::TypeTranslationTable **)(*(void *)a5 + 856);
  if (!v19 || (uint64_t result = re::internal::TypeTranslationTable::translateRuntimeEnum(v19, this, v18, a5)) == 0)
  {
    uint64_t v21 = re::TypeInfo::enumConstants(this);
    uint64_t v23 = v18;
    if (v22 > v18)
    {
      uint64_t v24 = *(void *)(v21 + 24 * v18 + 16);
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Runtime enum constant \"%s\" does not exist in serialized type \"%s\".", v25, v26, v27, v28, v29, v24);
      return 0;
    }
LABEL_15:
    re::internal::assertLog((re::internal *)6, v22, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v23, v22);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::Slice<re::EnumConstant>::operator[](void *a1, unint64_t a2)
{
  unint64_t v2 = a1[1];
  if (v2 > a2) {
    return *a1 + 24 * a2;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, a2, v2);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginOptional(uint64_t a1, const char *a2, int a3, unsigned char *a4, int a5)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    uint64_t v16 = 0;
    if (re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3))
    {
      if (*a4)
      {
        uint64_t v9 = 1;
      }
      else
      {
        char __src = 4;
        if (!*(unsigned char *)(a1 + 40)
          && (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, &__src, 1uLL) & 1) == 0)
        {
          re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Optional");
        }
        uint64_t v9 = *a4;
      }
      LOBYTE(v10) = 3;
      DWORD1(v10) = a5;
      *((void *)&v10 + 1) = a2;
      uint64_t v11 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v12 = v9;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v10);
      *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    }
    else
    {
      LOBYTE(v15[0]) = 3;
      DWORD1(v15[0]) = a5;
      *((void *)&v15[0] + 1) = a2;
      memset(&v15[1], 0, 32);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, v15);
    }
  }
}

_anonymous_namespace_ *re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endOptional(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 3);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if (v10) {
        int v7 = *(unsigned char **)&v11[7];
      }
      else {
        int v7 = v11;
      }
      if (*(uint64_t *)(*((void *)v1 + 16) + 48 * *((void *)v1 + 14) - 24) <= 0) {
        int v8 = "Optional should not have a value.";
      }
      else {
        int v8 = "Optional requires a value.";
      }
      re::DynamicString::format((re::DynamicString *)"Failed to serialize optional type \"%s\". %s", (re::DynamicString *)v12, v7, v8);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(void *)&v12[0])
      {
        if (BYTE8(v12[0])) {
          (*(void (**)(void))(**(void **)&v12[0] + 40))();
        }
        memset(v12, 0, sizeof(v12));
      }
      uint64_t result = v9;
      if (v9 && (v10 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v9 + 40))();
      }
    }
  }
  return result;
}

double re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(void *a1, _OWORD *a2)
{
  if (a1[14] >= a1[19])
  {
    re::DynamicString::format((re::DynamicString *)"State stack overflow (max depth is %zu). Increase user default com.apple.maxSerializationDepth to allow deeper hierarchies.", (re::DynamicString *)&v7, a1[19]);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)&v7);
    if (v7)
    {
      if (v8) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 40))(v7, v9);
      }
    }
  }
  long long v4 = a2[1];
  v6[0] = *a2;
  v6[1] = v4;
  void v6[2] = a2[2];
  *(void *)&double result = re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)v6).n128_u64[0];
  return result;
}

__n128 re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 48 * v4;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 32) = v7;
  *(__n128 *)uint64_t v5 = result;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          unint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x30uLL))
        {
          uint64_t v2 = 48 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 48 * v5[2]);
            __n128 result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        __n128 result = (void *)re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginBLOB(uint64_t a1, const char *a2, int a3, unint64_t *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (result)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeDataTag(a1, a2, *a4);
    unint64_t v10 = *a4;
    LOBYTE(v11) = 4;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeBLOB(uint64_t result, char *a2, char a3)
{
  if (!*(unsigned char *)(result + 40))
  {
    unint64_t v4 = (_anonymous_namespace_ *)result;
    size_t v5 = *(void *)(*(void *)(result + 128) + 48 * *(void *)(result + 112) - 24);
    uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, a2, v5);
    if ((result & 1) == 0) {
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v4, 0, (uint64_t)"BLOB");
    }
    if ((a3 & 2) == 0)
    {
      uint64_t v6 = *((void *)v4 + 16);
      uint64_t v7 = *((void *)v4 + 14) - 1;
      if (*(unsigned char *)(v6 + 48 * v7) != 2) {
        *(void *)(v6 + 48 * v7 + 32) += v5;
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endBLOB(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 4);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if (v10) {
        uint64_t v7 = *(unsigned char **)&v11[7];
      }
      else {
        uint64_t v7 = v11;
      }
      uint64_t v8 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize BLOB \"%s\". Expected number of bytes: %lld. Actual number of bytes: %lld.", (re::DynamicString *)v12, v7, *(void *)(v8 - 24), *(void *)(v8 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(void *)&v12[0])
      {
        if (BYTE8(v12[0])) {
          (*(void (**)(void))(**(void **)&v12[0] + 40))();
        }
        memset(v12, 0, sizeof(v12));
      }
      uint64_t result = v9;
      if (v9 && (v10 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v9 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginArray(uint64_t a1, const char *a2, int a3, unint64_t *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (result)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeArrayTag(a1, a2, *a4);
    unint64_t v10 = *a4;
    LOBYTE(v11) = 5;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endArray(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    unint64_t v4 = *(void *)(v2 + 48 * v3 + 32);
    if (v4 == *(void *)(v2 + 48 * v3 + 24))
    {
      if (v4 >= 0xF)
      {
        LOBYTE(__src[0]) = 3;
        if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(result, (char *)__src, 1uLL) & 1) == 0)re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v1, 0, (uint64_t)"Array"); {
        uint64_t v2 = *((void *)v1 + 16);
        }
        uint64_t v3 = *((void *)v1 + 14) - 1;
      }
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 5);
      uint64_t v6 = *((void *)v1 + 16);
      uint64_t v7 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v6 + 48 * v7) != 2) {
        ++*(void *)(v6 + 48 * v7 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v10);
      if (v11) {
        uint64_t v8 = *(unsigned char **)&v12[7];
      }
      else {
        uint64_t v8 = v12;
      }
      uint64_t v9 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)__src, v8, *(void *)(v9 - 24), *(void *)(v9 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)__src);
      if (*(void *)&__src[0])
      {
        if (BYTE8(__src[0])) {
          (*(void (**)(void))(**(void **)&__src[0] + 40))();
        }
        memset(__src, 0, sizeof(__src));
      }
      uint64_t result = v10;
      if (v10 && (v11 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::ArrayAccessor::elementAt(re::ArrayAccessor *this, char *a2, unint64_t a3)
{
  if (re::ArrayAccessor::size(this, a2) <= a3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    re::ArrayAccessor::size(this, a2);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return re::ArrayAccessor::elementAtUnchecked(this, (void **)a2, a3);
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeArrayTag(uint64_t result, const char *a2, unint64_t a3)
{
  uint64_t v5 = (_anonymous_namespace_ *)result;
  if (a3 > 0xE)
  {
    char v7 = -33;
    if (!*(unsigned char *)(result + 40)
      && (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, &v7, 1uLL) & 1) == 0)
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v5, a2, (uint64_t)"Array");
    }
    return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeUint64((uint64_t)v5, a2, a3);
  }
  else
  {
    char __src = a3 - 48;
    if (!*(unsigned char *)(result + 40))
    {
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, &__src, 1uLL);
      if ((result & 1) == 0) {
        return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v5, a2, (uint64_t)"Small Array");
      }
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionary(uint64_t a1, const char *a2, int a3, unint64_t *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (result)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeDictionaryTag(a1, a2, *a4);
    unint64_t v10 = *a4;
    LOBYTE(v11) = 6;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

double re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(uint64_t a1, int a2)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    LOBYTE(v3[0]) = 7;
    DWORD1(v3[0]) = a2;
    *((void *)&v3[0] + 1) = "entry";
    v3[1] = xmmword_23436C460;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, v3);
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = (uint64_t)result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == 2)
    {
      double result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 7);
      uint64_t v2 = *(void *)(v1 + 128);
      uint64_t v3 = *(void *)(v1 + 112) - 1;
      if (*(unsigned char *)(v2 + 48 * v3) != 2) {
        ++*(void *)(v2 + 48 * v3 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if (v6) {
        uint64_t v4 = *(unsigned char **)&v7[7];
      }
      else {
        uint64_t v4 = v7;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary entry \"%s\". Expected 2 objects (key+value). Actual number of objects: %lld.", (re::DynamicString *)v8, v4, *(void *)(*(void *)(v1 + 128) + 48 * *(void *)(v1 + 112) - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(void *)&v8[0])
      {
        if (BYTE8(v8[0])) {
          (*(void (**)(void))(**(void **)&v8[0] + 40))();
        }
        memset(v8, 0, sizeof(v8));
      }
      double result = v5;
      if (v5 && (v6 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v5 + 40))();
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endDictionary(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    unint64_t v4 = *(void *)(v2 + 48 * v3 + 32);
    if (v4 == *(void *)(v2 + 48 * v3 + 24))
    {
      if (v4 >= 0xF)
      {
        LOBYTE(__src[0]) = 3;
        if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(result, (char *)__src, 1uLL) & 1) == 0)re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v1, 0, (uint64_t)"Dictionary"); {
        uint64_t v2 = *((void *)v1 + 16);
        }
        uint64_t v3 = *((void *)v1 + 14) - 1;
      }
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject((uint64_t)v1);
      double result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 6);
      uint64_t v6 = *((void *)v1 + 16);
      uint64_t v7 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v6 + 48 * v7) != 2) {
        ++*(void *)(v6 + 48 * v7 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v10);
      if (v11) {
        uint64_t v8 = *(unsigned char **)&v12[7];
      }
      else {
        uint64_t v8 = v12;
      }
      uint64_t v9 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)__src, v8, *(void *)(v9 - 24), *(void *)(v9 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)__src);
      if (*(void *)&__src[0])
      {
        if (BYTE8(__src[0])) {
          (*(void (**)(void))(**(void **)&__src[0] + 40))();
        }
        memset(__src, 0, sizeof(__src));
      }
      double result = v10;
      if (v10 && (v11 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeDictionaryTag(uint64_t result, const char *a2, unint64_t a3)
{
  uint64_t v5 = (_anonymous_namespace_ *)result;
  if (a3 > 0xE)
  {
    char v8 = -46;
    if (!*(unsigned char *)(result + 40)
      && (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, &v8, 1uLL) & 1) == 0)
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v5, a2, (uint64_t)"Dictionary container");
    }
    double result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeUint64((uint64_t)v5, a2, a3);
    char v9 = -17;
    if (!*((unsigned char *)v5 + 40))
    {
      double result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, &v9, 1uLL);
      if ((result & 1) == 0)
      {
        uint64_t v6 = "Dictionary";
        return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v5, a2, (uint64_t)v6);
      }
    }
  }
  else
  {
    char __src = a3 - 32;
    if (!*(unsigned char *)(result + 40))
    {
      double result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, &__src, 1uLL);
      if ((result & 1) == 0)
      {
        uint64_t v6 = "Small Dictionary";
        return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v5, a2, (uint64_t)v6);
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(uint64_t *a1, char *a2, uint64_t (**a3)(unint64_t, unint64_t), uint64_t a4, char a5, __n128 a6)
{
LABEL_1:
  uint64_t v12 = a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = v12;
    uint64_t v14 = v13;
    uint64_t v15 = a2 - (char *)v12;
    unint64_t v16 = (a2 - (char *)v12) >> 4;
    if (!(!v7 & v6))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v23 = *((void *)a2 - 2);
          unint64_t v22 = a2 - 16;
          if ((*a3)(v23, *v12))
          {
            long long v25 = *(_OWORD *)v12;
            *(_OWORD *)uint64_t v12 = *(_OWORD *)v22;
            *(_OWORD *)unint64_t v22 = v25;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, v12 + 2, (void *)a2 - 2, a3);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, v12 + 2, v12 + 4, (void *)a2 - 2, a3);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, v12 + 2, v12 + 4, v12 + 6, (void *)a2 - 2, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 383) {
      break;
    }
    if (v14 == 1)
    {
      if (v12 != (uint64_t *)a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,re::Pair<void const*,void *,true>*>((char *)v12, a2, a2, a3, a6);
      }
      return;
    }
    unint64_t v17 = v16 >> 1;
    unsigned int v18 = &v12[2 * (v16 >> 1)];
    if ((unint64_t)v15 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, &v12[2 * (v16 >> 1)], (void *)a2 - 2, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12 + 2, v18 - 2, (void *)a2 - 4, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12 + 4, &v12[2 * v17 + 2], (void *)a2 - 6, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v18 - 2, v18, &v12[2 * v17 + 2], a3);
      long long v24 = *(_OWORD *)v12;
      *(_OWORD *)uint64_t v12 = *(_OWORD *)v18;
      *(_OWORD *)unsigned int v18 = v24;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(&v12[2 * (v16 >> 1)], v12, (void *)a2 - 2, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (((*a3)(*(v12 - 2), *v12) & 1) == 0)
    {
      uint64_t v12 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &>(v12, (uint64_t *)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
      goto LABEL_18;
    }
LABEL_13:
    uint64_t v19 = (char *)std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &>((long long *)v12, (long long *)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
    if ((v20 & 1) == 0) {
      goto LABEL_16;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((char *)v12, v19, (uint64_t (**)(uint64_t, void))a3);
    uint64_t v12 = (uint64_t *)(v19 + 16);
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v19 + 16, a2, (uint64_t (**)(uint64_t, void))a3))
    {
      a4 = -v14;
      a2 = v19;
      if (v21) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v21)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(a1, v19, a3, -v14, a5 & 1);
      uint64_t v12 = (uint64_t *)(v19 + 16);
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((uint64_t)v12, (uint64_t *)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((uint64_t)v12, a2, (uint64_t (**)(uint64_t, uint64_t))a3);
  }
}

  uint64_t v12 = a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = v12;
    uint64_t v14 = v13;
    uint64_t v15 = a2 - (char *)v12;
    unint64_t v16 = (a2 - (char *)v12) >> 4;
    if (!(!v7 & v6))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v23 = *((void *)a2 - 2);
          unint64_t v22 = a2 - 16;
          if ((*a3)(v23, *v12))
          {
            long long v25 = *(_OWORD *)v12;
            *(_OWORD *)uint64_t v12 = *(_OWORD *)v22;
            *(_OWORD *)unint64_t v22 = v25;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, v12 + 2, (void *)a2 - 2, a3);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, v12 + 2, v12 + 4, (void *)a2 - 2, a3);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, v12 + 2, v12 + 4, v12 + 6, (void *)a2 - 2, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 383) {
      break;
    }
    if (v14 == 1)
    {
      if (v12 != (uint64_t *)a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,re::Pair<void const*,void *,true>*>((char *)v12, a2, a2, a3, a6);
      }
      return;
    }
    unint64_t v17 = v16 >> 1;
    unsigned int v18 = &v12[2 * (v16 >> 1)];
    if ((unint64_t)v15 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, &v12[2 * (v16 >> 1)], (void *)a2 - 2, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12 + 2, v18 - 2, (void *)a2 - 4, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12 + 4, &v12[2 * v17 + 2], (void *)a2 - 6, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v18 - 2, v18, &v12[2 * v17 + 2], a3);
      long long v24 = *(_OWORD *)v12;
      *(_OWORD *)uint64_t v12 = *(_OWORD *)v18;
      *(_OWORD *)unsigned int v18 = v24;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(&v12[2 * (v16 >> 1)], v12, (void *)a2 - 2, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (((*a3)(*(v12 - 2), *v12) & 1) == 0)
    {
      uint64_t v12 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &>(v12, (uint64_t *)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
      goto LABEL_18;
    }
LABEL_13:
    uint64_t v19 = (char *)std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &>((long long *)v12, (long long *)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
    if ((v20 & 1) == 0) {
      goto LABEL_16;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((char *)v12, v19, (uint64_t (**)(uint64_t, void))a3);
    uint64_t v12 = (uint64_t *)(v19 + 16);
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v19 + 16, a2, (uint64_t (**)(uint64_t, void))a3))
    {
      a4 = -v14;
      a2 = v19;
      if (v21) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v21)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(a1, v19, a3, -v14, a5 & 1);
      uint64_t v12 = (uint64_t *)(v19 + 16);
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((uint64_t)v12, (uint64_t *)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((uint64_t)v12, a2, (uint64_t (**)(uint64_t, uint64_t))a3);
  }
}

  uint64_t v103 = (uint64_t)a1;
  uint64_t v107 = (uint64_t)a1;
LABEL_2:
  uint64_t v12 = (long long *)a4;
  uint64_t v13 = (uint64_t)a2;
  unint64_t v106 = (re::DynamicString *)(a2 - 3);
  uint64_t v104 = (uint64_t)(a2 - 6);
  uint64_t v14 = a2 - 1;
  while (1)
  {
    uint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v13 - a4) >> 4);
    if (!(!v7 & v6))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (*(void *)(a4 + 32) >= *(void *)(v13 - 16)) {
            return;
          }
          __n128 v44 = a4 + 48;
          unint64_t v45 = v13;
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(v103, (uint64_t)a2, (uint64_t)v106, (uint64_t)v106, a3, a4 + 48);
          return;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(v103, (uint64_t)a2, (uint64_t)v106, (uint64_t)v106, v104, v104, a3, a4 + 48);
          return;
        case 5uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(v103, (uint64_t)a2, (uint64_t)v106, (uint64_t)v106, v104, v104, v13 - 144, v13 - 144);
          if (*(void *)(a4 + 32) >= *(void *)(v13 - 160)) {
            return;
          }
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(v13 - 144, a4 + 48);
          if (*(void *)(v13 - 160) >= *(void *)(v13 - 112)) {
            return;
          }
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(v104, v13 - 144);
          if (*(void *)(v13 - 112) >= *(void *)(v13 - 64)) {
            return;
          }
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>((uint64_t)v106, v104);
          if (*(void *)(v13 - 64) >= *((void *)a2 - 2)) {
            return;
          }
          unint64_t v45 = (uint64_t)a2;
          __n128 v44 = (uint64_t)v106;
          break;
        default:
          JUMPOUT(0);
      }
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>(v45, v44);
      return;
    }
    if (v13 - a4 <= 1151) {
      break;
    }
    if (!a5)
    {
      unint64_t v52 = (char *)a2 - (char *)v12;
      if (a2 != v12 && v52 >= 49)
      {
        uint64_t v53 = 0xAAAAAAAAAAAAAAABLL * (v52 >> 4);
        uint64_t v54 = (unint64_t)(v53 - 2) >> 1;
        uint64_t v55 = v54;
        do
        {
          uint64_t v56 = v55;
          if ((unint64_t)v52 >= 0x60)
          {
            uint64_t v57 = &a2[-3 * v55];
            uint64_t v58 = 0xAAAAAAAAAAAAAAABLL * ((48 * v55) >> 4);
            if (v54 >= v58)
            {
              uint64_t v59 = 2 * v58;
              double v60 = (2 * v58) | 1;
              uint64_t v61 = &a2[-3 * v60];
              uint64_t v62 = v59 + 2;
              if (v62 < v53)
              {
                unint64_t v63 = *((void *)v61 - 2);
                unint64_t v64 = *((void *)v61 - 8);
                uint64_t v65 = v63 >= v64;
                unint64_t v66 = v63 >= v64 ? 0 : -1;
                v61 += 3 * v66;
                if (!v65) {
                  double v60 = v62;
                }
              }
              if (*((void *)v61 - 2) >= *((void *)v57 - 2))
              {
                *(void *)&uint64_t v113 = *((void *)v57 - 6);
                *((void *)v57 - 6) = 0;
                *(void *)&long long v114 = *((void *)v57 - 4);
                *((void *)v57 - 4) = 0;
                *((void *)&v114 + 1) = *((void *)v57 - 3);
                *((void *)v57 - 3) = 0;
                *((void *)&v113 + 1) = *((void *)v57 - 5);
                *((void *)v57 - 5) = 0;
                uint64_t v115 = *(v57 - 1);
                int v67 = v115;
                do
                {
                  uint64_t v68 = v57;
                  uint64_t v57 = v61;
                  unint64_t v69 = (re::DynamicString *)(v61 - 3);
                  re::DynamicString::operator=((re::DynamicString *)(v68 - 3), (re::DynamicString *)(v61 - 3));
                  *(v68 - 1) = *(v57 - 1);
                  if (v54 < v60) {
                    break;
                  }
                  long long v70 = (2 * v60) | 1;
                  uint64_t v61 = &a2[-3 * v70];
                  if (2 * v60 + 2 < v53)
                  {
                    uint64_t v71 = *((void *)v61 - 2);
                    unint64_t v72 = *((void *)v61 - 8);
                    uint64_t v73 = v71 >= v72;
                    unint64_t v74 = v71 >= v72 ? 0 : -1;
                    v61 += 3 * v74;
                    if (!v73) {
                      long long v70 = 2 * v60 + 2;
                    }
                  }
                  double v60 = v70;
                }
                while (*((void *)v61 - 2) >= v67);
                re::DynamicString::operator=(v69, (re::DynamicString *)&v113);
                *(v57 - 1) = v115;
                if (void)v113 && (BYTE8(v113)) {
                  (*(void (**)(void))(*(void *)v113 + 40))();
                }
                unint64_t v52 = (char *)a2 - (char *)v12;
              }
            }
          }
          uint64_t v55 = v56 - 1;
        }
        while (v56);
        uint64_t v75 = v52 / 0x30uLL;
        do
        {
          uint64_t v76 = 0;
          uint64_t v108 = *((void *)a2 - 6);
          *((void *)a2 - 6) = 0;
          unint64_t v110 = *((void *)a2 - 4);
          *((void *)a2 - 4) = 0;
          uint64_t v111 = *((void *)a2 - 3);
          *((void *)a2 - 3) = 0;
          uint64_t v109 = *((void *)a2 - 5);
          *((void *)a2 - 5) = 0;
          unint64_t v112 = *(a2 - 1);
          int v77 = a2;
          do
          {
            uint64_t v78 = &v77[3 * ~v76];
            __int16 v79 = (2 * v76) | 1;
            int v80 = 2 * v76 + 2;
            if (v80 < v75)
            {
              __int16 v81 = *((void *)v78 - 2);
              unint64_t v82 = *((void *)v78 - 8);
              __int16 v83 = v81 >= v82;
              unint64_t v84 = v81 >= v82 ? 0 : -1;
              v78 += 3 * v84;
              if (!v83) {
                __int16 v79 = v80;
              }
            }
            __n128 v85 = (char *)(v78 - 3);
            re::DynamicString::operator=((re::DynamicString *)(v77 - 3), (re::DynamicString *)(v78 - 3));
            *(v77 - 1) = *(v78 - 1);
            int v77 = v78;
            uint64_t v76 = v79;
          }
          while (v79 <= (uint64_t)((unint64_t)(v75 - 2) >> 1));
          long long v86 = v78 - 1;
          long long v87 = v12 + 3;
          if (v78 == v12 + 3)
          {
            re::DynamicString::operator=((re::DynamicString *)(v78 - 3), (re::DynamicString *)&v108);
            unint64_t *v86 = v112;
          }
          else
          {
            re::DynamicString::operator=((re::DynamicString *)(v78 - 3), (re::DynamicString *)v12);
            unint64_t *v86 = v12[2];
            re::DynamicString::operator=((re::DynamicString *)v12, (re::DynamicString *)&v108);
            _OWORD v12[2] = v112;
            if ((char *)a2 - v85 >= 49)
            {
              long long v88 = (((char *)a2 - v85) / 0x30uLL - 2) >> 1;
              long long v89 = &a2[-3 * v88];
              if (*((void *)v89 - 2) < *(void *)v86)
              {
                uint64_t v113 = 0u;
                long long v114 = 0u;
                *(void *)&uint64_t v113 = *((void *)v78 - 6);
                *((void *)v78 - 6) = 0;
                uint64_t v90 = v114;
                *(void *)&long long v114 = *((void *)v78 - 4);
                *((void *)v78 - 4) = v90;
                *((void *)&v114 + 1) = *((void *)v78 - 3);
                *((void *)v78 - 3) = 0;
                uint64_t v91 = *((void *)&v113 + 1);
                *((void *)&v113 + 1) = *((void *)v78 - 5);
                *((void *)v78 - 5) = v91;
                uint64_t v115 = *v86;
                do
                {
                  uint64_t v92 = v89;
                  unint64_t v93 = (re::DynamicString *)(v89 - 3);
                  re::DynamicString::operator=((re::DynamicString *)(v78 - 3), (re::DynamicString *)(v89 - 3));
                  *(v78 - 1) = *(v92 - 1);
                  if (!v88) {
                    break;
                  }
                  long long v88 = (v88 - 1) >> 1;
                  long long v89 = &a2[-3 * v88];
                  uint64_t v78 = v92;
                }
                while (*((void *)v89 - 2) < (unint64_t)v115);
                re::DynamicString::operator=(v93, (re::DynamicString *)&v113);
                *(v92 - 1) = v115;
                if ((void)v113)
                {
                  if (BYTE8(v113)) {
                    (*(void (**)(void))(*(void *)v113 + 40))();
                  }
                }
              }
            }
          }
          if (v108 && (v109 & 1) != 0) {
            (*(void (**)(void))(*(void *)v108 + 40))();
          }
          uint64_t v12 = v87;
        }
        while (v75-- > 2);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = a4 + 48;
    unsigned int v18 = v13 - 48 * (v15 >> 1);
    if (v15 >= 0x81)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(v107, (uint64_t)a2, v13 - 48 * (v15 >> 1), v13 - 48 * (v15 >> 1), v17, a4 + 48);
      uint64_t v19 = v13 - 48 * v16 + 48;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>((uint64_t)v106, (uint64_t)v106, v19, v19, a4 + 96, a4 + 96);
      char v20 = v13 + 48 * ~v16;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(v104, v104, v20, v20, a4 + 144, a4 + 144);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(v19, v19, v18, v18, v20, v20);
      *(void *)&uint64_t v113 = *(void *)(v13 - 48);
      *(void *)(v13 - 48) = 0;
      *(void *)&long long v114 = *(void *)(v13 - 32);
      *(void *)(v13 - 32) = 0;
      *((void *)&v114 + 1) = *(void *)(v13 - 24);
      *(void *)(v13 - 24) = 0;
      *((void *)&v113 + 1) = *(void *)(v13 - 40);
      *(void *)(v13 - 40) = 0;
      uint64_t v115 = *v14;
      re::DynamicString::operator=(v106, (re::DynamicString *)(v18 - 48));
      *uint64_t v14 = *(_OWORD *)(v18 - 16);
      re::DynamicString::operator=((re::DynamicString *)(v18 - 48), (re::DynamicString *)&v113);
      *(_OWORD *)(v18 - 16) = v115;
      if (void)v113 && (BYTE8(v113)) {
        (*(void (**)(void))(*(void *)v113 + 40))();
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(v13 - 48 * (v15 >> 1), v13 - 48 * (v15 >> 1), v107, (uint64_t)a2, v17, a4 + 48);
    }
    --a5;
    if ((a6 & 1) == 0 && *(void *)(v13 + 32) >= *(void *)(v13 - 16))
    {
      uint64_t v113 = 0u;
      long long v114 = 0u;
      uint64_t v33 = (void *)(v13 - 48);
      *(void *)&uint64_t v113 = *(void *)(v13 - 48);
      *uint64_t v33 = 0;
      uint64_t v34 = v114;
      *(void *)&long long v114 = *(void *)(v13 - 32);
      v33[2] = v34;
      *((void *)&v114 + 1) = *(void *)(v13 - 24);
      v33[3] = 0;
      uint64_t v35 = *((void *)&v113 + 1);
      *((void *)&v113 + 1) = *(void *)(v13 - 40);
      v33[1] = v35;
      uint64_t v115 = *(_OWORD *)(v13 - 16);
      if ((unint64_t)v115 >= *((void *)v12 + 4))
      {
        uint64_t v38 = (void *)(v13 - 64);
        do
        {
          a2 = (long long *)(v38 + 2);
          if (v38 + 2 <= (void *)v12) {
            break;
          }
          __int16 v39 = *v38;
          v38 -= 6;
        }
        while ((unint64_t)v115 >= v39);
      }
      else
      {
        uint64_t v36 = v13;
        do
        {
          a2 = (long long *)(v36 - 48);
          unint64_t v37 = *(void *)(v36 - 64);
          v36 -= 48;
        }
        while ((unint64_t)v115 >= v37);
      }
      if (a2 > v12)
      {
        char v40 = v12;
        do
        {
          uint64_t v12 = v40 + 3;
          uint64_t v41 = *((void *)v40 + 4);
          v40 += 3;
        }
        while ((unint64_t)v115 < v41);
      }
      while (a2 > v12)
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>((uint64_t)a2, (uint64_t)v12);
        do
        {
          uint64_t v42 = *((void *)a2 - 8);
          a2 -= 3;
        }
        while ((unint64_t)v115 >= v42);
        do
        {
          __n128 v43 = *((void *)v12 + 4);
          v12 += 3;
        }
        while ((unint64_t)v115 < v43);
      }
      if (a2 + 3 != (long long *)v13)
      {
        re::DynamicString::operator=((re::DynamicString *)(v13 - 48), (re::DynamicString *)a2);
        *(_OWORD *)(v13 - 16) = a2[2];
      }
      re::DynamicString::operator=((re::DynamicString *)a2, (re::DynamicString *)&v113);
      a2[2] = v115;
      if (void)v113 && (BYTE8(v113)) {
        (*(void (**)(void))(*(void *)v113 + 40))();
      }
      a6 = 0;
      goto LABEL_2;
    }
    BOOL v21 = 0;
    uint64_t v113 = 0u;
    long long v114 = 0u;
    *(void *)&uint64_t v113 = *(void *)(v13 - 48);
    *(void *)(v13 - 48) = 0;
    unint64_t v22 = v114;
    *(void *)&long long v114 = *(void *)(v13 - 32);
    *(void *)(v13 - 32) = v22;
    *((void *)&v114 + 1) = *(void *)(v13 - 24);
    *(void *)(v13 - 24) = 0;
    unint64_t v23 = *((void *)&v113 + 1);
    *((void *)&v113 + 1) = *(void *)(v13 - 40);
    *(void *)(v13 - 40) = v23;
    uint64_t v115 = *v14;
    do
    {
      long long v24 = *(void *)(v13 + v21 - 64);
      v21 -= 48;
    }
    while (v24 < (unint64_t)v115);
    long long v25 = (long long *)(v13 + v21);
    if (v21 == -48)
    {
      while (v25 > v12)
      {
        uint64_t v26 = v12 + 3;
        uint64_t v28 = *((void *)v12 + 4);
        v12 += 3;
        if (v28 < (unint64_t)v115) {
          goto LABEL_23;
        }
      }
      uint64_t v26 = v12;
    }
    else
    {
      do
      {
        uint64_t v26 = v12 + 3;
        uint64_t v27 = *((void *)v12 + 4);
        v12 += 3;
      }
      while (v27 >= (unint64_t)v115);
    }
LABEL_23:
    if (v25 <= v26)
    {
      a2 = v25;
    }
    else
    {
      uint64_t v29 = (unint64_t)v26;
      a2 = v25;
      do
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats *> &>((uint64_t)a2, v29);
        do
        {
          char v30 = *((void *)a2 - 8);
          a2 -= 3;
        }
        while (v30 < (unint64_t)v115);
        do
        {
          uint64_t v31 = *(void *)(v29 + 32);
          v29 += 48;
        }
        while (v31 >= (unint64_t)v115);
      }
      while ((unint64_t)a2 > v29);
    }
    uint64_t v12 = a2 + 3;
    if (a2 + 3 != (long long *)v13)
    {
      re::DynamicString::operator=(v106, (re::DynamicString *)a2);
      *uint64_t v14 = a2[2];
    }
    re::DynamicString::operator=((re::DynamicString *)a2, (re::DynamicString *)&v113);
    a2[2] = v115;
    if (void)v113 && (BYTE8(v113)) {
      (*(void (**)(void))(*(void *)v113 + 40))();
    }
    if (v25 > v26) {
      goto LABEL_62;
    }
    uint64_t v32 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>(v107, v13, (uint64_t)(a2 + 3), (uint64_t)(a2 + 3));
    if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>>((uint64_t)a2, (uint64_t)a2, a3, a4))
    {
      a1 = a2 + 3;
      if (v32) {
        goto LABEL_1;
      }
LABEL_62:
      std::__introsort<std::_ClassicAlgPolicy,re::AssetLoadRequest::LoadStatistics::forEachStat(void({block_pointer})(re::AssetLoadRequest::LoadStatistics::AssetTypeStats const&))::$_0 &,std::reverse_iterator<re::AssetLoadRequest::LoadStatistics::AssetTypeStats*>,false>(v107, v13, a2 + 3, a2 + 3, a5, a6 & 1);
      a6 = 0;
      a1 = a2 + 3;
      goto LABEL_1;
    }
    a4 = (uint64_t)(a2 + 3);
    a3 = (uint64_t)(a2 + 3);
    a2 = (long long *)v13;
    if (v32) {
      return;
    }
  }
  if (a6)
  {
    if (a2 != v12)
    {
      uint64_t v46 = a2 - 3;
      if (a2 - 3 != v12)
      {
        uint64_t v47 = 0;
        do
        {
          uint64_t v48 = v46 - 1;
          if (*((void *)v46 - 2) < *((void *)v46 + 4))
          {
            *(void *)&uint64_t v113 = *((void *)v46 - 6);
            *((void *)v46 - 6) = 0;
            *(void *)&long long v114 = *((void *)v46 - 4);
            *((void *)v46 - 4) = 0;
            *((void *)&v114 + 1) = *((void *)v46 - 3);
            *((void *)v46 - 3) = 0;
            *((void *)&v113 + 1) = *((void *)v46 - 5);
            *((void *)v46 - 5) = 0;
            uint64_t v115 = *v48;
            double v49 = v47;
            do
            {
              unint64_t v50 = (char *)a2 + v49;
              uint64_t v51 = (re::DynamicString *)((char *)a2 + v49 - 48);
              re::DynamicString::operator=((re::DynamicString *)((char *)a2 + v49 - 96), v51);
              *(long long *)((char *)a2 + v49 - 64) = *(long long *)((char *)a2 + v49 - 16);
              if (!v49) {
                break;
              }
              v49 += 48;
            }
            while ((unint64_t)v115 < *((void *)v50 + 4));
            re::DynamicString::operator=(v51, (re::DynamicString *)&v113);
            *((_OWORD *)v50 - 1) = v115;
            if ((void)v113)
            {
              if (BYTE8(v113)) {
                (*(void (**)(void))(*(void *)v113 + 40))();
              }
            }
          }
          uint64_t v46 = v48 - 2;
          v47 -= 48;
        }
        while (v48 - 2 != v12);
      }
    }
  }
  else if (a2 != v12)
  {
    uint64_t v95 = a2 - 3;
    if (a2 - 3 != v12)
    {
      uint64_t v96 = (re::DynamicString *)(a2 - 6);
      do
      {
        uint64_t v97 = v95 - 1;
        if (*((void *)v95 - 2) < *((void *)v95 + 4))
        {
          *(void *)&uint64_t v113 = *((void *)v95 - 6);
          *((void *)v95 - 6) = 0;
          *(void *)&long long v114 = *((void *)v95 - 4);
          *((void *)v95 - 4) = 0;
          *((void *)&v114 + 1) = *((void *)v95 - 3);
          *((void *)v95 - 3) = 0;
          *((void *)&v113 + 1) = *((void *)v95 - 5);
          *((void *)v95 - 5) = 0;
          uint64_t v115 = *v97;
          unint64_t v98 = v96;
          do
          {
            uint64_t v99 = (re::DynamicString *)((char *)v98 + 48);
            uint64_t v100 = re::DynamicString::operator=(v98, (re::DynamicString *)((char *)v98 + 48));
            *((_OWORD *)v100 + 2) = *((_OWORD *)v100 + 5);
            uint64_t v101 = *((void *)v100 + 16);
            unint64_t v98 = v99;
          }
          while ((unint64_t)v115 < v101);
          unint64_t v102 = re::DynamicString::operator=(v99, (re::DynamicString *)&v113);
          *((_OWORD *)v102 + 2) = v115;
          if ((void)v113)
          {
            if (BYTE8(v113)) {
              (*(void (**)(void))(*(void *)v113 + 40))();
            }
          }
        }
        uint64_t v95 = v97 - 2;
        uint64_t v96 = (re::DynamicString *)((char *)v96 - 48);
      }
      while (v97 - 2 != v12);
    }
  }
}

  char v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    uint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v22 = *(a2 - 2);
          BOOL v21 = (long long *)(a2 - 2);
          if (*v22 < **v11)
          {
            long long v24 = *(_OWORD *)v11;
            *(_OWORD *)char v11 = *v21;
            char *v21 = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v11, v11 + 2, v11 + 4, (_OWORD *)a2 - 1);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v11, v11 + 2, v11 + 4, (__n128 *)v11 + 3, (__n128 *)a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,re::Pair<unsigned long long const*,void *,true>*>(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v11, &v11[2 * (v15 >> 1)], a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v11 + 1, v17 - 2, a2 - 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v11 + 2, &v11[2 * v16 + 2], a2 - 6);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)v17 - 1, v17, &v11[2 * v16 + 2]);
      unint64_t v23 = *(_OWORD *)v11;
      *(_OWORD *)char v11 = *(_OWORD *)v17;
      *(_OWORD *)unint64_t v17 = v23;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((long long *)&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (**(v11 - 2) >= **v11)
    {
      char v11 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<unsigned long long const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &>(v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    unsigned int v18 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<unsigned long long const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &>(v11, a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    char v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((uint64_t)v11, v18);
    char v11 = v18 + 2;
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((uint64_t)(v18 + 2), a2))
    {
      a4 = -v13;
      a2 = v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(a1, v18, a3, -v13, a5 & 1);
      char v11 = v18 + 2;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(v11, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((uint64_t)v11, (uint64_t)a2);
  }
}

  char v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    uint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v22 = *(a2 - 2);
          BOOL v21 = (long long *)(a2 - 2);
          if (*v22 < **v11)
          {
            long long v24 = *(_OWORD *)v11;
            *(_OWORD *)char v11 = *v21;
            char *v21 = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v11, v11 + 2, v11 + 4, (_OWORD *)a2 - 1);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v11, v11 + 2, v11 + 4, (__n128 *)v11 + 3, (__n128 *)a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,re::Pair<unsigned int const*,void *,true>*>(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v11, &v11[2 * (v15 >> 1)], a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v11 + 1, v17 - 2, a2 - 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v11 + 2, &v11[2 * v16 + 2], a2 - 6);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)v17 - 1, v17, &v11[2 * v16 + 2]);
      unint64_t v23 = *(_OWORD *)v11;
      *(_OWORD *)char v11 = *(_OWORD *)v17;
      *(_OWORD *)unint64_t v17 = v23;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((long long *)&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (**(v11 - 2) >= **v11)
    {
      char v11 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<unsigned int const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &>(v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    unsigned int v18 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<unsigned int const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &>(v11, a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    char v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((uint64_t)v11, v18);
    char v11 = v18 + 2;
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((uint64_t)(v18 + 2), a2))
    {
      a4 = -v13;
      a2 = v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(a1, v18, a3, -v13, a5 & 1);
      char v11 = v18 + 2;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(v11, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((uint64_t)v11, (uint64_t)a2);
  }
}

  char v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    uint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v22 = *(a2 - 2);
          BOOL v21 = a2 - 2;
          if (*v22 < **v11)
          {
            long long v24 = *(_OWORD *)v11;
            *(_OWORD *)char v11 = *(_OWORD *)v21;
            *(_OWORD *)BOOL v21 = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v11, (_OWORD *)v11 + 1, (_OWORD *)a2 - 1);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v11, (__n128 *)v11 + 1, (__n128 *)v11 + 2, (__n128 *)a2 - 1);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v11, (__n128 *)v11 + 1, (__n128 *)v11 + 2, (__n128 *)v11 + 3, (__n128 *)a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,re::Pair<unsigned short const*,void *,true>*>(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v11, &v11[2 * (v15 >> 1)], (_OWORD *)a2 - 1);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v11 + 2, (_OWORD *)v17 - 1, (_OWORD *)a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v11 + 4, &v11[2 * v16 + 2], (_OWORD *)a2 - 3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v17 - 2, v17, &v11[2 * v16 + 2]);
      unint64_t v23 = *(_OWORD *)v11;
      *(_OWORD *)char v11 = *(_OWORD *)v17;
      *(_OWORD *)unint64_t v17 = v23;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(&v11[2 * (v15 >> 1)], v11, (_OWORD *)a2 - 1);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (**(v11 - 2) >= **v11)
    {
      char v11 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<unsigned short const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &>(v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    unsigned int v18 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<unsigned short const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &>(v11, a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    char v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>((__n128 *)v11, v18);
    char v11 = v18 + 2;
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>((__n128 *)v18 + 1, a2))
    {
      a4 = -v13;
      a2 = v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(a1, v18, a3, -v13, a5 & 1);
      char v11 = v18 + 2;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v11, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(v11, a2);
  }
}

  char v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    uint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v22 = *(a2 - 2);
          BOOL v21 = a2 - 2;
          if (*v22 < **v11)
          {
            long long v24 = *(_OWORD *)v11;
            *(_OWORD *)char v11 = *(_OWORD *)v21;
            *(_OWORD *)BOOL v21 = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v11, (_OWORD *)v11 + 1, (_OWORD *)a2 - 1);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v11, (__n128 *)v11 + 1, (__n128 *)v11 + 2, (__n128 *)a2 - 1);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v11, (__n128 *)v11 + 1, (__n128 *)v11 + 2, (__n128 *)v11 + 3, (__n128 *)a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,re::Pair<unsigned char const*,void *,true>*>(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v11, &v11[2 * (v15 >> 1)], (_OWORD *)a2 - 1);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v11 + 2, (_OWORD *)v17 - 1, (_OWORD *)a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v11 + 4, &v11[2 * v16 + 2], (_OWORD *)a2 - 3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v17 - 2, v17, &v11[2 * v16 + 2]);
      unint64_t v23 = *(_OWORD *)v11;
      *(_OWORD *)char v11 = *(_OWORD *)v17;
      *(_OWORD *)unint64_t v17 = v23;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(&v11[2 * (v15 >> 1)], v11, (_OWORD *)a2 - 1);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (**(v11 - 2) >= **v11)
    {
      char v11 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<unsigned char const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &>(v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    unsigned int v18 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<unsigned char const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &>(v11, a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    char v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>((__n128 *)v11, v18);
    char v11 = v18 + 2;
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>((__n128 *)v18 + 1, a2))
    {
      a4 = -v13;
      a2 = v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(a1, v18, a3, -v13, a5 & 1);
      char v11 = v18 + 2;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v11, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(v11, a2);
  }
}

  char v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    uint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v22 = *(a2 - 2);
          BOOL v21 = (long long *)(a2 - 2);
          if (*v22 < **v11)
          {
            long long v24 = *(_OWORD *)v11;
            *(_OWORD *)char v11 = *v21;
            char *v21 = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v11, v11 + 2, v11 + 4, (_OWORD *)a2 - 1);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v11, v11 + 2, v11 + 4, (__n128 *)v11 + 3, (__n128 *)a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,re::Pair<long long const*,void *,true>*>(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v11, &v11[2 * (v15 >> 1)], a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v11 + 1, v17 - 2, a2 - 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v11 + 2, &v11[2 * v16 + 2], a2 - 6);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)v17 - 1, v17, &v11[2 * v16 + 2]);
      unint64_t v23 = *(_OWORD *)v11;
      *(_OWORD *)char v11 = *(_OWORD *)v17;
      *(_OWORD *)unint64_t v17 = v23;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((long long *)&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (**(v11 - 2) >= **v11)
    {
      char v11 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<long long const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &>(v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    unsigned int v18 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<long long const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &>(v11, a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    char v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((uint64_t)v11, (uint64_t)v18);
    char v11 = v18 + 2;
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((uint64_t)(v18 + 2), (uint64_t)a2))
    {
      a4 = -v13;
      a2 = v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(a1, v18, a3, -v13, a5 & 1);
      char v11 = v18 + 2;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(v11, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((uint64_t)v11, (uint64_t)a2);
  }
}

  char v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    uint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v22 = *(a2 - 2);
          BOOL v21 = (long long *)(a2 - 2);
          if (*v22 < **v11)
          {
            long long v24 = *(_OWORD *)v11;
            *(_OWORD *)char v11 = *v21;
            char *v21 = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v11, v11 + 2, v11 + 4, (_OWORD *)a2 - 1);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v11, v11 + 2, v11 + 4, (__n128 *)v11 + 3, (__n128 *)a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,re::Pair<int const*,void *,true>*>(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v11, &v11[2 * (v15 >> 1)], a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v11 + 1, v17 - 2, a2 - 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v11 + 2, &v11[2 * v16 + 2], a2 - 6);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)v17 - 1, v17, &v11[2 * v16 + 2]);
      unint64_t v23 = *(_OWORD *)v11;
      *(_OWORD *)char v11 = *(_OWORD *)v17;
      *(_OWORD *)unint64_t v17 = v23;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((long long *)&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (**(v11 - 2) >= **v11)
    {
      char v11 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<int const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &>(v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    unsigned int v18 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<int const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &>(v11, a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    char v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((uint64_t)v11, (uint64_t)v18);
    char v11 = v18 + 2;
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((uint64_t)(v18 + 2), (uint64_t)a2))
    {
      a4 = -v13;
      a2 = v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(a1, v18, a3, -v13, a5 & 1);
      char v11 = v18 + 2;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(v11, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((uint64_t)v11, (uint64_t)a2);
  }
}

  char v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    uint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v22 = *(a2 - 2);
          BOOL v21 = a2 - 2;
          if (*v22 < **v11)
          {
            long long v24 = *(_OWORD *)v11;
            *(_OWORD *)char v11 = *(_OWORD *)v21;
            *(_OWORD *)BOOL v21 = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v11, (_OWORD *)v11 + 1, (_OWORD *)a2 - 1);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v11, (__n128 *)v11 + 1, (__n128 *)v11 + 2, (__n128 *)a2 - 1);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v11, (__n128 *)v11 + 1, (__n128 *)v11 + 2, (__n128 *)v11 + 3, (__n128 *)a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,re::Pair<short const*,void *,true>*>(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v11, &v11[2 * (v15 >> 1)], (_OWORD *)a2 - 1);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v11 + 2, (_OWORD *)v17 - 1, (_OWORD *)a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v11 + 4, &v11[2 * v16 + 2], (_OWORD *)a2 - 3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v17 - 2, v17, &v11[2 * v16 + 2]);
      unint64_t v23 = *(_OWORD *)v11;
      *(_OWORD *)char v11 = *(_OWORD *)v17;
      *(_OWORD *)unint64_t v17 = v23;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(&v11[2 * (v15 >> 1)], v11, (_OWORD *)a2 - 1);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (**(v11 - 2) >= **v11)
    {
      char v11 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<short const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &>(v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    unsigned int v18 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<short const*,void *,true> *,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &>(v11, a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    char v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>((__n128 *)v11, v18);
    char v11 = v18 + 2;
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>((__n128 *)v18 + 1, a2))
    {
      a4 = -v13;
      a2 = v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(a1, v18, a3, -v13, a5 & 1);
      char v11 = v18 + 2;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v11, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(v11, a2);
  }
}

  char v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    uint64_t v15 = ((char *)a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v22 = *(a2 - 2);
          BOOL v21 = a2 - 2;
          if (re::DynamicString::operator<(v22, *v11))
          {
            long long v24 = *(_OWORD *)v11;
            *(_OWORD *)char v11 = *(_OWORD *)v21;
            *(_OWORD *)BOOL v21 = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v11, v11 + 2, v11 + 4, a2 - 2);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v11, v11 + 2, v11 + 4, v11 + 6, a2 - 2);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,re::Pair<re::DynamicString const*,void *,true>*>(v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v11, &v11[2 * (v15 >> 1)], a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v11 + 2, v17 - 2, a2 - 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v11 + 4, &v11[2 * v16 + 2], a2 - 6);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v17 - 2, v17, &v11[2 * v16 + 2]);
      unint64_t v23 = *(_OWORD *)v11;
      *(_OWORD *)char v11 = *(_OWORD *)v17;
      *(_OWORD *)unint64_t v17 = v23;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_13;
      }
    }
    if ((re::DynamicString::operator<(*(v11 - 2), *v11) & 1) == 0)
    {
      char v11 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<re::DynamicString const*,void *,true> *,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &>(v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    unsigned int v18 = (uint64_t *)std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<re::DynamicString const*,void *,true> *,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &>((long long *)v11, (long long *)a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    char v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v11, v18);
    char v11 = v18 + 2;
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(v18 + 2, a2))
    {
      a4 = -v13;
      a2 = v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(a1, v18, a3, -v13, a5 & 1);
      char v11 = v18 + 2;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>((uint64_t)v11, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>((uint64_t)v11, (uint64_t)a2);
  }
}

  char v11 = a1;
LABEL_2:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = a2 - (char *)v11;
    uint64_t v15 = (a2 - (char *)v11) >> 4;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v22 = (void *)*((void *)a2 - 2);
          BOOL v21 = (long long *)(a2 - 16);
          if (*v22 >> 1 < *(void *)v11->n128_u64[0] >> 1)
          {
            long long v24 = (__int128)*v11;
            *char v11 = (__n128)*v21;
            char *v21 = v24;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)v11, &v11[1], (void **)a2 - 2);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)v11, v11 + 1, v11 + 2, (__n128 *)a2 - 1);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)v11, v11 + 1, v11 + 2, v11 + 3, (__n128 *)a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 383) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != (__n128 *)a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,re::Pair<re::StringID const*,void *,true>*>((unint64_t **)v11, a2, a2, a3);
      }
      return;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = (long long *)&v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)v11, &v11[v15 >> 1], (void **)a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)&v11[1], (void **)v17 - 2, (void **)a2 - 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)&v11[2], &v11[v16 + 1], (void **)a2 - 6);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(v17 - 1, (void **)v17, &v11[v16 + 1]);
      unint64_t v23 = (__int128)*v11;
      *char v11 = (__n128)*v17;
      *unint64_t v17 = v23;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((long long *)&v11[v15 >> 1], v11, (void **)a2 - 2);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (*(void *)v11[-1].n128_u64[0] >> 1 >= *(void *)v11->n128_u64[0] >> 1)
    {
      char v11 = (__n128 *)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<re::StringID const*,void *,true> *,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &>(v11, a2);
      goto LABEL_18;
    }
LABEL_13:
    unsigned int v18 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<re::StringID const*,void *,true> *,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &>((long long *)v11, (long long *)a2);
    if ((v19 & 1) == 0) {
      goto LABEL_16;
    }
    char v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((uint64_t)v11, (uint64_t)v18);
    char v11 = (__n128 *)(v18 + 1);
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((uint64_t)(v18 + 1), (uint64_t)a2))
    {
      a4 = -v13;
      a2 = (char *)v18;
      if (v20) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v12 = v13 + 1;
    if (!v20)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>(a1, v18, a3, -v13, a5 & 1);
      char v11 = (__n128 *)(v18 + 1);
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(v11, a2);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((uint64_t)v11, (uint64_t)a2);
  }
}

  uint64_t v12 = a1;
LABEL_2:
  uint64_t v13 = 1 - a4;
  while (1)
  {
    a1 = v12;
    uint64_t v14 = v13;
    uint64_t v15 = a2 - (char *)v12;
    unint64_t v16 = (a2 - (char *)v12) >> 4;
    if (!(!v7 & v6))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v23 = *((void *)a2 - 2);
          unint64_t v22 = a2 - 16;
          if ((*a3)(v23, *v12))
          {
            long long v25 = *(_OWORD *)v12;
            *(_OWORD *)uint64_t v12 = *(_OWORD *)v22;
            *(_OWORD *)unint64_t v22 = v25;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, v12 + 2, (void *)a2 - 2, a3);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, v12 + 2, v12 + 4, (void *)a2 - 2, a3);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, v12 + 2, v12 + 4, v12 + 6, (void *)a2 - 2, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 383) {
      break;
    }
    if (v14 == 1)
    {
      if (v12 != (uint64_t *)a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,re::Pair<void const*,void *,true>*>((char *)v12, a2, a2, a3, a6);
      }
      return;
    }
    unint64_t v17 = v16 >> 1;
    unsigned int v18 = &v12[2 * (v16 >> 1)];
    if ((unint64_t)v15 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12, &v12[2 * (v16 >> 1)], (void *)a2 - 2, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12 + 2, v18 - 2, (void *)a2 - 4, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v12 + 4, &v12[2 * v17 + 2], (void *)a2 - 6, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v18 - 2, v18, &v12[2 * v17 + 2], a3);
      long long v24 = *(_OWORD *)v12;
      *(_OWORD *)uint64_t v12 = *(_OWORD *)v18;
      *(_OWORD *)unsigned int v18 = v24;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(&v12[2 * (v16 >> 1)], v12, (void *)a2 - 2, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (((*a3)(*(v12 - 2), *v12) & 1) == 0)
    {
      uint64_t v12 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &>(v12, (uint64_t *)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
      goto LABEL_18;
    }
LABEL_13:
    uint64_t v19 = (char *)std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &>((long long *)v12, (long long *)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
    if ((v20 & 1) == 0) {
      goto LABEL_16;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((char *)v12, v19, (uint64_t (**)(uint64_t, void))a3);
    uint64_t v12 = (uint64_t *)(v19 + 16);
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v19 + 16, a2, (uint64_t (**)(uint64_t, void))a3))
    {
      a4 = -v14;
      a2 = v19;
      if (v21) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v13 = v14 + 1;
    if (!v21)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<google::protobuf::io::ZeroCopyOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(a1, v19, a3, -v14, a5 & 1);
      uint64_t v12 = (uint64_t *)(v19 + 16);
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((uint64_t)v12, (uint64_t *)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((uint64_t)v12, a2, (uint64_t (**)(uint64_t, uint64_t))a3);
  }
}

  uint64_t v12 = (long long *)&a2[-2].n128_i8[8];
  uint64_t v13 = (long long *)a1;
LABEL_2:
  uint64_t v14 = 1 - a4;
  while (1)
  {
    a1 = (uint64_t)v13;
    uint64_t v15 = v14;
    unint64_t v16 = (char *)a2 - (char *)v13;
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)v13) >> 3);
    if (!(!v7 & v6))
    {
      switch(v17)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if ((*a3)((long long *)&a2[-2].n128_i8[8], v13))
          {
            uint64_t v32 = *((void *)v13 + 2);
            char v30 = *v13;
            uint64_t v28 = *v12;
            *((void *)v13 + 2) = a2[-1].n128_u64[1];
            *uint64_t v13 = v28;
            *uint64_t v12 = v30;
            a2[-1].n128_u64[1] = v32;
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>(v13, (long long *)((char *)v13 + 24), (long long *)&a2[-2].n128_i8[8], a3);
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>((uint64_t)v13, (uint64_t)v13 + 24, (uint64_t)(v13 + 3), (uint64_t)&a2[-2].n128_i64[1], a3);
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>((__n128 *)v13, (uint64_t)v13 + 24, (uint64_t)(v13 + 3), (uint64_t)v13 + 72, (uint64_t)&a2[-2].n128_i64[1], a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v16 <= 575) {
      break;
    }
    if (v15 == 1)
    {
      if (v13 != (long long *)a2)
      {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*,geo::math::Matrix<double,3,1>*>((__n128 *)v13, a2, a2, (unsigned int (**)(uint64_t, __int8 *))a3, a6);
      }
      return;
    }
    unsigned int v18 = v17 >> 1;
    uint64_t v19 = (long long *)((char *)v13 + 24 * (v17 >> 1));
    if ((unint64_t)v16 >= 0xC01)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>(v13, (long long *)((char *)v13 + 24 * (v17 >> 1)), (long long *)&a2[-2].n128_i8[8], a3);
      char v20 = 3 * v18;
      BOOL v21 = (long long *)((char *)v13 + 24 * v18 - 24);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>((long long *)((char *)v13 + 24), v21, (long long *)&a2[-3], a3);
      unint64_t v22 = v13 + 3;
      unint64_t v23 = (long long *)((char *)v13 + 8 * v20 + 24);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>(v22, v23, (long long *)&a2[-5].n128_i8[8], a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>(v21, v19, v23, a3);
      uint64_t v31 = *(void *)(a1 + 16);
      uint64_t v29 = *(_OWORD *)a1;
      long long v24 = *v19;
      *(void *)(a1 + 16) = *((void *)v19 + 2);
      *(_OWORD *)a1 = v24;
      *((void *)v19 + 2) = v31;
      char *v19 = v29;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>((long long *)((char *)v13 + 24 * (v17 >> 1)), v13, (long long *)&a2[-2].n128_i8[8], a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (((*a3)((long long *)(a1 - 24), (long long *)a1) & 1) == 0)
    {
      uint64_t v13 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,geo::math::Matrix<double,3,1> *,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&)>((long long *)a1, (long long *)a2, a3);
      goto LABEL_18;
    }
LABEL_13:
    long long v25 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,geo::math::Matrix<double,3,1> *,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&)>((long long *)a1, (unint64_t)a2, (uint64_t (**)(char *, long long *))a3);
    if ((v26 & 1) == 0) {
      goto LABEL_16;
    }
    uint64_t v27 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>(a1, v25, a3);
    uint64_t v13 = (long long *)(v25 + 24);
    if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>(v25 + 24, (uint64_t)a2, a3))
    {
      a4 = -v15;
      a2 = (__n128 *)v25;
      if (v27) {
        return;
      }
      goto LABEL_1;
    }
    uint64_t v14 = v15 + 1;
    if (!v27)
    {
LABEL_16:
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*,false>(a1, v25, a3, -v15, a5 & 1);
      uint64_t v13 = (long long *)(v25 + 24);
LABEL_18:
      a5 = 0;
      a4 = -v15;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>((uint64_t)v13, (uint64_t)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
  }
  else
  {
    std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(geo::math::Matrix<double,3,1> const&,geo::math::Matrix<double,3,1> const&),geo::math::Matrix<double,3,1>*>((uint64_t)v13, (uint64_t)a2, (uint64_t (**)(uint64_t, uint64_t))a3);
  }
}

  unint64_t v93 = a2 - 32;
  uint64_t v95 = (uint64_t *)(a2 - 16);
  uint64_t v91 = a2 - 48;
  uint64_t v12 = a1;
  while (1)
  {
    a1 = v12;
    uint64_t v13 = a2 - v12;
    uint64_t v14 = (a2 - v12) >> 4;
    if (v6 || !v5)
    {
      switch(v14)
      {
        case 0:
        case 1:
          return;
        case 2:
          uint64_t v38 = *((void *)a2 - 2);
          unint64_t v37 = a2 - 16;
          if ((*a3)(v38, *(void *)a1))
          {
            unint64_t v106 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *(_OWORD *)v37;
            *(_OWORD *)unint64_t v37 = v106;
          }
          break;
        case 3:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, v95, a3);
          break;
        case 4:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, v95, a3);
          break;
        case 5:
          __int16 v39 = (uint64_t *)(a1 + 16);
          char v40 = (uint64_t *)(a1 + 32);
          uint64_t v41 = (uint64_t *)(a1 + 48);
          uint64_t v42 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, (void *)a1 + 6, a3);
          __n128 v44 = *((void *)a2 - 2);
          __n128 v43 = a2 - 16;
          if (((unsigned int (*)(uint64_t, void, __n128))*a3)(v44, *((void *)a1 + 6), v42))
          {
            unint64_t v45 = *(_OWORD *)v41;
            *(_OWORD *)uint64_t v41 = *(_OWORD *)v43;
            *(_OWORD *)__n128 v43 = v45;
            if ((*a3)(*v41, *v40))
            {
              uint64_t v46 = *(_OWORD *)v40;
              *(_OWORD *)char v40 = *(_OWORD *)v41;
              *(_OWORD *)uint64_t v41 = v46;
              if ((*a3)(*v40, *v39))
              {
                uint64_t v47 = *(_OWORD *)v39;
                *(_OWORD *)__int16 v39 = *(_OWORD *)v40;
                *(_OWORD *)char v40 = v47;
                if ((*a3)(*((void *)a1 + 2), *(void *)a1))
                {
                  uint64_t v107 = *(_OWORD *)a1;
                  *(_OWORD *)a1 = *(_OWORD *)v39;
                  *(_OWORD *)__int16 v39 = v107;
                }
              }
            }
          }
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v13 <= 383) {
      break;
    }
    if (!a4)
    {
      if (a1 == a2) {
        return;
      }
      uint64_t v92 = v13;
      uint64_t v94 = a2;
      uint64_t v59 = (unint64_t)(v14 - 2) >> 1;
      double v60 = v59;
      do
      {
        uint64_t v61 = v60;
        if (v59 >= v60)
        {
          uint64_t v62 = (2 * v60) | 1;
          unint64_t v63 = (uint64_t *)&a1[16 * v62];
          if (2 * v60 + 2 < v14 && (*a3)(*v63, v63[2]))
          {
            v63 += 2;
            uint64_t v62 = 2 * v61 + 2;
          }
          unint64_t v64 = (uint64_t *)&a1[16 * v61];
          if (((*a3)(*v63, *v64) & 1) == 0)
          {
            uint64_t v100 = v61;
            uint64_t v96 = *(_OWORD *)v64;
            uint64_t v65 = *v64;
            do
            {
              unint64_t v66 = v64;
              unint64_t v64 = v63;
              *(_OWORD *)unint64_t v66 = *(_OWORD *)v63;
              if (v59 < v62) {
                break;
              }
              int v67 = (2 * v62) | 1;
              unint64_t v63 = (uint64_t *)&a1[16 * v67];
              uint64_t v68 = 2 * v62 + 2;
              if (v68 < v14 && (*a3)(*v63, v63[2]))
              {
                v63 += 2;
                int v67 = v68;
              }
              uint64_t v62 = v67;
            }
            while (!(*a3)(*v63, v65));
            *(_OWORD *)unint64_t v64 = v96;
            uint64_t v61 = v100;
          }
        }
        double v60 = v61 - 1;
      }
      while (v61);
      unint64_t v69 = v94;
      long long v70 = v92 >> 4;
      while (2)
      {
        uint64_t v71 = v69;
        unint64_t v72 = 0;
        uint64_t v108 = *(_OWORD *)a1;
        uint64_t v73 = (uint64_t *)a1;
        do
        {
          unint64_t v74 = &v73[2 * v72 + 2];
          uint64_t v75 = (2 * v72) | 1;
          uint64_t v76 = 2 * v72 + 2;
          if (v76 < v70 && (*a3)(*v74, v73[2 * v72 + 4]))
          {
            v74 += 2;
            uint64_t v75 = v76;
          }
          *(_OWORD *)uint64_t v73 = *(_OWORD *)v74;
          uint64_t v73 = v74;
          unint64_t v72 = v75;
        }
        while (v75 <= (uint64_t)((unint64_t)(v70 - 2) >> 1));
        int v77 = (uint64_t *)(v71 - 16);
        if (v74 == v77)
        {
          unint64_t v69 = (char *)v77;
          __int16 v83 = v108;
          goto LABEL_112;
        }
        *(_OWORD *)unint64_t v74 = *(_OWORD *)v77;
        unint64_t v69 = (char *)v77;
        *(_OWORD *)int v77 = v108;
        uint64_t v78 = (char *)v74 - a1 + 16;
        if (v78 >= 17)
        {
          __int16 v79 = (((unint64_t)v78 >> 4) - 2) >> 1;
          int v80 = (uint64_t *)&a1[16 * v79];
          if ((*a3)(*v80, *v74))
          {
            uint64_t v101 = *(_OWORD *)v74;
            __int16 v81 = *v74;
            do
            {
              unint64_t v82 = v74;
              unint64_t v74 = v80;
              *(_OWORD *)unint64_t v82 = *(_OWORD *)v80;
              if (!v79) {
                break;
              }
              __int16 v79 = (v79 - 1) >> 1;
              int v80 = (uint64_t *)&a1[16 * v79];
            }
            while (((*a3)(*v80, v81) & 1) != 0);
            __int16 v83 = v101;
LABEL_112:
            *(_OWORD *)unint64_t v74 = v83;
          }
        }
        if (v70-- <= 2) {
          return;
        }
        continue;
      }
    }
    uint64_t v15 = (unint64_t)v14 >> 1;
    unint64_t v16 = &a1[16 * ((unint64_t)v14 >> 1)];
    if ((unint64_t)v13 < 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(v16, a1, v95, a3);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, v16, v95, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((void *)a1 + 2, (void *)v16 - 2, v93, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((void *)a1 + 4, &a1[16 * v15 + 16], v91, a3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((void *)v16 - 2, v16, &a1[16 * v15 + 16], a3);
      uint64_t v103 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)v16;
      *(_OWORD *)unint64_t v16 = v103;
    }
    --a4;
    if (a5 & 1) != 0 || ((*a3)(*((void *)a1 - 2), *(void *)a1))
    {
      unint64_t v17 = 0;
      uint64_t v97 = *(_OWORD *)a1;
      unsigned int v18 = *(void *)a1;
      do
      {
        uint64_t v19 = (*a3)(*(void *)&a1[v17 + 16], v18);
        v17 += 16;
      }
      while ((v19 & 1) != 0);
      char v20 = &a1[v17];
      BOOL v21 = a2;
      if (v17 == 16)
      {
        do
        {
          if (v20 >= a2) {
            break;
          }
          unint64_t v23 = *((void *)a2 - 2);
          a2 -= 16;
        }
        while (((*a3)(v23, v18) & 1) == 0);
      }
      else
      {
        do
        {
          unint64_t v22 = *((void *)a2 - 2);
          a2 -= 16;
        }
        while (!(*a3)(v22, v18));
      }
      uint64_t v12 = &a1[v17];
      if (v20 < a2)
      {
        long long v24 = a2;
        do
        {
          uint64_t v104 = *(_OWORD *)v12;
          *(_OWORD *)uint64_t v12 = *(_OWORD *)v24;
          *(_OWORD *)long long v24 = v104;
          do
          {
            long long v25 = *((void *)v12 + 2);
            v12 += 16;
          }
          while (((*a3)(v25, v18) & 1) != 0);
          do
          {
            uint64_t v26 = *((void *)v24 - 2);
            v24 -= 16;
          }
          while (!(*a3)(v26, v18));
        }
        while (v12 < v24);
      }
      uint64_t v27 = v12 - 16;
      if (v12 - 16 != a1) {
        *(_OWORD *)a1 = *(_OWORD *)v27;
      }
      *(_OWORD *)uint64_t v27 = v97;
      uint64_t v5 = v20 >= a2;
      a2 = v21;
      if (!v5) {
        goto LABEL_30;
      }
      {
        a2 = v12 - 16;
        if (v28) {
          return;
        }
        goto LABEL_1;
      }
      if (!v28)
      {
LABEL_30:
        a5 = 0;
      }
    }
    else
    {
      unint64_t v98 = *(_OWORD *)a1;
      uint64_t v29 = *(void *)a1;
      if ((*a3)(*(void *)a1, *v95))
      {
        uint64_t v12 = a1;
        do
        {
          char v30 = *((void *)v12 + 2);
          v12 += 16;
        }
        while (((*a3)(v29, v30) & 1) == 0);
      }
      else
      {
        uint64_t v31 = a1 + 16;
        do
        {
          uint64_t v12 = v31;
          if (v31 >= a2) {
            break;
          }
          v31 += 16;
        }
        while (!(*a3)(v29, *(void *)v12));
      }
      uint64_t v32 = a2;
      if (v12 < a2)
      {
        uint64_t v32 = a2;
        do
        {
          uint64_t v33 = *((void *)v32 - 2);
          v32 -= 16;
        }
        while (((*a3)(v29, v33) & 1) != 0);
      }
      while (v12 < v32)
      {
        uint64_t v105 = *(_OWORD *)v12;
        *(_OWORD *)uint64_t v12 = *(_OWORD *)v32;
        *(_OWORD *)uint64_t v32 = v105;
        do
        {
          uint64_t v34 = *((void *)v12 + 2);
          v12 += 16;
        }
        while (!(*a3)(v29, v34));
        do
        {
          uint64_t v35 = *((void *)v32 - 2);
          v32 -= 16;
        }
        while (((*a3)(v29, v35) & 1) != 0);
      }
      uint64_t v36 = v12 - 16;
      uint64_t v5 = v12 - 16 >= a1;
      char v6 = v12 - 16 == a1;
      if (v12 - 16 != a1) {
        *(_OWORD *)a1 = *(_OWORD *)v36;
      }
      a5 = 0;
      *(_OWORD *)uint64_t v36 = v98;
    }
  }
  uint64_t v48 = a1 + 16;
  unint64_t v50 = a1 == a2 || v48 == a2;
  if (a5)
  {
    if (!v50)
    {
      uint64_t v51 = 0;
      unint64_t v52 = (uint64_t *)a1;
      do
      {
        uint64_t v53 = v52[2];
        uint64_t v54 = *v52;
        unint64_t v52 = (uint64_t *)v48;
        if ((*a3)(v53, v54))
        {
          uint64_t v99 = *(_OWORD *)v52;
          uint64_t v55 = *v52;
          uint64_t v56 = v51;
          while (1)
          {
            *(_OWORD *)&a1[v56 + 16] = *(_OWORD *)&a1[v56];
            if (!v56) {
              break;
            }
            uint64_t v57 = (*a3)(v55, *(void *)&a1[v56 - 16]);
            v56 -= 16;
            if ((v57 & 1) == 0)
            {
              uint64_t v58 = &a1[v56 + 16];
              goto LABEL_80;
            }
          }
          uint64_t v58 = a1;
LABEL_80:
          *(_OWORD *)uint64_t v58 = v99;
        }
        uint64_t v48 = (char *)(v52 + 2);
        v51 += 16;
      }
      while (v52 + 2 != (uint64_t *)a2);
    }
  }
  else if (!v50)
  {
    do
    {
      __n128 v85 = *((void *)a1 + 2);
      long long v86 = *(void *)a1;
      a1 = v48;
      if ((*a3)(v85, v86))
      {
        unint64_t v102 = *(_OWORD *)a1;
        long long v87 = *(void *)a1;
        long long v88 = a1;
        do
        {
          long long v89 = v88 - 16;
          *(_OWORD *)long long v88 = *((_OWORD *)v88 - 1);
          uint64_t v90 = (*a3)(v87, *((void *)v88 - 4));
          long long v88 = v89;
        }
        while ((v90 & 1) != 0);
        *(_OWORD *)long long v89 = v102;
      }
      uint64_t v48 = a1 + 16;
    }
    while (a1 + 16 != a2);
  }
}

uint64_t std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((uint64_t *)result != a2)
  {
    unint64_t v4 = (_OWORD *)result;
    uint64_t v5 = (uint64_t *)(result + 16);
    if ((uint64_t *)(result + 16) != a2)
    {
      uint64_t v7 = 0;
      char v8 = (uint64_t *)result;
      do
      {
        uint64_t v9 = v8[2];
        uint64_t v10 = *v8;
        char v8 = v5;
        double result = (*a3)(v9, v10);
        if (result)
        {
          long long v14 = *(_OWORD *)v8;
          uint64_t v11 = *v8;
          uint64_t v12 = v7;
          while (1)
          {
            *(_OWORD *)((char *)v4 + v12 + 16) = *(_OWORD *)((char *)v4 + v12);
            if (!v12) {
              break;
            }
            double result = (*a3)(v11, *(void *)((char *)v4 + v12 - 16));
            v12 -= 16;
            if ((result & 1) == 0)
            {
              uint64_t v13 = (_OWORD *)((char *)v4 + v12 + 16);
              goto LABEL_10;
            }
          }
          uint64_t v13 = v4;
LABEL_10:
          *uint64_t v13 = v14;
        }
        uint64_t v5 = v8 + 2;
        v7 += 16;
      }
      while (v8 + 2 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(uint64_t result, void *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((void *)result != a2)
  {
    unint64_t v4 = (void *)result;
    for (uint64_t i = (void *)(result + 16); v4 + 2 != a2; uint64_t i = v4 + 2)
    {
      uint64_t v7 = v4[2];
      uint64_t v8 = *v4;
      unint64_t v4 = i;
      double result = (*a3)(v7, v8);
      if (result)
      {
        long long v12 = *(_OWORD *)v4;
        uint64_t v9 = *v4;
        uint64_t v10 = v4;
        do
        {
          uint64_t v11 = v10 - 1;
          *uint64_t v10 = *(v10 - 1);
          double result = (*a3)(v9, *((void *)v10 - 4));
          uint64_t v10 = v11;
        }
        while ((result & 1) != 0);
        *uint64_t v11 = v12;
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(void *a1, void *a2, void *a3, uint64_t (**a4)(void, void))
{
  char v8 = (*a4)(*a2, *a1);
  uint64_t result = (*a4)(*a3, *a2);
  if ((v8 & 1) == 0)
  {
    if (!result) {
      return result;
    }
    long long v11 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v11;
    if (!(*a4)(*a2, *a1)) {
      return 1;
    }
    long long v12 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v12;
    return 2;
  }
  if (!result)
  {
    long long v13 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v13;
    if (!(*a4)(*a3, *a2)) {
      return 1;
    }
    long long v14 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v14;
    return 2;
  }
  long long v10 = *(_OWORD *)a1;
  *(_OWORD *)a1 = *(_OWORD *)a3;
  *(_OWORD *)a3 = v10;
  return 1;
}

uint64_t *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  unint64_t v4 = a2;
  long long v14 = *(_OWORD *)a1;
  uint64_t v6 = *a1;
  if ((*a3)(*a1, *(a2 - 2)))
  {
    uint64_t v7 = a1;
    do
    {
      uint64_t v8 = v7[2];
      v7 += 2;
    }
    while (((*a3)(v6, v8) & 1) == 0);
  }
  else
  {
    uint64_t v9 = a1 + 2;
    do
    {
      uint64_t v7 = v9;
      if (v9 >= v4) {
        break;
      }
      v9 += 2;
    }
    while (!(*a3)(v6, *v7));
  }
  if (v7 < v4)
  {
    do
    {
      uint64_t v10 = *(v4 - 2);
      v4 -= 2;
    }
    while (((*a3)(v6, v10) & 1) != 0);
  }
  while (v7 < v4)
  {
    long long v15 = *(_OWORD *)v7;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)v4;
    *(_OWORD *)unint64_t v4 = v15;
    do
    {
      uint64_t v11 = v7[2];
      v7 += 2;
    }
    while (!(*a3)(v6, v11));
    do
    {
      uint64_t v12 = *(v4 - 2);
      v4 -= 2;
    }
    while (((*a3)(v6, v12) & 1) != 0);
  }
  if (v7 - 2 != a1) {
    *(_OWORD *)a1 = *((_OWORD *)v7 - 1);
  }
  *((_OWORD *)v7 - 1) = v14;
  return v7;
}

long long *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &>(long long *a1, long long *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v6 = 0;
  long long v19 = *a1;
  uint64_t v7 = *(void *)a1;
  do
    char v8 = (*a3)(*(void *)&a1[++v6], v7);
  while ((v8 & 1) != 0);
  uint64_t v9 = &a1[v6];
  uint64_t v10 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2) {
        break;
      }
      uint64_t v12 = *((void *)a2-- - 2);
    }
    while (((*a3)(v12, v7) & 1) == 0);
  }
  else
  {
    do
      uint64_t v11 = *((void *)a2-- - 2);
    while (!(*a3)(v11, v7));
  }
  if (v9 < a2)
  {
    long long v13 = &a1[v6];
    long long v14 = a2;
    do
    {
      long long v15 = *v13;
      *long long v13 = *v14;
      *long long v14 = v15;
      do
        uint64_t v16 = *((void *)v13++ + 2);
      while (((*a3)(v16, v7) & 1) != 0);
      do
        uint64_t v17 = *((void *)v14-- - 2);
      while (!(*a3)(v17, v7));
    }
    while (v13 < v14);
    uint64_t v10 = v13 - 1;
  }
  if (v10 != a1) {
    *a1 = *v10;
  }
  *uint64_t v10 = v19;
  return v10;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(char *a1, char *a2, uint64_t (**a3)(uint64_t, void))
{
  uint64_t v6 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      char v8 = a2 - 16;
      if ((*a3)(*((void *)a2 - 2), *(void *)a1))
      {
        long long v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)char v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, (void *)a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, (void *)a1 + 6, (void *)a2 - 2, a3);
      return 1;
    default:
      uint64_t v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, a3);
      uint64_t v11 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(*(void *)v11, *(void *)v10))
    {
      long long v18 = *(_OWORD *)v11;
      uint64_t v14 = *(void *)v11;
      uint64_t v15 = v12;
      while (1)
      {
        *(_OWORD *)&a1[v15 + 48] = *(_OWORD *)&a1[v15 + 32];
        if (v15 == -32) {
          break;
        }
        char v16 = (*a3)(v14, *(void *)&a1[v15 + 16]);
        v15 -= 16;
        if ((v16 & 1) == 0)
        {
          uint64_t v17 = &a1[v15 + 48];
          goto LABEL_12;
        }
      }
      uint64_t v17 = a1;
LABEL_12:
      *(_OWORD *)uint64_t v17 = v18;
      if (++v13 == 8) {
        return v11 + 16 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(void *a1, void *a2, void *a3, void *a4, uint64_t (**a5)(void, void))
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, a2, a3, a5);
  if ((*a5)(*a4, *a3))
  {
    long long v11 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)a4 = v11;
    if ((*a5)(*a3, *a2))
    {
      long long v12 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v12;
      if ((*a5)(*a2, *a1))
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(void *a1, void *a2, void *a3, void *a4, void *a5, uint64_t (**a6)(void, void))
{
  __n128 v12 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, a2, a3, a4, a6);
  if (((unsigned int (*)(void, void, __n128))*a6)(*a5, *a4, v12))
  {
    long long v14 = *(_OWORD *)a4;
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)a5 = v14;
    if ((*a6)(*a4, *a3))
    {
      long long v15 = *(_OWORD *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)a4 = v15;
      if ((*a6)(*a3, *a2))
      {
        long long v16 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)a3 = v16;
        if ((*a6)(*a2, *a1))
        {
          __n128 result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

char *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,re::Pair<void const*,void *,true>*>(char *a1, char *a2, char *a3, uint64_t (**a4)(unint64_t, unint64_t), __n128 a5)
{
  if (a1 != a2)
  {
    uint64_t v9 = a2 - a1;
    uint64_t v10 = (a2 - a1) >> 4;
    if (a2 - a1 >= 17)
    {
      unint64_t v11 = (unint64_t)(v10 - 2) >> 1;
      unint64_t v12 = v11 + 1;
      int v13 = &a1[16 * v11];
      do
      {
        a5 = std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((uint64_t)a1, (unsigned int (**)(void, uint64_t))a4, v10, v13);
        v13 -= 16;
        --v12;
      }
      while (v12);
    }
    long long v14 = a2;
    if (a2 != a3)
    {
      long long v15 = a2;
      do
      {
        if (((unsigned int (*)(void, void, __n128))*a4)(*(void *)v15, *(void *)a1, a5))
        {
          long long v16 = *(_OWORD *)v15;
          *(_OWORD *)long long v15 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          a5 = std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((uint64_t)a1, (unsigned int (**)(void, uint64_t))a4, v10, a1);
        }
        v15 += 16;
      }
      while (v15 != a3);
      long long v14 = a3;
    }
    if (v9 >= 17)
    {
      uint64_t v17 = (unint64_t)v9 >> 4;
      long long v18 = a2 - 16;
      do
      {
        long long v22 = *(_OWORD *)a1;
        long long v19 = (char *)std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (unsigned int (**)(void, void))a4, v17);
        if (v18 == v19)
        {
          *(_OWORD *)long long v19 = v22;
        }
        else
        {
          *(_OWORD *)long long v19 = *(_OWORD *)v18;
          *(_OWORD *)long long v18 = v22;
          std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>((uint64_t)a1, (uint64_t)(v19 + 16), a4, (v19 + 16 - a1) >> 4);
        }
        v18 -= 16;
      }
      while (v17-- > 2);
    }
    return v14;
  }
  return a3;
}

__n128 std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(uint64_t a1, unsigned int (**a2)(void, uint64_t), uint64_t a3, void *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v5 = a4;
    int64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - a1) >> 4)
    {
      uint64_t v10 = ((uint64_t)a4 - a1) >> 3;
      uint64_t v11 = v10 + 1;
      unint64_t v12 = (void *)(a1 + 16 * (v10 + 1));
      uint64_t v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(*v12, v12[2]))
      {
        v12 += 2;
        uint64_t v11 = v13;
      }
      if ((((uint64_t (*)(void, void))*a2)(*v12, *v5) & 1) == 0)
      {
        __n128 v19 = *(__n128 *)v5;
        uint64_t v15 = *v5;
        do
        {
          long long v16 = v5;
          uint64_t v5 = v12;
          *long long v16 = *(_OWORD *)v12;
          if (v7 < v11) {
            break;
          }
          uint64_t v17 = (2 * v11) | 1;
          unint64_t v12 = (void *)(a1 + 16 * v17);
          uint64_t v18 = 2 * v11 + 2;
          if (v18 < a3)
          {
            if ((*a2)(*v12, v12[2]))
            {
              v12 += 2;
              uint64_t v17 = v18;
            }
          }
          uint64_t v11 = v17;
        }
        while (!(*a2)(*v12, v15));
        __n128 result = v19;
        *(__n128 *)uint64_t v5 = v19;
      }
    }
  }
  return result;
}

void *std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(_OWORD *a1, unsigned int (**a2)(void, void), uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(*v9, *(void *)&a1[v6 + 2]))
    {
      v9 += 2;
      uint64_t v10 = v11;
    }
    *a1 = *(_OWORD *)v9;
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

__n128 std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(uint64_t a1, uint64_t a2, uint64_t (**a3)(unint64_t, unint64_t), uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (__n128 *)(a1 + 16 * (v4 >> 1));
    uint64_t v9 = (__n128 *)(a2 - 16);
    if ((*a3)(v8->n128_u64[0], *(void *)(a2 - 16)))
    {
      __n128 v13 = *v9;
      unint64_t v11 = v9->n128_u64[0];
      do
      {
        unint64_t v12 = v9;
        uint64_t v9 = v8;
        *unint64_t v12 = *v8;
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (__n128 *)(a1 + 16 * v7);
      }
      while (((*a3)(v8->n128_u64[0], v11) & 1) != 0);
      __n128 result = v13;
      __n128 *v9 = v13;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginObject(uint64_t a1, const char *a2, int a3, int a4)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v15 = 0;
  uint64_t v4 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (v4)
  {
    if ((a4 & 0x10) != 0)
    {
      char __src = -33;
      if (!*(unsigned char *)(a1 + 40)
        && (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, &__src, 1uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Object");
      }
      char v8 = 1;
    }
    else
    {
      char __src = -17;
      if (!*(unsigned char *)(a1 + 40)
        && (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, &__src, 1uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Object");
      }
      char v8 = 2;
    }
    LOBYTE(v10) = v8;
    DWORD1(v10) = a4;
    *((void *)&v10 + 1) = a2;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    unint64_t v13 = 0xFFFFFFFF80000000;
    uint64_t v14 = 0;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v10);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v15;
  }
  return v4;
}

_anonymous_namespace_ *re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endObject(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    char __src = 3;
    if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(result, &__src, 1uLL) & 1) == 0)re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v1, 0, (uint64_t)"Object"); {
    uint64_t v2 = *((void *)v1 + 16);
    }
    uint64_t v3 = *((void *)v1 + 14) - 1;
    uint64_t v4 = *(void *)(v2 + 48 * v3 + 16);
    if (v4)
    {
      do
      {
        --v4;
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject((uint64_t)v1);
      }
      while (v4);
      uint64_t v2 = *((void *)v1 + 16);
      uint64_t v3 = *((void *)v1 + 14) - 1;
    }
    __n128 result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, *(unsigned __int8 *)(v2 + 48 * v3));
    uint64_t v5 = *((void *)v1 + 16);
    uint64_t v6 = *((void *)v1 + 14) - 1;
    if (*(unsigned char *)(v5 + 48 * v6) != 2) {
      ++*(void *)(v5 + 48 * v6 + 32);
    }
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (__n128 v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v27 = 0;
    int v21 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginString(a1 + 24, a2, v9, &v27, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    if (v27) {
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
    }
    long long v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_29;
  }
  unint64_t v23 = *(void *)(a4 + 8);
  if (v23) {
    unint64_t v24 = v23 >> 1;
  }
  else {
    unint64_t v24 = v23 >> 1;
  }
  unint64_t v27 = v24;
  int v25 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginString(a1 + 24, a2, v9, &v27, 0);
  BOOL result = 0;
  if (v25)
  {
    if (v27)
    {
      if (*(unsigned char *)(a4 + 8)) {
        uint64_t v26 = *(char **)(a4 + 16);
      }
      else {
        uint64_t v26 = (char *)(a4 + 9);
      }
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, v26, 0);
    }
    long long v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_29:
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endString(v22);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::internal::serializeObjectWithOneMember<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)v29, *a5, a5[2]);
  re::TypeMemberCollection::operator[](v14, 0, (uint64_t)&v27);
  uint64_t v15 = a4 + *(unsigned int *)(v28 + 24);
  re::TypeRegistry::typeInfo(v27, *(void *)v28, v29);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v30);
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*a5 == *a6)
  {
    uint64_t v18 = *(void *)a5[2];
    uint64_t v19 = a6[2];
    uint64_t v20 = *(void *)v19;
    if ((unsigned __int16)v18 != (unsigned __int16)*(void *)v19) {
      goto LABEL_14;
    }
    BOOL v22 = WORD1(v18) == WORD1(v20);
    uint64_t v21 = (v20 ^ v18) & 0xFFFFFF00000000;
    BOOL v22 = v22 && v21 == 0;
    if (!v22) {
      goto LABEL_14;
    }
LABEL_4:
    if (!a1[64]) {
      return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v26, a7);
    }
    return 0;
  }
  if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, v16)) {
    goto LABEL_4;
  }
  uint64_t v19 = a6[2];
LABEL_14:
  if (*(_DWORD *)(v19 + 88) != 1)
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
    return 0;
  }
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v23, *a6, v19);
  re::TypeMemberCollection::operator[](v23, 0, (uint64_t)v24);
  re::TypeRegistry::typeInfo(v24[0], *v24[2], v29);
  re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v30);
  if (a1[64]) {
    return 0;
  }
  return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v25, a7);
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginString(uint64_t a1, const char *a2, int a3, unint64_t *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (result)
  {
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeStringTag(a1, a2, *a4);
    unint64_t v10 = *a4;
    LOBYTE(v11) = 8;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeString(uint64_t result, char *a2, char a3)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v4 = (_anonymous_namespace_ *)result;
    size_t v5 = *(void *)(*(void *)(result + 128) + 48 * *(void *)(result + 112) - 24);
    uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, a2, v5);
    if ((result & 1) == 0) {
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v4, 0, (uint64_t)"String");
    }
    if ((a3 & 2) == 0)
    {
      uint64_t v6 = *((void *)v4 + 16);
      uint64_t v7 = *((void *)v4 + 14) - 1;
      if (*(unsigned char *)(v6 + 48 * v7) != 2) {
        *(void *)(v6 + 48 * v7 + 32) += v5;
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endString(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 8);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if (v10) {
        uint64_t v7 = *(unsigned char **)&v11[7];
      }
      else {
        uint64_t v7 = v11;
      }
      uint64_t v8 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize string \"%s\". Expected number of characters: %lld. Actual number of characters: %lld.", (re::DynamicString *)v12, v7, *(void *)(v8 - 24), *(void *)(v8 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(void *)&v12[0])
      {
        if (BYTE8(v12[0])) {
          (*(void (**)(void))(**(void **)&v12[0] + 40))();
        }
        memset(v12, 0, sizeof(v12));
      }
      uint64_t result = v9;
      if (v9 && (v10 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v9 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeStringTag(uint64_t result, const char *a2, unint64_t a3)
{
  uint64_t v5 = (unsigned __int8 *)result;
  if (a3 > 0x20)
  {
    if (a3 <= 0xFF)
    {
      LOBYTE(__src) = 97;
      if (!*(unsigned char *)(result + 40))
      {
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
        if ((result & 1) == 0) {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String(8-Bit Length)");
        }
        int v8 = v5[40];
        LOBYTE(__src) = a3;
        if (!v8)
        {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, (char *)&__src, 1uLL);
          if ((result & 1) == 0)
          {
            uint64_t v6 = "String(8-Bit Length)";
            return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
          }
        }
      }
    }
    else if (a3 >> 16)
    {
      if (HIDWORD(a3))
      {
        LOBYTE(__src) = 100;
        if (!*(unsigned char *)(result + 40))
        {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
          if ((result & 1) == 0) {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String(64-Bit Length)");
          }
          int v7 = v5[40];
          unint64_t __src = a3;
          if (!v7)
          {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, (char *)&__src, 8uLL);
            if ((result & 1) == 0)
            {
              uint64_t v6 = "String(64-Bit Length)";
              return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
            }
          }
        }
      }
      else
      {
        LOBYTE(__src) = 99;
        if (!*(unsigned char *)(result + 40))
        {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
          if ((result & 1) == 0) {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String(32-Bit Length)");
          }
          int v10 = v5[40];
          LODWORD(__src) = a3;
          if (!v10)
          {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, (char *)&__src, 4uLL);
            if ((result & 1) == 0)
            {
              uint64_t v6 = "String(32-Bit Length)";
              return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
            }
          }
        }
      }
    }
    else
    {
      LOBYTE(__src) = 98;
      if (!*(unsigned char *)(result + 40))
      {
        uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
        if ((result & 1) == 0) {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String(16-Bit Length)");
        }
        int v9 = v5[40];
        LOWORD(__src) = a3;
        if (!v9)
        {
          uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>(v5, (char *)&__src, 2uLL);
          if ((result & 1) == 0)
          {
            uint64_t v6 = "String(16-Bit Length)";
            return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
          }
        }
      }
    }
  }
  else
  {
    LOBYTE(__src) = a3 + 64;
    if (!*(unsigned char *)(result + 40))
    {
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, (char *)&__src, 1uLL);
      if ((result & 1) == 0)
      {
        uint64_t v6 = "Small String";
        return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)v6);
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v19);
  if (v19[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v16, (uint64_t)&v20);
    if (*(_DWORD *)(v17 + 88) || (re::TypeRegistry::typeInfo(v16[0], *(void *)(v17 + 72), v21), v21[0]))
    {
      if (re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginObject((uint64_t)(a1 + 24), "@super", 0, 0))
      {
        re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, v16, a4);
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      }
    }
  }
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v16, *a3, a3[2]);
  if (v18)
  {
    for (unint64_t i = 0; i < v18; ++i)
    {
      if (a1[64]) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v16, i, (uint64_t)&v14);
      if (*(unsigned char *)(v15 + 28))
      {
        uint64_t v10 = *(void *)(v15 + 16);
        if (strlen((const char *)v10) >= 3 && *(unsigned char *)v10 == 109) {
          v10 += 2 * (*(unsigned char *)(v10 + 1) == 95);
        }
        uint64_t v11 = *(unsigned int *)(v15 + 32);
        uint64_t v12 = *(unsigned int *)(v15 + 24);
        re::TypeRegistry::typeInfo(v14, *(void *)v15, v21);
        uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v22);
        if (!a1[64]) {
          uint64_t result = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v10, v11, a2 + v12, v13, v13, a4);
        }
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v50);
  re::TypeRegistry::typeInfo((void *)*a4, *(void *)(a4[2] + 72), v46);
  if (v46[0])
  {
    if (!v50[0])
    {
      uint64_t v11 = re::TypeInfo::name((re::TypeInfo *)&v47)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginObject(a1 + 24, "@super", 0, 0))
    {
      if (v51 == v47)
      {
        uint64_t v18 = *v53;
        uint64_t v19 = *v49;
        if ((unsigned __int16)*v53 == (unsigned __int16)*v49)
        {
          BOOL v21 = WORD1(v18) == WORD1(v19);
          uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
          BOOL v21 = v21 && v20 == 0;
          if (v21) {
            goto LABEL_6;
          }
        }
      }
      else if (re::areSameTranslatedVersion((re *)&v51, (const re::TypeInfo *)&v47, v10))
      {
LABEL_6:
        re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((unsigned char *)a1, a2, &v51, a5);
LABEL_16:
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
        goto LABEL_17;
      }
      if (v52 == v48)
      {
        re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, &v51, &v47, a5);
      }
      else
      {
        uint64_t v22 = re::TypeInfo::name((re::TypeInfo *)&v51)[1];
        re::TypeInfo::name((re::TypeInfo *)&v47);
        re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
      }
      goto LABEL_16;
    }
  }
LABEL_17:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v45, *a3, a3[2]);
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v43, *a4, a4[2]);
  if (v44)
  {
    for (unint64_t i = 0; i < v44; ++i)
    {
      if (*(unsigned char *)(a1 + 64)) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[](v43, i, (uint64_t)v41);
      if (*(unsigned char *)(v42 + 28))
      {
        uint64_t v29 = *(void *)(v42 + 16);
        if (strlen((const char *)v29) >= 3 && *(unsigned char *)v29 == 109) {
          v29 += 2 * (*(unsigned char *)(v29 + 1) == 95);
        }
        uint64_t v30 = *(unsigned int *)(v42 + 32);
        uint64_t v31 = *(re **)(*a4 + 856);
        if (!v31
          || (uint64_t v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v41),
              v31 == -1))
        {
          uint64_t v33 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
          {
            uint64_t v34 = v33;
            uint64_t v35 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            uint64_t v55 = v35;
            __int16 v56 = 2080;
            uint64_t v57 = v29;
            _os_log_impl(&dword_233120000, v34, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          uint64_t v36 = *(re::internal **)(a1 + 208);
          re::TypeRegistry::typeInfo(v41[0], *(void *)v42, buf);
          re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v55 + 4);
          uint64_t result = re::internal::translateType(v36, (const re::TypeRegistry *)v39, (uint64_t)buf);
          if (!*(unsigned char *)(a1 + 64)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint8_t *, uint8_t *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
          }
        }
        else
        {
          re::TypeMemberCollection::operator[](v45, (int)v31, (uint64_t)v39);
          uint64_t v32 = *(unsigned int *)(v40 + 24);
          re::TypeRegistry::typeInfo(v39[0], *(void *)v40, buf);
          re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v55 + 4);
          re::TypeRegistry::typeInfo(v41[0], *(void *)v42, buf);
          uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v55 + 4);
          if (!*(unsigned char *)(a1 + 64)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, a2 + v32, v38, v37, a5);
          }
        }
      }
    }
  }
  return result;
}

double re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 96 * v3;
      do
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 96;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 32 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 32;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    uint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 96 * v3;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16) + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 96;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::serializeSharedObjects(uint64_t result)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  if (*(void *)(result + 288) >= 2uLL)
  {
    uint64_t v1 = result;
    uint64_t v2 = (_anonymous_namespace_ *)(result + 24);
    double result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginObject(result + 24, "@shared", 20, 0);
    if (result)
    {
      uint64_t v3 = *(void *)(v1 + 56);
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      uint64_t v14 = v3;
      uint64_t v15 = 0;
      re::DynamicString::setCapacity(&v14, 8uLL);
      if (*(void *)(v1 + 288) < 2uLL)
      {
LABEL_18:
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endObject(v2);
      }
      else
      {
        uint64_t v4 = 0;
        unint64_t v5 = 1;
        while (!*(unsigned char *)(v1 + 64))
        {
          re::DynamicString::assignf((re::DynamicString *)&v14, "%u", v5);
          unint64_t v6 = *(void *)(v1 + 288);
          if (v6 <= v5)
          {
            uint64_t v18 = 0;
            long long v30 = 0u;
            long long v31 = 0u;
            long long v28 = 0u;
            long long v29 = 0u;
            long long v27 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v19 = 136315906;
            uint64_t v20 = "operator[]";
            __int16 v21 = 1024;
            int v22 = 789;
            __int16 v23 = 2048;
            unint64_t v24 = v5;
            __int16 v25 = 2048;
            unint64_t v26 = v6;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          uint64_t v7 = *(void *)(v1 + 304) + v4;
          uint64_t v10 = *(void *)(v7 + 80);
          re::TypeInfo::TypeInfo((uint64_t)v11, v7 + 88);
          re::TypeInfo::TypeInfo((uint64_t)v12, v7 + 120);
          unsigned __int16 v13 = *(_WORD *)(v7 + 152);
          if ((_BYTE)v13)
          {
            if (v15) {
              int v8 = v16;
            }
            else {
              int v8 = (char *)&v15 + 1;
            }
            re::internal::serializePolymorphicObject<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((unsigned char *)v1, v8, v5, v10, (re::TypeInfo *)v11, v12, v13 > 0xFFu);
          }
          else if (!*(unsigned char *)(v1 + 64))
          {
            if (v15) {
              int v9 = (char *)v16;
            }
            else {
              int v9 = (char *)&v15 + 1;
            }
            (*(void (**)(uint64_t, char *, unint64_t, uint64_t, unsigned char *, re::TypeRegistry **, void))(*(void *)v1 + 72))(v1, v9, v5, v10, v11, v12, 0);
          }
          ++v5;
          v4 += 80;
          if (*(void *)(v1 + 288) <= v5) {
            goto LABEL_18;
          }
        }
      }
      double result = v14;
      if (v14)
      {
        if (v15) {
          return (*(uint64_t (**)(void))(*(void *)v14 + 40))();
        }
      }
    }
  }
  return result;
}

BOOL re::internal::serializePolymorphicObject<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, re::TypeRegistry **a6, int a7)
{
  re::TypeInfo::TypeInfo((uint64_t)v30, (uint64_t)a5);
  if (a7)
  {
    unsigned __int16 v13 = *a6;
    uint64_t v14 = re::TypeInfo::name(a5);
    re::TypeRegistry::typeInfo(v13, (const re::StringID *)v14, v28);
    if (!v28[0])
    {
      uint64_t v27 = re::TypeInfo::name(a5)[1];
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "No matching type found for polymorphic type \"%s\" to serialize.", v21, v22, v23, v24, v25, v27);
      return 0;
    }
    re::TypeInfo::operator=((uint64_t)v30, (uint64_t)v29);
  }
  v28[0] = *(unsigned char *)(v31 + 120);
  if (!v28[0])
  {
    uint64_t v26 = re::TypeInfo::name((re::TypeInfo *)v30)[1];
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "Failed to get custom class ID for type \"%s\".", v16, v17, v18, v19, v20, v26);
    return 0;
  }
  v29[0] = *(void *)(v31 + 128);
  if (!re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginObject((uint64_t)(a1 + 24), a2, 0, 0)) {
    return 0;
  }
  re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned long long>((uint64_t)(a1 + 24), "customClassID", 1, v29, 0);
  if (!a1[64]) {
    (*(void (**)(unsigned char *, const char *, uint64_t, uint64_t, re::TypeInfo *, unsigned char *, void))(*(void *)a1 + 72))(a1, "object", 10, a4, a5, v30, 0);
  }
  re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
  return a1[64] == 0;
}

uint64_t *re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 208);
  double result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5) {
    BOOL v7 = result == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = *result;
    uint64_t v10 = a3;
    unint64_t v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 224, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  char v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeBool(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeChar<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  char v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeI8<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  char v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeI16<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  __int16 v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<short>(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeI32<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, int *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  int v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<int>(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeI64<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  uint64_t v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeU8<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  char v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (unsigned __int8 *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeU16<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int16 *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  __int16 v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (unsigned __int16 *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeU32<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned int *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  int v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (unsigned int *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeU64<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  uint64_t v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeFloat<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  int v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (char *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeFloat(a1 + 24, a2, v9, v14, a7);
}

uint64_t re::serializeDouble<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  uint64_t v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (char *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeDouble(a1 + 24, a2, v9, v14, a7);
}

BOOL re::serializeCString<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_23:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v24 = **((void **)a5 + 2);
    uint64_t v25 = **((void **)a6 + 2);
    if ((unsigned __int16)v24 != (unsigned __int16)v25) {
      goto LABEL_23;
    }
    BOOL v27 = WORD1(v24) == WORD1(v25);
    uint64_t v26 = (v25 ^ v24) & 0xFFFFFF00000000;
    BOOL v27 = v27 && v26 == 0;
    if (!v27) {
      goto LABEL_23;
    }
  }
LABEL_4:
  if (a7)
  {
    int v29 = 0;
    int v19 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, v9, &v29, 0);
    BOOL result = 0;
    if (!v19) {
      return result;
    }
    if (v29)
    {
      if (v29 == 1)
      {
        re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, (char)v28);
        return 0;
      }
      long long v28 = 0;
      if (re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginString(a1 + 24, a2, 0, (unint64_t *)&v28, 0))
      {
        if (v28) {
          re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
        }
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    uint64_t v23 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    int v29 = 2 * (*a4 != 0);
    int v21 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, v9, &v29, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    if (v29 == 2)
    {
      uint64_t v22 = *a4;
      if (*a4) {
        uint64_t v22 = (const char *)strlen(v22);
      }
      long long v28 = v22;
      if (re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginString(a1 + 24, a2, 0, (unint64_t *)&v28, 0))
      {
        if (v28) {
          re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, *a4, 0);
        }
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    uint64_t v23 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endPointer(v23);
  return *(unsigned char *)(a1 + 64) == 0;
}

uint64_t re::serializeStringID<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (int v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    size_t v23 = 0;
    int v21 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginString(a1 + 24, a2, v9, &v23, 0);
    uint64_t result = 0;
    if (!v21) {
      return result;
    }
    if (v23) {
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    size_t v23 = strlen(*(const char **)(a4 + 8));
    uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginString(a1 + 24, a2, v9, &v23, 0);
    if (!result) {
      return result;
    }
    if (v23) {
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, *(char **)(a4 + 8), 0);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endString(v22);
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v10 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_28:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v23 = **((void **)a5 + 2);
    uint64_t v24 = **((void **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24) {
      goto LABEL_28;
    }
    BOOL v26 = WORD1(v23) == WORD1(v24);
    uint64_t v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    BOOL v26 = v26 && v25 == 0;
    if (!v26) {
      goto LABEL_28;
    }
  }
LABEL_4:
  if (!a7)
  {
    unint64_t v16 = **((void **)a5 + 2);
    uint64_t v32 = *(void *)a5;
    unint64_t v33 = v16;
    LODWORD(v34) = -1;
    v36[0] = 0x258C98EAAF29A10ALL;
    v36[1] = (unint64_t)"CallbackSerializerAttribute";
    BOOL v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v32, v36);
    re::StringID::destroyString((re::StringID *)v36);
    uint64_t v18 = *v17;
    uint64_t v19 = *(void *)(a1 + 200);
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v32 = v20;
    unint64_t v33 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    if ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v18 + 72))(v19, v18, a4, &v32))
    {
      if (v33) {
        unint64_t v21 = v33 >> 1;
      }
      else {
        unint64_t v21 = v33 >> 1;
      }
      v36[0] = v21;
      if (re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginString(a1 + 24, a2, v10, v36, 0))
      {
        if (v36[0])
        {
          if (v33) {
            uint64_t v22 = v34;
          }
          else {
            uint64_t v22 = (char *)&v33 + 1;
          }
          re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, v22, 0);
        }
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
        if (v32 && (v33 & 1) != 0) {
          (*(void (**)(void))(*(void *)v32 + 40))();
        }
        return *(unsigned char *)(a1 + 64) == 0;
      }
    }
    else
    {
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Failed to write string for \"%s\" (type %s) using serialization callback.", v27, v28, v29, v30, v31, (char)a2);
    }
    if (v32 && (v33 & 1) != 0) {
      (*(void (**)(void))(*(void *)v32 + 40))();
    }
    return 0;
  }
  uint64_t v32 = 0;
  int v14 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginString(a1 + 24, a2, v10, (unint64_t *)&v32, 0);
  BOOL result = 0;
  if (v14)
  {
    if (v32) {
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
    }
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginPointer(uint64_t a1, const char *a2, int a3, int *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v17 = 0;
  uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::advance(a1, a2, a3);
  if (result)
  {
    int v11 = *a4;
    if ((*a4 - 1) >= 2)
    {
      if (v11)
      {
        re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Unexpected PointerEncoding.", "!\"Unreachable code\"", "beginPointer", 927);
        uint64_t result = _os_crash();
        __break(1u);
        return result;
      }
      char __src = 4;
      if (!*(unsigned char *)(a1 + 40)
        && (re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, &__src, 1uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Optional");
      }
      int v11 = *a4;
    }
    LOBYTE(v12) = 9;
    DWORD1(v12) = a5;
    *((void *)&v12 + 1) = a2;
    uint64_t v13 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    BOOL v14 = v11 != 0;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v12);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v17;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endPointer(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 9);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v8);
      if (v9) {
        BOOL v7 = *(unsigned char **)&v10[7];
      }
      else {
        BOOL v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". No value was provided.", (re::DynamicString *)v11, v7);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      uint64_t result = v8;
      if (v8 && (v9 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v8 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  if (!*(void *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  unint64_t v7 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v7);
  if (v8 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  while (*(void *)(v9 + 24 * v8 + 4) != v6)
  {
    uint64_t v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v10 = 3 * v8;
  *(void *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  uint64_t v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v13) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(void *)(*(void *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10 + 4), *(void *)&v13[16] + v10 + 4, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    BOOL v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 80 * v4;
  *(void *)uint64_t v5 = *(void *)a2;
  re::TypeInfo::TypeInfo(v5 + 8, a2 + 8);
  uint64_t result = re::TypeInfo::TypeInfo(v5 + 40, a2 + 40);
  *(_WORD *)(v5 + 72) = *(_WORD *)(a2 + 72);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::addNew<int>(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::addEmplace<int>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 32 * v10;
  return v12 + 24;
}

void *re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x50uLL))
        {
          uint64_t v2 = 80 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 80 * v9;
        uint64_t v11 = (uint64_t)(v7 + 5);
        uint64_t v12 = v8 + 40;
        do
        {
          *(void *)(v11 - 40) = *(void *)(v12 - 40);
          re::TypeInfo::TypeInfo(v11 - 32, v12 - 32);
          re::TypeInfo::TypeInfo(v11, v12);
          *(_WORD *)(v11 + 32) = *(_WORD *)(v12 + 32);
          v11 += 80;
          uint64_t v13 = v12 + 40;
          v12 += 80;
        }
        while (v13 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::addEmplace<int>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, _DWORD *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  uint64_t v13 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::addEmplace<int>(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 24);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  isPointerToPolymorphicuint64_t Type = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6) {
    goto LABEL_4;
  }
  if (*(void *)this == *(void *)a6)
  {
    uint64_t v29 = **((void **)this + 2);
    uint64_t v30 = **((void **)a6 + 2);
    if ((unsigned __int16)v29 == (unsigned __int16)v30)
    {
      BOOL v32 = WORD1(v29) == WORD1(v30);
      uint64_t v31 = (v30 ^ v29) & 0xFFFFFF00000000;
      BOOL v32 = v32 && v31 == 0;
      if (v32) {
        goto LABEL_4;
      }
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    int v16 = 0;
    goto LABEL_5;
  }
  if (*((unsigned char *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (unint64_t v33 = re::TypeInfo::name(this), v34 = re::TypeInfo::name(a6), !re::StringID::operator==(v33, v34))))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, this, a6);
    return 0;
  }
  int v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v37);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)v38);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v37);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)v38);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    uint64_t v18 = *(re **)v44[2];
    v42[0] = (re *)v44[0];
    v42[1] = v18;
    if (v44[0]) {
      goto LABEL_8;
    }
    goto LABEL_14;
  }
  re::internal::actualType(a4, (void **)this, v42);
  if (!v42[0])
  {
LABEL_14:
    uint64_t v19 = re::TypeInfo::name(this);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Failed to get actual type of polymorphic object. Type \"%s\".", v20, v21, v22, v23, v24, v19[1]);
    return 0;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v42, &v37);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)v38);
  if ((a7 & 1) != 0 || !*a4)
  {
    LODWORD(v37) = 0;
    uint64_t v25 = (_anonymous_namespace_ *)(a1 + 24);
    int v26 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, a3, (int *)&v37, 0);
    uint64_t result = 0;
    if (v26)
    {
LABEL_16:
      uint64_t v28 = v25;
LABEL_17:
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endPointer(v28);
      return *(unsigned char *)(a1 + 64) == 0;
    }
  }
  else if (*(unsigned char *)(*((void *)this + 2) + 80))
  {
    uint64_t v17 = (unsigned int *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 312, (uint64_t *)a4);
    if (v17)
    {
      unsigned int v40 = *v17;
    }
    else
    {
      unsigned int v40 = *(void *)(a1 + 288);
      unint64_t v37 = *a4;
      re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)v41);
      re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)v43);
      v39[32] = isPointerToPolymorphicType;
      v39[33] = v16;
      re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject>::add((_anonymous_namespace_ *)(a1 + 272), (uint64_t)&v37);
      re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::addNew<int>(a1 + 312, (uint64_t *)a4, &v40);
    }
    LODWORD(v37) = 1;
    uint64_t v25 = (_anonymous_namespace_ *)(a1 + 24);
    uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, a3, (int *)&v37, 0);
    if (result)
    {
      if (!*(unsigned char *)(a1 + 64))
      {
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::writeInteger(a1 + 24, "ID", v40);
        uint64_t v35 = *(void *)(a1 + 152);
        uint64_t v36 = *(void *)(a1 + 136) - 1;
        if (*(unsigned char *)(v35 + 48 * v36) != 2) {
          ++*(void *)(v35 + 48 * v36 + 32);
        }
      }
      goto LABEL_16;
    }
  }
  else
  {
    LODWORD(v37) = 2;
    uint64_t result = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, a3, (int *)&v37, 0);
    if (result)
    {
      if (isPointerToPolymorphicType)
      {
        re::internal::serializePolymorphicObject<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((unsigned char *)a1, a2, a3, (uint64_t)*a4, (re::TypeInfo *)v41, v43, v16);
      }
      else if (!*(unsigned char *)(a1 + 64))
      {
        (*(void (**)(uint64_t, const char *, void, char *, void *, re::TypeRegistry **, void))(*(void *)a1 + 72))(a1, a2, 0, *a4, v44, v43, 0);
      }
      uint64_t v28 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_17;
    }
  }
  return result;
}

re::NetworkOPACKDeserializer *re::NetworkOPACKDeserializer::NetworkOPACKDeserializer(re::NetworkOPACKDeserializer *this)
{
  *(void *)&v4.var0 = 0xDEED4B9BC35C271ALL;
  v4.var1 = "NetworkOPACKDeserializer";
  uint64_t v2 = re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SerializerV2((uint64_t)this, &v4);
  *(void *)uint64_t v2 = &unk_26E6C7210;
  *(_OWORD *)(v2 + 448) = 0u;
  *(_OWORD *)(v2 + 464) = 0u;
  *(void *)(v2 + 200) = v2 + 456;
  re::StringID::destroyString((re::StringID *)&v4);
  *(void *)this = &unk_26E6C7150;
  return this;
}

void re::NetworkOPACKDeserializer::~NetworkOPACKDeserializer(re::NetworkOPACKDeserializer *this)
{
  *(void *)this = &unk_26E6C7278;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)this + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 360);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272);
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::~Serializer((uint64_t)this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6C7278;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)this + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 360);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 272);
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::~Serializer((uint64_t)this);
  JUMPOUT(0x237DBCBD0);
}

void re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::doClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::deserializeSharedObjects(a1, a2, a3, a4, a5, a6, a7, a8, v9);
  re::EncoderOPACK<re::FixedArrayInputStream>::endObject(a1 + 24);
  *(void *)(a1 + 288) = 0;
  ++*(_DWORD *)(a1 + 296);
  re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1 + 312);
  *(void *)(a1 + 376) = 0;
  ++*(_DWORD *)(a1 + 384);
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(a1 + 400);
}

void re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v11 = 6059476;
  signed int v12 = "BOOL";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 6104748;
  signed int v12 = "char";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x172E117BCLL;
  signed int v12 = "int8_t";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93A4A92;
  signed int v12 = "int16_t";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93BFE06;
  signed int v12 = "int32_t";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93EC744;
  signed int v12 = "int64_t";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 6655224;
  signed int v12 = "long";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x31CD534126;
  signed int v12 = "uint8_t";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD0D4E68;
  signed int v12 = "uint16_t";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD0F01DCLL;
  signed int v12 = "uint32_t";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD11CB1ALL;
  signed int v12 = "uint64_t";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x1947BDF6CLL;
  signed int v12 = "size_t";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 195052728;
  signed int v12 = "float";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x161EEF7A2;
  signed int v12 = "double";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 189247272;
  signed int v12 = "char*";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2686EB529B3EE220;
  signed int v12 = "DynamicString";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x458DDB01A18;
  signed int v12 = "StringID";
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderOPACK<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v2 = *(void *)(a1 + 208);
  uint64_t v11 = 0x258C98EAAF29A10ALL;
  signed int v12 = "CallbackSerializerAttribute";
  uint64_t v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    uint64_t v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      uint64_t v5 = *(void *)(a1 + 208);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        uint64_t v6 = a1 + 224;
        unsigned int v7 = (uint64_t *)(v14 + 24);
        uint64_t v8 = 48 * v13;
        do
        {
          uint64_t v9 = *v7;
          v7 += 6;
          int v16 = re::serializeIntrospectionCallbackSerializer<re::EncoderOPACK<re::FixedArrayInputStream>>;
          unint64_t v15 = v9 | 0xFFFFFFFF00000000;
          re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v6, &v15, &v16);
          v8 -= 48;
        }
        while (v8);
      }
      if (v11)
      {
        if (v14) {
          (*(void (**)(void))(*(void *)v11 + 40))();
        }
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::doSerialize(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  if (!a1[107] && a1[34] == 2)
  {
    int v25 = 0;
    uint64_t v22 = a4;
    re::TypeInfo::TypeInfo((uint64_t)&v23, (uint64_t)a5);
    re::TypeInfo::TypeInfo((uint64_t)v24, a6);
    v24[16] = 0;
    re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew((uint64_t)(a1 + 100), &v25, (uint64_t)&v22);
    a3 = 10;
  }
  uint64_t v14 = (uint64_t (*)(_DWORD *, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(_DWORD *, re::TypeInfo *))(*(void *)a1 + 80))(a1, a5);
  if (v14) {
    return v14(a1, a2, a3, a4, a5, a6, a7);
  }
  int v16 = re::TypeInfo::name(a5);
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
  return 0;
}

uint64_t (*re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(unsigned char *a1, const char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v2 = re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::serializePointer;
  if (*(unsigned char *)(a2 + 12) != 9)
  {
    if (*(void *)a2 == *(void *)(a1 + 208))
    {
      LODWORD(v5) = **(void **)(a2 + 16);
      HIDWORD(v5) = -1;
      uint64_t v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 224, &v5);
      uint64_t v2 = re::serializeType<re::EncoderOPACK<re::FixedArrayInputStream>>;
      if (v3) {
        return *(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
      }
    }
    else
    {
      return re::serializeType<re::EncoderOPACK<re::FixedArrayInputStream>>;
    }
  }
  return (uint64_t (*)(unsigned char *, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v2;
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SerializerV2(uint64_t a1, const StringID *a2)
{
  *(void *)a1 = &unk_26E6C72E0;
  re::StringID::StringID((re::StringID *)(a1 + 8), a2);
  re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::Encoder(a1 + 24, 13);
  *(void *)(a1 + 2re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0x7FFFFFFF00000000;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(void *)a1 = &unk_26E6C7278;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 332) = 0u;
  *(void *)(a1 + 348) = 0x7FFFFFFFLL;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0;
  *(_DWORD *)(a1 + 384) = 0;
  *(void *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 420) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 436) = 0x7FFFFFFFLL;
  return a1;
}

uint64_t re::NetworkSerializerBase<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>>::~NetworkSerializerBase(void *a1)
{
  *a1 = &unk_26E6C7278;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(a1 + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 45));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 34));
  return re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::~Serializer((uint64_t)a1);
}

void re::NetworkSerializerBase<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>>::~NetworkSerializerBase(void *a1)
{
  *a1 = &unk_26E6C7278;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(a1 + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 45));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 34));
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::~Serializer((uint64_t)a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::~SerializerV2(void *a1)
{
  *a1 = &unk_26E6C7278;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(a1 + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 45));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 34));
  return re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::~Serializer((uint64_t)a1);
}

void re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::~SerializerV2(void *a1)
{
  *a1 = &unk_26E6C7278;
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit(a1 + 50);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 45));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 39);
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 34));
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::~Serializer((uint64_t)a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::doOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(void *)(a1 + 288) = 0;
  ++*(_DWORD *)(a1 + 296);
  re::HashTable<void *,unsigned int,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(a1 + 312);
  *(void *)(a1 + 376) = 0;
  ++*(_DWORD *)(a1 + 384);
  re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(a1 + 400);
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::beginObject(a1 + 24, "container", 0, 0);
  if ((result & 1) == 0 && !*(unsigned char *)(a1 + 64))
  {
    return re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, "container", "Failed to open container.", v11, v12, v13, v14, v15, a9);
  }
  return result;
}

void re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::~Serializer(a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(void *)a1 + 80))(a1, a5);
  if (v14)
  {
    return v14(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    int v16 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
    return 0;
  }
}

uint64_t (*re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(unsigned char *a1, const char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a2 == *(void *)(a1 + 208)
    && (LODWORD(v4) = **(void **)(a2 + 16),
        HIDWORD(v4) = -1,
        (uint64_t v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 224, &v4)) != 0))
  {
    return *(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderOPACK<re::FixedArrayInputStream>>;
  }
}

uint64_t re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::Encoder(uint64_t result, int a2)
{
  *(void *)(result + 128) = 0;
  *(void *)(result + 104) = 0;
  *(void *)(result + ++*(void *)(this + 112) = 0;
  *(void *)(result + 96) = 0;
  *(_DWORD *)(result + 120) = 0;
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(unsigned char *)(result + 40) = 0;
  *(_DWORD *)(result + 136) = a2;
  *(unsigned char *)(result + 140) = 0;
  *(void *)(result + 152) = 1024;
  uint64_t v2 = &qword_268772000;
  {
    uint64_t v8 = result;
    uint64_t v2 = &qword_268772000;
    int v6 = v4;
    uint64_t result = v8;
    if (v6)
    {
      re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v5, (uint64_t)v9);
      uint64_t v7 = v10;
      if (!v9[0]) {
        uint64_t v7 = 0;
      }
      re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::Encoder(int)::s_maxSerializationDepth = v7;
      uint64_t v2 = &qword_268772000;
      uint64_t result = v8;
    }
  }
  uint64_t v3 = v2[291];
  if (v3) {
    *(void *)(result + 152) = v3;
  }
  return result;
}

uint64_t re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::~Serializer(uint64_t a1)
{
  *(void *)a1 = &unk_26E6C72E0;
  uint64_t v2 = (re::StringID *)(a1 + 8);
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::deinit((void *)a1);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 224));
  re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::~Encoder((unsigned char *)(a1 + 24));
  re::StringID::destroyString(v2);
  return a1;
}

void re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::deinit(void *a1)
{
  if (a1[26])
  {
    (*(void (**)(void *))(*a1 + 40))(a1);
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
    a1[26] = 0;
  }
}

unsigned char *re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::~Encoder(unsigned char *a1)
{
  if (a1[40]) {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 64));
  }
  return a1;
}

_anonymous_namespace_ *re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::close(_anonymous_namespace_ *result)
{
  if (*(void *)result)
  {
    uint64_t v1 = result;
    if (!*((unsigned char *)result + 40)) {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 0);
    }
    uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::deinit((uint64_t)v1 + 96);
    if (*((int *)v1 + 4) >= 1)
    {
      uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)v1 + 24))();
      *((void *)v1 + 1) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *(void *)uint64_t v1 = 0;
    *((void *)v1 + 3) = 0;
    *((void *)v1 + 4) = 0;
  }
  return result;
}

uint64_t re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v24 = 0;
  int v25 = 0;
  uint64_t v26 = 0;
  re::DynamicString::setCapacity(&v23, 0);
  uint64_t v22 = &a9;
  re::DynamicString::vassignf((re::DynamicString *)&v23, a3, &a9);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)(a1 + 24), a2, (re::DynamicString *)&v15);
  if (v16) {
    uint64_t v12 = *(unsigned char **)&v17[7];
  }
  else {
    uint64_t v12 = v17;
  }
  if (v24) {
    uint64_t v13 = v25;
  }
  else {
    uint64_t v13 = (char *)&v24 + 1;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: %s", (re::DynamicString *)&v18, "deserialize", v12, v13);
  *(void *)&v21[0] = 400;
  *((void *)&v21[0] + 1) = re::FoundationErrorCategory(void)::instance;
  *(void *)&v21[1] = v18;
  *((void *)&v21[2] + 1) = v20;
  *(long long *)((char *)&v21[1] + 8) = v19;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1 + 24, v21);
  if (*(void *)&v21[1])
  {
    if (BYTE8(v21[1])) {
      (*(void (**)(void))(**(void **)&v21[1] + 40))();
    }
    memset(&v21[1], 0, 32);
  }
  if (v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t result = (uint64_t)v23;
  if (v23)
  {
    if (v24) {
      return (*(uint64_t (**)(void))(*v23 + 40))();
    }
  }
  return result;
}

uint64_t re::serializeType<re::EncoderOPACK<re::FixedArrayInputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (this == (re::TypeInfo *)a6) {
    goto LABEL_19;
  }
  if (*(void *)this != *(void *)a6)
  {
    if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, a3)) {
      goto LABEL_19;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      uint64_t v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
      if (v19) {
        int v20 = *(_DWORD *)(v19 + 16);
      }
      else {
        int v20 = -1;
      }
      uint64_t v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
      if (v21) {
        int v22 = *(_DWORD *)(v21 + 16);
      }
      else {
        int v22 = -1;
      }
      if (v20 == v22) {
        goto LABEL_19;
      }
      uint64_t v24 = re::TypeInfo::name(this);
      int v25 = re::TypeInfo::name((re::TypeInfo *)a6);
      if (re::StringID::operator==(v24, v25))
      {
        uint64_t v26 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
        if (v26) {
          int v27 = *(_DWORD *)(v26 + 16);
        }
        else {
          int v27 = -1;
        }
        re::TypeInfo::atVersion(this, v27, v58);
        if (v58[0])
        {
          if (a7) {
            Instance = 0;
          }
          else {
            Instance = re::TypeInfo::createInstance((re::TypeInfo *)v59, *((re::Allocator **)a1 + 6), *((void **)a1 + 25));
          }
          if (a1[64]
            || ((*(void (**)(unsigned char *, const char *, const re::TypeInfo *, void **, unsigned char *, uint64_t, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, Instance, v59, a6, a7), a1[64]))
          {
            if (Instance) {
              re::TypeInfo::releaseInstance((re::TypeInfo *)v59, Instance, *((re::Allocator **)a1 + 6), *((void **)a1 + 25));
            }
          }
          else
          {
            if (a7) {
              return 1;
            }
            re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v59);
            re::internal::upgradeObject(Instance, v53, a4, (uint64_t **)this, *((re::Allocator **)a1 + 6), *((void **)a1 + 25), v54);
            if (v54[0]) {
              return 1;
            }
            if (v56) {
              LOBYTE(v51) = v57[7];
            }
            else {
              uint64_t v51 = v57;
            }
            re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "%s", v46, v47, v48, v49, v50, (char)v51);
            if (!v54[0] && v55 && (v56 & 1) != 0) {
              (*(void (**)(void))(*(void *)v55 + 40))();
            }
          }
        }
        else
        {
          uint64_t v35 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
          re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Unknown serialized type \"%s\" version %u. No matching runtime type found.", v41, v42, v43, v44, v45, v35);
        }
      }
      else
      {
        uint64_t v33 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
        re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
        re::TypeInfo::name(this);
        re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Type name changed: Serialized type \"%s\" version %u, runtime type \"%s\" version %u.", v36, v37, v38, v39, v40, v33);
      }
    }
    else
    {
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, this, (re::TypeInfo *)a6);
    }
    return 0;
  }
  uint64_t v15 = **((void **)this + 2);
  uint64_t v16 = **(void **)(a6 + 16);
  if ((unsigned __int16)v15 != (unsigned __int16)v16) {
    goto LABEL_10;
  }
  BOOL v18 = WORD1(v15) == WORD1(v16);
  uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
  BOOL v18 = v18 && v17 == 0;
  if (!v18) {
    goto LABEL_10;
  }
LABEL_19:
  switch(*((unsigned char *)this + 12))
  {
    case 1:
      uint64_t result = re::serializeBasic<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 2:
      uint64_t result = re::serializeEnum<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, a4, (uint64_t)this, a6, a7);
      break;
    case 3:
      uint64_t result = re::serializeOptional<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 4:
      uint64_t result = re::serializeArray<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 5:
      uint64_t result = re::serializeList<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 6:
      uint64_t result = re::serializeDictionary<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 7:
      uint64_t result = re::serializeUnion<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (char *)a4, this, (re::TypeInfo *)a6, a7);
      break;
    case 8:
      uint64_t result = re::serializeObject<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)a4, this, a6, a7);
      break;
    case 9:
      uint64_t v52 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Pointer type (\"%s\") needs to be handled explicitly by the serializer.", v28, v29, v30, v31, v32, v52);
      return 0;
    default:
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Invalid type category. Value = %d", (uint64_t)a4, (uint64_t)this, a6, a7, a8, *((unsigned char *)this + 12));
      return 0;
  }
  return result;
}

uint64_t re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, re::TypeInfo *this, re::TypeInfo *a4)
{
  uint64_t v7 = re::TypeInfo::name(this)[1];
  re::TypeInfo::name(a4);
  return re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Type mismatch. Runtime type \"%s\" and serialized type \"%s\" are different.", v8, v9, v10, v11, v12, v7);
}

uint64_t re::serializeBasic<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  int v10 = (int)a3;
  if (this != a6)
  {
    if (*(void *)this != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3)) {
        goto LABEL_4;
      }
LABEL_21:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, this, a6);
      return 0;
    }
    uint64_t v18 = **((void **)this + 2);
    uint64_t v19 = **((void **)a6 + 2);
    if ((unsigned __int16)v18 != (unsigned __int16)v19) {
      goto LABEL_21;
    }
    BOOL v21 = WORD1(v18) == WORD1(v19);
    uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
    BOOL v21 = v21 && v20 == 0;
    if (!v21) {
      goto LABEL_21;
    }
  }
LABEL_4:
  uint64_t v14 = re::TypeInfo::name(this);
  unint64_t v15 = (unint64_t)*v14 >> 1;
  if (v15 > 0xCA3DEFB5)
  {
    if ((unint64_t)*v14 >> 1 > 0x18E6A9A092)
    {
      if ((unint64_t)*v14 >> 1 <= 0x303EE8780EDLL)
      {
        if (v15 == 0x18E6A9A093)
        {
          return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v10, a4, a7);
        }
        else
        {
          if (v15 != 0x303EE86A734) {
            goto LABEL_69;
          }
          return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v10, (__int16 *)a4, a7);
        }
      }
      if (v15 == 0x303EE8780EELL)
      {
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v10, (int *)a4, a7);
      }
      if (v15 != 0x303EE88E58DLL) {
        goto LABEL_69;
      }
    }
    else
    {
      if ((unint64_t)*v14 >> 1 > 0x16749DFF02)
      {
        if (v15 == 0x16749DFF03)
        {
LABEL_54:
          return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v10, (int *)a4, a7);
        }
        uint64_t v22 = 0x16749F63A2;
LABEL_40:
        if (v15 == v22)
        {
          return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v10, a4, a7);
        }
LABEL_69:
        uint64_t v23 = re::TypeInfo::name(this);
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Unsupported basic type \"%s\".", v24, v25, v26, v27, v28, v23[1]);
        return 0;
      }
      if (v15 != 3393056694)
      {
        uint64_t v17 = 0x16749D2549;
LABEL_26:
        if (v15 != v17) {
          goto LABEL_69;
        }
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<short>(a1 + 24, a2, v10, (__int16 *)a4, a7);
      }
    }
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v10, a4, a7);
  }
  if ((unint64_t)*v14 >> 1 <= 0x5D0225B)
  {
    if ((unint64_t)*v14 >> 1 <= 0x2E9355)
    {
      if (v15 != 104431)
      {
        if (v15 == 3029738)
        {
          return re::EncoderOPACK<re::FixedArrayInputStream>::serializeBool(a1 + 24, a2, v10, a4, a7);
        }
        goto LABEL_69;
      }
      goto LABEL_54;
    }
    if (v15 != 3052374)
    {
      uint64_t v22 = 3327612;
      goto LABEL_40;
    }
    goto LABEL_46;
  }
  if ((unint64_t)*v14 >> 1 <= 0xB0F77BD0)
  {
    if (v15 == 97526364)
    {
      return re::EncoderOPACK<re::FixedArrayInputStream>::serializeFloat(a1 + 24, a2, v10, a4, a7);
    }
    uint64_t v17 = 109413500;
    goto LABEL_26;
  }
  if (v15 != 2969009105)
  {
    if (v15 != 3111160798) {
      goto LABEL_69;
    }
LABEL_46:
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v10, a4, a7);
  }
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeDouble(a1 + 24, a2, v10, a4, a7);
}

uint64_t re::serializeEnum<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **(void **)(a5 + 16);
      uint64_t v15 = **(void **)(a6 + 16);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_12;
        }
      }
    }
    else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
    {
      goto LABEL_12;
    }
    if (*(unsigned __int8 *)(a5 + 12) != *(unsigned __int8 *)(a6 + 12)
      || (uint64_t v18 = re::TypeInfo::name((re::TypeInfo *)a5),
          uint64_t v19 = re::TypeInfo::name((re::TypeInfo *)a6),
          !re::StringID::operator==(v18, v19)))
    {
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
      return 0;
    }
  }
LABEL_12:
  return re::internal::serializeEnumAsBinary<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
}

BOOL re::serializeOptional<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11 = (int)a3;
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v25[0] = 0;
    re::EncoderOPACK<re::FixedArrayInputStream>::beginOptional(a1 + 24, a2, v11, v25, 0);
    if (v25[0])
    {
      uint64_t v18 = *(re::internal **)(a1 + 208);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v27);
      re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
      re::internal::translateType(v18, (const re::TypeRegistry *)v26, (uint64_t)v27);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, 0, 0, v27, v27, 1);
      }
    }
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)&v28);
    re::TypeInfo::TypeInfo((uint64_t)v27, (uint64_t)a5);
    BOOL v24 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4) != 0;
    double v20 = re::EncoderOPACK<re::FixedArrayInputStream>::beginOptional(a1 + 24, a2, v11, &v24, 0);
    if (v24)
    {
      Instance = re::TypeInfo::createInstance((re::TypeInfo *)v26, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
      (*(void (**)(uint64_t, void **))(v29 + 88))(a4, Instance);
      re::TypeInfo::releaseInstance((re::TypeInfo *)v26, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
    }
    else
    {
      (*(void (**)(uint64_t, void, double))(v29 + 88))(a4, 0, v20);
    }
    if (v24)
    {
      uint64_t v23 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, uint64_t, unsigned char *, unsigned char *, void))(*(void *)a1 + 72))(a1, a2, 0, v23, v26, v25, 0);
      }
    }
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderOPACK<re::FixedArrayInputStream>::endOptional(v19);
  return *(unsigned char *)(a1 + 64) == 0;
}

uint64_t re::serializeArray<re::EncoderOPACK<re::FixedArrayInputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11 = (int)a3;
  if (a5 == a6) {
    goto LABEL_13;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned char *)a6 + 12) != 4) {
    goto LABEL_71;
  }
  uint64_t v18 = (void *)*((void *)a5 + 2);
  uint64_t v19 = (void *)*((void *)a6 + 2);
  int v20 = *((_DWORD *)v19 + 21) & 0xFFFFFF;
  if ((*((_DWORD *)v18 + 21) & 0xFFFFFF) != 0)
  {
    if (v20) {
      goto LABEL_13;
    }
LABEL_71:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, a5, a6);
    return 0;
  }
  if (v20 || *((_DWORD *)v18 + 22) != *((_DWORD *)v19 + 22)) {
    goto LABEL_71;
  }
LABEL_13:
  if (a7)
  {
    BOOL v21 = (re::internal *)*((void *)a1 + 26);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v72);
    re::TypeInfo::TypeInfo((uint64_t)v68, (uint64_t)v73);
    re::internal::translateType(v21, (const re::TypeRegistry *)v68, (uint64_t)v69);
    uint64_t v22 = (*(uint64_t (**)(unsigned char *, unsigned char *))(*(void *)a1 + 80))(a1, v69);
    if (v22)
    {
      uint64_t v23 = (void (*)(unsigned char *, void, void, void, unsigned char *, unsigned char *, uint64_t))v22;
      BOOL v24 = (void *)*((void *)a6 + 2);
      int v25 = *((_DWORD *)v24 + 21) & 0xFFFFFF;
      if (v25) {
        unint64_t v26 = 0;
      }
      else {
        unint64_t v26 = *((int *)v24 + 22);
      }
      unint64_t v72 = v26;
      if (v70 == 1)
      {
        v68[0] = v26 * *(unsigned int *)(v71 + 8);
        int v58 = re::EncoderOPACK<re::FixedArrayInputStream>::beginBLOB((uint64_t)(a1 + 24), a2, v11, v68, 0);
        uint64_t result = 0;
        if (!v58) {
          return result;
        }
        if (v68[0]) {
          re::EncoderOPACK<re::FixedArrayInputStream>::serializeBLOB((uint64_t)(a1 + 24), 0, 1);
        }
        uint64_t v39 = (_anonymous_namespace_ *)(a1 + 24);
        goto LABEL_49;
      }
      if (v25) {
        int v59 = 8;
      }
      else {
        int v59 = 4;
      }
      uint64_t v48 = (_anonymous_namespace_ *)(a1 + 24);
      uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::beginArray((uint64_t)(a1 + 24), a2, v11, (char *)&v72, v59);
      if (result)
      {
        unint64_t v60 = v72;
        if (v25) {
          BOOL v61 = v72 == 0;
        }
        else {
          BOOL v61 = 1;
        }
        char v62 = v61;
        if (!v61)
        {
          v67[0] = 0;
          v67[1] = 0xFFFFFFFFLL;
          (*(void (**)(unsigned char *, void, void *))(*(void *)a1 + 16))(a1, 0, v67);
          unint64_t v60 = v72;
        }
        if (v60)
        {
          unint64_t v63 = 0;
          do
          {
            v23(a1, 0, 0, 0, v69, v69, 1);
            ++v63;
          }
          while (v63 < v72);
        }
        if (v62) {
          goto LABEL_67;
        }
        goto LABEL_66;
      }
      return result;
    }
    goto LABEL_24;
  }
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v72);
  re::TypeInfo::TypeInfo((uint64_t)v69, (uint64_t)v73);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v72);
  re::TypeInfo::TypeInfo((uint64_t)v68, (uint64_t)v73);
  re::TypeInfo::TypeInfo((uint64_t)&v72, (uint64_t)a5);
  uint64_t v27 = (*(uint64_t (**)(unsigned char *, unsigned char *))(*(void *)a1 + 80))(a1, v69);
  if (!v27)
  {
LABEL_24:
    uint64_t v40 = re::TypeInfo::name((re::TypeInfo *)v69);
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v41, v42, v43, v44, v45, v40[1]);
    return 0;
  }
  uint64_t v28 = (void (*)(unsigned char *, void, void, uint64_t, unsigned char *, uint64_t *, void))v27;
  uint64_t v29 = re::ArrayAccessor::size((re::ArrayAccessor *)&v72, a4);
  uint64_t v30 = v29;
  unint64_t v66 = (const re::TypeInfo *)v29;
  if (v70 == 1)
  {
    unint64_t v65 = v29 * *(unsigned int *)(v71 + 8);
    int v34 = re::EncoderOPACK<re::FixedArrayInputStream>::beginBLOB((uint64_t)(a1 + 24), a2, v11, (uint64_t *)&v65, 0);
    uint64_t result = 0;
    if (v34)
    {
      unint64_t v36 = v65;
      unint64_t v37 = *(unsigned int *)(v71 + 8);
      if (result)
      {
        if (v36 >= v37)
        {
          uint64_t v38 = (char *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v72, a4, 0);
          re::EncoderOPACK<re::FixedArrayInputStream>::serializeBLOB((uint64_t)(a1 + 24), v38, 0);
        }
        uint64_t v39 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_49:
        re::EncoderOPACK<re::FixedArrayInputStream>::endBLOB(v39);
        return a1[64] == 0;
      }
    }
  }
  else
  {
    int v46 = *(_DWORD *)(*((void *)a5 + 2) + 84) & 0xFFFFFF;
    if (v46) {
      int v47 = 8;
    }
    else {
      int v47 = 4;
    }
    uint64_t v48 = (_anonymous_namespace_ *)(a1 + 24);
    uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::beginArray((uint64_t)(a1 + 24), a2, v11, (char *)&v66, v47);
    if (result)
    {
      if (result)
      {
        uint64_t v52 = v66;
        if (v46) {
          BOOL v53 = v66 == 0;
        }
        else {
          BOOL v53 = 1;
        }
        char v54 = v53;
        if (!v53)
        {
          uint64_t v55 = *(void *)a4;
          v64[0] = 0;
          v64[1] = 0xFFFFFFFFLL;
          (*(void (**)(unsigned char *, uint64_t, void *))(*(void *)a1 + 16))(a1, v55, v64);
          uint64_t v52 = v66;
        }
        if (v52)
        {
          unint64_t v56 = 0;
          do
          {
            uint64_t v57 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v72, a4, v56);
            v28(a1, 0, 0, v57, v69, v68, 0);
            ++v56;
          }
          while (v56 < (unint64_t)v66);
        }
        if (v54) {
          goto LABEL_67;
        }
LABEL_66:
        (*(void (**)(unsigned char *))(*(void *)a1 + 24))(a1);
LABEL_67:
        re::EncoderOPACK<re::FixedArrayInputStream>::endArray(v48);
        return a1[64] == 0;
      }
    }
  }
  return result;
}

uint64_t re::serializeList<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11 = (int)a3;
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    uint64_t v18 = *(re::internal **)(a1 + 208);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v65);
    re::TypeInfo::TypeInfo((uint64_t)v61, (uint64_t)&v66);
    re::internal::translateType(v18, (const re::TypeRegistry *)v61, (uint64_t)v62);
    uint64_t v19 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v62);
    if (v19)
    {
      unint64_t v65 = 0;
      if (v63 == 1)
      {
        v61[0] = 0;
        int v20 = re::EncoderOPACK<re::FixedArrayInputStream>::beginBLOB(a1 + 24, a2, v11, v61, 0);
        uint64_t result = 0;
        if (!v20) {
          return result;
        }
        if (v61[0]) {
          re::EncoderOPACK<re::FixedArrayInputStream>::serializeBLOB(a1 + 24, 0, 1);
        }
        uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_18:
        re::EncoderOPACK<re::FixedArrayInputStream>::endBLOB(v22);
        return *(unsigned char *)(a1 + 64) == 0;
      }
      uint64_t v45 = (void (*)(uint64_t, void, void, void, unsigned char *, unsigned char *, uint64_t))v19;
      int v46 = re::EncoderOPACK<re::FixedArrayInputStream>::beginArray(a1 + 24, a2, v11, (char *)&v65, 0);
      uint64_t result = 0;
      if (!v46) {
        return result;
      }
      if (v65)
      {
        for (unint64_t i = 0; i < v65; ++i)
          v45(a1, 0, 0, 0, v62, v62, 1);
      }
      uint64_t v44 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_45:
      re::EncoderOPACK<re::FixedArrayInputStream>::endArray(v44);
      return *(unsigned char *)(a1 + 64) == 0;
    }
    goto LABEL_29;
  }
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v65);
  re::TypeInfo::TypeInfo((uint64_t)v62, (uint64_t)&v66);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v65);
  re::TypeInfo::TypeInfo((uint64_t)v61, (uint64_t)&v66);
  re::TypeInfo::TypeInfo((uint64_t)&v65, (uint64_t)a5);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v62);
  if (!v23)
  {
LABEL_29:
    uint64_t v57 = re::TypeInfo::name((re::TypeInfo *)v62)[1];
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v36, v37, v38, v39, v40, v57);
    return 0;
  }
  BOOL v24 = (void (*)(uint64_t, void, void, uint64_t, unsigned char *, uint64_t *, void))v23;
  uint64_t v25 = (*(uint64_t (**)(uint64_t))(v67 + 80))(a4);
  uint64_t v26 = v25;
  unint64_t v60 = v25;
  if (*((unsigned char *)a5 + 12) == 5 && (*(unsigned char *)(*((void *)a5 + 2) + 48) & 8) != 0 && v63 == 1)
  {
    v59[0] = v25 * *(unsigned int *)(v64 + 8);
    int v31 = re::EncoderOPACK<re::FixedArrayInputStream>::beginBLOB(a1 + 24, a2, v11, v59, 0);
    uint64_t result = 0;
    if (!v31) {
      return result;
    }
    unint64_t v32 = v59[0];
    unint64_t v33 = *(unsigned int *)(v64 + 8);
    uint64_t v34 = v59[0] / v33;
    if (v59[0] / v33 * v33 == v59[0])
    {
      if (!result) {
        return result;
      }
      if (v32 >= v33)
      {
        uint64_t v35 = (char *)(*(uint64_t (**)(uint64_t, void))(v67 + 96))(a4, 0);
        re::EncoderOPACK<re::FixedArrayInputStream>::serializeBLOB(a1 + 24, v35, 0);
      }
      uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_18;
    }
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setError((_anonymous_namespace_ *)(a1 + 24), a2, "BLOB size mismatch: BLOB is %zu bytes, but list only accomodates %zu bytes (%zu elements * %zu bytes/element)", v27, v34, v28, v29, v30, v59[0]);
    return 0;
  }
  int v41 = re::EncoderOPACK<re::FixedArrayInputStream>::beginArray(a1 + 24, a2, v11, (char *)&v60, 0);
  uint64_t result = 0;
  if (v41)
  {
    if (result)
    {
      if (*(void *)(v67 + 96))
      {
        if (v60)
        {
          for (unint64_t j = 0; j < v60; ++j)
          {
            uint64_t v43 = (*(uint64_t (**)(uint64_t, unint64_t))(v67 + 96))(a4, j);
            v24(a1, 0, 0, v43, v62, v61, 0);
          }
        }
      }
      else
      {
        uint64_t v48 = *(uint64_t (**)(uint64_t, void))(v67 + 104);
        if (!v48 || !*(void *)(v67 + 112) || !*(void *)(v67 + 120))
        {
          re::TypeInfo::TypeInfo((uint64_t)v59, (uint64_t)&v65);
          uint64_t v58 = re::TypeInfo::name((re::TypeInfo *)v59)[1];
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "List type \"%s\" does not provide an indexer or iterator.", v52, v53, v54, v55, v56, v58);
          return 0;
        }
        uint64_t v49 = v48(a4, *(void *)(a1 + 56));
        uint64_t v50 = (*(uint64_t (**)(void))(v67 + 112))();
        if (v50)
        {
          uint64_t v51 = v50;
          do
          {
            v24(a1, 0, 0, v51, v62, v61, 0);
            uint64_t v51 = (*(uint64_t (**)(uint64_t))(v67 + 112))(v49);
          }
          while (v51);
        }
        (*(void (**)(uint64_t, void))(v67 + 120))(v49, *(void *)(a1 + 56));
      }
      uint64_t v44 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_45;
    }
  }
  return result;
}

BOOL re::serializeDictionary<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v11 = (int)a3;
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v51, (uint64_t)v56);
    re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)a5);
    uint64_t v29 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v54);
    if (v29)
    {
      uint64_t v30 = (void (*)(uint64_t, const char *, void, void **, unsigned char *, unsigned char *, void, double))v29;
      uint64_t v31 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v53);
      if (v31)
      {
        unint64_t v32 = (void (*)(uint64_t, const char *, void, uint64_t, unsigned char *, unsigned char *, void))v31;
        unint64_t v48 = (*(uint64_t (**)(uint64_t))(v50 + 88))(a4);
        BOOL v24 = (_anonymous_namespace_ *)(a1 + 24);
        int v33 = re::EncoderOPACK<re::FixedArrayInputStream>::beginDictionary(a1 + 24, a2, v11, (char *)&v48, 0);
        BOOL result = 0;
        if (!v33) {
          return result;
        }
        uint64_t v34 = *(void *)(a1 + 48);
        uint64_t v35 = *(void (**)(uint64_t, unint64_t *, uint64_t))(v50 + 96);
        re::TypeInfo::TypeInfo((uint64_t)&v55, (uint64_t)v49);
        v35(a4, &v55, v34);
        if (v48)
        {
          Instance = re::TypeInfo::createInstance((re::TypeInfo *)v54, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
          if (v48)
          {
            uint64_t v37 = 0;
            while (1)
            {
              double v38 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
              v30(a1, "key", 0, Instance, v54, v52, 0, v38);
              uint64_t v39 = *(re::Allocator **)(a1 + 48);
              if (*(unsigned char *)(a1 + 64)) {
                break;
              }
              uint64_t v40 = (*(uint64_t (**)(uint64_t, unsigned char *, re::Allocator *, void **))(v50 + 104))(a4, v49, v39, Instance);
              v32(a1, "value", 0, v40, v53, v51, 0);
              re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
              if (++v37 >= v48) {
                goto LABEL_27;
              }
            }
            re::TypeInfo::releaseInstance((re::TypeInfo *)v54, Instance, v39, *(void **)(a1 + 200));
            return 0;
          }
LABEL_27:
          re::TypeInfo::releaseInstance((re::TypeInfo *)v54, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
        }
LABEL_28:
        re::EncoderOPACK<re::FixedArrayInputStream>::endDictionary(v24);
        return *(unsigned char *)(a1 + 64) == 0;
      }
      goto LABEL_31;
    }
LABEL_29:
    int v41 = (re::TypeInfo *)v54;
LABEL_32:
    uint64_t v42 = re::TypeInfo::name(v41);
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v43, v44, v45, v46, v47, v42[1]);
    return 0;
  }
  uint64_t v18 = *(re::internal **)(a1 + 208);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
  re::internal::translateType(v18, (const re::TypeRegistry *)v53, (uint64_t)v54);
  uint64_t v19 = *(re::internal **)(a1 + 208);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
  re::internal::translateType(v19, (const re::TypeRegistry *)v52, (uint64_t)v53);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v54);
  if (!v20) {
    goto LABEL_29;
  }
  BOOL v21 = (void (*)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t, double))v20;
  uint64_t v22 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v53);
  if (!v22)
  {
LABEL_31:
    int v41 = (re::TypeInfo *)v53;
    goto LABEL_32;
  }
  uint64_t v23 = (void (*)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t))v22;
  unint64_t v55 = 0;
  BOOL v24 = (_anonymous_namespace_ *)(a1 + 24);
  int v25 = re::EncoderOPACK<re::FixedArrayInputStream>::beginDictionary(a1 + 24, a2, v11, (char *)&v55, 0);
  BOOL result = 0;
  if (v25)
  {
    if (v55)
    {
      for (unint64_t i = 0; i < v55; ++i)
      {
        double v28 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 1);
        v21(a1, "key", 0, 0, v54, v54, 1, v28);
        v23(a1, "value", 0, 0, v53, v53, 1);
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    goto LABEL_28;
  }
  return result;
}

uint64_t re::serializeUnion<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  int v11 = (int)a3;
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v15 = **((void **)a5 + 2);
    uint64_t v16 = **((void **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      BOOL v18 = WORD1(v15) == WORD1(v16);
      uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      BOOL v18 = v18 && v17 == 0;
      if (v18) {
        goto LABEL_4;
      }
    }
LABEL_19:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_19;
  }
LABEL_4:
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::beginObject(a1 + 24, a2, v11, 16);
  if (a7)
  {
    if (!result) {
      return result;
    }
    v19[0] = 0;
    re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, "tag", 0, (char *)v19, 0);
    if (v19[0] < *(unsigned int *)(*((void *)a6 + 2) + 88))
    {
      re::TypeInfo::unionMember(a6, v19[0], (uint64_t)v21);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, "value", 0, 0, v21, v21, 1);
      }
    }
  }
  else
  {
    if (!result) {
      return result;
    }
    re::TypeInfo::TypeInfo((uint64_t)v21, (uint64_t)a5);
    unint64_t Tag = re::UnionAccessor::readTag((re::UnionAccessor *)v21, a4);
    re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, "tag", 0, (char *)&Tag, 0);
    re::UnionAccessor::reset((re::UnionAccessor *)v21, a4, (const re::TypeInfo *)Tag, *(re::Allocator **)(a1 + 48));
    if (Tag < *(unsigned int *)(*((void *)a5 + 2) + 88))
    {
      re::TypeInfo::unionMember(a5, Tag, (uint64_t)v19);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, char *, unint64_t *, unint64_t *, void))(*(void *)a1 + 72))(a1, "value", 0, a4, v19, v19, 0);
      }
    }
  }
  re::EncoderOPACK<re::FixedArrayInputStream>::endObject(a1 + 24);
  return *(unsigned char *)(a1 + 64) == 0;
}

uint64_t re::serializeObject<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  if (a7)
  {
    if (*(unsigned char *)(*((void *)this + 2) + 49))
    {
      uint64_t v19 = *(re::TypeRegistry **)(a1 + 208);
      v35[0] = 0x2686EB529B3EE220;
      v35[1] = "DynamicString";
      re::TypeRegistry::typeInfo(v19, (const re::StringID *)v35, v36);
      re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v37);
      re::StringID::destroyString((re::StringID *)v35);
      uint64_t v20 = (re *)v38;
      BOOL v21 = (const re::TypeInfo *)v38;
      uint64_t v22 = a1;
      uint64_t v23 = a2;
      BOOL v24 = (const re::TypeInfo *)a3;
    }
    else
    {
      uint64_t v14 = re::TypeInfo::name(this);
      if ((unint64_t)*v14 >> 1 != 0x134375A94D9F7110) {
        goto LABEL_6;
      }
      uint64_t v15 = (const char *)v14[1];
      if (v15 != "DynamicString")
      {
        if (strcmp(v15, "DynamicString")) {
          goto LABEL_6;
        }
      }
      uint64_t v22 = a1;
      uint64_t v23 = a2;
      BOOL v24 = (const re::TypeInfo *)a3;
      uint64_t v20 = this;
      BOOL v21 = this;
    }
    re::serializeDynamicString<re::EncoderOPACK<re::FixedArrayInputStream>>(v22, v23, v24, 0, v20, v21, 1);
    return *(unsigned char *)(a1 + 64) == 0;
  }
LABEL_6:
  if ((*(unsigned char *)(*((void *)this + 2) + 48) & 4) == 0)
  {
    int v17 = re::EncoderOPACK<re::FixedArrayInputStream>::beginObject(a1 + 24, a2, a3, 0);
    uint64_t result = 0;
    if (!v17) {
      return result;
    }
    if (this == (re::TypeInfo *)a6) {
      goto LABEL_11;
    }
    if (*(void *)this == *(void *)a6)
    {
      uint64_t v25 = **((void **)this + 2);
      uint64_t v26 = **(void **)(a6 + 16);
      if ((unsigned __int16)v25 == (unsigned __int16)v26)
      {
        BOOL v28 = WORD1(v25) == WORD1(v26);
        uint64_t v27 = (v26 ^ v25) & 0xFFFFFF00000000;
        BOOL v28 = v28 && v27 == 0;
        if (v28) {
          goto LABEL_11;
        }
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v16))
    {
LABEL_11:
      re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>((unsigned char *)a1, a4, (uint64_t *)this, a7);
LABEL_26:
      re::EncoderOPACK<re::FixedArrayInputStream>::endObject(a1 + 24);
      return *(unsigned char *)(a1 + 64) == 0;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    }
    else
    {
      uint64_t v29 = re::TypeInfo::name(this)[1];
      re::TypeInfo::name((re::TypeInfo *)a6);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v30, v31, v32, v33, v34, v29);
    }
    goto LABEL_26;
  }
  return re::internal::serializeObjectWithOneMember<re::EncoderOPACK<re::FixedArrayInputStream>>((unsigned char *)a1, a2, a3, a4, (uint64_t *)this, (uint64_t *)a6, a7);
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeBool(uint64_t a1, const char *a2, int a3, unsigned char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v18, 0);
  if (result)
  {
    unsigned __int8 __dst = 0;
    if (*(unsigned char *)(a1 + 40))
    {
LABEL_5:
      for (uint64_t i = v18; i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
      uint64_t result = 1;
      if ((a5 & 2) == 0)
      {
        uint64_t v11 = *(void *)(a1 + 128);
        uint64_t v12 = *(void *)(a1 + 112) - 1;
        if (*(unsigned char *)(v11 + 48 * v12) != 2) {
          ++*(void *)(v11 + 48 * v12 + 32);
        }
      }
      return result;
    }
    uint64_t v13 = *(void *)(a1 + 168);
    if (v13)
    {
      uint64_t v14 = v13 - 1;
      int v15 = *(unsigned __int8 *)(a1 + v14 + 160);
      unsigned __int8 __dst = *(unsigned char *)(a1 + v14 + 160);
      *(void *)(a1 + 168) = v14;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Boolean");
        goto LABEL_5;
      }
      int v15 = __dst;
    }
    if (v15 == 2)
    {
      if ((a5 & 1) == 0) {
        *a4 = 0;
      }
    }
    else
    {
      if (v15 != 1)
      {
        uint64_t v16 = re::OPACK::toString(v15);
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, (uint64_t)"Boolean", (uint64_t)v16);
        return 0;
      }
      if ((a5 & 1) == 0) {
        *a4 = 1;
      }
    }
    goto LABEL_5;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeFloat(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v25 = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v25, 0);
  if (result)
  {
    unsigned __int8 __dst = 0;
    if (*(unsigned char *)(a1 + 40)) {
      goto LABEL_5;
    }
    uint64_t v13 = *(void *)(a1 + 168);
    if (v13)
    {
      uint64_t v14 = v13 - 1;
      int v15 = *(unsigned __int8 *)(a1 + v14 + 160);
      unsigned __int8 __dst = *(unsigned char *)(a1 + v14 + 160);
      *(void *)(a1 + 168) = v14;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL))goto LABEL_31; {
      int v15 = __dst;
      }
    }
    if (v15 != 53)
    {
      uint64_t v22 = re::OPACK::toString(v15);
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, (uint64_t)"Float", (uint64_t)v22);
      return 0;
    }
    if (*(unsigned char *)(a1 + 40)) {
      goto LABEL_5;
    }
    unint64_t v16 = *(void *)(a1 + 168);
    if (v16)
    {
      uint64_t v17 = 4;
      if (v16 < 4) {
        uint64_t v17 = *(void *)(a1 + 168);
      }
      int64_t v18 = v16 - v17;
      if ((uint64_t)(v16 - 1) >= (uint64_t)(v16 - v17))
      {
        uint64_t v19 = *(void *)(a1 + 168);
        do
        {
          *a4++ = *(unsigned char *)(a1 + 159 + v19);
          int64_t v20 = v19 - 2;
          --v19;
        }
        while (v20 >= v18);
      }
      *(void *)(a1 + 168) = v18;
      if (v16 > 3) {
        goto LABEL_5;
      }
      size_t v21 = 4 - v17;
    }
    else
    {
      size_t v21 = 4;
    }
    if (a5) {
      uint64_t v23 = 0;
    }
    else {
      uint64_t v23 = a4;
    }
    if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v23, v21))
    {
LABEL_5:
      for (uint64_t i = v25; i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
      uint64_t result = 1;
      if ((a5 & 2) == 0)
      {
        uint64_t v11 = *(void *)(a1 + 128);
        uint64_t v12 = *(void *)(a1 + 112) - 1;
        if (*(unsigned char *)(v11 + 48 * v12) != 2) {
          ++*(void *)(v11 + 48 * v12 + 32);
        }
      }
      return result;
    }
LABEL_31:
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Float");
    goto LABEL_5;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeDouble(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v25 = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v25, 0);
  if (result)
  {
    unsigned __int8 __dst = 0;
    if (*(unsigned char *)(a1 + 40)) {
      goto LABEL_5;
    }
    uint64_t v13 = *(void *)(a1 + 168);
    if (v13)
    {
      uint64_t v14 = v13 - 1;
      int v15 = *(unsigned __int8 *)(a1 + v14 + 160);
      unsigned __int8 __dst = *(unsigned char *)(a1 + v14 + 160);
      *(void *)(a1 + 168) = v14;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL))goto LABEL_31; {
      int v15 = __dst;
      }
    }
    if (v15 != 54)
    {
      uint64_t v22 = re::OPACK::toString(v15);
      re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, (uint64_t)"Double", (uint64_t)v22);
      return 0;
    }
    if (*(unsigned char *)(a1 + 40)) {
      goto LABEL_5;
    }
    unint64_t v16 = *(void *)(a1 + 168);
    if (v16)
    {
      uint64_t v17 = 8;
      if (v16 < 8) {
        uint64_t v17 = *(void *)(a1 + 168);
      }
      int64_t v18 = v16 - v17;
      if ((uint64_t)(v16 - 1) >= (uint64_t)(v16 - v17))
      {
        uint64_t v19 = *(void *)(a1 + 168);
        do
        {
          *a4++ = *(unsigned char *)(a1 + 159 + v19);
          int64_t v20 = v19 - 2;
          --v19;
        }
        while (v20 >= v18);
      }
      *(void *)(a1 + 168) = v18;
      if (v16 > 7) {
        goto LABEL_5;
      }
      size_t v21 = 8 - v17;
    }
    else
    {
      size_t v21 = 8;
    }
    if (a5) {
      uint64_t v23 = 0;
    }
    else {
      uint64_t v23 = a4;
    }
    if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v23, v21))
    {
LABEL_5:
      for (uint64_t i = v25; i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
      uint64_t result = 1;
      if ((a5 & 2) == 0)
      {
        uint64_t v11 = *(void *)(a1 + 128);
        uint64_t v12 = *(void *)(a1 + 112) - 1;
        if (*(unsigned char *)(v11 + 48 * v12) != 2) {
          ++*(void *)(v11 + 48 * v12 + 32);
        }
      }
      return result;
    }
LABEL_31:
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Double");
    goto LABEL_5;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::advance(uint64_t a1, const char *a2, int a3, void *a4, _DWORD *a5)
{
  int v9 = *(unsigned __int8 *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 48);
  if (v9 == 2)
  {
    if (!re::EncoderOPACK<re::FixedArrayInputStream>::advance_KeyedContainer(a1, a2, a3)) {
      return 0;
    }
  }
  else if (v9 == 1 && !re::EncoderOPACK<re::FixedArrayInputStream>::advance_UnkeyedContainer(a1, a2))
  {
    return 0;
  }
  return re::EncoderOPACK<re::FixedArrayInputStream>::evaluateConditional(a1, a2, a5, a4);
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readTag(uint64_t a1, const char *a2, char *__dst, uint64_t a4)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    uint64_t v6 = *(void *)(a1 + 168);
    if (v6)
    {
      uint64_t v7 = v6 - 1;
      *unsigned __int8 __dst = *(unsigned char *)(a1 + v7 + 160);
      *(void *)(a1 + 168) = v7;
      return 1;
    }
    uint64_t v4 = 1;
    if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, __dst, 1uLL))return v4; {
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a4);
    }
  }
  return 0;
}

BOOL re::EncoderOPACK<re::FixedArrayInputStream>::advance_UnkeyedContainer(uint64_t a1, const char *a2)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 168);
  if (v4)
  {
    unint64_t v5 = v4 - 1;
    int v6 = *(unsigned __int8 *)(a1 + v4 - 1 + 160);
    *(void *)(a1 + 168) = v5;
  }
  else
  {
    unsigned __int8 __dst = 0;
    if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL))
    {
      re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Array element or terminator");
      return 0;
    }
    int v6 = __dst;
    unint64_t v5 = *(void *)(a1 + 168);
  }
  if (v5 <= 7)
  {
    *(void *)(a1 + 168) = v5 + 1;
    *(unsigned char *)(a1 + v5 + 160) = v6;
  }
  return v6 != 3;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::advance_KeyedContainer(uint64_t a1, const char *a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 128);
  uint64_t v4 = *(void *)(a1 + 112) - 1;
  if ((*(unsigned char *)(v3 + 48 * v4 + 4) & 0x40) != 0) {
    return 1;
  }
  int v6 = *(_DWORD *)(v3 + 48 * v4 + 32);
  int v36 = v6;
  if (v6 == a3)
  {
LABEL_3:
    *(void *)(v3 + 48 * v4 + 32) = 0xFFFFFFFF80000000;
    return 1;
  }
  uint64_t v10 = a1 + 159;
  while (1)
  {
    if (v6 > a3)
    {
      uint64_t result = 0;
      *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 16) = v6;
      return result;
    }
    if ((v6 & 0x80000000) == 0) {
      re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
    }
    unsigned __int8 __dst = 0;
    if (*(unsigned char *)(a1 + 40)) {
      return 0;
    }
    uint64_t v11 = *(void *)(a1 + 168);
    if (v11)
    {
      uint64_t v12 = v11 - 1;
      int v13 = *(unsigned __int8 *)(a1 + v11 - 1 + 160);
      unsigned __int8 __dst = v13;
      *(void *)(a1 + 168) = v12;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL) & 1) == 0)
      {
        uint64_t v32 = "Integer (numeric tag)";
        goto LABEL_64;
      }
      int v13 = __dst;
    }
    if (v13 == 3) {
      break;
    }
    if ((v13 - 7) <= 0x28)
    {
      LODWORD(v14) = v13 - 8;
      goto LABEL_53;
    }
    if (v13 != 50)
    {
      if (v13 != 49)
      {
        if (v13 != 48)
        {
          unint64_t v31 = *(void *)(a1 + 168);
          if (v31 <= 7)
          {
            *(void *)(a1 + 168) = v31 + 1;
            *(unsigned char *)(a1 + v31 + 160) = v13;
          }
          return 0;
        }
        char v34 = 0;
        if (*(unsigned char *)(a1 + 40)) {
          return 0;
        }
        uint64_t v14 = *(void *)(a1 + 168);
        if (v14)
        {
          uint64_t v15 = v14 - 1;
          LOBYTE(v14) = *(unsigned char *)(a1 + v14 - 1 + 160);
          *(void *)(a1 + 168) = v15;
        }
        else
        {
          if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, &v34, 1uLL))
          {
            uint64_t v32 = "8-Bit Signed Integer";
            goto LABEL_64;
          }
          LOBYTE(v14) = v34;
        }
        LODWORD(v14) = (char)v14;
        goto LABEL_53;
      }
      __int16 v33 = 0;
      if (*(unsigned char *)(a1 + 40)) {
        return 0;
      }
      unint64_t v23 = *(void *)(a1 + 168);
      if (!v23)
      {
        uint64_t v26 = (char *)&v33;
        size_t v29 = 2;
        goto LABEL_51;
      }
      if (v23 >= 2) {
        uint64_t v24 = 2;
      }
      else {
        uint64_t v24 = *(void *)(a1 + 168);
      }
      int64_t v25 = v23 - v24;
      uint64_t v26 = (char *)&v33;
      if ((uint64_t)(v23 - 1) >= (uint64_t)(v23 - v24))
      {
        uint64_t v27 = *(void *)(a1 + 168);
        do
        {
          *v26++ = *(unsigned char *)(v10 + v27);
          int64_t v28 = v27 - 2;
          --v27;
        }
        while (v28 >= v25);
      }
      *(void *)(a1 + 168) = v25;
      if (v23 <= 1)
      {
        size_t v29 = 2 - v24;
LABEL_51:
        if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v26, v29) & 1) == 0)
        {
          uint64_t v32 = "16-Bit Signed Integer";
          goto LABEL_64;
        }
      }
      LODWORD(v14) = v33;
LABEL_53:
      int v36 = v14;
      goto LABEL_54;
    }
    if (*(unsigned char *)(a1 + 40)) {
      return 0;
    }
    unint64_t v16 = *(void *)(a1 + 168);
    if (v16)
    {
      if (v16 >= 4) {
        uint64_t v17 = 4;
      }
      else {
        uint64_t v17 = *(void *)(a1 + 168);
      }
      int64_t v18 = v16 - v17;
      uint64_t v19 = (char *)&v36;
      if ((uint64_t)(v16 - 1) >= (uint64_t)(v16 - v17))
      {
        uint64_t v20 = *(void *)(a1 + 168);
        do
        {
          *v19++ = *(unsigned char *)(v10 + v20);
          int64_t v21 = v20 - 2;
          --v20;
        }
        while (v21 >= v18);
      }
      *(void *)(a1 + 168) = v18;
      if (v16 > 3) {
        goto LABEL_54;
      }
      size_t v22 = 4 - v17;
    }
    else
    {
      uint64_t v19 = (char *)&v36;
      size_t v22 = 4;
    }
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v19, v22) & 1) == 0)
    {
      uint64_t v32 = "32-Bit Signed Integer";
LABEL_64:
      re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)v32);
      return 0;
    }
LABEL_54:
    int v6 = v36;
    if (v36 == a3)
    {
      uint64_t v3 = *(void *)(a1 + 128);
      uint64_t v4 = *(void *)(a1 + 112) - 1;
      goto LABEL_3;
    }
  }
  unint64_t v30 = *(void *)(a1 + 168);
  if (v30 <= 7)
  {
    *(void *)(a1 + 168) = v30 + 1;
    *(unsigned char *)(a1 + v30 + 160) = 3;
  }
  return 0;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::evaluateConditional(uint64_t a1, const char *a2, _DWORD *a3, void *a4)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  unsigned __int8 __dst = 0;
  uint64_t v9 = *(void *)(a1 + 168);
  if (v9)
  {
    uint64_t v10 = v9 - 1;
    unsigned int v11 = *(unsigned __int8 *)(a1 + v9 - 1 + 160);
    unsigned __int8 __dst = v11;
    *(void *)(a1 + 168) = v10;
  }
  else
  {
    if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL))
    {
LABEL_55:
      size_t v29 = "Array";
      goto LABEL_56;
    }
    unsigned int v11 = __dst;
  }
  uint64_t v12 = v11;
  unint64_t v13 = v11 - 209;
  if ((v11 + 33) < 0xF3u || v11 == 209)
  {
    unint64_t v15 = *(void *)(a1 + 168);
    if (v15 <= 7)
    {
      *(void *)(a1 + 168) = v15 + 1;
      *(unsigned char *)(a1 + v15 + 160) = v11;
    }
    return 1;
  }
  uint64_t v4 = 0;
  unsigned __int8 v56 = 0;
  if (*(unsigned char *)(a1 + 40)) {
    return v4;
  }
  uint64_t v17 = *(void *)(a1 + 168);
  if (v17)
  {
    uint64_t v18 = v17 - 1;
    int v19 = *(unsigned __int8 *)(a1 + v17 - 1 + 160);
    unsigned __int8 v56 = v19;
    *(void *)(a1 + 168) = v18;
    goto LABEL_21;
  }
  if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&v56, 1uLL))
  {
    int v19 = v56;
LABEL_21:
    if (v19 != 69)
    {
      unint64_t v26 = *(void *)(a1 + 168);
      if (v26 <= 7)
      {
        *(void *)(a1 + 168) = v26 + 1;
        *(unsigned char *)(a1 + v26 + 160) = v19;
LABEL_35:
        unint64_t v27 = *(void *)(a1 + 168);
        if (v27 <= 7)
        {
          unsigned __int8 v28 = __dst;
          *(void *)(a1 + 168) = v27 + 1;
          *(unsigned char *)(a1 + v27 + 160) = v28;
        }
      }
      return 1;
    }
    __int16 v55 = 0;
    int v54 = 0;
    if (*(unsigned char *)(a1 + 40))
    {
LABEL_23:
      if (v54 == 1852793664 && v55 == 100)
      {
        uint64_t v34 = 0;
        uint64_t v35 = v12 - 210;
        unsigned int v36 = 1;
        while (!*(unsigned char *)(a1 + 40))
        {
          uint64_t v37 = *(void *)(a1 + 168);
          if (v37)
          {
            uint64_t v38 = v37 - 1;
            unsigned __int8 v39 = *(unsigned char *)(a1 + v37 - 1 + 160);
            unsigned __int8 __dst = v39;
            *(void *)(a1 + 168) = v38;
          }
          else
          {
            if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL))goto LABEL_55; {
            unsigned __int8 v39 = __dst;
            }
          }
          if ((v39 + 46) >= 0xDu)
          {
            re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)a1, a2, (re::DynamicString *)&v48);
            if (v49) {
              uint64_t v45 = v51;
            }
            else {
              uint64_t v45 = v50;
            }
            re::DynamicString::format((re::DynamicString *)"Failed to read version conditional \"%s\". Invalid condition.", (re::DynamicString *)&v52, v45);
            re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1, (uint64_t)&v52);
            if ((void)v52)
            {
              if (BYTE8(v52)) {
                (*(void (**)(void))(*(void *)v52 + 40))();
              }
              long long v52 = 0u;
              long long v53 = 0u;
            }
            if (v48 && (v49 & 1) != 0) {
              (*(void (**)(void))(*(void *)v48 + 40))();
            }
            return 0;
          }
          int v47 = 0;
          uint64_t v4 = re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<int>((_anonymous_namespace_ *)a1, a2, &v47);
          if ((v4 & 1) == 0)
          {
            re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)a1, a2, (re::DynamicString *)&v48);
            if (v49) {
              uint64_t v46 = v51;
            }
            else {
              uint64_t v46 = v50;
            }
            re::DynamicString::format((re::DynamicString *)"Failed to read version conditional \"%s\". Failed to read version.", (re::DynamicString *)&v52, v46);
            re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(a1, (uint64_t)&v52);
            if ((void)v52)
            {
              if (BYTE8(v52)) {
                (*(void (**)(void))(*(void *)v52 + 40))();
              }
              long long v52 = 0u;
              long long v53 = 0u;
            }
            if (v48 && (v49 & 1) != 0) {
              (*(void (**)(void))(*(void *)v48 + 40))();
            }
            return v4;
          }
          if (*(_DWORD *)(a1 + 136) <= v47 || v35 == v34)
          {
            if (a3) {
              *a3 = v47;
            }
            *a4 = v13 + ~v34;
            return v4;
          }
          re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
          uint64_t v34 = v36;
          if (v13 <= v36++)
          {
            re::internal::assertLog((re::internal *)4, v40, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "evaluateConditional", 2285);
            _os_crash();
            __break(1u);
            goto LABEL_55;
          }
        }
        return 0;
      }
      unint64_t v21 = *(void *)(a1 + 168);
      if (v21 + 4 <= 7)
      {
        for (uint64_t i = 4; i != -1; --i)
        {
          char v23 = *((unsigned char *)&v54 + i);
          uint64_t v24 = *(void *)(a1 + 168);
          *(void *)(a1 + 168) = v24 + 1;
          *(unsigned char *)(a1 + v24 + 160) = v23;
        }
        unint64_t v21 = *(void *)(a1 + 168);
      }
      if (v21 <= 7)
      {
        unsigned __int8 v25 = v56;
        *(void *)(a1 + 168) = v21 + 1;
        *(unsigned char *)(a1 + v21 + 160) = v25;
        goto LABEL_35;
      }
      return 1;
    }
    unint64_t v30 = *(void *)(a1 + 168);
    if (v30)
    {
      uint64_t v31 = 5;
      if (v30 < 5) {
        uint64_t v31 = *(void *)(a1 + 168);
      }
      int64_t v32 = v30 - v31;
      if ((uint64_t)(v30 - 1) >= (uint64_t)(v30 - v31))
      {
        __int16 v33 = (char *)&v54;
        uint64_t v43 = *(void *)(a1 + 168);
        do
        {
          *v33++ = *(unsigned char *)(a1 + 159 + v43);
          int64_t v44 = v43 - 2;
          --v43;
        }
        while (v44 >= v32);
      }
      else
      {
        __int16 v33 = (char *)&v54;
      }
      *(void *)(a1 + 168) = v32;
      if (v30 > 4) {
        goto LABEL_23;
      }
      size_t v42 = 5 - v31;
    }
    else
    {
      __int16 v33 = (char *)&v54;
      size_t v42 = 5;
    }
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v33, v42) & 1) == 0)re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Small String"); {
    goto LABEL_23;
    }
  }
  size_t v29 = "Small String";
LABEL_56:
  re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)v29);
  return 0;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(uint64_t result)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  uint64_t v1 = result;
  unsigned __int8 __dst = 0;
  uint64_t v2 = *(void *)(result + 168);
  if (v2)
  {
    uint64_t v3 = v2 - 1;
    int v4 = *(unsigned __int8 *)(result + v3 + 160);
    unsigned __int8 __dst = v4;
    *(void *)(v1 + 168) = v3;
  }
  else
  {
    if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, (char *)&__dst, 1uLL))
    {
      uint64_t v12 = "Member";
      unint64_t v13 = (_anonymous_namespace_ *)v1;
      return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v13, "unknown", (uint64_t)v12);
    }
    int v4 = __dst;
  }
  uint64_t result = (uint64_t)re::OPACK::toString(v4);
  uint64_t v5 = result;
  unsigned __int8 v6 = __dst;
  if (__dst > 0x2Fu)
  {
    switch(__dst)
    {
      case '0':
LABEL_20:
        if (*(unsigned char *)(v1 + 40)) {
          return result;
        }
        uint64_t v10 = (void *)v1;
        size_t v11 = 1;
        goto LABEL_73;
      case '1':
LABEL_30:
        if (*(unsigned char *)(v1 + 40)) {
          return result;
        }
        unint64_t v15 = *(void *)(v1 + 168);
        if (!v15)
        {
          size_t v11 = 2;
          goto LABEL_72;
        }
        uint64_t v8 = 2;
        if (v15 >= 2) {
          uint64_t v9 = 2;
        }
        else {
          uint64_t v9 = *(void *)(v1 + 168);
        }
        *(void *)(v1 + 168) = v15 - v9;
        if (v15 != 1) {
          return result;
        }
        goto LABEL_48;
      case '2':
      case '5':
LABEL_23:
        if (*(unsigned char *)(v1 + 40)) {
          return result;
        }
        unint64_t v14 = *(void *)(v1 + 168);
        if (!v14)
        {
          size_t v11 = 4;
          goto LABEL_72;
        }
        uint64_t v8 = 4;
        if (v14 >= 4) {
          uint64_t v9 = 4;
        }
        else {
          uint64_t v9 = *(void *)(v1 + 168);
        }
        *(void *)(v1 + 168) = v14 - v9;
        if (v14 > 3) {
          return result;
        }
        goto LABEL_48;
      case '3':
      case '6':
        goto LABEL_12;
      case '4':
        goto LABEL_37;
      default:
        switch(__dst)
        {
          case 0xC1u:
            goto LABEL_20;
          case 0xC2u:
            goto LABEL_30;
          case 0xC3u:
            if (*(unsigned char *)(v1 + 40)) {
              return result;
            }
            unint64_t v18 = *(void *)(v1 + 168);
            if (!v18)
            {
              size_t v11 = 3;
              goto LABEL_72;
            }
            uint64_t v19 = 3;
            if (v18 < 3) {
              uint64_t v19 = *(void *)(v1 + 168);
            }
            *(void *)(v1 + 168) = v18 - v19;
            size_t v11 = v19 ^ 3;
            if (v19 == 3) {
              return result;
            }
            goto LABEL_72;
          case 0xC4u:
            goto LABEL_23;
          default:
            goto LABEL_37;
        }
    }
  }
  if (__dst - 1 >= 4)
  {
    if (__dst == 5)
    {
      if (*(unsigned char *)(v1 + 40)) {
        return result;
      }
      unint64_t v17 = *(void *)(v1 + 168);
      if (!v17)
      {
        size_t v11 = 16;
        goto LABEL_72;
      }
      uint64_t v8 = 16;
      if (v17 >= 0x10) {
        uint64_t v9 = 16;
      }
      else {
        uint64_t v9 = *(void *)(v1 + 168);
      }
      *(void *)(v1 + 168) = v17 - v9;
      if (v17 > 0xF) {
        return result;
      }
    }
    else
    {
      if (__dst != 6)
      {
LABEL_37:
        if (__dst - 7 < 0x29) {
          return result;
        }
        if (__dst - 64 > 0x24)
        {
          if (__dst - 112 > 0x24)
          {
            if ((__dst + 96) >= 0x21u)
            {
              if ((__dst + 48) > 0xEu)
              {
                if (__dst == 223)
                {
                  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readTag(v1, "unknown", (char *)&__dst, (uint64_t)"Array value/terminator");
                  if (result)
                  {
                    do
                    {
                      unsigned __int8 v23 = __dst;
                      if (__dst == 3) {
                        break;
                      }
                      unint64_t v24 = *(void *)(v1 + 168);
                      if (v24 <= 7)
                      {
                        *(void *)(v1 + 168) = v24 + 1;
                        *(unsigned char *)(v1 + v24 + 160) = v23;
                      }
                      re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(v1);
                      uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readTag(v1, "unknown", (char *)&__dst, (uint64_t)"Array value/terminator");
                    }
                    while ((result & 1) != 0);
                  }
                }
                else if ((__dst + 32) > 0xEu)
                {
                  if (__dst == 239)
                  {
                    for (uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readTag(v1, "unknown", (char *)&__dst, (uint64_t)"Dictionary key/value/terminator");
                          result;
                          uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readTag(v1, "unknown", (char *)&__dst, (uint64_t)"Dictionary key/value/terminator"))
                    {
                      unsigned __int8 v28 = __dst;
                      if (__dst == 3) {
                        break;
                      }
                      unint64_t v29 = *(void *)(v1 + 168);
                      if (v29 <= 7)
                      {
                        *(void *)(v1 + 168) = v29 + 1;
                        *(unsigned char *)(v1 + v29 + 160) = v28;
                      }
                      uint64_t v30 = -2;
                      do
                      {
                        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(v1);
                        BOOL v27 = __CFADD__(v30++, 1);
                      }
                      while (!v27);
                    }
                  }
                  else
                  {
                    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels((_anonymous_namespace_ *)v1, 0, (re::DynamicString *)&v32);
                    if (v33) {
                      uint64_t v31 = *(unsigned char **)&v34[7];
                    }
                    else {
                      uint64_t v31 = v34;
                    }
                    re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Found unsupported tag while skipping over data.", (re::DynamicString *)&v35, v31);
                    __n[0] = 400;
                    __n[1] = (size_t)re::FoundationErrorCategory(void)::instance;
                    __n[2] = v35;
                    __n[5] = v37;
                    *(_OWORD *)&__n[3] = v36;
                    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (long long *)__n);
                    if (__n[2])
                    {
                      if (__n[3]) {
                        (*(void (**)(void))(*(void *)__n[2] + 40))();
                      }
                      memset(&__n[2], 0, 32);
                    }
                    uint64_t result = v32;
                    if (v32 && (v33 & 1) != 0) {
                      return (*(uint64_t (**)(void))(*(void *)v32 + 40))();
                    }
                  }
                }
                else
                {
                  unint64_t v25 = *(void *)(v1 + 168);
                  if (v25 <= 7)
                  {
                    *(void *)(v1 + 168) = v25 + 1;
                    *(unsigned char *)(v1 + v25 + 160) = v6;
                  }
                  __n[0] = 0;
                  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readDictionaryTag(v1, "unknown", (char *)__n);
                  if (2 * __n[0])
                  {
                    size_t v26 = -2 * __n[0];
                    do
                    {
                      uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(v1);
                      BOOL v27 = __CFADD__(v26++, 1);
                    }
                    while (!v27);
                  }
                }
              }
              else
              {
                unint64_t v21 = *(void *)(v1 + 168);
                if (v21 <= 7)
                {
                  *(void *)(v1 + 168) = v21 + 1;
                  *(unsigned char *)(v1 + v21 + 160) = v6;
                }
                __n[0] = 0;
                uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readArrayTag(v1, "unknown", (char *)__n);
                for (i = __n[0]; i; uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(v1))
                  --i;
              }
            }
            return result;
          }
          unint64_t v20 = *(void *)(v1 + 168);
          if (v20 <= 7)
          {
            *(void *)(v1 + 168) = v20 + 1;
            *(unsigned char *)(v1 + v20 + 160) = v6;
          }
          __n[0] = 0;
          re::EncoderOPACK<re::FixedArrayInputStream>::readDataTag(v1, "unknown", (uint64_t *)__n);
        }
        else
        {
          unint64_t v16 = *(void *)(v1 + 168);
          if (v16 <= 7)
          {
            *(void *)(v1 + 168) = v16 + 1;
            *(unsigned char *)(v1 + v16 + 160) = v6;
          }
          __n[0] = 0;
          re::EncoderOPACK<re::FixedArrayInputStream>::readStringTag(v1, "unknown", (uint64_t *)__n);
        }
        return re::EncoderOPACK<re::FixedArrayInputStream>::readRaw(v1, "unknown", 0, __n[0], v5, 1);
      }
LABEL_12:
      if (*(unsigned char *)(v1 + 40)) {
        return result;
      }
      unint64_t v7 = *(void *)(v1 + 168);
      if (!v7)
      {
        size_t v11 = 8;
        goto LABEL_72;
      }
      uint64_t v8 = 8;
      if (v7 >= 8) {
        uint64_t v9 = 8;
      }
      else {
        uint64_t v9 = *(void *)(v1 + 168);
      }
      *(void *)(v1 + 168) = v7 - v9;
      if (v7 > 7) {
        return result;
      }
    }
LABEL_48:
    size_t v11 = v8 - v9;
LABEL_72:
    uint64_t v10 = (void *)v1;
LABEL_73:
    uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>(v10, 0, v11);
    if ((result & 1) == 0)
    {
      unint64_t v13 = (_anonymous_namespace_ *)v1;
      uint64_t v12 = (const char *)v5;
      return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v13, "unknown", (uint64_t)v12);
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readRaw(uint64_t a1, const char *a2, unsigned char *a3, size_t __n, uint64_t a5, char a6)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  size_t v10 = *(void *)(a1 + 168);
  if (v10)
  {
    if (v10 >= __n) {
      size_t v11 = __n;
    }
    else {
      size_t v11 = *(void *)(a1 + 168);
    }
    int64_t v12 = v10 - v11;
    if ((uint64_t)(v10 - 1) >= (uint64_t)(v10 - v11))
    {
      do
      {
        *a3++ = *(unsigned char *)(a1 + 159 + v10);
        int64_t v13 = v10 - 2;
        --v10;
      }
      while (v13 >= v12);
    }
    *(void *)(a1 + 168) = v12;
    __n -= v11;
  }
  if (__n)
  {
    unint64_t v14 = (a6 & 1) != 0 ? 0 : a3;
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v14, __n) & 1) == 0)
    {
      re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
      return 0;
    }
  }
  return 1;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readStringTag(uint64_t result, const char *a2, uint64_t *a3)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  uint64_t v5 = result;
  unsigned __int8 __dst = 0;
  uint64_t v6 = *(void *)(result + 168);
  if (v6)
  {
    uint64_t v7 = v6 - 1;
    uint64_t result = *(unsigned __int8 *)(result + v7 + 160);
    unsigned __int8 __dst = *(unsigned char *)(v5 + v7 + 160);
    *(void *)(v5 + 168) = v7;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, (char *)&__dst, 1uLL) & 1) == 0)return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String"); {
    uint64_t result = __dst;
    }
  }
  if ((result - 64) > 0x20)
  {
    switch((int)result)
    {
      case 'a':
        LOBYTE(v32) = 0;
        if (!*(unsigned char *)(v5 + 40))
        {
          uint64_t v8 = *(void *)(v5 + 168);
          if (v8)
          {
            uint64_t v9 = v8 - 1;
            LODWORD(v8) = *(unsigned __int8 *)(v5 + v8 - 1 + 160);
            *(void *)(v5 + 168) = v9;
          }
          else
          {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, (char *)&v32, 1uLL);
            if (!result) {
              return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
            }
            LODWORD(v8) = v32;
          }
          uint64_t v8 = v8;
          goto LABEL_8;
        }
        return result;
      case 'b':
        LOWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v11 = *(void *)(v5 + 168);
        if (v11)
        {
          uint64_t v12 = 2;
          if (v11 < 2) {
            uint64_t v12 = *(void *)(v5 + 168);
          }
          int64_t v13 = v11 - v12;
          if ((uint64_t)(v11 - 1) >= (uint64_t)(v11 - v12))
          {
            unint64_t v14 = (char *)&v32;
            uint64_t v26 = *(void *)(v5 + 168);
            do
            {
              *v14++ = *(unsigned char *)(v5 + 159 + v26);
              int64_t v27 = v26 - 2;
              --v26;
            }
            while (v27 >= v13);
          }
          else
          {
            unint64_t v14 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v13;
          if (v11 > 1)
          {
LABEL_43:
            uint64_t v8 = (unsigned __int16)v32;
            goto LABEL_8;
          }
          size_t v25 = 2 - v12;
        }
        else
        {
          unint64_t v14 = (char *)&v32;
          size_t v25 = 2;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v14, v25);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
        }
        goto LABEL_43;
      case 'c':
        LODWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v15 = *(void *)(v5 + 168);
        if (v15)
        {
          uint64_t v16 = 4;
          if (v15 < 4) {
            uint64_t v16 = *(void *)(v5 + 168);
          }
          int64_t v17 = v15 - v16;
          if ((uint64_t)(v15 - 1) >= (uint64_t)(v15 - v16))
          {
            unint64_t v18 = (char *)&v32;
            uint64_t v28 = *(void *)(v5 + 168);
            do
            {
              *v18++ = *(unsigned char *)(v5 + 159 + v28);
              int64_t v29 = v28 - 2;
              --v28;
            }
            while (v29 >= v17);
          }
          else
          {
            unint64_t v18 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v17;
          if (v15 > 3) {
            goto LABEL_49;
          }
          size_t v23 = 4 - v16;
        }
        else
        {
          unint64_t v18 = (char *)&v32;
          size_t v23 = 4;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v18, v23);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
        }
LABEL_49:
        uint64_t v8 = v32;
        goto LABEL_8;
      case 'd':
        uint64_t v32 = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v19 = *(void *)(v5 + 168);
        if (v19)
        {
          uint64_t v20 = 8;
          if (v19 < 8) {
            uint64_t v20 = *(void *)(v5 + 168);
          }
          int64_t v21 = v19 - v20;
          if ((uint64_t)(v19 - 1) >= (uint64_t)(v19 - v20))
          {
            size_t v22 = (char *)&v32;
            uint64_t v30 = *(void *)(v5 + 168);
            do
            {
              *v22++ = *(unsigned char *)(v5 + 159 + v30);
              int64_t v31 = v30 - 2;
              --v30;
            }
            while (v31 >= v21);
          }
          else
          {
            size_t v22 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v21;
          if (v19 > 7) {
            goto LABEL_55;
          }
          size_t v24 = 8 - v20;
        }
        else
        {
          size_t v22 = (char *)&v32;
          size_t v24 = 8;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v22, v24);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"String");
        }
LABEL_55:
        uint64_t v8 = v32;
        goto LABEL_8;
      default:
        size_t v10 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"String", (uint64_t)v10);
    }
  }
  uint64_t v8 = result - 64;
LABEL_8:
  *a3 = v8;
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readDataTag(uint64_t result, const char *a2, uint64_t *a3)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  uint64_t v5 = result;
  unsigned __int8 __dst = 0;
  uint64_t v6 = *(void *)(result + 168);
  if (v6)
  {
    uint64_t v7 = v6 - 1;
    uint64_t result = *(unsigned __int8 *)(result + v7 + 160);
    unsigned __int8 __dst = *(unsigned char *)(v5 + v7 + 160);
    *(void *)(v5 + 168) = v7;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, (char *)&__dst, 1uLL) & 1) == 0)return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB"); {
    uint64_t result = __dst;
    }
  }
  if ((result - 112) > 0x20)
  {
    switch((int)result)
    {
      case 145:
        LOBYTE(v32) = 0;
        if (!*(unsigned char *)(v5 + 40))
        {
          uint64_t v8 = *(void *)(v5 + 168);
          if (v8)
          {
            uint64_t v9 = v8 - 1;
            LODWORD(v8) = *(unsigned __int8 *)(v5 + v8 - 1 + 160);
            *(void *)(v5 + 168) = v9;
          }
          else
          {
            uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, (char *)&v32, 1uLL);
            if (!result) {
              return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
            }
            LODWORD(v8) = v32;
          }
          uint64_t v8 = v8;
          goto LABEL_8;
        }
        return result;
      case 146:
        LOWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v11 = *(void *)(v5 + 168);
        if (v11)
        {
          uint64_t v12 = 2;
          if (v11 < 2) {
            uint64_t v12 = *(void *)(v5 + 168);
          }
          int64_t v13 = v11 - v12;
          if ((uint64_t)(v11 - 1) >= (uint64_t)(v11 - v12))
          {
            unint64_t v14 = (char *)&v32;
            uint64_t v26 = *(void *)(v5 + 168);
            do
            {
              *v14++ = *(unsigned char *)(v5 + 159 + v26);
              int64_t v27 = v26 - 2;
              --v26;
            }
            while (v27 >= v13);
          }
          else
          {
            unint64_t v14 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v13;
          if (v11 > 1)
          {
LABEL_43:
            uint64_t v8 = (unsigned __int16)v32;
            goto LABEL_8;
          }
          size_t v25 = 2 - v12;
        }
        else
        {
          unint64_t v14 = (char *)&v32;
          size_t v25 = 2;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v14, v25);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
        }
        goto LABEL_43;
      case 147:
        LODWORD(v32) = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v15 = *(void *)(v5 + 168);
        if (v15)
        {
          uint64_t v16 = 4;
          if (v15 < 4) {
            uint64_t v16 = *(void *)(v5 + 168);
          }
          int64_t v17 = v15 - v16;
          if ((uint64_t)(v15 - 1) >= (uint64_t)(v15 - v16))
          {
            unint64_t v18 = (char *)&v32;
            uint64_t v28 = *(void *)(v5 + 168);
            do
            {
              *v18++ = *(unsigned char *)(v5 + 159 + v28);
              int64_t v29 = v28 - 2;
              --v28;
            }
            while (v29 >= v17);
          }
          else
          {
            unint64_t v18 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v17;
          if (v15 > 3) {
            goto LABEL_49;
          }
          size_t v23 = 4 - v16;
        }
        else
        {
          unint64_t v18 = (char *)&v32;
          size_t v23 = 4;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v18, v23);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
        }
LABEL_49:
        uint64_t v8 = v32;
        goto LABEL_8;
      case 148:
        uint64_t v32 = 0;
        if (*(unsigned char *)(v5 + 40)) {
          return result;
        }
        unint64_t v19 = *(void *)(v5 + 168);
        if (v19)
        {
          uint64_t v20 = 8;
          if (v19 < 8) {
            uint64_t v20 = *(void *)(v5 + 168);
          }
          int64_t v21 = v19 - v20;
          if ((uint64_t)(v19 - 1) >= (uint64_t)(v19 - v20))
          {
            size_t v22 = (char *)&v32;
            uint64_t v30 = *(void *)(v5 + 168);
            do
            {
              *v22++ = *(unsigned char *)(v5 + 159 + v30);
              int64_t v31 = v30 - 2;
              --v30;
            }
            while (v31 >= v21);
          }
          else
          {
            size_t v22 = (char *)&v32;
          }
          *(void *)(v5 + 168) = v21;
          if (v19 > 7) {
            goto LABEL_55;
          }
          size_t v24 = 8 - v20;
        }
        else
        {
          size_t v22 = (char *)&v32;
          size_t v24 = 8;
        }
        uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, v22, v24);
        if ((result & 1) == 0) {
          return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"BLOB");
        }
LABEL_55:
        uint64_t v8 = v32;
        goto LABEL_8;
      default:
        size_t v10 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"BLOB", (uint64_t)v10);
    }
  }
  uint64_t v8 = result - 112;
LABEL_8:
  *a3 = v8;
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readArrayTag(uint64_t result, const char *a2, char *__dst)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v5 = (void *)result;
    unsigned __int8 __dsta = 0;
    uint64_t v6 = *(void *)(result + 168);
    if (v6)
    {
      uint64_t v7 = v6 - 1;
      uint64_t result = *(unsigned __int8 *)(result + v7 + 160);
      unsigned __int8 __dsta = *((unsigned char *)v5 + v7 + 160);
      v5[21] = v7;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, (char *)&__dsta, 1uLL) & 1) == 0)return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Array"); {
      uint64_t result = __dsta;
      }
    }
    if ((result + 48) > 0xEu)
    {
      if (result == 223)
      {
        return re::EncoderOPACK<re::FixedArrayInputStream>::readUint64((uint64_t)v5, a2, __dst);
      }
      else
      {
        uint64_t v8 = re::OPACK::toString(result);
        return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"Array", (uint64_t)v8);
      }
    }
    else
    {
      *(void *)unsigned __int8 __dst = result - 208;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readDictionaryTag(uint64_t result, const char *a2, char *__dst)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v5 = result;
    unsigned __int8 __dsta = 0;
    uint64_t v6 = *(void *)(result + 168);
    if (v6)
    {
      uint64_t v7 = v6 - 1;
      uint64_t result = *(unsigned __int8 *)(result + v7 + 160);
      unsigned __int8 __dsta = *(unsigned char *)(v5 + v7 + 160);
      *(void *)(v5 + 168) = v7;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, (char *)&__dsta, 1uLL) & 1) == 0)return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Dictionary"); {
      uint64_t result = __dsta;
      }
    }
    if ((result + 32) <= 0xEu)
    {
      *(void *)unsigned __int8 __dst = result - 224;
      return result;
    }
    if (result != 210) {
      goto LABEL_17;
    }
    uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readUint64(v5, a2, __dst);
    if (!result || *(unsigned char *)(v5 + 40)) {
      return result;
    }
    uint64_t v8 = *(void *)(v5 + 168);
    if (v8)
    {
      uint64_t v9 = v8 - 1;
      uint64_t result = *(unsigned __int8 *)(v5 + v9 + 160);
      unsigned __int8 __dsta = *(unsigned char *)(v5 + v9 + 160);
      *(void *)(v5 + 168) = v9;
      goto LABEL_16;
    }
    if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v5, (char *)&__dsta, 1uLL))
    {
      uint64_t result = __dsta;
LABEL_16:
      if (result == 239) {
        return result;
      }
LABEL_17:
      size_t v10 = re::OPACK::toString(result);
      return re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)v5, (uint64_t)"Dictionary", (uint64_t)v10);
    }
    return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v5, a2, (uint64_t)"Dictionary");
  }
  return result;
}

uint64_t re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>(void *a1, char *__dst, size_t __n)
{
  size_t v3 = __n;
  uint64_t v5 = (int *)(a1 + 2);
  if (__dst)
  {
    uint64_t v6 = __dst;
    uint64_t v7 = (const void **)(a1 + 1);
    while (1)
    {
      size_t v8 = *v5;
      if (v3 <= v8) {
        break;
      }
      if ((int)v8 >= 1)
      {
        memcpy(v6, *v7, v8);
        uint64_t v9 = *v5;
        v6 += v9;
        v3 -= v9;
        uint64_t *v7 = 0;
        int *v5 = 0;
      }
      if (((*(uint64_t (**)(void, void *, int *))(*(void *)*a1 + 16))(*a1, a1 + 1, v5) & 1) == 0) {
        return 0;
      }
    }
    memcpy(v6, *v7, v3);
    uint64_t *v7 = (char *)*v7 + v3;
    *v5 -= v3;
    return 1;
  }
  size_t v11 = *v5;
  if (__n <= v11)
  {
    a1[1] += __n;
    *((_DWORD *)a1 + 4) = v11 - __n;
    return 1;
  }
  if ((int)v11 >= 1)
  {
    a1[1] = 0;
    *((_DWORD *)a1 + 4) = 0;
  }
  uint64_t v12 = *(uint64_t (**)(void))(*(void *)*a1 + 32);
  return v12();
}

uint64_t re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(_anonymous_namespace_ *a1, const char *a2, uint64_t a3)
{
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v7);
  if (v8) {
    uint64_t v5 = *(unsigned char **)&v9[7];
  }
  else {
    uint64_t v5 = v9;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: Error %s type %s.", (re::DynamicString *)v10, "deserialize", v5, "reading", a3);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v10);
  if (*(void *)&v10[0])
  {
    if (BYTE8(v10[0])) {
      (*(void (**)(void))(**(void **)&v10[0] + 40))();
    }
    memset(v10, 0, sizeof(v10));
  }
  uint64_t result = v7;
  if (v7)
  {
    if (v8) {
      return (*(uint64_t (**)(void))(*(void *)v7 + 40))();
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readUint64(uint64_t a1, const char *a2, char *__dst)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  unsigned __int8 __dsta = 0;
  uint64_t v7 = *(void *)(a1 + 168);
  if (v7)
  {
    uint64_t v8 = v7 - 1;
    int v9 = *(unsigned __int8 *)(a1 + v7 - 1 + 160);
    unsigned __int8 __dsta = v9;
    *(void *)(a1 + 168) = v8;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dsta, 1uLL) & 1) == 0)
    {
LABEL_25:
      re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"UInt64");
      return 0;
    }
    int v9 = __dsta;
  }
  if (v9 != 120)
  {
    unint64_t v16 = *(void *)(a1 + 168);
    if (v16 <= 7)
    {
      *(void *)(a1 + 168) = v16 + 1;
      *(unsigned char *)(a1 + v16 + 160) = v9;
    }
    uint64_t v18 = 0;
    if ((re::EncoderOPACK<re::FixedArrayInputStream>::readInteger(a1, a2, (char *)&v18, (uint64_t)"Int64") & 1) == 0) {
      return 0;
    }
    *(void *)unsigned __int8 __dst = v18;
    return 1;
  }
  if (!*(unsigned char *)(a1 + 40))
  {
    unint64_t v10 = *(void *)(a1 + 168);
    if (v10)
    {
      uint64_t v11 = 8;
      if (v10 < 8) {
        uint64_t v11 = *(void *)(a1 + 168);
      }
      int64_t v12 = v10 - v11;
      if ((uint64_t)(v10 - 1) >= (uint64_t)(v10 - v11))
      {
        uint64_t v13 = *(void *)(a1 + 168);
        do
        {
          *__dst++ = *(unsigned char *)(a1 + 159 + v13);
          int64_t v14 = v13 - 2;
          --v13;
        }
        while (v14 >= v12);
      }
      *(void *)(a1 + 168) = v12;
      if (v10 > 7) {
        return 1;
      }
      size_t v15 = 8 - v11;
    }
    else
    {
      size_t v15 = 8;
    }
    if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, __dst, v15))return 1; {
    goto LABEL_25;
    }
  }
  return 0;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readInteger(uint64_t a1, const char *a2, char *__dst, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  unsigned __int8 __dsta = 0;
  uint64_t v9 = *(void *)(a1 + 168);
  if (v9)
  {
    uint64_t v10 = v9 - 1;
    unsigned int v11 = *(unsigned __int8 *)(a1 + v10 + 160);
    unsigned __int8 __dsta = *(unsigned char *)(a1 + v10 + 160);
    *(void *)(a1 + 168) = v10;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dsta, 1uLL) & 1) == 0)
    {
      int64_t v14 = (_anonymous_namespace_ *)a1;
      size_t v15 = a2;
      unint64_t v16 = (const char *)a4;
      goto LABEL_17;
    }
    unsigned int v11 = __dsta;
  }
  if (v11 - 7 > 0x28)
  {
    switch(v11)
    {
      case '0':
        uint64_t result = 0;
        char v40 = 0;
        if (*(unsigned char *)(a1 + 40)) {
          return result;
        }
        uint64_t v12 = *(void *)(a1 + 168);
        if (v12)
        {
          uint64_t v13 = v12 - 1;
          LOBYTE(v12) = *(unsigned char *)(a1 + v12 - 1 + 160);
          *(void *)(a1 + 168) = v13;
LABEL_46:
          uint64_t v12 = (char)v12;
          goto LABEL_10;
        }
        if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, &v40, 1uLL))
        {
          LOBYTE(v12) = v40;
          goto LABEL_46;
        }
        unint64_t v16 = "8-Bit Signed Integer";
        goto LABEL_63;
      case '1':
        uint64_t result = 0;
        __int16 v39 = 0;
        if (*(unsigned char *)(a1 + 40)) {
          return result;
        }
        unint64_t v18 = *(void *)(a1 + 168);
        if (v18)
        {
          uint64_t v19 = 2;
          if (v18 < 2) {
            uint64_t v19 = *(void *)(a1 + 168);
          }
          int64_t v20 = v18 - v19;
          if ((uint64_t)(v18 - 1) >= (uint64_t)(v18 - v19))
          {
            int64_t v21 = (char *)&v39;
            uint64_t v34 = *(void *)(a1 + 168);
            do
            {
              *v21++ = *(unsigned char *)(a1 + 159 + v34);
              int64_t v35 = v34 - 2;
              --v34;
            }
            while (v35 >= v20);
          }
          else
          {
            int64_t v21 = (char *)&v39;
          }
          *(void *)(a1 + 168) = v20;
          if (v18 > 1) {
            goto LABEL_53;
          }
          size_t v33 = 2 - v19;
        }
        else
        {
          int64_t v21 = (char *)&v39;
          size_t v33 = 2;
        }
        if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v21, v33))
        {
LABEL_53:
          uint64_t v12 = v39;
          goto LABEL_10;
        }
        unint64_t v16 = "16-Bit Signed Integer";
        goto LABEL_63;
      case '2':
        uint64_t result = 0;
        int v38 = 0;
        if (*(unsigned char *)(a1 + 40)) {
          return result;
        }
        unint64_t v22 = *(void *)(a1 + 168);
        if (v22)
        {
          uint64_t v23 = 4;
          if (v22 < 4) {
            uint64_t v23 = *(void *)(a1 + 168);
          }
          int64_t v24 = v22 - v23;
          if ((uint64_t)(v22 - 1) >= (uint64_t)(v22 - v23))
          {
            size_t v25 = (char *)&v38;
            uint64_t v36 = *(void *)(a1 + 168);
            do
            {
              *v25++ = *(unsigned char *)(a1 + 159 + v36);
              int64_t v37 = v36 - 2;
              --v36;
            }
            while (v37 >= v24);
          }
          else
          {
            size_t v25 = (char *)&v38;
          }
          *(void *)(a1 + 168) = v24;
          if (v22 > 3) {
            goto LABEL_60;
          }
          size_t v32 = 4 - v23;
        }
        else
        {
          size_t v25 = (char *)&v38;
          size_t v32 = 4;
        }
        if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, v25, v32))
        {
LABEL_60:
          uint64_t v12 = v38;
          goto LABEL_10;
        }
        unint64_t v16 = "32-Bit Signed Integer";
LABEL_63:
        int64_t v14 = (_anonymous_namespace_ *)a1;
        size_t v15 = a2;
        break;
      case '3':
        if (*(unsigned char *)(a1 + 40)) {
          return 0;
        }
        unint64_t v26 = *(void *)(a1 + 168);
        if (v26)
        {
          uint64_t v27 = 8;
          if (v26 < 8) {
            uint64_t v27 = *(void *)(a1 + 168);
          }
          int64_t v28 = v26 - v27;
          if ((uint64_t)(v26 - 1) >= (uint64_t)(v26 - v27))
          {
            uint64_t v29 = *(void *)(a1 + 168);
            do
            {
              *__dst++ = *(unsigned char *)(a1 + 159 + v29);
              int64_t v30 = v29 - 2;
              --v29;
            }
            while (v30 >= v28);
          }
          *(void *)(a1 + 168) = v28;
          if (v26 > 7) {
            return 1;
          }
          size_t v31 = 8 - v27;
        }
        else
        {
          size_t v31 = 8;
        }
        if (re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, __dst, v31))return 1; {
        unint64_t v16 = "64-Bit Signed Integer";
        }
        goto LABEL_63;
      default:
        int64_t v17 = re::OPACK::toString(v11);
        re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, a4, (uint64_t)v17);
        return 0;
    }
LABEL_17:
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v14, v15, (uint64_t)v16);
    return 0;
  }
  uint64_t v12 = v11 - 8;
LABEL_10:
  *(void *)unsigned __int8 __dst = v12;
  return 1;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<int>(_anonymous_namespace_ *a1, const char *a2, _DWORD *a3)
{
  uint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"Int32");
  if (result)
  {
    if (__dst == (int)__dst)
    {
      *a3 = __dst;
      return 1;
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "Int32", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<signed char>(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      char v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<signed char>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<signed char>(_anonymous_namespace_ *a1, const char *a2, unsigned char *a3)
{
  uint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"Int8");
  if (result)
  {
    if (__dst == (char)__dst)
    {
      *a3 = __dst;
      return 1;
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "Int8", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<short>(uint64_t a1, const char *a2, int a3, __int16 *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      __int16 v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<short>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<short>(_anonymous_namespace_ *a1, const char *a2, _WORD *a3)
{
  uint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"Int16");
  if (result)
  {
    if (__dst == (__int16)__dst)
    {
      *a3 = __dst;
      return 1;
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "Int16", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<int>(uint64_t a1, const char *a2, int a3, int *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      int v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      unsigned int v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<int>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<long long>(uint64_t a1, const char *a2, int a3, void *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v14 = 0;
  uint64_t v5 = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v14, 0);
  if (v5)
  {
    if (a5)
    {
      uint64_t __dst = 0;
      re::EncoderOPACK<re::FixedArrayInputStream>::readInteger(a1, a2, (char *)&__dst, (uint64_t)"Int64");
    }
    else
    {
      uint64_t __dst = 0;
      if (re::EncoderOPACK<re::FixedArrayInputStream>::readInteger(a1, a2, (char *)&__dst, (uint64_t)"Int64"))*a4 = __dst; {
    }
      }
    for (uint64_t i = v14; i; --i)
      re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v11 = *(void *)(a1 + 128);
      uint64_t v12 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v11 + 48 * v12) != 2) {
        ++*(void *)(v11 + 48 * v12 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned char>(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      char v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<unsigned char>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<unsigned char>(_anonymous_namespace_ *a1, const char *a2, unsigned char *a3)
{
  unint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"UInt8");
  if (result)
  {
    if (__dst > 0xFF)
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "UInt8", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
    else
    {
      *a3 = __dst;
      return 1;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned short>(uint64_t a1, const char *a2, int a3, __int16 *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      __int16 v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<unsigned short>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<unsigned short>(_anonymous_namespace_ *a1, const char *a2, _WORD *a3)
{
  unint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"UInt16");
  if (result)
  {
    if (__dst >> 16)
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "UInt16", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
    else
    {
      *a3 = __dst;
      return 1;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned int>(uint64_t a1, const char *a2, int a3, int *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      int v17 = 0;
      uint64_t v12 = &v17;
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
    }
    else
    {
      uint64_t v10 = (_anonymous_namespace_ *)a1;
      uint64_t v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<unsigned int>(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<unsigned int>(_anonymous_namespace_ *a1, const char *a2, _DWORD *a3)
{
  unint64_t __dst = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::readInteger((uint64_t)a1, a2, (char *)&__dst, (uint64_t)"UInt32");
  if (result)
  {
    if (HIDWORD(__dst))
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
      if (v9) {
        uint64_t v7 = *(unsigned char **)&v10[7];
      }
      else {
        uint64_t v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Integer of type %s expected. Value (%lld) is out of range.", (re::DynamicString *)v11, v7, "UInt32", __dst);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      if (v8)
      {
        if (v9) {
          (*(void (**)(void))(*(void *)v8 + 40))();
        }
      }
      return 0;
    }
    else
    {
      *a3 = __dst;
      return 1;
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned long long>(uint64_t a1, const char *a2, int a3, char *a4, char a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v5 = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v18, 0);
  if (v5)
  {
    if (a5)
    {
      uint64_t v17 = 0;
      uint64_t v12 = (char *)&v17;
      uint64_t v10 = a1;
      uint64_t v11 = a2;
    }
    else
    {
      uint64_t v10 = a1;
      uint64_t v11 = a2;
      uint64_t v12 = a4;
    }
    re::EncoderOPACK<re::FixedArrayInputStream>::readUint64(v10, v11, v12);
    for (uint64_t i = v18; i; --i)
      re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(a1);
    if ((a5 & 2) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 128);
      uint64_t v15 = *(void *)(a1 + 112) - 1;
      if (*(unsigned char *)(v14 + 48 * v15) != 2) {
        ++*(void *)(v14 + 48 * v15 + 32);
      }
    }
  }
  return v5;
}

uint64_t re::internal::serializeEnumAsBinary<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re::internal *a5, re::internal *a6, int a7)
{
  if (a7)
  {
    uint64_t v11 = *(re::internal **)(a1 + 208);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v11, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (!*(unsigned char *)(a1 + 64)) {
      return (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, void, uint64_t *, uint64_t *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, 0, &__src, &__src, 1);
    }
    return 0;
  }
  uint64_t v15 = *(void **)a5;
  if (a5 == a6) {
    goto LABEL_8;
  }
  if (v15 == *(void **)a6)
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v17 = (uint64_t *)*((void *)a6 + 2);
    uint64_t v18 = *v17;
    if ((unsigned __int16)v16 == (unsigned __int16)*v17)
    {
      BOOL v20 = WORD1(v16) == WORD1(v18);
      uint64_t v19 = (v18 ^ v16) & 0xFFFFFF00000000;
      BOOL v20 = v20 && v19 == 0;
      if (v20) {
        goto LABEL_8;
      }
    }
LABEL_21:
    uint64_t v23 = *(re::internal **)(a1 + 208);
    re::TypeRegistry::typeInfo(v15, v17[9], &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v23, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (*(_DWORD *)(v58[1] + 8) < 9u)
    {
      uint64_t v55 = 0;
      if (!*(unsigned char *)(a1 + 64)
        && (*(unsigned int (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, uint64_t *, uint64_t *, void))(*(void *)a1 + 72))(a1, a2, a3, &v55, &__src, &__src, 0))
      {
        unsigned int EnumConstantIndex = re::internal::getEnumConstantIndex(a6, (const re::TypeInfo *)&v55, v29);
        if ((EnumConstantIndex & 0x80000000) != 0)
        {
          char v41 = v55;
          re::TypeInfo::name(a6);
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v42, v43, v44, v45, v46, v41);
        }
        else
        {
          unsigned int v31 = EnumConstantIndex;
          size_t v32 = *(re::internal::TypeTranslationTable **)(*(void *)a6 + 856);
          if (v32)
          {
            size_t v33 = (const void *)re::internal::TypeTranslationTable::translateSerializedEnum(v32, a6, v31, a5);
            if (v33)
            {
              memcpy(a4, v33, *(unsigned int *)(*((void *)a5 + 2) + 8));
              int v34 = 0;
              return v34 == 0;
            }
          }
          v56[0] = re::TypeInfo::enumConstants(a6);
          v56[1] = v47;
          uint64_t v48 = *(void *)(re::Slice<re::EnumConstant>::operator[](v56, v31) + 16);
          re::TypeInfo::name(a5);
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Serialized enum constant \"%s\" does not exist in runtime type \"%s\".", v49, v50, v51, v52, v53, v48);
        }
      }
    }
    else
    {
      uint64_t v54 = re::TypeInfo::name((re::TypeInfo *)&__src)[1];
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Enum type \"%s\" has invalid size: %zu bytes.", v24, v25, v26, v27, v28, v54);
    }
    int v34 = 1;
    return v34 == 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
  {
    uint64_t v15 = *(void **)a6;
    uint64_t v17 = (uint64_t *)*((void *)a6 + 2);
    goto LABEL_21;
  }
  uint64_t v15 = *(void **)a5;
LABEL_8:
  re::TypeRegistry::typeInfo(v15, *(void *)(*((void *)a5 + 2) + 72), &__src);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
  uint64_t __src = 0;
  if (*(unsigned char *)(a1 + 64)) {
    return 0;
  }
  int v22 = (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, void *, void *, void))(*(void *)a1 + 72))(a1, a2, a3, &__src, v56, v56, 0);
  uint64_t result = 0;
  if (v22)
  {
    if ((re::internal::getEnumConstantIndex(a5, (const re::TypeInfo *)&__src, v21) & 0x80000000) != 0)
    {
      char v35 = __src;
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v36, v37, v38, v39, v40, v35);
      return 0;
    }
    memcpy(a4, &__src, *(unsigned int *)(*((void *)a5 + 2) + 8));
    return 1;
  }
  return result;
}

double re::EncoderOPACK<re::FixedArrayInputStream>::beginOptional(uint64_t a1, const char *a2, int a3, unsigned char *a4, int a5)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    uint64_t v22 = 0;
    if (re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v22, 0))
    {
      unsigned __int8 __dst = 0;
      if (*(unsigned char *)(a1 + 40))
      {
LABEL_4:
        uint64_t v9 = *a4;
        LOBYTE(v15) = 3;
        DWORD1(v15) = a5;
        *((void *)&v15 + 1) = a2;
        uint64_t v16 = 0;
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        uint64_t v17 = v9;
        double result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v15);
        *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v22;
        return result;
      }
      uint64_t v11 = *(void *)(a1 + 168);
      if (v11)
      {
        uint64_t v12 = v11 - 1;
        int v13 = *(unsigned __int8 *)(a1 + v11 - 1 + 160);
        *(void *)(a1 + 168) = v12;
      }
      else
      {
        if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL) & 1) == 0)
        {
          re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Optional");
          goto LABEL_4;
        }
        int v13 = __dst;
      }
      if (v13 == 4)
      {
        *a4 = 0;
      }
      else
      {
        *a4 = 1;
        unint64_t v14 = *(void *)(a1 + 168);
        if (v14 <= 7)
        {
          *(void *)(a1 + 168) = v14 + 1;
          *(unsigned char *)(a1 + v14 + 160) = v13;
        }
      }
      goto LABEL_4;
    }
    *a4 = 0;
    LOBYTE(v21[0]) = 3;
    DWORD1(v21[0]) = a5;
    *((void *)&v21[0] + 1) = a2;
    memset(&v21[1], 0, 32);
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, v21);
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::FixedArrayInputStream>::endOptional(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject((uint64_t)v1);
      double result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 3);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if (v10) {
        uint64_t v7 = *(unsigned char **)&v11[7];
      }
      else {
        uint64_t v7 = v11;
      }
      if (*(uint64_t *)(*((void *)v1 + 16) + 48 * *((void *)v1 + 14) - 24) <= 0) {
        uint64_t v8 = "Optional should not have a value.";
      }
      else {
        uint64_t v8 = "Optional requires a value.";
      }
      re::DynamicString::format((re::DynamicString *)"Failed to serialize optional type \"%s\". %s", (re::DynamicString *)v12, v7, v8);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(void *)&v12[0])
      {
        if (BYTE8(v12[0])) {
          (*(void (**)(void))(**(void **)&v12[0] + 40))();
        }
        memset(v12, 0, sizeof(v12));
      }
      double result = v9;
      if (v9 && (v10 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v9 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::beginBLOB(uint64_t a1, const char *a2, int a3, uint64_t *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v16, 0);
  if (result)
  {
    re::EncoderOPACK<re::FixedArrayInputStream>::readDataTag(a1, a2, a4);
    uint64_t v10 = *a4;
    LOBYTE(v11) = 4;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeBLOB(uint64_t result, char *a2, char a3)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  int v4 = (_anonymous_namespace_ *)result;
  uint64_t v5 = *(void *)(result + 128) + 48 * *(void *)(result + 112);
  unint64_t v6 = *(void *)(v5 - 24);
  unint64_t v7 = *(void *)(result + 168);
  if (v7)
  {
    if (v7 >= v6) {
      uint64_t v8 = *(void *)(v5 - 24);
    }
    else {
      uint64_t v8 = *(void *)(result + 168);
    }
    uint64_t v9 = v7 - v8;
    if ((uint64_t)(v7 - 1) >= (uint64_t)(v7 - v8))
    {
      do
      {
        *a2++ = *(unsigned char *)(result + 159 + v7);
        uint64_t v10 = v7 - 2;
        --v7;
      }
      while (v10 >= v9);
    }
    *(void *)(result + 168) = v9;
    size_t v11 = v6 - v8;
    if (v6 == v8) {
      goto LABEL_15;
    }
    goto LABEL_11;
  }
  size_t v11 = *(void *)(v5 - 24);
  if (v6)
  {
LABEL_11:
    if (a3) {
      a2 = 0;
    }
    uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, a2, v11);
    if ((result & 1) == 0) {
      uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v4, 0, (uint64_t)"BLOB");
    }
  }
LABEL_15:
  if ((a3 & 2) == 0)
  {
    uint64_t v12 = *((void *)v4 + 16);
    uint64_t v13 = *((void *)v4 + 14) - 1;
    if (*(unsigned char *)(v12 + 48 * v13) != 2) {
      *(void *)(v12 + 48 * v13 + 32) += v6;
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::FixedArrayInputStream>::endBLOB(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 4);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if (v10) {
        unint64_t v7 = *(unsigned char **)&v11[7];
      }
      else {
        unint64_t v7 = v11;
      }
      uint64_t v8 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize BLOB \"%s\". Expected number of bytes: %lld. Actual number of bytes: %lld.", (re::DynamicString *)v12, v7, *(void *)(v8 - 24), *(void *)(v8 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(void *)&v12[0])
      {
        if (BYTE8(v12[0])) {
          (*(void (**)(void))(**(void **)&v12[0] + 40))();
        }
        memset(v12, 0, sizeof(v12));
      }
      uint64_t result = v9;
      if (v9 && (v10 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v9 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::beginArray(uint64_t a1, const char *a2, int a3, char *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v16, 0);
  if (result)
  {
    re::EncoderOPACK<re::FixedArrayInputStream>::readArrayTag(a1, a2, a4);
    uint64_t v10 = *(void *)a4;
    LOBYTE(v11) = 5;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::FixedArrayInputStream>::endArray(_anonymous_namespace_ *result)
{
  if (*((unsigned char *)result + 40)) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t v2 = *((void *)result + 16);
  uint64_t v3 = *((void *)result + 14) - 1;
  unint64_t v4 = *(void *)(v2 + 48 * v3 + 32);
  if (v4 == *(void *)(v2 + 48 * v3 + 24))
  {
    if (v4 < 0xF)
    {
LABEL_22:
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 5);
      uint64_t v12 = *((void *)v1 + 16);
      uint64_t v13 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v12 + 48 * v13) != 2) {
        ++*(void *)(v12 + 48 * v13 + 32);
      }
      return result;
    }
    LOBYTE(__dst[0]) = 0;
    uint64_t v5 = *((void *)result + 21);
    if (v5)
    {
      uint64_t v6 = v5 - 1;
      int v7 = *((unsigned __int8 *)result + v6 + 160);
      LOBYTE(__dst[0]) = v7;
      *((void *)v1 + 21) = v6;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>(result, (char *)__dst, 1uLL))
      {
        re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v1, 0, (uint64_t)"Array");
LABEL_21:
        uint64_t v2 = *((void *)v1 + 16);
        uint64_t v3 = *((void *)v1 + 14) - 1;
        goto LABEL_22;
      }
      int v7 = LOBYTE(__dst[0]);
    }
    if (v7 != 3)
    {
      uint64_t v10 = re::OPACK::toString(v7);
      return (_anonymous_namespace_ *)re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag(v1, (uint64_t)"Array", (uint64_t)v10);
    }
    goto LABEL_21;
  }
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v14);
  if (v15) {
    uint64_t v8 = *(unsigned char **)&v16[7];
  }
  else {
    uint64_t v8 = v16;
  }
  uint64_t v9 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)__dst, v8, *(void *)(v9 - 24), *(void *)(v9 - 16));
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)__dst);
  if (*(void *)&__dst[0])
  {
    if (BYTE8(__dst[0])) {
      (*(void (**)(void))(**(void **)&__dst[0] + 40))();
    }
    memset(__dst, 0, sizeof(__dst));
  }
  uint64_t result = v14;
  if (v14 && (v15 & 1) != 0) {
    return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v14 + 40))();
  }
  return result;
}

uint64_t re::anonymous namespace'::resizeArray<re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>>(uint64_t a1, void **a2, re::ArrayAccessor *a3, uint64_t a4, const re::TypeInfo *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((const re::TypeInfo *)a4 == a5) {
    return 1;
  }
  v25[10] = v8;
  v25[11] = v9;
  uint64_t v14 = *((void *)a3 + 2);
  if ((*(_DWORD *)(v14 + 84) & 0xFFFFFF) != 0)
  {
    re::TypeRegistry::typeInfo(*(void **)a3, *(void *)(v14 + 72), v24);
    re::TypeInfo::TypeInfo((uint64_t)v22, (uint64_t)v25);
    BOOL v21 = !is_mul_ok(*(unsigned int *)(v23 + 8), (unint64_t)a5);
    if (is_mul_ok(*(unsigned int *)(v23 + 8), (unint64_t)a5)) {
      re::ArrayAccessor::reset(a3, a2, *(re::Allocator **)(a1 + 48), a5);
    }
    else {
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Size overflow during deserialization. Element size = %zu, count = %zu", v16, v17, v18, v19, v20, *(_DWORD *)(v23 + 8));
    }
    return !v21;
  }
  else
  {
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Invalid array size. Expected size = %zu, actual size = %zu", a4, (uint64_t)a5, a6, a7, a8, a4);
    return 0;
  }
}

uint64_t re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setError(_anonymous_namespace_ *a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  re::DynamicString::setCapacity(&v23, 0);
  uint64_t v22 = &a9;
  re::DynamicString::vassignf((re::DynamicString *)&v23, a3, &a9);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v15);
  if (v16) {
    uint64_t v12 = *(unsigned char **)&v17[7];
  }
  else {
    uint64_t v12 = v17;
  }
  if (v24) {
    uint64_t v13 = v25;
  }
  else {
    uint64_t v13 = (char *)&v24 + 1;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to %s \"%s\". Reason: %s", (re::DynamicString *)&v18, "deserialize", v12, v13);
  *(void *)&v21[0] = 400;
  *((void *)&v21[0] + 1) = re::FoundationErrorCategory(void)::instance;
  *(void *)&v21[1] = v18;
  *((void *)&v21[2] + 1) = v20;
  *(long long *)((char *)&v21[1] + 8) = v19;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, v21);
  if (*(void *)&v21[1])
  {
    if (BYTE8(v21[1])) {
      (*(void (**)(void))(**(void **)&v21[1] + 40))();
    }
    memset(&v21[1], 0, 32);
  }
  if (v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  uint64_t result = (uint64_t)v23;
  if (v23)
  {
    if (v24) {
      return (*(uint64_t (**)(void))(*v23 + 40))();
    }
  }
  return result;
}

uint64_t re::anonymous namespace'::resizeList<re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a4 == a5) {
    return 1;
  }
  v23[10] = v5;
  v23[11] = v6;
  re::TypeRegistry::typeInfo(*(void **)a3, *(void *)(*(void *)(a3 + 16) + 72), v22);
  re::TypeInfo::TypeInfo((uint64_t)v20, (uint64_t)v23);
  BOOL v17 = !is_mul_ok(*(unsigned int *)(v21 + 8), a5);
  if (is_mul_ok(*(unsigned int *)(v21 + 8), a5))
  {
    uint64_t v18 = *(void *)(a1 + 48);
    long long v19 = *(void (**)(uint64_t, unsigned char *, uint64_t, unint64_t))(*(void *)(a3 + 16) + 88);
    re::TypeInfo::TypeInfo((uint64_t)v22, a3);
    v19(a2, v22, v18, a5);
  }
  else
  {
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Size overflow during deserialization. Element size = %zu, count = %zu", v12, v13, v14, v15, v16, *(_DWORD *)(v21 + 8));
  }
  return !v17;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::beginDictionary(uint64_t a1, const char *a2, int a3, char *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v16, 0);
  if (result)
  {
    re::EncoderOPACK<re::FixedArrayInputStream>::readDictionaryTag(a1, a2, a4);
    uint64_t v10 = *(void *)a4;
    LOBYTE(v11) = 6;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::FixedArrayInputStream>::endDictionary(_anonymous_namespace_ *result)
{
  if (*((unsigned char *)result + 40)) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t v2 = *((void *)result + 16);
  uint64_t v3 = *((void *)result + 14) - 1;
  unint64_t v4 = *(void *)(v2 + 48 * v3 + 32);
  if (v4 == *(void *)(v2 + 48 * v3 + 24))
  {
    if (v4 < 0xF)
    {
LABEL_22:
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 6);
      uint64_t v12 = *((void *)v1 + 16);
      uint64_t v13 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v12 + 48 * v13) != 2) {
        ++*(void *)(v12 + 48 * v13 + 32);
      }
      return result;
    }
    LOBYTE(__dst[0]) = 0;
    uint64_t v5 = *((void *)result + 21);
    if (v5)
    {
      uint64_t v6 = v5 - 1;
      int v7 = *((unsigned __int8 *)result + v6 + 160);
      LOBYTE(__dst[0]) = v7;
      *((void *)v1 + 21) = v6;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>(result, (char *)__dst, 1uLL))
      {
        re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v1, 0, (uint64_t)"Dictionary");
LABEL_21:
        uint64_t v2 = *((void *)v1 + 16);
        uint64_t v3 = *((void *)v1 + 14) - 1;
        goto LABEL_22;
      }
      int v7 = LOBYTE(__dst[0]);
    }
    if (v7 != 3)
    {
      uint64_t v10 = re::OPACK::toString(v7);
      return (_anonymous_namespace_ *)re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag(v1, (uint64_t)"Dictionary", (uint64_t)v10);
    }
    goto LABEL_21;
  }
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v14);
  if (v15) {
    uint64_t v8 = *(unsigned char **)&v16[7];
  }
  else {
    uint64_t v8 = v16;
  }
  uint64_t v9 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)__dst, v8, *(void *)(v9 - 24), *(void *)(v9 - 16));
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)__dst);
  if (*(void *)&__dst[0])
  {
    if (BYTE8(__dst[0])) {
      (*(void (**)(void))(**(void **)&__dst[0] + 40))();
    }
    memset(__dst, 0, sizeof(__dst));
  }
  uint64_t result = v14;
  if (v14 && (v15 & 1) != 0) {
    return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v14 + 40))();
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::beginObject(uint64_t a1, const char *a2, int a3, int a4)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v20 = 0;
  if (!re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v20, 0)) {
    return 0;
  }
  unsigned __int8 __dst = 0;
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 168);
  if (v9)
  {
    uint64_t v10 = v9 - 1;
    int v11 = *(unsigned __int8 *)(a1 + v10 + 160);
    unsigned __int8 __dst = *(unsigned char *)(a1 + v10 + 160);
    *(void *)(a1 + 168) = v10;
  }
  else
  {
    if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL) & 1) == 0)
    {
      re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Object");
      return 0;
    }
    int v11 = __dst;
  }
  if (v11 != 223 && v11 != 239)
  {
    uint64_t v13 = re::OPACK::toString(v11);
    re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::setErrorUnexpectedTag((_anonymous_namespace_ *)a1, (uint64_t)"Object", (uint64_t)v13);
    return 0;
  }
  uint64_t v7 = 1;
  if (v11 == 223) {
    char v12 = 1;
  }
  else {
    char v12 = 2;
  }
  LOBYTE(v14) = v12;
  DWORD1(v14) = a4;
  *((void *)&v14 + 1) = a2;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  unint64_t v17 = 0xFFFFFFFF80000000;
  uint64_t v18 = 0;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v14);
  *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v20;
  return v7;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::endObject(uint64_t result)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  uint64_t v1 = result;
  unsigned __int8 __dst = 0;
  while (1)
  {
    uint64_t v2 = *(void *)(v1 + 168);
    if (v2)
    {
      uint64_t v3 = v2 - 1;
      int v4 = *(unsigned __int8 *)(v1 + v2 - 1 + 160);
      unsigned __int8 __dst = v4;
      *(void *)(v1 + 168) = v3;
      goto LABEL_7;
    }
    uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)v1, (char *)&__dst, 1uLL);
    if (!result) {
      break;
    }
    int v4 = __dst;
LABEL_7:
    if (v4 == 3) {
      goto LABEL_13;
    }
    unint64_t v5 = *(void *)(v1 + 168);
    if (v5 <= 7)
    {
      *(void *)(v1 + 168) = v5 + 1;
      *(unsigned char *)(v1 + v5 + 160) = v4;
    }
    uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(v1);
    if (*(unsigned char *)(v1 + 40)) {
      return result;
    }
  }
  uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)v1, 0, (uint64_t)"Object");
LABEL_13:
  if (!*(unsigned char *)(v1 + 40))
  {
    uint64_t v6 = *(void *)(v1 + 128);
    uint64_t v7 = *(void *)(v1 + 112) - 1;
    uint64_t v8 = *(void *)(v6 + 48 * v7 + 16);
    if (v8)
    {
      do
      {
        --v8;
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject(v1);
      }
      while (v8);
      uint64_t v6 = *(void *)(v1 + 128);
      uint64_t v7 = *(void *)(v1 + 112) - 1;
    }
    uint64_t result = (uint64_t)re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState((_anonymous_namespace_ *)v1, *(unsigned __int8 *)(v6 + 48 * v7));
    uint64_t v9 = *(void *)(v1 + 128);
    uint64_t v10 = *(void *)(v1 + 112) - 1;
    if (*(unsigned char *)(v9 + 48 * v10) != 2) {
      ++*(void *)(v9 + 48 * v10 + 32);
    }
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (long long v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v35 = 0;
    int v20 = re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v35, 0);
    BOOL result = 0;
    if (!v20) {
      return result;
    }
    if (v35) {
      re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  unint64_t v23 = a4[1];
  if (v23) {
    unint64_t v24 = v23 >> 1;
  }
  else {
    unint64_t v24 = v23 >> 1;
  }
  unint64_t v35 = v24;
  int v25 = re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v35, 0);
  BOOL result = 0;
  if (v25)
  {
    unint64_t v26 = v35;
    if (v26 <= (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))())
    {
      if (!*a4)
      {
        size_t v33 = v35 + 1;
        *a4 = *(void *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v33);
      }
      re::DynamicString::resize(a4, v35, 0);
      if (v35)
      {
        if (a4[1]) {
          int v34 = (char *)a4[2];
        }
        else {
          int v34 = (char *)a4 + 9;
        }
        re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, v34, 0);
      }
      uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      re::EncoderOPACK<re::FixedArrayInputStream>::endString(v22);
      return *(unsigned char *)(a1 + 64) == 0;
    }
    char v27 = v35;
    (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v28, v29, v30, v31, v32, v27);
    return 0;
  }
  return result;
}

uint64_t re::internal::serializeObjectWithOneMember<re::EncoderOPACK<re::FixedArrayInputStream>>(unsigned char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)v29, *a5, a5[2]);
  re::TypeMemberCollection::operator[](v14, 0, (uint64_t)&v27);
  uint64_t v15 = a4 + *(unsigned int *)(v28 + 24);
  re::TypeRegistry::typeInfo(v27, *(void *)v28, v29);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v30);
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*a5 == *a6)
  {
    uint64_t v18 = *(void *)a5[2];
    uint64_t v19 = a6[2];
    uint64_t v20 = *(void *)v19;
    if ((unsigned __int16)v18 != (unsigned __int16)*(void *)v19) {
      goto LABEL_14;
    }
    BOOL v22 = WORD1(v18) == WORD1(v20);
    uint64_t v21 = (v20 ^ v18) & 0xFFFFFF00000000;
    BOOL v22 = v22 && v21 == 0;
    if (!v22) {
      goto LABEL_14;
    }
LABEL_4:
    if (!a1[64]) {
      return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v26, a7);
    }
    return 0;
  }
  if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, v16)) {
    goto LABEL_4;
  }
  uint64_t v19 = a6[2];
LABEL_14:
  if (*(_DWORD *)(v19 + 88) != 1)
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
    return 0;
  }
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v23, *a6, v19);
  re::TypeMemberCollection::operator[](v23, 0, (uint64_t)v24);
  re::TypeRegistry::typeInfo(v24[0], *v24[2], v29);
  re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v30);
  if (a1[64]) {
    return 0;
  }
  return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v25, a7);
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::beginString(uint64_t a1, const char *a2, int a3, uint64_t *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v16, 0);
  if (result)
  {
    re::EncoderOPACK<re::FixedArrayInputStream>::readStringTag(a1, a2, a4);
    uint64_t v10 = *a4;
    LOBYTE(v11) = 8;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
    *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v16;
    return *(unsigned char *)(a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(uint64_t result, char *a2, char a3)
{
  if (*(unsigned char *)(result + 40)) {
    return result;
  }
  int v4 = (_anonymous_namespace_ *)result;
  uint64_t v5 = *(void *)(result + 128) + 48 * *(void *)(result + 112);
  unint64_t v6 = *(void *)(v5 - 24);
  unint64_t v7 = *(void *)(result + 168);
  if (v7)
  {
    if (v7 >= v6) {
      uint64_t v8 = *(void *)(v5 - 24);
    }
    else {
      uint64_t v8 = *(void *)(result + 168);
    }
    uint64_t v9 = v7 - v8;
    if ((uint64_t)(v7 - 1) >= (uint64_t)(v7 - v8))
    {
      do
      {
        *a2++ = *(unsigned char *)(result + 159 + v7);
        uint64_t v10 = v7 - 2;
        --v7;
      }
      while (v10 >= v9);
    }
    *(void *)(result + 168) = v9;
    size_t v11 = v6 - v8;
    if (v6 == v8) {
      goto LABEL_15;
    }
    goto LABEL_11;
  }
  size_t v11 = *(void *)(v5 - 24);
  if (v6)
  {
LABEL_11:
    if (a3) {
      a2 = 0;
    }
    uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, a2, v11);
    if ((result & 1) == 0) {
      uint64_t result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v4, 0, (uint64_t)"String");
    }
  }
LABEL_15:
  if ((a3 & 2) == 0)
  {
    uint64_t v12 = *((void *)v4 + 16);
    uint64_t v13 = *((void *)v4 + 14) - 1;
    if (*(unsigned char *)(v12 + 48 * v13) != 2) {
      *(void *)(v12 + 48 * v13 + 32) += v6;
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::FixedArrayInputStream>::endString(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 8);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if (v10) {
        unint64_t v7 = *(unsigned char **)&v11[7];
      }
      else {
        unint64_t v7 = v11;
      }
      uint64_t v8 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize string \"%s\". Expected number of characters: %lld. Actual number of characters: %lld.", (re::DynamicString *)v12, v7, *(void *)(v8 - 24), *(void *)(v8 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(void *)&v12[0])
      {
        if (BYTE8(v12[0])) {
          (*(void (**)(void))(**(void **)&v12[0] + 40))();
        }
        memset(v12, 0, sizeof(v12));
      }
      uint64_t result = v9;
      if (v9 && (v10 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v9 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>(unsigned char *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v21);
  if (v21[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)&v22);
    if (*(_DWORD *)(v19 + 88) || (re::TypeRegistry::typeInfo(v18[0], *(void *)(v19 + 72), v23), v23[0]))
    {
      if (re::EncoderOPACK<re::FixedArrayInputStream>::beginObject((uint64_t)(a1 + 24), "@super", 0, 0))
      {
        re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, v18, a4);
        re::EncoderOPACK<re::FixedArrayInputStream>::endObject((uint64_t)(a1 + 24));
      }
    }
  }
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v18, *a3, a3[2]);
  if (v20)
  {
    for (unint64_t i = 0; i < v20; ++i)
    {
      if (a1[64]) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v18, i, (uint64_t)&v16);
      if (*(unsigned char *)(v17 + 28))
      {
        uint64_t v10 = *(void *)(v17 + 16);
        if (strlen((const char *)v10) >= 3 && *(unsigned char *)v10 == 109) {
          v10 += 2 * (*(unsigned char *)(v10 + 1) == 95);
        }
        uint64_t v11 = *(unsigned int *)(v17 + 32);
        uint64_t v12 = a2 + *(unsigned int *)(v17 + 24);
        re::TypeRegistry::typeInfo(v16, *(void *)v17, v23);
        re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v24);
        if (a1[64]
          || (uint64_t result = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v10, v11, v12, v15, v15, a4), (result & 1) == 0))
        {
          uint64_t result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a3);
          if (v13)
          {
            uint64_t v14 = (_DWORD *)(result + 16);
            while (i != *v14)
            {
              v14 += 6;
              if (!--v13) {
                goto LABEL_22;
              }
            }
            if (!a1[64]) {
              uint64_t result = (*(uint64_t (**)(unsigned char *, void, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, *((void *)v14 - 1), v11, v12, v15, v15, a4);
            }
          }
        }
      }
LABEL_22:
      ;
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v53);
  re::TypeRegistry::typeInfo((void *)*a4, *(void *)(a4[2] + 72), v49);
  if (v49[0])
  {
    if (!v53[0])
    {
      uint64_t v11 = re::TypeInfo::name((re::TypeInfo *)&v50)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (re::EncoderOPACK<re::FixedArrayInputStream>::beginObject(a1 + 24, "@super", 0, 0))
    {
      if (v54 == v50)
      {
        uint64_t v18 = *v56;
        uint64_t v19 = *v52;
        if ((unsigned __int16)*v56 == (unsigned __int16)*v52)
        {
          BOOL v21 = WORD1(v18) == WORD1(v19);
          uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
          BOOL v21 = v21 && v20 == 0;
          if (v21) {
            goto LABEL_6;
          }
        }
      }
      else if (re::areSameTranslatedVersion((re *)&v54, (const re::TypeInfo *)&v50, v10))
      {
LABEL_6:
        re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>((unsigned char *)a1, a2, &v54, a5);
LABEL_16:
        re::EncoderOPACK<re::FixedArrayInputStream>::endObject(a1 + 24);
        goto LABEL_17;
      }
      if (v55 == v51)
      {
        re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, &v54, &v50, a5);
      }
      else
      {
        uint64_t v22 = re::TypeInfo::name((re::TypeInfo *)&v54)[1];
        re::TypeInfo::name((re::TypeInfo *)&v50);
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
      }
      goto LABEL_16;
    }
  }
LABEL_17:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v48, *a3, a3[2]);
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v46, *a4, a4[2]);
  if (v47)
  {
    for (unint64_t i = 0; i < v47; ++i)
    {
      if (*(unsigned char *)(a1 + 64)) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[](v46, i, (uint64_t)v44);
      if (*(unsigned char *)(v45 + 28))
      {
        uint64_t v29 = *(void *)(v45 + 16);
        if (strlen((const char *)v29) >= 3 && *(unsigned char *)v29 == 109) {
          v29 += 2 * (*(unsigned char *)(v29 + 1) == 95);
        }
        uint64_t v30 = *(unsigned int *)(v45 + 32);
        uint64_t v31 = *(re **)(*a4 + 856);
        if (!v31
          || (uint64_t v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v44),
              v31 == -1))
        {
          unint64_t v35 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            uint64_t v36 = v35;
            uint64_t v37 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            uint64_t v58 = v37;
            __int16 v59 = 2080;
            uint64_t v60 = v29;
            _os_log_impl(&dword_233120000, v36, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          uint64_t v38 = *(re::internal **)(a1 + 208);
          re::TypeRegistry::typeInfo(v44[0], *(void *)v45, buf);
          re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v58 + 4);
          uint64_t result = re::internal::translateType(v38, (const re::TypeRegistry *)v42, (uint64_t)buf);
          if (!*(unsigned char *)(a1 + 64)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint8_t *, uint8_t *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
          }
        }
        else
        {
          re::TypeMemberCollection::operator[](v48, (int)v31, (uint64_t)v42);
          uint64_t v32 = a2 + *(unsigned int *)(v43 + 24);
          re::TypeRegistry::typeInfo(v42[0], *(void *)v43, buf);
          re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v58 + 4);
          re::TypeRegistry::typeInfo(v44[0], *(void *)v45, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v58 + 4);
          if (*(unsigned char *)(a1 + 64)
            || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, v32, v41, v40, a5), (result & 1) == 0))
          {
            uint64_t result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a4);
            if (v33)
            {
              int v34 = (_DWORD *)(result + 16);
              while (i != *v34)
              {
                v34 += 6;
                if (!--v33) {
                  goto LABEL_37;
                }
              }
              uint64_t v39 = *((void *)v34 - 1);
              re::TypeRegistry::typeInfo(v42[0], *(void *)v43, buf);
              re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v58 + 4);
              re::TypeRegistry::typeInfo(v44[0], *(void *)v45, buf);
              uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v58 + 4);
              if (!*(unsigned char *)(a1 + 64)) {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v39, v30, v32, v41, v40, a5);
              }
            }
          }
        }
      }
LABEL_37:
      ;
    }
  }
  return result;
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::deserializeSharedObjects(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!*(unsigned char *)(result + 64))
  {
    uint64_t v9 = result;
    uint64_t v10 = result + 24;
    uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::beginObject(result + 24, "@shared", 20, 0);
    if (result)
    {
      uint64_t v16 = *(void *)(v9 + 56);
      unint64_t v98 = 0;
      uint64_t v99 = 0;
      uint64_t v96 = v16;
      uint64_t v97 = 0;
      re::DynamicString::setCapacity(&v96, 8uLL);
      uint64_t v17 = v9 + 400;
      LODWORD(v90) = 0;
      uint64_t v18 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(v9 + 400, (unsigned int *)&v90);
      if (v18) {
        *((void *)&v95 + 1) = **(void **)(v18 + 24);
      }
      else {
        *((void *)&v95 + 1) = 0xFFFFFFFFLL;
      }
      if (*(void *)(v9 + 376))
      {
        uint64_t v77 = v10;
        uint64_t v19 = 0;
        unint64_t v20 = 0;
        LODWORD(v21) = *(_DWORD *)(v9 + 428) - 1;
        uint64_t v22 = (char *)&v97 + 1;
        do
        {
          uint64_t v23 = (long long *)(*(void *)(v9 + 392) + v19);
          long long v90 = *v23;
          re::TypeInfo::TypeInfo((uint64_t)v91, (uint64_t)(v23 + 1));
          re::TypeInfo::TypeInfo((uint64_t)v93, (uint64_t)(v23 + 3));
          __int16 v94 = *((_WORD *)v23 + 40);
          if ((v90 & 0x80000000) != 0)
          {
            re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, 0, "Invalid referenceID %u.", v24, v25, v26, v27, v28, v90);
            goto LABEL_71;
          }
          re::TypeRegistry::typeInfo((void *)v91[0], *(void *)(v92 + 72), &v80);
          re::TypeInfo::TypeInfo((uint64_t)v89, (uint64_t)&v81);
          re::TypeRegistry::typeInfo(v93[0], v93[2][9], &v80);
          re::TypeInfo::TypeInfo((uint64_t)&v85, (uint64_t)&v81);
          if ((int)v90 > (int)v21)
          {
            re::DynamicString::assignf((re::DynamicString *)&v96, "%u", v90);
            uint64_t v21 = v90;
            if ((_BYTE)v94)
            {
              if (v97) {
                uint64_t v29 = v98;
              }
              else {
                uint64_t v29 = v22;
              }
              if (!re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::FixedArrayInputStream>,false>(v9, v29, v90, *((void ***)&v90 + 1), v91, (re::TypeInfo *)v89, (re::TypeInfo *)&v85, HIBYTE(v94), 0))goto LABEL_64; {
            }
              }
            else
            {
              unint64_t v35 = v22;
              uint64_t v36 = **((void **)&v90 + 1);
              if (!**((void **)&v90 + 1))
              {
                Instance = re::TypeInfo::createInstance((re::TypeInfo *)v89, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                **((void **)&v90 + 1) = Instance;
                uint64_t v36 = **((void **)&v90 + 1);
              }
              char v38 = v97;
              uint64_t v39 = v98;
              re::TypeRegistry::typeInfo((void *)v91[0], *(void *)(v92 + 72), &v80);
              re::TypeInfo::TypeInfo((uint64_t)v84, (uint64_t)&v81);
              if (*(unsigned char *)(v9 + 64)) {
                goto LABEL_69;
              }
              if (v38) {
                uint64_t v40 = v39;
              }
              else {
                uint64_t v40 = v35;
              }
              uint64_t v22 = v35;
              char v41 = (*(uint64_t (**)(uint64_t, const char *, uint64_t, uint64_t, _DWORD *, uint64_t *, void))(*(void *)v9 + 72))(v9, v40, v21, v36, v84, &v85, 0);
              uint64_t v17 = v9 + 400;
              if ((v41 & 1) == 0)
              {
LABEL_64:
                if (!*(unsigned char *)(v9 + 64))
                {
                  if (v97) {
                    uint64_t v64 = v98;
                  }
                  else {
                    uint64_t v64 = v22;
                  }
                  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, v64, "Failed to deserialize shared object (reference ID = %d).", v30, v31, v32, v33, v34, v21);
                }
LABEL_69:
                if (**((void **)&v90 + 1))
                {
                  re::TypeInfo::releaseInstance((re::TypeInfo *)v89, **((void ***)&v90 + 1), *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                  **((void **)&v90 + 1) = 0;
                }
                goto LABEL_71;
              }
            }
            uint64_t v42 = **((void **)&v90 + 1);
            v84[0] = v21;
            uint64_t v80 = v42;
            re::TypeInfo::TypeInfo((uint64_t)&v81, (uint64_t)v89);
            re::TypeInfo::TypeInfo((uint64_t)v83, (uint64_t)&v85);
            v83[16] = v94;
            re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew(v17, v84, (uint64_t)&v80);
          }
          ++v20;
          unint64_t v43 = *(void *)(v9 + 376);
          v19 += 88;
        }
        while (v43 > v20);
        *(void *)&long long v95 = 0;
        *((void *)&v95 + 1) = 0xFFFFFFFFLL;
        uint64_t v10 = v77;
        if (v43)
        {
          uint64_t v44 = 0;
          uint64_t v45 = *(void *)(v9 + 392);
          uint64_t v46 = 88 * v43;
          int v47 = -1;
          do
          {
            re::TypeRegistry::typeInfo(*(void **)(v45 + 16), *(void *)(*(void *)(v45 + 32) + 72), &v90);
            re::TypeInfo::TypeInfo((uint64_t)&v80, (uint64_t)&v90 + 8);
            re::TypeRegistry::typeInfo(*(void **)(v45 + 48), *(void *)(*(void *)(v45 + 64) + 72), &v90);
            re::TypeInfo::TypeInfo((uint64_t)v89, (uint64_t)&v90 + 8);
            int v48 = *(_DWORD *)v45;
            if (*(_DWORD *)v45 == v47)
            {
              long long v79 = v95;
              if (!re::internal::areCompatible((re **)(v45 + 16), (uint64_t)&v79))
              {
                uint64_t v65 = re::TypeInfo::name((re::TypeInfo *)&v80)[1];
                re::TypeRegistry::typeName(*(_anonymous_namespace_ **)(v9 + 208), &v95);
                re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, 0, "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".", v66, v67, v68, v69, v70, v65);
                goto LABEL_71;
              }
              uint64_t v49 = **(char ****)(v45 + 8);
              if (v49) {
                BOOL v50 = v49 == v44;
              }
              else {
                BOOL v50 = 1;
              }
              if (!v50) {
                re::TypeInfo::releaseInstance((re::TypeInfo *)&v80, v49, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
              }
              re::TypeInfo::TypeInfo((uint64_t)&v90, (uint64_t)&v80);
              if (*(unsigned char *)(v45 + 80))
              {
                if (!(void)v95)
                {
                  uint64_t v76 = re::TypeInfo::name((re::TypeInfo *)&v80)[1];
                  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, 0, "Invalid reference. Polymorphic type \"%s\" has invalid actual type.", v71, v72, v73, v74, v75, v76);
                  goto LABEL_71;
                }
                LODWORD(v85) = v47;
                uint64_t v51 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(v17, (unsigned int *)&v85);
                if (!v51)
                {
                  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, 0, "Invalid reference. No such object %z", v52, v53, v54, v55, v56, v47);
                  goto LABEL_71;
                }
                re::TypeInfo::operator=((uint64_t)&v90, v51 + 8);
              }
              uint64_t v57 = *(char ***)(v45 + 8);
              if ((*((unsigned char *)v82 + 49) & 2) != 0)
              {
                *uint64_t v57 = (char *)v44;
                uint64_t v61 = (void (*)(char **))v82[4];
                if (v61) {
                  v61(v44);
                }
                if (*(unsigned char *)(v45 + 80))
                {
                  uint64_t v62 = *(void *)(v45 + 8);
                  char v63 = *(re **)v91[0];
                  v78[0] = (re *)v90;
                  v78[1] = v63;
                  re::TypeInfo::setActualTypeForPointer((void **)(v45 + 16), v62, v78);
                }
              }
              else
              {
                if (*v57)
                {
                  if (*(unsigned char *)(v45 + 80))
                  {
                    re::TypeInfo::getActualTypeFromPointer((uint64_t)&v80, *v57, &v85);
                    if (v85 != (void)v90
                      || (uint64_t v58 = *(void *)v91[0], v86 != (unsigned __int16)*(void *)v91[0])
                      || v87 != WORD1(v58)
                      || ((v88 ^ HIDWORD(v58)) & 0xFFFFFF) != 0)
                    {
                      re::TypeInfo::releaseInstance((re::TypeInfo *)&v80, **(void ***)(v45 + 8), *(re::Allocator **)(v9 + 48), 0);
                    }
                  }
                }
                __int16 v59 = **(void ****)(v45 + 8);
                if (!v59)
                {
                  **(void **)(v45 + 8) = re::TypeInfo::createInstance((re::TypeInfo *)&v90, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                  __int16 v59 = **(void ****)(v45 + 8);
                }
                re::TypeInfo::copy((re::TypeInfo *)&v90, v59, v44, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
              }
            }
            else if (v48 > v47)
            {
              uint64_t v44 = **(char ****)(v45 + 8);
              uint64_t v60 = *v82;
              *(void *)&long long v95 = v80;
              *((void *)&v95 + 1) = v60;
              int v47 = v48;
            }
            v45 += 88;
            v46 -= 88;
          }
          while (v46);
        }
      }
      re::EncoderOPACK<re::FixedArrayInputStream>::endObject(v10);
LABEL_71:
      uint64_t result = v96;
      if (v96)
      {
        if (v97) {
          return (*(uint64_t (**)(void))(*(void *)v96 + 40))();
        }
      }
    }
    else if (!*(unsigned char *)(v9 + 64) && *(void *)(v9 + 376))
    {
      return re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, "@shared", "Failed to deserialize shared objects. Entry not found.", v11, v12, v13, v14, v15, a9);
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(uint64_t a1, unsigned int *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = *a2;
  unint64_t v3 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v6 + 96 * v4 + 12) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 96 * v4 + 8) & 0x7FFFFFFF;
      if (v4 == 0x7FFFFFFF) {
        break;
      }
      if (*(_DWORD *)(v6 + 96 * v4 + 12) == v2) {
        return v6 + 96 * v4 + 16;
      }
    }
    return 0;
  }
  return v6 + 96 * v4 + 16;
}

BOOL re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::FixedArrayInputStream>,false>(uint64_t a1, const char *a2, uint64_t a3, void **a4, re **a5, re::TypeInfo *a6, re::TypeInfo *a7, int a8, char a9)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  uint64_t v15 = a1 + 24;
  int v16 = re::EncoderOPACK<re::FixedArrayInputStream>::beginObject(a1 + 24, a2, 0, 0);
  BOOL result = 0;
  if (v16)
  {
    uint64_t v46 = 0;
    if ((re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned long long>(v15, "customClassID", 1, (char *)&v46, 0) & 1) == 0)return 0; {
    re::TypeInfo::typeIDForCustomClassID(a7, v46, v45);
    }
    if (v45[0])
    {
      if ((a9 & 1) == 0 && *a4)
      {
        re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
        *a4 = 0;
      }
      re::TypeRegistry::typeInfo(*(re **)a7, v45, buf);
      re::TypeInfo::TypeInfo((uint64_t)&v41, (uint64_t)&v48 + 4);
      if (a8)
      {
        uint64_t v18 = *(re::TypeRegistry **)(a1 + 208);
      }
      else
      {
        uint64_t v18 = *(re::TypeRegistry **)(a1 + 208);
        if (*a5 == v18)
        {
          re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&v41);
          uint64_t v27 = v45[0];
          uint64_t v28 = v45[1];
          if (a9)
          {
LABEL_30:
            Instance = 0;
            goto LABEL_37;
          }
LABEL_36:
          Instance = re::TypeInfo::createInstance(a6, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
          *a4 = Instance;
          v37[0] = v27;
          v37[1] = v28;
          re::internal::setActualType(a4, a5, v37);
LABEL_37:
          v36[0] = v27;
          v36[1] = v28;
          (*(void (**)(uint64_t, void **, void *))(*(void *)a1 + 16))(a1, Instance, v36);
          if (!*(unsigned char *)(a1 + 64)) {
            (*(void (**)(uint64_t, const char *, uint64_t, void **, re::TypeInfo *, uint64_t **, BOOL))(*(void *)a1 + 72))(a1, "object", 10, Instance, a6, &v41, Instance == 0);
          }
LABEL_39:
          (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
          re::EncoderOPACK<re::FixedArrayInputStream>::endObject(v15);
          return *(unsigned char *)(a1 + 64) == 0;
        }
      }
      uint64_t v25 = re::TypeInfo::name((re::TypeInfo *)&v41);
      uint64_t v26 = re::TypeRegistry::typeInfo(v18, (const re::StringID *)v25, buf);
      if (!buf[0] || !*(unsigned char *)(*(void *)&v50[10] + 120))
      {
        uint64_t v30 = *re::foundationSerializationLogObjects((re *)v26);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v31 = v30;
          uint64_t v32 = re::TypeInfo::name((re::TypeInfo *)&v41)[1];
          *(_DWORD *)buf = 136315138;
          uint64_t v48 = v32;
          _os_log_impl(&dword_233120000, v31, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", buf, 0xCu);
        }
        v38[0] = 0;
        v38[1] = 0xFFFFFFFFLL;
        (*(void (**)(uint64_t, void, void *))(*(void *)a1 + 16))(a1, 0, v38);
        if (!*(unsigned char *)(a1 + 64)) {
          (*(void (**)(uint64_t, const char *, uint64_t, void, uint64_t **, uint64_t **, uint64_t))(*(void *)a1 + 72))(a1, "object", 10, 0, &v41, &v41, 1);
        }
        goto LABEL_39;
      }
      re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&v48 + 4);
      uint64_t v27 = *(re **)a6;
      uint64_t v28 = (re *)**((void **)a6 + 2);
      if (a9) {
        goto LABEL_30;
      }
      goto LABEL_36;
    }
    if ((a9 & 1) == 0 && *a4)
    {
      re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
      *a4 = 0;
    }
    uint64_t v19 = re::TypeInfo::name(a7);
    if ((unint64_t)*v19 >> 1 == 0x36D724013CDDLL)
    {
      unint64_t v20 = (char *)v19[1];
      if (v20 == "Component" || (uint64_t v19 = (uint64_t *)strcmp(v20, "Component"), !v19))
      {
        uint64_t v19 = (uint64_t *)re::EncoderOPACK<re::FixedArrayInputStream>::checkForString(v15, 10);
        if (v19)
        {
          uint64_t v42 = 0;
          unint64_t v43 = 0;
          uint64_t v44 = 0;
          re::DynamicString::setCapacity(&v41, 0);
          uint64_t v21 = *(re::TypeRegistry **)(a1 + 208);
          v39[0] = 0x2686EB529B3EE220;
          v39[1] = "DynamicString";
          re::TypeRegistry::typeInfo(v21, (const re::StringID *)v39, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v48 + 4);
          re::StringID::destroyString((re::StringID *)v39);
          BOOL v22 = re::serializeDynamicString<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, "object", (const re::TypeInfo *)0xA, &v41, (re *)v40, (const re::TypeInfo *)v40, 0);
          if (v22)
          {
            uint64_t v23 = *re::foundationSerializationLogObjects((re *)v22);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              if (v42) {
                uint64_t v24 = v43;
              }
              else {
                uint64_t v24 = (char *)&v42 + 1;
              }
              *(_DWORD *)buf = 134218498;
              uint64_t v48 = v46;
              __int16 v49 = 1040;
              *(_DWORD *)BOOL v50 = 256;
              *(_WORD *)&v50[4] = 2080;
              *(void *)&void v50[6] = v24;
              _os_log_impl(&dword_233120000, v23, OS_LOG_TYPE_DEFAULT, "Skipping unknown Component %llu. String data: %.256s", buf, 0x1Cu);
            }
            if (v41 && (v42 & 1) != 0) {
              (*(void (**)(void))(*v41 + 40))();
            }
LABEL_45:
            re::EncoderOPACK<re::FixedArrayInputStream>::endObject(v15);
            return 1;
          }
          uint64_t v19 = v41;
          if (v41 && (v42 & 1) != 0) {
            uint64_t v19 = (uint64_t *)(*(uint64_t (**)(void))(*v41 + 40))();
          }
        }
      }
    }
    uint64_t v33 = *re::foundationSerializationLogObjects((re *)v19);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = v33;
      uint64_t v35 = re::TypeInfo::name(a7)[1];
      *(_DWORD *)buf = 136315394;
      uint64_t v48 = v35;
      __int16 v49 = 2048;
      *(void *)BOOL v50 = v46;
      _os_log_impl(&dword_233120000, v34, OS_LOG_TYPE_DEFAULT, "Skipping unknown polymorphic \"%s\" type. Custom class ID = %llu", buf, 0x16u);
    }
    goto LABEL_45;
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  unint64_t v8 = v7 ^ (v7 >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 96 * v13;
    return v12 + 16;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(_DWORD *)(v11 + 96 * v10 + 12) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 96 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 96 * v10;
  return v12 + 16;
}

BOOL re::EncoderOPACK<re::FixedArrayInputStream>::checkForString(uint64_t a1, char a2)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  unsigned __int8 __dst = 0;
  uint64_t v5 = *(void *)(a1 + 168);
  if (v5)
  {
    uint64_t v6 = v5 - 1;
    int v7 = *(unsigned __int8 *)(a1 + v5 - 1 + 160);
    unsigned __int8 __dst = v7;
    *(void *)(a1 + 168) = v6;
  }
  else
  {
    if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL))
    {
      re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, "check", (uint64_t)"Key");
      return 0;
    }
    int v7 = __dst;
  }
  if (v7 != (a2 + 8))
  {
    unint64_t v10 = *(void *)(a1 + 168);
    if (v10 <= 7)
    {
      BOOL result = 0;
      *(void *)(a1 + 168) = v10 + 1;
      *(unsigned char *)(a1 + v10 + 160) = v7;
      return result;
    }
    return 0;
  }
  unsigned __int8 v13 = 0;
  unint64_t v8 = *(void *)(a1 + 168);
  if (!*(unsigned char *)(a1 + 40))
  {
    if (v8)
    {
      unint64_t v11 = v8 - 1;
      int v12 = *(unsigned __int8 *)(a1 + v11 + 160);
      *(void *)(a1 + 168) = v11;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&v13, 1uLL))
      {
        re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, "check", (uint64_t)"String");
        unint64_t v8 = *(void *)(a1 + 168);
        goto LABEL_10;
      }
      int v12 = v13;
      unint64_t v11 = *(void *)(a1 + 168);
    }
    BOOL result = (v12 - 64) < 0x30;
    if (v11 <= 7)
    {
      *(void *)(a1 + 168) = v11 + 1;
      *(unsigned char *)(a1 + v11 + 160) = v12;
      unint64_t v8 = *(void *)(a1 + 168);
      if (v8 <= 7) {
        goto LABEL_11;
      }
    }
    return result;
  }
LABEL_10:
  BOOL result = 0;
  if (v8 < 8)
  {
LABEL_11:
    unsigned __int8 v9 = __dst;
    *(void *)(a1 + 168) = v8 + 1;
    *(unsigned char *)(a1 + v8 + 160) = v9;
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 96 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 96 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 96 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 96 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 96 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 96 * v10) = a3;
  *(_DWORD *)(*(void *)(a1 + 16) + 96 * v10 + 12) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + 96 * v10;
  *(void *)(v14 + 16) = *(void *)a5;
  re::TypeInfo::TypeInfo(v14 + 24, a5 + 8);
  re::TypeInfo::TypeInfo(v14 + 56, a5 + 40);
  *(_WORD *)(v14 + 88) = *(_WORD *)(a5 + 72);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 12, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 96;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 96 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t *re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 208);
  BOOL result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5) {
    BOOL v7 = result == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = *result;
    uint64_t v10 = a3;
    unint64_t v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 224, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeBool(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeChar<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeI8<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeI16<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<short>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeI32<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, int *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeI64<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeU8<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeU16<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeU32<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, int *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeU64<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeFloat<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeFloat(a1 + 24, a2, v9, a4, a7);
}

uint64_t re::serializeDouble<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderOPACK<re::FixedArrayInputStream>::serializeDouble(a1 + 24, a2, v9, a4, a7);
}

BOOL re::serializeCString<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_22:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v23 = **((void **)a5 + 2);
    uint64_t v24 = **((void **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24) {
      goto LABEL_22;
    }
    BOOL v26 = WORD1(v23) == WORD1(v24);
    uint64_t v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    BOOL v26 = v26 && v25 == 0;
    if (!v26) {
      goto LABEL_22;
    }
  }
LABEL_4:
  if (a7)
  {
    int v48 = 0;
    int v19 = re::EncoderOPACK<re::FixedArrayInputStream>::beginPointer(a1 + 24, a2, v9, &v48, 0);
    BOOL result = 0;
    if (!v19) {
      return result;
    }
    if (!v48) {
      goto LABEL_12;
    }
    if (v48 != 1)
    {
      size_t v47 = 0;
      if (re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, 0, (uint64_t *)&v47, 0))
      {
        if (v47) {
          re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
        }
        re::EncoderOPACK<re::FixedArrayInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
LABEL_12:
      re::EncoderOPACK<re::FixedArrayInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      goto LABEL_47;
    }
    goto LABEL_16;
  }
  int v48 = 2 * (*a4 != 0);
  int v21 = re::EncoderOPACK<re::FixedArrayInputStream>::beginPointer(a1 + 24, a2, v9, &v48, 0);
  BOOL result = 0;
  if (!v21) {
    return result;
  }
  int v22 = v48;
  if (v48)
  {
    if (v48 == 1)
    {
LABEL_16:
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, v46);
      return 0;
    }
  }
  else
  {
    if (!*a4) {
      goto LABEL_44;
    }
    (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
    *a4 = 0;
    int v22 = v48;
  }
  if (v22 == 2)
  {
    size_t v27 = *a4 ? strlen(*a4) : 0;
    size_t v47 = v27;
    if (re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, 0, (uint64_t *)&v47, 0))
    {
      uint64_t v28 = (char *)*a4;
      unint64_t v29 = v47;
      if (!*a4 || v47 != v27)
      {
        if (v28)
        {
          (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
          *a4 = 0;
          unint64_t v29 = v47;
        }
        unint64_t v30 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
        char v36 = v47;
        if (v29 > v30)
        {
          (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v37, v38, v39, v40, v41, v36);
          return 0;
        }
        uint64_t v42 = v47 == -1;
        uint64_t v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, v47);
          return 0;
        }
        uint64_t v28 = (char *)(*(uint64_t (**)(void, size_t, void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v47 + 1, 0);
        *a4 = v28;
        size_t v27 = v47;
      }
      if (v27)
      {
        re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, v28, 0);
        uint64_t v28 = (char *)*a4;
        uint64_t v44 = v47;
      }
      else
      {
        uint64_t v44 = 0;
      }
      v28[v44] = 0;
      re::EncoderOPACK<re::FixedArrayInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    }
  }
LABEL_44:
  re::EncoderOPACK<re::FixedArrayInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  int v45 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(unsigned char *)(a1 + 64)) {
    return v45 == 0;
  }
  (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  int v45 = *(unsigned __int8 *)(a1 + 64);
  return v45 == 0;
}

BOOL re::serializeStringID<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9 = (int)a3;
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (int v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v47 = 0;
    int v20 = re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v47, 0);
    BOOL result = 0;
    if (!v20) {
      return result;
    }
    if (v47) {
      re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    }
    goto LABEL_26;
  }
  unint64_t v46 = 0;
  if (re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v46, 0))
  {
    unint64_t v22 = v46;
    if (v46)
    {
      unint64_t v23 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
      char v29 = v46;
      if (v22 > v23)
      {
        (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v30, v31, v32, v33, v34, v29);
        return 0;
      }
      uint64_t v36 = v46 == -1;
      uint64_t v37 = v36 << 63 >> 63;
      if (v37 != v36 || v37 < 0)
      {
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v24, v25, v26, v27, v28, v46);
        return 0;
      }
      uint64_t v38 = (char *)(*(uint64_t (**)(void, unint64_t, void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56), v46 + 1, 0);
      uint64_t v39 = (_anonymous_namespace_ *)re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, v38, 0);
      v38[v46] = 0;
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v40 = v44;
      uint64_t v41 = v45;
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v42 = *a4;
      uint64_t v43 = a4[1];
      *a4 = v40;
      a4[1] = (uint64_t)v41;
      unint64_t v47 = v40 & 0xFFFFFFFFFFFFFFFELL | v42 & 1;
      uint64_t v48 = v43;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
      (*(void (**)(void, char *))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v38);
    }
    else
    {
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v35 = a4[1];
      unint64_t v47 = *a4 & 1;
      uint64_t v48 = v35;
      *a4 = 0;
      a4[1] = (uint64_t)"";
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
    }
LABEL_26:
    re::EncoderOPACK<re::FixedArrayInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return 0;
}

uint64_t re::serializeIntrospectionCallbackSerializer<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  int v10 = (int)a3;
  uint64_t v40 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v28 = **((void **)a5 + 2);
    uint64_t v29 = **((void **)a6 + 2);
    if ((unsigned __int16)v28 == (unsigned __int16)v29)
    {
      BOOL v31 = WORD1(v28) == WORD1(v29);
      uint64_t v30 = (v29 ^ v28) & 0xFFFFFF00000000;
      BOOL v31 = v31 && v30 == 0;
      if (v31) {
        goto LABEL_4;
      }
    }
LABEL_32:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_32;
  }
LABEL_4:
  if (a7)
  {
    uint64_t v32 = 0;
    int v14 = re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v10, &v32, 0);
    uint64_t result = 0;
    if (!v14) {
      return result;
    }
    if (v32) {
      re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    }
    re::EncoderOPACK<re::FixedArrayInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
  }
  else
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v32 = *(void *)a5;
    uint64_t v33 = v16;
    LODWORD(v34) = -1;
    *(void *)buf = 0x258C98EAAF29A10ALL;
    *(void *)&buf[8] = "CallbackSerializerAttribute";
    BOOL v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v32, buf);
    re::StringID::destroyString((re::StringID *)buf);
    uint64_t v18 = *v17;
    uint64_t v19 = *(void *)(a1 + 200);
    unint64_t v36 = 0;
    uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v10, (uint64_t *)&v36, 0);
    if (!result) {
      return result;
    }
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v32 = v20;
    uint64_t v33 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    if (v36)
    {
      re::DynamicString::resize(&v32, v36, 0);
      if (v33) {
        int v21 = v34;
      }
      else {
        int v21 = (char *)&v33 + 1;
      }
      re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, v21, 0);
    }
    re::EncoderOPACK<re::FixedArrayInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    unint64_t v22 = (char *)&v33 + 1;
    if (v33) {
      unint64_t v23 = v34;
    }
    else {
      unint64_t v23 = (char *)&v33 + 1;
    }
    uint64_t v24 = (re *)(*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, char *))(v18 + 80))(*(void *)(a1 + 48), v19, v18, a4, v23);
    if ((v24 & 1) == 0)
    {
      uint64_t v25 = *re::foundationSerializationLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        if (v33) {
          unint64_t v22 = v34;
        }
        uint64_t v26 = v25;
        uint64_t v27 = re::TypeInfo::name(a5)[1];
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v22;
        __int16 v38 = 2080;
        uint64_t v39 = v27;
        _os_log_impl(&dword_233120000, v26, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);
      }
    }
    if (v32 && (v33 & 1) != 0) {
      (*(void (**)(void))(*(void *)v32 + 40))();
    }
  }
  return *(unsigned char *)(a1 + 64) == 0;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::beginPointer(uint64_t a1, const char *a2, int a3, int *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  uint64_t v22 = 0;
  uint64_t result = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v22, 0);
  if (result)
  {
    unsigned __int8 __dst = 0;
    if (*(unsigned char *)(a1 + 40))
    {
LABEL_5:
      BOOL v10 = *a4 != 0;
      LOBYTE(v16) = 9;
      DWORD1(v16) = a5;
      *((void *)&v16 + 1) = a2;
      uint64_t v17 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      BOOL v18 = v10;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v16);
      *(void *)(*(void *)(a1 + 128) + 48 * *(void *)(a1 + 112) - 32) = v22;
      return *(unsigned char *)(a1 + 40) == 0;
    }
    uint64_t v11 = *(void *)(a1 + 168);
    if (v11)
    {
      uint64_t v12 = v11 - 1;
      int v13 = *(unsigned __int8 *)(a1 + v11 - 1 + 160);
      unsigned __int8 __dst = v13;
      *(void *)(a1 + 168) = v12;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, (char *)&__dst, 1uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Optional");
        goto LABEL_5;
      }
      int v13 = __dst;
    }
    if (v13 == 4)
    {
      *a4 = 0;
    }
    else
    {
      if ((v13 - 7) > 0x2C) {
        int v14 = 2;
      }
      else {
        int v14 = 1;
      }
      *a4 = v14;
      unint64_t v15 = *(void *)(a1 + 168);
      if (v15 <= 7)
      {
        *(void *)(a1 + 168) = v15 + 1;
        *(unsigned char *)(a1 + v15 + 160) = v13;
      }
    }
    goto LABEL_5;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::FixedArrayInputStream>::endPointer(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    uint64_t v2 = *((void *)result + 16);
    uint64_t v3 = *((void *)result + 14) - 1;
    if (*(void *)(v2 + 48 * v3 + 32) == *(void *)(v2 + 48 * v3 + 24))
    {
      for (uint64_t i = *(void *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject((uint64_t)v1);
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 9);
      uint64_t v5 = *((void *)v1 + 16);
      uint64_t v6 = *((void *)v1 + 14) - 1;
      if (*(unsigned char *)(v5 + 48 * v6) != 2) {
        ++*(void *)(v5 + 48 * v6 + 32);
      }
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v8);
      if (v9) {
        BOOL v7 = *(unsigned char **)&v10[7];
      }
      else {
        BOOL v7 = v10;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". No value was provided.", (re::DynamicString *)v11, v7);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v11);
      if (*(void *)&v11[0])
      {
        if (BYTE8(v11[0])) {
          (*(void (**)(void))(**(void **)&v11[0] + 40))();
        }
        memset(v11, 0, sizeof(v11));
      }
      uint64_t result = v8;
      if (v8 && (v9 & 1) != 0) {
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v8 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  if (!*(void *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  unint64_t v7 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v7);
  if (v8 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  while (*(void *)(v9 + 24 * v8 + 4) != v6)
  {
    uint64_t v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v10 = 3 * v8;
  *(void *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  uint64_t v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v13) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(void *)(*(void *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10 + 4), *(void *)&v13[16] + v10 + 4, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

BOOL re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, uint64_t a7)
{
  isPointerToPolymorphicuint64_t Type = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6) {
    goto LABEL_4;
  }
  if (*(void *)this == *(void *)a6)
  {
    uint64_t v24 = **((void **)this + 2);
    uint64_t v25 = **((void **)a6 + 2);
    if ((unsigned __int16)v24 == (unsigned __int16)v25)
    {
      BOOL v27 = WORD1(v24) == WORD1(v25);
      uint64_t v26 = (v25 ^ v24) & 0xFFFFFF00000000;
      BOOL v27 = v27 && v26 == 0;
      if (v27) {
        goto LABEL_4;
      }
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    int v16 = 0;
    goto LABEL_5;
  }
  if (*((unsigned char *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (uint64_t v28 = re::TypeInfo::name(this), v29 = re::TypeInfo::name(a6), !re::StringID::operator==(v28, v29))))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, this, a6);
    return 0;
  }
  int v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v40);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)&v41);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v40);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v41);
  if (isPointerToPolymorphicType && (a7 & 1) == 0)
  {
    re::internal::actualType(a4, (void **)this, v47);
    if (v47[0]) {
      goto LABEL_8;
    }
LABEL_15:
    BOOL v18 = re::TypeInfo::name(this);
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Failed to get actual type of polymorphic object. Type \"%s\".", v19, v20, v21, v22, v23, v18[1]);
    return 0;
  }
  uint64_t v17 = *(re **)v49[2];
  v47[0] = (re *)v49[0];
  v47[1] = v17;
  if (!v49[0]) {
    goto LABEL_15;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v47, &v40);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v41);
  int v45 = 0;
  if (!re::EncoderOPACK<re::FixedArrayInputStream>::beginPointer(a1 + 24, a2, a3, &v45, 0)) {
    return 0;
  }
  if (v45 == 1)
  {
    unsigned int v44 = 0;
    if (!*(unsigned char *)(a1 + 64))
    {
      re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<unsigned int>((_anonymous_namespace_ *)(a1 + 24), "ID", &v44);
      uint64_t v31 = *(void *)(a1 + 152);
      uint64_t v32 = *(void *)(a1 + 136) - 1;
      if (*(unsigned char *)(v31 + 48 * v32) != 2) {
        ++*(void *)(v31 + 48 * v32 + 32);
      }
      if (!*(unsigned char *)(a1 + 64))
      {
        if ((a7 & 1) == 0)
        {
          unsigned int v40 = v44;
          uint64_t v41 = a4;
          re::TypeInfo::TypeInfo((uint64_t)&v42, (uint64_t)this);
          re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)a6);
          v43[32] = isPointerToPolymorphicType;
          v43[33] = v16;
          unint64_t v33 = *(void *)(a1 + 376);
          if (v33)
          {
            uint64_t v34 = *(_DWORD **)(a1 + 392);
            do
            {
              unint64_t v35 = v33 >> 1;
              unint64_t v36 = &v34[22 * (v33 >> 1)];
              unsigned int v38 = *v36;
              uint64_t v37 = v36 + 22;
              v33 += ~(v33 >> 1);
              if (v40 < v38) {
                unint64_t v33 = v35;
              }
              else {
                uint64_t v34 = v37;
              }
            }
            while (v33);
          }
          else
          {
            uint64_t v34 = *(_DWORD **)(a1 + 392);
          }
          re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::insert((_anonymous_namespace_ *)(a1 + 360), 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v34 - *(void *)(a1 + 392)) >> 3), (uint64_t)&v40);
        }
        goto LABEL_50;
      }
    }
    return 0;
  }
  if (v45)
  {
    if (isPointerToPolymorphicType)
    {
      re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::FixedArrayInputStream>,false>(a1, a2, a3, (void **)a4, (re **)this, (re::TypeInfo *)v46, (re::TypeInfo *)v48, v16, a7);
    }
    else
    {
      if (a7)
      {
        Instance = 0;
      }
      else
      {
        Instance = *a4;
        if (!*a4)
        {
          Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v49, *(re::Allocator **)(a1 + 48), 0);
          *a4 = Instance;
        }
      }
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, char *, void *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, 0, Instance, v49, v48, a7);
      }
    }
  }
  else if ((a7 & 1) == 0)
  {
    if (*a4)
    {
      re::TypeInfo::releaseInstance((re::TypeInfo *)v46, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
      *a4 = 0;
    }
  }
LABEL_50:
  re::EncoderOPACK<re::FixedArrayInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  return *(unsigned char *)(a1 + 64) == 0;
}

uint64_t re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::insert(_anonymous_namespace_ *this, unint64_t a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v4 = *((void *)this + 2);
  if (v4 + 1 <= a2)
  {
    memset(v13, 0, sizeof(v13));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v7 = *((void *)this + 4);
  long long v8 = (_OWORD *)(v7 + 88 * v4);
  if (v4 <= a2)
  {
    _OWORD *v8 = *(_OWORD *)a3;
    uint64_t v11 = v7 + 88 * v4;
    re::TypeInfo::TypeInfo(v11 + 16, a3 + 16);
    uint64_t result = re::TypeInfo::TypeInfo(v11 + 48, a3 + 48);
  }
  else
  {
    uint64_t v9 = v7 + 88 * v4;
    _OWORD *v8 = *(_OWORD *)(v9 - 88);
    re::TypeInfo::TypeInfo(v9 + 16, v9 - 72);
    re::TypeInfo::TypeInfo(v9 + 48, v9 - 40);
    *(_WORD *)(v9 + 80) = *(_WORD *)(v9 - 8);
    uint64_t v10 = 88 * a2;
    std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *>((uint64_t)v13, *((void *)this + 4) + v10, *((void *)this + 4) + 88 * *((void *)this + 2) - 88, *((void *)this + 4) + 88 * *((void *)this + 2));
    uint64_t v11 = *((void *)this + 4) + v10;
    *(_OWORD *)uint64_t v11 = *(_OWORD *)a3;
    re::TypeInfo::operator=(v11 + 16, a3 + 16);
    uint64_t result = re::TypeInfo::operator=(v11 + 48, a3 + 48);
  }
  *(_WORD *)(v11 + 80) = *(_WORD *)(a3 + 80);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x58uLL))
        {
          uint64_t v2 = 88 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 88 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 88, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 88 * v9;
        uint64_t v11 = (uint64_t)(v7 + 6);
        uint64_t v12 = v8 + 48;
        do
        {
          *(_OWORD *)(v11 - 48) = *(_OWORD *)(v12 - 48);
          re::TypeInfo::TypeInfo(v11 - 32, v12 - 32);
          re::TypeInfo::TypeInfo(v11, v12);
          *(_WORD *)(v11 + 32) = *(_WORD *)(v12 + 32);
          v11 += 88;
          uint64_t v13 = v12 + 40;
          v12 += 88;
        }
        while (v13 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0;
    do
    {
      *(_OWORD *)(a4 + v7 - 88) = *(_OWORD *)(a3 + v7 - 88);
      re::TypeInfo::operator=(a4 + v7 - 72, a3 + v7 - 72);
      re::TypeInfo::operator=(a4 + v7 - 40, a3 + v7 - 40);
      *(_WORD *)(a4 + v7 - 8) = *(_WORD *)(a3 + v7 - 8);
      v7 -= 88;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

re::NetworkCompatSerializer *re::NetworkCompatSerializer::NetworkCompatSerializer(re::NetworkCompatSerializer *this)
{
  *(void *)&v4.var0 = 0x287C37956ADFC9C4;
  v4.var1 = "NetworkCompatSerializer";
  uint64_t v2 = re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::SerializerV1((uint64_t)this, &v4);
  *(void *)uint64_t v2 = &unk_26E6C73E0;
  *(_OWORD *)(v2 + 432) = 0u;
  *(_OWORD *)(v2 + 448) = 0u;
  *(void *)(v2 + 184) = v2 + 440;
  re::StringID::destroyString((re::StringID *)&v4);
  *(void *)this = &unk_26E6C7348;
  return this;
}

void re::NetworkCompatSerializer::~NetworkCompatSerializer(re::NetworkCompatSerializer *this)
{
  *(void *)this = &unk_26E6C8C28;
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 392);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 352);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 312);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6C8C28;
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 392);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 352);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 312);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)this);
  JUMPOUT(0x237DBCBD0);
}

void *re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::trackObject(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((void *)(a1 + 256), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::untrackObject(uint64_t result)
{
  if (*(unsigned char *)(result + 256))
  {
    --*(void *)(result + 408);
    ++*(_DWORD *)(result + 416);
  }
  return result;
}

void re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>>::doOpen(uint64_t a1)
{
  *(unsigned char *)(a1 + 257) = 0;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(void *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(void *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(void *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doClose(uint64_t a1)
{
  *(void *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(void *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(void *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v11 = 6059476;
  uint64_t v12 = "BOOL";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 6104748;
  uint64_t v12 = "char";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x172E117BCLL;
  uint64_t v12 = "int8_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93A4A92;
  uint64_t v12 = "int16_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93BFE06;
  uint64_t v12 = "int32_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93EC744;
  uint64_t v12 = "int64_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 6655224;
  uint64_t v12 = "long";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x31CD534126;
  uint64_t v12 = "uint8_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD0D4E68;
  uint64_t v12 = "uint16_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD0F01DCLL;
  uint64_t v12 = "uint32_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD11CB1ALL;
  uint64_t v12 = "uint64_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x1947BDF6CLL;
  uint64_t v12 = "size_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 195052728;
  uint64_t v12 = "float";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x161EEF7A2;
  uint64_t v12 = "double";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 189247272;
  uint64_t v12 = "char*";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2686EB529B3EE220;
  uint64_t v12 = "DynamicString";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x458DDB01A18;
  uint64_t v12 = "StringID";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v2 = *(void *)(a1 + 192);
  uint64_t v11 = 0x258C98EAAF29A10ALL;
  uint64_t v12 = "CallbackSerializerAttribute";
  uint64_t v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    uint64_t v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      uint64_t v5 = *(void *)(a1 + 192);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        uint64_t v6 = a1 + 208;
        uint64_t v7 = (uint64_t *)(v14 + 24);
        uint64_t v8 = 48 * v13;
        do
        {
          uint64_t v9 = *v7;
          v7 += 6;
          int v16 = re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>;
          unint64_t v15 = v9 | 0xFFFFFFFF00000000;
          re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v6, &v15, &v16);
          v8 -= 48;
        }
        while (v8);
      }
      if (v11)
      {
        if (v14) {
          (*(void (**)(void))(*(void *)v11 + 40))();
        }
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = (unsigned char *)(a1 + 256);
  uint64_t v15 = *(void *)(a1 + 408);
  if (!v15)
  {
    if (a7) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = a4;
    }
    uint64_t v17 = **((void **)a5 + 2);
    *(void *)&long long v26 = *(void *)a5;
    *((void *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((void *)(a1 + 256), v16, &v26);
  }
  BOOL v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(void *)a1 + 80))(a1, a5);
  if (v18)
  {
    uint64_t result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(void *)(a1 + 408);
        ++*(_DWORD *)(a1 + 416);
      }
    }
  }
  else
  {
    uint64_t v20 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v21, v22, v23, v24, v25, v20[1]);
    return 0;
  }
  return result;
}

uint64_t (*re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(unsigned char *a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    uint64_t v6 = (char *)v4[1];
    uint64_t v7 = re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::serializeCString;
    if (v6 == "char*") {
      return (uint64_t (*)(unsigned char *, const char *, const re::TypeInfo *, char *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v7;
    }
    int v8 = strcmp(v6, "char*");
    uint64_t v7 = re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::serializeCString;
    if (!v8) {
      return (uint64_t (*)(unsigned char *, const char *, const re::TypeInfo *, char *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v7;
    }
  }
  if (*((unsigned char *)this + 12) != 9) {
    goto LABEL_9;
  }
  unsigned int v9 = *(unsigned __int8 *)(*((void *)this + 2) + 80);
  uint64_t v7 = re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::serializePointer;
  if (v9 >= 2)
  {
    if (v9 != 2)
    {
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      uint64_t result = (uint64_t (*)(unsigned char *, const char *, const re::TypeInfo *, char *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))_os_crash();
      __break(1u);
      return result;
    }
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
    _os_crash();
    __break(1u);
LABEL_9:
    if (*(void *)this == *(void *)(a1 + 192))
    {
      LODWORD(v12) = **((void **)this + 2);
      HIDWORD(v12) = -1;
      uint64_t v10 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 208, &v12);
      uint64_t v7 = re::serializeType<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>;
      if (v10) {
        return *(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, char *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v10;
      }
    }
    else
    {
      return re::serializeType<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>;
    }
  }
  return (uint64_t (*)(unsigned char *, const char *, const re::TypeInfo *, char *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v7;
}

uint64_t re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::SerializerV1(uint64_t a1, const StringID *a2)
{
  *(void *)a1 = &unk_26E6C8C90;
  re::StringID::StringID((re::StringID *)(a1 + 8), a2);
  re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::Encoder(a1 + 24, 13);
  *(_DWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(void *)(a1 + 244) = 0x7FFFFFFFLL;
  *(void *)a1 = &unk_26E6C8C28;
  *(_WORD *)(a1 + 2re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 1;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_DWORD *)(a1 + 296) = 0;
  *(void *)(a1 + 300) = 0x7FFFFFFFLL;
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(void *)(a1 + 424) = 0;
  *(_DWORD *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_DWORD *)(a1 + 416) = 0;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  return a1;
}

uint64_t re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>>::~NetworkSerializerBase(void *a1)
{
  *a1 = &unk_26E6C8C28;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 44));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 39));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 33);
  return re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)a1);
}

void re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>>::~NetworkSerializerBase(void *a1)
{
  *a1 = &unk_26E6C8C28;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 44));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 39));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 33);
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~SerializerV1(void *a1)
{
  *a1 = &unk_26E6C8C28;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 44));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 39));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 33);
  return re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)a1);
}

void re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~SerializerV1(void *a1)
{
  *a1 = &unk_26E6C8C28;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 44));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 39));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 33);
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer((uint64_t)a1);
  JUMPOUT(0x237DBCBD0);
}

void re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doOpen(uint64_t a1)
{
  *(unsigned char *)(a1 + 257) = 0;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(void *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(void *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(void *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(void *)a1 + 80))(a1, a5);
  if (v14)
  {
    return v14(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    uint64_t v16 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
    return 0;
  }
}

uint64_t (*re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(unsigned char *a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a2 == *(void *)(a1 + 192)
    && (LODWORD(v4) = **(void **)(a2 + 16),
        HIDWORD(v4) = -1,
        (uint64_t v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 208, &v4)) != 0))
  {
    return *(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, char *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>;
  }
}

uint64_t re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::Encoder(uint64_t result, int a2)
{
  *(void *)(result + 128) = 0;
  *(void *)(result + 104) = 0;
  *(void *)(result + ++*(void *)(this + 112) = 0;
  *(void *)(result + 96) = 0;
  *(_DWORD *)(result + 120) = 0;
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(unsigned char *)(result + 40) = 0;
  *(_DWORD *)(result + 136) = a2;
  *(unsigned char *)(result + 140) = 0;
  *(void *)(result + 152) = 1024;
  uint64_t v2 = &qword_268772000;
  {
    uint64_t v8 = result;
    uint64_t v2 = &qword_268772000;
    int v6 = v4;
    uint64_t result = v8;
    if (v6)
    {
      re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v5, (uint64_t)v9);
      uint64_t v7 = v10;
      if (!v9[0]) {
        uint64_t v7 = 0;
      }
      re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::Encoder(int)::s_maxSerializationDepth = v7;
      uint64_t v2 = &qword_268772000;
      uint64_t result = v8;
    }
  }
  uint64_t v3 = v2[369];
  if (v3) {
    *(void *)(result + 152) = v3;
  }
  return result;
}

uint64_t re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(uint64_t a1)
{
  *(void *)a1 = &unk_26E6C8C90;
  uint64_t v2 = (re::StringID *)(a1 + 8);
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::deinit((void *)a1);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 208));
  re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::~Encoder((unsigned char *)(a1 + 24));
  re::StringID::destroyString(v2);
  return a1;
}

void re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::deinit(void *a1)
{
  if (a1[24])
  {
    (*(void (**)(void *))(*a1 + 40))(a1);
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
    a1[24] = 0;
  }
}

unsigned char *re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::~Encoder(unsigned char *a1)
{
  if (a1[40]) {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 64));
  }
  return a1;
}

_anonymous_namespace_ *re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::close(_anonymous_namespace_ *result)
{
  if (*(void *)result)
  {
    uint64_t v1 = result;
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::doClose((uint64_t)result);
    if (!*((unsigned char *)v1 + 40)) {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 0);
    }
    uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::deinit((uint64_t)v1 + 96);
    if (*((int *)v1 + 4) >= 1)
    {
      uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)v1 + 24))();
      *((void *)v1 + 1) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *(void *)uint64_t v1 = 0;
    *((void *)v1 + 3) = 0;
    *((void *)v1 + 4) = 0;
  }
  return result;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::doClose(uint64_t result)
{
  if (!*(unsigned char *)(result + 40))
  {
    char v1 = 69;
    return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(result, "End-of-file", 0, &v1, (uint64_t)"uint8", 0);
  }
  return result;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  if (a6) {
    a4 = 0;
  }
  if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, a4, 1uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v11 - 16);
  }
  return 1;
}

uint64_t re::serializeType<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (this == (re::TypeInfo *)a6) {
    goto LABEL_19;
  }
  if (*(void *)this != *(void *)a6)
  {
    if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, a3)) {
      goto LABEL_19;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      uint64_t v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
      if (v19) {
        int v20 = *(_DWORD *)(v19 + 16);
      }
      else {
        int v20 = -1;
      }
      uint64_t v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
      if (v21) {
        int v22 = *(_DWORD *)(v21 + 16);
      }
      else {
        int v22 = -1;
      }
      if (v20 == v22) {
        goto LABEL_19;
      }
      uint64_t v24 = re::TypeInfo::name(this)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
      re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "Cannot serialize type \"%s\" version %u as version %u. Downgrading versions is not supported.", v30, v31, v32, v33, v34, v24);
    }
    else
    {
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, this, (re::TypeInfo *)a6);
    }
    return 0;
  }
  uint64_t v15 = **((void **)this + 2);
  uint64_t v16 = **(void **)(a6 + 16);
  if ((unsigned __int16)v15 != (unsigned __int16)v16) {
    goto LABEL_10;
  }
  BOOL v18 = WORD1(v15) == WORD1(v16);
  uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
  BOOL v18 = v18 && v17 == 0;
  if (!v18) {
    goto LABEL_10;
  }
LABEL_19:
  switch(*((unsigned char *)this + 12))
  {
    case 1:
      uint64_t result = re::serializeBasic<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 2:
      uint64_t result = re::serializeEnum<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, (re::TypeInfo *)a4, (uint64_t)this, a6, a7);
      break;
    case 3:
      uint64_t result = re::serializeOptional<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 4:
      uint64_t result = re::serializeArray<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 5:
      uint64_t result = re::serializeList<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 6:
      uint64_t result = re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 7:
      uint64_t result = re::serializeUnion<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 8:
      uint64_t result = re::serializeObject<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)a4, this, a6, a7);
      break;
    case 9:
      uint64_t v35 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "Pointer type (\"%s\") needs to be handled explicitly by the serializer.", v25, v26, v27, v28, v29, v35);
      return 0;
    default:
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "Invalid type category. Value = %d", (uint64_t)a4, (uint64_t)this, a6, a7, a8, *((unsigned char *)this + 12));
      return 0;
  }
  return result;
}

uint64_t re::serializeBasic<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  if (this != a6)
  {
    if (*(void *)this != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3)) {
        goto LABEL_4;
      }
LABEL_21:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, this, a6);
      return 0;
    }
    uint64_t v24 = **((void **)this + 2);
    uint64_t v25 = **((void **)a6 + 2);
    if ((unsigned __int16)v24 != (unsigned __int16)v25) {
      goto LABEL_21;
    }
    BOOL v27 = WORD1(v24) == WORD1(v25);
    uint64_t v26 = (v25 ^ v24) & 0xFFFFFF00000000;
    BOOL v27 = v27 && v26 == 0;
    if (!v27) {
      goto LABEL_21;
    }
  }
LABEL_4:
  uint64_t v14 = re::TypeInfo::name(this);
  unint64_t v15 = (unint64_t)*v14 >> 1;
  if (v15 <= 0xCA3DEFB5)
  {
    if ((unint64_t)*v14 >> 1 <= 0x5D0225B)
    {
      if ((unint64_t)*v14 >> 1 <= 0x2E9355)
      {
        if (v15 != 104431)
        {
          if (v15 == 3029738)
          {
            uint64_t v16 = a1 + 24;
            uint64_t v17 = "BOOL";
            BOOL v18 = a2;
            uint64_t v19 = (uint64_t)a3;
            int v20 = a4;
            char v21 = a7;
            return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(v16, v18, v19, v20, (uint64_t)v17, v21);
          }
          goto LABEL_72;
        }
        goto LABEL_54;
      }
      if (v15 == 3052374)
      {
        uint64_t v16 = a1 + 24;
        uint64_t v17 = "char";
        BOOL v18 = a2;
        uint64_t v19 = (uint64_t)a3;
        int v20 = a4;
        char v21 = a7;
        return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(v16, v18, v19, v20, (uint64_t)v17, v21);
      }
      uint64_t v34 = 3327612;
LABEL_40:
      if (v15 == v34)
      {
        uint64_t v35 = a1 + 24;
        unint64_t v36 = "int64";
        uint64_t v37 = a2;
        uint64_t v38 = (uint64_t)a3;
        uint64_t v39 = a4;
        char v40 = a7;
        return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(v35, v37, v38, v39, (uint64_t)v36, v40);
      }
      goto LABEL_72;
    }
    if ((unint64_t)*v14 >> 1 > 0xB0F77BD0)
    {
      if (v15 == 2969009105)
      {
        uint64_t v35 = a1 + 24;
        unint64_t v36 = "double";
        uint64_t v37 = a2;
        uint64_t v38 = (uint64_t)a3;
        uint64_t v39 = a4;
        char v40 = a7;
        return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(v35, v37, v38, v39, (uint64_t)v36, v40);
      }
      if (v15 == 3111160798)
      {
        uint64_t v16 = a1 + 24;
        uint64_t v17 = "int8";
        BOOL v18 = a2;
        uint64_t v19 = (uint64_t)a3;
        int v20 = a4;
        char v21 = a7;
        return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(v16, v18, v19, v20, (uint64_t)v17, v21);
      }
LABEL_72:
      unint64_t v47 = re::TypeInfo::name(this);
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Unsupported basic type \"%s\".", v48, v49, v50, v51, v52, v47[1]);
      return 0;
    }
    if (v15 == 97526364)
    {
      uint64_t v41 = a1 + 24;
      uint64_t v42 = "float";
      uint64_t v43 = a2;
      uint64_t v44 = (uint64_t)a3;
      int v45 = a4;
      char v46 = a7;
      return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(v41, v43, v44, v45, (uint64_t)v42, v46);
    }
    uint64_t v23 = 109413500;
    goto LABEL_26;
  }
  if ((unint64_t)*v14 >> 1 > 0x18E6A9A092)
  {
    if ((unint64_t)*v14 >> 1 <= 0x303EE8780EDLL)
    {
      if (v15 == 0x18E6A9A093)
      {
        uint64_t v16 = a1 + 24;
        uint64_t v17 = "uint8";
        BOOL v18 = a2;
        uint64_t v19 = (uint64_t)a3;
        int v20 = a4;
        char v21 = a7;
        return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(v16, v18, v19, v20, (uint64_t)v17, v21);
      }
      if (v15 != 0x303EE86A734) {
        goto LABEL_72;
      }
      uint64_t v28 = a1 + 24;
      uint64_t v29 = "uint16";
      uint64_t v30 = a2;
      uint64_t v31 = (uint64_t)a3;
      uint64_t v32 = a4;
      char v33 = a7;
      return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<short>(v28, v30, v31, v32, (uint64_t)v29, v33);
    }
    if (v15 == 0x303EE8780EELL)
    {
      uint64_t v41 = a1 + 24;
      uint64_t v42 = "uint32";
      uint64_t v43 = a2;
      uint64_t v44 = (uint64_t)a3;
      int v45 = a4;
      char v46 = a7;
      return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(v41, v43, v44, v45, (uint64_t)v42, v46);
    }
    if (v15 != 0x303EE88E58DLL) {
      goto LABEL_72;
    }
    goto LABEL_51;
  }
  if ((unint64_t)*v14 >> 1 <= 0x16749DFF02)
  {
    if (v15 != 3393056694)
    {
      uint64_t v23 = 0x16749D2549;
LABEL_26:
      if (v15 != v23) {
        goto LABEL_72;
      }
      uint64_t v28 = a1 + 24;
      uint64_t v29 = "int16";
      uint64_t v30 = a2;
      uint64_t v31 = (uint64_t)a3;
      uint64_t v32 = a4;
      char v33 = a7;
      return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<short>(v28, v30, v31, v32, (uint64_t)v29, v33);
    }
LABEL_51:
    uint64_t v35 = a1 + 24;
    unint64_t v36 = "uint64";
    uint64_t v37 = a2;
    uint64_t v38 = (uint64_t)a3;
    uint64_t v39 = a4;
    char v40 = a7;
    return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(v35, v37, v38, v39, (uint64_t)v36, v40);
  }
  if (v15 != 0x16749DFF03)
  {
    uint64_t v34 = 0x16749F63A2;
    goto LABEL_40;
  }
LABEL_54:
  uint64_t v41 = a1 + 24;
  uint64_t v42 = "int32";
  uint64_t v43 = a2;
  uint64_t v44 = (uint64_t)a3;
  int v45 = a4;
  char v46 = a7;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(v41, v43, v44, v45, (uint64_t)v42, v46);
}

uint64_t re::serializeEnum<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, re::TypeInfo *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **(void **)(a5 + 16);
      uint64_t v15 = **(void **)(a6 + 16);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_12;
        }
      }
    }
    else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
    {
      goto LABEL_12;
    }
    if (*(unsigned __int8 *)(a5 + 12) != *(unsigned __int8 *)(a6 + 12)
      || (BOOL v18 = re::TypeInfo::name((re::TypeInfo *)a5),
          uint64_t v19 = re::TypeInfo::name((re::TypeInfo *)a6),
          !re::StringID::operator==(v18, v19)))
    {
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
      return 0;
    }
  }
LABEL_12:
  return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::TypeInfo *)a6, a7);
}

BOOL re::serializeOptional<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v24[0] = 0;
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginOptional(a1 + 24, a2, (uint64_t)a3, v24, 0);
    if (v24[0])
    {
      BOOL v18 = *(re::internal **)(a1 + 192);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v26);
      re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)&v27);
      re::internal::translateType(v18, (const re::TypeRegistry *)v25, (uint64_t)v26);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, 0, 0, v26, v26, 1);
      }
    }
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), v26);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)&v27);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v26);
    re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)&v27);
    re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)a5);
    BOOL v23 = (*(uint64_t (**)(uint64_t))(v28 + 80))(a4) != 0;
    double v20 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginOptional(a1 + 24, a2, (uint64_t)a3, (char *)&v23, 0);
    if (v23)
    {
      uint64_t v21 = (*(uint64_t (**)(uint64_t, double))(v28 + 80))(a4, v20);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, uint64_t, unsigned char *, char *, void))(*(void *)a1 + 72))(a1, a2, 0, v21, v25, v24, 0);
      }
    }
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endOptional(v19);
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::serializeArray<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v22 = **((void **)a5 + 2);
    uint64_t v23 = **((void **)a6 + 2);
    if ((unsigned __int16)v22 != (unsigned __int16)v23) {
      goto LABEL_13;
    }
    BOOL v25 = WORD1(v22) == WORD1(v23);
    uint64_t v24 = (v23 ^ v22) & 0xFFFFFF00000000;
    BOOL v25 = v25 && v24 == 0;
    if (!v25) {
      goto LABEL_13;
    }
LABEL_4:
    char v14 = 1;
    if (a7) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_4;
  }
LABEL_13:
  if (*((unsigned char *)a6 + 12) != 4) {
    goto LABEL_52;
  }
  uint64_t v26 = (void *)*((void *)a5 + 2);
  uint64_t v27 = (void *)*((void *)a6 + 2);
  int v28 = *((_DWORD *)v27 + 21) & 0xFFFFFF;
  if ((*((_DWORD *)v26 + 21) & 0xFFFFFF) != 0)
  {
    if (v28) {
      goto LABEL_16;
    }
LABEL_52:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a5, a6);
    return 0;
  }
  if (v28 || *((_DWORD *)v26 + 22) != *((_DWORD *)v27 + 22)) {
    goto LABEL_52;
  }
LABEL_16:
  char v14 = 0;
  if (a7)
  {
LABEL_5:
    uint64_t v15 = (re::internal *)*((void *)a1 + 24);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v60);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v61);
    re::internal::translateType(v15, (const re::TypeRegistry *)v56, (uint64_t)v57);
    uint64_t v16 = (*(uint64_t (**)(unsigned char *, unsigned char *))(*(void *)a1 + 80))(a1, v57);
    if (v16)
    {
      BOOL v17 = (void (*)(unsigned char *, void, void, void, unsigned char *, unsigned char *, uint64_t))v16;
      BOOL v18 = (void *)*((void *)a6 + 2);
      int v19 = *((_DWORD *)v18 + 21) & 0xFFFFFF;
      if (v19)
      {
        unint64_t v20 = 0;
        int v21 = 8;
      }
      else
      {
        unint64_t v20 = *((int *)v18 + 22);
        int v21 = 4;
      }
      unint64_t v60 = v20;
      BOOL result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v60, v21);
      if (result)
      {
        uint64_t v46 = v60;
        if (v19) {
          BOOL v47 = v60 == 0;
        }
        else {
          BOOL v47 = 1;
        }
        char v48 = v47;
        if (!v47)
        {
          v55[0] = 0;
          v55[1] = 0xFFFFFFFFLL;
          (*(void (**)(unsigned char *, void, void *))(*(void *)a1 + 16))(a1, 0, v55);
          uint64_t v46 = v60;
        }
        if (v58 == 1)
        {
          if (v46) {
            re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeArray((uint64_t)(a1 + 24), 0, *(unsigned int *)(v59 + 8), v46, 1);
          }
        }
        else if (v46)
        {
          unint64_t v52 = 0;
          do
          {
            v17(a1, 0, 0, 0, v57, v57, 1);
            ++v52;
          }
          while (v52 < v60);
        }
        if ((v48 & 1) == 0) {
          (*(void (**)(unsigned char *))(*(void *)a1 + 24))(a1);
        }
        uint64_t v51 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_66:
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endArray(v51);
        return a1[64] == 0;
      }
      return result;
    }
    goto LABEL_36;
  }
LABEL_17:
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v60);
  re::TypeInfo::TypeInfo((uint64_t)v57, (uint64_t)v61);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v60);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v61);
  re::TypeInfo::TypeInfo((uint64_t)&v60, (uint64_t)a5);
  uint64_t v29 = (*(uint64_t (**)(unsigned char *, unsigned char *))(*(void *)a1 + 80))(a1, v57);
  if (!v29)
  {
LABEL_36:
    char v40 = re::TypeInfo::name((re::TypeInfo *)v57);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v41, v42, v43, v44, v45, v40[1]);
    return 0;
  }
  uint64_t v30 = (void (*)(unsigned char *, void, void, uint64_t, unsigned char *, unsigned char *, void))v29;
  unint64_t v54 = re::ArrayAccessor::size((re::ArrayAccessor *)&v60, a4);
  int v31 = *(_DWORD *)(*((void *)a5 + 2) + 84) & 0xFFFFFF;
  if (v31) {
    int v32 = 8;
  }
  else {
    int v32 = 4;
  }
  BOOL result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v54, v32);
  if (result)
  {
    unint64_t v34 = v54;
    if (v31) {
      BOOL v35 = v54 == 0;
    }
    else {
      BOOL v35 = 1;
    }
    char v36 = v35;
    if (!v35)
    {
      uint64_t v37 = *(void *)a4;
      v53[0] = 0;
      v53[1] = 0xFFFFFFFFLL;
      (*(void (**)(unsigned char *, uint64_t, void *))(*(void *)a1 + 16))(a1, v37, v53);
      unint64_t v34 = v54;
    }
    if (v58 == 1) {
      char v38 = v14;
    }
    else {
      char v38 = 0;
    }
    if (v38)
    {
      if (v34)
      {
        uint64_t v39 = (char *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v60, a4, 0);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeArray((uint64_t)(a1 + 24), v39, *(unsigned int *)(v59 + 8), v54, 0);
      }
    }
    else if (v34)
    {
      unint64_t v49 = 0;
      do
      {
        uint64_t v50 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v60, a4, v49);
        v30(a1, 0, 0, v50, v57, v56, 0);
        ++v49;
      }
      while (v49 < v54);
    }
    if ((v36 & 1) == 0) {
      (*(void (**)(unsigned char *))(*(void *)a1 + 24))(a1);
    }
    uint64_t v51 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_66;
  }
  return result;
}

BOOL re::serializeList<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v20 = **((void **)a5 + 2);
    uint64_t v21 = **((void **)a6 + 2);
    if ((unsigned __int16)v20 != (unsigned __int16)v21) {
      goto LABEL_15;
    }
    BOOL v23 = WORD1(v20) == WORD1(v21);
    uint64_t v22 = (v21 ^ v20) & 0xFFFFFF00000000;
    BOOL v23 = v23 && v22 == 0;
    if (!v23) {
      goto LABEL_15;
    }
LABEL_4:
    int v14 = 1;
    if (a7) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_4;
  }
LABEL_15:
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
  int v14 = 0;
  if (a7)
  {
LABEL_5:
    uint64_t v15 = *(re::internal **)(a1 + 192);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v56);
    re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)&v57);
    re::internal::translateType(v15, (const re::TypeRegistry *)v52, (uint64_t)v53);
    uint64_t v16 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v53);
    if (v16)
    {
      BOOL v17 = (void (*)(uint64_t, void, void, void, unsigned char *, unsigned char *, uint64_t))v16;
      unint64_t v56 = 0;
      BOOL v18 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v56, 0);
      BOOL result = 0;
      if (!v18) {
        return result;
      }
      if (v54 == 1)
      {
        if (v56) {
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeArray(a1 + 24, 0, *(unsigned int *)(v55 + 8), v56, 1);
        }
      }
      else if (v56)
      {
        for (unint64_t i = 0; i < v56; ++i)
          v17(a1, 0, 0, 0, v53, v53, 1);
      }
      char v36 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_48;
    }
    goto LABEL_28;
  }
LABEL_17:
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)&v57);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)&v57);
  re::TypeInfo::TypeInfo((uint64_t)&v56, (uint64_t)a5);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v53);
  if (!v24)
  {
LABEL_28:
    uint64_t v48 = re::TypeInfo::name((re::TypeInfo *)v53)[1];
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v30, v31, v32, v33, v34, v48);
    return 0;
  }
  BOOL v25 = (void (*)(uint64_t, void, void, uint64_t, unsigned char *, unsigned char *, void))v24;
  unint64_t v51 = (*(uint64_t (**)(uint64_t))(v58 + 80))(a4);
  BOOL v26 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v51, 0);
  BOOL result = 0;
  if (!v26) {
    return result;
  }
  uint64_t v27 = *(uint64_t (**)(uint64_t, void))(v58 + 96);
  if (!v27)
  {
    uint64_t v39 = *(uint64_t (**)(uint64_t, void))(v58 + 104);
    if (v39 && *(void *)(v58 + 112) && *(void *)(v58 + 120))
    {
      uint64_t v40 = v39(a4, *(void *)(a1 + 56));
      uint64_t v41 = (*(uint64_t (**)(void))(v58 + 112))();
      if (v41)
      {
        uint64_t v42 = v41;
        do
        {
          v25(a1, 0, 0, v42, v53, v52, 0);
          uint64_t v42 = (*(uint64_t (**)(uint64_t))(v58 + 112))(v40);
        }
        while (v42);
      }
      (*(void (**)(uint64_t, void))(v58 + 120))(v40, *(void *)(a1 + 56));
      goto LABEL_47;
    }
    re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)&v56);
    uint64_t v49 = re::TypeInfo::name((re::TypeInfo *)v50)[1];
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "List type \"%s\" does not provide an indexer or iterator.", v43, v44, v45, v46, v47, v49);
    return 0;
  }
  if (*((unsigned char *)a5 + 12) == 5) {
    int v28 = v14;
  }
  else {
    int v28 = 0;
  }
  if (v28 == 1 && (*(unsigned char *)(*((void *)a5 + 2) + 48) & 8) != 0 && v54 == 1)
  {
    if (v51)
    {
      uint64_t v29 = (char *)v27(a4, 0);
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeArray(a1 + 24, v29, *(unsigned int *)(v55 + 8), v51, 0);
    }
  }
  else if (v51)
  {
    for (unint64_t j = 0; j < v51; ++j)
    {
      uint64_t v38 = (*(uint64_t (**)(uint64_t, unint64_t))(v58 + 96))(a4, j);
      v25(a1, 0, 0, v38, v53, v52, 0);
    }
  }
LABEL_47:
  char v36 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_48:
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endArray(v36);
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v85);
    re::TypeInfo::TypeInfo((uint64_t)v75, (uint64_t)&v85.n128_i64[1]);
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v85);
    re::TypeInfo::TypeInfo((uint64_t)v74, (uint64_t)&v85.n128_i64[1]);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v85);
    re::TypeInfo::TypeInfo((uint64_t)v73, (uint64_t)&v85.n128_i64[1]);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v85);
    re::TypeInfo::TypeInfo((uint64_t)v72, (uint64_t)&v85.n128_i64[1]);
    re::TypeInfo::TypeInfo((uint64_t)v70, (uint64_t)a5);
    uint64_t v29 = (*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 80))(a1, v75);
    if (!v29)
    {
      unint64_t v51 = (re::TypeInfo *)v75;
      goto LABEL_45;
    }
    uint64_t v30 = (void (*)(uint64_t, const char *, void, uint64_t, void *, unsigned char *, void, double))v29;
    uint64_t v31 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v74);
    if (!v31)
    {
      unint64_t v51 = (re::TypeInfo *)v74;
      goto LABEL_45;
    }
    uint64_t v32 = (void (*)(uint64_t, const char *, void, uint64_t, unsigned char *, unsigned char *, void))v31;
    unint64_t v69 = (*(uint64_t (**)(uint64_t))(v71 + 88))(a4);
    BOOL v33 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginDictionary((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v69, 0);
    BOOL result = 0;
    if (!v33) {
      return result;
    }
    if (v69)
    {
      uint64_t v34 = *(void *)a5;
      v85.n128_u64[0] = 0x449AD97C4B77BED4;
      v85.n128_u64[1] = (unint64_t)"_CompareFunc";
      BOOL v35 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v34 + 200, &v85);
      if (v35)
      {
        unint64_t v36 = *v35;
        re::StringID::destroyString((re::StringID *)&v85);
        if (v34)
        {
          unint64_t v37 = *(void *)v75[2];
          v85.n128_u64[0] = v36;
          v85.n128_u64[1] = v37;
          LODWORD(v86) = -1;
          uint64_t v38 = (unint64_t *)re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v75[0] + 768, (uint64_t *)&v85);
          if (v38)
          {
            unint64_t v39 = *v38;
            if (*v38)
            {
              uint64_t v68 = 0;
              v65[1] = 0;
              unint64_t v66 = 0;
              int v67 = 0;
              v65[0] = *(void *)(a1 + 56);
              re::DynamicArray<re::RigNodeConstraint>::setCapacity(v65, v69);
              ++v67;
              uint64_t v40 = (*(uint64_t (**)(uint64_t, void))(v71 + 112))(a4, *(void *)(a1 + 56));
              if ((*(unsigned int (**)(void))(v71 + 120))())
              {
                do
                {
                  uint64_t v41 = (*(uint64_t (**)(uint64_t))(v71 + 128))(v40);
                  uint64_t v42 = (*(uint64_t (**)(uint64_t))(v71 + 136))(v40);
                  v85.n128_u64[0] = v41;
                  v85.n128_u64[1] = v42;
                  __n128 v43 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)v65, &v85);
                }
                while (((*(uint64_t (**)(uint64_t, __n128))(v71 + 120))(v40, v43) & 1) != 0);
              }
              (*(void (**)(uint64_t, void))(v71 + 144))(v40, *(void *)(a1 + 56));
              v85.n128_u64[0] = v39;
              unint64_t v45 = 126 - 2 * __clz(v66);
              if (v66) {
                uint64_t v46 = v45;
              }
              else {
                uint64_t v46 = 0;
              }
              std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(v68, (char *)&v68[2 * v66], (uint64_t (**)(unint64_t, unint64_t))&v85, v46, 1, v44);
              if (v69)
              {
                uint64_t v47 = 0;
                for (unint64_t i = 0; i < v69; ++i)
                {
                  double v49 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
                  if (v66 <= i)
                  {
                    uint64_t v76 = 0;
                    long long v88 = 0u;
                    long long v89 = 0u;
                    long long v86 = 0u;
                    long long v87 = 0u;
                    __n128 v85 = 0u;
                    unint64_t v63 = v66;
                    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                    int v77 = 136315906;
                    uint64_t v78 = "operator[]";
                    __int16 v79 = 1024;
                    int v80 = 789;
                    __int16 v81 = 2048;
                    unint64_t v82 = i;
                    __int16 v83 = 2048;
                    unint64_t v84 = v63;
                    _os_log_send_and_compose_impl();
                    _os_crash_msg();
                    __break(1u);
LABEL_56:
                    uint64_t v76 = 0;
                    long long v88 = 0u;
                    long long v89 = 0u;
                    long long v86 = 0u;
                    long long v87 = 0u;
                    __n128 v85 = 0u;
                    unint64_t v64 = v50;
                    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                    int v77 = 136315906;
                    uint64_t v78 = "operator[]";
                    __int16 v79 = 1024;
                    int v80 = 789;
                    __int16 v81 = 2048;
                    unint64_t v82 = i;
                    __int16 v83 = 2048;
                    unint64_t v84 = v64;
                    _os_log_send_and_compose_impl();
                    _os_crash_msg();
                    __break(1u);
                  }
                  v30(a1, "key", 0, v68[v47], v75, v73, 0, v49);
                  unint64_t v50 = v66;
                  if (v66 <= i) {
                    goto LABEL_56;
                  }
                  v32(a1, "value", 0, v68[v47 + 1], v74, v72, 0);
                  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
                  v47 += 2;
                }
              }
              if (v65[0] && v68) {
                (*(void (**)(void))(*(void *)v65[0] + 40))();
              }
              goto LABEL_53;
            }
          }
        }
      }
      else
      {
        re::StringID::destroyString((re::StringID *)&v85);
      }
      uint64_t v58 = (*(uint64_t (**)(uint64_t, void))(v71 + 112))(a4, *(void *)(a1 + 56));
      (*(void (**)(void))(v71 + 120))();
      if (v69)
      {
        for (unint64_t j = 0; j < v69; ++j)
        {
          double v60 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
          uint64_t v61 = (*(uint64_t (**)(uint64_t, double))(v71 + 128))(v58, v60);
          ((void (*)(uint64_t, const char *, void, uint64_t, void *, unsigned char *, void))v30)(a1, "key", 0, v61, v75, v73, 0);
          uint64_t v62 = (*(uint64_t (**)(uint64_t))(v71 + 136))(v58);
          v32(a1, "value", 0, v62, v74, v72, 0);
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
          (*(void (**)(uint64_t))(v71 + 120))(v58);
        }
      }
      (*(void (**)(uint64_t, void))(v71 + 144))(v58, *(void *)(a1 + 56));
    }
LABEL_53:
    int v28 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_54:
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionary(v28);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  BOOL v18 = *(re::internal **)(a1 + 192);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v85);
  re::TypeInfo::TypeInfo((uint64_t)&v77, (uint64_t)&v85.n128_i64[1]);
  re::internal::translateType(v18, (const re::TypeRegistry *)&v77, (uint64_t)v65);
  int v19 = *(re::internal **)(a1 + 192);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v85);
  re::TypeInfo::TypeInfo((uint64_t)v75, (uint64_t)&v85.n128_i64[1]);
  re::internal::translateType(v19, (const re::TypeRegistry *)v75, (uint64_t)&v77);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 80))(a1, v65);
  if (!v20)
  {
    unint64_t v51 = (re::TypeInfo *)v65;
LABEL_45:
    unint64_t v52 = re::TypeInfo::name(v51);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v53, v54, v55, v56, v57, v52[1]);
    return 0;
  }
  uint64_t v21 = (void (*)(uint64_t, const char *, void, void, void *, void *, uint64_t, double))v20;
  uint64_t v22 = (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 80))(a1, &v77);
  if (!v22)
  {
    unint64_t v51 = (re::TypeInfo *)&v77;
    goto LABEL_45;
  }
  BOOL v23 = (void (*)(uint64_t, const char *, void, void, int *, int *, uint64_t))v22;
  v85.n128_u64[0] = 0;
  BOOL v24 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginDictionary((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, v85.n128_u64, 0);
  BOOL result = 0;
  if (v24)
  {
    if (v85.n128_u64[0])
    {
      unint64_t v26 = 0;
      do
      {
        double v27 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 1);
        v21(a1, "key", 0, 0, v65, v65, 1, v27);
        v23(a1, "value", 0, 0, &v77, &v77, 1);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
        ++v26;
      }
      while (v26 < v85.n128_u64[0]);
    }
    int v28 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_54;
  }
  return result;
}

BOOL re::serializeUnion<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_19:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 != (unsigned __int16)v15) {
      goto LABEL_19;
    }
    BOOL v17 = WORD1(v14) == WORD1(v15);
    uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
    BOOL v17 = v17 && v16 == 0;
    if (!v17) {
      goto LABEL_19;
    }
  }
LABEL_4:
  if (a7)
  {
    if (!*(unsigned char *)(a1 + 64))
    {
      LOBYTE(v20) = 1;
      DWORD1(v20) = 16;
      *((void *)&v20 + 1) = a2;
      long long v21 = 0u;
      long long v22 = 0u;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)(a1 + 24), &v20);
      v18[0] = 0;
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, "tag", 0, (char *)v18, (uint64_t)"uint64", 0);
      if (v18[0] < *(unsigned int *)(*((void *)a6 + 2) + 88))
      {
        re::TypeInfo::unionMember(a6, v18[0], (uint64_t)&v20);
        if (!*(unsigned char *)(a1 + 64)) {
          (*(void (**)(uint64_t, const char *, void, void, long long *, long long *, uint64_t))(*(void *)a1 + 72))(a1, "value", 0, 0, &v20, &v20, 1);
        }
      }
LABEL_13:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(unsigned char *)(a1 + 64) == 0;
    }
  }
  else if (!*(unsigned char *)(a1 + 64))
  {
    LOBYTE(v20) = 1;
    DWORD1(v20) = 16;
    *((void *)&v20 + 1) = a2;
    long long v21 = 0u;
    long long v22 = 0u;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)(a1 + 24), &v20);
    re::TypeInfo::TypeInfo((uint64_t)&v20, (uint64_t)a5);
    unint64_t Tag = re::UnionAccessor::readTag((re::UnionAccessor *)&v20, a4);
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, "tag", 0, (char *)&Tag, (uint64_t)"uint64", 0);
    if (Tag < *(unsigned int *)(*((void *)a5 + 2) + 88))
    {
      re::TypeInfo::unionMember(a5, Tag, (uint64_t)v18);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, char *, unint64_t *, unint64_t *, void))(*(void *)a1 + 72))(a1, "value", 0, a4, v18, v18, 0);
      }
    }
    goto LABEL_13;
  }
  return 0;
}

uint64_t re::serializeObject<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  if (a7)
  {
    if (*(unsigned char *)(*((void *)this + 2) + 49))
    {
      BOOL v17 = *(re::TypeRegistry **)(a1 + 192);
      v34[0] = 0x2686EB529B3EE220;
      v34[1] = "DynamicString";
      re::TypeRegistry::typeInfo(v17, (const re::StringID *)v34, v36);
      re::TypeInfo::TypeInfo((uint64_t)v35, (uint64_t)v36 + 8);
      re::StringID::destroyString((re::StringID *)v34);
      BOOL v18 = (re *)v35;
      int v19 = (const re::TypeInfo *)v35;
      uint64_t v20 = a1;
      long long v21 = a2;
      long long v22 = (const re::TypeInfo *)a3;
    }
    else
    {
      uint64_t v14 = re::TypeInfo::name(this);
      if ((*v14 & 0xFFFFFFFFFFFFFFFELL) != 0x2686EB529B3EE220) {
        goto LABEL_6;
      }
      uint64_t v15 = (const char *)v14[1];
      if (v15 != "DynamicString")
      {
        if (strcmp(v15, "DynamicString")) {
          goto LABEL_6;
        }
      }
      uint64_t v20 = a1;
      long long v21 = a2;
      long long v22 = (const re::TypeInfo *)a3;
      BOOL v18 = this;
      int v19 = this;
    }
    re::serializeDynamicString<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(v20, v21, v22, 0, v18, v19, 1);
    return *(unsigned char *)(a1 + 64) == 0;
  }
LABEL_6:
  if ((*(unsigned char *)(*((void *)this + 2) + 48) & 4) == 0)
  {
    if (*(unsigned char *)(a1 + 64)) {
      return 0;
    }
    LOBYTE(v36[0]) = 1;
    DWORD1(v36[0]) = 0;
    *((void *)&v36[0] + 1) = a2;
    memset(&v36[1], 0, 32);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)(a1 + 24), v36);
    if (this == (re::TypeInfo *)a6) {
      goto LABEL_16;
    }
    if (*(void *)this == *(void *)a6)
    {
      uint64_t v24 = **((void **)this + 2);
      uint64_t v25 = **(void **)(a6 + 16);
      if ((unsigned __int16)v24 == (unsigned __int16)v25)
      {
        BOOL v27 = WORD1(v24) == WORD1(v25);
        uint64_t v26 = (v25 ^ v24) & 0xFFFFFF00000000;
        BOOL v27 = v27 && v26 == 0;
        if (v27) {
          goto LABEL_16;
        }
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v23))
    {
LABEL_16:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((unsigned char *)a1, a4, (uint64_t *)this, a7);
LABEL_27:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(unsigned char *)(a1 + 64) == 0;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    }
    else
    {
      uint64_t v28 = re::TypeInfo::name(this)[1];
      re::TypeInfo::name((re::TypeInfo *)a6);
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v29, v30, v31, v32, v33, v28);
    }
    goto LABEL_27;
  }
  return re::internal::serializeObjectWithOneMember<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((unsigned char *)a1, a2, a3, a4, (uint64_t *)this, (uint64_t *)a6, a7);
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<short>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  if (a6) {
    a4 = 0;
  }
  if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, a4, 2uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v11 - 16);
  }
  return 1;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  if (a6) {
    a4 = 0;
  }
  if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, a4, 4uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v11 - 16);
  }
  return 1;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  if (a6) {
    a4 = 0;
  }
  if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)a1, a4, 8uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v11 - 16);
  }
  return 1;
}

uint64_t re::internal::serializeEnumAsBinary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, const re::TypeInfo *a3, re::TypeInfo *a4, re::internal *a5, re::TypeInfo *a6, int a7)
{
  if (a7)
  {
    uint64_t v11 = (re::internal *)*((void *)a1 + 24);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v25);
    re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)v26);
    re::internal::translateType(v11, (const re::TypeRegistry *)v24, (uint64_t)v25);
    if (!a1[64]) {
      return (*(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, 0, v25, v25, 1);
    }
    return 0;
  }
  uint64_t v15 = *(void **)a5;
  if (a5 == a6) {
    goto LABEL_8;
  }
  if (v15 == *(void **)a6)
  {
    uint64_t v19 = **((void **)a5 + 2);
    uint64_t v20 = **((void **)a6 + 2);
    if ((unsigned __int16)v19 == (unsigned __int16)v20)
    {
      BOOL v22 = WORD1(v19) == WORD1(v20);
      uint64_t v21 = (v20 ^ v19) & 0xFFFFFF00000000;
      BOOL v22 = v22 && v21 == 0;
      if (v22) {
        goto LABEL_8;
      }
    }
LABEL_15:
    uint64_t result = re::internal::findEnumConstantToSerialize<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a4, a5, a6, 1);
    if (!result) {
      return result;
    }
    a4 = (re::TypeInfo *)result;
    BOOL v23 = (re::internal *)*((void *)a1 + 24);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v25);
    re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)v26);
    re::internal::translateType(v23, (const re::TypeRegistry *)v24, (uint64_t)v25);
    if (a1[64]) {
      return 0;
    }
    uint64_t v16 = *(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, re::TypeInfo *, unsigned char *, unsigned char *, void))(*(void *)a1 + 72);
    BOOL v17 = v25;
    BOOL v18 = v25;
    return v16(a1, a2, a3, a4, v17, v18, 0);
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_15;
  }
  uint64_t v15 = *(void **)a5;
LABEL_8:
  re::TypeRegistry::typeInfo(v15, *(void *)(*((void *)a5 + 2) + 72), v25);
  re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)v26);
  if (a1[64]) {
    return 0;
  }
  uint64_t v16 = *(uint64_t (**)(unsigned char *, const char *, const re::TypeInfo *, re::TypeInfo *, unsigned char *, unsigned char *, void))(*(void *)a1 + 72);
  BOOL v17 = v24;
  BOOL v18 = v24;
  return v16(a1, a2, a3, a4, v17, v18, 0);
}

double re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginOptional(uint64_t a1, const char *a2, uint64_t a3, char *a4, int a5)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1, a2, 0, a4, (uint64_t)"BOOL", 2);
    uint64_t v9 = *a4;
    LOBYTE(v11) = 3;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v9;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endOptional(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = (uint64_t)result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == *(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 24))
    {
      double result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 3);
      uint64_t v2 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      ++*(void *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if (v6) {
        uint64_t v3 = *(unsigned char **)&v7[7];
      }
      else {
        uint64_t v3 = v7;
      }
      if (*(uint64_t *)(*(void *)(v1 + 128) + 48 * *(void *)(v1 + 112) - 24) <= 0) {
        int v4 = "Optional should not have a value.";
      }
      else {
        int v4 = "Optional requires a value.";
      }
      re::DynamicString::format((re::DynamicString *)"Failed to serialize optional type \"%s\". %s", (re::DynamicString *)v8, v3, v4);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(void *)&v8[0])
      {
        if (BYTE8(v8[0])) {
          (*(void (**)(void))(**(void **)&v8[0] + 40))();
        }
        memset(v8, 0, sizeof(v8));
      }
      double result = v5;
      if (v5)
      {
        if (v6) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v5 + 40))();
        }
      }
    }
  }
  return result;
}

BOOL re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginArray(_anonymous_namespace_ *a1, const char *a2, uint64_t a3, unint64_t *a4, int a5)
{
  if (*((unsigned char *)a1 + 40)) {
    return 0;
  }
  BOOL result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::isValidSize(a1, a2, *a4);
  if (result)
  {
    if ((a5 & 4) == 0) {
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>((uint64_t)a1, a2, 0, (char *)a4, (uint64_t)"uint32", 2);
    }
    if ((a5 & 8) != 0)
    {
      if (*a4) {
        char v10 = 73;
      }
      else {
        char v10 = 78;
      }
      char v17 = v10;
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>((uint64_t)a1, a2, 0, &v17, (uint64_t)"uint8", 2);
    }
    unint64_t v11 = *a4;
    LOBYTE(v12) = 5;
    DWORD1(v12) = a5;
    *((void *)&v12 + 1) = a2;
    uint64_t v13 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    unint64_t v14 = v11;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v12);
    return *((unsigned char *)a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeArray(uint64_t result, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v7 = (_anonymous_namespace_ *)result;
    size_t v8 = a4 * a3;
    if (a5) {
      a2 = 0;
    }
    BOOL result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, a2, v8);
    if (result)
    {
      if ((a5 & 2) == 0)
      {
        uint64_t v9 = *((void *)v7 + 16) + 48 * *((void *)v7 + 14);
        *(void *)(v9 - 16) += a4;
      }
    }
    else
    {
      return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v7, 0, (uint64_t)"Array");
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endArray(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = (uint64_t)result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == *(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 24))
    {
      BOOL result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 5);
      uint64_t v2 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      ++*(void *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if (v6) {
        uint64_t v3 = *(unsigned char **)&v7[7];
      }
      else {
        uint64_t v3 = v7;
      }
      uint64_t v4 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)v8, v3, *(void *)(v4 - 24), *(void *)(v4 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(void *)&v8[0])
      {
        if (BYTE8(v8[0])) {
          (*(void (**)(void))(**(void **)&v8[0] + 40))();
        }
        memset(v8, 0, sizeof(v8));
      }
      BOOL result = v5;
      if (v5)
      {
        if (v6) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v5 + 40))();
        }
      }
    }
  }
  return result;
}

BOOL re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::isValidSize(_anonymous_namespace_ *a1, const char *a2, unint64_t a3)
{
  unint64_t v3 = HIDWORD(a3);
  if (HIDWORD(a3))
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
    if (v9) {
      char v6 = *(unsigned char **)&v10[7];
    }
    else {
      char v6 = v10;
    }
    re::DynamicString::format((re::DynamicString *)"Failed to serialize array/string \"%s\". Max length exceeded: actual length \"%zu\", max length: \"%u\".", (re::DynamicString *)v11, v6, a3, 0xFFFFFFFFLL);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
    if (*(void *)&v11[0])
    {
      if (BYTE8(v11[0])) {
        (*(void (**)(void))(**(void **)&v11[0] + 40))();
      }
      memset(v11, 0, sizeof(v11));
    }
    if (v8 && (v9 & 1) != 0) {
      (*(void (**)(void))(*(void *)v8 + 40))();
    }
  }
  return v3 == 0;
}

BOOL re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginDictionary(_anonymous_namespace_ *a1, const char *a2, uint64_t a3, unint64_t *a4, int a5)
{
  if (*((unsigned char *)a1 + 40)) {
    return 0;
  }
  BOOL result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::isValidSize(a1, a2, *a4);
  if (result)
  {
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>((uint64_t)a1, a2, 0, (char *)a4, (uint64_t)"uint32", 2);
    unint64_t v10 = *a4;
    LOBYTE(v11) = 6;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v11);
    return *((unsigned char *)a1 + 40) == 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = (uint64_t)result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == 2)
    {
      BOOL result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 7);
      uint64_t v2 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      ++*(void *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v4);
      if (v5) {
        unint64_t v3 = *(unsigned char **)&v6[7];
      }
      else {
        unint64_t v3 = v6;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary entry \"%s\". Expected 2 objects (key+value). Actual number of objects: %lld.", (re::DynamicString *)v7, v3, *(void *)(*(void *)(v1 + 128) + 48 * *(void *)(v1 + 112) - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v7);
      if (*(void *)&v7[0])
      {
        if (BYTE8(v7[0])) {
          (*(void (**)(void))(**(void **)&v7[0] + 40))();
        }
        memset(v7, 0, sizeof(v7));
      }
      BOOL result = v4;
      if (v4)
      {
        if (v5) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v4 + 40))();
        }
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionary(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = (uint64_t)result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == *(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 24))
    {
      BOOL result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 6);
      uint64_t v2 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      ++*(void *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if (v6) {
        unint64_t v3 = *(unsigned char **)&v7[7];
      }
      else {
        unint64_t v3 = v7;
      }
      uint64_t v4 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)v8, v3, *(void *)(v4 - 24), *(void *)(v4 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(void *)&v8[0])
      {
        if (BYTE8(v8[0])) {
          (*(void (**)(void))(**(void **)&v8[0] + 40))();
        }
        memset(v8, 0, sizeof(v8));
      }
      BOOL result = v5;
      if (v5)
      {
        if (v6) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v5 + 40))();
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(uint64_t *a1, char *a2, uint64_t (**a3)(unint64_t, unint64_t), uint64_t a4, char a5, __n128 a6)
{
BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(char *a1, char *a2, uint64_t (**a3)(uint64_t, void))
{
  uint64_t v6 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = a2 - 16;
      if ((*a3)(*((void *)a2 - 2), *(void *)a1))
      {
        long long v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)uint64_t v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, (void *)a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, (void *)a1 + 6, (void *)a2 - 2, a3);
      return 1;
    default:
      unint64_t v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (void *)a1 + 2, (void *)a1 + 4, a3);
      long long v11 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(*(void *)v11, *(void *)v10))
    {
      long long v18 = *(_OWORD *)v11;
      uint64_t v14 = *(void *)v11;
      uint64_t v15 = v12;
      while (1)
      {
        *(_OWORD *)&a1[v15 + 48] = *(_OWORD *)&a1[v15 + 32];
        if (v15 == -32) {
          break;
        }
        char v16 = (*a3)(v14, *(void *)&a1[v15 + 16]);
        v15 -= 16;
        if ((v16 & 1) == 0)
        {
          unint64_t v17 = &a1[v15 + 48];
          goto LABEL_12;
        }
      }
      unint64_t v17 = a1;
LABEL_12:
      *(_OWORD *)unint64_t v17 = v18;
      if (++v13 == 8) {
        return v11 + 16 == a2;
      }
    }
    unint64_t v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 == a2) {
      return 1;
    }
  }
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = result;
    BOOL result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 1);
    uint64_t v2 = *((void *)v1 + 16) + 48 * *((void *)v1 + 14);
    ++*(void *)(v2 - 16);
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  long long v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (uint64_t v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v27 = 0;
    BOOL v21 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v27, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    if (v27) {
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
    }
    BOOL v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_29;
  }
  unint64_t v23 = *(void *)(a4 + 8);
  if (v23) {
    unint64_t v24 = v23 >> 1;
  }
  else {
    unint64_t v24 = v23 >> 1;
  }
  unint64_t v27 = v24;
  BOOL v25 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v27, 0);
  BOOL result = 0;
  if (v25)
  {
    if (v27)
    {
      if (*(unsigned char *)(a4 + 8)) {
        uint64_t v26 = *(char **)(a4 + 16);
      }
      else {
        uint64_t v26 = (char *)(a4 + 9);
      }
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, v26, 0);
    }
    BOOL v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_29:
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString(v22);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::internal::serializeObjectWithOneMember<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)v29, *a5, a5[2]);
  re::TypeMemberCollection::operator[](v14, 0, (uint64_t)&v27);
  uint64_t v15 = a4 + *(unsigned int *)(v28 + 24);
  re::TypeRegistry::typeInfo(v27, *(void *)v28, v29);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v30);
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*a5 == *a6)
  {
    uint64_t v18 = *(void *)a5[2];
    uint64_t v19 = a6[2];
    uint64_t v20 = *(void *)v19;
    if ((unsigned __int16)v18 != (unsigned __int16)*(void *)v19) {
      goto LABEL_14;
    }
    BOOL v22 = WORD1(v18) == WORD1(v20);
    uint64_t v21 = (v20 ^ v18) & 0xFFFFFF00000000;
    BOOL v22 = v22 && v21 == 0;
    if (!v22) {
      goto LABEL_14;
    }
LABEL_4:
    if (!a1[64]) {
      return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v26, a7);
    }
    return 0;
  }
  if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, v16)) {
    goto LABEL_4;
  }
  uint64_t v19 = a6[2];
LABEL_14:
  if (*(_DWORD *)(v19 + 88) != 1)
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
    return 0;
  }
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v23, *a6, v19);
  re::TypeMemberCollection::operator[](v23, 0, (uint64_t)v24);
  re::TypeRegistry::typeInfo(v24[0], *v24[2], v29);
  re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v30);
  if (a1[64]) {
    return 0;
  }
  return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v25, a7);
}

BOOL re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString(_anonymous_namespace_ *a1, const char *a2, uint64_t a3, unint64_t *a4, int a5)
{
  if (*((unsigned char *)a1 + 40)) {
    return 0;
  }
  BOOL result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::isValidSize(a1, a2, *a4);
  if (result)
  {
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>((uint64_t)a1, "length", 0, (char *)a4, (uint64_t)"uint32", 2);
    unint64_t v10 = *a4;
    LOBYTE(v11) = 8;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unint64_t v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v11);
    return *((unsigned char *)a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(uint64_t result, char *a2, char a3)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v4 = (_anonymous_namespace_ *)result;
    uint64_t v5 = *(void *)(result + 128) + 48 * *(void *)(result + 112);
    uint64_t v6 = *(void *)(v5 - 24);
    if (a3) {
      a2 = 0;
    }
    BOOL result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((void *)result, a2, *(void *)(v5 - 24));
    if (result)
    {
      if ((a3 & 2) == 0)
      {
        uint64_t v7 = *((void *)v4 + 16) + 48 * *((void *)v4 + 14);
        *(void *)(v7 - 16) += v6;
      }
    }
    else
    {
      return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v4, 0, (uint64_t)"string");
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = (uint64_t)result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == *(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 24))
    {
      BOOL result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 8);
      uint64_t v2 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      ++*(void *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if (v6) {
        unint64_t v3 = *(unsigned char **)&v7[7];
      }
      else {
        unint64_t v3 = v7;
      }
      uint64_t v4 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize string \"%s\". Expected number of characters: %lld. Actual number of characters: %lld.", (re::DynamicString *)&v8, v3, *(void *)(v4 - 24), *(void *)(v4 - 16));
      *(void *)&v11[0] = 400;
      *((void *)&v11[0] + 1) = re::FoundationErrorCategory(void)::instance;
      *(void *)&v11[1] = v8;
      *((void *)&v11[2] + 1) = v10;
      *(long long *)((char *)&v11[1] + 8) = v9;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, v11);
      if (*(void *)&v11[1])
      {
        if (BYTE8(v11[1])) {
          (*(void (**)(void))(**(void **)&v11[1] + 40))();
        }
        memset(&v11[1], 0, 32);
      }
      BOOL result = v5;
      if (v5)
      {
        if (v6) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v5 + 40))();
        }
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(unsigned char *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v19);
  if (v19[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v16, (uint64_t)&v20);
    if (*(_DWORD *)(v17 + 88) || (re::TypeRegistry::typeInfo(v16[0], *(void *)(v17 + 72), v21), v21[0])) {
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, v16, a4);
    }
  }
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v16, *a3, a3[2]);
  if (v18)
  {
    for (unint64_t i = 0; i < v18; ++i)
    {
      if (a1[64]) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v16, i, (uint64_t)&v14);
      if (*(unsigned char *)(v15 + 28))
      {
        uint64_t v10 = *(void *)(v15 + 16);
        if (strlen((const char *)v10) >= 3 && *(unsigned char *)v10 == 109) {
          v10 += 2 * (*(unsigned char *)(v10 + 1) == 95);
        }
        uint64_t v11 = *(unsigned int *)(v15 + 32);
        uint64_t v12 = *(unsigned int *)(v15 + 24);
        re::TypeRegistry::typeInfo(v14, *(void *)v15, v21);
        uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v22);
        if (!a1[64]) {
          uint64_t result = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v10, v11, a2 + v12, v13, v13, a4);
        }
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v50);
  re::TypeRegistry::typeInfo((void *)*a4, *(void *)(a4[2] + 72), v46);
  if (v46[0])
  {
    if (!v50[0])
    {
      uint64_t v11 = re::TypeInfo::name((re::TypeInfo *)&v47)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (v51 == v47)
    {
      uint64_t v18 = *v53;
      uint64_t v19 = *v49;
      if ((unsigned __int16)*v53 == (unsigned __int16)*v49)
      {
        BOOL v21 = WORD1(v18) == WORD1(v19);
        uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        BOOL v21 = v21 && v20 == 0;
        if (v21) {
          goto LABEL_5;
        }
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v51, (const re::TypeInfo *)&v47, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((unsigned char *)a1, a2, &v51, a5);
      goto LABEL_15;
    }
    if (v52 == v48)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, &v51, &v47, a5);
    }
    else
    {
      uint64_t v22 = re::TypeInfo::name((re::TypeInfo *)&v51)[1];
      re::TypeInfo::name((re::TypeInfo *)&v47);
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v45, *a3, a3[2]);
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v43, *a4, a4[2]);
  if (v44)
  {
    for (unint64_t i = 0; i < v44; ++i)
    {
      if (*(unsigned char *)(a1 + 64)) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[](v43, i, (uint64_t)v41);
      if (*(unsigned char *)(v42 + 28))
      {
        uint64_t v29 = *(void *)(v42 + 16);
        if (strlen((const char *)v29) >= 3 && *(unsigned char *)v29 == 109) {
          v29 += 2 * (*(unsigned char *)(v29 + 1) == 95);
        }
        uint64_t v30 = *(unsigned int *)(v42 + 32);
        uint64_t v31 = *(re **)(*a4 + 856);
        if (!v31
          || (uint64_t v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v41),
              v31 == -1))
        {
          uint64_t v33 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
          {
            uint64_t v34 = v33;
            uint64_t v35 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            uint64_t v55 = v35;
            __int16 v56 = 2080;
            uint64_t v57 = v29;
            _os_log_impl(&dword_233120000, v34, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          unint64_t v36 = *(re::internal **)(a1 + 192);
          re::TypeRegistry::typeInfo(v41[0], *(void *)v42, buf);
          re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v55 + 4);
          uint64_t result = re::internal::translateType(v36, (const re::TypeRegistry *)v39, (uint64_t)buf);
          if (!*(unsigned char *)(a1 + 64)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint8_t *, uint8_t *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
          }
        }
        else
        {
          re::TypeMemberCollection::operator[](v45, (int)v31, (uint64_t)v39);
          uint64_t v32 = *(unsigned int *)(v40 + 24);
          re::TypeRegistry::typeInfo(v39[0], *(void *)v40, buf);
          re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v55 + 4);
          re::TypeRegistry::typeInfo(v41[0], *(void *)v42, buf);
          uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v55 + 4);
          if (!*(unsigned char *)(a1 + 64)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, a2 + v32, v38, v37, a5);
          }
        }
      }
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 192);
  uint64_t result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5) {
    BOOL v7 = result == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = *result;
    uint64_t v10 = a3;
    unint64_t v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 208, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"BOOL", a7);
}

uint64_t re::serializeChar<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"char", a7);
}

uint64_t re::serializeI8<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"int8", a7);
}

uint64_t re::serializeI16<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  __int16 v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (char *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"int16", a7);
}

uint64_t re::serializeI32<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (char *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"int32", a7);
}

uint64_t re::serializeI64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (char *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"int64", a7);
}

uint64_t re::serializeU8<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = &v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"uint8", a7);
}

uint64_t re::serializeU16<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  __int16 v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (char *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"uint16", a7);
}

uint64_t re::serializeU32<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (char *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"uint32", a7);
}

uint64_t re::serializeU64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (char *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"uint64", a7);
}

uint64_t re::serializeFloat<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (char *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"float", a7);
}

uint64_t re::serializeDouble<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v20 = 0;
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v16 = **((void **)a5 + 2);
      uint64_t v17 = **((void **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        BOOL v19 = WORD1(v16) == WORD1(v17);
        uint64_t v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        BOOL v19 = v19 && v18 == 0;
        if (v19) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7) {
    uint64_t v14 = (char *)&v20;
  }
  else {
    uint64_t v14 = a4;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"double", a7);
}

BOOL re::serializeCString<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_23:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v24 = **((void **)a5 + 2);
    uint64_t v25 = **((void **)a6 + 2);
    if ((unsigned __int16)v24 != (unsigned __int16)v25) {
      goto LABEL_23;
    }
    BOOL v27 = WORD1(v24) == WORD1(v25);
    uint64_t v26 = (v25 ^ v24) & 0xFFFFFF00000000;
    BOOL v27 = v27 && v26 == 0;
    if (!v27) {
      goto LABEL_23;
    }
  }
LABEL_4:
  if (a7)
  {
    int v29 = 0;
    int v19 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, (uint64_t)a3, &v29, 0);
    BOOL result = 0;
    if (!v19) {
      return result;
    }
    if (v29)
    {
      if (v29 == 1)
      {
        re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, (char)v28);
        return 0;
      }
      uint64_t v28 = 0;
      if (re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (unint64_t *)&v28, 0))
      {
        if (v28) {
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
        }
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    uint64_t v23 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    int v29 = 2 * (*a4 != 0);
    int v21 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, (uint64_t)a3, &v29, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    if (v29 == 2)
    {
      uint64_t v22 = *a4;
      if (*a4) {
        uint64_t v22 = (const char *)strlen(v22);
      }
      uint64_t v28 = v22;
      if (re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (unint64_t *)&v28, 0))
      {
        if (v28) {
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, *a4, 0);
        }
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    uint64_t v23 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer(v23);
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::serializeStringID<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (int v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    size_t v23 = 0;
    BOOL v21 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v23, 0);
    BOOL result = 0;
    if (!v21) {
      return result;
    }
    if (v23) {
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    size_t v23 = strlen(*(const char **)(a4 + 8));
    BOOL result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v23, 0);
    if (!result) {
      return result;
    }
    if (v23) {
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, *(char **)(a4 + 8), 0);
    }
    uint64_t v22 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString(v22);
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_28:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v23 = **((void **)a5 + 2);
    uint64_t v24 = **((void **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24) {
      goto LABEL_28;
    }
    BOOL v26 = WORD1(v23) == WORD1(v24);
    uint64_t v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    BOOL v26 = v26 && v25 == 0;
    if (!v26) {
      goto LABEL_28;
    }
  }
LABEL_4:
  if (!a7)
  {
    unint64_t v16 = **((void **)a5 + 2);
    uint64_t v32 = *(void *)a5;
    unint64_t v33 = v16;
    LODWORD(v34) = -1;
    v36[0] = 0x258C98EAAF29A10ALL;
    v36[1] = (unint64_t)"CallbackSerializerAttribute";
    BOOL v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v32, v36);
    re::StringID::destroyString((re::StringID *)v36);
    uint64_t v18 = *v17;
    uint64_t v19 = *(void *)(a1 + 184);
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v32 = v20;
    unint64_t v33 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    if ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v18 + 72))(v19, v18, a4, &v32))
    {
      if (v33) {
        unint64_t v21 = v33 >> 1;
      }
      else {
        unint64_t v21 = v33 >> 1;
      }
      v36[0] = v21;
      if (re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, v36, 0))
      {
        if (v36[0])
        {
          if (v33) {
            uint64_t v22 = v34;
          }
          else {
            uint64_t v22 = (char *)&v33 + 1;
          }
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, v22, 0);
        }
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
        if (v32 && (v33 & 1) != 0) {
          (*(void (**)(void))(*(void *)v32 + 40))();
        }
        return *(unsigned char *)(a1 + 64) == 0;
      }
    }
    else
    {
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Failed to write string for \"%s\" (type %s) using serialization callback.", v27, v28, v29, v30, v31, (char)a2);
    }
    if (v32 && (v33 & 1) != 0) {
      (*(void (**)(void))(*(void *)v32 + 40))();
    }
    return 0;
  }
  uint64_t v32 = 0;
  BOOL v14 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (unint64_t *)&v32, 0);
  BOOL result = 0;
  if (v14)
  {
    if (v32) {
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
    }
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(uint64_t a1, const char *a2, uint64_t a3, int *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  int v10 = *a4;
  if (*a4 == 2)
  {
    char v11 = 73;
  }
  else if (v10 == 1)
  {
    char v11 = 82;
  }
  else
  {
    if (v10)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Unexpected PointerEncoding.", "!\"Unreachable code\"", "beginPointer", 410);
      uint64_t result = _os_crash();
      __break(1u);
      return result;
    }
    char v11 = 78;
  }
  char v18 = v11;
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1, a2, 0, &v18, (uint64_t)"uint8", 2);
  BOOL v12 = *a4 != 0;
  LOBYTE(v13) = 9;
  DWORD1(v13) = a5;
  *((void *)&v13 + 1) = a2;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  BOOL v15 = v12;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v13);
  return *(unsigned char *)(a1 + 40) == 0;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer(_anonymous_namespace_ *result)
{
  if (!*((unsigned char *)result + 40))
  {
    uint64_t v1 = (uint64_t)result;
    if (*(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 16) == *(void *)(*((void *)result + 16) + 48 * *((void *)result + 14) - 24))
    {
      uint64_t result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 9);
      uint64_t v2 = *(void *)(v1 + 128) + 48 * *(void *)(v1 + 112);
      ++*(void *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v4);
      if (v5) {
        unint64_t v3 = *(unsigned char **)&v6[7];
      }
      else {
        unint64_t v3 = v6;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". No value was provided.", (re::DynamicString *)v7, v3);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v7);
      if (*(void *)&v7[0])
      {
        if (BYTE8(v7[0])) {
          (*(void (**)(void))(**(void **)&v7[0] + 40))();
        }
        memset(v7, 0, sizeof(v7));
      }
      uint64_t result = v4;
      if (v4)
      {
        if (v5) {
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v4 + 40))();
        }
      }
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  if (!*(void *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  unint64_t v7 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v7);
  if (v8 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  while (*(void *)(v9 + 24 * v8 + 4) != v6)
  {
    uint64_t v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v10 = 3 * v8;
  *(void *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  uint64_t v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v13) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(void *)(*(void *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10 + 4), *(void *)&v13[16] + v10 + 4, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

BOOL re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::serializeCString(unsigned char *a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_15:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a5, a6);
      return 0;
    }
    uint64_t v17 = **((void **)a5 + 2);
    uint64_t v18 = **((void **)a6 + 2);
    if ((unsigned __int16)v17 != (unsigned __int16)v18) {
      goto LABEL_15;
    }
    BOOL v20 = WORD1(v17) == WORD1(v18);
    uint64_t v19 = (v18 ^ v17) & 0xFFFFFF00000000;
    BOOL v20 = v20 && v19 == 0;
    if (!v20) {
      goto LABEL_15;
    }
  }
LABEL_4:
  if (!*a4)
  {
    LODWORD(v26) = 0;
    uint64_t v14 = (_anonymous_namespace_ *)(a1 + 24);
    int v23 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer((uint64_t)(a1 + 24), a2, (uint64_t)a3, (int *)&v26, 0);
    BOOL result = 0;
    if (!v23) {
      return result;
    }
    goto LABEL_23;
  }
  if (!a1[256]
    || (BOOL v26 = *a4,
        (signed int v12 = (int *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(a1 + 264), (uint64_t *)&v26)) == 0))
  {
    int v25 = 2;
    if (re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer((uint64_t)(a1 + 24), a2, (uint64_t)a3, &v25, 0))
    {
      BOOL v26 = (const char *)strlen(*a4);
      BOOL result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (unint64_t *)&v26, 0);
      if (!result) {
        return result;
      }
      if (v26) {
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString((uint64_t)(a1 + 24), (char *)*a4, 0);
      }
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      unint64_t v21 = *a4;
      uint64_t v22 = **((void **)a5 + 2);
      *(void *)&long long v24 = *(void *)a5;
      *((void *)&v24 + 1) = v22;
      re::internal::SharedObjectGraph::addObject((uint64_t)(a1 + 256), (uint64_t)v21, &v24);
      return a1[64] == 0;
    }
    return 0;
  }
  int v13 = *v12;
  int v25 = 1;
  LODWORD(v26) = v13;
  uint64_t v14 = (_anonymous_namespace_ *)(a1 + 24);
  int v15 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer((uint64_t)(a1 + 24), a2, (uint64_t)a3, &v25, 0);
  BOOL result = 0;
  if (!v15) {
    return result;
  }
  if (!a1[64]) {
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>((uint64_t)(a1 + 24), "ID", 0, (char *)&v26, (uint64_t)"Reference ID", 0);
  }
LABEL_23:
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer(v14);
  return a1[64] == 0;
}

uint64_t re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  isPointerToPolymorphicuint64_t Type = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6) {
    goto LABEL_4;
  }
  if (*(void *)this == *(void *)a6)
  {
    uint64_t v30 = **((void **)this + 2);
    uint64_t v31 = **((void **)a6 + 2);
    if ((unsigned __int16)v30 == (unsigned __int16)v31)
    {
      BOOL v33 = WORD1(v30) == WORD1(v31);
      uint64_t v32 = (v31 ^ v30) & 0xFFFFFF00000000;
      BOOL v33 = v33 && v32 == 0;
      if (v33) {
        goto LABEL_4;
      }
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    int v16 = 0;
    goto LABEL_5;
  }
  if (*((unsigned char *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (uint64_t v34 = re::TypeInfo::name(this), v35 = re::TypeInfo::name(a6), !re::StringID::operator==(v34, v35))))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, this, a6);
    return 0;
  }
  int v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v42);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)v43);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v42);
  re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)v43);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    uint64_t v22 = *(void *)v41[2];
    *(void *)&long long v39 = v41[0];
    *((void *)&v39 + 1) = v22;
    if (v41[0]) {
      goto LABEL_8;
    }
    goto LABEL_16;
  }
  re::internal::actualType(a4, (void **)this, &v39);
  if (!(void)v39)
  {
LABEL_16:
    int v23 = re::TypeInfo::name(this);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Failed to get actual type of polymorphic object. Type \"%s\".", v24, v25, v26, v27, v28, v23[1]);
    return 0;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, (re **)&v39, &v42);
  re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)v43);
  if ((a7 & 1) == 0)
  {
    uint64_t v17 = *a4;
    if (*a4)
    {
      if (*(unsigned char *)(a1 + 256))
      {
        uint64_t v42 = *a4;
        uint64_t v18 = (_DWORD *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 264, (uint64_t *)&v42);
        if (v18)
        {
          LODWORD(v42) = *v18;
          int v37 = 1;
          uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
          int v20 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, a3, &v37, 0);
          uint64_t result = 0;
          if (v20)
          {
            if (!*(unsigned char *)(a1 + 64)) {
              re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, "ID", 0, (char *)&v42, (uint64_t)"Reference ID", 0);
            }
            goto LABEL_18;
          }
          return result;
        }
        uint64_t v17 = *a4;
      }
      long long v36 = v39;
      re::internal::SharedObjectGraph::beginObject((void *)(a1 + 256), (uint64_t)v17, &v36);
      LODWORD(v42) = 2;
      uint64_t result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, a3, (int *)&v42, 0);
      if (result)
      {
        if (isPointerToPolymorphicType)
        {
          re::internal::serializePolymorphicObject<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, (uint64_t)*a4, (re::TypeInfo *)v38, v40, v16);
        }
        else if (!*(unsigned char *)(a1 + 64))
        {
          (*(void (**)(uint64_t, const char *, void, char *, void *, re::TypeRegistry **, void))(*(void *)a1 + 72))(a1, a2, 0, *a4, v41, v40, 0);
        }
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        if (*(unsigned char *)(a1 + 256))
        {
          --*(void *)(a1 + 408);
          ++*(_DWORD *)(a1 + 416);
        }
        return *(unsigned char *)(a1 + 64) == 0;
      }
      return result;
    }
  }
  LODWORD(v42) = 0;
  uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  int v29 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, a3, (int *)&v42, 0);
  uint64_t result = 0;
  if (v29)
  {
LABEL_18:
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer(v19);
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return result;
}

void *re::internal::SharedObjectGraph::addObject(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *a3;
  uint64_t result = re::internal::SharedObjectGraph::beginObject((void *)a1, a2, &v5);
  if (*(unsigned char *)a1)
  {
    --*(void *)(a1 + 152);
    ++*(_DWORD *)(a1 + 160);
  }
  return result;
}

BOOL re::internal::serializePolymorphicObject<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, re::TypeRegistry **a6, int a7)
{
  re::TypeInfo::TypeInfo((uint64_t)v29, (uint64_t)a5);
  if (a7)
  {
    int v13 = *a6;
    uint64_t v14 = re::TypeInfo::name(a5);
    re::TypeRegistry::typeInfo(v13, (const re::StringID *)v14, v31);
    if (!LOBYTE(v31[0]))
    {
      uint64_t v27 = re::TypeInfo::name(a5)[1];
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "No matching type found for polymorphic type \"%s\" to serialize.", v21, v22, v23, v24, v25, v27);
      return 0;
    }
    re::TypeInfo::operator=((uint64_t)v29, (uint64_t)v31 + 8);
  }
  if (!*(unsigned char *)(v30 + 120))
  {
    uint64_t v26 = re::TypeInfo::name((re::TypeInfo *)v29)[1];
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Failed to get custom class ID for type \"%s\".", v16, v17, v18, v19, v20, v26);
    return 0;
  }
  uint64_t v28 = *(void *)(v30 + 128);
  if (*(unsigned char *)(a1 + 64)) {
    return 0;
  }
  LOBYTE(v31[0]) = 1;
  DWORD1(v31[0]) = 0;
  *((void *)&v31[0] + 1) = a2;
  memset(&v31[1], 0, 32);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)(a1 + 24), v31);
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, "customClassID", 1, (char *)&v28, (uint64_t)"uint64", 0);
  if (!*(unsigned char *)(a1 + 64)) {
    (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, re::TypeInfo *, unsigned char *, void))(*(void *)a1 + 72))(a1, "object", 10, a4, a5, v29, 0);
  }
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
  return *(unsigned char *)(a1 + 64) == 0;
}

re::NetworkCompatDeserializer *re::NetworkCompatDeserializer::NetworkCompatDeserializer(re::NetworkCompatDeserializer *this)
{
  *(void *)&v4.var0 = 0xEFB8C0610360E046;
  v4.var1 = "NetworkCompatDeserializer";
  uint64_t v2 = re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::SerializerV1((uint64_t)this, &v4);
  *(void *)uint64_t v2 = &unk_26E6C7508;
  *(_OWORD *)(v2 + 432) = 0u;
  *(_OWORD *)(v2 + 448) = 0u;
  *(void *)(v2 + 184) = v2 + 440;
  re::StringID::destroyString((re::StringID *)&v4);
  *(void *)this = &unk_26E6C7448;
  return this;
}

void re::NetworkCompatDeserializer::~NetworkCompatDeserializer(re::NetworkCompatDeserializer *this)
{
  *(void *)this = &unk_26E6C7570;
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 392);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 352);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 312);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer((uint64_t)this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6C7570;
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 392);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 352);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 312);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer((uint64_t)this);
  JUMPOUT(0x237DBCBD0);
}

void *re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::trackObject(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((void *)(a1 + 256), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::untrackObject(uint64_t result)
{
  if (*(unsigned char *)(result + 256))
  {
    --*(void *)(result + 408);
    ++*(_DWORD *)(result + 416);
  }
  return result;
}

void re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>>::doOpen(uint64_t a1)
{
  *(unsigned char *)(a1 + 257) = 1;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(void *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(void *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(void *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::doClose(uint64_t a1)
{
  *(void *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(void *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(void *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v11 = 6059476;
  signed int v12 = "BOOL";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 6104748;
  signed int v12 = "char";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x172E117BCLL;
  signed int v12 = "int8_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93A4A92;
  signed int v12 = "int16_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93BFE06;
  signed int v12 = "int32_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2CE93EC744;
  signed int v12 = "int64_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 6655224;
  signed int v12 = "long";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x31CD534126;
  signed int v12 = "uint8_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD0D4E68;
  signed int v12 = "uint16_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD0F01DCLL;
  signed int v12 = "uint32_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x607DD11CB1ALL;
  signed int v12 = "uint64_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x1947BDF6CLL;
  signed int v12 = "size_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 195052728;
  signed int v12 = "float";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x161EEF7A2;
  signed int v12 = "double";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 189247272;
  signed int v12 = "char*";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x2686EB529B3EE220;
  signed int v12 = "DynamicString";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v11 = 0x458DDB01A18;
  signed int v12 = "StringID";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  uint64_t v2 = *(void *)(a1 + 192);
  uint64_t v11 = 0x258C98EAAF29A10ALL;
  signed int v12 = "CallbackSerializerAttribute";
  unint64_t v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    uint64_t v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      uint64_t v5 = *(void *)(a1 + 192);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        uint64_t v6 = a1 + 208;
        unsigned int v7 = (uint64_t *)(v14 + 24);
        uint64_t v8 = 48 * v13;
        do
        {
          uint64_t v9 = *v7;
          v7 += 6;
          uint64_t v16 = re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::FixedArrayInputStream>>;
          unint64_t v15 = v9 | 0xFFFFFFFF00000000;
          re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v6, &v15, &v16);
          v8 -= 48;
        }
        while (v8);
      }
      if (v11)
      {
        if (v14) {
          (*(void (**)(void))(*(void *)v11 + 40))();
        }
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = (unsigned char *)(a1 + 256);
  uint64_t v15 = *(void *)(a1 + 408);
  if (!v15)
  {
    if (a7) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = a4;
    }
    uint64_t v17 = **((void **)a5 + 2);
    *(void *)&long long v26 = *(void *)a5;
    *((void *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((void *)(a1 + 256), v16, &v26);
  }
  uint64_t v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(void *)a1 + 80))(a1, a5);
  if (v18)
  {
    uint64_t result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(void *)(a1 + 408);
        ++*(_DWORD *)(a1 + 416);
      }
    }
  }
  else
  {
    uint64_t v20 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v21, v22, v23, v24, v25, v20[1]);
    return 0;
  }
  return result;
}

uint64_t (*re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(re::Allocator **a1, const char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    uint64_t v6 = (char *)v4[1];
    unsigned int v7 = re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::serializeCString;
    if (v6 == "char*") {
      return (uint64_t (*)(re::Allocator **, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v7;
    }
    int v8 = strcmp(v6, "char*");
    unsigned int v7 = re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::serializeCString;
    if (!v8) {
      return (uint64_t (*)(re::Allocator **, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v7;
    }
  }
  if (*((unsigned char *)this + 12) != 9) {
    goto LABEL_9;
  }
  unsigned int v9 = *(unsigned __int8 *)(*((void *)this + 2) + 80);
  unsigned int v7 = re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::serializePointer;
  if (v9 >= 2)
  {
    if (v9 != 2)
    {
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      uint64_t result = (uint64_t (*)(re::Allocator **, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))_os_crash();
      __break(1u);
      return result;
    }
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
    _os_crash();
    __break(1u);
LABEL_9:
    if (*(void *)this == *(void *)(a1 + 192))
    {
      LODWORD(v12) = **((void **)this + 2);
      HIDWORD(v12) = -1;
      uint64_t v10 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 208, &v12);
      unsigned int v7 = re::serializeType<re::EncoderBinary<re::FixedArrayInputStream>>;
      if (v10) {
        return *(uint64_t (**)(re::Allocator **, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v10;
      }
    }
    else
    {
      return re::serializeType<re::EncoderBinary<re::FixedArrayInputStream>>;
    }
  }
  return (uint64_t (*)(re::Allocator **, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v7;
}

uint64_t re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::SerializerV1(uint64_t a1, const StringID *a2)
{
  *(void *)a1 = &unk_26E6C75D8;
  re::StringID::StringID((re::StringID *)(a1 + 8), a2);
  re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::Encoder(a1 + 24, 13);
  *(_DWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(void *)(a1 + 244) = 0x7FFFFFFFLL;
  *(void *)a1 = &unk_26E6C7570;
  *(_WORD *)(a1 + 2re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 1;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_DWORD *)(a1 + 296) = 0;
  *(void *)(a1 + 300) = 0x7FFFFFFFLL;
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(void *)(a1 + 424) = 0;
  *(_DWORD *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_DWORD *)(a1 + 416) = 0;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  return a1;
}

uint64_t re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>>::~NetworkSerializerBase(void *a1)
{
  *a1 = &unk_26E6C7570;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 44));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 39));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 33);
  return re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer((uint64_t)a1);
}

void re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>>::~NetworkSerializerBase(void *a1)
{
  *a1 = &unk_26E6C7570;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 44));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 39));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 33);
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer((uint64_t)a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::~SerializerV1(void *a1)
{
  *a1 = &unk_26E6C7570;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 44));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 39));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 33);
  return re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer((uint64_t)a1);
}

void re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::~SerializerV1(void *a1)
{
  *a1 = &unk_26E6C7570;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 49));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 44));
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 39));
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 33);
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer((uint64_t)a1);
  JUMPOUT(0x237DBCBD0);
}

void re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::doOpen(uint64_t a1)
{
  *(unsigned char *)(a1 + 257) = 1;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(void *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(void *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(void *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer(a1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(void *)a1 + 80))(a1, a5);
  if (v14)
  {
    return v14(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    uint64_t v16 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
    return 0;
  }
}

uint64_t (*re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(re::Allocator **a1, const char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a2 == *(void *)(a1 + 192)
    && (LODWORD(v4) = **(void **)(a2 + 16),
        HIDWORD(v4) = -1,
        (uint64_t v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 208, &v4)) != 0))
  {
    return *(uint64_t (**)(re::Allocator **, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderBinary<re::FixedArrayInputStream>>;
  }
}

uint64_t re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::Encoder(uint64_t result, int a2)
{
  *(void *)(result + 128) = 0;
  *(void *)(result + 104) = 0;
  *(void *)(result + ++*(void *)(this + 112) = 0;
  *(void *)(result + 96) = 0;
  *(_DWORD *)(result + 120) = 0;
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(unsigned char *)(result + 40) = 0;
  *(_DWORD *)(result + 136) = a2;
  *(unsigned char *)(result + 140) = 0;
  *(void *)(result + 152) = 1024;
  uint64_t v2 = &qword_268772000;
  {
    uint64_t v8 = result;
    uint64_t v2 = &qword_268772000;
    int v6 = v4;
    uint64_t result = v8;
    if (v6)
    {
      re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v5, (uint64_t)v9);
      uint64_t v7 = v10;
      if (!v9[0]) {
        uint64_t v7 = 0;
      }
      re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::Encoder(int)::s_maxSerializationDepth = v7;
      uint64_t v2 = &qword_268772000;
      uint64_t result = v8;
    }
  }
  uint64_t v3 = v2[293];
  if (v3) {
    *(void *)(result + 152) = v3;
  }
  return result;
}

uint64_t re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer(uint64_t a1)
{
  *(void *)a1 = &unk_26E6C75D8;
  uint64_t v2 = (re::StringID *)(a1 + 8);
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::deinit((void *)a1);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 208));
  re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::~Encoder((unsigned char *)(a1 + 24));
  re::StringID::destroyString(v2);
  return a1;
}

void re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::deinit(void *a1)
{
  if (a1[24])
  {
    (*(void (**)(void *))(*a1 + 40))(a1);
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
    a1[24] = 0;
  }
}

unsigned char *re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::~Encoder(unsigned char *a1)
{
  if (a1[40]) {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 64));
  }
  return a1;
}

_anonymous_namespace_ *re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::close(_anonymous_namespace_ *result)
{
  if (*(void *)result)
  {
    uint64_t v1 = result;
    re::EncoderBinary<re::FixedArrayInputStream>::doClose((uint64_t)result);
    if (!*((unsigned char *)v1 + 40)) {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 0);
    }
    uint64_t result = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::deinit((uint64_t)v1 + 96);
    if (*((int *)v1 + 4) >= 1)
    {
      uint64_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)v1 + 24))();
      *((void *)v1 + 1) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *(void *)uint64_t v1 = 0;
    *((void *)v1 + 3) = 0;
    *((void *)v1 + 4) = 0;
  }
  return result;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::doClose(uint64_t result)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v1 = result;
    char v9 = 69;
    uint64_t result = re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(result, "End-of-file", 0, &v9, (uint64_t)"uint8", 0);
    if (v9 != 69)
    {
      re::DynamicString::format((re::DynamicString *)"Failed to read end-of-file marker.", (re::DynamicString *)&v2);
      *(void *)&long long v5 = 400;
      *((void *)&v5 + 1) = re::FoundationErrorCategory(void)::instance;
      uint64_t v6 = v2;
      uint64_t v8 = v4;
      long long v7 = v3;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, &v5);
      uint64_t result = v6;
      if (v6)
      {
        if (v7) {
          return (*(uint64_t (**)(void))(*(void *)v6 + 40))();
        }
      }
    }
  }
  return result;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  if (a6) {
    a4 = 0;
  }
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, a4, 1uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v11 - 16);
  }
  return 1;
}

uint64_t re::serializeType<re::EncoderBinary<re::FixedArrayInputStream>>(re::Allocator **a1, const char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (this == (re::TypeInfo *)a6) {
    goto LABEL_19;
  }
  if (*(void *)this != *(void *)a6)
  {
    if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, a3)) {
      goto LABEL_19;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      uint64_t v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
      if (v19) {
        int v20 = *(_DWORD *)(v19 + 16);
      }
      else {
        int v20 = -1;
      }
      uint64_t v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
      if (v21) {
        int v22 = *(_DWORD *)(v21 + 16);
      }
      else {
        int v22 = -1;
      }
      if (v20 == v22) {
        goto LABEL_19;
      }
      uint64_t v24 = re::TypeInfo::name(this);
      uint64_t v25 = re::TypeInfo::name((re::TypeInfo *)a6);
      if (re::StringID::operator==(v24, v25))
      {
        uint64_t v26 = re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
        if (v26) {
          int v27 = *(_DWORD *)(v26 + 16);
        }
        else {
          int v27 = -1;
        }
        re::TypeInfo::atVersion(this, v27, v58);
        if (v58[0])
        {
          if (a7) {
            Instance = 0;
          }
          else {
            Instance = re::TypeInfo::createInstance((re::TypeInfo *)v59, a1[6], a1[23]);
          }
          if (*((unsigned char *)a1 + 64)
            || ((*((void (**)(re::Allocator **, const char *, const re::TypeInfo *, void **, unsigned char *, uint64_t, uint64_t))*a1
                 + 9))(a1, a2, a3, Instance, v59, a6, a7), *((unsigned char *)a1 + 64)))
          {
            if (Instance) {
              re::TypeInfo::releaseInstance((re::TypeInfo *)v59, Instance, a1[6], a1[23]);
            }
          }
          else
          {
            if (a7) {
              return 1;
            }
            re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v59);
            re::internal::upgradeObject(Instance, v53, a4, (uint64_t **)this, a1[6], a1[23], v54);
            if (v54[0]) {
              return 1;
            }
            if (v56) {
              LOBYTE(v51) = v57[7];
            }
            else {
              uint64_t v51 = v57;
            }
            re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "%s", v46, v47, v48, v49, v50, (char)v51);
            if (!v54[0] && v55 && (v56 & 1) != 0) {
              (*(void (**)(void))(*(void *)v55 + 40))();
            }
          }
        }
        else
        {
          uint64_t v35 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
          re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Unknown serialized type \"%s\" version %u. No matching runtime type found.", v41, v42, v43, v44, v45, v35);
        }
      }
      else
      {
        uint64_t v33 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
        re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)a6 + 96, **(void **)(a6 + 16));
        re::TypeInfo::name(this);
        re::DataArray<re::TextureAtlasTile>::tryGet(*(void *)this + 96, **((void **)this + 2));
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Type name changed: Serialized type \"%s\" version %u, runtime type \"%s\" version %u.", v36, v37, v38, v39, v40, v33);
      }
    }
    else
    {
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, this, (re::TypeInfo *)a6);
    }
    return 0;
  }
  uint64_t v15 = **((void **)this + 2);
  uint64_t v16 = **(void **)(a6 + 16);
  if ((unsigned __int16)v15 != (unsigned __int16)v16) {
    goto LABEL_10;
  }
  BOOL v18 = WORD1(v15) == WORD1(v16);
  uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
  BOOL v18 = v18 && v17 == 0;
  if (!v18) {
    goto LABEL_10;
  }
LABEL_19:
  switch(*((unsigned char *)this + 12))
  {
    case 1:
      uint64_t result = re::serializeBasic<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 2:
      uint64_t result = re::serializeEnum<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, a4, (uint64_t)this, a6, a7);
      break;
    case 3:
      uint64_t result = re::serializeOptional<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 4:
      uint64_t result = re::serializeArray<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 5:
      uint64_t result = re::serializeList<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 6:
      uint64_t result = re::serializeDictionary<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 7:
      uint64_t result = re::serializeUnion<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 8:
      uint64_t result = re::serializeObject<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)a4, this, a6, a7);
      break;
    case 9:
      uint64_t v52 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Pointer type (\"%s\") needs to be handled explicitly by the serializer.", v28, v29, v30, v31, v32, v52);
      return 0;
    default:
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Invalid type category. Value = %d", (uint64_t)a4, (uint64_t)this, a6, a7, a8, *((unsigned char *)this + 12));
      return 0;
  }
  return result;
}

uint64_t re::serializeBasic<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  if (this != a6)
  {
    if (*(void *)this != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3)) {
        goto LABEL_4;
      }
LABEL_21:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, this, a6);
      return 0;
    }
    uint64_t v24 = **((void **)this + 2);
    uint64_t v25 = **((void **)a6 + 2);
    if ((unsigned __int16)v24 != (unsigned __int16)v25) {
      goto LABEL_21;
    }
    BOOL v27 = WORD1(v24) == WORD1(v25);
    uint64_t v26 = (v25 ^ v24) & 0xFFFFFF00000000;
    BOOL v27 = v27 && v26 == 0;
    if (!v27) {
      goto LABEL_21;
    }
  }
LABEL_4:
  uint64_t v14 = re::TypeInfo::name(this);
  unint64_t v15 = (unint64_t)*v14 >> 1;
  if (v15 <= 0xCA3DEFB5)
  {
    if ((unint64_t)*v14 >> 1 <= 0x5D0225B)
    {
      if ((unint64_t)*v14 >> 1 <= 0x2E9355)
      {
        if (v15 != 104431)
        {
          if (v15 == 3029738)
          {
            uint64_t v16 = a1 + 24;
            uint64_t v17 = "BOOL";
            BOOL v18 = a2;
            uint64_t v19 = (uint64_t)a3;
            int v20 = a4;
            char v21 = a7;
            return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(v16, v18, v19, v20, (uint64_t)v17, v21);
          }
          goto LABEL_72;
        }
        goto LABEL_54;
      }
      if (v15 == 3052374)
      {
        uint64_t v16 = a1 + 24;
        uint64_t v17 = "char";
        BOOL v18 = a2;
        uint64_t v19 = (uint64_t)a3;
        int v20 = a4;
        char v21 = a7;
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(v16, v18, v19, v20, (uint64_t)v17, v21);
      }
      uint64_t v34 = 3327612;
LABEL_40:
      if (v15 == v34)
      {
        uint64_t v35 = a1 + 24;
        uint64_t v36 = "int64";
        uint64_t v37 = a2;
        uint64_t v38 = (uint64_t)a3;
        uint64_t v39 = a4;
        char v40 = a7;
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(v35, v37, v38, v39, (uint64_t)v36, v40);
      }
      goto LABEL_72;
    }
    if ((unint64_t)*v14 >> 1 > 0xB0F77BD0)
    {
      if (v15 == 2969009105)
      {
        uint64_t v35 = a1 + 24;
        uint64_t v36 = "double";
        uint64_t v37 = a2;
        uint64_t v38 = (uint64_t)a3;
        uint64_t v39 = a4;
        char v40 = a7;
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(v35, v37, v38, v39, (uint64_t)v36, v40);
      }
      if (v15 == 3111160798)
      {
        uint64_t v16 = a1 + 24;
        uint64_t v17 = "int8";
        BOOL v18 = a2;
        uint64_t v19 = (uint64_t)a3;
        int v20 = a4;
        char v21 = a7;
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(v16, v18, v19, v20, (uint64_t)v17, v21);
      }
LABEL_72:
      uint64_t v47 = re::TypeInfo::name(this);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Unsupported basic type \"%s\".", v48, v49, v50, v51, v52, v47[1]);
      return 0;
    }
    if (v15 == 97526364)
    {
      uint64_t v41 = a1 + 24;
      uint64_t v42 = "float";
      uint64_t v43 = a2;
      uint64_t v44 = (uint64_t)a3;
      uint64_t v45 = a4;
      char v46 = a7;
      return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(v41, v43, v44, v45, (uint64_t)v42, v46);
    }
    uint64_t v23 = 109413500;
    goto LABEL_26;
  }
  if ((unint64_t)*v14 >> 1 > 0x18E6A9A092)
  {
    if ((unint64_t)*v14 >> 1 <= 0x303EE8780EDLL)
    {
      if (v15 == 0x18E6A9A093)
      {
        uint64_t v16 = a1 + 24;
        uint64_t v17 = "uint8";
        BOOL v18 = a2;
        uint64_t v19 = (uint64_t)a3;
        int v20 = a4;
        char v21 = a7;
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(v16, v18, v19, v20, (uint64_t)v17, v21);
      }
      if (v15 != 0x303EE86A734) {
        goto LABEL_72;
      }
      uint64_t v28 = a1 + 24;
      uint64_t v29 = "uint16";
      uint64_t v30 = a2;
      uint64_t v31 = (uint64_t)a3;
      uint64_t v32 = a4;
      char v33 = a7;
      return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(v28, v30, v31, v32, (uint64_t)v29, v33);
    }
    if (v15 == 0x303EE8780EELL)
    {
      uint64_t v41 = a1 + 24;
      uint64_t v42 = "uint32";
      uint64_t v43 = a2;
      uint64_t v44 = (uint64_t)a3;
      uint64_t v45 = a4;
      char v46 = a7;
      return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(v41, v43, v44, v45, (uint64_t)v42, v46);
    }
    if (v15 != 0x303EE88E58DLL) {
      goto LABEL_72;
    }
    goto LABEL_51;
  }
  if ((unint64_t)*v14 >> 1 <= 0x16749DFF02)
  {
    if (v15 != 3393056694)
    {
      uint64_t v23 = 0x16749D2549;
LABEL_26:
      if (v15 != v23) {
        goto LABEL_72;
      }
      uint64_t v28 = a1 + 24;
      uint64_t v29 = "int16";
      uint64_t v30 = a2;
      uint64_t v31 = (uint64_t)a3;
      uint64_t v32 = a4;
      char v33 = a7;
      return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(v28, v30, v31, v32, (uint64_t)v29, v33);
    }
LABEL_51:
    uint64_t v35 = a1 + 24;
    uint64_t v36 = "uint64";
    uint64_t v37 = a2;
    uint64_t v38 = (uint64_t)a3;
    uint64_t v39 = a4;
    char v40 = a7;
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(v35, v37, v38, v39, (uint64_t)v36, v40);
  }
  if (v15 != 0x16749DFF03)
  {
    uint64_t v34 = 0x16749F63A2;
    goto LABEL_40;
  }
LABEL_54:
  uint64_t v41 = a1 + 24;
  uint64_t v42 = "int32";
  uint64_t v43 = a2;
  uint64_t v44 = (uint64_t)a3;
  uint64_t v45 = a4;
  char v46 = a7;
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(v41, v43, v44, v45, (uint64_t)v42, v46);
}

uint64_t re::serializeEnum<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v14 = **(void **)(a5 + 16);
      uint64_t v15 = **(void **)(a6 + 16);
      if ((unsigned __int16)v14 == (unsigned __int16)v15)
      {
        BOOL v17 = WORD1(v14) == WORD1(v15);
        uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
        BOOL v17 = v17 && v16 == 0;
        if (v17) {
          goto LABEL_12;
        }
      }
    }
    else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
    {
      goto LABEL_12;
    }
    if (*(unsigned __int8 *)(a5 + 12) != *(unsigned __int8 *)(a6 + 12)
      || (BOOL v18 = re::TypeInfo::name((re::TypeInfo *)a5),
          uint64_t v19 = re::TypeInfo::name((re::TypeInfo *)a6),
          !re::StringID::operator==(v18, v19)))
    {
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
      return 0;
    }
  }
LABEL_12:
  return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
}

BOOL re::serializeOptional<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v25[0] = 0;
    re::EncoderBinary<re::FixedArrayInputStream>::beginOptional(a1 + 24, a2, (uint64_t)a3, v25, 0);
    if (v25[0])
    {
      BOOL v18 = *(re::internal **)(a1 + 192);
      re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v27);
      re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
      re::internal::translateType(v18, (const re::TypeRegistry *)v26, (uint64_t)v27);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, 0, 0, v27, v27, 1);
      }
    }
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)&v28);
    re::TypeInfo::TypeInfo((uint64_t)v27, (uint64_t)a5);
    BOOL v24 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4) != 0;
    double v20 = re::EncoderBinary<re::FixedArrayInputStream>::beginOptional(a1 + 24, a2, (uint64_t)a3, (char *)&v24, 0);
    if (v24)
    {
      Instance = re::TypeInfo::createInstance((re::TypeInfo *)v26, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
      (*(void (**)(uint64_t, void **))(v29 + 88))(a4, Instance);
      re::TypeInfo::releaseInstance((re::TypeInfo *)v26, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
    }
    else
    {
      (*(void (**)(uint64_t, void, double))(v29 + 88))(a4, 0, v20);
    }
    if (v24)
    {
      uint64_t v23 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, uint64_t, unsigned char *, char *, void))(*(void *)a1 + 72))(a1, a2, 0, v23, v26, v25, 0);
      }
    }
    uint64_t v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endOptional(v19);
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::serializeArray<re::EncoderBinary<re::FixedArrayInputStream>>(re::Allocator **a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v22 = **((void **)a5 + 2);
    uint64_t v23 = **((void **)a6 + 2);
    if ((unsigned __int16)v22 != (unsigned __int16)v23) {
      goto LABEL_13;
    }
    BOOL v25 = WORD1(v22) == WORD1(v23);
    uint64_t v24 = (v23 ^ v22) & 0xFFFFFF00000000;
    BOOL v25 = v25 && v24 == 0;
    if (!v25) {
      goto LABEL_13;
    }
LABEL_4:
    char v14 = 1;
    if (a7) {
      goto LABEL_5;
    }
LABEL_17:
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v75);
    re::TypeInfo::TypeInfo((uint64_t)v71, (uint64_t)v76);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v75);
    re::TypeInfo::TypeInfo((uint64_t)v69, (uint64_t)v76);
    re::TypeInfo::TypeInfo((uint64_t)v67, (uint64_t)a5);
    uint64_t v29 = (*((uint64_t (**)(re::Allocator **, unsigned char *))*a1 + 10))(a1, v71);
    if (!v29)
    {
      char v46 = (re::TypeInfo *)v71;
      goto LABEL_28;
    }
    uint64_t v30 = (void (*)(re::Allocator **, void, void, uint64_t, unsigned char *, unsigned char *, void))v29;
    uint64_t v31 = re::ArrayAccessor::size((re::ArrayAccessor *)v67, a4);
    unint64_t v66 = v31;
    int v32 = *(_DWORD *)(*((void *)a5 + 2) + 84) & 0xFFFFFF;
    if (v32) {
      int v33 = 8;
    }
    else {
      int v33 = 4;
    }
    BOOL result = re::EncoderBinary<re::FixedArrayInputStream>::beginArray((uint64_t)(a1 + 3), a2, (uint64_t)a3, (char *)&v66, v33);
    if (!result) {
      return result;
    }
    char v40 = (const re::TypeInfo *)v66;
    if (v31 != v66)
    {
      if ((*(_DWORD *)(v68 + 84) & 0xFFFFFF) == 0)
      {
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, 0, "Invalid array size. Expected size = %zu, actual size = %zu", v35, v36, v37, v38, v39, v31);
        return 0;
      }
      re::TypeRegistry::typeInfo(v67[0], *(void *)(v68 + 72), &v75);
      re::TypeInfo::TypeInfo((uint64_t)v73, (uint64_t)v76);
      if (!is_mul_ok(*(unsigned int *)(v74 + 8), (unint64_t)v40))
      {
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, 0, "Size overflow during deserialization. Element size = %zu, count = %zu", v41, v42, v43, v44, v45, *(_DWORD *)(v74 + 8));
        return 0;
      }
      re::ArrayAccessor::reset((re::ArrayAccessor *)v67, (void **)a4, a1[6], v40);
      uint64_t v31 = v66;
    }
    if (v32) {
      BOOL v57 = v31 == 0;
    }
    else {
      BOOL v57 = 1;
    }
    char v58 = v57;
    if (!v57)
    {
      uint64_t v59 = *(void *)a4;
      v65[0] = 0;
      v65[1] = 0xFFFFFFFFLL;
      (*((void (**)(re::Allocator **, uint64_t, void *))*a1 + 2))(a1, v59, v65);
      uint64_t v31 = v66;
    }
    if (v71[12] == 1) {
      char v60 = v14;
    }
    else {
      char v60 = 0;
    }
    if (v60)
    {
      if (v31)
      {
        uint64_t v61 = (char *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)v67, a4, 0);
        re::EncoderBinary<re::FixedArrayInputStream>::serializeArray((uint64_t)(a1 + 3), v61, *(unsigned int *)(v72 + 8), v66, 0);
      }
    }
    else if (v31)
    {
      unint64_t v62 = 0;
      do
      {
        uint64_t v63 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)v67, a4, v62);
        v30(a1, 0, 0, v63, v71, v69, 0);
        ++v62;
      }
      while (v62 < v66);
    }
    if ((v58 & 1) == 0) {
      (*((void (**)(re::Allocator **))*a1 + 3))(a1);
    }
    char v56 = (_anonymous_namespace_ *)(a1 + 3);
    goto LABEL_75;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_4;
  }
LABEL_13:
  if (*((unsigned char *)a6 + 12) != 4) {
    goto LABEL_45;
  }
  uint64_t v26 = *((void *)a5 + 2);
  BOOL v27 = (void *)*((void *)a6 + 2);
  int v28 = *((_DWORD *)v27 + 21) & 0xFFFFFF;
  if ((*(_DWORD *)(v26 + 84) & 0xFFFFFF) != 0)
  {
    if (v28) {
      goto LABEL_16;
    }
LABEL_45:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, a5, a6);
    return 0;
  }
  if (v28 || *(_DWORD *)(v26 + 88) != *((_DWORD *)v27 + 22)) {
    goto LABEL_45;
  }
LABEL_16:
  char v14 = 0;
  if (!a7) {
    goto LABEL_17;
  }
LABEL_5:
  uint64_t v15 = a1[24];
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v75);
  re::TypeInfo::TypeInfo((uint64_t)v71, (uint64_t)v76);
  re::internal::translateType(v15, (const re::TypeRegistry *)v71, (uint64_t)v73);
  uint64_t v16 = (*((uint64_t (**)(re::Allocator **, unsigned char *))*a1 + 10))(a1, v73);
  if (!v16)
  {
    char v46 = (re::TypeInfo *)v73;
LABEL_28:
    uint64_t v64 = re::TypeInfo::name(v46)[1];
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v47, v48, v49, v50, v51, v64);
    return 0;
  }
  BOOL v17 = (void (*)(re::Allocator **, void, void, void, unsigned char *, unsigned char *, uint64_t))v16;
  BOOL v18 = (void *)*((void *)a6 + 2);
  int v19 = *((_DWORD *)v18 + 21) & 0xFFFFFF;
  if (v19)
  {
    unint64_t v20 = 0;
    int v21 = 8;
  }
  else
  {
    unint64_t v20 = *((int *)v18 + 22);
    int v21 = 4;
  }
  unint64_t v75 = v20;
  BOOL result = re::EncoderBinary<re::FixedArrayInputStream>::beginArray((uint64_t)(a1 + 3), a2, (uint64_t)a3, (char *)&v75, v21);
  if (result)
  {
    uint64_t v52 = v75;
    if (v19) {
      BOOL v53 = v75 == 0;
    }
    else {
      BOOL v53 = 1;
    }
    char v54 = v53;
    if (!v53)
    {
      v70[0] = 0;
      v70[1] = 0xFFFFFFFFLL;
      (*((void (**)(re::Allocator **, void, void *))*a1 + 2))(a1, 0, v70);
      uint64_t v52 = v75;
    }
    if (v73[12] == 1)
    {
      if (v52) {
        re::EncoderBinary<re::FixedArrayInputStream>::serializeArray((uint64_t)(a1 + 3), 0, *(unsigned int *)(v74 + 8), v52, 1);
      }
    }
    else if (v52)
    {
      unint64_t v55 = 0;
      do
      {
        v17(a1, 0, 0, 0, v73, v73, 1);
        ++v55;
      }
      while (v55 < v75);
    }
    if ((v54 & 1) == 0) {
      (*((void (**)(re::Allocator **))*a1 + 3))(a1);
    }
    char v56 = (_anonymous_namespace_ *)(a1 + 3);
LABEL_75:
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endArray(v56);
    return *((unsigned char *)a1 + 64) == 0;
  }
  return result;
}

BOOL re::serializeList<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_15:
      if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
      {
        re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
        return 0;
      }
      char v14 = 0;
      if (a7) {
        goto LABEL_5;
      }
      goto LABEL_17;
    }
    uint64_t v20 = **((void **)a5 + 2);
    uint64_t v21 = **((void **)a6 + 2);
    if ((unsigned __int16)v20 != (unsigned __int16)v21) {
      goto LABEL_15;
    }
    BOOL v23 = WORD1(v20) == WORD1(v21);
    uint64_t v22 = (v21 ^ v20) & 0xFFFFFF00000000;
    BOOL v23 = v23 && v22 == 0;
    if (!v23) {
      goto LABEL_15;
    }
  }
LABEL_4:
  char v14 = 1;
  if (a7)
  {
LABEL_5:
    uint64_t v15 = *(re::internal **)(a1 + 192);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v66);
    re::TypeInfo::TypeInfo((uint64_t)v62, (uint64_t)v67);
    re::internal::translateType(v15, (const re::TypeRegistry *)v62, (uint64_t)v64);
    uint64_t v16 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v64);
    if (v16)
    {
      BOOL v17 = (void (*)(uint64_t, void, void, void, unsigned char *, unsigned char *, uint64_t))v16;
      unint64_t v66 = 0;
      BOOL v18 = re::EncoderBinary<re::FixedArrayInputStream>::beginArray(a1 + 24, a2, (uint64_t)a3, (char *)&v66, 0);
      BOOL result = 0;
      if (!v18) {
        return result;
      }
      if (v64[12] == 1)
      {
        if (v66) {
          re::EncoderBinary<re::FixedArrayInputStream>::serializeArray(a1 + 24, 0, *(unsigned int *)(v65 + 8), v66, 1);
        }
      }
      else if (v66)
      {
        for (unint64_t i = 0; i < v66; ++i)
          v17(a1, 0, 0, 0, v64, v64, 1);
      }
      uint64_t v37 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_54;
    }
    uint64_t v35 = (re::TypeInfo *)v64;
    goto LABEL_25;
  }
LABEL_17:
  re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v66);
  re::TypeInfo::TypeInfo((uint64_t)v62, (uint64_t)v67);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v66);
  re::TypeInfo::TypeInfo((uint64_t)v61, (uint64_t)v67);
  re::TypeInfo::TypeInfo((uint64_t)v59, (uint64_t)a5);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v62);
  if (!v24)
  {
    uint64_t v35 = (re::TypeInfo *)v62;
LABEL_25:
    uint64_t v56 = re::TypeInfo::name(v35)[1];
    uint64_t v34 = "Failed to resolve serialize function for type \"%s\"";
    goto LABEL_26;
  }
  BOOL v25 = (void (*)(uint64_t, void, void, uint64_t, unsigned char *, unsigned char *, void))v24;
  uint64_t v26 = (*(uint64_t (**)(uint64_t))(v60 + 80))(a4);
  unint64_t v58 = v26;
  BOOL v27 = re::EncoderBinary<re::FixedArrayInputStream>::beginArray(a1 + 24, a2, (uint64_t)a3, (char *)&v58, 0);
  BOOL result = 0;
  if (!v27) {
    return result;
  }
  unint64_t v28 = v58;
  if (v26 != v58)
  {
    re::TypeRegistry::typeInfo(v59[0], *(void *)(v60 + 72), &v66);
    re::TypeInfo::TypeInfo((uint64_t)v64, (uint64_t)v67);
    if (!is_mul_ok(*(unsigned int *)(v65 + 8), v28))
    {
      LODWORD(vre::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = *(_DWORD *)(v65 + 8);
      uint64_t v34 = "Size overflow during deserialization. Element size = %zu, count = %zu";
LABEL_26:
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, v34, v29, v30, v31, v32, v33, v56);
      return 0;
    }
    uint64_t v38 = *(void *)(a1 + 48);
    uint64_t v39 = *(void (**)(uint64_t, unint64_t *, uint64_t, unint64_t))(v60 + 88);
    re::TypeInfo::TypeInfo((uint64_t)&v66, (uint64_t)v59);
    v39(a4, &v66, v38, v28);
  }
  char v40 = *(uint64_t (**)(uint64_t, void))(v60 + 96);
  if (v40)
  {
    if (*((unsigned char *)a5 + 12) == 5) {
      char v41 = v14;
    }
    else {
      char v41 = 0;
    }
    if (v41)
    {
      unint64_t v42 = v58;
      if ((*(unsigned char *)(*((void *)a5 + 2) + 48) & 8) != 0 && v62[12] == 1)
      {
        if (v58)
        {
          uint64_t v43 = (char *)v40(a4, 0);
          re::EncoderBinary<re::FixedArrayInputStream>::serializeArray(a1 + 24, v43, *(unsigned int *)(v63 + 8), v58, 0);
        }
        goto LABEL_53;
      }
    }
    else
    {
      unint64_t v42 = v58;
    }
    if (v42)
    {
      unint64_t v48 = 0;
      do
      {
        uint64_t v49 = (*(uint64_t (**)(uint64_t, unint64_t))(v60 + 96))(a4, v48);
        v25(a1, 0, 0, v49, v62, v61, 0);
        ++v48;
      }
      while (v48 < v58);
    }
    goto LABEL_53;
  }
  uint64_t v44 = *(uint64_t (**)(uint64_t, void))(v60 + 104);
  if (!v44 || !*(void *)(v60 + 112) || !*(void *)(v60 + 120))
  {
    uint64_t v50 = (re::TypeInfo *)re::TypeInfo::TypeInfo((uint64_t)&v66, (uint64_t)v59);
    uint64_t v57 = re::TypeInfo::name(v50)[1];
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "List type \"%s\" does not provide an indexer or iterator.", v51, v52, v53, v54, v55, v57);
    return 0;
  }
  uint64_t v45 = v44(a4, *(void *)(a1 + 56));
  uint64_t v46 = (*(uint64_t (**)(void))(v60 + 112))();
  if (v46)
  {
    uint64_t v47 = v46;
    do
    {
      v25(a1, 0, 0, v47, v62, v61, 0);
      uint64_t v47 = (*(uint64_t (**)(uint64_t))(v60 + 112))(v45);
    }
    while (v47);
  }
  (*(void (**)(uint64_t, void))(v60 + 120))(v45, *(void *)(a1 + 56));
LABEL_53:
  uint64_t v37 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_54:
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endArray(v37);
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::serializeDictionary<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_11;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_11;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 72), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(void **)a5, *(void *)(*((void *)a5 + 2) + 80), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v51, (uint64_t)v56);
    re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)a5);
    uint64_t v29 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v54);
    if (v29)
    {
      uint64_t v30 = (void (*)(uint64_t, const char *, void, void **, unsigned char *, unsigned char *, void, double))v29;
      uint64_t v31 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v53);
      if (v31)
      {
        uint64_t v32 = (void (*)(uint64_t, const char *, void, uint64_t, unsigned char *, unsigned char *, void))v31;
        unint64_t v48 = (*(uint64_t (**)(uint64_t))(v50 + 88))(a4);
        uint64_t v24 = (_anonymous_namespace_ *)(a1 + 24);
        BOOL v33 = re::EncoderBinary<re::FixedArrayInputStream>::beginDictionary(a1 + 24, a2, (uint64_t)a3, (char *)&v48, 0);
        BOOL result = 0;
        if (!v33) {
          return result;
        }
        uint64_t v34 = *(void *)(a1 + 48);
        uint64_t v35 = *(void (**)(uint64_t, unint64_t *, uint64_t))(v50 + 96);
        re::TypeInfo::TypeInfo((uint64_t)&v55, (uint64_t)v49);
        v35(a4, &v55, v34);
        if (v48)
        {
          Instance = re::TypeInfo::createInstance((re::TypeInfo *)v54, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
          if (v48)
          {
            uint64_t v37 = 0;
            while (1)
            {
              double v38 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
              v30(a1, "key", 0, Instance, v54, v52, 0, v38);
              uint64_t v39 = *(re::Allocator **)(a1 + 48);
              if (*(unsigned char *)(a1 + 64)) {
                break;
              }
              uint64_t v40 = (*(uint64_t (**)(uint64_t, unsigned char *, re::Allocator *, void **))(v50 + 104))(a4, v49, v39, Instance);
              v32(a1, "value", 0, v40, v53, v51, 0);
              re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
              if (++v37 >= v48) {
                goto LABEL_27;
              }
            }
            re::TypeInfo::releaseInstance((re::TypeInfo *)v54, Instance, v39, *(void **)(a1 + 184));
            return 0;
          }
LABEL_27:
          re::TypeInfo::releaseInstance((re::TypeInfo *)v54, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
        }
LABEL_28:
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionary(v24);
        return *(unsigned char *)(a1 + 64) == 0;
      }
      goto LABEL_31;
    }
LABEL_29:
    char v41 = (re::TypeInfo *)v54;
LABEL_32:
    unint64_t v42 = re::TypeInfo::name(v41);
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v43, v44, v45, v46, v47, v42[1]);
    return 0;
  }
  BOOL v18 = *(re::internal **)(a1 + 192);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
  re::internal::translateType(v18, (const re::TypeRegistry *)v53, (uint64_t)v54);
  int v19 = *(re::internal **)(a1 + 192);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
  re::internal::translateType(v19, (const re::TypeRegistry *)v52, (uint64_t)v53);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v54);
  if (!v20) {
    goto LABEL_29;
  }
  uint64_t v21 = (void (*)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t, double))v20;
  uint64_t v22 = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)a1 + 80))(a1, v53);
  if (!v22)
  {
LABEL_31:
    char v41 = (re::TypeInfo *)v53;
    goto LABEL_32;
  }
  BOOL v23 = (void (*)(uint64_t, const char *, void, void, unsigned char *, unsigned char *, uint64_t))v22;
  unint64_t v55 = 0;
  uint64_t v24 = (_anonymous_namespace_ *)(a1 + 24);
  BOOL v25 = re::EncoderBinary<re::FixedArrayInputStream>::beginDictionary(a1 + 24, a2, (uint64_t)a3, (char *)&v55, 0);
  BOOL result = 0;
  if (v25)
  {
    if (v55)
    {
      for (unint64_t i = 0; i < v55; ++i)
      {
        double v28 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 1);
        v21(a1, "key", 0, 0, v54, v54, 1, v28);
        v23(a1, "value", 0, 0, v53, v53, 1);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    goto LABEL_28;
  }
  return result;
}

BOOL re::serializeUnion<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_19:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 != (unsigned __int16)v15) {
      goto LABEL_19;
    }
    BOOL v17 = WORD1(v14) == WORD1(v15);
    uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
    BOOL v17 = v17 && v16 == 0;
    if (!v17) {
      goto LABEL_19;
    }
  }
LABEL_4:
  if (a7)
  {
    if (!*(unsigned char *)(a1 + 64))
    {
      LOBYTE(v20) = 1;
      DWORD1(v20) = 16;
      *((void *)&v20 + 1) = a2;
      long long v21 = 0u;
      long long v22 = 0u;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)(a1 + 24), &v20);
      v18[0] = 0;
      re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, "tag", 0, (char *)v18, (uint64_t)"uint64", 0);
      if (v18[0] < *(unsigned int *)(*((void *)a6 + 2) + 88))
      {
        re::TypeInfo::unionMember(a6, v18[0], (uint64_t)&v20);
        if (!*(unsigned char *)(a1 + 64)) {
          (*(void (**)(uint64_t, const char *, void, void, long long *, long long *, uint64_t))(*(void *)a1 + 72))(a1, "value", 0, 0, &v20, &v20, 1);
        }
      }
LABEL_13:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(unsigned char *)(a1 + 64) == 0;
    }
  }
  else if (!*(unsigned char *)(a1 + 64))
  {
    LOBYTE(v20) = 1;
    DWORD1(v20) = 16;
    *((void *)&v20 + 1) = a2;
    long long v21 = 0u;
    long long v22 = 0u;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)(a1 + 24), &v20);
    re::TypeInfo::TypeInfo((uint64_t)&v20, (uint64_t)a5);
    unint64_t Tag = re::UnionAccessor::readTag((re::UnionAccessor *)&v20, a4);
    re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, "tag", 0, (char *)&Tag, (uint64_t)"uint64", 0);
    re::UnionAccessor::reset((re::UnionAccessor *)&v20, a4, (const re::TypeInfo *)Tag, *(re::Allocator **)(a1 + 48));
    if (Tag < *(unsigned int *)(*((void *)a5 + 2) + 88))
    {
      re::TypeInfo::unionMember(a5, Tag, (uint64_t)v18);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, char *, unint64_t *, unint64_t *, void))(*(void *)a1 + 72))(a1, "value", 0, a4, v18, v18, 0);
      }
    }
    goto LABEL_13;
  }
  return 0;
}

uint64_t re::serializeObject<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  if (a7)
  {
    if (*(unsigned char *)(*((void *)this + 2) + 49))
    {
      BOOL v17 = *(re::TypeRegistry **)(a1 + 192);
      v34[0] = 0x2686EB529B3EE220;
      v34[1] = "DynamicString";
      re::TypeRegistry::typeInfo(v17, (const re::StringID *)v34, v36);
      re::TypeInfo::TypeInfo((uint64_t)v35, (uint64_t)v36 + 8);
      re::StringID::destroyString((re::StringID *)v34);
      BOOL v18 = (re *)v35;
      int v19 = (const re::TypeInfo *)v35;
      uint64_t v20 = a1;
      long long v21 = a2;
      long long v22 = (const re::TypeInfo *)a3;
    }
    else
    {
      uint64_t v14 = re::TypeInfo::name(this);
      if ((*v14 & 0xFFFFFFFFFFFFFFFELL) != 0x2686EB529B3EE220) {
        goto LABEL_6;
      }
      uint64_t v15 = (const char *)v14[1];
      if (v15 != "DynamicString")
      {
        if (strcmp(v15, "DynamicString")) {
          goto LABEL_6;
        }
      }
      uint64_t v20 = a1;
      long long v21 = a2;
      long long v22 = (const re::TypeInfo *)a3;
      BOOL v18 = this;
      int v19 = this;
    }
    re::serializeDynamicString<re::EncoderBinary<re::FixedArrayInputStream>>(v20, v21, v22, 0, v18, v19, 1);
    return *(unsigned char *)(a1 + 64) == 0;
  }
LABEL_6:
  if ((*(unsigned char *)(*((void *)this + 2) + 48) & 4) == 0)
  {
    if (*(unsigned char *)(a1 + 64)) {
      return 0;
    }
    LOBYTE(v36[0]) = 1;
    DWORD1(v36[0]) = 0;
    *((void *)&v36[0] + 1) = a2;
    memset(&v36[1], 0, 32);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)(a1 + 24), v36);
    if (this == (re::TypeInfo *)a6) {
      goto LABEL_16;
    }
    if (*(void *)this == *(void *)a6)
    {
      uint64_t v24 = **((void **)this + 2);
      uint64_t v25 = **(void **)(a6 + 16);
      if ((unsigned __int16)v24 == (unsigned __int16)v25)
      {
        BOOL v27 = WORD1(v24) == WORD1(v25);
        uint64_t v26 = (v25 ^ v24) & 0xFFFFFF00000000;
        BOOL v27 = v27 && v26 == 0;
        if (v27) {
          goto LABEL_16;
        }
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v23))
    {
LABEL_16:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((unsigned char *)a1, a4, (uint64_t *)this, a7);
LABEL_27:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(unsigned char *)(a1 + 64) == 0;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    }
    else
    {
      uint64_t v28 = re::TypeInfo::name(this)[1];
      re::TypeInfo::name((re::TypeInfo *)a6);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v29, v30, v31, v32, v33, v28);
    }
    goto LABEL_27;
  }
  return re::internal::serializeObjectWithOneMember<re::EncoderBinary<re::FixedArrayInputStream>>((unsigned char *)a1, a2, a3, a4, (uint64_t *)this, (uint64_t *)a6, a7);
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  if (a6) {
    a4 = 0;
  }
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, a4, 2uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v11 - 16);
  }
  return 1;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  if (a6) {
    a4 = 0;
  }
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, a4, 4uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v11 - 16);
  }
  return 1;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  if (a6) {
    a4 = 0;
  }
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)a1, a4, 8uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 128) + 48 * *(void *)(a1 + 112);
    ++*(void *)(v11 - 16);
  }
  return 1;
}

uint64_t re::internal::serializeEnumAsBinary<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re::internal *a5, re::internal *a6, int a7)
{
  if (a7)
  {
    uint64_t v11 = *(re::internal **)(a1 + 192);
    re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v11, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (!*(unsigned char *)(a1 + 64)) {
      return (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, void, uint64_t *, uint64_t *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, 0, &__src, &__src, 1);
    }
    return 0;
  }
  uint64_t v15 = *(void **)a5;
  if (a5 == a6) {
    goto LABEL_8;
  }
  if (v15 == *(void **)a6)
  {
    uint64_t v16 = **((void **)a5 + 2);
    BOOL v17 = (uint64_t *)*((void *)a6 + 2);
    uint64_t v18 = *v17;
    if ((unsigned __int16)v16 == (unsigned __int16)*v17)
    {
      BOOL v20 = WORD1(v16) == WORD1(v18);
      uint64_t v19 = (v18 ^ v16) & 0xFFFFFF00000000;
      BOOL v20 = v20 && v19 == 0;
      if (v20) {
        goto LABEL_8;
      }
    }
LABEL_21:
    BOOL v23 = *(re::internal **)(a1 + 192);
    re::TypeRegistry::typeInfo(v15, v17[9], &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v23, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (*(_DWORD *)(v58[1] + 8) < 9u)
    {
      uint64_t v55 = 0;
      if (!*(unsigned char *)(a1 + 64)
        && (*(unsigned int (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, uint64_t *, uint64_t *, void))(*(void *)a1 + 72))(a1, a2, a3, &v55, &__src, &__src, 0))
      {
        unsigned int EnumConstantIndex = re::internal::getEnumConstantIndex(a6, (const re::TypeInfo *)&v55, v29);
        if ((EnumConstantIndex & 0x80000000) != 0)
        {
          char v41 = v55;
          re::TypeInfo::name(a6);
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v42, v43, v44, v45, v46, v41);
        }
        else
        {
          unsigned int v31 = EnumConstantIndex;
          uint64_t v32 = *(re::internal::TypeTranslationTable **)(*(void *)a6 + 856);
          if (v32)
          {
            uint64_t v33 = (const void *)re::internal::TypeTranslationTable::translateSerializedEnum(v32, a6, v31, a5);
            if (v33)
            {
              memcpy(a4, v33, *(unsigned int *)(*((void *)a5 + 2) + 8));
              int v34 = 0;
              return v34 == 0;
            }
          }
          v56[0] = re::TypeInfo::enumConstants(a6);
          v56[1] = v47;
          uint64_t v48 = *(void *)(re::Slice<re::EnumConstant>::operator[](v56, v31) + 16);
          re::TypeInfo::name(a5);
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Serialized enum constant \"%s\" does not exist in runtime type \"%s\".", v49, v50, v51, v52, v53, v48);
        }
      }
    }
    else
    {
      uint64_t v54 = re::TypeInfo::name((re::TypeInfo *)&__src)[1];
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Enum type \"%s\" has invalid size: %zu bytes.", v24, v25, v26, v27, v28, v54);
    }
    int v34 = 1;
    return v34 == 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
  {
    uint64_t v15 = *(void **)a6;
    BOOL v17 = (uint64_t *)*((void *)a6 + 2);
    goto LABEL_21;
  }
  uint64_t v15 = *(void **)a5;
LABEL_8:
  re::TypeRegistry::typeInfo(v15, *(void *)(*((void *)a5 + 2) + 72), &__src);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
  uint64_t __src = 0;
  if (*(unsigned char *)(a1 + 64)) {
    return 0;
  }
  int v22 = (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, void *, void *, void))(*(void *)a1 + 72))(a1, a2, a3, &__src, v56, v56, 0);
  uint64_t result = 0;
  if (v22)
  {
    if ((re::internal::getEnumConstantIndex(a5, (const re::TypeInfo *)&__src, v21) & 0x80000000) != 0)
    {
      char v35 = __src;
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v36, v37, v38, v39, v40, v35);
      return 0;
    }
    memcpy(a4, &__src, *(unsigned int *)(*((void *)a5 + 2) + 8));
    return 1;
  }
  return result;
}

double re::EncoderBinary<re::FixedArrayInputStream>::beginOptional(uint64_t a1, const char *a2, uint64_t a3, char *a4, int a5)
{
  if (!*(unsigned char *)(a1 + 40))
  {
    re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1, a2, 0, a4, (uint64_t)"BOOL", 2);
    uint64_t v9 = *a4;
    LOBYTE(v11) = 3;
    DWORD1(v11) = a5;
    *((void *)&v11 + 1) = a2;
    uint64_t v12 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = v9;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
  }
  return result;
}

BOOL re::EncoderBinary<re::FixedArrayInputStream>::beginArray(uint64_t a1, const char *a2, uint64_t a3, char *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  if ((a5 & 4) == 0) {
    re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1, a2, 0, a4, (uint64_t)"uint32", 2);
  }
  if ((a5 & 8) != 0)
  {
    if (*(void *)a4) {
      char v10 = 73;
    }
    else {
      char v10 = 78;
    }
    char v17 = v10;
    re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1, a2, 0, &v17, (uint64_t)"uint8", 2);
  }
  uint64_t v11 = *(void *)a4;
  LOBYTE(v12) = 5;
  DWORD1(v12) = a5;
  *((void *)&v12 + 1) = a2;
  uint64_t v13 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v14 = v11;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v12);
  return *(unsigned char *)(a1 + 40) == 0;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeArray(uint64_t result, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  if (!*(unsigned char *)(result + 40))
  {
    long long v7 = (_anonymous_namespace_ *)result;
    size_t v8 = a4 * a3;
    if (a5) {
      a2 = 0;
    }
    double result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, a2, v8);
    if (result)
    {
      if ((a5 & 2) == 0)
      {
        uint64_t v9 = *((void *)v7 + 16) + 48 * *((void *)v7 + 14);
        *(void *)(v9 - 16) += a4;
      }
    }
    else
    {
      return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v7, 0, (uint64_t)"Array");
    }
  }
  return result;
}

BOOL re::EncoderBinary<re::FixedArrayInputStream>::beginDictionary(uint64_t a1, const char *a2, uint64_t a3, char *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1, a2, 0, a4, (uint64_t)"uint32", 2);
  uint64_t v10 = *(void *)a4;
  LOBYTE(v11) = 6;
  DWORD1(v11) = a5;
  *((void *)&v11 + 1) = a2;
  uint64_t v12 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = v10;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
  return *(unsigned char *)(a1 + 40) == 0;
}

BOOL re::serializeDynamicString<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (uint64_t v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v35 = 0;
    BOOL v20 = re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v35, 0);
    BOOL result = 0;
    if (!v20) {
      return result;
    }
    if (v35) {
      re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    }
    int v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  unint64_t v23 = a4[1];
  if (v23) {
    unint64_t v24 = v23 >> 1;
  }
  else {
    unint64_t v24 = v23 >> 1;
  }
  unint64_t v35 = v24;
  BOOL v25 = re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v35, 0);
  BOOL result = 0;
  if (v25)
  {
    unint64_t v26 = v35;
    if (v26 <= (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))())
    {
      if (!*a4)
      {
        size_t v33 = v35 + 1;
        *a4 = *(void *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v33);
      }
      re::DynamicString::resize(a4, v35, 0);
      if (v35)
      {
        if (a4[1]) {
          int v34 = (char *)a4[2];
        }
        else {
          int v34 = (char *)a4 + 9;
        }
        re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, v34, 0);
      }
      int v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString(v22);
      return *(unsigned char *)(a1 + 64) == 0;
    }
    char v27 = v35;
    (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v28, v29, v30, v31, v32, v27);
    return 0;
  }
  return result;
}

uint64_t re::internal::serializeObjectWithOneMember<re::EncoderBinary<re::FixedArrayInputStream>>(unsigned char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v14 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)v29, *a5, a5[2]);
  re::TypeMemberCollection::operator[](v14, 0, (uint64_t)&v27);
  uint64_t v15 = a4 + *(unsigned int *)(v28 + 24);
  re::TypeRegistry::typeInfo(v27, *(void *)v28, v29);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v30);
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*a5 == *a6)
  {
    uint64_t v18 = *(void *)a5[2];
    uint64_t v19 = a6[2];
    uint64_t v20 = *(void *)v19;
    if ((unsigned __int16)v18 != (unsigned __int16)*(void *)v19) {
      goto LABEL_14;
    }
    BOOL v22 = WORD1(v18) == WORD1(v20);
    uint64_t v21 = (v20 ^ v18) & 0xFFFFFF00000000;
    BOOL v22 = v22 && v21 == 0;
    if (!v22) {
      goto LABEL_14;
    }
LABEL_4:
    if (!a1[64]) {
      return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v26, a7);
    }
    return 0;
  }
  if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, v16)) {
    goto LABEL_4;
  }
  uint64_t v19 = a6[2];
LABEL_14:
  if (*(_DWORD *)(v19 + 88) != 1)
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
    return 0;
  }
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v23, *a6, v19);
  re::TypeMemberCollection::operator[](v23, 0, (uint64_t)v24);
  re::TypeRegistry::typeInfo(v24[0], *v24[2], v29);
  re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v30);
  if (a1[64]) {
    return 0;
  }
  return (*(uint64_t (**)(unsigned char *, const char *, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, a3, v15, v26, v25, a7);
}

BOOL re::EncoderBinary<re::FixedArrayInputStream>::beginString(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 0;
  }
  re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1, "length", 0, a4, (uint64_t)"uint32", 2);
  uint64_t v10 = *(void *)a4;
  LOBYTE(v11) = 8;
  DWORD1(v11) = a5;
  *((void *)&v11 + 1) = a2;
  uint64_t v12 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = v10;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)a1, &v11);
  return *(unsigned char *)(a1 + 40) == 0;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeString(uint64_t result, char *a2, char a3)
{
  if (!*(unsigned char *)(result + 40))
  {
    uint64_t v4 = (_anonymous_namespace_ *)result;
    uint64_t v5 = *(void *)(result + 128) + 48 * *(void *)(result + 112);
    uint64_t v6 = *(void *)(v5 - 24);
    if (a3) {
      a2 = 0;
    }
    BOOL result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((void *)result, a2, *(void *)(v5 - 24));
    if (result)
    {
      if ((a3 & 2) == 0)
      {
        uint64_t v7 = *((void *)v4 + 16) + 48 * *((void *)v4 + 14);
        *(void *)(v7 - 16) += v6;
      }
    }
    else
    {
      return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v4, 0, (uint64_t)"string");
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>(unsigned char *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v21);
  if (v21[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)&v22);
    if (*(_DWORD *)(v19 + 88) || (re::TypeRegistry::typeInfo(v18[0], *(void *)(v19 + 72), v23), v23[0])) {
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, v18, a4);
    }
  }
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v18, *a3, a3[2]);
  if (v20)
  {
    for (unint64_t i = 0; i < v20; ++i)
    {
      if (a1[64]) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v18, i, (uint64_t)&v16);
      if (*(unsigned char *)(v17 + 28))
      {
        uint64_t v10 = *(void *)(v17 + 16);
        if (strlen((const char *)v10) >= 3 && *(unsigned char *)v10 == 109) {
          v10 += 2 * (*(unsigned char *)(v10 + 1) == 95);
        }
        uint64_t v11 = *(unsigned int *)(v17 + 32);
        uint64_t v12 = a2 + *(unsigned int *)(v17 + 24);
        re::TypeRegistry::typeInfo(v16, *(void *)v17, v23);
        re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v24);
        if (a1[64]
          || (uint64_t result = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v10, v11, v12, v15, v15, a4), (result & 1) == 0))
        {
          uint64_t result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a3);
          if (v13)
          {
            uint64_t v14 = (_DWORD *)(result + 16);
            while (i != *v14)
            {
              v14 += 6;
              if (!--v13) {
                goto LABEL_21;
              }
            }
            if (!a1[64]) {
              uint64_t result = (*(uint64_t (**)(unsigned char *, void, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, *((void *)v14 - 1), v11, v12, v15, v15, a4);
            }
          }
        }
      }
LABEL_21:
      ;
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  re::TypeRegistry::typeInfo((void *)*a3, *(void *)(a3[2] + 72), v53);
  re::TypeRegistry::typeInfo((void *)*a4, *(void *)(a4[2] + 72), v49);
  if (v49[0])
  {
    if (!v53[0])
    {
      uint64_t v11 = re::TypeInfo::name((re::TypeInfo *)&v50)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (v54 == v50)
    {
      uint64_t v18 = *v56;
      uint64_t v19 = *v52;
      if ((unsigned __int16)*v56 == (unsigned __int16)*v52)
      {
        BOOL v21 = WORD1(v18) == WORD1(v19);
        uint64_t v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        BOOL v21 = v21 && v20 == 0;
        if (v21) {
          goto LABEL_5;
        }
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v54, (const re::TypeInfo *)&v50, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((unsigned char *)a1, a2, &v54, a5);
      goto LABEL_15;
    }
    if (v55 == v51)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, &v54, &v50, a5);
    }
    else
    {
      uint64_t v22 = re::TypeInfo::name((re::TypeInfo *)&v54)[1];
      re::TypeInfo::name((re::TypeInfo *)&v50);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v48, *a3, a3[2]);
  uint64_t result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v46, *a4, a4[2]);
  if (v47)
  {
    for (unint64_t i = 0; i < v47; ++i)
    {
      if (*(unsigned char *)(a1 + 64)) {
        break;
      }
      uint64_t result = (uint64_t)re::TypeMemberCollection::operator[](v46, i, (uint64_t)v44);
      if (*(unsigned char *)(v45 + 28))
      {
        uint64_t v29 = *(void *)(v45 + 16);
        if (strlen((const char *)v29) >= 3 && *(unsigned char *)v29 == 109) {
          v29 += 2 * (*(unsigned char *)(v29 + 1) == 95);
        }
        uint64_t v30 = *(unsigned int *)(v45 + 32);
        uint64_t v31 = *(re **)(*a4 + 856);
        if (!v31
          || (uint64_t v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v44),
              v31 == -1))
        {
          unint64_t v35 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            uint64_t v36 = v35;
            uint64_t v37 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            uint64_t v58 = v37;
            __int16 v59 = 2080;
            uint64_t v60 = v29;
            _os_log_impl(&dword_233120000, v36, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          uint64_t v38 = *(re::internal **)(a1 + 192);
          re::TypeRegistry::typeInfo(v44[0], *(void *)v45, buf);
          re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v58 + 4);
          uint64_t result = re::internal::translateType(v38, (const re::TypeRegistry *)v42, (uint64_t)buf);
          if (!*(unsigned char *)(a1 + 64)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint8_t *, uint8_t *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
          }
        }
        else
        {
          re::TypeMemberCollection::operator[](v48, (int)v31, (uint64_t)v42);
          uint64_t v32 = a2 + *(unsigned int *)(v43 + 24);
          re::TypeRegistry::typeInfo(v42[0], *(void *)v43, buf);
          re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v58 + 4);
          re::TypeRegistry::typeInfo(v44[0], *(void *)v45, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v58 + 4);
          if (*(unsigned char *)(a1 + 64)
            || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v29, v30, v32, v41, v40, a5), (result & 1) == 0))
          {
            uint64_t result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a4);
            if (v33)
            {
              int v34 = (_DWORD *)(result + 16);
              while (i != *v34)
              {
                v34 += 6;
                if (!--v33) {
                  goto LABEL_35;
                }
              }
              uint64_t v39 = *((void *)v34 - 1);
              re::TypeRegistry::typeInfo(v42[0], *(void *)v43, buf);
              re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v58 + 4);
              re::TypeRegistry::typeInfo(v44[0], *(void *)v45, buf);
              uint64_t result = re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v58 + 4);
              if (!*(unsigned char *)(a1 + 64)) {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, v39, v30, v32, v41, v40, a5);
              }
            }
          }
        }
      }
LABEL_35:
      ;
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 192);
  uint64_t result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5) {
    BOOL v7 = result == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = *result;
    uint64_t v10 = a3;
    unint64_t v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 208, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"BOOL", a7);
}

uint64_t re::serializeChar<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"char", a7);
}

uint64_t re::serializeI8<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int8", a7);
}

uint64_t re::serializeI16<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int16", a7);
}

uint64_t re::serializeI32<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int32", a7);
}

uint64_t re::serializeI64<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int64", a7);
}

uint64_t re::serializeU8<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint8", a7);
}

uint64_t re::serializeU16<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint16", a7);
}

uint64_t re::serializeU32<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint32", a7);
}

uint64_t re::serializeU64<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint64", a7);
}

uint64_t re::serializeFloat<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"float", a7);
}

uint64_t re::serializeDouble<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 == *(void *)a6)
    {
      uint64_t v15 = **((void **)a5 + 2);
      uint64_t v16 = **((void **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        BOOL v18 = WORD1(v15) == WORD1(v16);
        uint64_t v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        BOOL v18 = v18 && v17 == 0;
        if (v18) {
          goto LABEL_4;
        }
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"double", a7);
}

BOOL re::serializeCString<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_22:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v23 = **((void **)a5 + 2);
    uint64_t v24 = **((void **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24) {
      goto LABEL_22;
    }
    BOOL v26 = WORD1(v23) == WORD1(v24);
    uint64_t v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    BOOL v26 = v26 && v25 == 0;
    if (!v26) {
      goto LABEL_22;
    }
  }
LABEL_4:
  if (a7)
  {
    int v48 = 0;
    BOOL v19 = re::EncoderBinary<re::FixedArrayInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
    BOOL result = 0;
    if (!v19) {
      return result;
    }
    if (!v48) {
      goto LABEL_12;
    }
    if (v48 != 1)
    {
      size_t v47 = 0;
      if (re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v47, 0))
      {
        if (v47) {
          re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
        }
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
LABEL_12:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      goto LABEL_47;
    }
    goto LABEL_16;
  }
  int v48 = 2 * (*a4 != 0);
  BOOL v21 = re::EncoderBinary<re::FixedArrayInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
  BOOL result = 0;
  if (!v21) {
    return result;
  }
  int v22 = v48;
  if (v48)
  {
    if (v48 == 1)
    {
LABEL_16:
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, v46);
      return 0;
    }
  }
  else
  {
    if (!*a4) {
      goto LABEL_44;
    }
    (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
    *a4 = 0;
    int v22 = v48;
  }
  if (v22 == 2)
  {
    size_t v27 = *a4 ? strlen(*a4) : 0;
    size_t v47 = v27;
    if (re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v47, 0))
    {
      uint64_t v28 = (char *)*a4;
      unint64_t v29 = v47;
      if (!*a4 || v47 != v27)
      {
        if (v28)
        {
          (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
          *a4 = 0;
          unint64_t v29 = v47;
        }
        unint64_t v30 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
        char v36 = v47;
        if (v29 > v30)
        {
          (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v37, v38, v39, v40, v41, v36);
          return 0;
        }
        uint64_t v42 = v47 == -1;
        uint64_t v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, v47);
          return 0;
        }
        uint64_t v28 = (char *)(*(uint64_t (**)(void, size_t, void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v47 + 1, 0);
        *a4 = v28;
        size_t v27 = v47;
      }
      if (v27)
      {
        re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, v28, 0);
        uint64_t v28 = (char *)*a4;
        size_t v44 = v47;
      }
      else
      {
        size_t v44 = 0;
      }
      v28[v44] = 0;
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    }
  }
LABEL_44:
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  int v45 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(unsigned char *)(a1 + 64)) {
    return v45 == 0;
  }
  (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  int v45 = *(unsigned __int8 *)(a1 + 64);
  return v45 == 0;
}

BOOL re::serializeStringID<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  if (a5 == a6) {
    goto LABEL_14;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      BOOL v17 = WORD1(v14) == WORD1(v15);
      uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      BOOL v17 = v17 && v16 == 0;
      if (v17) {
        goto LABEL_14;
      }
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  uint64_t v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (BOOL v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    unint64_t v47 = 0;
    BOOL v20 = re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v47, 0);
    BOOL result = 0;
    if (!v20) {
      return result;
    }
    if (v47) {
      re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    }
    goto LABEL_26;
  }
  unint64_t v46 = 0;
  if (re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v46, 0))
  {
    unint64_t v22 = v46;
    if (v46)
    {
      unint64_t v23 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
      char v29 = v46;
      if (v22 > v23)
      {
        (*(void (**)(void))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24));
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v30, v31, v32, v33, v34, v29);
        return 0;
      }
      uint64_t v36 = v46 == -1;
      uint64_t v37 = v36 << 63 >> 63;
      if (v37 != v36 || v37 < 0)
      {
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v24, v25, v26, v27, v28, v46);
        return 0;
      }
      uint64_t v38 = (char *)(*(uint64_t (**)(void, unint64_t, void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56), v46 + 1, 0);
      uint64_t v39 = (_anonymous_namespace_ *)re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, v38, 0);
      v38[v46] = 0;
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v40 = v44;
      uint64_t v41 = v45;
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v42 = *a4;
      uint64_t v43 = a4[1];
      *a4 = v40;
      a4[1] = (uint64_t)v41;
      unint64_t v47 = v40 & 0xFFFFFFFFFFFFFFFELL | v42 & 1;
      uint64_t v48 = v43;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
      (*(void (**)(void, char *))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v38);
    }
    else
    {
      uint64_t v44 = 0;
      int v45 = "";
      uint64_t v35 = a4[1];
      unint64_t v47 = *a4 & 1;
      uint64_t v48 = v35;
      *a4 = 0;
      a4[1] = (uint64_t)"";
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
    }
LABEL_26:
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(unsigned char *)(a1 + 64) == 0;
  }
  return 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  if (a5 == a6) {
    goto LABEL_4;
  }
  if (*(void *)a5 == *(void *)a6)
  {
    uint64_t v28 = **((void **)a5 + 2);
    uint64_t v29 = **((void **)a6 + 2);
    if ((unsigned __int16)v28 == (unsigned __int16)v29)
    {
      BOOL v31 = WORD1(v28) == WORD1(v29);
      uint64_t v30 = (v29 ^ v28) & 0xFFFFFF00000000;
      BOOL v31 = v31 && v30 == 0;
      if (v31) {
        goto LABEL_4;
      }
    }
LABEL_32:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3)) {
    goto LABEL_32;
  }
LABEL_4:
  if (a7)
  {
    uint64_t v32 = 0;
    BOOL v14 = re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v32, 0);
    BOOL result = 0;
    if (!v14) {
      return result;
    }
    if (v32) {
      re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    }
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
  }
  else
  {
    uint64_t v16 = **((void **)a5 + 2);
    uint64_t v32 = *(void *)a5;
    uint64_t v33 = v16;
    LODWORD(v34) = -1;
    *(void *)buf = 0x258C98EAAF29A10ALL;
    *(void *)&buf[8] = "CallbackSerializerAttribute";
    BOOL v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v32, buf);
    re::StringID::destroyString((re::StringID *)buf);
    uint64_t v18 = *v17;
    uint64_t v19 = *(void *)(a1 + 184);
    unint64_t v36 = 0;
    BOOL result = re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v36, 0);
    if (!result) {
      return result;
    }
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v32 = v20;
    uint64_t v33 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    if (v36)
    {
      re::DynamicString::resize(&v32, v36, 0);
      if (v33) {
        BOOL v21 = v34;
      }
      else {
        BOOL v21 = (char *)&v33 + 1;
      }
      re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, v21, 0);
    }
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    unint64_t v22 = (char *)&v33 + 1;
    if (v33) {
      unint64_t v23 = v34;
    }
    else {
      unint64_t v23 = (char *)&v33 + 1;
    }
    uint64_t v24 = (re *)(*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, char *))(v18 + 80))(*(void *)(a1 + 48), v19, v18, a4, v23);
    if ((v24 & 1) == 0)
    {
      uint64_t v25 = *re::foundationSerializationLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        if (v33) {
          unint64_t v22 = v34;
        }
        uint64_t v26 = v25;
        uint64_t v27 = re::TypeInfo::name(a5)[1];
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v22;
        __int16 v38 = 2080;
        uint64_t v39 = v27;
        _os_log_impl(&dword_233120000, v26, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);
      }
    }
    if (v32 && (v33 & 1) != 0) {
      (*(void (**)(void))(*(void *)v32 + 40))();
    }
  }
  return *(unsigned char *)(a1 + 64) == 0;
}

BOOL re::EncoderBinary<re::FixedArrayInputStream>::beginPointer(_anonymous_namespace_ *a1, const char *a2, uint64_t a3, int *a4, int a5)
{
  if (*((unsigned char *)a1 + 40)) {
    return 0;
  }
  char v22 = 78;
  re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>((uint64_t)a1, a2, 0, &v22, (uint64_t)"uint8", 2);
  switch(v22)
  {
    case 'I':
      int v10 = 2;
      break;
    case 'N':
      int v10 = 0;
      uint64_t v11 = 0;
      goto LABEL_10;
    case 'R':
      int v10 = 1;
      break;
    default:
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, 0, (re::DynamicString *)&v18);
      if (v19) {
        uint64_t v12 = *(unsigned char **)&v20[7];
      }
      else {
        uint64_t v12 = v20;
      }
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". Invalid tag.", (re::DynamicString *)v21, v12);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v21);
      if (*(void *)&v21[0])
      {
        if (BYTE8(v21[0])) {
          (*(void (**)(void))(**(void **)&v21[0] + 40))();
        }
        memset(v21, 0, sizeof(v21));
      }
      if (v18)
      {
        if (v19) {
          (*(void (**)(void))(*(void *)v18 + 40))();
        }
      }
      return 0;
  }
  uint64_t v11 = 1;
LABEL_10:
  *a4 = v10;
  LOBYTE(v13) = 9;
  DWORD1(v13) = a5;
  *((void *)&v13 + 1) = a2;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = v11;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v13);
  return *((unsigned char *)a1 + 40) == 0;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  if (!*(void *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  unint64_t v7 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v7);
  if (v8 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  while (*(void *)(v9 + 24 * v8 + 4) != v6)
  {
    uint64_t v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v10 = 3 * v8;
  *(void *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  uint64_t v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v13) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(void *)(*(void *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10 + 4), *(void *)&v13[16] + v10 + 4, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

BOOL re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::serializeCString(uint64_t a1, const char *a2, const re::TypeInfo *a3, char **a4, re *a5, const re::TypeInfo *a6, char a7)
{
  if (a5 != a6)
  {
    if (*(void *)a5 != *(void *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3)) {
        goto LABEL_4;
      }
LABEL_15:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    uint64_t v14 = **((void **)a5 + 2);
    uint64_t v15 = **((void **)a6 + 2);
    if ((unsigned __int16)v14 != (unsigned __int16)v15) {
      goto LABEL_15;
    }
    BOOL v17 = WORD1(v14) == WORD1(v15);
    uint64_t v16 = (v15 ^ v14) & 0xFFFFFF00000000;
    BOOL v17 = v17 && v16 == 0;
    if (!v17) {
      goto LABEL_15;
    }
  }
LABEL_4:
  int v50 = 0;
  if (re::EncoderBinary<re::FixedArrayInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v50, 0))
  {
    if (v50 == 1)
    {
      unsigned int v49 = 0;
      if (!*(unsigned char *)(a1 + 64))
      {
        re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, "ID", 0, (char *)&v49, (uint64_t)"Reference ID", 0);
        if (!*(unsigned char *)(a1 + 64))
        {
          if (*(void *)(a1 + 328) <= (unint64_t)v49)
          {
            re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Invalid reference ID for shared object: %u", v19, v20, v21, v22, v23, v49);
          }
          else
          {
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v49, (uint64_t)&v45);
            if (v45 == *(void **)a5)
            {
              uint64_t v24 = **((void **)a5 + 2);
              if (v46 == (unsigned __int16)v24 && v47 == WORD1(v24) && ((v48 ^ HIDWORD(v24)) & 0xFFFFFF) == 0)
              {
                if ((a7 & 1) == 0)
                {
                  if (*a4)
                  {
                    uint64_t v42 = *a4;
                    if (v42 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v49))
                    {
                      (*(void (**)(void, char *))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), *a4);
                      *a4 = 0;
                    }
                  }
                  *a4 = (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v49);
                  re::internal::SharedObjectGraph::addReference((void *)(a1 + 256), v49);
                }
                goto LABEL_37;
              }
            }
            uint64_t v25 = *(_anonymous_namespace_ **)(a1 + 192);
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v49, (uint64_t)&v45);
            uint64_t v43 = *((void *)re::TypeRegistry::typeName(v25, &v45) + 1);
            re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Invalid reference ID for shared object. Expected type \"char *\". Actual type \"%s\".", v26, v27, v28, v29, v30, v43);
          }
        }
      }
    }
    else
    {
      if (!v50)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
            *a4 = 0;
          }
        }
LABEL_37:
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        return *(unsigned char *)(a1 + 64) == 0;
      }
      if ((a7 & 1) == 0 && *a4)
      {
        (*(void (**)(void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48));
        *a4 = 0;
      }
      int v45 = 0;
      if (re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v45, 0))
      {
        uint64_t v36 = v45 == (void *)-1;
        uint64_t v37 = v36 << 63 >> 63;
        if (v37 == v36 && (v37 & 0x8000000000000000) == 0)
        {
          __int16 v38 = (char *)(*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), (uint64_t)v45 + 1, 0);
          uint64_t v39 = (uint64_t)v38;
          if ((a7 & 1) == 0) {
            *a4 = v38;
          }
          uint64_t v40 = v45;
          if (v45)
          {
            re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, v38, 0);
            uint64_t v40 = v45;
          }
          *((unsigned char *)v40 + v39) = 0;
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
          uint64_t v41 = **((void **)a5 + 2);
          *(void *)&long long v44 = *(void *)a5;
          *((void *)&v44 + 1) = v41;
          re::internal::SharedObjectGraph::addObject(a1 + 256, v39, &v44);
          goto LABEL_37;
        }
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, (char)v45);
      }
    }
  }
  return 0;
}

BOOL re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  isPointerToPolymorphicuint64_t Type = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6) {
    goto LABEL_4;
  }
  if (*(void *)this == *(void *)a6)
  {
    uint64_t v26 = **((void **)this + 2);
    uint64_t v27 = **((void **)a6 + 2);
    if ((unsigned __int16)v26 == (unsigned __int16)v27)
    {
      BOOL v29 = WORD1(v26) == WORD1(v27);
      uint64_t v28 = (v27 ^ v26) & 0xFFFFFF00000000;
      BOOL v29 = v29 && v28 == 0;
      if (v29) {
        goto LABEL_4;
      }
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    int v16 = 0;
    goto LABEL_5;
  }
  if (*((unsigned char *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (uint64_t v30 = re::TypeInfo::name(this), v31 = re::TypeInfo::name(a6), !re::StringID::operator==(v30, v31))))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, this, a6);
    return 0;
  }
  int v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(void **)this, *(void *)(*((void *)this + 2) + 72), &v58);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v59);
  re::TypeRegistry::typeInfo(*(void **)a6, *(void *)(*((void *)a6 + 2) + 72), &v58);
  re::TypeInfo::TypeInfo((uint64_t)v55, (uint64_t)v59);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    BOOL v17 = *v57;
    v54[0] = (re *)v56[0];
    v54[1] = v17;
    if (v56[0]) {
      goto LABEL_8;
    }
LABEL_15:
    uint64_t v45 = re::TypeInfo::name(this)[1];
    uint64_t v23 = "Failed to get actual type of polymorphic object. Type \"%s\".";
    uint64_t v24 = a1;
    uint64_t v25 = a2;
LABEL_16:
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v24, v25, v23, v18, v19, v20, v21, v22, v45);
    return 0;
  }
  re::internal::actualType(a4, (void **)this, v54);
  if (!v54[0]) {
    goto LABEL_15;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v54, &v58);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v59);
  int v51 = 0;
  if (re::EncoderBinary<re::FixedArrayInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, a3, &v51, 0))
  {
    if (v51 != 1)
    {
      if (!v51)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v52, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
            *a4 = 0;
          }
        }
        goto LABEL_57;
      }
      if (isPointerToPolymorphicType)
      {
        re::internal::deserializePolymorphicObject<re::EncoderBinary<re::FixedArrayInputStream>,true>(a1, (uint64_t)a2, a3, (void **)a4, (re **)this, (re::TypeInfo *)v52, (re::TypeInfo *)v55, v16, a7);
        goto LABEL_57;
      }
      if (!a7)
      {
        Instance = *a4;
        if (!*a4) {
          Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v56, *(re::Allocator **)(a1 + 48), 0);
        }
        uint64_t v40 = 0;
        *a4 = Instance;
        goto LABEL_53;
      }
      uint64_t v37 = *(re::TypeRegistry **)(a1 + 192);
      if ((re::TypeRegistry *)v56[0] != v37)
      {
        __int16 v38 = re::TypeInfo::name((re::TypeInfo *)v56);
        re::TypeRegistry::typeInfo(v37, (const re::StringID *)v38, &v58);
        if (!(_BYTE)v58)
        {
          Instance = 0;
          uint64_t v40 = 1;
          goto LABEL_53;
        }
        re::TypeInfo::operator=((uint64_t)v56, (uint64_t)v59);
      }
      Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v56, *(re::Allocator **)(a1 + 48), 0);
      uint64_t v40 = 0;
LABEL_53:
      uint64_t v41 = *v57;
      *(void *)&long long v46 = v56[0];
      *((void *)&v46 + 1) = v41;
      re::internal::SharedObjectGraph::beginObject((void *)(a1 + 256), (uint64_t)Instance, &v46);
      if (!*(unsigned char *)(a1 + 64)) {
        (*(void (**)(uint64_t, const char *, void, char *, void *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, a2, 0, Instance, v56, v55, v40);
      }
      if (*(unsigned char *)(a1 + 256))
      {
        --*(void *)(a1 + 408);
        ++*(_DWORD *)(a1 + 416);
      }
      goto LABEL_57;
    }
    unsigned int v50 = 0;
    if (!*(unsigned char *)(a1 + 64))
    {
      re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, "ID", 0, (char *)&v50, (uint64_t)"Reference ID", 0);
      if (!*(unsigned char *)(a1 + 64))
      {
        if (*(void *)(a1 + 328) > (unint64_t)v50)
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v50, (uint64_t)v49);
          if (!re::internal::areCompatible((re **)this, (uint64_t)v49))
          {
            uint64_t v42 = re::TypeInfo::name((re::TypeInfo *)v56)[1];
            uint64_t v43 = *(_anonymous_namespace_ **)(a1 + 192);
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v50, (uint64_t)&v58);
            LOBYTE(v45) = v42;
            re::TypeRegistry::typeName(v43, &v58);
            uint64_t v23 = "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".";
            goto LABEL_61;
          }
          if (a7)
          {
LABEL_57:
            re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
            return *(unsigned char *)(a1 + 64) == 0;
          }
          if (*a4)
          {
            uint64_t v33 = *a4;
            if (v33 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v50))
            {
              re::TypeInfo::releaseInstance((re::TypeInfo *)v52, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
              *a4 = 0;
            }
          }
          uint64_t v34 = re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v50);
          uint64_t v35 = (char **)v34;
          *a4 = (char *)v34;
          if ((*(unsigned char *)(v53 + 49) & 2) != 0)
          {
            long long v44 = *(void (**)(uint64_t))(v53 + 32);
            if (v44) {
              v44(v34);
            }
            re::internal::SharedObjectGraph::addReference((void *)(a1 + 256), v50);
          }
          else
          {
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v50, (uint64_t)v48);
            if (!v48[0])
            {
              LOBYTE(v45) = v50;
              uint64_t v23 = "TypeID for shared object at index %d is invalid.";
              goto LABEL_61;
            }
            re::TypeRegistry::typeInfo(v48[0], v48, &v58);
            if (!(_BYTE)v58)
            {
              LOBYTE(v45) = v50;
              uint64_t v23 = "No TypeInfo found for shared object at index %d.";
              goto LABEL_61;
            }
            uint64_t v36 = re::TypeInfo::createInstance((re::TypeInfo *)v59, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
            *a4 = (char *)v36;
            if ((re::TypeInfo::copy((re::TypeInfo *)v59, v36, v35, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184)) & 1) == 0)
            {
              uint64_t v45 = re::TypeInfo::name((re::TypeInfo *)v59)[1];
              uint64_t v23 = "Failed to copy non-shareable object of type '%s'.";
LABEL_61:
              uint64_t v24 = a1;
              uint64_t v25 = 0;
              goto LABEL_16;
            }
          }
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v50, (uint64_t)v47);
          re::TypeInfo::setActualTypeForPointer((void **)this, (uint64_t)a4, v47);
          goto LABEL_57;
        }
        LOBYTE(v45) = v50;
        uint64_t v23 = "Invalid reference ID for shared object: %u";
        goto LABEL_61;
      }
    }
  }
  return 0;
}

BOOL re::internal::deserializePolymorphicObject<re::EncoderBinary<re::FixedArrayInputStream>,true>(uint64_t a1, uint64_t a2, uint64_t a3, void **a4, re **a5, re::TypeInfo *a6, re::TypeInfo *a7, int a8, char a9)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 64))
  {
    uint64_t v15 = (_anonymous_namespace_ *)(a1 + 24);
    LOBYTE(buf) = 1;
    DWORD1(buf) = 0;
    *((void *)&buf + 1) = a2;
    long long v40 = 0u;
    long long v41 = 0u;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((void *)(a1 + 24), &buf);
    unint64_t v38 = 0;
    if (re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>((uint64_t)v15, "customClassID", 1, (char *)&v38, (uint64_t)"uint64", 0))
    {
      re::TypeInfo::typeIDForCustomClassID(a7, v38, v37);
      if (v37[0])
      {
        if ((a9 & 1) == 0 && *a4)
        {
          re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
          *a4 = 0;
        }
        re::TypeRegistry::typeInfo(*(re **)a7, v37, &buf);
        re::TypeInfo::TypeInfo((uint64_t)v36, (uint64_t)&buf + 8);
        if (a8)
        {
          int v16 = *(re::TypeRegistry **)(a1 + 192);
        }
        else
        {
          int v16 = *(re::TypeRegistry **)(a1 + 192);
          if (*a5 == v16)
          {
            re::TypeInfo::operator=((uint64_t)a6, (uint64_t)v36);
            uint64_t v26 = v37[0];
            uint64_t v27 = v37[1];
            goto LABEL_21;
          }
        }
        uint64_t v24 = re::TypeInfo::name((re::TypeInfo *)v36);
        uint64_t v25 = re::TypeRegistry::typeInfo(v16, (const re::StringID *)v24, &buf);
        if (!(_BYTE)buf || !*(unsigned char *)(*((void *)&v40 + 1) + 120))
        {
          uint64_t v28 = *re::foundationSerializationLogObjects((re *)v25);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            BOOL v29 = v28;
            uint64_t v30 = re::TypeInfo::name((re::TypeInfo *)v36)[1];
            LODWORD(buf) = 136315138;
            *(void *)((char *)&buf + 4) = v30;
            _os_log_impl(&dword_233120000, v29, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", (uint8_t *)&buf, 0xCu);
          }
          v35[0] = 0;
          v35[1] = 0xFFFFFFFFLL;
          (*(void (**)(uint64_t, void, void *))(*(void *)a1 + 16))(a1, 0, v35);
          if (!*(unsigned char *)(a1 + 64)) {
            (*(void (**)(uint64_t, const char *, uint64_t, void, unsigned char *, unsigned char *, uint64_t))(*(void *)a1 + 72))(a1, "object", 10, 0, v36, v36, 1);
          }
          goto LABEL_25;
        }
        re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&buf + 8);
        uint64_t v26 = *(re **)a6;
        uint64_t v27 = (re *)**((void **)a6 + 2);
LABEL_21:
        Instance = re::TypeInfo::createInstance(a6, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
        uint64_t v32 = Instance;
        if ((a9 & 1) == 0)
        {
          *a4 = Instance;
          v34[0] = v26;
          v34[1] = v27;
          re::internal::setActualType(a4, a5, v34);
        }
        v33[0] = v26;
        v33[1] = v27;
        (*(void (**)(uint64_t, void **, void *))(*(void *)a1 + 16))(a1, v32, v33);
        if (!*(unsigned char *)(a1 + 64)) {
          (*(void (**)(uint64_t, const char *, uint64_t, void **, re::TypeInfo *, unsigned char *, BOOL))(*(void *)a1 + 72))(a1, "object", 10, v32, a6, v36, v32 == 0);
        }
LABEL_25:
        (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject(v15);
        return *(unsigned char *)(a1 + 64) == 0;
      }
      BOOL v17 = re::TypeInfo::name(a7);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Unknown polymorphic \"%s\" type. Custom class ID = %llu", v18, v19, v20, v21, v22, v17[1]);
    }
  }
  return 0;
}

void re::ecs2::PhysicsSimulationManager::~PhysicsSimulationManager(re::ecs2::PhysicsSimulationManager *this)
{
}

{
  uint64_t vars8;

  re::ecs2::PhysicsSimulationManager::deinit(this);
  re::ecs2::PhysicsSimulationTracking::~PhysicsSimulationTracking((re::ecs2::PhysicsSimulationManager *)((char *)this + 16));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::PhysicsSimulationManager::isMultipleSimulationEnabled(re::ecs2::PhysicsSimulationManager *this)
{
  return *((unsigned __int8 *)this + 320);
}

uint64_t re::ecs2::PhysicsSimulationManager::perEntityRootPhysicsSimulation(re::ecs2::PhysicsSimulationManager *this)
{
  return (uint64_t)this + 72;
}

uint64_t re::ecs2::PhysicsSimulationManager::physicsSimulationsForScene(uint64_t a1, unint64_t a2)
{
  if (!*(void *)(a1 + 432)) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 440) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 456)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 448);
  if (*(void *)(v5 + 88 * v3 + 16) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 88 * v3 + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v5 + 88 * v3 + 16) == a2) {
        return v5 + 88 * v3 + 24;
      }
    }
    return 0;
  }
  return v5 + 88 * v3 + 24;
}

uint64_t re::ecs2::PhysicsSimulationManager::destroyPendingPhysicsSimulations(re::ecs2::PhysicsSimulationManager *this)
{
  return re::ecs2::PhysicsSimulationTracking::destroyPendingSimulations((re::ecs2::PhysicsSimulationManager *)((char *)this + 16));
}

void re::ecs2::PhysicsSimulationManager::updatePerEntityPhysicsSimulationRoot(re::ecs2::PhysicsSimulationManager *this, char a2)
{
  uint64_t v4 = (char *)this + 16;
  re::ecs2::PhysicsSimulationTracking::updateEnginePreferredUpdateRate((re::ecs2::PhysicsSimulationManager *)((char *)this + 16));
  uint64_t v5 = (char *)this + 120;
  re::ecs2::PhysicsSimulationTracking::buildPerEntityStateForDirtyEntityHierarchies((uint64_t)v4, a2, (uint64_t)v5);
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)v5);
}

re *re::ecs2::PhysicsSimulationManager::registerScene(re::ecs2::PhysicsSimulationManager *this, re::ecs2::Scene *a2)
{
  return re::ecs2::PhysicsSimulationTracking::registerScene((re::ecs2::PhysicsSimulationManager *)((char *)this + 16), (unint64_t)a2);
}

re::ecs2::Scene **re::ecs2::PhysicsSimulationManager::unregisterScene(re::ecs2::PhysicsSimulationManager *this, re::ecs2::Scene *a2)
{
  return re::ecs2::PhysicsSimulationTracking::unregisterScene((re::ecs2::PhysicsSimulationManager *)((char *)this + 16), a2);
}

uint64_t re::ecs2::PhysicsSimulationManager::isDebugRenderingEnabled(re::ecs2::PhysicsSimulationManager *this)
{
  return *((unsigned __int8 *)this + 616);
}

uint64_t re::ecs2::PhysicsSimulationManager::setDebugRenderingEnabled(uint64_t this, char a2)
{
  *(unsigned char *)(this + 616) = a2;
  return this;
}

uint64_t re::ecs2::PhysicsSimulationManager::setDefaultGravity(uint64_t a1, _OWORD *a2)
{
  return re::ecs2::PhysicsSimulationTracking::setDefaultGravity(a1 + 16, a2);
}

uint64_t re::ecs2::PhysicsSimulationManager::defaultGravity(re::ecs2::PhysicsSimulationManager *this)
{
  return (uint64_t)this + 336;
}

uint64_t re::ecs2::PhysicsSimulationManager::setDefaultLinearDamping(uint64_t this, float a2)
{
  *(float *)(this + 352) = a2;
  return this;
}

float re::ecs2::PhysicsSimulationManager::defaultLinearDamping(re::ecs2::PhysicsSimulationManager *this)
{
  return *((float *)this + 88);
}

uint64_t re::ecs2::PhysicsSimulationManager::setDefaultAngularDamping(uint64_t this, float a2)
{
  *(float *)(this + 3re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = a2;
  return this;
}

float re::ecs2::PhysicsSimulationManager::defaultAngularDamping(re::ecs2::PhysicsSimulationManager *this)
{
  return *((float *)this + 89);
}

uint64_t re::ecs2::PhysicsSimulationManager::setDefaultFixedTimeStep(re::ecs2::PhysicsSimulationManager *this, float a2)
{
  *((float *)this + 90) = a2;
  return re::ecs2::PhysicsSimulationTracking::updateDefaultFixedTimeStepsForPhysicsSimulations((uint64_t)this + 16);
}

float re::ecs2::PhysicsSimulationManager::defaultFixedTimeStep(re::ecs2::PhysicsSimulationManager *this)
{
  float result = *((float *)this + 90);
  if (result <= 0.0) {
    return *((float *)this + 91);
  }
  return result;
}

uint64_t re::ecs2::PhysicsSimulationManager::setDefaultMaxSubStepCount(re::ecs2::PhysicsSimulationManager *this, int a2)
{
  return re::ecs2::PhysicsSimulationTracking::setDefaultMaxSubStepCount((uint64_t)this + 16, a2);
}

uint64_t re::ecs2::PhysicsSimulationManager::defaultMaxSubStepCount(re::ecs2::PhysicsSimulationManager *this)
{
  return *((unsigned int *)this + 92);
}

uint64_t re::ecs2::PhysicsSimulationManager::legacyGlobalSimulation(re::ecs2::PhysicsSimulationManager *this)
{
  return *((void *)this + 74);
}

uint64_t re::ecs2::PhysicsSimulationManager::setAnchorShouldHaveSharedSimulationByDefault(uint64_t this, char a2)
{
  *(unsigned char *)(this + 576) = a2;
  return this;
}

uint64_t re::ecs2::PhysicsSimulationManager::anchorShouldHaveSharedSimulationByDefault(re::ecs2::PhysicsSimulationManager *this)
{
  return *((unsigned __int8 *)this + 576);
}

void re::ecs2::PhysicsSimulationTracking::~PhysicsSimulationTracking(re::ecs2::PhysicsSimulationTracking *this)
{
  *((void *)this + 37) = 0;
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 64);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 58);
  re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::deinit((uint64_t *)this + 52);
  re::BucketArray<RESubscriptionHandle,8ul>::deinit((uint64_t)this + 360);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 360);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 34);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 31);
  re::ecs2::HierarchyStateTracking<re::ecs2::RootPhysicsSimulationData>::~HierarchyStateTracking((uint64_t *)this);
}

{
  uint64_t vars8;

  re::ecs2::PhysicsSimulationTracking::~PhysicsSimulationTracking(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t *re::ecs2::HierarchyStateTracking<re::ecs2::RootPhysicsSimulationData>::~HierarchyStateTracking(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C8E28;
  unint64_t v2 = a1 + 1;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 25);
  re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(a1 + 19);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 13);
  re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(a1 + 7);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
  return a1;
}

double re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 88;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(result + 8) = v1 & 0x7FFFFFFF;
    uint64_t v2 = result + 24;
    re::DataArray<re::ecs2::PhysicsSimulationData>::deinit(result + 24);
    return re::DynamicArray<unsigned long>::deinit(v2);
  }
  return result;
}

uint64_t re::DataArray<re::ecs2::PhysicsSimulationData>::deinit(uint64_t result)
{
  if (*(_DWORD *)(result + 44))
  {
    int v1 = (void *)result;
    double v2 = re::DataArray<re::ecs2::PhysicsSimulationData>::clear((void *)result);
    if (!v1[2])
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v3 = (void *)v1[4];
    (*(void (**)(void, void, double))(*(void *)*v1 + 40))(*v1, *v3, v2);
    (*(void (**)(void, void))(*(void *)*v1 + 40))(*v1, v3[1]);
    double result = re::DynamicArray<unsigned long>::deinit((uint64_t)v1);
    *((_DWORD *)v1 + 11) = 0;
  }
  return result;
}

double re::DataArray<re::ecs2::PhysicsSimulationData>::clear(void *a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)v12, (uint64_t)a1, 0);
  if (*(void **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFFLL || (DWORD2(v12[0]) & 0xFFFF0000) != 4294901760)
  {
    do
    {
      unint64_t v4 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)v12);
      re::DataArray<re::ecs2::PhysicsSimulationData>::destroy((uint64_t)a1, v4);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(v12);
    }
    while (*(void **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFF || WORD5(v12[0]) != 0xFFFF);
  }
  uint64_t v7 = a1[2];
  unint64_t v8 = v7 - 1;
  if (v7 != 1)
  {
    uint64_t v9 = 16 * v7;
    do
    {
      if (a1[2] <= v8)
      {
        memset(v12, 0, sizeof(v12));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v10 = a1[4] + v9;
      (*(void (**)(void, void))(*(void *)*a1 + 40))(*a1, *(void *)(v10 - 16));
      (*(void (**)(void, void))(*(void *)*a1 + 40))(*a1, *(void *)(v10 - 8));
      re::DynamicArray<re::DataArray<re::RigGraphOperatorDefinition>::ElementBlock>::removeAt((uint64_t)a1, v8);
      v9 -= 16;
      --v8;
    }
    while (v8);
  }
  double result = NAN;
  a1[6] = 0xFFFFFFFF00000000;
  return result;
}

void re::DataArray<re::ecs2::PhysicsSimulationData>::destroy(uint64_t a1, unint64_t a2)
{
  int v2 = a2;
  unint64_t v4 = a2 >> 16;
  uint64_t v5 = (re *)re::DataArray<re::ecs2::PhysicsSimulationData>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (v5)
  {
    uint64_t v6 = v5;
    re::ecs2::PhysicsSimulationData::deinit(v5);
    objc_destroyWeak((id *)v6 + 6);
    *((void *)v6 + 6) = 0;
    if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *(_DWORD *)uint64_t v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
}

uint64_t re::DataArray<re::ecs2::PhysicsSimulationData>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (unsigned int v3 = *(_DWORD *)(a1 + 44)) : (unsigned int v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((uint64_t v4 = *(void *)(a1 + 32),
          (int v5 = *(_DWORD *)(*(void *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (BOOL v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (BOOL v6 = 0),
         v6)))
  {
    return *(void *)(v4 + 16 * WORD1(a2)) + 272 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::RootPhysicsSimulationData>::trackedComponents()
{
  return 0;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::RootPhysicsSimulationData>::trackedActivationComponents()
{
  return 0;
}

void re::ecs2::HierarchyStateTracking<re::ecs2::RootPhysicsSimulationData>::clearEntityHierarchyStateData(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 84))
  {
    re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v17);
    v11[0] = 0;
    v11[1] = 0;
    int v12 = 1;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = 0;
    int v16 = 0;
    re::BucketArray<re::ecs2::Entity const*,32ul>::init((uint64_t)v11, (uint64_t)v17, 1uLL);
    *(void *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = a2;
    uint64_t v4 = v15;
    if (v15)
    {
      uint64_t v5 = a1 + 56;
      do
      {
        uint64_t v10 = 0;
        uint64_t v10 = *(void *)re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, v4 - 1);
        re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, --v15);
        ++v16;
        re::HashTable<re::ecs2::Entity const*,re::ecs2::RootPhysicsSimulationData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::remove(v5, &v10);
        uint64_t v6 = *(void *)(v10 + 328);
        if (v6)
        {
          uint64_t v7 = *(uint64_t **)(v10 + 344);
          uint64_t v8 = 8 * v6;
          do
          {
            uint64_t v9 = *v7++;
            *(void *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = v9;
            v8 -= 8;
          }
          while (v8);
        }
        uint64_t v4 = v15;
      }
      while (v15);
    }
    re::BucketArray<re::ecs2::Entity const*,32ul>::deinit((uint64_t)v11);
    if (v11[0])
    {
      if ((v12 & 1) == 0) {
        (*(void (**)(void))(*(void *)v11[0] + 40))();
      }
    }
    re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v17);
  }
}

uint64_t re::HashTable<re::ecs2::Entity const*,re::ecs2::RootPhysicsSimulationData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v4 = ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(v5 + 4 * v4);
  if (v6 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  if (*(void *)(v8 + 56 * v6 + 16) != v2)
  {
    while (1)
    {
      unsigned int v9 = v6;
      LODWORD(v6) = *(_DWORD *)(v8 + 56 * v6 + 8) & 0x7FFFFFFF;
      if (v6 == 0x7FFFFFFF) {
        return 0;
      }
      if (*(void *)(v8 + 56 * v6 + 16) == v2)
      {
        *(_DWORD *)(v8 + 56 * v9 + 8) = *(_DWORD *)(v8 + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(v8 + 56 * v6 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v8 + 56 * v6 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = v10 + 56 * v6;
  int v14 = *(_DWORD *)(v11 + 8);
  uint64_t v13 = (int *)(v11 + 8);
  int v12 = v14;
  if (v14 < 0)
  {
    *uint64_t v13 = v12 & 0x7FFFFFFF;
    uint64_t v10 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v10 + 56 * v6 + 8);
  }
  int v15 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v10 + 56 * v6 + 8) = *(_DWORD *)(a1 + 36) | v12 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v6;
  *(_DWORD *)(a1 + 40) = v15 + 1;
  return 1;
}

uint64_t *re::BucketArray<re::ecs2::Entity const*,32ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  double result = re::BucketArray<re::ecs2::Entity const*,32ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::ecs2::Entity const*,32ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 32 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        double result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 256, 0);
        double result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 32 * v3)
  {
    re::BucketArray<re::ecs2::Entity const*,32ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 32) >> 5);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 5)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 5));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 0x1F);
}

uint64_t re::BucketArray<re::ecs2::Entity const*,32ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(void *)(a1 + 8) <= a2 >> 5) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v3 = a1 + 24;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  return *(void *)(v3 + 8 * (a2 >> 5)) + 8 * (a2 & 0x1F);
}

uint64_t re::BucketArray<re::ecs2::Entity const*,32ul>::deinit(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    for (unint64_t i = 0; i != v2; ++i)
      re::BucketArray<re::ecs2::Entity const*,32ul>::operator[](a1, i);
  }
  while (*(void *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  uint64_t result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

double re::ColorManager::ColorManager(re::ColorManager *this)
{
  *(_WORD *)this = 0;
  *((_OWORD *)this + 1) = xmmword_23435FD50;
  *((_OWORD *)this + 2) = xmmword_23435FD60;
  *((_OWORD *)this + 3) = xmmword_23435FD80;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_DWORD *)this + 16) = 0;
  *(_OWORD *)((char *)this + 88) = xmmword_23436C470;
  *(_OWORD *)((char *)this + 104) = xmmword_2343679C0;
  *((unsigned char *)this + 120) = 0;
  __asm { FMOV            V1.2S, #1.0 }
  *(void *)((char *)this + 124) = _D1;
  *((unsigned char *)this + 132) = 0;
  *((void *)this + 17) = 0x3F80000000000000;
  *((unsigned char *)this + 144) = 0;
  *(_OWORD *)((char *)this + 148) = xmmword_23436C480;
  *(void *)((char *)this + 164) = 0;
  *((unsigned char *)this + 172) = 0;
  *(_WORD *)((char *)this + 173) = 257;
  *((_OWORD *)this + 779) = 0u;
  double result = 0.000000381469872;
  *((_OWORD *)this + 780) = xmmword_23436C490;
  return result;
}

void re::RealityDataPipeFactory::~RealityDataPipeFactory(re::RealityDataPipeFactory *this)
{
}

uint64_t re::RealityDataPipeFactory::makeRenderGraphDataPipe(re *a1, uint64_t a2)
{
  uint64_t v3 = re::globalAllocators(a1);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 1920, 8);
  return re::RealityDataPipe::RealityDataPipe(v4, a2);
}

void re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_0,BOOL ()(void)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_0,BOOL ()(void)>::operator()(uint64_t a1)
{
  return re::Engine::isRunning(*(re::Engine **)(a1 + 8));
}

void *re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_0,BOOL ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7790;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_0,BOOL ()(void)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7790;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_0,BOOL ()(void)>::size()
{
  return 16;
}

uint64_t (***re::FunctionBase<24ul,BOOL ()(void)>::destroyCallable(uint64_t a1))(void)
{
  double result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    double result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      double result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void re::ecs2::RenderOptionsManager::~RenderOptionsManager(re::ecs2::RenderOptionsManager *this)
{
  int v1 = (uint64_t *)((char *)this + 8);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32);
  re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::~HierarchyStateTracking(v1);
}

{
  uint64_t *v1;
  uint64_t vars8;

  int v1 = (uint64_t *)((char *)this + 8);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32);
  re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::~HierarchyStateTracking(v1);
  JUMPOUT(0x237DBCBD0);
}

char *re::ecs2::RenderOptionsManager::renderOptions(re::ecs2::RenderOptionsManager *this)
{
  int v1 = (char *)this + 8;
  if (*((_DWORD *)this + 35)) {
    re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::updatePerEntityStateData((uint64_t)this + 8);
  }
  return v1;
}

uint64_t re::ecs2::RenderOptionsManager::registerScene(re::ecs2::RenderOptionsManager *this, re::EventBus **a2)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  long long v44 = (re::ecs2::Scene *)a2;
  uint64_t v2 = a2[36];
  if (!v2)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) An event bus is expected for this system to track entity state changes.", "eventBus", "registerScene", 100);
    _os_crash();
    __break(1u);
  }
  uint64_t v4 = (re::ecs2::RenderOptionsManager *)((char *)this + 8);
  v38[0] = 0;
  v38[1] = 0;
  int v39 = 1;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v40 = 0;
  int v43 = 0;
  uint64_t v5 = (re *)(*(uint64_t (**)(re *))(*(void *)v4 + 16))(v4);
  if (v6)
  {
    uint64_t v7 = (uint64_t *)v5;
    uint64_t v8 = 8 * v6;
    do
    {
      uint64_t v9 = *v7++;
      uint64_t v46 = re::globalAllocators(v5)[2];
      uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v46 + 32))(v46, 32, 0);
      *uint64_t v10 = &unk_26E6C7860;
      v10[1] = v4;
      void v10[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentDidChangeEvent>;
      v10[3] = 0;
      unsigned __int16 v47 = v10;
      uint64_t v11 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidChangeEvent>(v2, (uint64_t)v45, v9, 0);
      uint64_t v13 = v12;
      int v14 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
      *int v14 = v11;
      v14[1] = v13;
      re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable((uint64_t)v45);
      re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(v4, v2, (uint64_t)v38, v9);
      uint64_t v5 = (re *)re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(v4, v2, (uint64_t)v38, v9);
      v8 -= 8;
    }
    while (v8);
  }
  int v15 = (re *)(*(uint64_t (**)(re *))(*(void *)v4 + 24))(v4);
  if (v16)
  {
    BOOL v17 = (uint64_t *)v15;
    uint64_t v18 = 8 * v16;
    do
    {
      uint64_t v19 = *v17++;
      re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(v4, v2, (uint64_t)v38, v19);
      int v15 = (re *)re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(v4, v2, (uint64_t)v38, v19);
      v18 -= 8;
    }
    while (v18);
  }
  uint64_t v46 = re::globalAllocators(v15)[2];
  uint64_t v20 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v46 + 32))(v46, 32, 0);
  *uint64_t v20 = &unk_26E6C7968;
  v20[1] = v4;
  void v20[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityDidReparentEvent>;
  v20[3] = 0;
  unsigned __int16 v47 = v20;
  uint64_t v21 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidReparentEvent>(v2, (uint64_t)v45, 0, 0);
  uint64_t v23 = v22;
  uint64_t v24 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  *uint64_t v24 = v21;
  v24[1] = v23;
  uint64_t v25 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable((uint64_t)v45);
  uint64_t v46 = re::globalAllocators(v25)[2];
  uint64_t v26 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v46 + 32))(v46, 32, 0);
  void *v26 = &unk_26E6C79C0;
  v26[1] = v4;
  v26[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityDidActivateEvent>;
  v26[3] = 0;
  unsigned __int16 v47 = v26;
  uint64_t v27 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidActivateEvent>(v2, (uint64_t)v45, 0, 0);
  uint64_t v29 = v28;
  uint64_t v30 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  *uint64_t v30 = v27;
  v30[1] = v29;
  uint64_t v31 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::destroyCallable((uint64_t)v45);
  uint64_t v46 = re::globalAllocators(v31)[2];
  uint64_t v32 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v46 + 32))(v46, 32, 0);
  void *v32 = &unk_26E6C7A18;
  v32[1] = v4;
  _OWORD v32[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityWillDeactivateEvent>;
  v32[3] = 0;
  unsigned __int16 v47 = v32;
  uint64_t v33 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(v2, (uint64_t)v45, 0, 0);
  uint64_t v35 = v34;
  uint64_t v36 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  void *v36 = v33;
  v36[1] = v35;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::destroyCallable((uint64_t)v45);
  re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add((uint64_t)this + 160, (uint64_t *)&v44, (uint64_t)v38);
  re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add((uint64_t)this + 16, (uint64_t *)&v44);
  re::BucketArray<RESubscriptionHandle,8ul>::deinit((uint64_t)v38);
  uint64_t result = v38[0];
  if (v38[0])
  {
    if ((v39 & 1) == 0) {
      return (*(uint64_t (**)(void))(*(void *)v38[0] + 40))();
    }
  }
  return result;
}

uint64_t re::ecs2::RenderOptionsManager::unregisterScene(re::ecs2::RenderOptionsManager *this, re::ecs2::Scene *a2)
{
  int v14 = a2;
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)this + 16, (uint64_t *)&v14);
  uint64_t v3 = *((void *)v14 + 13);
  uint64_t v4 = *(void *)(v3 + 328);
  if (v4)
  {
    uint64_t v5 = *(void *)(v3 + 344);
    uint64_t v6 = 8 * v4;
    do
    {
      if (*(unsigned char *)(*(void *)v5 + 288)) {
        (*(void (**)(char *))(*((void *)this + 1) + 40))((char *)this + 8);
      }
      v5 += 8;
      v6 -= 8;
    }
    while (v6);
  }
  uint64_t v7 = (char *)this + 160;
  uint64_t result = re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet((uint64_t)v7, (uint64_t *)&v14);
  if (result)
  {
    uint64_t v9 = *((void *)v14 + 36);
    if (v9)
    {
      uint64_t v10 = result;
      uint64_t v11 = *(void *)(result + 40);
      if (v11)
      {
        for (unint64_t i = 0; i != v11; ++i)
        {
          uint64_t v13 = re::BucketArray<RESubscriptionHandle,8ul>::operator[](v10, i);
          re::EventBus::unsubscribe(v9, *(void *)v13, *(void *)(v13 + 8));
        }
      }
    }
    return re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::remove((uint64_t)v7, (uint64_t *)&v14);
  }
  return result;
}

BOOL re::ecs2::RenderOptionsManager::needsUpdate(re::ecs2::RenderOptionsManager *this)
{
  return *((_DWORD *)this + 35) != 0;
}

uint64_t *re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::~HierarchyStateTracking(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C8DD8;
  uint64_t v2 = a1 + 1;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 25);
  re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(a1 + 19);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 13);
  re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(a1 + 7);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
  return a1;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::trackedComponents()
{
  return 0;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::trackedActivationComponents()
{
  return 0;
}

void re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::clearEntityHierarchyStateData(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 84))
  {
    re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v17);
    v11[0] = 0;
    v11[1] = 0;
    int v12 = 1;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = 0;
    int v16 = 0;
    re::BucketArray<re::ecs2::Entity const*,32ul>::init((uint64_t)v11, (uint64_t)v17, 1uLL);
    *(void *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = a2;
    uint64_t v4 = v15;
    if (v15)
    {
      uint64_t v5 = a1 + 56;
      do
      {
        uint64_t v10 = 0;
        uint64_t v10 = *(void *)re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, v4 - 1);
        re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, --v15);
        ++v16;
        re::HashTable<re::ecs2::Entity const*,re::ecs2::RootPhysicsSimulationData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::remove(v5, &v10);
        uint64_t v6 = *(void *)(v10 + 328);
        if (v6)
        {
          uint64_t v7 = *(uint64_t **)(v10 + 344);
          uint64_t v8 = 8 * v6;
          do
          {
            uint64_t v9 = *v7++;
            *(void *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = v9;
            v8 -= 8;
          }
          while (v8);
        }
        uint64_t v4 = v15;
      }
      while (v15);
    }
    re::BucketArray<re::ecs2::Entity const*,32ul>::deinit((uint64_t)v11);
    if (v11[0])
    {
      if ((v12 & 1) == 0) {
        (*(void (**)(void))(*(void *)v11[0] + 40))();
      }
    }
    re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v17);
  }
}

uint64_t (***re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(re *a1, re::EventBus *a2, uint64_t a3, uint64_t a4))(void)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v15 = re::globalAllocators(a1)[2];
  uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v15 + 32))(v15, 32, 0);
  void *v8 = &unk_26E6C78B8;
  v8[1] = a1;
  _OWORD v8[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentDidActivateEvent>;
  v8[3] = 0;
  int v16 = v8;
  uint64_t v9 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidActivateEvent>(a2, (uint64_t)v14, a4, 0);
  uint64_t v11 = v10;
  int v12 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(a3);
  *int v12 = v9;
  v12[1] = v11;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable((uint64_t)v14);
}

uint64_t (***re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(re *a1, re::EventBus *a2, uint64_t a3, uint64_t a4))(void)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v15 = re::globalAllocators(a1)[2];
  uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v15 + 32))(v15, 32, 0);
  void *v8 = &unk_26E6C7910;
  v8[1] = a1;
  _OWORD v8[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentWillDeactivateEvent>;
  v8[3] = 0;
  int v16 = v8;
  uint64_t v9 = re::EventBus::subscribe<re::ecs2::Entity,REComponentWillDeactivateEvent>(a2, (uint64_t)v14, a4, 0);
  uint64_t v11 = v10;
  int v12 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(a3);
  *int v12 = v9;
  v12[1] = v11;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable((uint64_t)v14);
}

uint64_t re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 80 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 80 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 80 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 80 * v10;
  return v12 + 24;
}

uint64_t re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(void *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentDidChangeEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (!*(unsigned char *)(a2 + 371)
    && (*(unsigned char *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

uint64_t re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  unint64_t v7 = *(unsigned int *)(a1 + 24);
  if (!v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % v7;
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v6 % v7));
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v12 = re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v11 = *(void *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (*(void *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)unsigned int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7860;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C7860;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentDidActivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (!*(unsigned char *)(a2 + 371)
    && (*(unsigned char *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C78B8;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C78B8;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentWillDeactivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (!*(unsigned char *)(a2 + 371)
    && (*(unsigned char *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7910;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C7910;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, char a4)
{
  v9[5] = *MEMORY[0x263EF8340];
  v9[3] = *(void *)(a2 + 24);
  unsigned char v9[4] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator=<24ul>((uint64_t)v9, a2);
  uint64_t v7 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidReparentEvent>(a1, 0, (uint64_t)v9, a3, a4);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable((uint64_t)v9);
  return v7;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityDidReparentEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (!*(unsigned char *)(a2 + 371)
    && (*(unsigned char *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v14[8] = *MEMORY[0x263EF8340];
  uint64_t Type = re::EventBus::getTypeId<RESceneEntityDidReparentEvent>();
  unint64_t EventInfo = re::EventBus::addOrGetEventInfo(a1, Type);
  re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(a3, a5, v14);
  uint64_t v12 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v14, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v14);
  return v12;
}

{
  uint64_t Type;
  re *EventInfo;
  uint64_t v12;
  uint64_t v13;
  void v15[5];
  void v16[9];

  unsigned char v16[8] = *MEMORY[0x263EF8340];
  uint64_t Type = re::EventBus::getTypeId<RESceneEntityDidReparentEvent>();
  unint64_t EventInfo = (re *)re::EventBus::addOrGetEventInfo(a1, Type);
  uint64_t v12 = re::globalAllocators(EventInfo)[2];
  v15[0] = &unk_26E6FA0D8;
  v15[1] = a3;
  _OWORD v15[3] = v12;
  v15[4] = v15;
  re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>((uint64_t)v15, a5, v16);
  unsigned int v13 = re::EventBus::EventInfo::addSubscription((unint64_t)EventInfo, (uint64_t)v16, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v16);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable((uint64_t)v15);
  return v13;
}

uint64_t (***re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>@<X0>(uint64_t a1@<X2>, char a2@<W4>, void *a3@<X8>))(void)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v6 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v6)[2];
    a3[7] = 0;
    long long v5 = &unk_26E6C8EB8;
  }
  else
  {
    uint64_t v4 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v4)[2];
    a3[7] = 0;
    long long v5 = &unk_26E6C8F10;
  }
  *a3 = v5;
  a3[4] = v9;
  a3[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v8);
  a3[7] = a3;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable((uint64_t)v8);
}

uint64_t re::EventBus::getTypeId<RESceneEntityDidReparentEvent>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::EventBus::getTypeId<RESceneEntityDidReparentEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"29RESceneEntityDidReparentEvent" & 0x7FFFFFFFFFFFFFFFLL), v3);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[416];
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C8EB8;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C8EB8;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
  return 1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C8EB8;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C8EB8;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C8F10;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C8F10;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  return (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C8F10;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C8F10;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

uint64_t re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t (***re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator()(void *a1, void *a2)
{
  int v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    int v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7968;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C7968;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::size()
{
  return 32;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, char a4)
{
  v9[5] = *MEMORY[0x263EF8340];
  v9[3] = *(void *)(a2 + 24);
  unsigned char v9[4] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator=<24ul>((uint64_t)v9, a2);
  uint64_t v7 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidActivateEvent>(a1, 0, (uint64_t)v9, a3, a4);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::destroyCallable((uint64_t)v9);
  return v7;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityDidActivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  if (!*(unsigned char *)(a2 + 371))
  {
    uint64_t v3 = a1 + 200;
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v5);
    re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove(v3, &v5);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C79C0;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C79C0;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, char a4)
{
  v9[5] = *MEMORY[0x263EF8340];
  v9[3] = *(void *)(a2 + 24);
  unsigned char v9[4] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)v9, a2);
  uint64_t v7 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(a1, 0, (uint64_t)v9, a3, a4);
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::destroyCallable((uint64_t)v9);
  return v7;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityWillDeactivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v3 = a1 + 200;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove(a1 + 104, &v5);
  re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(v3, &v5);
  return 0;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v14[8] = *MEMORY[0x263EF8340];
  uint64_t Type = re::EventBus::getTypeId<RESceneEntityWillDeactivateEvent>();
  unint64_t EventInfo = re::EventBus::addOrGetEventInfo(a1, Type);
  re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(a3, a5, v14);
  uint64_t v12 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v14, a2, a4);
  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v14);
  return v12;
}

uint64_t (***re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>@<X0>(uint64_t a1@<X2>, char a2@<W4>, void *a3@<X8>))(void)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = 0;
  if (a2)
  {
    uint64_t v6 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v6)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C8F78;
  }
  else
  {
    uint64_t v4 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)v8, a1);
    a3[6] = re::globalAllocators(v4)[2];
    a3[7] = 0;
    uint64_t v5 = &unk_26E6C8FD0;
  }
  *a3 = v5;
  a3[4] = v9;
  a3[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v8);
  a3[7] = a3;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::destroyCallable((uint64_t)v8);
}

uint64_t re::EventBus::getTypeId<RESceneEntityWillDeactivateEvent>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::EventBus::getTypeId<RESceneEntityWillDeactivateEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"32RESceneEntityWillDeactivateEvent" & 0x7FFFFFFFFFFFFFFFLL), v3);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[420];
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C8F78;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C8F78;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  (*(void (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
  return 1;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C8F78;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C8F78;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C8FD0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(void *a1)
{
  *a1 = &unk_26E6C8FD0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v5 = *a2;
  return (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v5, v3);
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C8FD0;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

void *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, void *a2)
{
  *a2 = &unk_26E6C8FD0;
  a2[4] = *(void *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

uint64_t re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        unint64_t v7 = v5;
        uint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          uint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t (***re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator()(void *a1, void *a2)
{
  int v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    int v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7A18;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C7A18;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 80 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 80 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 80 * v10) = a3;
  *(void *)(*(void *)(a1 + 16) + 80 * v10 + 16) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + 80 * v10;
  *(void *)(v14 + 24) = 0;
  *(void *)(v14 + 32) = 0;
  v14 += 24;
  *(_DWORD *)(v14 + 16) = 1;
  *(void *)(v14 + 32) = 0;
  *(void *)(v14 + 40) = 0;
  *(void *)(v14 + 24) = 0;
  *(_DWORD *)(v14 + 48) = 0;
  re::BucketArray<RESubscriptionHandle,8ul>::swap(v14, a5);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 24);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 80;
        }
        while (v11 < v9);
      }
      re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v8) = a3;
  *(void *)(*(void *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), *(void *)&v13[16] + v10 + 16, *(void *)&v13[16] + v10 + 16);
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(void *)(v6 + 80 * v4 + 16) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 80 * v4 + 8) & 0x7FFFFFFF;
      if (v4 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v6 + 80 * v4 + 16) == v2) {
        return v6 + 80 * v4 + 24;
      }
    }
    return 0;
  }
  return v6 + 80 * v4 + 24;
}

void re::ecs2::VisualProxyScopeManager::~VisualProxyScopeManager(re::ecs2::VisualProxyScopeManager *this)
{
  int v1 = (uint64_t *)((char *)this + 8);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32);
  re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::~HierarchyStateTracking(v1);
}

{
  uint64_t *v1;
  uint64_t vars8;

  int v1 = (uint64_t *)((char *)this + 8);
  re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 32);
  re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::~HierarchyStateTracking(v1);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::VisualProxyScopeManager::scopeDataPerEntity(re::ecs2::VisualProxyScopeManager *this)
{
  return (uint64_t)this + 64;
}

void re::ecs2::VisualProxyScopeManager::updateScopeMaskData(re::ecs2::VisualProxyScopeManager *this)
{
  int v1 = (char *)this + 8;
  uint64_t v2 = (char *)this + 112;
  (*(void (**)(char *, char *))(*((void *)this + 1) + 32))((char *)this + 8, (char *)this + 112);
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)v2);
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)(v1 + 200));
}

uint64_t re::ecs2::VisualProxyScopeManager::registerScene(re::ecs2::VisualProxyScopeManager *this, re::EventBus **a2)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  long long v44 = (re::ecs2::Scene *)a2;
  uint64_t v2 = a2[36];
  if (!v2)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) An event bus is expected for this system to track entity state changes.", "eventBus", "registerScene", 100);
    _os_crash();
    __break(1u);
  }
  uint64_t v4 = (re::ecs2::VisualProxyScopeManager *)((char *)this + 8);
  v38[0] = 0;
  v38[1] = 0;
  int v39 = 1;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v40 = 0;
  int v43 = 0;
  long long v5 = (re *)(*(uint64_t (**)(re *))(*(void *)v4 + 16))(v4);
  if (v6)
  {
    unsigned int v7 = (uint64_t *)v5;
    uint64_t v8 = 8 * v6;
    do
    {
      uint64_t v9 = *v7++;
      uint64_t v46 = re::globalAllocators(v5)[2];
      uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v46 + 32))(v46, 32, 0);
      *uint64_t v10 = &unk_26E6C7AD8;
      v10[1] = v4;
      void v10[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentDidChangeEvent>;
      v10[3] = 0;
      unsigned __int16 v47 = v10;
      uint64_t v11 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidChangeEvent>(v2, (uint64_t)v45, v9, 0);
      uint64_t v13 = v12;
      uint64_t v14 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
      *uint64_t v14 = v11;
      v14[1] = v13;
      re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::destroyCallable((uint64_t)v45);
      re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(v4, v2, (uint64_t)v38, v9);
      long long v5 = (re *)re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(v4, v2, (uint64_t)v38, v9);
      v8 -= 8;
    }
    while (v8);
  }
  uint64_t v15 = (re *)(*(uint64_t (**)(re *))(*(void *)v4 + 24))(v4);
  if (v16)
  {
    uint64_t v17 = (uint64_t *)v15;
    uint64_t v18 = 8 * v16;
    do
    {
      uint64_t v19 = *v17++;
      re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(v4, v2, (uint64_t)v38, v19);
      uint64_t v15 = (re *)re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(v4, v2, (uint64_t)v38, v19);
      v18 -= 8;
    }
    while (v18);
  }
  uint64_t v46 = re::globalAllocators(v15)[2];
  uint64_t v20 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v46 + 32))(v46, 32, 0);
  *uint64_t v20 = &unk_26E6C7BE0;
  v20[1] = v4;
  void v20[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityDidReparentEvent>;
  v20[3] = 0;
  unsigned __int16 v47 = v20;
  uint64_t v21 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidReparentEvent>(v2, (uint64_t)v45, 0, 0);
  uint64_t v23 = v22;
  uint64_t v24 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  *uint64_t v24 = v21;
  v24[1] = v23;
  uint64_t v25 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::destroyCallable((uint64_t)v45);
  uint64_t v46 = re::globalAllocators(v25)[2];
  uint64_t v26 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v46 + 32))(v46, 32, 0);
  void *v26 = &unk_26E6C7C38;
  v26[1] = v4;
  v26[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityDidActivateEvent>;
  v26[3] = 0;
  unsigned __int16 v47 = v26;
  uint64_t v27 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidActivateEvent>(v2, (uint64_t)v45, 0, 0);
  uint64_t v29 = v28;
  uint64_t v30 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  *uint64_t v30 = v27;
  v30[1] = v29;
  uint64_t v31 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::destroyCallable((uint64_t)v45);
  uint64_t v46 = re::globalAllocators(v31)[2];
  uint64_t v32 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v46 + 32))(v46, 32, 0);
  void *v32 = &unk_26E6C7C90;
  v32[1] = v4;
  _OWORD v32[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityWillDeactivateEvent>;
  v32[3] = 0;
  unsigned __int16 v47 = v32;
  uint64_t v33 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(v2, (uint64_t)v45, 0, 0);
  uint64_t v35 = v34;
  uint64_t v36 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  void *v36 = v33;
  v36[1] = v35;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::destroyCallable((uint64_t)v45);
  re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add((uint64_t)this + 160, (uint64_t *)&v44, (uint64_t)v38);
  re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add((uint64_t)this + 16, (uint64_t *)&v44);
  re::BucketArray<RESubscriptionHandle,8ul>::deinit((uint64_t)v38);
  uint64_t result = v38[0];
  if (v38[0])
  {
    if ((v39 & 1) == 0) {
      return (*(uint64_t (**)(void))(*(void *)v38[0] + 40))();
    }
  }
  return result;
}

uint64_t re::ecs2::VisualProxyScopeManager::unregisterScene(re::ecs2::VisualProxyScopeManager *this, re::ecs2::Scene *a2)
{
  uint64_t v14 = a2;
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)this + 16, (uint64_t *)&v14);
  uint64_t v3 = *((void *)v14 + 13);
  uint64_t v4 = *(void *)(v3 + 328);
  if (v4)
  {
    uint64_t v5 = *(void *)(v3 + 344);
    uint64_t v6 = 8 * v4;
    do
    {
      if (*(unsigned char *)(*(void *)v5 + 288)) {
        (*(void (**)(char *))(*((void *)this + 1) + 40))((char *)this + 8);
      }
      v5 += 8;
      v6 -= 8;
    }
    while (v6);
  }
  unsigned int v7 = (char *)this + 160;
  uint64_t result = re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet((uint64_t)v7, (uint64_t *)&v14);
  if (result)
  {
    uint64_t v9 = *((void *)v14 + 36);
    if (v9)
    {
      uint64_t v10 = result;
      uint64_t v11 = *(void *)(result + 40);
      if (v11)
      {
        for (unint64_t i = 0; i != v11; ++i)
        {
          uint64_t v13 = re::BucketArray<RESubscriptionHandle,8ul>::operator[](v10, i);
          re::EventBus::unsubscribe(v9, *(void *)v13, *(void *)(v13 + 8));
        }
      }
    }
    return re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::remove((uint64_t)v7, (uint64_t *)&v14);
  }
  return result;
}

uint64_t *re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::~HierarchyStateTracking(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_26E6C8E78;
  uint64_t v2 = a1 + 1;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 25);
  re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(a1 + 19);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 13);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 7);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
  return a1;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::trackedComponents()
{
  return 0;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::trackedActivationComponents()
{
  return 0;
}

void re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::clearEntityHierarchyStateData(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 84))
  {
    re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v17);
    v11[0] = 0;
    v11[1] = 0;
    int v12 = 1;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v13 = 0;
    int v16 = 0;
    re::BucketArray<re::ecs2::Entity const*,32ul>::init((uint64_t)v11, (uint64_t)v17, 1uLL);
    *(void *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = a2;
    uint64_t v4 = v15;
    if (v15)
    {
      uint64_t v5 = a1 + 56;
      do
      {
        uint64_t v10 = 0;
        uint64_t v10 = *(void *)re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, v4 - 1);
        re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, --v15);
        ++v16;
        re::HashTable<re::ecs2::Entity const*,re::ecs2::EntityVisualProxyScopeData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::remove(v5, &v10);
        uint64_t v6 = *(void *)(v10 + 328);
        if (v6)
        {
          unsigned int v7 = *(uint64_t **)(v10 + 344);
          uint64_t v8 = 8 * v6;
          do
          {
            uint64_t v9 = *v7++;
            *(void *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = v9;
            v8 -= 8;
          }
          while (v8);
        }
        uint64_t v4 = v15;
      }
      while (v15);
    }
    re::BucketArray<re::ecs2::Entity const*,32ul>::deinit((uint64_t)v11);
    if (v11[0])
    {
      if ((v12 & 1) == 0) {
        (*(void (**)(void))(*(void *)v11[0] + 40))();
      }
    }
    re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v17);
  }
}

uint64_t re::HashTable<re::ecs2::Entity const*,re::ecs2::EntityVisualProxyScopeData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v4 = ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(v5 + 4 * v4);
  if (v6 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = v8 + 32 * v6;
  if (*(void *)(v9 + 16) != v2)
  {
    while (1)
    {
      unsigned int v10 = v6;
      uint64_t v6 = *(_DWORD *)(v8 + 32 * v6 + 8) & 0x7FFFFFFF;
      if (v6 == 0x7FFFFFFF) {
        return 0;
      }
      uint64_t v11 = v8 + 32 * v6;
      if (*(void *)(v11 + 16) == v2)
      {
        *(_DWORD *)(v8 + 32 * v10 + 8) = *(_DWORD *)(v8 + 32 * v10 + 8) & 0x80000000 | *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
LABEL_9:
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v13 = v12 + 32 * v6;
  int v16 = *(_DWORD *)(v13 + 8);
  uint64_t v15 = (int *)(v13 + 8);
  int v14 = v16;
  if (v16 < 0)
  {
    *uint64_t v15 = v14 & 0x7FFFFFFF;
    uint64_t v12 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v12 + 32 * v6 + 8);
  }
  int v17 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v12 + 32 * v6 + 8) = *(_DWORD *)(a1 + 36) | v14 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v6;
  *(_DWORD *)(a1 + 40) = v17 + 1;
  return 1;
}

uint64_t (***re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(re *a1, re::EventBus *a2, uint64_t a3, uint64_t a4))(void)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v15 = re::globalAllocators(a1)[2];
  uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v15 + 32))(v15, 32, 0);
  void *v8 = &unk_26E6C7B30;
  v8[1] = a1;
  _OWORD v8[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentDidActivateEvent>;
  v8[3] = 0;
  int v16 = v8;
  uint64_t v9 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidActivateEvent>(a2, (uint64_t)v14, a4, 0);
  uint64_t v11 = v10;
  uint64_t v12 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(a3);
  *uint64_t v12 = v9;
  v12[1] = v11;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::destroyCallable((uint64_t)v14);
}

uint64_t (***re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(re *a1, re::EventBus *a2, uint64_t a3, uint64_t a4))(void)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v15 = re::globalAllocators(a1)[2];
  uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v15 + 32))(v15, 32, 0);
  void *v8 = &unk_26E6C7B88;
  v8[1] = a1;
  _OWORD v8[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentWillDeactivateEvent>;
  v8[3] = 0;
  int v16 = v8;
  uint64_t v9 = re::EventBus::subscribe<re::ecs2::Entity,REComponentWillDeactivateEvent>(a2, (uint64_t)v14, a4, 0);
  uint64_t v11 = v10;
  uint64_t v12 = (void *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(a3);
  *uint64_t v12 = v9;
  v12[1] = v11;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::destroyCallable((uint64_t)v14);
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentDidChangeEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (!*(unsigned char *)(a2 + 371)
    && (*(unsigned char *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7AD8;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C7AD8;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentDidActivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (!*(unsigned char *)(a2 + 371)
    && (*(unsigned char *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7B30;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C7B30;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentWillDeactivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (!*(unsigned char *)(a2 + 371)
    && (*(unsigned char *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7B88;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C7B88;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityDidReparentEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (!*(unsigned char *)(a2 + 371)
    && (*(unsigned char *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7BE0;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C7BE0;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityDidActivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  if (!*(unsigned char *)(a2 + 371))
  {
    uint64_t v3 = a1 + 200;
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v5);
    re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove(v3, &v5);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7C38;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C7C38;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityWillDeactivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v3 = a1 + 200;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove(a1 + 104, &v5);
  re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(v3, &v5);
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::~CallableMemFn()
{
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = (uint64_t (*)(void *, void))a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (void *)(a1[1] + (v3 >> 1));
  if (v3) {
    uint64_t v2 = *(uint64_t (**)(void *, void))(*v4 + v2);
  }
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7C90;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)a2 = &unk_26E6C7C90;
  *(void *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::size()
{
  return 32;
}

void re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_1,void ()(re::Function<void ()(void)> const&)>::~Callable()
{
}

uint64_t (***re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_1,void ()(re::Function<void ()(void)> const&)>::operator()(uint64_t a1, uint64_t a2))(void)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v5, a2);
  uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 832);
  uint64_t v9 = v6;
  uint64_t v10 = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v8, (uint64_t)v5);
  re::ResourceFetchManager::executeWithMostRecentTransportVoucher(v3, (uint64_t)v8);
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v8);
  return re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v5);
}

void *re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_1,void ()(re::Function<void ()(void)> const&)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7CE8;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_1,void ()(re::Function<void ()(void)> const&)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7CE8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_1,void ()(re::Function<void ()(void)> const&)>::size()
{
  return 16;
}

uint64_t (***re::FunctionBase<24ul,void ()(re::Function<void ()(void)> const&)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_2,void ()(unsigned long long,re::Function<void ()(void)> const&)>::~Callable()
{
}

uint64_t (***re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_2,void ()(unsigned long long,re::Function<void ()(void)> const&)>::operator()(uint64_t a1, uint64_t *a2, uint64_t a3))(void)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v4 = *a2;
  uint64_t v8 = *(void *)(a3 + 24);
  uint64_t v9 = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v7, a3);
  uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 832);
  uint64_t v11 = v8;
  uint64_t v12 = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v10, (uint64_t)v7);
  re::ResourceFetchManager::executeWithMostRecentTransportVoucherForPeerID(v5, v4, (uint64_t)v10);
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v10);
  return re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v7);
}

void *re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_2,void ()(unsigned long long,re::Function<void ()(void)> const&)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7D50;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_2,void ()(unsigned long long,re::Function<void ()(void)> const&)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7D50;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_2,void ()(unsigned long long,re::Function<void ()(void)> const&)>::size()
{
  return 16;
}

uint64_t (***re::FunctionBase<24ul,void ()(unsigned long long,re::Function<void ()(void)> const&)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::Scheduler::TaskDescriptor>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = v4 << 7;
        do
        {
          re::DynamicArray<unsigned long>::deinit((uint64_t)v3 + 88);
          re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)v3 + 40);
          re::StringID::destroyString(v3);
          uint64_t v3 = (re::StringID *)((char *)v3 + 128);
          v5 -= 128;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(re::StringID **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::Scheduler::TaskDescriptor>::add(_anonymous_namespace_ *this, uint64_t *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::Scheduler::TaskDescriptor>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + (v4 << 7);
  uint64_t v6 = *a2;
  *(void *)uint64_t v5 = *(void *)v5 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(void *)uint64_t v5 = *a2 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(void *)(v5 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  long long v7 = *((_OWORD *)a2 + 1);
  *(void *)(v5 + 29) = *(uint64_t *)((char *)a2 + 29);
  *(_OWORD *)(v5 + 16) = v7;
  *(void *)(v5 + 64) = a2[8];
  *(void *)(v5 + 72) = 0;
  uint64_t result = re::FunctionBase<24ul,void ()(float)>::operator=<24ul>(v5 + 40, (uint64_t)(a2 + 5));
  uint64_t v9 = a2[10];
  *(void *)(v5 + 120) = 0;
  *(_DWORD *)(v5 + ++*(void *)(this + 112) = 0;
  *(void *)(v5 + 96) = 0;
  *(void *)(v5 + 104) = 0;
  *(void *)(v5 + 80) = v9;
  *(void *)(v5 + 88) = 0;
  uint64_t v10 = a2[12];
  *(void *)(v5 + 88) = a2[11];
  *(void *)(v5 + 96) = v10;
  a2[11] = 0;
  a2[12] = 0;
  uint64_t v11 = *(void *)(v5 + 104);
  *(void *)(v5 + 104) = a2[13];
  a2[13] = v11;
  uint64_t v12 = *(void *)(v5 + 120);
  *(void *)(v5 + 120) = a2[15];
  a2[15] = v12;
  ++*((_DWORD *)a2 + 28);
  ++*(_DWORD *)(v5 + 112);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::Scheduler::TaskDescriptor>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::Scheduler::TaskDescriptor>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Scheduler::TaskDescriptor>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::Scheduler::TaskDescriptor>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::Scheduler::TaskDescriptor>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 57)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 128, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          unint64_t v2 = a2 << 7;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, a2 << 7, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = &v8[16 * v9];
        uint64_t v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *uint64_t v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *uint64_t v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          uint64_t *v8 = 0;
          v8[1] = (uint64_t)"";
          long long v13 = *((_OWORD *)v8 + 1);
          *(unint64_t *)((char *)v11 + 29) = *(uint64_t *)((char *)v8 + 29);
          *((_OWORD *)v11 + 1) = v13;
          v11[8] = v8[8];
          v11[9] = 0;
          re::FunctionBase<24ul,void ()(float)>::operator=<24ul>((uint64_t)(v11 + 5), (uint64_t)(v8 + 5));
          uint64_t v14 = v8[10];
          v11[15] = 0;
          *((_DWORD *)v11 + 28) = 0;
          v11[12] = 0;
          v11[13] = 0;
          v11[10] = v14;
          v11[11] = 0;
          uint64_t v15 = v8[12];
          v11[11] = v8[11];
          v8[11] = 0;
          v11[12] = v15;
          v8[12] = 0;
          uint64_t v16 = v11[13];
          v11[13] = v8[13];
          v8[13] = v16;
          uint64_t v17 = v11[15];
          v11[15] = v8[15];
          v8[15] = v17;
          ++*((_DWORD *)v8 + 28);
          ++*((_DWORD *)v11 + 28);
          re::DynamicArray<unsigned long>::deinit((uint64_t)(v8 + 11));
          re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)(v8 + 5));
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 16;
          v11 += 16;
        }
        while (v8 != v10);
        uint64_t v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::FunctionBase<24ul,void ()(float)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(float)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (*(void *)(a1 + 24) == *(void *)(a2 + 24))
    {
      uint64_t v5 = a2;
      if (v4 != a2)
      {
        *(void *)(a1 + 32) = v4;
        *(void *)(a2 + 32) = 0;
        return a1;
      }
    }
    else
    {
      uint64_t v5 = *(void *)(a2 + 32);
      if (!v4) {
        return a1;
      }
    }
    unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(v5);
    uint64_t v7 = a1;
    if (v6 >= 0x19)
    {
      unint64_t v8 = v6;
      uint64_t v9 = *(void *)(a1 + 24);
      if (v9) {
        uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v9 + 32))(v9, v8, 0);
      }
      else {
        uint64_t v7 = 0;
      }
    }
    *(void *)(a1 + 32) = v7;
    (*(void (**)(void))(**(void **)(a2 + 32) + 32))(*(void *)(a2 + 32));
    re::FunctionBase<24ul,void ()(float)>::destroyCallable(a2);
  }
  return a1;
}

{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  if (a1 != a2)
  {
    re::FunctionBase<24ul,void ()(float)>::destroyCallable(a1);
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      unint64_t v6 = a1;
      if (v5 >= 0x19)
      {
        uint64_t v7 = v5;
        unint64_t v8 = *(void *)(a1 + 24);
        if (v8) {
          unint64_t v6 = (*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v8 + 32))(v8, v7, 0);
        }
        else {
          unint64_t v6 = 0;
        }
      }
      *(void *)(a1 + 32) = v6;
      (*(void (**)(void))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32));
    }
  }
  return a1;
}

uint64_t (***re::FunctionBase<24ul,void ()(float)>::destroyCallable(uint64_t a1))(void)
{
  uint64_t result = *(uint64_t (****)(void))(a1 + 32);
  if (result)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    if (*(void *)(a1 + 32) != a1) {
      uint64_t result = (uint64_t (***)(void))(*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
    }
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

void re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, *(re::ProfilerManager **)(*((void *)a1 + 1) + 952), 1);
  }
  uint64_t v4 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if (v4)
  {
    uint64_t v5 = (re::ProfilerThreadContext *)re::profilerThreadContext(v4);
    re::ProfilerThreadContext::pushTimeScope(v5);
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    return kdebug_trace();
  }
  return result;
}

void *re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7DB8;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7DB8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::ProfilerThreadContext::pushTimeScope(re::ProfilerThreadContext *this)
{
  if (*((void *)this + 19))
  {
    uint64_t v2 = mach_absolute_time();
    uint64_t v3 = v2;
    unint64_t v4 = *((void *)this + 17);
    uint64_t v5 = (char *)*((void *)this + 16);
    if ((unint64_t)v5 >= v4)
    {
      uint64_t v7 = (char *)*((void *)this + 15);
      uint64_t v8 = (v5 - v7) >> 3;
      unint64_t v9 = v8 + 1;
      if ((unint64_t)(v8 + 1) >> 61) {
        abort();
      }
      uint64_t v10 = v4 - (void)v7;
      if (v10 >> 2 > v9) {
        unint64_t v9 = v10 >> 2;
      }
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v11 = v9;
      }
      if (v11)
      {
        uint64_t v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)this + 136, v11);
        uint64_t v7 = (char *)*((void *)this + 15);
        uint64_t v5 = (char *)*((void *)this + 16);
      }
      else
      {
        uint64_t v12 = 0;
      }
      long long v13 = (uint64_t *)&v12[8 * v8];
      uint64_t v14 = &v12[8 * v11];
      *long long v13 = v3;
      unint64_t v6 = v13 + 1;
      while (v5 != v7)
      {
        uint64_t v15 = *((void *)v5 - 1);
        v5 -= 8;
        *--long long v13 = v15;
      }
      *((void *)this + 15) = v13;
      *((void *)this + 16) = v6;
      *((void *)this + 17) = v14;
      if (v7) {
        operator delete(v7);
      }
    }
    else
    {
      *(void *)uint64_t v5 = v2;
      unint64_t v6 = v5 + 8;
    }
    *((void *)this + 16) = v6;
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a2);
}

void re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 16);
  uint64_t v3 = (re::ProfilerConfig *)mach_absolute_time();
  **(void **)(a1 + 16) = v3;
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(v3);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v5 = re::profilerThreadContext(isStatisticCollectionEnabled);
    unint64_t v6 = *(int64x2_t **)(v5 + 152);
    if (v6)
    {
      unint64_t v7 = **(void **)(a1 + 16) - v2;
      unint64_t v8 = v6[8].u64[0];
      unint64_t v9 = v6[8].u64[1];
      if (v8 >= v7) {
        unint64_t v8 = **(void **)(a1 + 16) - v2;
      }
      if (v9 <= v7) {
        unint64_t v9 = **(void **)(a1 + 16) - v2;
      }
      v6[8].i64[0] = v8;
      v6[8].i64[1] = v9;
      int64x2_t v10 = vdupq_n_s64(1uLL);
      v10.i64[0] = v7;
      v6[9] = vaddq_s64(v6[9], v10);
      *(unsigned char *)(v5 + 184) = 0;
    }
  }
  unint64_t v11 = *(re::FrameManager **)(a1 + 8);
  return re::FrameManager::nextFrame(v11);
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7E10;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7E10;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 24;
}

int64x2_t re::ProfilerThreadContext::addStatistic(uint64_t a1, unsigned int a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 152);
  if (v3)
  {
    unint64_t v4 = (int64x2_t *)(v3 + ((unint64_t)a2 << 6));
    unint64_t v5 = v4[4].u64[0];
    unint64_t v6 = v4[4].u64[1];
    if (v5 >= a3) {
      unint64_t v5 = a3;
    }
    if (v6 <= a3) {
      unint64_t v6 = a3;
    }
    v4[4].i64[0] = v5;
    v4[4].i64[1] = v6;
    int64x2_t v7 = vdupq_n_s64(1uLL);
    v7.i64[0] = a3;
    int64x2_t result = vaddq_s64(v4[5], v7);
    v4[5] = result;
    *(unsigned char *)(a1 + 184) = 0;
  }
  return result;
}

void re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))();
}

void *re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7E68;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7E68;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::operator()()
{
  uint64_t v0 = re::internal::enableSignposts(0, 0);
  if (v0) {
    uint64_t v0 = kdebug_trace();
  }
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v0);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v2 = re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::popTimeScope(v2, 2u);
  }
  uint64_t v3 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if (v3)
  {
    unint64_t v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(v3);
    re::ProfilerThreadContext::end(v4);
  }
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7EC0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C7EC0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::size()
{
  return 24;
}

double re::ProfilerThreadContext::popTimeScope(uint64_t a1, unsigned int a2)
{
  if (*(void *)(a1 + 152))
  {
    uint64_t v4 = mach_absolute_time();
    uint64_t v5 = *(void *)(a1 + 128);
    unint64_t v6 = v4 - *(void *)(v5 - 8);
    *(void *)(a1 + 128) = v5 - 8;
    *(void *)&double result = re::ProfilerThreadContext::addStatistic(a1, a2, v6).u64[0];
  }
  return result;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, *(re::ProfilerManager **)(*((void *)a1 + 1) + 952), 1);
  }
  uint64_t v4 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if (v4)
  {
    uint64_t v5 = (re::ProfilerThreadContext *)re::profilerThreadContext(v4);
    re::ProfilerThreadContext::pushTimeScope(v5);
  }
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    return kdebug_trace();
  }
  return result;
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7F18;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7F18;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
}

double re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  *(_WORD *)(v1 + 8) = 0;
  long long v2 = *(_OWORD *)(v1 + 64);
  *(_OWORD *)(v1 + 80) = *(_OWORD *)(v1 + 48);
  *(_OWORD *)(v1 + 96) = v2;
  long long v3 = *(_OWORD *)(v1 + 32);
  *(_OWORD *)(v1 + 48) = *(_OWORD *)(v1 + 16);
  *(_OWORD *)(v1 + 64) = v3;
  *(_OWORD *)(v1 + 168) = *(_OWORD *)(v1 + 140);
  *(_OWORD *)(v1 + 180) = *(_OWORD *)(v1 + 152);
  *(_OWORD *)(v1 + 140) = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(v1 + 152) = *(_OWORD *)(v1 + 124);
  double result = 0.0;
  *(void *)(v1 + ++*(void *)(this + 112) = 0;
  *(_DWORD *)(v1 + 120) = 0;
  long long v5 = *(_OWORD *)(v1 + 216);
  *(_WORD *)(v1 + 252) = *(_WORD *)(v1 + 232);
  *(_OWORD *)(v1 + 236) = v5;
  long long v6 = *(_OWORD *)(v1 + 196);
  *(_WORD *)(v1 + 232) = *(_WORD *)(v1 + 212);
  *(_OWORD *)(v1 + 216) = v6;
  *(void *)(v1 + 196) = 0;
  return result;
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7F70;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7F70;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(uint64_t a1)
{
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7FC8;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C7FC8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::operator()(uint64_t a1, float *a2)
{
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8020;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8020;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::operator()(uint64_t a1)
{
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8078;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8078;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::operator()(uint64_t a1)
{
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C80D0;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C80D0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::~Callable()
{
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::operator()(uint64_t a1)
{
  v3[4] = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 8);
  v3[0] = &unk_26E6C9DD8;
  v3[1] = v1;
  _OWORD v3[2] = 1;
  void v3[3] = v3;
  re::runInLocalAutoreleasePool((uint64_t)v3);
  return std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v3);
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8128;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8128;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::operator()(uint64_t a1, float *a2)
{
  if (!*(unsigned char *)(*(void *)(a1 + 8) + 356))
  {
    re::AnimationManager::update(*(re::AnimationManager **)(a1 + 16), *a2);
    long long v3 = *(re::AnimationManager **)(a1 + 16);
    re::AnimationManager::applyAnimations(v3);
  }
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C8180;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C8180;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::size()
{
  return 24;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::operator()()
{
  uint64_t v0 = re::internal::enableSignposts(0, 0);
  if (v0) {
    uint64_t v0 = kdebug_trace();
  }
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v0);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v2 = re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::popTimeScope(v2, 3u);
  }
  long long v3 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if (v3)
  {
    uint64_t v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(v3);
    re::ProfilerThreadContext::end(v4);
  }
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C81D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C81D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::size()
{
  return 24;
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if (isStatisticCollectionEnabled)
  {
    long long v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, *(re::ProfilerManager **)(*((void *)a1 + 1) + 952), 1);
  }
  uint64_t v4 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if (v4)
  {
    long long v5 = (re::ProfilerThreadContext *)re::profilerThreadContext(v4);
    re::ProfilerThreadContext::pushTimeScope(v5);
  }
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    return kdebug_trace();
  }
  return result;
}

void *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8230;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8230;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 8);
  (*(void (**)(void *))(*v1[115] + 56))(v1[115]);
  uint64_t v2 = (uint64_t (*)(void **))(*v1)[6];
  return v2(v1);
}

void *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8288;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8288;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(uint64_t a1, float *a2)
{
}

void *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C82E0;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C82E0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::operator()(void *a1, float *a2)
{
  uint64_t v2 = a1[1];
  if (!*(unsigned char *)(v2 + 356))
  {
    uint64_t v3 = *(void *)(v2 + 224);
    if (v3)
    {
      float v5 = *a2;
      long long v6 = *(uint64_t **)(v2 + 240);
      int64x2_t v7 = &v6[v3];
      float v8 = 3.4028e38;
      do
      {
        uint64_t v9 = a1[2];
        uint64_t v20 = *v6;
        uint64_t v10 = re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(v9 + 432, &v20);
        if (v10)
        {
          uint64_t v11 = v10;
          re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v20, v10, 0);
          BOOL v12 = v11 == v20 && (unsigned __int16)v21 == 0xFFFFLL;
          if (!v12 || (v21 & 0xFFFF0000) != 4294901760)
          {
            do
            {
              uint64_t v14 = re::DataArray<re::ecs2::PhysicsSimulationData>::DataArrayIterator<re::ecs2::PhysicsSimulationData,re::ecs2::PhysicsSimulationData&>::operator*((unsigned __int16 *)&v20);
              uint64_t v15 = *(re::PhysicsSimulation **)(v14 + 8);
              if (v15)
              {
                re::PhysicsSimulation::update(v15, v5);
                if ((*(unsigned int (**)(void))(**(void **)(v14 + 8) + 104))(*(void *)(v14 + 8)))
                {
                  uint64_t v16 = *(void *)(v14 + 8);
                  float v17 = *(double *)(v16 + 888);
                  if ((float)(*(float *)(v16 + 68) - v17) <= v8) {
                    float v8 = *(float *)(v16 + 68) - v17;
                  }
                }
              }
              re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v20);
            }
            while (v20 != v11 || (unsigned __int16)v21 != 0xFFFF || WORD1(v21) != 0xFFFF);
          }
        }
        ++v6;
      }
      while (v6 != v7);
      if (v8 != 3.4028e38) {
        re::Scheduler::enqueueTaskWithDeadline(*(re::Scheduler **)(a1[3] + 680), *(void *)(a1[3] + 216), v8);
      }
    }
  }
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C8338;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C8338;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::size()
{
  return 32;
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::operator()()
{
  uint64_t v0 = re::internal::enableSignposts(0, 0);
  if (v0) {
    uint64_t v0 = kdebug_trace();
  }
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v0);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v2 = re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::popTimeScope(v2, 4u);
  }
  uint64_t v3 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if (v3)
  {
    uint64_t v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(v3);
    re::ProfilerThreadContext::end(v4);
  }
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C8390;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C8390;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::size()
{
  return 24;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, *(re::ProfilerManager **)(*((void *)a1 + 1) + 952), 1);
  }
  uint64_t v4 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if (v4)
  {
    float v5 = (re::ProfilerThreadContext *)re::profilerThreadContext(v4);
    re::ProfilerThreadContext::pushTimeScope(v5);
  }
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    return kdebug_trace();
  }
  return result;
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C83E8;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C83E8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable(uint64_t a1)
{
  return a1;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable(uint64_t a1)
{
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  return MEMORY[0x270F26188](*(void *)(a1 + 16));
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 16);
  *a2 = &unk_26E6C8440;
  a2[1] = v3;
  a2[2] = v4;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C8440;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 24;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 16))();
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8498;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8498;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::operator()(uint64_t a1)
{
  return re::AssetManager::afterFrameUpdate(*(re::AssetManager **)(a1 + 8));
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C84F0;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C84F0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::operator()(uint64_t a1)
{
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8548;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8548;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::operator()(uint64_t a1)
{
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C85A0;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C85A0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))();
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C85F8;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C85F8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::operator()(uint64_t a1)
{
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8650;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8650;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::operator()()
{
  uint64_t v0 = re::internal::enableSignposts(0, 0);
  if (v0) {
    uint64_t v0 = kdebug_trace();
  }
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v0);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v2 = re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::popTimeScope(v2, 5u);
  }
  uint64_t v3 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if (v3)
  {
    uint64_t v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(v3);
    re::ProfilerThreadContext::end(v4);
  }
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C86A8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C86A8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::size()
{
  return 24;
}

void re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    uint64_t v4 = (re::ProfilerManager *)*((void *)a1 + 1);
    re::ProfilerThreadContext::begin(v3, v4, 1);
  }
}

void *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8700;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8700;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
}

int64x2_t re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = (re::ProfilerConfig *)(*(uint64_t (**)(void *))(*v2[115] + 104))(v2[115]);
  if (!v3)
  {
    uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(v3);
    if (isStatisticCollectionEnabled)
    {
      uint64_t v6 = re::profilerThreadContext(isStatisticCollectionEnabled);
      if (*(void *)(v6 + 152)) {
        uint64_t v1 = mach_absolute_time();
      }
    }
    else
    {
      uint64_t v6 = 0;
    }
    if (re::internal::enableSignposts(0, 0)) {
      kdebug_trace();
    }
    re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v12, 1520, (uint64_t)v2);
    ((void (*)(void **))(*v2)[7])(v2);
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v12);
    if (v6)
    {
      if (*(void *)(v6 + 152))
      {
        uint64_t v7 = mach_absolute_time();
        float v8 = *(int64x2_t **)(v6 + 152);
        if (v8)
        {
          uint64_t v9 = v8[28].u64[0];
          uint64_t v10 = v8[28].u64[1];
          if (v9 >= v7 - v1) {
            uint64_t v9 = v7 - v1;
          }
          if (v10 <= v7 - v1) {
            uint64_t v10 = v7 - v1;
          }
          v8[28].i64[0] = v9;
          v8[28].i64[1] = v10;
          int64x2_t v11 = vdupq_n_s64(1uLL);
          v11.i64[0] = v7 - v1;
          int64x2_t result = vaddq_s64(v8[29], v11);
          v8[29] = result;
          *(unsigned char *)(v6 + 184) = 0;
        }
      }
    }
  }
  return result;
}

void *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8758;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8758;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v2 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::end(v2);
  }
}

void *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  int64x2_t result = a2;
  *a2 = &unk_26E6C87B0;
  return result;
}

void *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  int64x2_t result = a2;
  *a2 = &unk_26E6C87B0;
  return result;
}

uint64_t re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v2 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::pushTimeScope(v2);
  }
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    return kdebug_trace();
  }
  return result;
}

void *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8808;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8808;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
}

void re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
}

void *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8860;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8860;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
}

double re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()()
{
  uint64_t v0 = re::internal::enableSignposts(0, 0);
  if (v0) {
    uint64_t v0 = kdebug_trace();
  }
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v0);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v3 = re::profilerThreadContext(isStatisticCollectionEnabled);
    return re::ProfilerThreadContext::popTimeScope(v3, 7u);
  }
  return result;
}

void *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C88B8;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C88B8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, *(re::ProfilerManager **)(*((void *)a1 + 1) + 952), 1);
  }
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result)
  {
    return kdebug_trace();
  }
  return result;
}

void *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8910;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8910;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
}

re::FrameProfiler *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  uint64_t result = *(re::FrameProfiler **)(a1 + 8);
  if (*((unsigned char *)result + 204))
  {
    if (!*((unsigned char *)result + 17)) {
      return (re::FrameProfiler *)re::FrameProfiler::frameUpdateFinished(result);
    }
  }
  return result;
}

void *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8968;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8968;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(uint64_t a1)
{
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  memset(v6, 0, sizeof(v6));
  int v7 = 1065353216;
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  uint64_t v2 = re::internal::enableSignposts(0, 0);
  if (v2) {
    uint64_t v2 = kdebug_trace();
  }
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v2);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::end(v4);
  }
  re::ProfilerManager::process(*(void *)(*(void *)(a1 + 8) + 952), v6);
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)v6);
}

void *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C89C0;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C89C0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::operator()(uint64_t a1)
{
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  uint64_t v2 = re::internal::enableSignposts(0, 0);
  if (v2) {
    uint64_t v2 = kdebug_trace();
  }
  uint64_t isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v2);
  if (isStatisticCollectionEnabled)
  {
    uint64_t v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::end(v4);
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 952);
  memset(v7, 0, sizeof(v7));
  int v8 = 1065353216;
  re::ProfilerManager::process(v5, v7);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)v7);
  uint64_t result = re::internal::enableSignposts(0, 0);
  if (result) {
    return kdebug_trace();
  }
  return result;
}

void *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8A18;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8A18;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::~Callable()
{
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::operator()(uint64_t result)
{
  *(void *)(*(void *)(result + 8) + 1184) = 0xBFF0000000000000;
  return result;
}

void *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8A70;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E6C8A70;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::size()
{
  return 16;
}

uint64_t re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 8 * v4;
        do
        {
          if (*(void *)v3)
          {

            *(void *)uint64_t v3 = 0;
          }
          v3 += 8;
          v5 -= 8;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(void *)(v6 + 88 * v4 + 16) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 88 * v4 + 8) & 0x7FFFFFFF;
      if (v4 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v6 + 88 * v4 + 16) == v2) {
        return v6 + 88 * v4 + 24;
      }
    }
    return 0;
  }
  return v6 + 88 * v4 + 24;
}

void std::__shared_weak_count::__release_shared[abi:nn180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

uint64_t re::Event<re::Engine>::~Event(uint64_t a1)
{
  if (*(void *)a1) {
    re::DynamicArray<unsigned long>::deinit(a1);
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    if (*(void *)(a1 + 72)) {
      (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    }
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0;
    *(void *)(a1 + 40) = 0;
    ++*(_DWORD *)(a1 + 64);
  }
  re::DynamicArray<unsigned long>::deinit(a1);
  return a1;
}

uint64_t re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = re::internal::ServiceKeyHash::operator()((uint64_t)&v17, a2);
  unint64_t v5 = v4;
  unint64_t v6 = *(unsigned int *)(a1 + 24);
  if (!v6)
  {
    LODWORD(v7) = 0;
    goto LABEL_9;
  }
  unint64_t v7 = v4 % v6;
  uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % v6));
  if (v8 == 0x7FFFFFFF)
  {
LABEL_9:
    unsigned int v14 = re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::addAsCopy(a1, v7, v5, (uint64_t)a2, (uint64_t)a2);
    ++*(_DWORD *)(a1 + 40);
    return *(void *)(a1 + 16) + 40 * v14 + 8;
  }
  unint64_t v16 = v4 % v6;
  uint64_t v9 = *a2;
  uint64_t v10 = *(void *)(a1 + 16);
  while (1)
  {
    uint64_t v11 = v10 + 40 * v8;
    uint64_t v13 = *(void *)(v11 + 8);
    uint64_t v12 = v11 + 8;
    if (v13 == v9 && re::StringID::operator==((void *)(v12 + 8), a2 + 1)) {
      return v12;
    }
    uint64_t v8 = *(_DWORD *)(v10 + 40 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF)
    {
      LODWORD(v7) = v16;
      goto LABEL_9;
    }
  }
}

re::ServiceRegistration *re::ServiceRegistration::ServiceRegistration(re::ServiceRegistration *this, const re::IntrospectionBase *a2, StringID *a3, void *a4)
{
  re::StringID::StringID((re::StringID *)&v8, a3);
  *(void *)this = a2;
  re::StringID::StringID((re::ServiceRegistration *)((char *)this + 8), &v8);
  re::StringID::destroyString((re::StringID *)&v8);
  *((void *)this + 3) = a4;
  return this;
}

uint64_t re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(unsigned int *)(a1 + 36);
  if (v8 == 0x7FFFFFFF)
  {
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    int v9 = v8;
    if (v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 40 * v8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 40 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  uint64_t v13 = 40 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v13) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  unsigned int v14 = (void *)(*(void *)(a1 + 16) + 40 * v8);
  v14[1] = *(void *)a5;
  re::StringID::StringID((re::StringID *)(v14 + 2), (const StringID *)(a5 + 8));
  v14[4] = *(void *)(a5 + 24);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

uint64_t re::internal::ServiceKeyHash::operator()(uint64_t a1, void *a2)
{
  unint64_t v2 = 0xBF58476D1CE4E5B9 * (*a2 ^ (*a2 >> 30));
  unint64_t v3 = (0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31);
  unint64_t v4 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * ((a2[1] >> 31) ^ (a2[1] >> 1))) ^ ((0xBF58476D1CE4E5B9 * ((a2[1] >> 31) ^ (a2[1] >> 1))) >> 27));
  return ((v4 ^ (v4 >> 31)) + (v3 << 6) + (v3 >> 2) - 0x61C8864680B583E9) ^ v3;
}

void re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v14, 0, 36);
      *(void *)&v14[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::init((uint64_t)v14, v4, a2);
      long long v5 = *(_OWORD *)v14;
      *(_OWORD *)unsigned int v14 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v14[16];
      *(void *)&unsigned char v14[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v14[24];
      *(_OWORD *)&unsigned char v14[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v14[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v14[16] + v10) & 0x80000000) != 0)
          {
            unint64_t v12 = re::internal::ServiceKeyHash::operator()((uint64_t)&v15, (void *)(*(void *)&v14[16] + v10 + 8));
            re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::addAsMove(a1, v12 % *(unsigned int *)(a1 + 24), v12, *(void *)&v14[16] + v10 + 8, (void *)(*(void *)&v14[16] + v10 + 8));
            unsigned int v9 = *(_DWORD *)&v14[32];
          }
          ++v11;
          v10 += 40;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit((uint64_t *)v14);
    }
  }
  else
  {
    if (a2) {
      signed int v13 = a2;
    }
    else {
      signed int v13 = 3;
    }
  }
}

void re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unsigned int v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    long long v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  unint64_t v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    unsigned int v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 601);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v7 = *(unsigned int *)(a1 + 36);
  if (v7 == 0x7FFFFFFF)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 32);
    int v8 = v7;
    if (v7 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 40 * v7);
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v11 = *(_DWORD *)(v10 + 40 * v7);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  uint64_t v12 = 40 * v7;
  *(_DWORD *)(v10 + v12) = v11 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v12) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v7) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  uint64_t v13 = (void *)(*(void *)(a1 + 16) + 40 * v7);
  v13[1] = *a5;
  uint64_t v14 = a5[1];
  _OWORD v13[2] = v13[2] & 0xFFFFFFFFFFFFFFFELL | v14 & 1;
  _OWORD v13[2] = a5[1] & 0xFFFFFFFFFFFFFFFELL | v14 & 1;
  uint64_t v15 = a5[3];
  v13[3] = a5[2];
  a5[1] = 0;
  a5[2] = "";
  v13[4] = v15;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v7;
  ++*(_DWORD *)(a1 + 28);
  return v7;
}

double re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2];
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v6 + v4 + 16));
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 40;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::make::shared::object<re::EventBus>(re *a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = re::globalAllocators(a1);
  uint64_t v4 = (re::EventBus *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 200, 8);
  re::EventBus::EventBus(v4);
  *a2 = v5;
}

uint64_t *re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFuncs(void *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 28);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
  (*(void (**)(void *))(*a1 + 64))(a1);
  uint64_t v3 = a1[26];
  double result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3) {
    BOOL v5 = result == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = *result;
    uint64_t v7 = a1[26];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      int v8 = (uint64_t *)(v15 + 40);
      uint64_t v9 = 48 * v14;
      do
      {
        uint64_t v10 = *(v8 - 2);
        uint64_t v11 = *v8;
        v8 += 6;
        uint64_t v17 = v11;
        unint64_t v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    double result = v13;
    if (v13)
    {
      if (v15) {
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
      }
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFuncs(void *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 28);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
  (*(void (**)(void *))(*a1 + 64))(a1);
  uint64_t v3 = a1[26];
  double result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3) {
    BOOL v5 = result == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = *result;
    uint64_t v7 = a1[26];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      int v8 = (uint64_t *)(v15 + 40);
      uint64_t v9 = 48 * v14;
      do
      {
        uint64_t v10 = *(v8 - 2);
        uint64_t v11 = *v8;
        v8 += 6;
        uint64_t v17 = v11;
        unint64_t v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    double result = v13;
    if (v13)
    {
      if (v15) {
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
      }
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFuncs(void *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 26);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
  (*(void (**)(void *))(*a1 + 64))(a1);
  uint64_t v3 = a1[24];
  double result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3) {
    BOOL v5 = result == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = *result;
    uint64_t v7 = a1[24];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      int v8 = (uint64_t *)(v15 + 40);
      uint64_t v9 = 48 * v14;
      do
      {
        uint64_t v10 = *(v8 - 2);
        uint64_t v11 = *v8;
        v8 += 6;
        uint64_t v17 = v11;
        unint64_t v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    double result = v13;
    if (v13)
    {
      if (v15) {
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
      }
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFuncs(void *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 26);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
  (*(void (**)(void *))(*a1 + 64))(a1);
  uint64_t v3 = a1[24];
  double result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3) {
    BOOL v5 = result == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = *result;
    uint64_t v7 = a1[24];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      int v8 = (uint64_t *)(v15 + 40);
      uint64_t v9 = 48 * v14;
      do
      {
        uint64_t v10 = *(v8 - 2);
        uint64_t v11 = *v8;
        v8 += 6;
        uint64_t v17 = v11;
        unint64_t v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    double result = v13;
    if (v13)
    {
      if (v15) {
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::ProfilerManager::getProcessorId<re::FrameProfiler>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::ProfilerManager::getProcessorId<re::FrameProfiler>(void)::processoruint64_t Id = atomic_fetch_add(&re::ProfilerManager::s_nextProcessorId, 1uLL)+ 1;
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[428];
}

void std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      unint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  BOOL v5 = operator new(8 * prime);
  uint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  int v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    uint64_t v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          void *v8 = *v14;
          *uint64_t v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          uint64_t v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        int v8 = v14;
        uint64_t v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

uint64_t re::ProfilerManager::getProcessorId<re::ProfilerFlameChartProcessor>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::ProfilerManager::getProcessorId<re::ProfilerFlameChartProcessor>(void)::processoruint64_t Id = atomic_fetch_add(&re::ProfilerManager::s_nextProcessorId, 1uLL)+ 1;
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[424];
}

uint64_t re::ProfilerManager::getProcessorId<re::ProfilerMiniHUDProcessor>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::ProfilerManager::getProcessorId<re::ProfilerMiniHUDProcessor>(void)::processoruint64_t Id = atomic_fetch_add(&re::ProfilerManager::s_nextProcessorId, 1uLL)+ 1;
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[422];
}

uint64_t re::ProfilerManager::getProcessorId<re::ProfilerDetailedHUDProcessor>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::ProfilerManager::getProcessorId<re::ProfilerDetailedHUDProcessor>(void)::processoruint64_t Id = atomic_fetch_add(&re::ProfilerManager::s_nextProcessorId, 1uLL)+ 1;
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[426];
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  uint64_t v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  double result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }
        else
        {
          v8 &= *(void *)&v2 - 1;
        }
        if (v8 != v5) {
          return 0;
        }
      }
      double result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t re::ProfilerManager::getProcessorId<re::ProfilerLogProcessor>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::ProfilerManager::getProcessorId<re::ProfilerLogProcessor>(void)::processoruint64_t Id = atomic_fetch_add(&re::ProfilerManager::s_nextProcessorId, 1uLL)+ 1;
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[303];
}

uint64_t re::ProfilerManager::getProcessorId<re::ProfilerCsvProcessor>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::ProfilerManager::getProcessorId<re::ProfilerCsvProcessor>(void)::processoruint64_t Id = atomic_fetch_add(&re::ProfilerManager::s_nextProcessorId, 1uLL)+ 1;
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[305];
}

void re::ecs2::System::System(uint64_t a1, char a2)
{
  *(void *)a1 = &unk_26E70C0C0;
  *(void *)(a1 + 24) = -1;
  *(void *)(a1 + 32) = -1;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = a2;
  *(_WORD *)(a1 + 52) = 260;
  *(_DWORD *)(a1 + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 1023969417;
  *(unsigned char *)(a1 + 60) = 0;
  *(unsigned char *)(a1 + 64) = 1;
  *(unsigned char *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 84) = 0;
  *(unsigned char *)(a1 + 86) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = -1;
}

re::ecs2::DrawableQueueSyncSystem *re::ecs2::DrawableQueueSyncSystem::DrawableQueueSyncSystem(re::ecs2::DrawableQueueSyncSystem *this)
{
  re::ecs2::System::System((uint64_t)this, 1, 1);
  *(void *)(v2 + 152) = 0;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_OWORD *)(v2 + 104) = 0u;
  *(void *)uint64_t v2 = &unk_26E700698;
  uint64_t v3 = v2 + 176;
  *(void *)(v2 + 176) = &unk_26E700630;
  *(void *)(v2 + 192) = 0;
  *(void *)(v2 + 184) = 0;
  uint64_t v4 = v2 + 184;
  *(_DWORD *)(v2 + 200) = 1;
  *(void *)(v2 + 216) = 0;
  *(void *)(v2 + 224) = 0;
  *(void *)(v2 + 208) = 0;
  *(_DWORD *)(v2 + 232) = 0;
  unint64_t v5 = (void *)(v2 + 304);
  *(_OWORD *)(v2 + 2re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0u;
  *(_OWORD *)(v2 + 272) = 0u;
  *(_OWORD *)(v2 + 288) = 0u;
  *(_OWORD *)(v2 + 304) = 0u;
  *(_OWORD *)(v2 + 240) = 0u;
  uint64_t v6 = (void *)(v2 + 240);
  *(_DWORD *)(v2 + 320) = 1;
  uint64_t v7 = (void *)(v2 + 352);
  *(_OWORD *)(v2 + 328) = 0u;
  *(_OWORD *)(v2 + 344) = 0u;
  *(void *)(v2 + 360) = 0;
  *(_DWORD *)(v2 + 368) = 1;
  *(_OWORD *)(v2 + 376) = 0u;
  *(_OWORD *)(v2 + 392) = 0u;
  *(_OWORD *)(v2 + 401) = 0u;
  uint8x8_t v10 = (_anonymous_namespace_ *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v5, 0);
  *((_DWORD *)this + 80) += 2;
  *((void *)this + 43) = 0;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v7, 0);
  *((_DWORD *)this + 92) += 2;
  *((void *)this + 49) = 0;
  *((void *)this + 50) = this;
  *((void *)this + 51) = v3;
  *((unsigned char *)this + 416) = 1;
  LOWORD(v12) = 257;
  HIDWORD(v12) = 1023969417;
  char v13 = 0;
  re::ecs2::System::setTaskOptions(this, &v12);
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *((void *)this + 57) = 0x7FFFFFFF00000000;
  *((_DWORD *)this + 116) = 0;
  return this;
}

void re::ecs2::System::System(uint64_t a1, char a2, char a3)
{
  *(void *)a1 = &unk_26E70C0C0;
  *(void *)(a1 + 24) = -1;
  *(void *)(a1 + 32) = -1;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = a3;
  *(_WORD *)(a1 + 52) = 260;
  *(_DWORD *)(a1 + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 1023969417;
  *(unsigned char *)(a1 + 60) = 0;
  *(unsigned char *)(a1 + 64) = 1;
  *(unsigned char *)(a1 + 68) = 0;
  *(unsigned char *)(a1 + 84) = a2;
  *(_WORD *)(a1 + 85) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = -1;
}

uint64_t re::BucketArray<re::ecs2::BasicComponentStateSceneData<re::ecs2::DrawableQueueSyncComponent>,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  uint64_t result = re::BucketArray<re::ecs2::BasicComponentStateSceneData<re::ecs2::DrawableQueueSyncComponent>,4ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::HashBrown<re::ecs2::Scene const*,unsigned long,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,void,false>::init(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  result[7] = a2;
  unint64_t v4 = 151 * a3;
  unint64_t v5 = ((unint64_t)(151 * a3) >> 7) + 15;
  result[2] = v5 & 0x3FFFFFFFFFFFFF0;
  if ((v5 & 0x3FFFFFFFFFFFFF0) != 0)
  {
    unint64_t v6 = v5 >> 4;
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 17 * (v5 & 0x3FFFFFFFFFFFFF0), 16);
    *uint64_t v3 = result;
    if (v4 >= 0x80)
    {
      uint64_t v7 = 0;
      *(void *)&long long v8 = -1;
      *((void *)&v8 + 1) = -1;
      do
        *(_OWORD *)(*v3 + 16 * v7++) = v8;
      while (v6 != v7);
      uint64_t result = (void *)*v3;
    }
    v3[1] = &result[2 * v6];
    unint64_t v9 = v3[2];
    if (v9)
    {
      uint64_t v10 = 0;
      for (unint64_t i = 0; i < v9; ++i)
      {
        uint64_t v12 = (void *)(v3[1] + v10);
        *uint64_t v12 = 0;
        v12[1] = 0;
        unint64_t v9 = v3[2];
        v10 += 16;
      }
    }
  }
  else
  {
    unint64_t v9 = 0;
    *uint64_t result = 0;
    result[1] = 0;
  }
  void v3[5] = 0;
  v3[6] = 0;
  void v3[3] = 0;
  v3[4] = v9;
  return result;
}

uint64_t *re::BucketArray<re::ecs2::BasicComponentStateSceneData<re::ecs2::DrawableQueueSyncComponent>,4ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        uint64_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 448, 0);
        uint64_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::introspect<re::SimulationClock>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::introspect<re::SimulationClock>(void)::info = re::introspect_SimulationClock(0);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[355];
}

double re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::addSubscription(_anonymous_namespace_ *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf((uint64_t)a1, (void *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (*((_DWORD *)a1 + 20))
    {
      v6[0] = 1;
      long long v5 = *(_OWORD *)(a2 + 16);
      long long v7 = *(_OWORD *)a2;
      long long v8 = v5;
      *(void *)&double result = re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::add((uint64_t)a1 + 40, (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(void *)&double result = re::DynamicArray<re::EvaluationRegister>::add(a1, a2).n128_u64[0];
    }
  }
  return result;
}

__n128 re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t v11 = *(void *)(a1 + 32) + 40 * v5;
  __n128 result = *(__n128 *)a2;
  long long v13 = *(_OWORD *)(a2 + 16);
  *(void *)(v11 + 32) = *(void *)(a2 + 32);
  *(__n128 *)uint64_t v11 = result;
  *(_OWORD *)(v11 + 16) = v13;
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf@<X0>(uint64_t result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(void *)(result + 32);
  uint64_t v4 = *(void *)(result + 16);
  if (v4)
  {
    uint64_t v5 = 32 * v4;
    unint64_t v6 = *(void **)(result + 32);
    while (1)
    {
      if (*v6 == *a2)
      {
        __n128 result = a2[2];
        if (v6[1] == a2[1] && v6[2] == result) {
          break;
        }
      }
      v6 += 4;
      v5 -= 32;
      if (!v5)
      {
        unint64_t v6 = (void *)(v3 + 32 * v4);
        break;
      }
    }
  }
  else
  {
    unint64_t v6 = *(void **)(result + 32);
  }
  uint64_t v8 = ((uint64_t)v6 - v3) >> 5;
  if (v8 == v4)
  {
    char v9 = 0;
  }
  else
  {
    *(void *)(a3 + 8) = v8;
    char v9 = 1;
  }
  *(unsigned char *)a3 = v9;
  return result;
}

void *re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x28uLL))
        {
          uint64_t v2 = 40 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 40 * v5[2]);
            __n128 result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        __n128 result = (void *)re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::createSubscription<re::Engine>(re::Engine *,REEventHandlerResult (re::Engine::*)(re::SimulationTimer*,re::SimulationTimerEventArgs const&))::{lambda(re::SimulationTimer*,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription const&,re::SimulationTimerEventArgs const&)#1}::__invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t (*)(void *, uint64_t))a2[1];
  uint64_t v4 = a2[2];
  uint64_t v5 = (void *)(*a2 + (v4 >> 1));
  if (v4) {
    uint64_t v3 = *(uint64_t (**)(void *, uint64_t))(*v5 + v3);
  }
  return v3(v5, a1);
}

double re::ecs2::ThrottleManager::ThrottleManager(re::ecs2::ThrottleManager *this)
{
  ArcSharedObject::ArcSharedObject(this, 0);
  *(void *)this = &unk_26E70B840;
  double result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 52) = 0u;
  *(void *)((char *)this + 68) = 0x7FFFFFFFLL;
  *((_DWORD *)this + 29) = 0;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 16) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_WORD *)this + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0;
  return result;
}

uint64_t re::ProfilerManager::getProcessorId<re::FrameAnalysisProfilerProcessor>()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74BF8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF74BF8))
  {
    qword_26AF74BF0 = atomic_fetch_add(&re::ProfilerManager::s_nextProcessorId, 1uLL) + 1;
    __cxa_guard_release(&qword_26AF74BF8);
  }
  return qword_26AF74BF0;
}

void re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::removeSubscription(uint64_t a1, long long *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf(a1, a2, (uint64_t)v5);
  if (v5[0])
  {
    if (*(_DWORD *)(a1 + 80))
    {
      v5[0] = 0;
      long long v4 = a2[1];
      long long v6 = *a2;
      long long v7 = v4;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::add(a1 + 40, (uint64_t)v5);
    }
    else
    {
      re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStable((void *)a1, a2);
    }
  }
}

BOOL re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStable(void *a1, void *a2)
{
  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf((uint64_t)a1, a2, (uint64_t)v5);
  int v3 = v5[0];
  if (v5[0]) {
    re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt(a1, v6);
  }
  return v3 != 0;
}

void *re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt(void *result, unint64_t a2)
{
  unint64_t v2 = result[2];
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  int v3 = result;
  uint64_t v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    uint64_t v5 = result[4];
    double result = (void *)(v5 + 32 * a2);
    unint64_t v6 = (char *)(v5 + 32 * v2);
    if (v6 != (char *)(result + 4))
    {
      double result = memmove(result, result + 4, v6 - (char *)(result + 4));
      uint64_t v4 = v3[2] - 1;
    }
  }
  _OWORD v3[2] = v4;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = re::internal::ServiceKeyHash::operator()((uint64_t)&v23, a2);
  unint64_t v5 = *(unsigned int *)(a1 + 24);
  if (!v5) {
    return 0;
  }
  unint64_t v6 = v4 % v5;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(v7 + 4 * (v4 % v5));
  if (v8 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v11 = *a2;
  char v9 = a2 + 1;
  uint64_t v10 = v11;
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v13 = 0x7FFFFFFFLL;
  while (1)
  {
    uint64_t v14 = v12 + 40 * v8;
    uint64_t v16 = *(void *)(v14 + 8);
    uint64_t v15 = v14 + 8;
    if (v16 == v10 && re::StringID::operator==((void *)(v15 + 8), v9)) {
      break;
    }
    uint64_t v13 = v8;
    uint64_t v8 = *(_DWORD *)(v12 + 40 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      return 0;
    }
  }
  int v18 = *(_DWORD *)(v12 + 40 * v8) & 0x7FFFFFFF;
  if (v13 == 0x7FFFFFFF) {
    *(_DWORD *)(v7 + 4 * v6) = v18;
  }
  else {
    *(_DWORD *)(v12 + 40 * v13) = *(_DWORD *)(v12 + 40 * v13) & 0x80000000 | v18;
  }
  uint64_t v19 = *(void *)(a1 + 16);
  uint64_t v20 = (int *)(v19 + 40 * v8);
  int v21 = *v20;
  if (*v20 < 0)
  {
    *uint64_t v20 = v21 & 0x7FFFFFFF;
    re::StringID::destroyString((re::StringID *)(v19 + 40 * v8 + 16));
    uint64_t v19 = *(void *)(a1 + 16);
    int v21 = *(_DWORD *)(v19 + 40 * v8);
  }
  int v22 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v19 + 40 * v8) = *(_DWORD *)(a1 + 36) | v21 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v8;
  *(_DWORD *)(a1 + 40) = v22 + 1;
  return 1;
}

double re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::FunctionBase<24ul,void ()(void)>::destroyCallable(v6 + 24);
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 64;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::ecs2::EntityHandle::reset((re::ecs2::EntityHandle *)(v6 + 24));
          objc_destroyWeak((id *)(v6 + 24));
          *(void *)(v6 + 24) = 0;
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 48;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::DynamicArray<unsigned long>::deinit(v6 + 24);
          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 64;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::SharedPtr<re::ecs2::Entity>,re::ecs2::RemoteEffectHoverData,re::Hash<re::SharedPtr<re::ecs2::Entity>>,re::EqualTo<re::SharedPtr<re::ecs2::Entity>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          uint64_t v8 = *(void *)(v6 + 16);
          if (v8)
          {

            *(void *)(v6 + 16) = 0;
            unint64_t v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 1536;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void *re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    unint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = result[2];
      uint64_t v5 = 72 * v2;
      do
      {
        re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v4);
        v4 += 72;
        v5 -= 72;
      }
      while (v5);
      double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *unint64_t v3 = 0;
      v3[1] = 0;
    }
    *uint64_t v1 = 0;
  }
  return result;
}

void *re::FixedArray<re::Function<void ()(float)>>::deinit(void *result)
{
  if (*result)
  {
    uint64_t v1 = result;
    unint64_t v3 = result + 1;
    uint64_t v2 = result[1];
    if (v2)
    {
      uint64_t v4 = result[2];
      uint64_t v5 = 40 * v2;
      do
      {
        re::FunctionBase<24ul,void ()(float)>::destroyCallable(v4);
        v4 += 40;
        v5 -= 40;
      }
      while (v5);
      double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v1 + 40))(*v1, v1[2]);
      *unint64_t v3 = 0;
      v3[1] = 0;
    }
    *uint64_t v1 = 0;
  }
  return result;
}

uint64_t re::EventBus::getTypeId<REEngineDoUpdateEvent>()
{
  uint64_t v0 = &qword_268772000;
  {
    uint64_t v0 = &qword_268772000;
    if (v2)
    {
      re::EventBus::getTypeId<REEngineDoUpdateEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"21REEngineDoUpdateEvent" & 0x7FFFFFFFFFFFFFFFLL), v3);
      uint64_t v0 = &qword_268772000;
    }
  }
  return v0[361];
}

void std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::~__func()
{
}

__n128 std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x18uLL);
  *(void *)int v2 = &unk_26E6C8AC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C8AC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(char **)(a2 + 8);
  *(void *)&v7.var0 = *(void *)a2;
  v7.var1 = v4;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = "";
  *(_OWORD *)uint64_t v8 = *(_OWORD *)(a2 + 16);
  *(void *)&v8[13] = *(void *)(a2 + 29);
  v9[3] = *(void *)(a2 + 64);
  unsigned char v9[4] = 0;
  re::FunctionBase<24ul,void ()(float)>::operator=<24ul>((uint64_t)v9, a2 + 40);
  uint64_t v5 = *(void *)(a2 + 88);
  v9[5] = *(void *)(a2 + 80);
  uint64_t v10 = v5;
  long long v11 = *(_OWORD *)(a2 + 96);
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  uint64_t v13 = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = 0;
  ++*(_DWORD *)(a2 + 112);
  int v12 = 1;
  uint64_t v6 = *(void *)(a1 + 8);
  *(void *)(v6 + 120) = re::Scheduler::ScheduleDescriptor::addTask(*(void *)(a1 + 16), &v7);
  if (v10)
  {
    if (v13) {
      (*(void (**)(void))(*(void *)v10 + 40))();
    }
    uint64_t v13 = 0;
    long long v11 = 0uLL;
    uint64_t v10 = 0;
    ++v12;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)v9);
  re::StringID::destroyString((re::StringID *)&v7);
}

uint64_t std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::target_type()
{
}

uint64_t re::Scheduler::ScheduleDescriptor::addTask(uint64_t a1, StringID *a2)
{
  if (a2[4].var1)
  {
    unint64_t v4 = *(void *)(a1 + 56);
    if (v4 >= *(void *)(a1 + 48))
    {
      re::DynamicArray<re::Scheduler::TaskDescriptor>::growCapacity((void *)(a1 + 40), v4 + 1);
      unint64_t v4 = *(void *)(a1 + 56);
    }
    uint64_t v5 = *(void *)(a1 + 72) + (v4 << 7);
    re::StringID::StringID((re::StringID *)v5, a2);
    StringID v6 = a2[1];
    *(void *)(v5 + 29) = *(char **)((char *)&a2[1].var1 + 5);
    *(StringID *)(v5 + 16) = v6;
    *(void *)(v5 + 64) = *(void *)&a2[4].var0;
    *(void *)(v5 + 72) = 0;
    re::FunctionBase<24ul,void ()(float)>::operator=<24ul>(v5 + 40, (uint64_t)&a2[2].var1);
    *(void *)(v5 + 80) = *(void *)&a2[5].var0;
    re::DynamicArray<unsigned long>::DynamicArray(v5 + 88, (uint64_t *)&a2[5].var1);
    uint64_t result = *(void *)(a1 + 56);
    *(void *)(a1 + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = result + 1;
    ++*(_DWORD *)(a1 + 64);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Task Descriptor does not contain an update function", "taskDescriptor.taskFunction", "addTask", 141);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

void *std::__function::__value_func<void ()(re::Scheduler::TaskDescriptor)>::~__value_func[abi:nn180100](void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

re::EventBus::EventInfo *re::EventBus::subscriptionCountInternal<re::Engine,REEngineDoUpdateEvent>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t result = (re::EventBus::EventInfo *)re::EventBus::getEventInfo<REEngineDoUpdateEvent>(a1);
  if (result)
  {
    uint64_t result = (re::EventBus::EventInfo *)re::EventBus::EventInfo::getSubscriptions(result, a2, a3);
    if (result) {
      return (re::EventBus::EventInfo *)*((void *)result + 15);
    }
  }
  return result;
}

uint64_t re::EventBus::getEventInfo<REEngineDoUpdateEvent>(uint64_t a1)
{
  uint64_t Type = re::EventBus::getTypeId<REEngineDoUpdateEvent>();
  uint64_t v2 = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find((void *)(a1 + 24), &Type);
  if (v2 == -1) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 32) + 48 * v2 + 8);
  }
}

uint64_t re::EventBus::EventInfo::getSubscriptions(re::EventBus::EventInfo *this, unint64_t a2, unint64_t a3)
{
  if (!(a2 | a3)) {
    return (uint64_t)this + 88;
  }
  v6[0] = a2;
  v6[1] = a3;
  uint64_t v4 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, v6);
  if (v4 == -1) {
    return 0;
  }
  else {
    return *((void *)this + 28) + 144 * v4 + 16;
  }
}

void std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::~__func()
{
}

__n128 std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26E6C8B58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E6C8B58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(char **)(a2 + 8);
  *(void *)&v7.var0 = *(void *)a2;
  v7.var1 = v4;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = "";
  *(_OWORD *)uint64_t v8 = *(_OWORD *)(a2 + 16);
  *(void *)&v8[13] = *(void *)(a2 + 29);
  v9[3] = *(void *)(a2 + 64);
  unsigned char v9[4] = 0;
  re::FunctionBase<24ul,void ()(float)>::operator=<24ul>((uint64_t)v9, a2 + 40);
  uint64_t v5 = *(void *)(a2 + 88);
  v9[5] = *(void *)(a2 + 80);
  uint64_t v10 = v5;
  long long v11 = *(_OWORD *)(a2 + 96);
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  uint64_t v13 = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = 0;
  ++*(_DWORD *)(a2 + 112);
  int v12 = 1;
  uint64_t v6 = *(void *)(a1 + 8);
  *(void *)(v6 + 264) = re::Scheduler::ScheduleDescriptor::addTask(*(void *)(a1 + 16), &v7);
  if (v10)
  {
    if (v13) {
      (*(void (**)(void))(*(void *)v10 + 40))();
    }
    uint64_t v13 = 0;
    long long v11 = 0uLL;
    uint64_t v10 = 0;
    ++v12;
  }
  re::FunctionBase<24ul,void ()(float)>::destroyCallable((uint64_t)v9);
  re::StringID::destroyString((re::StringID *)&v7);
}

uint64_t std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::target_type()
{
}

_anonymous_namespace_ *re::DynamicOverflowArray<unsigned long long,5ul>::resize(_anonymous_namespace_ *result, unint64_t a2, void *a3)
{
  uint64_t v4 = result;
  unint64_t v5 = *((void *)result + 1);
  if (v5 >= a2)
  {
    if (v5 <= a2) {
      return result;
    }
  }
  else
  {
    __n128 result = re::DynamicOverflowArray<unsigned long long,5ul>::reserve(result, a2);
    unint64_t v7 = *((void *)v4 + 1);
    if (v7 < a2)
    {
      do
      {
        uint64_t v8 = (char *)v4 + 24;
        if ((*((unsigned char *)v4 + 16) & 1) == 0) {
          uint64_t v8 = (char *)*((void *)v4 + 4);
        }
        *(void *)&v8[8 * v7++] = *a3;
      }
      while (a2 != v7);
    }
  }
  *((void *)v4 + 1) = a2;
  *((_DWORD *)v4 + 4) += 2;
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<unsigned long long,5ul>::reserve(_anonymous_namespace_ *result, unint64_t a2)
{
  unint64_t v3 = result;
  if (*(void *)result)
  {
    if ((*((_DWORD *)result + 4) & 1) == 0)
    {
LABEL_3:
      unint64_t v4 = *((void *)v3 + 3);
      goto LABEL_6;
    }
  }
  else
  {
    __n128 result = (_anonymous_namespace_ *)re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity(v3, a2);
    int v5 = *((_DWORD *)v3 + 4) + 2;
    *((_DWORD *)v3 + 4) = v5;
    if ((v5 & 1) == 0) {
      goto LABEL_3;
    }
  }
  unint64_t v4 = 5;
LABEL_6:
  if (v4 < a2)
  {
    return (_anonymous_namespace_ *)re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity(v3, a2);
  }
  return result;
}

void *re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity(void *result, unint64_t a2)
{
  unint64_t v4 = result;
  uint64_t v5 = *result;
  if (a2 && !v5)
  {
    __n128 result = (void *)re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity(v4, a2);
    int v6 = *((_DWORD *)v4 + 4) + 2;
LABEL_4:
    *((_DWORD *)v4 + 4) = v6;
    return result;
  }
  int v7 = *((_DWORD *)result + 4);
  if (v7) {
    uint64_t v8 = 5;
  }
  else {
    uint64_t v8 = result[3];
  }
  if (v8 != a2)
  {
    unint64_t v9 = result[1];
    if (v9 <= a2 && (a2 > 5 || (v7 & 1) == 0))
    {
      if (a2 < 6)
      {
        uint64_t v14 = result + 3;
        uint64_t v15 = v4[4];
        if (v7) {
          uint64_t v16 = v4 + 3;
        }
        else {
          uint64_t v16 = (const void *)v4[4];
        }
        memcpy(v14, v16, 8 * v9);
        __n128 result = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 40))(v5, v15);
        int v6 = *((_DWORD *)v4 + 4) | 1;
        goto LABEL_4;
      }
      if (a2 >> 61)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 646, 8, a2);
        _os_crash();
        __break(1u);
      }
      else
      {
        uint64_t v2 = 8 * a2;
        uint64_t v10 = (void *)(*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)v5 + 32))(*result, 8 * a2, 8);
        if (v10)
        {
          int v12 = v10;
          if (v4[2]) {
            uint64_t v13 = v4 + 3;
          }
          else {
            uint64_t v13 = (const void *)v4[4];
          }
          __n128 result = memcpy(v10, v13, 8 * v4[1]);
          int v17 = *((_DWORD *)v4 + 4);
          if ((v17 & 1) == 0)
          {
            __n128 result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v4 + 40))(*v4, v4[4]);
            int v17 = *((_DWORD *)v4 + 4);
          }
          *((_DWORD *)v4 + 4) = v17 & 0xFFFFFFFE;
          v4[3] = a2;
          v4[4] = v12;
          return result;
        }
      }
      re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, v2, *(void *)(*v4 + 8));
      __n128 result = (void *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

id re::internal::defaultRetain<re::Engine>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::Engine>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
}

void re::NetworkAssetManager::init(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 16) = a2;
  if (a2)
  {
    *(void *)&long long v20 = a1;
    *((void *)&v20 + 1) = re::NetworkAssetManager::onComponentUpdated;
    *(void *)&long long v21 = 0;
    *((void *)&v21 + 1) = re::Event<re::NetworkSystem,re::ecs2::Component *>::createSubscription<re::NetworkAssetManager>(re::NetworkAssetManager *,REEventHandlerResult (re::NetworkAssetManager::*)(re::NetworkSystem*,re::ecs2::Component *))::{lambda(re::NetworkSystem*,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription const&,re::ecs2::Component *&&)#1}::__invoke;
    re::Event<re::NetworkSystem,re::ecs2::Component *>::addSubscription((_DWORD *)(a2 + 352), (uint64_t)&v20);
  }
  *(void *)(a1 + 8) = a3;
  *(unsigned char *)(a1 + 216) = a4;
  re::Bundle::application(&v18);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104))(a1);
  re::Bundle::ID(&v18, (re::DynamicString *)&v13);
  if (v14) {
    uint64_t v8 = *(unsigned char **)&v15[7];
  }
  else {
    uint64_t v8 = v15;
  }
  re::DynamicString::format((re::DynamicString *)"RootAssetEntity-%llu-%s", (re::DynamicString *)&v20, v7, v8);
  re::StringID::StringID((re::StringID *)&v16, (const re::DynamicString *)&v20);
  uint64_t v9 = v16;
  uint64_t v10 = v17;
  uint64_t v16 = 0;
  int v17 = "";
  uint64_t v11 = *(void *)(a1 + 200);
  uint64_t v12 = *(void *)(a1 + 208);
  *(void *)(a1 + 200) = v9;
  *(void *)(a1 + 208) = v10;
  v19[0] = v9 & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
  v19[1] = v12;
  re::StringID::destroyString((re::StringID *)v19);
  re::StringID::destroyString((re::StringID *)&v16);
  if ((void)v20)
  {
    if (BYTE8(v20)) {
      (*(void (**)(void))(*(void *)v20 + 40))();
    }
    long long v20 = 0u;
    long long v21 = 0u;
  }
  if (v13 && (v14 & 1) != 0) {
    (*(void (**)(void))(*(void *)v13 + 40))();
  }
}

uint64_t re::NetworkAssetManager::onComponentUpdated(re::NetworkAssetManager *this, re::NetworkSystem *a2, re::ecs2::Component *a3)
{
  uint64_t v5 = (*(uint64_t (**)(re::ecs2::Component *, re::NetworkSystem *))(*(void *)a3 + 40))(a3, a2);
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5);
  uint64_t v8 = &qword_268772000;
  do
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)v7, memory_order_acquire) & 1) == 0)
    {
      uint64_t v12 = v7;
      uint64_t v31 = v6;
      int v13 = __cxa_guard_acquire(v7);
      uint64_t v8 = &qword_268772000;
      int v14 = v13;
      uint64_t v6 = v31;
      uint64_t v7 = v12;
      if (v14)
      {
        re::introspect<re::ecs2::NetworkAssetComponent>(void)::info = (_UNKNOWN *)re::ecs2::introspect_NetworkAssetComponent(0);
        __cxa_guard_release(v12);
        uint64_t v8 = &qword_268772000;
        uint64_t v6 = v31;
        uint64_t v7 = v12;
      }
    }
    if (v6 == v8[436])
    {
      unint64_t v25 = *((void *)a3 + 4);
      if (!re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)this + 32, v25))(*(void (**)(re::NetworkAssetManager *, unint64_t, char *, void))(*(void *)this + 136))(this, v25, (char *)a3 + 72, *((void *)a3 + 2)); {
      uint64_t v26 = (*(uint64_t (**)(void))(**((void **)this + 1) + 32))(*((void *)this + 1));
      }
      uint64_t v27 = *(void *)re::ServiceLocator::serviceOrNull<re::AssetService>(v26);
      (*(void (**)(void))(v27 + 368))();
      return 0;
    }
    uint64_t v9 = *(unsigned int *)(v6 + 56);
    if (!v9) {
      break;
    }
    uint64_t v10 = *(void **)(v6 + 64);
    while (1)
    {
      uint64_t v11 = (_DWORD *)*v10;
      if (*(_DWORD *)*v10 == 1 && v11[10] == 3) {
        break;
      }
      ++v10;
      if (!--v9) {
        goto LABEL_14;
      }
    }
    uint64_t v6 = *((void *)v11 + 2);
  }
  while (v6);
LABEL_14:
  uint64_t v15 = (*(uint64_t (**)(re::ecs2::Component *))(*(void *)a3 + 40))(a3);
  uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 48))(v15);
  id v18 = &qword_268772000;
  while (1)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)v17, memory_order_acquire) & 1) == 0)
    {
      uint64_t v22 = v17;
      uint64_t v32 = v16;
      int v23 = __cxa_guard_acquire(v17);
      id v18 = &qword_268772000;
      int v24 = v23;
      uint64_t v16 = v32;
      int v17 = v22;
      if (v24)
      {
        re::introspect<re::ecs2::AssetStateComponent>(void)::info = (_UNKNOWN *)re::ecs2::introspect_AssetStateComponent(0);
        __cxa_guard_release(v22);
        id v18 = &qword_268772000;
        uint64_t v16 = v32;
        int v17 = v22;
      }
    }
    if (v16 == v18[438]) {
      break;
    }
    uint64_t v19 = *(unsigned int *)(v16 + 56);
    if (v19)
    {
      for (unint64_t i = *(void **)(v16 + 64); ; ++i)
      {
        long long v21 = (_DWORD *)*i;
        if (*(_DWORD *)*i == 1 && v21[10] == 3) {
          break;
        }
        if (!--v19) {
          return 0;
        }
      }
      uint64_t v16 = *((void *)v21 + 2);
      if (v16) {
        continue;
      }
    }
    return 0;
  }
  uint64_t v28 = *((void *)a3 + 5);
  if (v28 != (*(uint64_t (**)(re::NetworkAssetManager *))(*(void *)this + 104))(this))
  {
    uint64_t v29 = (void (***)(void, void, void, void, void, void))*((void *)this + 28);
    if (v29) {
      (**v29)(v29, *((void *)a3 + 4), *((void *)a3 + 5), *((unsigned __int8 *)a3 + 48), 0, 0);
    }
  }
  return 0;
}

void re::NetworkAssetManager::deinit(re::NetworkAssetManager *this)
{
  unint64_t v3 = (uint64_t *)((char *)this + 184);
  uint64_t v2 = *((void *)this + 23);
  if (v2)
  {
    if (!*(void *)(v2 + 56)
      || (uint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 1) + 104))(*((void *)this + 1)),
          re::Collection<re::SharedPtr<re::ecs2::Scene>>::remove(v4, v3),
          (uint64_t v2 = *((void *)this + 23)) != 0))
    {

      *unint64_t v3 = 0;
    }
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5)
  {

    *((void *)this + 3) = 0;
  }
  *((void *)this + 1) = 0;
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    re::Event<re::NetworkSystem,re::ecs2::Component *>::unsubscribe<re::NetworkAssetManager>(v6 + 352, (uint64_t)this);
  }
  *((void *)this + 2) = 0;
}

uint64_t re::Collection<re::SharedPtr<re::ecs2::Scene>>::remove(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    uint64_t v5 = 8 * v4;
    uint64_t v6 = *(void **)(a1 + 40);
    while (*v6 != *a2)
    {
      ++v6;
      v5 -= 8;
      if (!v5)
      {
        uint64_t v6 = (void *)(v3 + 8 * v4);
        break;
      }
    }
  }
  else
  {
    uint64_t v6 = *(void **)(a1 + 40);
  }
  unint64_t v7 = ((uint64_t)v6 - v3) >> 3;
  if (v7 == v4) {
    return 0;
  }
  int v9 = *(_DWORD *)(a1 + 32);
  uint64_t v10 = *a2;
  uint64_t v17 = v10;
  if (v10) {
    id v11 = (id)(v10 + 8);
  }
  (*(void (**)(uint64_t, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, v7, &v17);
  if (v9 == *(_DWORD *)(a1 + 32)) {
    goto LABEL_20;
  }
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 24);
  if (v13)
  {
    uint64_t v14 = 8 * v13;
    uint64_t v15 = *(void **)(a1 + 40);
    while (*v15 != v17)
    {
      ++v15;
      v14 -= 8;
      if (!v14)
      {
        uint64_t v15 = (void *)(v12 + 8 * v13);
        break;
      }
    }
  }
  else
  {
    uint64_t v15 = *(void **)(a1 + 40);
  }
  unint64_t v7 = ((uint64_t)v15 - v12) >> 3;
  if (v7 != v13)
  {
LABEL_20:
    re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::removeAt(a1 + 8, v7);
    (*(void (**)(uint64_t, unint64_t, uint64_t *))(*(void *)a1 + 56))(a1, v7, &v17);
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v17) {

  }
  return v8;
}

void re::Event<re::NetworkSystem,re::ecs2::Component *>::unsubscribe<re::NetworkAssetManager>(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 16))
  {
    unint64_t v4 = 0;
    uint64_t v5 = (_anonymous_namespace_ *)(a1 + 40);
    do
    {
      uint64_t v6 = (long long *)(*(void *)(a1 + 32) + 32 * v4);
      if (*(void *)v6 == a2)
      {
        if (!*(_DWORD *)(a1 + 80))
        {
          re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((void *)a1, v4);
          continue;
        }
        v8[0] = 0;
        long long v7 = v6[1];
        long long v9 = *v6;
        long long v10 = v7;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::add(v5, (uint64_t)v8);
      }
      ++v4;
    }
    while (v4 < *(void *)(a1 + 16));
  }
}

uint64_t re::NetworkAssetManager::assetLoadDescriptors@<X0>(re::NetworkAssetManager *this@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
  if (result
    && (uint64_t result = (uint64_t)re::ecs2::EntityHandle::resolve((id *)result, *((void *)this + 1))) != 0
    && (uint64_t result = re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(result + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType)) != 0)
  {
    *a3 = 1;
    return re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)(a3 + 8), (uint64_t *)(result + 72));
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + 48 * v3 + 16) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 48 * v3 + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v5 + 48 * v3 + 16) == a2) {
        return v5 + 48 * v3 + 24;
      }
    }
    return 0;
  }
  return v5 + 48 * v3 + 24;
}

id *re::NetworkAssetManager::dependencyAssetId@<X0>(re::NetworkAssetManager *this@<X0>, const char *a2@<X2>, unint64_t a3@<X1>, uint64_t a4@<X8>)
{
  uint64_t result = (id *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a3);
  if (!result) {
    goto LABEL_9;
  }
  uint64_t result = (id *)re::ecs2::EntityHandle::resolve(result, *((void *)this + 1));
  if (!result) {
    goto LABEL_9;
  }
  uint64_t result = (id *)re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(result + 4), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
  if (!result) {
    goto LABEL_9;
  }
  uint64_t v8 = (uint64_t)(result + 14);
  long long v9 = (void *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v8, (uint64_t)&v10);
  uint64_t result = v10;
  if (v10)
  {
    if (v11) {
      uint64_t result = (id *)(*((uint64_t (**)(void))*v10 + 5))();
    }
  }
  if (v9)
  {
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = *v9;
  }
  else
  {
LABEL_9:
    *(unsigned char *)a4 = 0;
  }
  return result;
}

id *re::NetworkAssetManager::netComponent(re::NetworkAssetManager *this, unint64_t a2)
{
  uint64_t result = (id *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
  if (result)
  {
    uint64_t result = (id *)re::ecs2::EntityHandle::resolve(result, *((void *)this + 1));
    if (result) {
      return (id *)re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(result + 4), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
    }
  }
  return result;
}

uint64_t re::NetworkAssetManager::localPeerId(re::NetworkAssetManager *this)
{
  return RESyncServiceGetLocalPeerId();
}

id *re::NetworkAssetManager::ownerPeerID@<X0>(re::NetworkAssetManager *this@<X0>, unint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = (id *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
  if (result)
  {
    uint64_t v6 = re::ecs2::EntityHandle::resolve(result, *((void *)this + 1));
    return (id *)re::NetworkAssetManager::ownerPeerID(a3, this, (uint64_t)v6);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

unsigned char *re::NetworkAssetManager::ownerPeerID(unsigned char *this, const re::ecs2::Entity *a2, uint64_t a3)
{
  uint64_t v3 = this;
  if (a3 && (uint64_t v4 = *(void *)(a3 + 200)) != 0)
  {
    uint64_t v5 = *(void *)(a3 + 24);
    if (v5 && (*(unsigned char *)(v5 + 288) & 0x80) != 0) {
      uint64_t v5 = 0;
    }
    uint64_t v6 = *((void *)a2 + 3);
    if (v6 != v5 || v6 == 0)
    {
      this = *(unsigned char **)(v4 + 32);
      if (this) {
        this = (unsigned char *)RESyncableGetOwnerPeerID();
      }
    }
    else
    {
      this = (unsigned char *)RESyncServiceGetLocalPeerId();
    }
    *uint64_t v3 = 1;
    *((void *)v3 + 1) = this;
  }
  else
  {
    *this = 0;
  }
  return this;
}

uint64_t re::NetworkAssetManager::fromPeerID@<X0>(re::NetworkAssetManager *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
  if (result
    && (uint64_t result = (uint64_t)re::ecs2::EntityHandle::resolve((id *)result, *((void *)this + 1))) != 0
    && (uint64_t v6 = *(void *)(result + 200)) != 0)
  {
    uint64_t result = *(void *)(v6 + 32);
    if (result) {
      uint64_t result = RESyncableGetFromPeerID();
    }
    *(unsigned char *)a3 = 1;
    *(void *)(a3 + 8) = result;
  }
  else
  {
    *(unsigned char *)a3 = 0;
  }
  return result;
}

uint64_t re::NetworkAssetManager::setUseIndependentScene(uint64_t this, uint64_t a2)
{
  if (*(unsigned __int8 *)(this + 192) != a2)
  {
    if (*(void *)(this + 176))
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Network asset manager has already attached to a scene", "m_activeScene == nullptr", "setUseIndependentScene", 208);
      this = _os_crash();
      __break(1u);
    }
    else
    {
      *(unsigned char *)(this + 192) = a2;
    }
  }
  return this;
}

void re::NetworkAssetManager::hackOneTimeSetUp(re::NetworkAssetManager *this)
{
  if (!*((unsigned char *)this + 193))
  {
    if (!*((unsigned char *)this + 192))
    {
LABEL_8:
      *((unsigned char *)this + 193) = 1;
      return;
    }
    unint64_t v2 = (re *)(*(uint64_t (**)(void))(**((void **)this + 1) + 104))(*((void *)this + 1));
    if (*((void *)v2 + 3))
    {
      if (*((void *)this + 23))
      {
        uint64_t v3 = *re::assetsLogObjects(v2);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v6 = 0;
          _os_log_impl(&dword_233120000, v3, OS_LOG_TYPE_DEFAULT, "Network asset one-time set up: adding asset scene to ECS service", v6, 2u);
        }
        uint64_t v4 = (void *)(*(uint64_t (**)(void))(**((void **)this + 1) + 104))(*((void *)this + 1));
        re::Collection<re::SharedPtr<re::ecs2::Scene>>::add(v4, (uint64_t *)this + 23);
      }
      goto LABEL_8;
    }
    uint64_t v5 = *re::assetsLogObjects(v2);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl(&dword_233120000, v5, OS_LOG_TYPE_DEBUG, "Delaying network asset one-time set up: no other scenes yet", buf, 2u);
    }
  }
}

void re::Collection<re::SharedPtr<re::ecs2::Scene>>::add(void *a1, uint64_t *a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = *a2;
  uint64_t v7 = v4;
  if (v4) {
    id v5 = (id)(v4 + 8);
  }
  (*(void (**)(void *, uint64_t, uint64_t *))(*a1 + 24))(a1, v3, &v7);
  uint64_t v6 = a1[3];
  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::add(a1 + 1, &v7);
  (*(void (**)(void *, uint64_t, uint64_t *))(*a1 + 48))(a1, v6, &v7);
  if (v7) {
}
  }

void re::Collection<re::SharedPtr<re::ecs2::Entity>>::add(void *a1, uint64_t *a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = *a2;
  uint64_t v7 = v4;
  if (v4) {
    id v5 = (id)(v4 + 8);
  }
  (*(void (**)(void *, uint64_t, uint64_t *))(*a1 + 24))(a1, v3, &v7);
  uint64_t v6 = a1[3];
  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::add(a1 + 1, &v7);
  (*(void (**)(void *, uint64_t, uint64_t *))(*a1 + 48))(a1, v6, &v7);
  if (v7) {
}
  }

BOOL re::NetworkAssetManager::shareAsset(uint64_t a1, unint64_t a2, uint64_t *a3, const char **a4, char a5)
{
  long long v10 = (re::ecs2::EntityFactory *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 32, a2);
  char v11 = v10;
  if (!v10)
  {
    if (*(unsigned char *)(a1 + 192))
    {
      uint64_t v13 = (re::ecs2::Scene **)(a1 + 184);
      if (!*(void *)(a1 + 184))
      {
        uint64_t v37 = 0x70790C8A86948A1ELL;
        unint64_t v38 = "RootAssetScene";
        re::make::shared::object<re::ecs2::Scene,re::ConstStringID>((re *)&v37, v39);
        uint64_t v15 = *v13;
        uint64_t v16 = v39[0];
        *uint64_t v13 = v39[0];
        v39[0] = v15;
        if (v15)
        {

          uint64_t v16 = *v13;
        }
        long long v10 = (re::ecs2::EntityFactory *)re::ecs2::Scene::setHiddenFromSwiftAPI((uint64_t)v16, v14);
        if (*(unsigned char *)(a1 + 193))
        {
          uint64_t v17 = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 104))(*(void *)(a1 + 8));
          re::Collection<re::SharedPtr<re::ecs2::Scene>>::add(v17, (uint64_t *)(a1 + 184));
        }
        uint64_t v18 = *(void *)(a1 + 24);
        uint64_t v19 = *(void *)(a1 + 184);
        *(void *)(a1 + 176) = v19;
        if (v18) {
          re::Collection<re::SharedPtr<re::ecs2::Entity>>::add((void *)(*(void *)(v19 + 104) + 304), (uint64_t *)(a1 + 24));
        }
      }
    }
    long long v20 = (uint64_t *)(a1 + 24);
    if (!*(void *)(a1 + 24))
    {
      long long v21 = re::ecs2::EntityFactory::instance(v10);
      re::ecs2::EntityFactory::make((re::ecs2::EntityFactory *)v21, 4uLL, (re::ecs2::Entity **)&v37);
      uint64_t v22 = *v20;
      uint64_t v23 = v37;
      *long long v20 = v37;
      if (v22)
      {

        uint64_t v23 = *v20;
      }
      *(_DWORD *)(v23 + 288) |= 0x1400u;
      re::StringID::StringID((re::StringID *)&v37, (const StringID *)(a1 + 200));
      re::StringID::operator=((unint64_t *)(v23 + 272), &v37);
      re::StringID::destroyString((re::StringID *)&v37);
      re::ecs2::EntityComponentCollection::add((re::ecs2::EntityComponentCollection *)(*(void *)(a1 + 24) + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::LinkedTLEComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
      re::ecs2::EntityComponentCollection::add((re::ecs2::EntityComponentCollection *)(*(void *)(a1 + 24) + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
      uint64_t v24 = *(void *)(a1 + 176);
      if (v24) {
        re::Collection<re::SharedPtr<re::ecs2::Entity>>::add((void *)(*(void *)(v24 + 104) + 304), (uint64_t *)(a1 + 24));
      }
    }
    unint64_t v25 = (re::ecs2::Entity *)*v20;
    re::DynamicString::format((re::DynamicString *)"%s Asset:%llu", (re::DynamicString *)&v37, *a4, a2);
    uint64_t v26 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                + 7)
                                                             + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 216, 0);
    re::make::shared::inplace<re::ecs2::NetworkAssetComponent>(v26, &v35);
    uint64_t v27 = v35;
    *((void *)v35 + 4) = a2;
    uint64_t v28 = *a4;
    uint64_t v29 = (re::ecs2::Component *)((char *)v27 + 40);
    uint64_t v30 = (re::ecs2::Scene *)strlen(v28);
    v39[0] = (re::ecs2::Scene *)v28;
    v39[1] = v30;
    re::DynamicString::operator=(v29, (uint64_t)v39);
    re::DynamicArray<re::AssetLoadDescriptor>::operator=((uint64_t)v35 + 72, a3);
    uint64_t v31 = v36;
    *((unsigned char *)v35 + 160) = a5;
    uint64_t v32 = (re::ecs2::NetworkComponent *)re::ecs2::EntityComponentCollection::add((re::ecs2::EntityComponentCollection *)(v31 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
    uint64_t v34 = v35;
    if (v35) {
      uint64_t v33 = (char *)v35 + 8;
    }
    re::ecs2::EntityComponentCollection::add(v31 + 32, (uint64_t *)&v34, 1);
    if (v34)
    {

      uint64_t v34 = 0;
    }
    re::ecs2::NetworkComponent::markDirty(v32, v35);
    if (v35) {

    }
    if (v31) {
    if (v37 && (v38 & 1) != 0)
    }
      (*(void (**)(void))(*(void *)v37 + 40))();
  }
  return v11 == 0;
}

void anonymous namespace'::makeAssetEntity(_anonymous_namespace_ *this, const re::DynamicString *a2, re::ecs2::Entity *a3)
{
  uint64_t v6 = re::ecs2::EntityFactory::instance(this);
  uint64_t v7 = re::ecs2::EntityFactory::make((re::ecs2::EntityFactory *)v6, 4uLL, (re::ecs2::Entity **)this);
  uint64_t v8 = *(void *)this;
  *(_DWORD *)(v8 + 288) |= 0x1400u;
  if (*((void *)a2 + 1)) {
    long long v9 = (const char *)*((void *)a2 + 2);
  }
  else {
    long long v9 = (char *)a2 + 9;
  }
  v10[0] = 0;
  v10[1] = (uint64_t)"";
  re::StringID::operator=((unint64_t *)(v8 + 272), v10);
  re::StringID::destroyString((re::StringID *)v10);
  re::ecs2::Entity::setParentInternal((re::ecs2::Entity *)v8, a3, 0xFFFFFFFFFFFFFFFFLL);
}

uint64_t re::DynamicArray<re::AssetLoadDescriptor>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = *a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::AssetLoadDescriptor>::copy((void *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::AssetLoadDescriptor>::clear(a1);
      }
    }
    else if (v4)
    {
      unint64_t v5 = a2[2];
      *(void *)a1 = v4;
      re::DynamicArray<re::AssetLoadDescriptor>::setCapacity((void *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::AssetLoadDescriptor>::copy((void *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::NetworkAssetManager::preloadAsset(uint64_t a1, re::AssetHandle *this, uint64_t a3)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  uint64_t v6 = (re *)re::AssetHandle::assetInfo(this);
  unint64_t v7 = *((void *)v6 + 10);
  if (v7 + 1 <= 1)
  {
    uint64_t v8 = *re::assetsLogObjects(v6);
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v9) {
      return result;
    }
    *(_WORD *)long long buf = 0;
    char v11 = "Will not preload asset with assetID: 0.";
    uint64_t v12 = v8;
    uint32_t v13 = 2;
    goto LABEL_50;
  }
  if (!*(void *)(a3 + 8))
  {
    uint64_t v33 = *re::assetsLogObjects(v6);
    BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v34) {
      return result;
    }
    uint64_t v35 = *((void *)re::AssetHandle::assetInfo(this) + 10);
    if (v35 == -1) {
      uint64_t v35 = 0;
    }
    uint64_t v36 = **(void **)(*((void *)this + 1) + 264);
    *(_DWORD *)long long buf = 134218242;
    *(void *)uint64_t v52 = v35;
    *(_WORD *)&v52[8] = 2080;
    *(void *)&v52[10] = v36;
    char v11 = "Will not preload assetId:%llu, asset type: %s, because there are 0 peerIDs.";
LABEL_49:
    uint64_t v12 = v33;
    uint32_t v13 = 22;
LABEL_50:
    _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, v11, buf, v13);
    return 0;
  }
  uint64_t v14 = (re *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 32, v7);
  if (!v14)
  {
    uint64_t v33 = *re::assetsLogObjects(0);
    BOOL v37 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v37) {
      return result;
    }
    uint64_t v38 = *((void *)re::AssetHandle::assetInfo(this) + 10);
    if (v38 == -1) {
      uint64_t v38 = 0;
    }
    uint64_t v39 = **(void **)(*((void *)this + 1) + 264);
    *(_DWORD *)long long buf = 134218242;
    *(void *)uint64_t v52 = v38;
    *(_WORD *)&v52[8] = 2080;
    *(void *)&v52[10] = v39;
    char v11 = "Failed to preload assetId:%llu, asset type: %s, because there is no assetEntityHandle.";
    goto LABEL_49;
  }
  uint64_t v15 = *(void *)(a1 + 8);
  if (!v15)
  {
    uint64_t v33 = *re::assetsLogObjects(v14);
    BOOL v40 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v40) {
      return result;
    }
    uint64_t v41 = *((void *)re::AssetHandle::assetInfo(this) + 10);
    if (v41 == -1) {
      uint64_t v41 = 0;
    }
    uint64_t v42 = **(void **)(*((void *)this + 1) + 264);
    *(_DWORD *)long long buf = 134218242;
    *(void *)uint64_t v52 = v41;
    *(_WORD *)&v52[8] = 2080;
    *(void *)&v52[10] = v42;
    char v11 = "Failed to preload assetId:%llu, asset type: %s, because there is no ECS Service.";
    goto LABEL_49;
  }
  uint64_t v16 = re::ecs2::EntityHandle::resolve((id *)v14, v15);
  if (!v16)
  {
    uint64_t v33 = *re::assetsLogObjects(0);
    BOOL v43 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v43) {
      return result;
    }
    uint64_t v44 = *((void *)re::AssetHandle::assetInfo(this) + 10);
    if (v44 == -1) {
      uint64_t v44 = 0;
    }
    uint64_t v45 = **(void **)(*((void *)this + 1) + 264);
    *(_DWORD *)long long buf = 134218242;
    *(void *)uint64_t v52 = v44;
    *(_WORD *)&v52[8] = 2080;
    *(void *)&v52[10] = v45;
    char v11 = "Failed to preload assetId:%llu, asset type: %s, because there is no Asset Entity.";
    goto LABEL_49;
  }
  uint64_t v17 = (re::ecs2::Entity *)v16;
  uint64_t v18 = *((void *)v16 + 41);
  if (v18)
  {
    uint64_t v19 = (uint64_t *)*((void *)v16 + 43);
    uint64_t v20 = 8 * v18;
    do
    {
      uint64_t v21 = *v19;
      if (*v19)
      {
        uint64_t v22 = (void *)(v21 + 8);
        id v23 = (id)(v21 + 8);
        uint64_t v24 = re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(v21 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);

        if (v24) {
          return 0;
        }
      }
      else if (re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)0x20, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType))
      {
        return 0;
      }
      ++v19;
      v20 -= 8;
    }
    while (v20);
  }
  re::DynamicString::format((re::DynamicString *)"AssetPreload for Asset:%llu", (re::DynamicString *)&v49, v7);
  re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::create(&v47);
  uint64_t v25 = v48;
  uint64_t v26 = (re::ecs2::EntityComponentCollection *)(v48 + 32);
  uint64_t v46 = v47;
  if (v47) {
    uint64_t v27 = (char *)v47 + 8;
  }
  re::ecs2::EntityComponentCollection::add((uint64_t)v26, (uint64_t *)&v46, 1);
  if (v46)
  {

    uint64_t v46 = 0;
  }
  uint64_t v28 = (re::ecs2::NetworkComponent *)re::ecs2::EntityComponentCollection::add(v26, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
  re::ecs2::NetworkComponent::setNetworkShareMode(v28, 0);
  *(_DWORD *)long long buf = 1;
  uint64_t v55 = 0;
  *(void *)&v52[12] = 0;
  uint64_t v53 = 0;
  *(void *)&unint64_t v52[4] = 0;
  int v54 = 0;
  uint64_t v29 = *(void *)(a3 + 8);
  if (v29)
  {
    uint64_t v30 = *(unint64_t **)a3;
    uint64_t v31 = 8 * v29;
    do
    {
      unint64_t v32 = *v30++;
      re::ecs2::SyncAccessControl::addEntry(buf, v32, 0);
      v31 -= 8;
    }
    while (v31);
  }
  re::ecs2::NetworkComponent::setAccessControl((uint64_t)v28, (uint64_t *)buf);
  re::ecs2::NetworkComponent::markDirty(v28, v47);
  if (*(void *)&v52[4] && v55) {
    (*(void (**)(void))(**(void **)&v52[4] + 40))();
  }
  if (v47) {

  }
  if (v25) {
  if (v49)
  }
  {
    if (v50) {
      (*(void (**)(void))(*(void *)v49 + 40))();
    }
  }
  return 1;
}

void re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::create(void *a1@<X8>)
{
  uint64_t v2 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                             + 7)
                                                          + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 56, 0);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(void *)(v2 + 48) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)(v3 + 16) = 0;
  *(unsigned char *)(v3 + 24) = 0;
  *(void *)uint64_t v3 = &unk_26E6C92B0;
  *(void *)(v3 + 40) = 0;
  *(void *)(v3 + 48) = 0;
  *(void *)(v3 + 32) = 0;
  *a1 = v3;
}

void re::NetworkAssetManager::willAddScene(re::NetworkAssetManager *this, re::ecs2::Scene *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)this + 192) && !*((void *)this + 22) && !*((void *)a2 + 47))
  {
    uint64_t v4 = (uint64_t *)((char *)this + 24);
    uint64_t v3 = *((void *)this + 3);
    *((void *)this + 22) = a2;
    if (!v3) {
      goto LABEL_8;
    }
    do
    {
      uint64_t v5 = v3;
      uint64_t v3 = *(void *)(v3 + 24);
    }
    while (v3);
    if (!*(void *)(v5 + 16))
    {
      uint64_t v8 = *re::assetsLogObjects(this);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *((void *)a2 + 5);
        int v10 = 136315138;
        uint64_t v11 = v9;
        _os_log_impl(&dword_233120000, v8, OS_LOG_TYPE_DEFAULT, "Adding asset root entity to scene '%s'", (uint8_t *)&v10, 0xCu);
      }
      re::Collection<re::SharedPtr<re::ecs2::Entity>>::add((void *)(*((void *)a2 + 13) + 304), v4);
    }
    else
    {
LABEL_8:
      uint64_t v6 = *re::assetsLogObjects(this);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *((void *)a2 + 5);
        int v10 = 136315138;
        uint64_t v11 = v7;
        _os_log_impl(&dword_233120000, v6, OS_LOG_TYPE_DEFAULT, "Asset root entity will be attached to scene '%s'", (uint8_t *)&v10, 0xCu);
      }
    }
  }
}

void re::NetworkAssetManager::willRemoveScene(re::NetworkAssetManager *this, re::ecs2::Scene *a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)this + 192) && *((re::ecs2::Scene **)this + 22) == a2)
  {
    uint64_t v4 = (re::ecs2::Entity *)*((void *)this + 3);
    if (v4) {
      re::ecs2::Entity::removeFromSceneOrParent(v4);
    }
    *((void *)this + 22) = 0;
    uint64_t v5 = (re *)(*(uint64_t (**)(void))(**((void **)this + 1) + 104))(*((void *)this + 1));
    uint64_t v6 = *((void *)v5 + 3);
    if (v6)
    {
      uint64_t v7 = (re::ecs2::Scene **)*((void *)v5 + 5);
      uint64_t v8 = &v7[v6];
      do
      {
        uint64_t v9 = *v7;
        if (*v7 != a2 && !*((void *)v9 + 47))
        {
          *((void *)this + 22) = v9;
          uint64_t v10 = *((void *)this + 3);
          if (v10)
          {
            do
            {
              uint64_t v11 = v10;
              uint64_t v10 = *(void *)(v10 + 24);
            }
            while (v10);
            if (!*(void *)(v11 + 16))
            {
              uint64_t v12 = *re::assetsLogObjects(v5);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v13 = *((void *)a2 + 5);
                uint64_t v14 = *(void *)(*((void *)this + 22) + 40);
                *(_DWORD *)long long buf = 136315394;
                uint64_t v18 = v13;
                __int16 v19 = 2080;
                uint64_t v20 = v14;
                _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Moving asset root entity from scene '%s' to '%s'", buf, 0x16u);
              }
              re::Collection<re::SharedPtr<re::ecs2::Entity>>::add((void *)(*(void *)(*((void *)this + 22) + 104) + 304), (uint64_t *)this + 3);
            }
          }
        }
        ++v7;
      }
      while (v7 != v8);
    }
    if (!*((void *)this + 22))
    {
      uint64_t v15 = *re::assetsLogObjects(v5);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *((void *)a2 + 5);
        *(_DWORD *)long long buf = 136315138;
        uint64_t v18 = v16;
        _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "Detached asset root entity from removed scene '%s'", buf, 0xCu);
      }
    }
  }
}

uint64_t re::NetworkAssetManager::unshareAsset(re::NetworkAssetManager *this, unint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(re::NetworkAssetManager *))(*(void *)this + 112))(this);
  if (result)
  {
    uint64_t result = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
    if (result)
    {
      uint64_t result = (uint64_t)re::ecs2::EntityHandle::resolve((id *)result, *((void *)this + 1));
      if (result)
      {
        uint64_t v5 = *(void *)(result + 24);
        if (v5 && (*(unsigned char *)(v5 + 288) & 0x80) != 0) {
          uint64_t v5 = 0;
        }
        if (*((void *)this + 3) == v5)
        {
          re::ecs2::Entity::removeFromSceneOrParent((re::ecs2::Entity *)result);
          re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this + 32, a2);
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

void re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t a1, unint64_t a2)
{
  if (*(void *)a1)
  {
    unint64_t v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    unint64_t v4 = (v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24);
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(unsigned int *)(v5 + 4 * v4);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = *(void *)(a1 + 16);
      if (*(void *)(v7 + 48 * v6 + 16) == a2)
      {
        *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v7 + 48 * v6 + 8) & 0x7FFFFFFF;
LABEL_8:
        uint64_t v10 = *(void *)(a1 + 16);
        uint64_t v11 = v10 + 48 * v6;
        int v14 = *(_DWORD *)(v11 + 8);
        uint64_t v13 = (int *)(v11 + 8);
        int v12 = v14;
        if (v14 < 0)
        {
          *uint64_t v13 = v12 & 0x7FFFFFFF;
          uint64_t v15 = v10 + 48 * v6;
          re::ecs2::EntityHandle::reset((re::ecs2::EntityHandle *)(v15 + 24));
          objc_destroyWeak((id *)(v15 + 24));
          *(void *)(v15 + 24) = 0;
          uint64_t v10 = *(void *)(a1 + 16);
          int v12 = *(_DWORD *)(v10 + 48 * v6 + 8);
        }
        int v16 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v10 + 48 * v6 + 8) = *(_DWORD *)(a1 + 36) | v12 & 0x80000000;
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v6;
        *(_DWORD *)(a1 + 40) = v16 + 1;
      }
      else
      {
        while (1)
        {
          unsigned int v8 = v6;
          int v9 = *(_DWORD *)(v7 + 48 * v6 + 8);
          uint64_t v6 = v9 & 0x7FFFFFFF;
          if ((v9 & 0x7FFFFFFF) == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v7 + 48 * v6 + 16) == a2)
          {
            *(_DWORD *)(v7 + 48 * v8 + 8) = *(_DWORD *)(v7 + 48 * v8 + 8) & 0x80000000 | *(_DWORD *)(v7 + 48 * v6 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

uint64_t re::NetworkAssetManager::setAssetChangeCallback(uint64_t result, uint64_t a2)
{
  *(void *)(result + 224) = a2;
  return result;
}

void re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::create(void *a1@<X8>)
{
  uint64_t v2 = (*(uint64_t (**)(void, uint64_t, void))(**((void **)re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                             + 7)
                                                          + 32))(*((void *)re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 56, 0);
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(void *)(v2 + 48) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v2, 0);
  *(void *)(v3 + 16) = 0;
  *(unsigned char *)(v3 + 24) = 0;
  *(void *)uint64_t v3 = &unk_26E6C9158;
  *a1 = v3;
}

uint64_t re::NetworkAssetManager::updateAssetState(const re::ecs2::Entity *a1, unint64_t a2, char a3)
{
  if (!*((unsigned char *)a1 + 216)) {
    return 0;
  }
  uint64_t result = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)a1 + 32, a2);
  if (result)
  {
    uint64_t result = (uint64_t)re::ecs2::EntityHandle::resolve((id *)result, *((void *)a1 + 1));
    if (result)
    {
      uint64_t v7 = result;
      uint64_t v8 = *(void *)(result + 328);
      if (v8)
      {
        int v9 = *(void **)(result + 344);
        uint64_t v10 = 8 * v8;
        while (1)
        {
          uint64_t v11 = (void *)*v9;
          if (*v9) {
            int v12 = v11 + 1;
          }
          uint64_t v13 = re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(v11 + 4), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
          if (v13)
          {
            int v14 = (const re::ecs2::Component *)v13;
            uint64_t v15 = *(void *)(v13 + 40);
            if (v15 == (*(uint64_t (**)(const re::ecs2::Entity *))(*(void *)a1 + 104))(a1)) {
              break;
            }
          }
          if (v11) {

          }
          ++v9;
          v10 -= 8;
          if (!v10) {
            goto LABEL_13;
          }
        }
        *((unsigned char *)v14 + 48) = a3;
        uint64_t v18 = (re::ecs2::NetworkComponent *)v11[25];
        if (v18) {
          re::ecs2::NetworkComponent::markDirty(v18, v14);
        }

        return 1;
      }
LABEL_13:
      uint64_t v16 = (*(uint64_t (**)(const re::ecs2::Entity *))(*(void *)a1 + 104))(a1);
      re::NetworkAssetManager::ownerPeerID(v38, a1, v7);
      if (v38[0])
      {
        unint64_t v17 = v39;
        if (v39 != v16)
        {
          __int16 v19 = re::ecs2::EntityChildCollection::add((re::ecs2::EntityChildCollection *)(v7 + 304));
          uint64_t v20 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"AssetState for Asset:%llu, Peer:%llu", (re::DynamicString *)&v35, a2, v16);
          if (v36) {
            uint64_t v21 = *(const char **)&v37[7];
          }
          else {
            uint64_t v21 = v37;
          }
          uint64_t v27 = 0;
          uint64_t v28 = "";
          re::StringID::operator=((unint64_t *)v19 + 34, &v27);
          re::StringID::destroyString((re::StringID *)&v27);
          re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::create(&v34);
          uint64_t v22 = v34;
          *((void *)v34 + 4) = a2;
          *((void *)v22 + 5) = v16;
          uint64_t v33 = v22;
          id v23 = (char *)v22 + 8;
          re::ecs2::EntityComponentCollection::add((uint64_t)v19 + 32, (uint64_t *)&v33, 1);
          if (v33)
          {

            uint64_t v33 = 0;
          }
          uint64_t v24 = (re::ecs2::NetworkComponent *)re::ecs2::EntityComponentCollection::add((re::ecs2::Entity *)((char *)v19 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
          re::ecs2::NetworkComponent::setNetworkShareMode(v24, 0);
          LODWORD(v27) = 1;
          uint64_t v32 = 0;
          uint64_t v29 = 0;
          uint64_t v30 = 0;
          uint64_t v28 = 0;
          int v31 = 0;
          re::ecs2::SyncAccessControl::addEntry(&v27, v17, 0);
          re::ecs2::NetworkComponent::setAccessControl((uint64_t)v24, &v27);
          uint64_t v25 = v34;
          *((unsigned char *)v34 + 48) = a3;
          uint64_t v26 = (re::ecs2::NetworkComponent *)*((void *)v19 + 25);
          if (v26) {
            re::ecs2::NetworkComponent::markDirty(v26, v25);
          }
          if (v28 && v32) {
            (*(void (**)(void))(*(void *)v28 + 40))();
          }
          if (v34) {

          }
          if (v35)
          {
            if (v36) {
              (*(void (**)(void))(*(void *)v35 + 40))();
            }
          }
          return 1;
        }
      }
      return 0;
    }
  }
  return result;
}

BOOL re::NetworkAssetManager::clearAssetDescriptors(re::NetworkAssetManager *this, unint64_t a2)
{
  uint64_t v3 = (id *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
  unint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = re::ecs2::EntityHandle::resolve(v3, *((void *)this + 1));
    uint64_t v6 = (const re::ecs2::Component *)re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(v5 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
    re::DynamicArray<re::AssetLoadDescriptor>::clear((uint64_t)v6 + 72);
    uint64_t v7 = *((void *)v6 + 2);
    if (v7)
    {
      uint64_t v8 = *(re::ecs2::NetworkComponent **)(v7 + 200);
      if (v8) {
        re::ecs2::NetworkComponent::markDirty(v8, v6);
      }
    }
  }
  return v4 != 0;
}

void re::DynamicArray<re::AssetLoadDescriptor>::clear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = 144 * v2;
    do
    {
      re::DynamicString::deinit((re::DynamicString *)(v3 + 112));
      re::DynamicArray<unsigned long>::deinit(v3 + 72);
      re::DynamicArray<unsigned long>::deinit(v3 + 32);
      re::DynamicString::deinit((re::DynamicString *)v3);
      v3 += 144;
      v4 -= 144;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

BOOL re::NetworkAssetManager::setAssetDependencies(re::NetworkAssetManager *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = re::NetworkAssetManager::netComponent(a1, a2);
  uint64_t v5 = v4;
  if (v4)
  {
    re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)(v4 + 14), a3);
    id v6 = v5[2];
    if (v6)
    {
      uint64_t v7 = (re::ecs2::NetworkComponent *)*((void *)v6 + 25);
      if (v7) {
        re::ecs2::NetworkComponent::markDirty(v7, (const re::ecs2::Component *)v5);
      }
    }
  }
  return v5 != 0;
}

uint64_t re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u) {
        signed int v5 = 3;
      }
      else {
        signed int v5 = *(_DWORD *)(a2 + 28);
      }
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init(a1, v4, v5);
      re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::NetworkAssetManager::updateSharedMetadata(re::NetworkAssetManager *a1, unint64_t a2, uint64_t a3)
{
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 120))(v20);
  if (LOBYTE(v20[0]))
  {
    uint64_t v6 = v20[1];
    if (v6 == (*(uint64_t (**)(re::NetworkAssetManager *))(*(void *)a1 + 104))(a1))
    {
      uint64_t v7 = re::NetworkAssetManager::netComponent(a1, a2);
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear((uint64_t)(v7 + 21));
      uint64_t v8 = *(unsigned int *)(a3 + 32);
      if (v8)
      {
        uint64_t v9 = 0;
        uint64_t v10 = *(int **)(a3 + 16);
        while (1)
        {
          int v11 = *v10;
          v10 += 16;
          if (v11 < 0) {
            break;
          }
          if (v8 == ++v9)
          {
            LODWORD(v9) = *(_DWORD *)(a3 + 32);
            break;
          }
        }
      }
      else
      {
        LODWORD(v9) = 0;
      }
      if (v8 != v9)
      {
        uint64_t v12 = v9;
        uint64_t v13 = *(void *)(a3 + 16);
        unsigned int v14 = *(_DWORD *)(a3 + 32);
        do
        {
          uint64_t v15 = v13 + (v12 << 6);
          if (*(unsigned char *)(v15 + 24))
          {
            re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<re::DynamicString&>((uint64_t)(v7 + 21), (StringID *)(v15 + 8), (const re::DynamicString *)(v15 + 32));
            unsigned int v14 = *(_DWORD *)(a3 + 32);
            uint64_t v13 = *(void *)(a3 + 16);
          }
          if (v14 <= (int)v9 + 1) {
            unsigned int v16 = v9 + 1;
          }
          else {
            unsigned int v16 = v14;
          }
          while (1)
          {
            uint64_t v12 = (v9 + 1);
            if (v16 - 1 == v9) {
              break;
            }
            LODWORD(v9) = v9 + 1;
            unsigned int v17 = v12;
            if ((*(_DWORD *)(v13 + (v12 << 6)) & 0x80000000) != 0) {
              goto LABEL_20;
            }
          }
          unsigned int v17 = v16;
LABEL_20:
          LODWORD(v9) = v17;
        }
        while (v8 != v17);
      }
      id v18 = v7[2];
      if (v18)
      {
        __int16 v19 = (re::ecs2::NetworkComponent *)*((void *)v18 + 25);
        if (v19) {
          re::ecs2::NetworkComponent::markDirty(v19, (const re::ecs2::Component *)v7);
        }
      }
    }
  }
}

void re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    if (*(_DWORD *)(a1 + 32))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::EntryWithoutHash::free((_DWORD *)(*(void *)(a1 + 16) + v3));
        ++v4;
        v3 += 56;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<re::DynamicString&>(uint64_t a1, StringID *a2, const re::DynamicString *a3)
{
  unint64_t v6 = 0xBF58476D1CE4E5B9 * ((*(void *)&a2->var0 >> 31) ^ (*(void *)&a2->var0 >> 1));
  unint64_t v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v7 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v11 = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DynamicString&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 56 * v11;
    return v12 + 24;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (!re::StringID::operator==((void *)(v10 + 56 * v9 + 8), a2))
  {
    uint64_t v9 = *(_DWORD *)(v10 + 56 * v9) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v10 + 56 * v9;
  return v12 + 24;
}

re::DynamicString *re::NetworkAssetManager::getSharedMetadataString@<X0>(re::NetworkAssetManager *this@<X0>, const re::StringID *a2@<X2>, unint64_t a3@<X1>, unsigned char *a4@<X8>)
{
  uint64_t result = (re::DynamicString *)re::NetworkAssetManager::netComponent(this, a3);
  if (result
    && (uint64_t result = (re::DynamicString *)re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)result + 168, a2)) != 0)
  {
    *a4 = 1;
    return re::DynamicString::DynamicString((re::DynamicString *)(a4 + 8), result);
  }
  else
  {
    *a4 = 0;
  }
  return result;
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(uint64_t a1, void *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v3 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  while (!re::StringID::operator==((void *)(v5 + 56 * v4 + 8), a2))
  {
    uint64_t v4 = *(_DWORD *)(v5 + 56 * v4) & 0x7FFFFFFF;
    if (v4 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v5 + 56 * v4 + 24;
}

id *re::NetworkAssetManager::tryGetSharedMetadata(re::NetworkAssetManager *this, unint64_t a2)
{
  uint64_t v2 = re::NetworkAssetManager::netComponent(this, a2);
  if (v2) {
    return v2 + 21;
  }
  else {
    return 0;
  }
}

id *re::NetworkAssetManager::copySharedMetadata(re::NetworkAssetManager *a1, unint64_t a2, uint64_t a3)
{
  uint64_t result = re::NetworkAssetManager::netComponent(a1, a2);
  if (result)
  {
    return (id *)re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(a3, (uint64_t)(result + 21));
  }
  return result;
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(void *)a1)
    {
      if (v4)
      {
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u) {
        signed int v5 = 3;
      }
      else {
        signed int v5 = *(_DWORD *)(a2 + 28);
      }
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init(a1, v4, v5);
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::NetworkAssetManager::copySharedMetadata(re::NetworkAssetManager *this, unint64_t a2, __CFDictionary **a3)
{
  uint64_t v4 = re::NetworkAssetManager::netComponent(this, a2);
  if (v4)
  {
    signed int v5 = v4;
    uint64_t v6 = *((unsigned int *)v4 + 50);
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = (int *)v4[23];
      while (1)
      {
        int v9 = *v8;
        v8 += 14;
        if (v9 < 0) {
          break;
        }
        if (v6 == ++v7)
        {
          LODWORD(v7) = *((_DWORD *)v4 + 50);
          break;
        }
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
    if (v6 != v7)
    {
      uint64_t v10 = v7;
      do
      {
        unsigned int v11 = v5[23];
        uint64_t v12 = &v11[7 * v10];
        CFStringRef v13 = CFStringCreateWithCString(0, (const char *)v12[2], 0x8000100u);
        if (v12[4]) {
          unsigned int v14 = (const char *)v11[7 * v10 + 5];
        }
        else {
          unsigned int v14 = (char *)&v11[7 * v10 + 4] + 1;
        }
        CFStringRef v15 = CFStringCreateWithCString(0, v14, 0x8000100u);
        CFDictionaryAddValue(*a3, v13, v15);
        CFRelease(v13);
        CFRelease(v15);
        unsigned int v16 = *((_DWORD *)v5 + 50);
        if (v16 <= (int)v7 + 1) {
          unsigned int v16 = v7 + 1;
        }
        while (1)
        {
          uint64_t v10 = (v7 + 1);
          if (v16 - 1 == v7) {
            break;
          }
          LODWORD(v7) = v7 + 1;
          unsigned int v17 = v10;
          if ((*((_DWORD *)v5[23] + 14 * v10) & 0x80000000) != 0) {
            goto LABEL_19;
          }
        }
        unsigned int v17 = v16;
LABEL_19:
        LODWORD(v7) = v17;
      }
      while (v6 != v17);
    }
  }
}

BOOL re::NetworkAssetManager::onAdd(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  v38[0] = a2;
  unint64_t v8 = (void *)(a1 + 32);
  BOOL v9 = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(a1 + 32, a2);
  if (v9) {
    return !v9;
  }
  re::ecs2::EntityHandle::EntityHandle((uint64_t)&location, a4);
  unint64_t v10 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  unint64_t v11 = v10 ^ (v10 >> 31);
  if (*v8)
  {
    unint64_t v12 = v11 % *(unsigned int *)(a1 + 56);
    uint64_t v13 = *(unsigned int *)(*(void *)(a1 + 40) + 4 * v12);
    if (v13 != 0x7FFFFFFF)
    {
      uint64_t v14 = *(void *)(a1 + 48);
      if (*(void *)(v14 + 48 * v13 + 16) == a2) {
        goto LABEL_10;
      }
      while (1)
      {
        LODWORD(v13) = *(_DWORD *)(v14 + 48 * v13 + 8) & 0x7FFFFFFF;
        if (v13 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v14 + 48 * v13 + 16) == a2) {
          goto LABEL_10;
        }
      }
    }
  }
  else
  {
    LODWORD(v12) = 0;
  }
  re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove((uint64_t)v8, v12, v11, v38, (uint64_t)&location);
  ++*(_DWORD *)(a1 + 72);
LABEL_10:
  re::ecs2::EntityHandle::reset((re::ecs2::EntityHandle *)&location);
  objc_destroyWeak((id *)&location);
  uint64_t v15 = re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 80, a2);
  if (v15)
  {
    (*(void (**)(void))(**(void **)(v15 + 32) + 16))(*(void *)(v15 + 32));
    re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t (***)(void))(a1 + 80), a2);
  }
  uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8));
  uint64_t v17 = re::ServiceLocator::serviceOrNull<re::EventBus>(v16);
  if (v17)
  {
    id v18 = (re::EventBus *)v17;
    BOOL v32 = v9;
    uint64_t v37 = 0;
    v34[1] = 0;
    unint64_t v35 = 0;
    v34[0] = 0;
    int v36 = 0;
    re::DynamicArray<re::SharedPtr<re::Shareable<re::AssetLoadDescriptor>>>::resize((uint64_t)v34, *(void *)(a3 + 16));
    uint64_t v20 = *(void *)(a3 + 16);
    if (v20)
    {
      uint64_t v21 = 0;
      unint64_t v22 = 0;
      id v23 = *(uint64_t **)(a3 + 32);
      uint64_t v24 = 144 * v20;
      while (1)
      {
        re::DynamicString::DynamicString((re::DynamicString *)&location, (const re::DynamicString *)v23);
        re::DynamicArray<BOOL>::DynamicArray((uint64_t)v41, v23 + 4);
        re::DynamicArray<BOOL>::DynamicArray((uint64_t)v44, v23 + 9);
        re::DynamicString::DynamicString((re::DynamicString *)v47, (const re::DynamicString *)(v23 + 14));
        re::make::shared::object<re::Shareable<re::AssetLoadDescriptor>,re::AssetLoadDescriptor&>((re *)&location, &v33);
        *(void *)&v56[0] = v33;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF74D18, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_26AF74D18))
        {
          _MergedGlobals_31 = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"41RENetworkNewAssetLoadDescriptorAddedEvent" & 0x7FFFFFFFFFFFFFFFLL), v26);
          __cxa_guard_release(&qword_26AF74D18);
        }
        re::EventBus::publish(v18, a4, _MergedGlobals_31, (uint64_t)v56, 8uLL, 0);
        unint64_t v25 = v35;
        if (v35 <= v22) {
          break;
        }
        re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(v37 + v21), v33);
        if (v33) {

        }
        if (v47[0])
        {
          if (v47[1]) {
            (*(void (**)(void))(*(void *)v47[0] + 40))();
          }
          memset(v47, 0, sizeof(v47));
        }
        if (v44[0])
        {
          if (v46) {
            (*(void (**)(void))(*(void *)v44[0] + 40))();
          }
          uint64_t v46 = 0;
          memset(v44, 0, sizeof(v44));
          ++v45;
        }
        if (v41[0])
        {
          if (v43) {
            (*(void (**)(void))(*(void *)v41[0] + 40))();
          }
          uint64_t v43 = 0;
          memset(v41, 0, sizeof(v41));
          ++v42;
        }
        __int16 v19 = (re *)location;
        if (void)location && (BYTE8(location)) {
          __int16 v19 = (re *)(*(uint64_t (**)(void))(*(void *)location + 40))();
        }
        v23 += 18;
        v21 += 8;
        ++v22;
        v24 -= 144;
        if (!v24) {
          goto LABEL_38;
        }
      }
      v38[1] = 0;
      memset(v56, 0, sizeof(v56));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v48 = 136315906;
      uint64_t v49 = "operator[]";
      __int16 v50 = 1024;
      int v51 = 789;
      __int16 v52 = 2048;
      unint64_t v53 = v22;
      __int16 v54 = 2048;
      unint64_t v55 = v25;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
LABEL_38:
      if (re::assetsHighFrequencyLoggingEnabled(void)::onceToken == -1)
      {
LABEL_39:
        if (re::assetsHighFrequencyLoggingEnabled(void)::shouldLog)
        {
          uint64_t v27 = *re::assetsLogObjects(v19);
          BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
          uint64_t v29 = v38[0];
          if (v28)
          {
            LODWORD(location) = 134217984;
            *(void *)((char *)&location + 4) = v38[0];
            _os_log_impl(&dword_233120000, v27, OS_LOG_TYPE_DEFAULT, "AssetId %llu added over network", (uint8_t *)&location, 0xCu);
          }
        }
        else
        {
          uint64_t v29 = v38[0];
        }
        *(void *)&locatiounint64_t n = v29;
        *((void *)&location + 1) = v37;
        unint64_t v40 = v35;
        uint64_t Type = re::EventBus::getTypeId<RENetworkAssetAddedEvent>();
        re::EventBus::publish(v18, a4, Type, (uint64_t)&location, 0x18uLL, 0);
        re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)v34);
        BOOL v9 = v32;
        return !v9;
      }
    }
    dispatch_once(&re::assetsHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_1);
    goto LABEL_39;
  }
  return !v9;
}

BOOL re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + 48 * v3 + 16) == a2) {
    return 1;
  }
  do
  {
    LODWORD(v3) = *(_DWORD *)(v5 + 48 * v3 + 8) & 0x7FFFFFFF;
    BOOL result = v3 != 0x7FFFFFFF;
  }
  while (v3 != 0x7FFFFFFF && *(void *)(v5 + 48 * v3 + 16) != a2);
  return result;
}

uint64_t re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + (v3 << 6) + 16) != a2)
  {
    while (1)
    {
      uint64_t v3 = *(_DWORD *)(v5 + (v3 << 6) + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v5 + (v3 << 6) + 16) == a2) {
        return v5 + (v3 << 6) + 24;
      }
    }
    return 0;
  }
  return v5 + (v3 << 6) + 24;
}

uint64_t (***re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t (***result)(void), unint64_t a2))(void)
{
  if (*result)
  {
    unint64_t v2 = result;
    unint64_t v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    unint64_t v4 = (v3 ^ (v3 >> 31)) % *((unsigned int *)result + 6);
    uint64_t v5 = result[1];
    uint64_t v6 = *((unsigned int *)v5 + v4);
    if (v6 != 0x7FFFFFFF)
    {
      uint64_t v7 = result[2];
      unint64_t v8 = &v7[8 * v6];
      if (v8[2] == (uint64_t (*)(void))a2)
      {
        *((_DWORD *)v5 + v4) = v8[1] & 0x7FFFFFFF;
LABEL_8:
        unint64_t v12 = result[2];
        uint64_t v13 = &v12[8 * v6];
        int v16 = *((_DWORD *)v13 + 2);
        uint64_t v15 = (int *)(v13 + 1);
        int v14 = v16;
        if (v16 < 0)
        {
          *uint64_t v15 = v14 & 0x7FFFFFFF;
          BOOL result = re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)&v12[8 * v6 + 3]);
          unint64_t v12 = v2[2];
          int v14 = (int)v12[8 * v6 + 1];
        }
        int v17 = *((_DWORD *)v2 + 10);
        LODWORD(v12[8 * v6 + 1]) = *((_DWORD *)v2 + 9) | v14 & 0x80000000;
        --*((_DWORD *)v2 + 7);
        *((_DWORD *)v2 + 9) = v6;
        *((_DWORD *)v2 + 10) = v17 + 1;
      }
      else
      {
        while (1)
        {
          unsigned int v9 = v6;
          int v10 = (int)v7[8 * v6 + 1];
          uint64_t v6 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF) {
            break;
          }
          unint64_t v11 = &v7[8 * v6];
          if (v11[2] == (uint64_t (*)(void))a2)
          {
            LODWORD(v7[8 * (unint64_t)v9 + 1]) = (uint64_t)v7[8 * (unint64_t)v9 + 1] & 0x80000000 | v11[1] & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

void re::DynamicArray<re::SharedPtr<re::Shareable<re::AssetLoadDescriptor>>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    unint64_t v5 = a2;
    do
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = *(void *)(v6 + 8 * v5);
      if (v7)
      {

        *(void *)(v6 + 8 * v5) = 0;
        unint64_t v4 = *(void *)(a1 + 16);
      }
      ++v5;
    }
    while (v5 < v4);
  }
  else
  {
    if (*(void *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((void *)a1, a2);
      unint64_t v4 = *(void *)(a1 + 16);
    }
    if (a2 > v4) {
      bzero((void *)(*(void *)(a1 + 32) + 8 * v4), 8 * (a2 - v4));
    }
  }
  *(void *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

BOOL re::NetworkAssetManager::isAssetIdLocal(re::NetworkAssetManager *this)
{
  (*(void (**)(void *__return_ptr))(*(void *)this + 120))(v4);
  if (!LOBYTE(v4[0])) {
    return 1;
  }
  uint64_t v2 = (*(uint64_t (**)(re::NetworkAssetManager *))(*(void *)this + 104))(this);
  return v2 == v4[1];
}

uint64_t re::NetworkAssetManager::onRemove(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = a2;
  uint64_t v48 = *MEMORY[0x263EF8340];
  re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a1 + 32, a2);
  uint64_t v6 = re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 128, v4);
  if (v6)
  {
    (*(void (**)(void))(**(void **)(v6 + 32) + 16))(*(void *)(v6 + 32));
    re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t (***)(void))(a1 + 128), v4);
  }
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8));
  uint64_t v8 = re::ServiceLocator::serviceOrNull<re::EventBus>(v7);
  if (v8)
  {
    unsigned int v9 = (re::EventBus *)v8;
    uint64_t v24 = 0;
    v21[1] = 0;
    unint64_t v22 = 0;
    v21[0] = 0;
    int v23 = 0;
    re::DynamicArray<re::SharedPtr<re::Shareable<re::AssetLoadDescriptor>>>::resize((uint64_t)v21, *(void *)(a3 + 16));
    uint64_t v11 = *(void *)(a3 + 16);
    if (v11)
    {
      uint64_t v12 = 0;
      unint64_t v13 = 0;
      int v14 = *(uint64_t **)(a3 + 32);
      uint64_t v15 = 144 * v11;
      while (1)
      {
        re::DynamicString::DynamicString((re::DynamicString *)&buf, (const re::DynamicString *)v14);
        re::DynamicArray<BOOL>::DynamicArray((uint64_t)v28, v14 + 4);
        re::DynamicArray<BOOL>::DynamicArray((uint64_t)v31, v14 + 9);
        re::DynamicString::DynamicString((re::DynamicString *)v34, (const re::DynamicString *)(v14 + 14));
        re::make::shared::object<re::Shareable<re::AssetLoadDescriptor>,re::AssetLoadDescriptor&>((re *)&buf, &v20);
        unint64_t v16 = v22;
        if (v22 <= v13) {
          break;
        }
        re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(v24 + v12), v20);
        if (v20) {

        }
        if (v34[0])
        {
          if (v34[1]) {
            (*(void (**)(void))(*(void *)v34[0] + 40))();
          }
          memset(v34, 0, sizeof(v34));
        }
        if (v31[0])
        {
          if (v33) {
            (*(void (**)(void))(*(void *)v31[0] + 40))();
          }
          uint64_t v33 = 0;
          memset(v31, 0, sizeof(v31));
          ++v32;
        }
        if (v28[0])
        {
          if (v30) {
            (*(void (**)(void))(*(void *)v28[0] + 40))();
          }
          uint64_t v30 = 0;
          memset(v28, 0, sizeof(v28));
          ++v29;
        }
        int v10 = (re *)buf;
        if (void)buf && (BYTE8(buf)) {
          int v10 = (re *)(*(uint64_t (**)(void))(*(void *)buf + 40))();
        }
        v14 += 18;
        v12 += 8;
        ++v13;
        v15 -= 144;
        if (!v15) {
          goto LABEL_25;
        }
      }
      uint64_t v25 = 0;
      unsigned int v9 = (re::EventBus *)&v35;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v43 = 0u;
      unint64_t v4 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v35 = 136315906;
      int v36 = "operator[]";
      __int16 v37 = 1024;
      int v38 = 789;
      __int16 v39 = 2048;
      unint64_t v40 = v13;
      __int16 v41 = 2048;
      unint64_t v42 = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
LABEL_25:
      if (re::assetsHighFrequencyLoggingEnabled(void)::onceToken == -1) {
        goto LABEL_26;
      }
    }
    dispatch_once(&re::assetsHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_1);
LABEL_26:
    if (re::assetsHighFrequencyLoggingEnabled(void)::shouldLog)
    {
      int v17 = *re::assetsLogObjects(v10);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v4;
        _os_log_impl(&dword_233120000, v17, OS_LOG_TYPE_DEFAULT, "AssetId %llu removed over network", (uint8_t *)&buf, 0xCu);
      }
    }
    *(void *)&long long buf = v4;
    *((void *)&buf + 1) = v24;
    unint64_t v27 = v22;
    uint64_t Type = re::EventBus::getTypeId<RENetworkAssetRemovedEvent>();
    re::EventBus::publish(v9, 0, Type, (uint64_t)&buf, 0x18uLL, 0);
    re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)v21);
  }
  return 1;
}

uint64_t re::NetworkAssetManager::onAddedCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<re::Function<void ()(void)>&>(a1 + 80, &v4, a3);
}

uint64_t re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<re::Function<void ()(void)>&>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(void *)result)
  {
    unint64_t v9 = v8 % *(unsigned int *)(result + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(result + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v11 = *(void *)(result + 16);
      if (*(void *)(v11 + (v10 << 6) + 16) == v6) {
        return result;
      }
      while (1)
      {
        uint64_t v10 = *(_DWORD *)(v11 + (v10 << 6) + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v11 + (v10 << 6) + 16) == v6) {
          return result;
        }
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  uint64_t v12 = *(unsigned int *)(result + 36);
  if (v12 == 0x7FFFFFFF)
  {
    uint64_t v12 = *(unsigned int *)(result + 32);
    int v13 = v12;
    if (v12 == *(_DWORD *)(result + 24))
    {
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(result, 2 * *(_DWORD *)(result + 28));
      LODWORD(v9) = v8 % *(unsigned int *)(v5 + 24);
      int v13 = *(_DWORD *)(v5 + 32);
      uint64_t v6 = *a2;
    }
    *(_DWORD *)(v5 + 32) = v13 + 1;
    uint64_t v14 = *(void *)(v5 + 16);
    int v15 = *(_DWORD *)(v14 + (v12 << 6) + 8);
  }
  else
  {
    uint64_t v14 = *(void *)(result + 16);
    int v15 = *(_DWORD *)(v14 + (v12 << 6) + 8);
    *(_DWORD *)(result + 36) = v15 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v14 + (v12 << 6) + 8) = v15 | 0x80000000;
  *(_DWORD *)(*(void *)(v5 + 16) + (v12 << 6) + 8) = *(_DWORD *)(*(void *)(v5 + 16) + (v12 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(v5 + 8) + 4 * v9);
  *(void *)(*(void *)(v5 + 16) + (v12 << 6)) = v8;
  *(void *)(*(void *)(v5 + 16) + (v12 << 6) + 16) = v6;
  uint64_t v16 = *(void *)(v5 + 16) + (v12 << 6);
  *(void *)(v16 + 48) = *(void *)(a3 + 24);
  *(void *)(v16 + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0;
  BOOL result = re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(v16 + 24, a3);
  *(_DWORD *)(*(void *)(v5 + 8) + 4 * v9) = v12;
  ++*(_DWORD *)(v5 + 28);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

uint64_t re::NetworkAssetManager::onRemovedCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<re::Function<void ()(void)>&>(a1 + 128, &v4, a3);
}

uint64_t re::ServiceLocator::serviceOrNull<re::AssetService>(uint64_t a1)
{
  {
    re::introspect<re::AssetService>(void)::info = re::introspect_AssetService(0);
  }
  uint64_t v2 = re::introspect<re::AssetService>(void)::info;
  re::StringID::invalid((re::StringID *)v5);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(*(void *)a1 + 16))(a1, v2, v5);
  re::StringID::destroyString((re::StringID *)v5);
  return v3;
}

void re::NetworkAssetManager::hackSetAssetRootEntity(re::NetworkAssetManager *this, re::ecs2::Entity *a2)
{
  if (*(void *)(*((void *)this + 3) + 328))
  {
    uint64_t v4 = *re::assetsLogObjects(this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_233120000, v4, OS_LOG_TYPE_DEFAULT, "hackSetAssetRootEntity called when a m_localAssetRootEntity already exists. This may result in previously loaded assets not syncing over the network. Please call hackSetAssetRootEntity before any assets are loaded.", (uint8_t *)v7, 2u);
    }
  }
  if (a2)
  {
    if (!*((void *)a2 + 25)) {
      re::ecs2::EntityComponentCollection::add((re::ecs2::Entity *)((char *)a2 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
    }
    re::StringID::StringID((re::StringID *)v7, (const StringID *)((char *)this + 200));
    re::StringID::operator=((unint64_t *)a2 + 34, v7);
    re::StringID::destroyString((re::StringID *)v7);
    uint64_t v5 = (char *)a2 + 8;
  }
  uint64_t v6 = *((void *)this + 3);
  *((void *)this + 3) = a2;
  if (v6) {
}
  }

void re::NetworkAssetManager::getAssetState(re::NetworkAssetManager *this@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v7 = (id *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a3);
  if (v7
    && (unint64_t v8 = re::ecs2::EntityHandle::resolve(v7, *((void *)this + 1))) != 0
    && (uint64_t v9 = *((void *)v8 + 41)) != 0)
  {
    uint64_t v10 = (uint64_t *)*((void *)v8 + 43);
    uint64_t v11 = 8 * v9;
    while (1)
    {
      uint64_t v12 = *v10;
      if (*v10) {
        id v13 = (id)(v12 + 8);
      }
      uint64_t v14 = re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(v12 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
      if (v14)
      {
        if (*(void *)(v14 + 40) == a2) {
          break;
        }
      }
      if (v12) {

      }
      ++v10;
      v11 -= 8;
      if (!v11) {
        goto LABEL_12;
      }
    }
    int v15 = *(unsigned __int8 *)(v14 + 48);
    *(unsigned char *)a4 = 1;
    *(_DWORD *)(a4 + 4) = v15;
    if (v12)
    {
    }
  }
  else
  {
LABEL_12:
    *(unsigned char *)a4 = 0;
  }
}

uint64_t re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::AssetLoadDescriptor>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::AssetLoadDescriptor>::copy((void *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::AssetLoadDescriptor>::copy(void *a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(a1, *(void *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetLoadDescriptor *,re::AssetLoadDescriptor *,re::AssetLoadDescriptor *>((uint64_t)&v14, *(void *)(a2 + 32), *(void *)(a2 + 32) + 144 * a1[2], a1[4]);
    uint64_t v8 = a1[2];
    if (v8 != v4)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      uint64_t v10 = a1[4];
      uint64_t v11 = 144 * v8;
      uint64_t v12 = 144 * v4;
      do
      {
        re::DynamicString::DynamicString((re::DynamicString *)(v10 + v11), (const re::DynamicString *)(v9 + v11));
        re::DynamicArray<BOOL>::DynamicArray(v10 + v11 + 32, (uint64_t *)(v9 + v11 + 32));
        re::DynamicArray<BOOL>::DynamicArray(v10 + v11 + 72, (uint64_t *)(v9 + v11 + 72));
        re::DynamicString::DynamicString((re::DynamicString *)(v10 + v11 + 112), (const re::DynamicString *)(v9 + v11 + 112));
        v9 += 144;
        v12 -= 144;
        v10 += 144;
      }
      while (v11 != v12);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetLoadDescriptor *,re::AssetLoadDescriptor *,re::AssetLoadDescriptor *>((uint64_t)&v13, *(void *)(a2 + 32), *(void *)(a2 + 32) + 144 * v4, a1[4]);
    uint64_t v5 = a1[2];
    if (v4 != v5)
    {
      uint64_t v6 = a1[4] + 144 * v4;
      uint64_t v7 = 144 * v5 - 144 * v4;
      do
      {
        re::DynamicString::deinit((re::DynamicString *)(v6 + 112));
        re::DynamicArray<unsigned long>::deinit(v6 + 72);
        re::DynamicArray<unsigned long>::deinit(v6 + 32);
        re::DynamicString::deinit((re::DynamicString *)v6);
        v6 += 144;
        v7 -= 144;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

void *re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      BOOL result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x90uLL))
        {
          uint64_t v2 = 144 * a2;
          BOOL result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 144 * a2, 8);
          if (result)
          {
            uint64_t v7 = (uint64_t)result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            re::ObjectHelper::move<re::AssetLoadDescriptor>(v5[4], v5[4] + 144 * v5[2], v7);
            BOOL result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 144, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        BOOL result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        BOOL result = (void *)re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::ObjectHelper::move<re::AssetLoadDescriptor>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(_OWORD *)a3 = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      *(void *)(a3 + 24) = *(void *)(v5 + 24);
      uint64_t v6 = *(void *)(v5 + 8);
      *(void *)a3 = *(void *)v5;
      *(void *)uint64_t v5 = 0;
      uint64_t v7 = *(void *)(v5 + 16);
      *(void *)(v5 + 24) = 0;
      uint64_t v9 = *(void *)(a3 + 8);
      uint64_t v8 = *(void *)(a3 + 16);
      *(void *)(a3 + 8) = v6;
      *(void *)(a3 + 16) = v7;
      *(void *)(v5 + 8) = v9;
      *(void *)(v5 + 16) = v8;
      *(void *)(a3 + 64) = 0;
      *(_DWORD *)(a3 + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      *(void *)(a3 + 32) = 0;
      uint64_t v10 = *(void *)(v5 + 40);
      *(void *)(a3 + 32) = *(void *)(v5 + 32);
      *(void *)(v5 + 32) = 0;
      *(void *)(a3 + 40) = v10;
      *(void *)(v5 + 40) = 0;
      uint64_t v11 = *(void *)(a3 + 48);
      *(void *)(a3 + 48) = *(void *)(v5 + 48);
      *(void *)(v5 + 48) = v11;
      uint64_t v12 = *(void *)(a3 + 64);
      *(void *)(a3 + 64) = *(void *)(v5 + 64);
      *(void *)(v5 + 64) = v12;
      ++*(_DWORD *)(v5 + 56);
      ++*(_DWORD *)(a3 + 56);
      *(void *)(a3 + 104) = 0;
      *(void *)(a3 + 80) = 0;
      *(void *)(a3 + 88) = 0;
      *(void *)(a3 + 72) = 0;
      *(_DWORD *)(a3 + 96) = 0;
      uint64_t v13 = *(void *)(v5 + 80);
      *(void *)(a3 + 72) = *(void *)(v5 + 72);
      *(void *)(v5 + 72) = 0;
      *(void *)(a3 + 80) = v13;
      *(void *)(v5 + 80) = 0;
      uint64_t v14 = *(void *)(a3 + 88);
      *(void *)(a3 + 88) = *(void *)(v5 + 88);
      *(void *)(v5 + 88) = v14;
      uint64_t v15 = *(void *)(a3 + 104);
      *(void *)(a3 + 104) = *(void *)(v5 + 104);
      *(void *)(v5 + 104) = v15;
      ++*(_DWORD *)(v5 + 96);
      ++*(_DWORD *)(a3 + 96);
      *(_OWORD *)(a3 + ++*(void *)(this + 112) = 0u;
      *(_OWORD *)(a3 + 128) = 0u;
      *(void *)(a3 + ++*(void *)(this + 112) = *(void *)(v5 + 112);
      *(void *)(v5 + ++*(void *)(this + 112) = 0;
      *(void *)(a3 + 136) = *(void *)(v5 + 136);
      *(void *)(v5 + 136) = 0;
      uint64_t v17 = *(void *)(a3 + 120);
      uint64_t v16 = *(void *)(a3 + 128);
      uint64_t v18 = *(void *)(v5 + 128);
      *(void *)(a3 + 120) = *(void *)(v5 + 120);
      *(void *)(a3 + 128) = v18;
      *(void *)(v5 + 120) = v17;
      *(void *)(v5 + 128) = v16;
      re::DynamicString::deinit((re::DynamicString *)(v5 + 112));
      re::DynamicArray<unsigned long>::deinit(v5 + 72);
      re::DynamicArray<unsigned long>::deinit(v5 + 32);
      re::DynamicString::deinit((re::DynamicString *)v5);
      v5 += 144;
      a3 += 144;
    }
    while (v5 != a2);
  }
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetLoadDescriptor *,re::AssetLoadDescriptor *,re::AssetLoadDescriptor *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    re::DynamicString::operator=((re::DynamicString *)(a4 + v7), (re::DynamicString *)(a2 + v7));
    re::DynamicArray<BOOL>::operator=(a4 + v7 + 32, (uint64_t *)(a2 + v7 + 32));
    re::DynamicArray<BOOL>::operator=(a4 + v7 + 72, (uint64_t *)(a2 + v7 + 72));
    re::DynamicString::operator=((re::DynamicString *)(a4 + v7 + 112), (re::DynamicString *)(a2 + v7 + 112));
    v7 += 144;
  }
  while (a2 + v7 != v6);
  return v6;
}

double re::Event<re::NetworkSystem,re::ecs2::Component *>::addSubscription(_DWORD *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf((uint64_t)a1, (void *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (a1[20])
    {
      v6[0] = 1;
      long long v5 = *(_OWORD *)(a2 + 16);
      long long v7 = *(_OWORD *)a2;
      long long v8 = v5;
      *(void *)&double result = re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 10), (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(void *)&double result = re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)a1, a2).n128_u64[0];
    }
  }
  return result;
}

__n128 re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 40 * v4;
  __n128 result = *(__n128 *)a2;
  long long v7 = *(_OWORD *)(a2 + 16);
  *(void *)(v5 + 32) = *(void *)(a2 + 32);
  *(__n128 *)uint64_t v5 = result;
  *(_OWORD *)(v5 + 16) = v7;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void *re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::Event<re::NetworkSystem,re::ecs2::Component *>::createSubscription<re::NetworkAssetManager>(re::NetworkAssetManager *,REEventHandlerResult (re::NetworkAssetManager::*)(re::NetworkSystem*,re::ecs2::Component *))::{lambda(re::NetworkSystem*,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription const&,re::ecs2::Component *&&)#1}::__invoke(uint64_t a1, void *a2, void *a3)
{
  unint64_t v4 = (uint64_t (*)(void *, uint64_t, void))a2[1];
  uint64_t v5 = a2[2];
  BOOL v6 = (void *)(*a2 + (v5 >> 1));
  if (v5) {
    unint64_t v4 = *(uint64_t (**)(void *, uint64_t, void))(*v6 + v4);
  }
  return v4(v6, a1, *a3);
}

void re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::removeAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = v5 + 8 * v2;
    uint64_t v7 = *(void *)(v5 + 8 * a2);
    *(void *)(v5 + 8 * a2) = *(void *)(v6 - 8);
    *(void *)(v6 - 8) = v7;
  }
  uint64_t v8 = *(void *)(a1 + 32) + 8 * v2;
  uint64_t v9 = *(void *)(v8 - 8);
  if (v9)
  {

    *(void *)(v8 - 8) = 0;
    uint64_t v4 = *(void *)(a1 + 16) - 1;
  }
  *(void *)(a1 + 16) = v4;
  ++*(_DWORD *)(a1 + 24);
}

void *re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::add(void *this, uint64_t *a2)
{
  unint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  uint64_t v5 = *a2;
  *(void *)(v3[4] + 8 * v4) = *a2;
  if (v5)
  {
    this = (id)(v5 + 8);
    unint64_t v4 = v3[2];
  }
  _OWORD v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void *re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          uint64_t v2 = 8 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_15;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 8 * v9;
        uint64_t v11 = v7;
        uint64_t v12 = (void *)v5[4];
        do
        {
          *v11++ = *v12;
          *v12++ = 0;
          v10 -= 8;
        }
        while (v10);
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

void re::make::shared::object<re::ecs2::Scene,re::ConstStringID>(re *a1@<X0>, re::ecs2::Scene **a2@<X8>)
{
  unint64_t v4 = re::globalAllocators(a1);
  uint64_t v5 = (re::ecs2::Scene *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 384, 8);
  uint64_t v6 = (char *)*((void *)a1 + 1);
  *(void *)&v7.var0 = 2 * *(void *)a1;
  v7.var1 = v6;
  *a2 = re::ecs2::Scene::Scene(v5, &v7);
  re::StringID::destroyString((re::StringID *)&v7);
}

double re::make::shared::inplace<re::ecs2::NetworkAssetComponent>@<D0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + ++*(void *)(this + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(void *)(v4 + 16) = 0;
  *(unsigned char *)(v4 + 24) = 0;
  *(void *)uint64_t v4 = &unk_26E6C9228;
  *(_OWORD *)(v4 + re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::clear((uint64_t)this + 56) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  uint64_t v5 = (void *)(v4 + 40);
  re::DynamicString::setCapacity(v5, 0);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(void *)&double result = 0x7FFFFFFFLL;
  *(void *)(a1 + 148) = 0x7FFFFFFFLL;
  *(unsigned char *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_DWORD *)(a1 + 200) = 0;
  *(void *)(a1 + 204) = 0x7FFFFFFFLL;
  *a2 = a1;
  return result;
}

void re::ecs2::NetworkAssetComponent::~NetworkAssetComponent(re::ecs2::NetworkAssetComponent *this)
{
  *(void *)this = &unk_26E6C9228;
  uint64_t v2 = (re::ecs2::NetworkAssetComponent *)((char *)this + 40);
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 21);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 14);
  re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)this + 72);
  re::DynamicString::deinit(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  re::DynamicString *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E6C9228;
  uint64_t v2 = (re::ecs2::NetworkAssetComponent *)((char *)this + 40);
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 21);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 14);
  re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)this + 72);
  re::DynamicString::deinit(v2);
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

double re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::EntryWithoutHash::free((_DWORD *)(a1[2] + v3));
        ++v4;
        v3 += 56;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::EntryWithoutHash::free(_DWORD *a1)
{
  if ((*a1 & 0x80000000) != 0)
  {
    *a1 &= ~0x80000000;
    re::StringID::destroyString((re::StringID *)(a1 + 2));
    return re::DynamicString::deinit((re::DynamicString *)(a1 + 6));
  }
  return result;
}

uint64_t re::DynamicArray<re::AssetLoadDescriptor>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 144 * v4;
        do
        {
          re::DynamicString::deinit((re::DynamicString *)(v3 + 112));
          re::DynamicArray<unsigned long>::deinit(v3 + 72);
          re::DynamicArray<unsigned long>::deinit(v3 + 32);
          re::DynamicString::deinit((re::DynamicString *)v3);
          v3 += 144;
          v5 -= 144;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(void *)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::ecs2::AssetPreloadComponent::~AssetPreloadComponent(re::ecs2::AssetPreloadComponent *this)
{
  *(void *)this = &unk_26E6C92B0;
  re::AssetHandle::~AssetHandle((re::ecs2::AssetPreloadComponent *)((char *)this + 32));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6C92B0;
  re::AssetHandle::~AssetHandle((re::ecs2::AssetPreloadComponent *)((char *)this + 32));
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

void re::ecs2::AssetStateComponent::~AssetStateComponent(re::ecs2::AssetStateComponent *this)
{
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((void *)re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

void re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(void *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)v8, (re::DynamicString *)(v8 + 16), (void *)(v8 + 48));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 56;
    }
  }
}

void re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &unk_2343655D0, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      unint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = *(void *)(a1 + 16);
        int v7 = *(_DWORD *)(v6 + v5);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v5) = v7 & 0x7FFFFFFF;
          re::DynamicString::deinit((re::DynamicString *)(v6 + v5 + 8));
          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        ++v4;
        v5 += 56;
      }
      while (v4 < v3);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (re::DynamicString *)(*(void *)&v13[16] + v10 + 16));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

uint64_t re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, void *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 56 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 56 * v10) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v10 + 16), a4);
  uint64_t v14 = *(void *)(a1 + 8);
  *(void *)(*(void *)(a1 + 16) + 56 * v10 + 48) = *a5;
  *(_DWORD *)(v14 + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DynamicString&>(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, const re::DynamicString *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v9);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  uint64_t v14 = 56 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v14) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(void *)(a1 + 16) + 56 * v9 + 8), a4);
  re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v9 + 24), a5);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v15, 0, 36);
      *(void *)&v15[36] = 0x7FFFFFFFLL;
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v15, v4, a2);
      long long v5 = *(_OWORD *)v15;
      *(_OWORD *)uint64_t v15 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v15[16];
      *(void *)&unsigned char v15[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v15[24];
      *(_OWORD *)&v15[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v15[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v15[16] + v10) & 0x80000000) != 0)
          {
            unint64_t v12 = 0xBF58476D1CE4E5B9
                * ((*(void *)(*(void *)&v15[16] + v10 + 8) >> 31) ^ (*(void *)(*(void *)&v15[16] + v10 + 8) >> 1));
            unint64_t v13 = (0x94D049BB133111EBLL * (v12 ^ (v12 >> 27))) ^ ((0x94D049BB133111EBLL * (v12 ^ (v12 >> 27))) >> 31);
            re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(a1, v13 % *(unsigned int *)(a1 + 24), v13, (StringID *)(*(void *)&v15[16] + v10 + 8));
            unsigned int v9 = *(_DWORD *)&v15[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)v15);
    }
  }
  else
  {
    if (a2) {
      signed int v14 = a2;
    }
    else {
      signed int v14 = 3;
    }
  }
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v9);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 56 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  uint64_t v14 = 56 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v14) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v9) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(void *)(a1 + 16) + 56 * v9 + 8), a4);
  uint64_t v15 = *(void *)(a1 + 16) + 56 * v9;
  *(_OWORD *)(v15 + 40) = 0u;
  *(_OWORD *)(v15 + 24) = 0u;
  *(void *)(v15 + 48) = a5[3];
  uint64_t v16 = a5[1];
  *(void *)(v15 + 24) = *a5;
  *a5 = 0;
  uint64_t v17 = a5[2];
  a5[3] = 0;
  uint64_t v19 = *(void *)(v15 + 32);
  uint64_t v18 = *(void *)(v15 + 40);
  *(void *)(v15 + 32) = v16;
  *(void *)(v15 + 40) = v17;
  a5[1] = v19;
  a5[2] = v18;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(uint64_t a1, uint64_t a2)
{
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
  unsigned int v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4) {
    re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, v4);
  }
  unint64_t v5 = *(unsigned int *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      if ((*(_DWORD *)(v8 + v6) & 0x80000000) != 0)
      {
        unint64_t v9 = 0xBF58476D1CE4E5B9 * ((*(void *)(v8 + v6 + 8) >> 31) ^ (*(void *)(v8 + v6 + 8) >> 1));
        unint64_t v10 = (0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) ^ ((0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) >> 31);
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DynamicString&>(a1, v10 % *(unsigned int *)(a1 + 24), v10, (StringID *)(v8 + v6 + 8), (const re::DynamicString *)(v8 + v6 + 24));
        unint64_t v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 56;
    }
  }
}

uint64_t re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      int v12 = *(_DWORD *)(a1 + 28);
      signed int v13 = 2 * v12;
      uint64_t v14 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v13) {
          BOOL v15 = v10 == v13;
        }
        else {
          BOOL v15 = 1;
        }
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v28, 0, 36);
          *(void *)&v28[36] = 0x7FFFFFFFLL;
          re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v28, v14, v13);
          long long v16 = *(_OWORD *)v28;
          *(_OWORD *)BOOL v28 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          uint64_t v17 = *(void *)&v28[16];
          uint64_t v18 = *(void *)(a1 + 16);
          *(void *)&v28[16] = v18;
          *(void *)(a1 + 16) = v17;
          long long v20 = *(_OWORD *)&v28[24];
          *(_OWORD *)&v28[24] = *(_OWORD *)(a1 + 24);
          unsigned int v19 = *(_DWORD *)&v28[32];
          *(_OWORD *)(a1 + 24) = v20;
          unint64_t v21 = v19;
          if (v19)
          {
            unint64_t v22 = 0;
            uint64_t v23 = v18 + 16;
            do
            {
              if ((*(_DWORD *)(v23 - 8) & 0x80000000) != 0) {
                re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)(v23 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v23 - 16), v23, v23 + 8);
              }
              ++v22;
              v23 += 48;
            }
            while (v22 < v21);
          }
          re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v28);
        }
      }
      else
      {
        if (v13) {
          signed int v26 = 2 * v12;
        }
        else {
          signed int v26 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v24 = *(void *)(a1 + 16);
    int v25 = *(_DWORD *)(v24 + 48 * v10 + 8);
  }
  else
  {
    uint64_t v24 = *(void *)(a1 + 16);
    int v25 = *(_DWORD *)(v24 + 48 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v25 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v24 + 48 * v10 + 8) = v25 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 48 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 48 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 48 * v10) = a3;
  *(void *)(*(void *)(a1 + 16) + 48 * v10 + 16) = *a4;
  uint64_t result = re::ecs2::EntityHandle::EntityHandle(*(void *)(a1 + 16) + 48 * v10 + 24, a5);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return result;
}