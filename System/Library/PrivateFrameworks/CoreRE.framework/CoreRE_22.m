void re::InlineRenderGraphProvider::~InlineRenderGraphProvider(re::InlineRenderGraphProvider *this)
{
  char *v2;

  *(void *)this = &unk_26E713AC8;
  v2 = (char *)this + 40;
  re::FunctionBase<24ul,void ()(char const*,char const*,re::RenderFrame &)>::destroyCallable((uint64_t)this + 80);
  re::FunctionBase<24ul,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::destroyCallable((uint64_t)v2);
  *(void *)this = &unk_26E6D52C8;
  re::DynamicString::deinit((re::InlineRenderGraphProvider *)((char *)this + 8));
}

{
  char *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E713AC8;
  v2 = (char *)this + 40;
  re::FunctionBase<24ul,void ()(char const*,char const*,re::RenderFrame &)>::destroyCallable((uint64_t)this + 80);
  re::FunctionBase<24ul,unsigned long long ()(char const*,char const*,re::RenderFrame &)>::destroyCallable((uint64_t)v2);
  *(void *)this = &unk_26E6D52C8;
  re::DynamicString::deinit((re::InlineRenderGraphProvider *)((char *)this + 8));
  JUMPOUT(0x237DBCBD0);
}

void re::IBLContext::createConstantBuffer(uint64_t a1, re::FrameContext *this, re::BufferTable *a3, long long *a4)
{
  re::FrameContext::perFrameAlloc(this, 0xD0uLL, 0x10uLL, (uint64_t)&v36);
  uint64_t v7 = v36 + v37;
  uint64_t v35 = 0x262DF9A294ABAC1CLL;
  uint64_t v36 = v38;
  re::BufferTable::setBuffer(a3, (const re::WeakStringID *)&v35, (const BufferView *)&v36);
  *(_DWORD *)(v7 + 8) = 0;
  *(void *)uint64_t v7 = 1065353216;
  *(_DWORD *)(v7 + 24) = 0;
  *(void *)(v7 + 16) = 0x3F80000000000000;
  *(_DWORD *)(v7 + 40) = 1065353216;
  *(void *)(v7 + 32) = 0;
  *(void *)(v7 + 48) = 0;
  *(_OWORD *)(v7 + 64) = 0u;
  long long v8 = *a4;
  long long v9 = a4[1];
  long long v10 = a4[2];
  *(_DWORD *)(v7 + 88) = *((void *)a4 + 1);
  *(void *)(v7 + 80) = v8;
  *(_DWORD *)(v7 + 104) = DWORD2(v9);
  *(void *)(v7 + 96) = v9;
  *(_DWORD *)(v7 + 120) = DWORD2(v10);
  *(void *)(v7 + 112) = v10;
  *(_DWORD *)(v7 + 128) = 0;
  *(_DWORD *)(v7 + 152) = 0;
  *(void *)(v7 + 144) = 1065353216;
  *(_DWORD *)(v7 + 168) = 0;
  *(void *)(v7 + 160) = 0x3F80000000000000;
  *(_DWORD *)(v7 + 184) = 1065353216;
  *(void *)(v7 + 176) = 0;
  *(void *)(v7 + 192) = 0;
  uint64_t v11 = *(void *)(a1 + 16);
  if (v11)
  {
    uint64_t v12 = *(void *)(a1 + 32);
    v13 = (long long *)(v12 + 224 * v11);
    for (i = (id *)(v12 + 192); ; i += 28)
    {
      v15 = (long long *)(i - 24);
      id v16 = *(i - 24);
      id v17 = *(i - 23);
      float v18 = *((float *)i - 44);
      long long v31 = *((_OWORD *)i - 10);
      long long v32 = *((_OWORD *)i - 9);
      int v19 = *((_DWORD *)i - 28);
      long long v33 = *((_OWORD *)i - 6);
      long long v34 = *((_OWORD *)i - 8);
      float v20 = *((float *)i - 20);
      id v21 = *(i - 9);
      id v22 = *(i - 8);
      uint64_t v23 = (uint64_t)*(i - 7);
      id v24 = *(i - 6);
      id v25 = *(i - 5);
      v26 = v25;
      if (*((unsigned char *)i + 17)) {
        break;
      }
      if (v25) {

      }
      if (v24) {
      if (v22)
      }

      if (v21) {
      if (v17)
      }

      if (v16) {
      if (v15 + 14 == v13)
      }
        return;
    }
    long long v29 = *((_OWORD *)i - 1);
    long long v30 = *(_OWORD *)i;
    long long v28 = *((_OWORD *)i - 2);
    float v27 = exp2f(v18);
    *(_DWORD *)(v7 + 8) = DWORD2(v31);
    *(void *)uint64_t v7 = v31;
    *(_DWORD *)(v7 + 24) = DWORD2(v32);
    *(void *)(v7 + 16) = v32;
    *(_DWORD *)(v7 + 40) = DWORD2(v34);
    *(void *)(v7 + 32) = v34;
    *(float *)(v7 + 48) = v27;
    *(_DWORD *)(v7 + 52) = v19;
    *(_OWORD *)(v7 + 64) = v33;
    *(float *)(v7 + 128) = v20 * 0.5;
    *(_DWORD *)(v7 + 152) = DWORD2(v28);
    *(void *)(v7 + 144) = v28;
    *(_DWORD *)(v7 + 168) = DWORD2(v29);
    *(void *)(v7 + 160) = v29;
    *(_DWORD *)(v7 + 184) = DWORD2(v30);
    *(void *)(v7 + 176) = v30;
    *(void *)(v7 + 192) = v23;
    if (v26) {

    }
    if (v24) {
    if (v22)
    }

    if (v21) {
    if (v17)
    }

    if (v16) {
  }
    }
}

void re::IBLContext::updateSceneTextures(id *this, re::TextureTable *a2)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  id v22 = (id)0xE459D7324435E49;
  re::TextureTable::setTexture(a2, (uint64_t *)&v22, this + 5);
  id v4 = this[2];
  if (v4)
  {
    v5 = (char *)this[4];
    v6 = &v5[224 * (void)v4];
    while (1)
    {
      id v7 = *(id *)v5;
      id v22 = v7;
      id v8 = *((id *)v5 + 1);
      id v23 = v8;
      long long v10 = *((_OWORD *)v5 + 2);
      long long v9 = *((_OWORD *)v5 + 3);
      long long v24 = *((_OWORD *)v5 + 1);
      long long v25 = v10;
      long long v26 = v9;
      long long v12 = *((_OWORD *)v5 + 5);
      long long v11 = *((_OWORD *)v5 + 6);
      long long v13 = *((_OWORD *)v5 + 4);
      *(void *)&v29[14] = *(void *)(v5 + 110);
      long long v28 = v12;
      *(_OWORD *)long long v29 = v11;
      long long v27 = v13;
      id v14 = *((id *)v5 + 15);
      id v30 = v14;
      id v15 = *((id *)v5 + 16);
      v31[0] = v15;
      v31[1] = *((id *)v5 + 17);
      id v16 = *((id *)v5 + 18);
      id v32 = v16;
      id v17 = *((id *)v5 + 19);
      id v33 = v17;
      long long v19 = *((_OWORD *)v5 + 11);
      long long v18 = *((_OWORD *)v5 + 12);
      long long v20 = *((_OWORD *)v5 + 10);
      __int16 v37 = *((_WORD *)v5 + 104);
      long long v35 = v19;
      long long v36 = v18;
      long long v34 = v20;
      if (HIBYTE(v37)) {
        break;
      }
      if (v17) {

      }
      if (v16) {
      if (v15)
      }

      if (v14) {
      if (v8)
      }

      if (v7) {
      v5 += 224;
      }
      if (v5 == v6) {
        return;
      }
    }
    uint64_t v21 = 0xC0489AC946E8FF4;
    re::TextureTable::setTexture(a2, &v21, &v23);
    uint64_t v21 = 0x74B9011688CA44FFLL;
    re::TextureTable::setTexture(a2, &v21, &v22);
    if (v29[21])
    {
      uint64_t v21 = 0x23C1563FB78C78B1;
      re::TextureTable::setTexture(a2, &v21, v31);
      uint64_t v21 = 0x5495C6E7C96973E2;
      re::TextureTable::setTexture(a2, &v21, &v30);
    }
    if (v33)
    {

      id v33 = 0;
    }
    if (v32)
    {

      id v32 = 0;
    }
    if (v31[0])
    {

      v31[0] = 0;
    }
    if (v30)
    {

      id v30 = 0;
    }
    if (v23)
    {

      id v23 = 0;
    }
    if (v22) {
  }
    }
}

void re::IBLContext::updateRenderSceneContextFlags(re::IBLContext *this, BOOL *a2, BOOL *a3)
{
  uint64_t v3 = *((void *)this + 2);
  if (v3)
  {
    uint64_t v6 = *((void *)this + 4);
    uint64_t v15 = v6 + 224 * v3;
    do
    {
      id v7 = *(id *)v6;
      id v8 = *(id *)(v6 + 8);
      int v9 = *(unsigned __int8 *)(v6 + 116);
      int v10 = *(unsigned __int8 *)(v6 + 117);
      id v11 = *(id *)(v6 + 120);
      id v12 = *(id *)(v6 + 128);
      id v13 = *(id *)(v6 + 144);
      id v14 = *(id *)(v6 + 152);
      if (*(unsigned char *)(v6 + 209))
      {
        *a2 = (v9 | *a2) != 0;
        *a3 = (v10 | *a3) != 0;
      }
      if (v14) {

      }
      if (v13) {
      if (v12)
      }

      if (v11) {
      if (v8)
      }

      if (v7) {
      v6 += 224;
      }
    }
    while (v6 != v15);
  }
}

void re::VirtualEnvironmentProbeContext::updateSceneTextures(re::VirtualEnvironmentProbeContext *this, re::TextureTable *a2)
{
  unint64_t v4 = 0;
  uint64_t v15 = *MEMORY[0x263EF8340];
  for (char i = 1; ; char i = 0)
  {
    char v6 = i;
    if (v4 >= *((void *)this + 2)) {
      goto LABEL_6;
    }
    id v7 = (id *)*((void *)this + 4);
    if ((i & 1) == 0) {
      break;
    }
    *(void *)&long long v10 = 0x456D423E25537F70;
    re::TextureTable::setTexture(a2, (uint64_t *)&v10, v7);
    if (!*((void *)this + 2))
    {
      long long v13 = 0u;
      long long v14 = 0u;
      long long v11 = 0u;
      long long v12 = 0u;
      long long v10 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_12:
      long long v13 = 0u;
      long long v14 = 0u;
      long long v11 = 0u;
      long long v12 = 0u;
      long long v10 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    id v8 = (id *)(*((void *)this + 4) + 8);
    *(void *)&long long v10 = 0x456D423E247CF466;
    re::TextureTable::setTexture(a2, (uint64_t *)&v10, v8);
LABEL_6:
    unint64_t v4 = 1;
    if ((v6 & 1) == 0) {
      return;
    }
  }
  *(void *)&long long v10 = 0x456D423E25537F71;
  re::TextureTable::setTexture(a2, (uint64_t *)&v10, v7 + 3);
  if (*((void *)this + 2) <= 1uLL) {
    goto LABEL_12;
  }
  int v9 = (id *)(*((void *)this + 4) + 32);
  *(void *)&long long v10 = 0x456D423E247CF467;
  re::TextureTable::setTexture(a2, (uint64_t *)&v10, v9);
}

uint64_t re::VirtualEnvironmentProbeContext::createTextureBuffer(re::VirtualEnvironmentProbeContext *this, re::FrameContext *a2, re::BufferTable *a3)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (([*(id *)a2 supportsFamily:5001] & 1) != 0 || !*((void *)this + 2))
  {
    re::FrameContext::perFrameAlloc(a2, 0x20uLL, 0x10uLL, (uint64_t)v38);
    uint64_t v29 = 0x458FBDFDF334653DLL;
    unint64_t v15 = *(void *)&v38[8];
    *(void *)&long long v41 = *(void *)&v38[16];
    *((void *)&v41 + 1) = *(void *)&v38[8];
    re::BufferTable::setBuffer(a3, (const re::WeakStringID *)&v29, (const BufferView *)&v41);
    if (!(v15 >> 37)) {
      goto LABEL_40;
    }
    uint64_t v17 = *((void *)a2 + 3);
    uint64_t v18 = *(void *)v38 + v15;
    uint64_t v33 = 0;
    uint64_t v30 = 0;
    unint64_t v31 = 0;
    int v32 = 0;
    uint64_t v29 = v17;
    re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(&v29, 4uLL);
    unint64_t v10 = 0;
    ++v32;
    for (char i = 1; ; char i = 0)
    {
      char v20 = i;
      if (v10 >= *((void *)this + 2))
      {
        uint64_t v21 = (void *)(v18 + 8 * v10);
        *uint64_t v21 = 0;
        v21[2] = 0;
      }
      else
      {
        *(void *)(v18 + 8 * v10) = objc_msgSend(*(id *)(*((void *)this + 4) + 24 * v10), sel_gpuResourceID);
        unint64_t v13 = *((void *)this + 2);
        if (v13 <= v10)
        {
          uint64_t v22 = 0;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v41 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v35 = 136315906;
          *(void *)&v35[4] = "operator[]";
          *(_WORD *)&v35[12] = 1024;
          *(_DWORD *)&v35[14] = 797;
          *(_WORD *)&v35[18] = 2048;
          *(void *)&v35[20] = v10;
          __int16 v36 = 2048;
          *(void *)__int16 v37 = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_35:
          uint64_t v22 = 0;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v41 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v35 = 136315906;
          *(void *)&v35[4] = "operator[]";
          *(_WORD *)&v35[12] = 1024;
          *(_DWORD *)&v35[14] = 797;
          *(_WORD *)&v35[18] = 2048;
          *(void *)&v35[20] = v10;
          __int16 v36 = 2048;
          *(void *)__int16 v37 = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_36:
          uint64_t v22 = 0;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v41 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v35 = 136315906;
          *(void *)&v35[4] = "operator[]";
          *(_WORD *)&v35[12] = 1024;
          *(_DWORD *)&v35[14] = 797;
          *(_WORD *)&v35[18] = 2048;
          *(void *)&v35[20] = v10;
          __int16 v36 = 2048;
          *(void *)__int16 v37 = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_37:
          uint64_t v34 = 0;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v41 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v38 = 136315906;
          *(void *)&v38[4] = "operator[]";
          *(_WORD *)&v38[12] = 1024;
          *(_DWORD *)&v38[14] = 797;
          *(_WORD *)&v38[18] = 2048;
          *(void *)&v38[20] = v10;
          __int16 v39 = 2048;
          unint64_t v40 = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_38:
          uint64_t v34 = 0;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v41 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v38 = 136315906;
          *(void *)&v38[4] = "operator[]";
          *(_WORD *)&v38[12] = 1024;
          *(_DWORD *)&v38[14] = 797;
          *(_WORD *)&v38[18] = 2048;
          *(void *)&v38[20] = v10;
          __int16 v39 = 2048;
          unint64_t v40 = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_39:
          uint64_t v34 = 0;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v41 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)uint64_t v38 = 136315906;
          *(void *)&v38[4] = "operator[]";
          *(_WORD *)&v38[12] = 1024;
          *(_DWORD *)&v38[14] = 797;
          *(_WORD *)&v38[18] = 2048;
          *(void *)&v38[20] = v10;
          __int16 v39 = 2048;
          unint64_t v40 = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_40:
          re::internal::assertLog((re::internal *)6, v16, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
          _os_crash();
          __break(1u);
        }
        *(void *)(v18 + 8 * v10 + 16) = objc_msgSend(*(id *)(*((void *)this + 4) + 24 * v10 + 8), sel_gpuResourceID);
        unint64_t v13 = *((void *)this + 2);
        if (v13 <= v10) {
          goto LABEL_35;
        }
        *(void *)&long long v41 = *(id *)(*((void *)this + 4) + 24 * v10);
        re::DynamicArray<re::SharedPtr<re::ShareableInternal<re::GeomInstance>>>::add(&v29, &v41);
        if ((void)v41) {

        }
        unint64_t v13 = *((void *)this + 2);
        if (v13 <= v10) {
          goto LABEL_36;
        }
        *(void *)&long long v41 = *(id *)(*((void *)this + 4) + 24 * v10 + 8);
        re::DynamicArray<re::SharedPtr<re::ShareableInternal<re::GeomInstance>>>::add(&v29, &v41);
        if ((void)v41) {
      }
        }
      unint64_t v10 = 1;
      if ((v20 & 1) == 0)
      {
        *(void *)&long long v41 = 0x458FBDFDF334653DLL;
        re::BufferTable::setBufferUsedResources((uint64_t)a3, &v41, v33, v31);
        return re::DynamicArray<NS::SharedPtr<MTL::SamplerState>>::deinit((uint64_t)&v29);
      }
    }
  }
  uint64_t v33 = 0;
  uint64_t v30 = 0;
  unint64_t v31 = 0;
  int v32 = 0;
  uint64_t v29 = *((void *)a2 + 3);
  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(&v29, 2uLL);
  ++v32;
  id v28 = objc_msgSend(objc_msgSend(MEMORY[0x263F127B8], sel_alloc), sel_init);
  objc_msgSend(v28, sel_setIndex_, 0);
  objc_msgSend(v28, sel_setDataType_, 58);
  objc_msgSend(v28, sel_setAccess_, 0);
  objc_msgSend(v28, sel_setTextureType_, 5);
  objc_msgSend(v28, sel_setArrayLength_, 2);
  re::DynamicArray<NS::SharedPtr<NS::String>>::add((_anonymous_namespace_ *)&v29, &v28);
  id v27 = objc_msgSend(objc_msgSend(MEMORY[0x263F127B8], sel_alloc), sel_init);
  objc_msgSend(v27, sel_setIndex_, 2);
  objc_msgSend(v27, sel_setDataType_, 58);
  objc_msgSend(v27, sel_setAccess_, 0);
  objc_msgSend(v27, sel_setTextureType_, 5);
  objc_msgSend(v27, sel_setArrayLength_, 2);
  re::DynamicArray<NS::SharedPtr<NS::String>>::add((_anonymous_namespace_ *)&v29, &v27);
  re::DynamicArray<NS::SharedPtr<MTL::ArgumentDescriptor>>::DynamicArray((uint64_t)v25, &v29);
  re::mtl::Device::makeArgumentEncoder((id *)a2, (uint64_t)v25, &v26);
  re::DynamicArray<NS::SharedPtr<MTL::SamplerState>>::deinit((uint64_t)v25);
  id v6 = v26;
  re::FrameContext::perFrameAlloc(a2, (unint64_t)objc_msgSend(v26, sel_encodedLength), 0x10uLL, (uint64_t)&v22);
  *(void *)long long v35 = 0x458FBDFDF334653DLL;
  unsigned int v8 = v23;
  uint64_t v7 = v24;
  *(void *)&long long v41 = v24;
  *((void *)&v41 + 1) = v23;
  re::BufferTable::setBuffer(a3, (const re::WeakStringID *)v35, (const BufferView *)&v41);
  objc_msgSend(v6, sel_setArgumentBuffer_offset_, v7, v8);
  uint64_t v9 = *((void *)a2 + 3);
  *(void *)&v37[2] = 0;
  memset(&v35[8], 0, 20);
  *(void *)long long v35 = v9;
  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(v35, 4uLL);
  unint64_t v10 = 0;
  ++*(_DWORD *)&v35[24];
  char v11 = 1;
  do
  {
    char v12 = v11;
    if (v10 < *((void *)this + 2))
    {
      objc_msgSend(v6, sel_setTexture_atIndex_, *(void *)(*((void *)this + 4) + 24 * v10), v10);
      unint64_t v13 = *((void *)this + 2);
      if (v13 <= v10) {
        goto LABEL_37;
      }
      objc_msgSend(v6, sel_setTexture_atIndex_, *(void *)(*((void *)this + 4) + 24 * v10 + 8), v10 | 2);
      unint64_t v13 = *((void *)this + 2);
      if (v13 <= v10) {
        goto LABEL_38;
      }
      *(void *)&long long v41 = *(id *)(*((void *)this + 4) + 24 * v10);
      re::DynamicArray<re::SharedPtr<re::ShareableInternal<re::GeomInstance>>>::add(v35, &v41);
      if ((void)v41) {

      }
      unint64_t v13 = *((void *)this + 2);
      if (v13 <= v10) {
        goto LABEL_39;
      }
      *(void *)&long long v41 = *(id *)(*((void *)this + 4) + 24 * v10 + 8);
      re::DynamicArray<re::SharedPtr<re::ShareableInternal<re::GeomInstance>>>::add(v35, &v41);
      if ((void)v41) {
    }
      }
    char v11 = 0;
    unint64_t v10 = 1;
  }
  while ((v12 & 1) != 0);
  *(void *)&long long v41 = 0x458FBDFDF334653DLL;
  re::BufferTable::setBufferUsedResources((uint64_t)a3, &v41, *(uint64_t *)&v37[2], *(unint64_t *)&v35[16]);
  re::DynamicArray<NS::SharedPtr<MTL::SamplerState>>::deinit((uint64_t)v35);
  if (v6) {

  }
  if (v27) {
  if (v28)
  }

  return re::DynamicArray<NS::SharedPtr<MTL::SamplerState>>::deinit((uint64_t)&v29);
}

uint64_t re::BufferTable::setBufferUsedResources(uint64_t a1, void *a2, uint64_t a3, unint64_t a4)
{
  uint64_t result = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)a1, a2);
  if (result != -1)
  {
    unint64_t v8 = *(unsigned __int8 *)(*(void *)(a1 + 8) + 16 * result + 8);
    if (*(_DWORD *)(a1 + 280) > v8)
    {
      return re::BufferTable::setBufferIndirectResources((re::BufferTable *)a1, v8, a3, a4);
    }
  }
  return result;
}

void re::VirtualEnvironmentProbeContext::createConstantBuffer(re::VirtualEnvironmentProbeContext *this, re::FrameContext *a2, re::BufferTable *a3, float a4)
{
  re::FrameContext::perFrameAlloc(a2, 0x40uLL, 0x10uLL, (uint64_t)&v21);
  uint64_t v7 = v21;
  unsigned int v8 = v22;
  uint64_t v20 = 0x6C67F4CE96CFCB6ALL;
  uint64_t v21 = v23;
  re::BufferTable::setBuffer(a3, (const re::WeakStringID *)&v20, (const BufferView *)&v21);
  unint64_t v9 = 0;
  uint64_t v10 = v7 + v8;
  long long v11 = *((_OWORD *)this + 3);
  long long v12 = *((_OWORD *)this + 4);
  long long v13 = *((_OWORD *)this + 5);
  *(_DWORD *)(v10 + 8) = DWORD2(v11);
  *(void *)uint64_t v10 = v11;
  *(_DWORD *)(v10 + 24) = DWORD2(v12);
  *(_DWORD *)(v10 + 40) = DWORD2(v13);
  *(void *)(v10 + 16) = v12;
  *(void *)(v10 + 32) = v13;
  unint64_t v14 = *((void *)this + 2);
  *(_DWORD *)(v10 + 56) = v14;
  char v15 = 1;
  do
  {
    char v16 = v15;
    float v17 = 0.0;
    if (v9 < v14)
    {
      uint64_t v18 = *((void *)this + 4) + 24 * v9;
      float v19 = *(float *)(v18 + 20);
      float v17 = (float)(v19 * exp2f(*(float *)(v18 + 16))) * a4;
    }
    char v15 = 0;
    *(float *)(v10 + 4 * v9 + 48) = v17;
    unint64_t v9 = 1;
  }
  while ((v16 & 1) != 0);
}

void re::generatePrefilteredDiffuseIblTexture(uint64_t a1@<X0>, id *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, BOOL a5@<W4>, char a6@<W5>, uint8_t *a7@<X6>, id *a8@<X8>)
{
  uint64_t v75 = *MEMORY[0x263EF8340];
  id v52 = *(id *)(a1 + 184);
  unint64_t v13 = 256;
  if (a3 < 0x100) {
    unint64_t v13 = a3;
  }
  if (v13 <= 1) {
    unint64_t v14 = 1;
  }
  else {
    unint64_t v14 = v13;
  }
  id v15 = objc_msgSend(*a2, sel_width);
  id v16 = objc_msgSend(*a2, sel_height);
  if (v14 >= (unint64_t)v15) {
    id v17 = v15;
  }
  else {
    id v17 = (id)v14;
  }
  if (v14 >= (unint64_t)v16) {
    unint64_t v14 = (unint64_t)v16;
  }
  unsigned __int8 v51 = 0;
  uint64_t v18 = (re *)re::internal::chooseWritableTextureFormat((uint64_t)&v52, a2, a5, a6, &v51);
  float v19 = *re::graphicsLogObjects(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218496;
    *(void *)v64 = v17;
    *(_WORD *)&v64[8] = 2048;
    *(void *)&v64[10] = v14;
    __int16 v65 = 1024;
    int v66 = (int)v18;
    _os_log_impl(&dword_233120000, v19, OS_LOG_TYPE_DEFAULT, "Generating diffuse prefiltered %zux%zux6 cubemap of format %d\n", buf, 0x1Cu);
  }
  int v20 = v51;
  if (v51)
  {
    int v44 = re::translateSRGBPixelFormatToLinear((uint64_t)v18);
    uint64_t v21 = 19;
  }
  else
  {
    uint64_t v21 = 3;
    int v44 = (int)v18;
  }
  if (objc_msgSend(*a2, sel_isShareable)) {
    uint64_t v22 = 2;
  }
  else {
    uint64_t v22 = 0;
  }
  id v23 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  objc_msgSend(v23, sel_setTextureType_, 5);
  objc_msgSend(v23, sel_setWidth_, v17);
  objc_msgSend(v23, sel_setHeight_, v14);
  objc_msgSend(v23, sel_setPixelFormat_, v18);
  objc_msgSend(v23, sel_setMipmapLevelCount_, 1);
  objc_msgSend(v23, sel_setSampleCount_, objc_msgSend(*a2, sel_sampleCount));
  objc_msgSend(v23, sel_setUsage_, v21);
  objc_msgSend(v23, sel_setStorageMode_, v22);
  if (objc_msgSend(*a2, sel_isShareable)) {
    SharedTexture = (_anonymous_namespace_ *)re::mtl::Device::makeSharedTexture(v23, &v52, a8);
  }
  else {
    SharedTexture = (_anonymous_namespace_ *)re::mtl::Device::makeTexture(v23, &v52, a8);
  }
  buf[0] = 0;
  if (v20) {
    long long v25 = "generatePrefilteredDiffuseMapWithLinearToSRGB";
  }
  else {
    long long v25 = "generatePrefilteredDiffuseMap";
  }
  uint64_t v70 = 0;
  memset(v68, 0, sizeof(v68));
  int v69 = 0;
  char v71 = 0;
  char v72 = 0;
  uint64_t v73 = 0;
  char v74 = 0;
  id v26 = *(id *)re::getOrCreateComputePipelineState(a1, (uint64_t)buf);
  id v50 = (id)[v52 newCommandQueue];

  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97138, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97138))
  {
    re::ns::String::String((re::ns::String *)&_MergedGlobals_410, (re::ns *)"generatePrefilteredDiffuseMapQueue");
    __cxa_guard_release(&qword_26AF97138);
  }
  id v27 = (id)_MergedGlobals_410;
  [v50 setLabel:v27];

  re::mtl::CommandQueue::makeCommandBuffer(&v50, &v49);
  re::mtl::CommandBuffer::makeComputeCommandEncoder(&v49, &v48);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97148, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97148))
  {
    long long v42 = re::ns::String::String((re::ns::String *)&qword_26AF97140, (re::ns *)"Generate Diffuse IBL Texture");
    __cxa_guard_release((__guard *)v42 + 1);
  }
  id v28 = (id)qword_26AF97140;
  [v48 setLabel:v28];

  unsigned int v29 = objc_msgSend(v26, sel_threadExecutionWidth);
  uint64_t v30 = objc_msgSend(v26, sel_maxTotalThreadsPerThreadgroup) / v29;
  id v31 = objc_msgSend(*a8, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v44, 3, 0, 1, 0, 6);
  uint64_t v32 = (objc_msgSend(v31, sel_width) + v29 - 1) / v29;
  uint64_t v33 = (re *)objc_msgSend(v31, sel_height);
  uint64_t v34 = ((int)v30 + (int)v33 - 1) / v30;
  long long v35 = *re::graphicsLogObjects(v33);
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v56 = 67110400;
    *(_DWORD *)&v56[4] = v32;
    LOWORD(v57) = 1024;
    *(_DWORD *)((char *)&v57 + 2) = v34;
    HIWORD(v57) = 1024;
    *(_DWORD *)v58 = 6;
    *(_WORD *)&v58[4] = 1024;
    *(_DWORD *)&v58[6] = v29;
    __int16 v59 = 1024;
    int v60 = v30;
    __int16 v61 = 1024;
    int v62 = 1;
    _os_log_impl(&dword_233120000, v35, OS_LOG_TYPE_DEFAULT, "Dispatching %dx%dx%d thread groups of size %dx%dx%d\n", v56, 0x26u);
  }
  [v48 setComputePipelineState:v26];
  [v48 setTexture:*a2 atIndex:0];
  [v48 setTexture:v31 atIndex:1];
  int v47 = a4;
  id v36 = objc_msgSend(v52, sel_newBufferWithBytes_length_options_, &v47, 4, 0);
  [v48 setBuffer:v36 offset:0 atIndex:0];
  *(void *)v56 = v32;
  uint64_t v57 = v34;
  *(void *)v58 = 6;
  *(void *)v53 = v29;
  uint64_t v54 = v30;
  uint64_t v55 = 1;
  [v48 dispatchThreadgroups:v56 threadsPerThreadgroup:v53];
  [v48 endEncoding];
  re::mtl::CommandBuffer::makeBlitCommandEncoder(&v49, v56);
  [*(id *)v56 endEncoding];
  [v49 commit];
  [v49 waitUntilCompleted];
  re::mtl::CommandBuffer::error(&v49, v53);
  uint64_t v37 = [*(id *)v53 code];

  if (v37)
  {
    if (a7)
    {
      re::mtl::CommandBuffer::error(&v49, v53);
      if (v53 != a7)
      {
        id v39 = *(id *)v53;
        *(void *)v53 = 0;
        unint64_t v40 = *(void **)a7;
        *(void *)a7 = v39;
      }
    }
    long long v41 = *re::graphicsLogObjects(v38);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v53 = 0;
      _os_log_error_impl(&dword_233120000, v41, OS_LOG_TYPE_ERROR, "Internal Metal error while generating specular IBL cubemap. Execution likely took too long - Try again, and if the issue persists, lower samplesPerTexel.", v53, 2u);
    }
  }

  if (v36) {
  if (v31)
  }

  if (v26) {
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v68);
  }
  if (v67[0])
  {
    if (v67[1]) {
      (*(void (**)(void))(*(void *)v67[0] + 40))();
    }
    memset(v67, 0, sizeof(v67));
  }
  if (buf[0] && *(void *)&v64[4] && (v64[12] & 1) != 0) {
    (*(void (**)(void))(**(void **)&v64[4] + 40))();
  }
  if (v23) {
}
  }

uint64_t re::internal::chooseWritableTextureFormat(uint64_t a1, id *a2, BOOL a3, char a4, unsigned char *a5)
{
  *a5 = 0;
  int v8 = objc_msgSend(*a2, sel_pixelFormat);
  if (a4 & 1) != 0 || (re::isHDR(v8))
  {
    int v9 = 1;
    if (a3)
    {
LABEL_4:
      BOOL v10 = 1;
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v16 = 0;
    MTLPixelFormatGetInfoForDevice();
    int v9 = 0;
    if (a3) {
      goto LABEL_4;
    }
  }
  BOOL v10 = re::getComponentCount() == 1;
LABEL_7:
  if (objc_msgSend(*a2, sel_swizzle, v16) == 84148994) {
    BOOL v11 = v10;
  }
  else {
    BOOL v11 = a3;
  }
  BOOL v12 = !v11;
  if (v9)
  {
    unsigned int v13 = 115;
    unsigned int v14 = 25;
  }
  else
  {
    unsigned int v13 = 70;
    unsigned int v14 = 10;
  }
  if (v12) {
    return v13;
  }
  else {
    return v14;
  }
}

void re::generatePrefilteredSpecularIblTexture(uint64_t a1@<X0>, id *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, BOOL a5@<W4>, char a6@<W5>, uint8_t *a7@<X6>, id *a8@<X8>)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  id v64 = *(id *)(a1 + 184);
  unint64_t v13 = 1024;
  if (a3 < 0x400) {
    unint64_t v13 = a3;
  }
  if (v13 <= 1) {
    unint64_t v14 = 1;
  }
  else {
    unint64_t v14 = v13;
  }
  id v15 = objc_msgSend(*a2, sel_width);
  id v16 = objc_msgSend(*a2, sel_height);
  if (v14 >= (unint64_t)v15) {
    unint64_t v17 = (unint64_t)v15;
  }
  else {
    unint64_t v17 = v14;
  }
  if (v14 >= (unint64_t)v16) {
    id v18 = v16;
  }
  else {
    id v18 = (id)v14;
  }
  v53 = a2;
  unint64_t v54 = (unint64_t)(floor(log2((double)v17)) + 1.0);
  unsigned __int8 v63 = 0;
  float v19 = (re *)re::internal::chooseWritableTextureFormat((uint64_t)&v64, a2, a5, a6, &v63);
  unsigned int v20 = v19;
  int v21 = v63;
  if (v63)
  {
    float v19 = (re *)re::translateSRGBPixelFormatToLinear((uint64_t)v19);
    int v22 = (int)v19;
    uint64_t v23 = 19;
  }
  else
  {
    uint64_t v23 = 3;
    int v22 = (int)v19;
  }
  uint64_t v24 = *re::graphicsLogObjects(v19);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218752;
    *(void *)v76 = v17;
    *(_WORD *)&v76[8] = 2048;
    *(void *)&v76[10] = v18;
    __int16 v77 = 1024;
    v78[0] = v20;
    LOWORD(v78[1]) = 2048;
    *(void *)((char *)&v78[1] + 2) = v54;
    _os_log_impl(&dword_233120000, v24, OS_LOG_TYPE_DEFAULT, "Generating prefiltered %zux%zux6 cubemap of format %d with %zu mip-levels\n", buf, 0x26u);
  }
  id v25 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  objc_msgSend(v25, sel_setTextureType_, 5);
  objc_msgSend(v25, sel_setWidth_, v17);
  objc_msgSend(v25, sel_setHeight_, v18);
  objc_msgSend(v25, sel_setPixelFormat_, v20);
  objc_msgSend(v25, sel_setMipmapLevelCount_, v54);
  objc_msgSend(v25, sel_setSampleCount_, objc_msgSend(*a2, sel_sampleCount));
  objc_msgSend(v25, sel_setUsage_, v23);
  if (objc_msgSend(*a2, sel_isShareable)) {
    uint64_t v26 = 2;
  }
  else {
    uint64_t v26 = 0;
  }
  objc_msgSend(v25, sel_setStorageMode_, v26);
  if (objc_msgSend(*a2, sel_isShareable)) {
    SharedTexture = (_anonymous_namespace_ *)re::mtl::Device::makeSharedTexture(v25, &v64, a8);
  }
  else {
    SharedTexture = (_anonymous_namespace_ *)re::mtl::Device::makeTexture(v25, &v64, a8);
  }
  buf[0] = 0;
  if (v21) {
    id v28 = "generatePrefilteredSpecularMapWithLinearToSRGB";
  }
  else {
    id v28 = "generatePrefilteredSpecularMap";
  }
  uint64_t v82 = 0;
  memset(v80, 0, sizeof(v80));
  int v81 = 0;
  char v83 = 0;
  char v84 = 0;
  uint64_t v85 = 0;
  char v86 = 0;
  id v29 = *(id *)re::getOrCreateComputePipelineState(a1, (uint64_t)buf);
  id v62 = (id)[v64 newCommandQueue];

  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97158, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97158))
  {
    re::ns::String::String((re::ns::String *)&qword_26AF97150, (re::ns *)"generatePrefilteredSpecularMapQueue");
    __cxa_guard_release(&qword_26AF97158);
  }
  id v50 = v25;
  id v30 = (id)qword_26AF97150;
  [v62 setLabel:v30];

  re::mtl::CommandQueue::makeCommandBuffer(&v62, &v61);
  re::mtl::CommandBuffer::makeComputeCommandEncoder(&v61, &v60);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97168, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97168))
  {
    id v48 = re::ns::String::String((re::ns::String *)&qword_26AF97160, (re::ns *)"Generate Specular IBL Texture");
    __cxa_guard_release((__guard *)v48 + 1);
  }
  id v31 = (id)qword_26AF97160;
  [v60 setLabel:v31];

  unsigned int v32 = objc_msgSend(v29, sel_threadExecutionWidth);
  unsigned int v33 = objc_msgSend(v29, sel_maxTotalThreadsPerThreadgroup);
  if (v54)
  {
    uint64_t v34 = 0;
    uint64_t v35 = v33 / v32;
    uint64_t v36 = v22;
    do
    {
      id v37 = objc_msgSend(*a8, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v36, 3, v34, 1, 0, 6);
      uint64_t v38 = (objc_msgSend(v37, sel_width) + v32 - 1) / v32;
      id v39 = (re *)objc_msgSend(v37, sel_height);
      uint64_t v40 = ((int)v35 - 1 + (int)v39) / v35;
      long long v41 = *re::graphicsLogObjects(v39);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v68 = 67110400;
        *(_DWORD *)&v68[4] = v38;
        LOWORD(v69) = 1024;
        *(_DWORD *)((char *)&v69 + 2) = v40;
        HIWORD(v69) = 1024;
        *(_DWORD *)uint64_t v70 = 6;
        *(_WORD *)&v70[4] = 1024;
        *(_DWORD *)&v70[6] = v32;
        __int16 v71 = 1024;
        int v72 = v35;
        __int16 v73 = 1024;
        int v74 = 1;
        _os_log_impl(&dword_233120000, v41, OS_LOG_TYPE_DEFAULT, "Dispatching %dx%dx%d thread groups of size %dx%dx%d\n", v68, 0x26u);
      }
      [v60 setComputePipelineState:v29];
      [v60 setTexture:*v53 atIndex:0];
      [v60 setTexture:v37 atIndex:1];
      uint64_t v55 = 0;
      int v56 = 0;
      int v57 = v34;
      int v58 = v54;
      int v59 = a4;
      id v42 = objc_msgSend(v64, sel_newBufferWithBytes_length_options_, &v55, 24, 0);
      [v60 setBuffer:v42 offset:0 atIndex:0];
      *(void *)v68 = v38;
      uint64_t v69 = v40;
      *(void *)uint64_t v70 = 6;
      *(void *)__int16 v65 = v32;
      uint64_t v66 = v35;
      uint64_t v67 = 1;
      [v60 dispatchThreadgroups:v68 threadsPerThreadgroup:v65];
      if (v42) {

      }
      if (v37) {
      ++v34;
      }
    }
    while (v54 != v34);
  }
  [v60 endEncoding];
  re::mtl::CommandBuffer::makeBlitCommandEncoder(&v61, v68);
  [*(id *)v68 endEncoding];
  [v61 commit];
  [v61 waitUntilCompleted];
  re::mtl::CommandBuffer::error(&v61, v65);
  uint64_t v43 = [*(id *)v65 code];

  if (v43)
  {
    if (a7)
    {
      re::mtl::CommandBuffer::error(&v61, v65);
      if (v65 != a7)
      {
        id v45 = *(id *)v65;
        *(void *)__int16 v65 = 0;
        uint64_t v46 = *(void **)a7;
        *(void *)a7 = v45;
      }
    }
    int v47 = *re::graphicsLogObjects(v44);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int16 v65 = 0;
      _os_log_error_impl(&dword_233120000, v47, OS_LOG_TYPE_ERROR, "Internal Metal error while generating specular IBL cubemap. Execution likely took too long - Try again, and if the issue persists, lower samplesPerTexel.", v65, 2u);
    }
  }

  if (v29) {
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v80);
  }
  if (v79[0])
  {
    if (v79[1]) {
      (*(void (**)(void))(*(void *)v79[0] + 40))();
    }
    memset(v79, 0, sizeof(v79));
  }
  if (buf[0] && *(void *)&v76[4] && (v76[12] & 1) != 0) {
    (*(void (**)(void))(**(void **)&v76[4] + 40))();
  }
  if (v50) {
}
  }

uint64_t std::__function::__value_func<void ()(re::BackgroundTask &)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<re::BackgroundTaskResult ()(re::BackgroundTask &)>::~__value_func[abi:nn180100](void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(re::BackgroundTask &)>::~__value_func[abi:nn180100](void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

re::MeshShadowGenerationBacklog *re::MeshShadowGenerationBacklog::MeshShadowGenerationBacklog(re::MeshShadowGenerationBacklog *this)
{
  *((void *)this + 5) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 1) = 0;
  v2 = (_anonymous_namespace_ *)re::Queue<re::ShadowPair>::setCapacity(this, 0);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(void *)((char *)this + 84) = 0x7FFFFFFFLL;
  return this;
}

void re::MeshShadowGenerationBacklog::~MeshShadowGenerationBacklog(re::MeshShadowGenerationBacklog *this)
{
  double v2 = re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)this + 6);
  if (*(void *)this)
  {
    if (*((void *)this + 5)) {
      (*(void (**)(void, double))(**(void **)this + 40))(*(void *)this, v2);
    }
    *((void *)this + 5) = 0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
    *((_DWORD *)this + 8) = 0;
  }
}

uint64_t re::MeshShadowGenerationBacklog::pushBack(_anonymous_namespace_ *a1, __n128 *a2)
{
  uint64_t v4 = (uint64_t)a1 + 48;
  uint64_t result = re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::contains((uint64_t)a1 + 48, (uint64_t)a2);
  if ((result & 1) == 0)
  {
    re::Queue<re::ShadowPair>::enqueue(a1, a2);
    return re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::add(v4, (uint64_t)a2);
  }
  return result;
}

__n128 re::Queue<re::ShadowPair>::enqueue(_anonymous_namespace_ *this, __n128 *a2)
{
  unint64_t v5 = *((void *)this + 1);
  uint64_t v4 = *((void *)this + 2);
  if (v4 + 1 >= v5)
  {
    re::Queue<re::ShadowPair>::growCapacity(this, v4 + 1);
    unint64_t v5 = *((void *)this + 1);
    uint64_t v4 = *((void *)this + 2);
  }
  id v6 = (__n128 *)(*((void *)this + 5) + 24 * ((*((void *)this + 3) + v4) % v5));
  __n128 result = *a2;
  v6[1].n128_u64[0] = a2[1].n128_u64[0];
  __n128 *v6 = result;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 8);
  return result;
}

uint64_t re::MeshShadowGenerationBacklog::popFront@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  *a3 = 0;
  uint64_t v4 = a3 + 8;
  if (*(void *)(this + 16))
  {
    uint64_t v5 = this;
    uint64_t v6 = this + 48;
    while (1)
    {
      re::Queue<re::ShadowPair>::dequeue(v5, a2, (uint64_t)&v7);
      this = re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::contains(v6, (uint64_t)&v7);
      if (this) {
        break;
      }
      if (!*(void *)(v5 + 16)) {
        return this;
      }
    }
    *a3 = 1;
    *(_OWORD *)uint64_t v4 = v7;
    *((void *)v4 + 2) = v8;
    return re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::remove(v6, (uint64_t)&v7);
  }
  return this;
}

uint64_t re::Queue<re::ShadowPair>::dequeue@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *(void *)(result + 16);
  if (v3)
  {
    uint64_t v4 = *(void *)(result + 24);
    uint64_t v5 = *(void *)(result + 40) + 24 * v4;
    *(_OWORD *)a3 = *(_OWORD *)v5;
    *(void *)(a3 + 16) = *(void *)(v5 + 16);
    if ((unint64_t)(v4 + 1) < *(void *)(result + 8)) {
      uint64_t v6 = v4 + 1;
    }
    else {
      uint64_t v6 = 0;
    }
    *(void *)(result + 16) = v3 - 1;
    *(void *)(result + 24) = v6;
    ++*(_DWORD *)(result + 32);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Queue<T> is empty", "m_size > 0", "dequeue", 569);
    __n128 result = _os_crash();
    __break(1u);
  }
  return result;
}

void *re::Queue<re::ShadowPair>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    uint64_t v6 = result + 2;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::Queue<re::ShadowPair>::setCapacity(v5, a2);
        void *v6 = 0;
        v6[1] = 0;
        *((_DWORD *)v6 + 4) = 0;
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x18uLL))
        {
          uint64_t v2 = 24 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            uint64_t v8 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 440, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 444, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v8 = 0;
      if (!v3)
      {
LABEL_18:
        v5[5] = v8;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      if (v5[2])
      {
        uint64_t v9 = 0;
        uint64_t v10 = v5[3];
        do
        {
          uint64_t v11 = v5[5] + 24 * ((unint64_t)(v9 + v5[3]) % v5[1]);
          BOOL v12 = &v8[3 * v10];
          long long v13 = *(_OWORD *)v11;
          v12[2] = *(void *)(v11 + 16);
          *(_OWORD *)BOOL v12 = v13;
          if (v10 + 1 < a2) {
            ++v10;
          }
          else {
            uint64_t v10 = 0;
          }
          ++v9;
        }
        while (v9 != v5[2]);
      }
      __n128 result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[5]);
      goto LABEL_18;
    }
  }
  return result;
}

void *re::Queue<re::ShadowPair>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::Queue<re::ShadowPair>::setCapacity(this, a2);
    }
    else
    {
      this = re::Queue<re::ShadowPair>::setCapacity(v4, v3);
      v4[2] = 0;
      v4[3] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
  }
  return this;
}

uint64_t re::getOrCreateArgumentBuffer(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)&long long v54 = *(void *)(v2 + 128);
  *((void *)&v54 + 1) = v2;
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)uint64_t v55 = *(void *)(*(void *)(a1 + 16) + 1376);
  *(_OWORD *)&v55[8] = *(_OWORD *)(a1 + 40);
  uint64_t v4 = *(void *)(v3 + 104);
  uint64_t v5 = re::HashBrown<re::ArgumentBufferCacheKey,re::CachedArgumentBuffer *,re::Hash<re::ArgumentBufferCacheKey>,re::EqualTo<re::ArgumentBufferCacheKey>,void,false>::find((uint64_t *)(v4 + 104), &v54);
  if (v5 == -1 || (uint64_t v6 = *(void *)(*(void *)(v4 + 112) + 48 * v5 + 40)) == 0)
  {
    uint64_t v23 = re::globalAllocators((re *)v5);
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v23[2] + 32))(v23[2], 80, 8);
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_OWORD *)(v6 + 48) = 0u;
    *(_OWORD *)(v6 + 64) = 0u;
    objc_initWeak((id *)(v6 + 64), 0);
    uint64_t v24 = (id *)(*(void *)(v1 + 24) + 120);
    *(_WORD *)(v6 + 75) = 0;
    re::createArgumentBuffer(v1, v24, v6);
    re::encodeArgumentBuffer(v1, (uint64_t)&v54, v6);
    *(void *)(v6 + 56) = -1;
    uint64_t v25 = *(void *)(v1 + 72);
    if (v25) {
      uint64_t v26 = (void *)(v25 + 8);
    }
    else {
      uint64_t v26 = 0;
    }
    objc_storeWeak((id *)(v6 + 64), v26);
    re::CachedArgumentBuffer::updateWritableBufferVersions(v6, *(unsigned __int8 *)(v1 + 65), *(unsigned __int8 *)(v1 + 64));
    *(unsigned char *)(v6 + 76) = 1;
    uint64_t v1 = *(void *)v1;
    id v27 = (_anonymous_namespace_ *)re::HashBrown<re::ArgumentBufferCacheKey,re::CachedArgumentBuffer *,re::Hash<re::ArgumentBufferCacheKey>,re::EqualTo<re::ArgumentBufferCacheKey>,void,false>::find((uint64_t *)v1, &v54);
    if (v27 != (_anonymous_namespace_ *)-1) {
      goto LABEL_57;
    }
    if (*(void *)(v1 + 56))
    {
LABEL_34:
      uint64_t v29 = *(void *)(v1 + 32);
      if (!v29 || (unint64_t v30 = *(void *)(v1 + 16), v30 > 8 * v29))
      {
        re::HashBrown<re::ArgumentBufferCacheKey,re::CachedArgumentBuffer *,re::Hash<re::ArgumentBufferCacheKey>,re::EqualTo<re::ArgumentBufferCacheKey>,void,false>::resize((uint64_t *)v1, 1);
        unint64_t v30 = *(void *)(v1 + 16);
      }
      unint64_t v31 = (*(void *)v55 + ((void)v54 << 6) + ((unint64_t)v54 >> 2) - 0x61C8864680B583E9) ^ v54;
      char v32 = (_BYTE)v31 << 6;
      uint64_t v33 = ((*(void *)&v55[16] + (*(void *)&v55[8] << 6) + (*(void *)&v55[8] >> 2) - 0x61C8864680B583E9) ^ *(void *)&v55[8])
          + (v31 >> 2);
      unint64_t v34 = v30 >> 4;
      unint64_t v35 = ((v33 + (v31 << 6) - 0x61C8864680B583E9) ^ v31) % (v30 >> 4);
      uint64_t v36 = *(void *)v1;
      unint64_t v37 = v35;
      while (1)
      {
        unint64_t v38 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v36 + 16 * v37)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
        if (v38 < 0x40) {
          break;
        }
        if (v37 + 1 == v34) {
          unint64_t v37 = 0;
        }
        else {
          ++v37;
        }
        if (v37 == v35)
        {
          re::internal::assertLog((re::internal *)4, v28, -1.79399301e-307, 4.74803907e-38, "assertion failure: '%s' (%s:line %i) Unexpected full hash-table", "blockIndex != h1(key) % blockCount()", "internalAdd", 656);
          _os_crash();
          __break(1u);
          break;
        }
      }
      uint64_t v39 = v36 + 16 * v37;
      char v40 = ((v33 + v32 + 23) ^ v31) & 0x7F;
      BOOL v41 = *(unsigned __int8 *)(v39 + v38) == 255;
      *(unsigned char *)(v39 + v38) = v40;
      uint64_t v42 = 3 * (v38 + 16 * v37);
      uint64_t v43 = *(void *)(v1 + 8) + 48 * (v38 + 16 * v37);
      long long v44 = *(_OWORD *)v55;
      uint64_t v45 = *(void *)&v55[16];
      *(_OWORD *)uint64_t v43 = v54;
      *(_OWORD *)(v43 + 16) = v44;
      *(void *)(v43 + 32) = v45;
      *(void *)(v43 + 40) = v6;
      uint64_t v46 = *(void *)(v1 + 32);
      ++*(void *)(v1 + 24);
      *(void *)(v1 + 32) = v46 - v41;
      re::HashBrown<re::ArgumentBufferCacheKey,re::CachedArgumentBuffer *,re::Hash<re::ArgumentBufferCacheKey>,re::EqualTo<re::ArgumentBufferCacheKey>,void,false>::updateHashes(v1, (void *)(*(void *)(v1 + 8) + 16 * v42));
      goto LABEL_57;
    }
LABEL_61:
    goto LABEL_34;
  }
  unint64_t v7 = *(char **)(v1 + 72);
  unint64_t v8 = v6 + 64;
  WeakRetained = (char *)objc_loadWeakRetained((id *)(v6 + 64));
  if (WeakRetained) {
    uint64_t v11 = WeakRetained - 8;
  }
  else {
    uint64_t v11 = 0;
  }
  if (WeakRetained) {

  }
  if (v7 != v11)
  {
    *(void *)(v6 + 56) = -1;
    uint64_t v12 = *(void *)(v1 + 72);
    if (v12) {
      long long v13 = (void *)(v12 + 8);
    }
    else {
      long long v13 = 0;
    }
    objc_storeWeak((id *)(v6 + 64), v13);
  }
  unint64_t v14 = *(unsigned __int8 *)(v6 + 75);
  if (v14 >= 2)
  {
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, *(unsigned __int8 *)(v6 + 75), 2);
    _os_crash();
    __break(1u);
LABEL_60:
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, v8, 2);
    id v27 = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    goto LABEL_61;
  }
  uint64_t v15 = v6 + 60;
  uint64_t v16 = 2 * v14;
  if (*(unsigned __int8 *)(v1 + 64) == *(unsigned __int8 *)(v6 + 56 + v16)
    && *(unsigned __int8 *)(v1 + 65) == *(unsigned __int8 *)(v15 + v16)
    && *(unsigned char *)(v6 + 73) != 0)
  {
    goto LABEL_57;
  }
  unint64_t v8 = *(unsigned __int8 *)(v6 + 76);
  if (v8 >= 2) {
    goto LABEL_60;
  }
  id v18 = (id *)(*(void *)(v1 + 24) + 120);
  if (!*(void *)(v6 + 8 * v8))
  {
    re::createArgumentBuffer(v1, v18, v6);
    re::encodeArgumentBuffer(v1, (uint64_t)&v54, v6);
LABEL_56:
    re::CachedArgumentBuffer::updateWritableBufferVersions(v6, *(unsigned __int8 *)(v1 + 65), *(unsigned __int8 *)(v1 + 64));
    char v50 = *(unsigned char *)(v6 + 76);
    *(unsigned char *)(v6 + 75) = v50;
    *(unsigned char *)(v6 + 76) = (v50 & 1) == 0;
LABEL_57:
    *(unsigned char *)(v6 + 73) = 1;
    return v6;
  }
  id v52 = *v18;
  id v19 = *(id *)(v6 + 8 * v8);
  id v53 = 0;
  NS::SharedPtr<MTL::Texture>::operator=(&v53, &v52);
  objc_msgSend(v53, sel_setArgumentBuffer_offset_, v19, 0);
  if (v19) {

  }
  if (v52)
  {

    id v52 = 0;
  }
  unint64_t v21 = *(unsigned __int8 *)(v6 + 76);
  if (v21 < 2)
  {
    BOOL v22 = *(unsigned __int8 *)(v1 + 64) != *(unsigned __int8 *)(v6 + 56 + 2 * v21) || *(unsigned char *)(v6 + 73) == 0;
    if (*(unsigned __int8 *)(v1 + 65) != *(_WORD *)(v15 + 2 * v21)) {
      re::encodeConstants(*(uint64_t **)(v1 + 32), *(void *)(*((void *)&v54 + 1) + 96), *(void *)(*((void *)&v54 + 1) + 112), &v53, 0);
    }
    if (v22)
    {
      uint64_t v47 = *(void *)(v6 + 32);
      *(void *)(v6 + 32) = 0;
      if (v47)
      {
        id v48 = *(id **)(v6 + 48);
        uint64_t v49 = 8 * v47;
        do
        {
          if (*v48)
          {

            *id v48 = 0;
          }
          ++v48;
          v49 -= 8;
        }
        while (v49);
      }
      ++*(_DWORD *)(v6 + 40);
      re::encodeTextures(v1, (uint64_t)&v54, &v53, v6);
    }
    re::ArgumentEncoderBufferPair::~ArgumentEncoderBufferPair(&v53);
    goto LABEL_56;
  }
  re::internal::assertLog((re::internal *)6, v20, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, *(unsigned __int8 *)(v6 + 76), 2);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void re::createArgumentBuffer(uint64_t a1, id *a2, uint64_t a3)
{
  uint64_t v6 = (id *)(*(void *)(a1 + 8) + 184);
  uint64_t v7 = *(unsigned __int8 *)(a3 + 76);
  re::ensureHeapInitialized(*(void *)a1, v6);
  id v8 = *(id *)(*(void *)(*(void *)a1 + 96) + 8 * *(void *)(*(void *)a1 + 80) - 8);
  id v19 = v8;
  unint64_t v9 = objc_msgSend(*v6, "heapBufferSizeAndAlignWithLength:options:", objc_msgSend(*a2, sel_encodedLength), 256);
  if ((unint64_t)objc_msgSend(v8, sel_maxAvailableSizeWithAlignment_, v10) < v9)
  {
    re::createNewHeap(v6, &v18);
    uint64_t v11 = *(void *)a1;
    unint64_t v12 = *(void *)(*(void *)a1 + 80);
    if (v12 >= *(void *)(*(void *)a1 + 72))
    {
      re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::growCapacity((void *)(v11 + 64), v12 + 1);
      unint64_t v12 = *(void *)(v11 + 80);
    }
    uint64_t v13 = *(void *)(v11 + 96);
    id v14 = v18;
    *(void *)(v13 + 8 * v12) = v18;
    ++*(void *)(v11 + 80);
    ++*(_DWORD *)(v11 + 88);
    objc_msgSend(**(id **)(a1 + 56), sel_useHeap_stages_, v14, 3);
    NS::SharedPtr<MTL::Texture>::operator=(&v19, (void **)(*(void *)(*(void *)a1 + 96) + 8 * *(void *)(*(void *)a1 + 80) - 8));
    if (v14) {

    }
    id v8 = v19;
  }
  id v18 = objc_msgSend(v8, sel_newBufferWithLength_options_, objc_msgSend(*a2, sel_encodedLength), 256);
  if (v7 >= 2)
  {
    re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, v7, 2);
    _os_crash();
    __break(1u);
LABEL_15:
    re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) makeBuffer returned null for argument buffer! Have we run out of memory?", "cachedArgumentBuffer->argumentBufferChain[indexToWrite]", "createArgumentBuffer", 193);
    _os_crash();
    __break(1u);
    return;
  }
  uint64_t v16 = (void **)(a3 + 8 * v7);
  NS::SharedPtr<MTL::Texture>::operator=(v16, &v18);
  if (v18) {

  }
  if (!*v16) {
    goto LABEL_15;
  }
  if (v19) {
}
  }

void re::encodeArgumentBuffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = *(unsigned __int8 *)(a3 + 76);
  id v17 = *(id *)(*(void *)(a1 + 24) + 120);
  if (v6 < 2)
  {
    id v8 = *(id *)(a3 + 8 * v6);
    id v18 = 0;
    NS::SharedPtr<MTL::Texture>::operator=(&v18, &v17);
    objc_msgSend(v18, sel_setArgumentBuffer_offset_, v8, 0);
    if (v8) {

    }
    if (v17)
    {

      id v17 = 0;
    }
    re::encodeTextures(a1, a2, &v18, a3);
    uint64_t v10 = *(void **)(a2 + 8);
    uint64_t v11 = v10[7];
    if (!v11)
    {
LABEL_11:
      re::encodeConstants(*(uint64_t **)(a1 + 32), v10[12], v10[14], &v18, 1);
      re::ArgumentEncoderBufferPair::~ArgumentEncoderBufferPair(&v18);
      return;
    }
    uint64_t v12 = *(void *)(a1 + 32);
    unint64_t v6 = 8 * v11;
    uint64_t v13 = (unsigned __int16 *)(v10[9] + 4);
    while (1)
    {
      id v14 = (void *)(*(void *)(v12 + 16) + 48 * *(v13 - 1));
      unint64_t v15 = *v13;
      unint64_t v16 = v14[1];
      if (v16 <= v15) {
        break;
      }
      objc_msgSend(v18, sel_setBuffer_offset_atIndex_, *(void *)(*v14 + 16 * v15), *(unsigned int *)(*v14 + 16 * v15 + 8), *(v13 - 2));
      v13 += 4;
      v6 -= 8;
      if (!v6)
      {
        uint64_t v10 = *(void **)(a2 + 8);
        goto LABEL_11;
      }
    }
    re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, *v13, v16);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, v6, 2, v17);
  _os_crash();
  __break(1u);
}

uint64_t re::CachedArgumentBuffer::updateWritableBufferVersions(uint64_t this, uint64_t a2, __int16 a3)
{
  unint64_t v3 = *(unsigned __int8 *)(this + 76);
  if (v3 >= 2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, *(unsigned __int8 *)(this + 76), 2);
    this = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v4 = this + 2 * v3;
    *(_WORD *)(v4 + 60) = a2;
    *(_WORD *)(v4 + 56) = a3;
    *(unsigned char *)(this + 72) = 1;
  }
  return this;
}

void re::encodeConstants(uint64_t *a1, uint64_t a2, uint64_t a3, id *a4, char a5)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t v6 = a3;
    uint64_t v8 = a3 + 112 * a2;
    do
    {
      if ((a5 & 1) != 0 || (*(_WORD *)(v6 + 104) & 0x200) != 0)
      {
        uint64_t v9 = (uint64_t)objc_msgSend(*a4, sel_constantDataAtIndex_, *(unsigned __int16 *)(v6 + 96));
        uint64_t v10 = v9;
        uint64_t v11 = *(void *)(v6 + 24);
        if (v11)
        {
          uint64_t v12 = *(int **)(v6 + 40);
          uint64_t v13 = 16 * v11;
          do
          {
            if ((*v12 - 4) >= 4 && *v12 != 9)
            {
              unint64_t v15 = *re::graphicsLogObjects((re *)v9);
              uint64_t v9 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
              if (v9)
              {
                int v16 = *(unsigned __int16 *)(v6 + 96);
                int v17 = *v12;
                *(_DWORD *)buf = 67109376;
                *(_DWORD *)&uint8_t buf[4] = v16;
                LOWORD(v31) = 1024;
                *(_DWORD *)((char *)&v31 + 2) = v17;
                _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, "Cannot encode a constant at argument index %d. Table at index %d does not support argument buffers.", buf, 0xEu);
              }
            }
            v12 += 4;
            v13 -= 16;
          }
          while (v13);
        }
        id v18 = *(long long **)(v6 + 88);
        id v19 = *(long long **)(v6 + 72);
        if (v19)
        {
          uint64_t v20 = 16 * (void)v19;
          do
          {
            if ((*(_DWORD *)v18 - 4) >= 4 && *(_DWORD *)v18 != 9)
            {
              BOOL v22 = *re::graphicsLogObjects((re *)v9);
              uint64_t v9 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
              if (v9)
              {
                int v23 = *(unsigned __int16 *)(v6 + 96);
                int v24 = *(_DWORD *)v18;
                *(_DWORD *)buf = 67109376;
                *(_DWORD *)&uint8_t buf[4] = v23;
                LOWORD(v31) = 1024;
                *(_DWORD *)((char *)&v31 + 2) = v24;
                _os_log_impl(&dword_233120000, v22, OS_LOG_TYPE_DEFAULT, "Cannot encode a constant at argument index %d. Table at index %d does not support argument buffers.", buf, 0xEu);
              }
            }
            ++v18;
            v20 -= 16;
          }
          while (v20);
          id v18 = *(long long **)(v6 + 88);
          id v19 = *(long long **)(v6 + 72);
        }
        uint64_t v25 = *a1;
        uint64_t v26 = *(unsigned int *)(v6 + 100);
        uint64_t v27 = *(void *)(v6 + 24);
        *(void *)buf = *(void *)(v6 + 40);
        uint64_t v31 = v27;
        v29[0] = v18;
        v29[1] = v19;
        re::ConstantTableCollection::fill(v25, v10, v26, (uint64_t)buf, v29);
      }
      v6 += 112;
    }
    while (v6 != v8);
  }
}

void re::encodeTextures(uint64_t a1, uint64_t a2, id *a3, uint64_t a4)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (!re::mtl::Device::needsArgumentBufferTextureEmulation((re::mtl::Device *)(*(void *)(a1 + 8) + 184)))
  {
    uint64_t v8 = *(void *)(a2 + 8);
    uint64_t v9 = *(void *)(v8 + 16);
    if (v9)
    {
      uint64_t v10 = *(unsigned __int16 **)(v8 + 32);
      uint64_t v11 = &v10[4 * v9];
      uint64_t v32 = *(void *)(a1 + 32);
      do
      {
        if (*((unsigned char *)v10 + 6))
        {
          objc_msgSend(*a3, sel_setTexture_atIndex_, 0, *v10);
        }
        else
        {
          (*(void (**)(id *__return_ptr))(**(void **)(*(void *)(v32 + 8) + 8 * v10[1]) + 24))(v34);
          objc_msgSend(*a3, sel_setTexture_atIndex_, v34[0], *v10);
          if (v10[1])
          {
            uint64_t v12 = *(void *)(a4 + 48);
            unint64_t v13 = *(void *)(a4 + 32);
            if (v13)
            {
              id v14 = *(void ***)(a4 + 48);
              do
              {
                unint64_t v15 = v13 >> 1;
                int v16 = &v14[v13 >> 1];
                id v18 = *v16;
                int v17 = v16 + 1;
                v13 += ~(v13 >> 1);
                if (v18 < v34[0]) {
                  id v14 = v17;
                }
                else {
                  unint64_t v13 = v15;
                }
              }
              while (v13);
            }
            else
            {
              id v14 = *(void ***)(a4 + 48);
            }
            uint64_t v19 = (uint64_t)v14 - v12;
            unint64_t v20 = ((uint64_t)v14 - v12) >> 3;
            id v21 = v34[0];
            id v33 = v21;
            unint64_t v22 = *(void *)(a4 + 32);
            unint64_t v23 = v22 + 1;
            if (v22 + 1 <= v19 >> 3)
            {
              v34[1] = 0;
              long long v46 = 0u;
              long long v47 = 0u;
              long long v44 = 0u;
              long long v45 = 0u;
              long long v43 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v35 = 136315906;
              uint64_t v36 = "insert";
              __int16 v37 = 1024;
              int v38 = 887;
              __int16 v39 = 2048;
              unint64_t v40 = v20;
              __int16 v41 = 2048;
              unint64_t v42 = v23;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            id v24 = v21;
            if (v22 >= *(void *)(a4 + 24))
            {
              re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::growCapacity((void *)(a4 + 16), v22 + 1);
              unint64_t v22 = *(void *)(a4 + 32);
            }
            uint64_t v25 = *(void *)(a4 + 48);
            uint64_t v26 = (void *)(v25 + 8 * v22);
            if (v22 <= v20)
            {
              void *v26 = v24;
              *(void *)(a4 + 32) = v22 + 1;
              ++*(_DWORD *)(a4 + 40);
            }
            else
            {
              uint64_t v27 = *(v26 - 1);
              *(v26 - 1) = 0;
              void *v26 = v27;
              uint64_t v28 = (void **)(v26 - 1);
              if (v26 - 1 != (void *)(v25 + 8 * v20))
              {
                uint64_t v29 = 8 * v20 - 8 * v22 + 8;
                do
                {
                  unint64_t v30 = v28 - 1;
                  NS::SharedPtr<MTL::Texture>::operator=(v28, v28 - 1);
                  uint64_t v28 = v30;
                  v29 += 8;
                }
                while (v29);
                uint64_t v25 = *(void *)(a4 + 48);
              }
              NS::SharedPtr<MTL::Texture>::operator=((void **)(v25 + 8 * v20), &v33);
              id v31 = v33;
              ++*(void *)(a4 + 32);
              ++*(_DWORD *)(a4 + 40);
              if (v31) {
            }
              }
          }
          else
          {
            *(unsigned char *)(a4 + 74) = 1;
          }
          if (v34[0]) {
        }
          }
        v10 += 4;
      }
      while (v10 != v11);
    }
  }
}

void re::ensureHeapInitialized(uint64_t a1, id *this)
{
  if (!*(void *)(a1 + 80))
  {
    uint64_t v2 = (void *)(a1 + 64);
    re::createNewHeap(this, &v3);
    re::DynamicArray<re::SharedPtr<re::ShareableInternal<re::GeomInstance>>>::add(v2, &v3);
    if (v3) {
  }
    }
}

void re::createNewHeap(id *this@<X0>, void *a2@<X8>)
{
  id v5 = objc_msgSend(objc_msgSend(MEMORY[0x263F128F0], sel_alloc), sel_init);
  objc_msgSend(v5, sel_setCpuCacheMode_, 0);
  objc_msgSend(v5, sel_setStorageMode_, 0);
  objc_msgSend(v5, sel_setSize_, 0x40000);
  objc_msgSend(v5, sel_setHazardTrackingMode_, 1);
  *a2 = objc_msgSend(*this, sel_newHeapWithDescriptor_, v5);
  if (v5)
  {
  }
}

re::ArgumentBufferCacheReferences *re::ArgumentBufferCacheReferences::ArgumentBufferCacheReferences(re::ArgumentBufferCacheReferences *this, re::Allocator *a2)
{
  *((void *)this + 4) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *(void *)this = a2;
  re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(this, 0);
  ++*((_DWORD *)this + 6);
  *((void *)this + 9) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 5) = a2;
  re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((void *)this + 5, 0);
  ++*((_DWORD *)this + 16);
  *((_WORD *)this + 40) = 0;
  return this;
}

void *re::ArgumentBufferCacheReferences::addAndUseResourcePtrs(void *this, id *a2, uint64_t a3)
{
  uint64_t v4 = (uint64_t)this;
  uint64_t v5 = *(void *)(a3 + 16);
  if (v5)
  {
    unint64_t v6 = 0;
    uint64_t v7 = *(unint64_t **)(a3 + 32);
    uint64_t v8 = &v7[v5];
    do
    {
      unint64_t v9 = *v7;
      unint64_t v13 = *v7;
      unint64_t v10 = *(void *)(v4 + 16);
      if (v6 >= v10)
      {
        unint64_t v11 = 0;
      }
      else
      {
        while (1)
        {
          unint64_t v11 = *(void *)(*(void *)(v4 + 32) + 8 * v6);
          if (v11 >= v9) {
            break;
          }
          if (v10 == ++v6)
          {
            unint64_t v6 = *(void *)(v4 + 16);
            break;
          }
        }
      }
      if (v11 != v9)
      {
        re::DynamicArray<unsigned long>::insert((void *)v4, v6, &v13);
        this = re::DynamicArray<unsigned long>::add((void *)(v4 + 40), &v13);
      }
      ++v7;
    }
    while (v7 != v8);
  }
  uint64_t v12 = *(void *)(v4 + 56);
  if (v12)
  {
    this = (void *)[*a2 useResources:*(void *)(v4 + 72) count:v12 usage:1 stages:3];
    *(void *)(v4 + 56) = 0;
    ++*(_DWORD *)(v4 + 64);
  }
  return this;
}

uint64_t re::processArgumentBufferContextAndUseResources(uint64_t a1, uint64_t a2, id *a3)
{
  uint64_t ArgumentBuffer = re::getOrCreateArgumentBuffer(a1);
  if (*(unsigned char *)(ArgumentBuffer + 74) && !*(unsigned char *)(a2 + 81))
  {
    objc_msgSend(*a3, sel_useHeap_stages_, *(void *)(*(void *)(*(void *)(a1 + 8) + 64) + 8), 3);
    *(unsigned char *)(a2 + 81) = 1;
  }
  re::ArgumentBufferCacheReferences::addAndUseResourcePtrs((void *)a2, a3, ArgumentBuffer + 16);
  return ArgumentBuffer;
}

void re::ArgumentEncoderBufferPair::~ArgumentEncoderBufferPair(id *this)
{
  id v2 = *this;
  if (v2)
  {
    objc_msgSend(v2, sel_setArgumentBuffer_offset_, 0, 0);
    if (*this)
    {

      *this = 0;
    }
  }
}

uint64_t re::FunctionConstantsEnumerator::hasMatchingValueInLayer(re::FunctionConstantsEnumerator *this, const char *__s2, uint64_t a3)
{
  uint64_t v3 = *((void *)this + 1);
  if (!v3) {
    return 0;
  }
  unint64_t v6 = (void *)*((void *)this + 2);
  uint64_t v7 = &v6[11 * v3];
  while (1)
  {
    uint64_t v8 = (v6[1] & 1) != 0 ? (const char *)v6[2] : (char *)v6 + 9;
    if (!strcmp(v8, __s2))
    {
      uint64_t v9 = v6[7];
      if (v9) {
        break;
      }
    }
LABEL_7:
    v6 += 11;
    if (v6 == v7) {
      return 0;
    }
  }
  uint64_t v10 = 16 * v9;
  unint64_t v11 = (void *)(v6[8] + 8);
  while (!*((unsigned char *)v11 - 8) || *v11 != a3)
  {
    v11 += 2;
    v10 -= 16;
    if (!v10) {
      goto LABEL_7;
    }
  }
  return 1;
}

uint64_t *re::FunctionConstantsEnumerator::createLayerToIndexMap(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *((void *)a1 + 2) = 0;
  unint64_t v8 = *(void *)(a2 + 8);
  *((void *)a1 + 1) = v8;
  unint64_t v21 = v8;
  if (v8)
  {
    uint64_t v11 = v8;
    if (v8 >> 62) {
      goto LABEL_23;
    }
    *((void *)a1 + 2) = result;
    if (result)
    {
      unint64_t v13 = result;
      id v14 = result;
      unint64_t v15 = v21 - 1;
      if (v21 != 1)
      {
        do
        {
          *id v14 = 0;
          v14 += 4;
          --v15;
        }
        while (v15);
      }
      unint64_t v16 = 0;
      *id v14 = 0;
      if (v21 <= 1) {
        uint64_t v17 = 1;
      }
      else {
        uint64_t v17 = v21;
      }
      while (1)
      {
        if (a4)
        {
          if (*(void *)(a2 + 8) <= v16)
          {
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_22:
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_23:
            re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 4, v11);
            _os_crash();
            __break(1u);
            break;
          }
          uint64_t v18 = 0;
          uint64_t v19 = *(void *)(a2 + 16) + 88 * v16;
          uint64_t v11 = a3;
          while (1)
          {
            uint64_t result = (uint64_t *)re::DynamicString::operator==(v11, v19);
            if (result) {
              break;
            }
            ++v18;
            v11 += 64;
            if (a4 == v18) {
              goto LABEL_19;
            }
          }
          if (v21 <= v16) {
            goto LABEL_22;
          }
          unint64_t v20 = (char *)v13 + 4 * v16;
          if (!*v20) {
            *unint64_t v20 = 1;
          }
          *((_WORD *)v20 + 1) = v18;
        }
LABEL_19:
        if (++v16 == v17) {
          return result;
        }
      }
    }
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::FixedArray<re::Optional<unsigned long long>>::indexOf@<X0>(uint64_t result@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)(result + 8);
  uint64_t v3 = *(void *)(result + 16);
  if (v4)
  {
    uint64_t v5 = 16 * v4;
    unint64_t v6 = *(unsigned __int8 **)(result + 16);
    do
    {
      if (*a2 && *v6)
      {
        if (*((void *)v6 + 1) == *((void *)a2 + 1)) {
          goto LABEL_11;
        }
      }
      else if (!(*v6 | *a2))
      {
        goto LABEL_11;
      }
      v6 += 16;
      v5 -= 16;
    }
    while (v5);
    unint64_t v6 = (unsigned __int8 *)(v3 + 16 * v4);
  }
  else
  {
    unint64_t v6 = *(unsigned __int8 **)(result + 16);
  }
LABEL_11:
  uint64_t v7 = (uint64_t)&v6[-v3] >> 4;
  if (v7 == v4)
  {
    char v8 = 0;
  }
  else
  {
    *(void *)(a3 + 8) = v7;
    char v8 = 1;
  }
  *(unsigned char *)a3 = v8;
  return result;
}

uint64_t re::FunctionConstantsEnumerator::enumerateFunctionConstantSet(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 88 * v2;
  uint64_t v6 = *(void *)(a1 + 16) + 48;
  do
  {
    uint64_t v7 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(a2, (void *)(v6 - 16));
    if (v7 == -1)
    {
      uint64_t v9 = 0;
    }
    else
    {
      uint64_t v8 = *(unsigned int *)(a2[1] + 16 * v7 + 8);
      v11[0] = 1;
      uint64_t v12 = v8;
      re::FixedArray<re::Optional<unsigned long long>>::indexOf(v6, v11, (uint64_t)v13);
      if (v13[0]) {
        uint64_t v9 = v14;
      }
      else {
        uint64_t v9 = 0;
      }
    }
    v4 += *(void *)(v6 + 24) * v9;
    v6 += 88;
    v5 -= 88;
  }
  while (v5);
  return v4;
}

uint64_t re::FunctionConstantsEnumerator::createPermutation@<X0>(_anonymous_namespace_ *a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  *(void *)(a5 + 32) = 0;
  *(void *)(a5 + 8) = 0;
  *(void *)(a5 + 16) = 0;
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 24) = 0;
  if (a4)
  {
    unint64_t v9 = a4;
    unint64_t v5 = a3;
    re::DynamicArray<re::TechniqueFunctionConstant>::setCapacity((void *)a5, v9);
    ++*(_DWORD *)(a5 + 24);
    re::DynamicArray<re::TechniqueFunctionConstant>::copy((uint64_t *)a5, 0, (uint64_t *)v5, v9);
    uint64_t v10 = *(void *)(a5 + 32);
    a4 = *(void *)(a5 + 16);
  }
  else
  {
    uint64_t v10 = 0;
  }
  LayerToIndexMap = (_anonymous_namespace_ *)re::FunctionConstantsEnumerator::createLayerToIndexMap((_anonymous_namespace_ *)&v30, (uint64_t)a1, v10, a4);
  if (*((void *)a1 + 1))
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unint64_t v15 = a2 % *((void *)a1 + 4);
    while (1)
    {
      unint64_t v16 = (void *)(*((void *)a1 + 2) + v13);
      unint64_t v17 = v16[9];
      unint64_t v18 = v15 / v17;
      unint64_t v19 = v16[7];
      if (v19 <= v15 / v17)
      {
        *(void *)int v38 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v45 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v34 = 136315906;
        *(void *)&v34[4] = "operator[]";
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = 476;
        *(_WORD *)&v34[18] = 2048;
        *(void *)&v34[20] = v15 / v17;
        *(_WORD *)&v34[28] = 2048;
        *(void *)&v34[30] = v19;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_40:
        *(void *)int v38 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v45 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v34 = 136315906;
        *(void *)&v34[4] = "operator[]";
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = 468;
        *(_WORD *)&v34[18] = 2048;
        *(void *)&v34[20] = v14;
        *(_WORD *)&v34[28] = 2048;
        *(void *)&v34[30] = v19;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_41:
        *(void *)int v38 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v45 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v34 = 136315906;
        *(void *)&v34[4] = "operator[]";
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = 789;
        *(_WORD *)&v34[18] = 2048;
        *(void *)&v34[20] = v19;
        *(_WORD *)&v34[28] = 2048;
        *(void *)&v34[30] = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_42:
        uint64_t v33 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v45 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int v38 = 136315906;
        *(void *)&v38[4] = "operator[]";
        __int16 v39 = 1024;
        int v40 = 476;
        __int16 v41 = 2048;
        unint64_t v42 = v14;
        __int16 v43 = 2048;
        unint64_t v44 = v19;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_43:
        *(void *)int v38 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v45 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v34 = 136315906;
        *(void *)&v34[4] = "removeAt";
        *(_WORD *)&v34[12] = 1024;
        *(_DWORD *)&v34[14] = 931;
        *(_WORD *)&v34[18] = 2048;
        *(void *)&v34[20] = v19;
        *(_WORD *)&v34[28] = 2048;
        *(void *)&v34[30] = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_44:
        uint64_t v33 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v45 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int v38 = 136315906;
        *(void *)&v38[4] = "operator[]";
        __int16 v39 = 1024;
        int v40 = 476;
        __int16 v41 = 2048;
        unint64_t v42 = v14;
        __int16 v43 = 2048;
        unint64_t v44 = v19;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v20 = v16[8];
      if (*(unsigned char *)(v20 + 16 * v18)) {
        unint64_t v29 = *(void *)(v20 + 16 * v18 + 8);
      }
      unint64_t v19 = v31;
      if (v31 <= v14) {
        goto LABEL_40;
      }
      if (*(unsigned char *)(v32 + v12)) {
        break;
      }
      if (*(unsigned char *)(v20 + 16 * v18))
      {
        memset(v34, 0, 32);
        re::DynamicString::setCapacity(v34, 0);
        uint64_t v35 = 0;
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        unint64_t v19 = *((void *)a1 + 1);
        if (v19 <= v14) {
          goto LABEL_42;
        }
        re::DynamicString::operator=((re::DynamicString *)v34, (re::DynamicString *)(*((void *)a1 + 2) + v13));
        unint64_t v19 = *((void *)a1 + 1);
        if (v19 <= v14) {
          goto LABEL_44;
        }
        *(_DWORD *)&v34[32] = *(_DWORD *)(*((void *)a1 + 2) + v13 + 40);
        TypeSize = (_anonymous_namespace_ *)re::mtl::getTypeSize(*(unsigned __int16 *)&v34[32]);
        unint64_t v5 = (int)TypeSize;
        re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v34, v29);
        re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)a5, (re::DynamicString *)v34);
        re::FunctionConstantsEnumerator::createLayerToIndexMap((_anonymous_namespace_ *)&v45, (uint64_t)a1, *(void *)(a5 + 32), *(void *)(a5 + 16));
        re::FixedArray<float>::operator=(&v30, (uint64_t *)&v45);
        if ((void)v45 && *((void *)&v45 + 1)) {
          (*(void (**)(void, void))(*(void *)v45 + 40))(v45, v46);
        }
        if (v35)
        {
          if (v36)
          {
            (*(void (**)(void))(*(void *)v35 + 40))();
            uint64_t v36 = 0;
            uint64_t v37 = 0;
          }
          uint64_t v35 = 0;
        }
        LayerToIndexMap = *(_anonymous_namespace_ **)v34;
        if (*(void *)v34)
        {
          if (v34[8])
          {
            uint64_t v22 = *(void *)&v34[16];
LABEL_33:
            LayerToIndexMap = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, uint64_t))(*(void *)LayerToIndexMap + 40))(LayerToIndexMap, v22);
          }
        }
      }
LABEL_34:
      v15 %= v17;
      ++v14;
      v13 += 88;
      v12 += 4;
      if (*((void *)a1 + 1) <= v14) {
        goto LABEL_35;
      }
    }
    unint64_t v19 = *(__int16 *)(v32 + v12 + 2);
    unint64_t v5 = *(void *)(a5 + 16);
    if (*(unsigned char *)(v20 + 16 * v18))
    {
      if (v5 <= v19) {
        goto LABEL_41;
      }
      LayerToIndexMap = (_anonymous_namespace_ *)re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)(*(void *)(a5 + 32) + (v19 << 6)), v29);
      goto LABEL_34;
    }
    if (v5 <= v19) {
      goto LABEL_43;
    }
    if (v5 - 1 > v19)
    {
      uint64_t v23 = *(void *)(a5 + 32);
      uint64_t v24 = v23 + (v5 << 6);
      uint64_t v25 = re::DynamicString::operator=((re::DynamicString *)(v23 + (v19 << 6)), (re::DynamicString *)(v24 - 64));
      *((_DWORD *)v25 + 8) = *(_DWORD *)(v24 - 32);
      re::FixedArray<float>::operator=((uint64_t *)v25 + 5, (uint64_t *)(v24 - 24));
      unint64_t v5 = *(void *)(a5 + 16);
    }
    unint64_t v26 = *(void *)(a5 + 32) + (v5 << 6);
    unint64_t v5 = v26 - 64;
    re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v26 - 24));
    re::DynamicString::deinit((re::DynamicString *)v5);
    uint64_t v27 = *(void *)(a5 + 16) - 1;
    *(void *)(a5 + 16) = v27;
    ++*(_DWORD *)(a5 + 24);
    re::FunctionConstantsEnumerator::createLayerToIndexMap((_anonymous_namespace_ *)&v45, (uint64_t)a1, *(void *)(a5 + 32), v27);
    re::FixedArray<float>::operator=(&v30, (uint64_t *)&v45);
    LayerToIndexMap = (_anonymous_namespace_ *)v45;
    if (!(void)v45 || !*((void *)&v45 + 1)) {
      goto LABEL_34;
    }
    uint64_t v22 = v46;
    goto LABEL_33;
  }
LABEL_35:
  uint64_t result = v30;
  if (v30)
  {
    if (v31) {
      return (*(uint64_t (**)(void))(*(void *)v30 + 40))();
    }
  }
  return result;
}

void *re::FunctionConstantsEnumerator::overrideEnumerator@<X0>(void *result@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v4 = (uint64_t)result;
  uint64_t v108 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(unsigned int *)(a2 + 32);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = (int *)(*(void *)(a2 + 16) + 8);
    while (1)
    {
      int v9 = *v8;
      v8 += 28;
      if (v9 < 0) {
        break;
      }
      if (v6 == ++v7)
      {
        LODWORD(v7) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if (v6 == v7) {
    goto LABEL_8;
  }
  uint64_t v10 = v7;
  uint64_t v11 = *(void *)(a2 + 16);
  unsigned int v12 = *(_DWORD *)(a2 + 32);
LABEL_10:
  uint64_t v13 = *(void *)(v4 + 8);
  if (!v13) {
    goto LABEL_15;
  }
  uint64_t v14 = v11 + 112 * v10 + 16;
  uint64_t v15 = 88 * v13;
  unint64_t v16 = (void *)(*(void *)(v4 + 16) + 32);
  while (1)
  {
    uint64_t result = (void *)re::Hash<re::DynamicString>::operator()((uint64_t)&v92, v14);
    unint64_t v17 = (void *)*v16;
    v16 += 11;
    if (result == v17) {
      break;
    }
    v15 -= 88;
    if (!v15)
    {
      unsigned int v12 = *(_DWORD *)(a2 + 32);
      uint64_t v11 = *(void *)(a2 + 16);
LABEL_15:
      if (v12 <= (int)v7 + 1) {
        unsigned int v18 = v7 + 1;
      }
      else {
        unsigned int v18 = v12;
      }
      while (1)
      {
        uint64_t v10 = (v7 + 1);
        if (v18 - 1 == v7) {
          break;
        }
        LODWORD(v7) = v7 + 1;
        unsigned int v19 = v10;
        if ((*(_DWORD *)(v11 + 112 * v10 + 8) & 0x80000000) != 0) {
          goto LABEL_22;
        }
      }
      unsigned int v19 = v18;
LABEL_22:
      LODWORD(v7) = v19;
      if (v6 == v19)
      {
LABEL_8:
        *a3 = 0;
        return result;
      }
      goto LABEL_10;
    }
  }
  v79 = a3;
  re::FixedArray<re::FunctionConstantsEnumerator::PermutationLayer>::FixedArray(&v88, v4);
  long long v90 = *(_OWORD *)(v4 + 24);
  uint64_t v20 = *(unsigned int *)(a2 + 32);
  if (v20)
  {
    uint64_t v21 = 0;
    uint64_t v22 = (int *)(*(void *)(a2 + 16) + 8);
    while (1)
    {
      int v23 = *v22;
      v22 += 28;
      if (v23 < 0) {
        break;
      }
      if (v20 == ++v21)
      {
        LODWORD(v21) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v21) = 0;
  }
  if (v20 == v21) {
    goto LABEL_108;
  }
  uint64_t v24 = v21;
  uint64_t v81 = a2;
  uint64_t v25 = *(void *)(a2 + 16);
  unint64_t v26 = *(void *)(v4 + 8);
  unsigned int v27 = *(_DWORD *)(a2 + 32);
  unsigned int v80 = v27;
  do
  {
    if (!v26) {
      goto LABEL_100;
    }
    unint64_t v28 = 0;
    uint64_t v29 = v25 + 112 * v24;
    uint64_t v30 = v29 + 16;
    unint64_t v31 = (re::TechniqueFunctionConstant *)(v29 + 48);
    uint64_t v82 = (re::TechniqueFunctionConstant *)(v29 + 48);
    do
    {
      unint64_t v32 = *(void *)(v4 + 16);
      unint64_t v33 = re::Hash<re::DynamicString>::operator()((uint64_t)&v92, v30);
      unint64_t v34 = v32 + 88 * v28;
      uint64_t v36 = *(void *)(v34 + 32);
      uint64_t v35 = (void *)(v34 + 32);
      if (v33 != v36) {
        goto LABEL_98;
      }
      uint64_t As64Bits = re::TechniqueFunctionConstant::getAs64Bits(v31);
      LOBYTE(v92) = 1;
      *((void *)&v92 + 1) = As64Bits;
      int v38 = (_anonymous_namespace_ *)re::FixedArray<re::Optional<unsigned long long>>::indexOf(v32 + 88 * v28 + 48, (unsigned __int8 *)&v92, (uint64_t)v86);
      if (v86[0])
      {
        unint64_t v39 = *((void *)&v88 + 1);
        if (*((void *)&v88 + 1) <= v28)
        {
          *(void *)v98 = 0;
          long long v95 = 0u;
          long long v96 = 0u;
          long long v93 = 0u;
          long long v94 = 0u;
          long long v92 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          v105[0] = 136315906;
          *(void *)&v105[1] = "operator[]";
          LOWORD(v105[3]) = 1024;
          *(_DWORD *)((char *)&v105[3] + 2) = 468;
          HIWORD(v105[4]) = 2048;
          *(void *)&v105[5] = v28;
          LOWORD(v105[7]) = 2048;
          *(void *)((char *)&v105[7] + 2) = v39;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_113:
          *(void *)v98 = 0;
          long long v95 = 0u;
          long long v96 = 0u;
          long long v93 = 0u;
          long long v94 = 0u;
          long long v92 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          v105[0] = 136315906;
          *(void *)&v105[1] = "operator[]";
          LOWORD(v105[3]) = 1024;
          *(_DWORD *)((char *)&v105[3] + 2) = 468;
          HIWORD(v105[4]) = 2048;
          *(void *)&v105[5] = v39;
          LOWORD(v105[7]) = 2048;
          *(void *)((char *)&v105[7] + 2) = v32;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_114:
          re::internal::assertLog((re::internal *)4, v49, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "first", 440);
          _os_crash();
          __break(1u);
LABEL_115:
          re::internal::assertLog((re::internal *)7, v49, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 362, v52, 1, v51);
          _os_crash();
          __break(1u);
LABEL_116:
          re::internal::assertLog((re::internal *)4, v49, "assertion failure: '%s' (%s:line %i) Too much data to copy.", "requiredSize <= m_size", "copy", 363);
          _os_crash();
          __break(1u);
LABEL_117:
          uint64_t v91 = 0;
          long long v106 = 0u;
          long long v107 = 0u;
          memset(v105, 0, sizeof(v105));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)v98 = 136315906;
          *(void *)&v98[4] = "operator[]";
          __int16 v99 = 1024;
          int v100 = 468;
          __int16 v101 = 2048;
          unint64_t v102 = v28;
          __int16 v103 = 2048;
          unint64_t v104 = v39;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_118:
          re::internal::assertLog((re::internal *)4, v62, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
          _os_crash();
          __break(1u);
        }
        unint64_t v39 = v87;
        unint64_t v32 = *(void *)(v89 + 88 * v28 + 56);
        if (v32 <= v87) {
          goto LABEL_113;
        }
        int v40 = *(unsigned __int8 **)(v89 + 88 * v28 + 64);
        __int16 v41 = &v40[16 * v87];
        int v42 = *v41;
        if (*v41)
        {
          __int16 v43 = (unsigned __int8 *)*((void *)v41 + 1);
          if (*v40)
          {
            *((void *)v41 + 1) = *((void *)v40 + 1);
            int v44 = 1;
LABEL_88:
            unint64_t v31 = v82;
            if (!(v44 | v42)) {
              goto LABEL_98;
            }
            BOOL v72 = v44 != 0;
            if (v42) {
              BOOL v73 = 1;
            }
            else {
              BOOL v73 = v44 == 0;
            }
            if (!v73)
            {
              *int v40 = 0;
              goto LABEL_98;
            }
          }
          else
          {
            *__int16 v41 = 0;
            BOOL v72 = *v40 != 0;
            unint64_t v31 = v82;
          }
          if (v42 && !v72) {
            *int v40 = 1;
          }
          *((void *)v40 + 1) = v43;
          goto LABEL_98;
        }
        __int16 v43 = (unsigned __int8 *)*v40;
        if (*v40)
        {
          *__int16 v41 = 1;
          __int16 v43 = &v40[16 * v39];
          *((void *)v43 + 1) = *((void *)v40 + 1);
          int v44 = *v40;
        }
        else
        {
          int v44 = 0;
        }
        goto LABEL_88;
      }
      uint64_t v83 = 0;
      unint64_t v84 = 0;
      uint64_t v85 = 0;
      unint64_t v45 = v32 + 88 * v28;
      uint64_t v47 = *(void *)(v45 + 56);
      long long v46 = (uint64_t *)(v45 + 56);
      unint64_t v39 = v47 + 1;
      long long v48 = (_anonymous_namespace_ *)re::TechniqueFunctionConstant::getAs64Bits(v31);
      if (!v84) {
        goto LABEL_114;
      }
      uint64_t v50 = v85;
      if (!*v85) {
        *uint64_t v85 = 1;
      }
      *((void *)v50 + 1) = v48;
      uint64_t v51 = *v46;
      unint64_t v52 = v84;
      if (*v46 == -1) {
        goto LABEL_115;
      }
      if (*v46 + 1 > v84) {
        goto LABEL_116;
      }
      if (v51)
      {
        id v53 = v85 + 16;
        long long v54 = (void *)(*(void *)(v32 + 88 * v28 + 64) + 8);
        uint64_t v55 = 16 * v51;
        do
        {
          int v56 = *((unsigned __int8 *)v54 - 8);
          if (*v53) {
            BOOL v57 = 0;
          }
          else {
            BOOL v57 = v56 == 0;
          }
          if (!v57)
          {
            if (*v53) {
              BOOL v58 = v56 == 0;
            }
            else {
              BOOL v58 = 0;
            }
            if (v58)
            {
              unsigned char *v53 = 0;
            }
            else
            {
              if (*v53) {
                BOOL v59 = 1;
              }
              else {
                BOOL v59 = v56 == 0;
              }
              if (!v59) {
                unsigned char *v53 = 1;
              }
              *((void *)v53 + 1) = *v54;
            }
          }
          v53 += 16;
          v54 += 2;
          v55 -= 16;
        }
        while (v55);
      }
      long long v92 = 0u;
      long long v93 = 0u;
      re::DynamicString::setCapacity(&v92, 0);
      *(void *)&long long v94 = *v35;
      DWORD2(v94) = 0;
      *(void *)&long long v96 = 0;
      long long v95 = 0uLL;
      if (v83)
      {
        re::FixedArray<re::Optional<unsigned long long>>::init<>(&v95, v83, v84);
        re::FixedArray<re::Optional<unsigned long long>>::copy((uint64_t)&v95, (uint64_t)&v83);
      }
      *((void *)&v96 + 1) = *(void *)(v32 + 88 * v28 + 72);
      char v97 = 0;
      unint64_t v39 = *((void *)&v88 + 1);
      if (*((void *)&v88 + 1) <= v28) {
        goto LABEL_117;
      }
      uint64_t v60 = v89;
      id v61 = re::DynamicString::operator=((re::DynamicString *)(v89 + 88 * v28), (re::DynamicString *)&v92);
      unint64_t v31 = v82;
      uint64_t v63 = v94;
      *((_DWORD *)v61 + 10) = DWORD2(v94);
      *((void *)v61 + 4) = v63;
      id v64 = (uint64_t *)((char *)v61 + 48);
      if ((long long *)((char *)v61 + 48) != &v95)
      {
        uint64_t v65 = *v64;
        if (*v64) {
          BOOL v66 = v65 == (void)v95;
        }
        else {
          BOOL v66 = 1;
        }
        if (!v66) {
          goto LABEL_118;
        }
        *id v64 = v95;
        *(void *)&long long v95 = v65;
        uint64_t v67 = v60 + 88 * v28;
        uint64_t v68 = *(void *)(v67 + 56);
        *(void *)(v67 + 56) = *((void *)&v95 + 1);
        *((void *)&v95 + 1) = v68;
        uint64_t v69 = *(void *)(v67 + 64);
        *(void *)(v67 + 64) = v96;
        *(void *)&long long v96 = v69;
      }
      uint64_t v70 = v60 + 88 * v28;
      uint64_t v71 = *((void *)&v96 + 1);
      *(unsigned char *)(v70 + 80) = v97;
      *(void *)(v70 + 72) = v71;
      if ((void)v95)
      {
        if (*((void *)&v95 + 1))
        {
          (*(void (**)(void))(*(void *)v95 + 40))();
          *((void *)&v95 + 1) = 0;
          *(void *)&long long v96 = 0;
        }
        *(void *)&long long v95 = 0;
      }
      if (void)v92 && (BYTE8(v92)) {
        (*(void (**)(void))(*(void *)v92 + 40))();
      }
      if (v83 && v84) {
        (*(void (**)(void))(*(void *)v83 + 40))();
      }
LABEL_98:
      ++v28;
      unint64_t v26 = *(void *)(v4 + 8);
    }
    while (v26 > v28);
    LODWORD(v20) = v80;
    unsigned int v27 = *(_DWORD *)(v81 + 32);
    uint64_t v25 = *(void *)(v81 + 16);
LABEL_100:
    if (v27 <= (int)v21 + 1) {
      unsigned int v74 = v21 + 1;
    }
    else {
      unsigned int v74 = v27;
    }
    while (1)
    {
      uint64_t v24 = (v21 + 1);
      if (v74 - 1 == v21) {
        break;
      }
      LODWORD(v21) = v21 + 1;
      unsigned int v75 = v24;
      if ((*(_DWORD *)(v25 + 112 * v24 + 8) & 0x80000000) != 0) {
        goto LABEL_107;
      }
    }
    unsigned int v75 = v74;
LABEL_107:
    LODWORD(v21) = v75;
  }
  while (v20 != v75);
LABEL_108:
  re::FunctionConstantsEnumerator::calculateDerivedFields(&v88);
  if (*(void *)(v4 + 24) == (void)v90)
  {
    char v76 = 0;
    __int16 v77 = v79;
  }
  else
  {
    __int16 v77 = v79;
    *(_OWORD *)(v79 + 8) = v88;
    uint64_t v78 = v89;
    uint64_t v89 = 0;
    long long v88 = 0uLL;
    *((void *)v79 + 3) = v78;
    *((_OWORD *)v79 + 2) = v90;
    char v76 = 1;
  }
  *__int16 v77 = v76;
  return re::FixedArray<re::FunctionConstantsEnumerator::PermutationLayer>::deinit(&v88);
}

void *re::FunctionConstantsEnumerator::calculateDerivedFields(void *this)
{
  unint64_t v1 = this[1];
  if (v1)
  {
    uint64_t v2 = this[2];
    uint64_t v3 = v2 + 88 * v1;
    uint64_t v4 = 88 * v1;
    unint64_t v5 = (uint64_t *)(v2 + 56);
    unint64_t v6 = 1;
    do
    {
      uint64_t v7 = *v5;
      v5 += 11;
      v6 *= v7;
      v4 -= 88;
    }
    while (v4);
    this[4] = v6;
    uint64_t v8 = (unint64_t *)(v2 + 72);
    unint64_t v9 = v1;
    do
    {
      v6 /= *(v8 - 2);
      *uint64_t v8 = v6;
      v8 += 11;
      --v9;
    }
    while (v9);
    do
    {
      uint64_t v10 = *(void *)(v2 + 56);
      unint64_t v11 = (v10 - 0x61C8864680B583E9 + (*(void *)(v2 + 32) << 6) + (*(void *)(v2 + 32) >> 2)) ^ *(void *)(v2 + 32);
      if (v10)
      {
        uint64_t v12 = 16 * v10;
        uint64_t v13 = (void *)(*(void *)(v2 + 64) + 8);
        do
        {
          if (*((unsigned char *)v13 - 8))
          {
            uint64_t v14 = *v13;
            v11 ^= (v11 << 6) - 0x61C8864680B583E9 + (v11 >> 2) + 1;
          }
          else
          {
            uint64_t v14 = 0;
          }
          v11 ^= (v11 << 6) - 0x61C8864680B583E9 + (v11 >> 2) + v14;
          v13 += 2;
          v12 -= 16;
        }
        while (v12);
      }
      unint64_t v15 = (*(unsigned __int16 *)(v2 + 42)
           - 0x61C8864680B583E9
           + ((((v11 << 6) - 0x61C8864680B583E9 + (v11 >> 2) + *(void *)(v2 + 72)) ^ v11) << 6)
           + ((((v11 << 6) - 0x61C8864680B583E9 + (v11 >> 2) + *(void *)(v2 + 72)) ^ v11) >> 2)) ^ ((v11 << 6) - 0x61C8864680B583E9 + (v11 >> 2) + *(void *)(v2 + 72)) ^ v11;
      v1 ^= (v1 << 6)
          - 0x61C8864680B583E9
          + (v1 >> 2)
          + ((*(unsigned __int16 *)(v2 + 40) - 0x61C8864680B583E9 + (v15 << 6) + (v15 >> 2)) ^ v15);
      v2 += 88;
    }
    while (v2 != v3);
  }
  else
  {
    this[4] = 1;
  }
  this[3] = v1;
  return this;
}

void re::FunctionConstantsEnumerator::createEnumerator(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v91 = *MEMORY[0x263EF8340];
  *(_OWORD *)a6 = 0u;
  *(_OWORD *)(a6 + 16) = 0u;
  *(void *)(a6 + 32) = 1;
  uint64_t As64Bits = re::HashBrown<re::DynamicString,re::VariedFunctionConstant,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::HashBrown((uint64_t)v76, a1);
  if (a3)
  {
    unint64_t v11 = &a2[a3];
    do
    {
      v74[0] = *a2;
      uint64_t As64Bits = re::HashBrown<unsigned long,re::HashBrown<unsigned long,unsigned short,re::Hash<unsigned long>,re::EqualTo<unsigned long>,void,false>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,void,false>::find(a5, v74);
      if (As64Bits != -1)
      {
        uint64_t v12 = a5[1] + 72 * As64Bits;
        uint64_t v13 = (uint64_t *)(v12 + 8);
        *(void *)long long v88 = v12 + 8;
        *(void *)&v88[8] = 0;
        unint64_t v14 = *(void *)(v12 + 24);
        if (v14 >= 0x10)
        {
          uint64_t v15 = 0;
          uint64_t v16 = *v13;
          unint64_t v17 = v14 >> 4;
          while (1)
          {
            unsigned __int16 v18 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v16 + v15)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
            *(void *)&v88[8] = (unsigned __int16)~v18;
            if (v18 != 0xFFFF) {
              break;
            }
            v15 += 16;
            if (!--v17) {
              goto LABEL_20;
            }
          }
          uint64_t v19 = __clz(__rbit64((unsigned __int16)~v18)) + v15;
          for (*(void *)&v88[16] = v19; *(void *)&v88[16] != -1; uint64_t v19 = *(void *)&v88[16])
          {
            uint64_t v20 = *(void *)(*(void *)v88 + 8) + 96 * v19;
            re::DynamicString::DynamicString((re::DynamicString *)&v81, (const re::DynamicString *)v20);
            LODWORD(v83) = *(_DWORD *)(v20 + 32);
            re::DynamicArray<char const*>::DynamicArray((uint64_t)&v83 + 8, (uint64_t *)(v20 + 40));
            uint64_t v21 = *(void *)(v20 + 80);
            __int16 v87 = *(_WORD *)(v20 + 88);
            uint64_t v86 = v21;
            if (re::HashBrown<re::DynamicString,re::VariedFunctionConstant,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::find(v76, (uint64_t)&v81) == -1)re::HashBrown<re::DynamicString,re::VariedFunctionConstant,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::addNew(v76, (const re::DynamicString *)&v81, (uint64_t *)&v83); {
            if (*((void *)&v83 + 1))
            }
            {
              if (*((void *)&v85 + 1)) {
                (*(void (**)(void))(**((void **)&v83 + 1) + 40))();
              }
              *((void *)&v85 + 1) = 0;
              long long v84 = 0uLL;
              *((void *)&v83 + 1) = 0;
              LODWORD(v85) = v85 + 1;
            }
            if (void)v81 && (BYTE8(v81)) {
              (*(void (**)(void))(*(void *)v81 + 40))();
            }
            uint64_t As64Bits = (uint64_t)re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v88);
          }
        }
      }
LABEL_20:
      ++a2;
    }
    while (a2 != v11);
  }
  uint64_t v22 = *(void *)(a4 + 16);
  if (v22)
  {
    int v23 = *(re::TechniqueFunctionConstant **)(a4 + 32);
    uint64_t v24 = (re::TechniqueFunctionConstant *)((char *)v23 + 64 * v22);
    do
    {
      uint64_t As64Bits = re::HashBrown<re::DynamicString,re::VariedFunctionConstant,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::find(v76, (uint64_t)v23);
      if (As64Bits != -1)
      {
        uint64_t v25 = As64Bits;
        uint64_t v26 = v76[1];
        uint64_t As64Bits = re::TechniqueFunctionConstant::getAs64Bits(v23);
        uint64_t v27 = As64Bits;
        uint64_t v28 = v26 + 96 * v25;
        unint64_t v31 = *(void *)(v28 + 56);
        uint64_t v30 = (void *)(v28 + 56);
        unint64_t v29 = v31;
        unint64_t v33 = (uint64_t **)(v30 + 2);
        unint64_t v32 = (uint64_t *)v30[2];
        unint64_t v34 = v32;
        if (v31)
        {
          uint64_t v35 = 8 * v29;
          unint64_t v34 = (uint64_t *)v30[2];
          while (*v34 != As64Bits)
          {
            ++v34;
            v35 -= 8;
            if (!v35)
            {
              unint64_t v34 = &v32[v29];
              break;
            }
          }
        }
        unint64_t v36 = v34 - v32;
        if (v36 == v29)
        {
          if (v29 == -1) {
            goto LABEL_73;
          }
          if (v29 >= *(void *)(v26 + 96 * v25 + 48))
          {
            uint64_t As64Bits = (uint64_t)re::DynamicArray<float *>::growCapacity(v30 - 2, v29 + 1);
            unint64_t v29 = *v30;
            unint64_t v32 = *v33;
          }
          uint64_t v37 = &v32[v29];
          if (v29)
          {
            *uint64_t v37 = *(v37 - 1);
            if (v37 - 1 != v32)
            {
              uint64_t As64Bits = (uint64_t)memmove(v32 + 1, v32, 8 * v29 - 8);
              unint64_t v32 = *v33;
              unint64_t v29 = *v30;
            }
          }
          *unint64_t v32 = v27;
          *uint64_t v30 = v29 + 1;
          ++*(_DWORD *)(v26 + 96 * v25 + 64);
        }
        else
        {
          if (v29 <= v36) {
            goto LABEL_74;
          }
          uint64_t v38 = v32[v36];
          v32[v36] = *v32;
          *unint64_t v32 = v38;
        }
        *(unsigned char *)(v26 + 96 * v25 + 88) = 1;
      }
      int v23 = (re::TechniqueFunctionConstant *)((char *)v23 + 64);
    }
    while (v23 != v24);
  }
  if (v79)
  {
    unint64_t v39 = v78;
    if (v78)
    {
      int v40 = (void *)a6;
      v74[0] = (uint64_t)v76;
      if (v77 >= 0x10)
      {
        uint64_t v41 = 0;
        unint64_t v42 = v77 >> 4;
        while (1)
        {
          unsigned __int16 v43 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v76[0] + v41)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
          v74[1] = (unsigned __int16)~v43;
          if (v43 != 0xFFFF) {
            break;
          }
          v41 += 16;
          if (!--v42) {
            goto LABEL_69;
          }
        }
        uint64_t v44 = __clz(__rbit64((unsigned __int16)~v43)) + v41;
        uint64_t v75 = v44;
        if (v44 != -1)
        {
          unint64_t v36 = 0;
          unint64_t v29 = 88;
          do
          {
            int v23 = (re::TechniqueFunctionConstant *)v40[1];
            if ((unint64_t)v23 <= v36) {
              goto LABEL_75;
            }
            uint64_t v45 = *(void *)(v74[0] + 8);
            uint64_t v46 = v45 + 96 * v44;
            uint64_t v47 = v40[2];
            uint64_t v48 = v47 + 88 * v36;
            *(void *)(v48 + 32) = re::Hash<re::DynamicString>::operator()((uint64_t)&v81, v46);
            *(_DWORD *)(v48 + 40) = *(_DWORD *)(v46 + 32);
            uint64_t v49 = re::DynamicString::operator=((re::DynamicString *)v48, (re::DynamicString *)v46);
            unint64_t v52 = *(void *)(v46 + 56);
            uint64_t v50 = v46 + 56;
            unint64_t v51 = v52;
            int v53 = *(unsigned __int8 *)(v50 + 32);
            *(unsigned char *)(v48 + 80) = v53;
            long long v54 = (void *)(v48 + 48);
            if (v53)
            {
              int v40 = (void *)a6;
              if (*(void *)v50)
              {
                uint64_t v55 = 0;
                unint64_t v56 = 0;
                uint64_t v57 = v47 + 88 * v36;
                BOOL v58 = (re::TechniqueFunctionConstant **)(v57 + 56);
                BOOL v59 = (uint64_t *)(v57 + 64);
                while (1)
                {
                  int v23 = *v58;
                  if ((unint64_t)*v58 <= v56) {
                    break;
                  }
                  uint64_t v60 = *(void *)(*(void *)(v45 + 96 * v44 + 72) + 8 * v56);
                  uint64_t v61 = *v59;
                  if (!*(unsigned char *)(*v59 + v55)) {
                    *(unsigned char *)(v61 + v55) = 1;
                  }
                  *(void *)(v61 + v55 + 8) = v60;
                  ++v56;
                  v55 += 16;
                  if (*(void *)v50 <= v56) {
                    goto LABEL_68;
                  }
                }
                uint64_t v80 = 0;
                long long v84 = 0u;
                long long v85 = 0u;
                long long v82 = 0u;
                long long v83 = 0u;
                long long v81 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)long long v88 = 136315906;
                *(void *)&v88[4] = "operator[]";
                *(_WORD *)&v88[12] = 1024;
                *(_DWORD *)&v88[14] = 468;
                *(_WORD *)&v88[18] = 2048;
                *(void *)&v88[20] = v56;
                __int16 v89 = 2048;
                unint64_t v90 = (unint64_t)v23;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_72;
              }
            }
            else
            {
              uint64_t v62 = v47 + 88 * v36;
              uint64_t v64 = *(void *)(v62 + 56);
              uint64_t v63 = (unint64_t *)(v62 + 56);
              if (!v64) {
                goto LABEL_76;
              }
              uint64_t v65 = v47 + 88 * v36;
              uint64_t v68 = *(unsigned char **)(v65 + 64);
              BOOL v66 = (void *)(v65 + 64);
              uint64_t v67 = v68;
              if (*v68) {
                *uint64_t v67 = 0;
              }
              int v40 = (void *)a6;
              if (*(void *)v50)
              {
                uint64_t v69 = 0;
                uint64_t v70 = 0;
                while (1)
                {
                  int v23 = (re::TechniqueFunctionConstant *)((char *)v70 + 1);
                  unint64_t v56 = *v63;
                  if (*v63 <= (unint64_t)v70 + 1) {
                    break;
                  }
                  uint64_t v71 = *(void *)(*(void *)(v45 + 96 * v44 + 72) + 8 * (void)v70);
                  uint64_t v72 = *v66 + v69;
                  if (!*(unsigned char *)(v72 + 16)) {
                    *(unsigned char *)(v72 + 16) = 1;
                  }
                  *(void *)(v72 + 24) = v71;
                  v69 += 16;
                  uint64_t v70 = v23;
                  if (*(void *)v50 <= (unint64_t)v23) {
                    goto LABEL_68;
                  }
                }
LABEL_72:
                uint64_t v80 = 0;
                long long v84 = 0u;
                long long v85 = 0u;
                long long v82 = 0u;
                long long v83 = 0u;
                long long v81 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)long long v88 = 136315906;
                *(void *)&v88[4] = "operator[]";
                *(_WORD *)&v88[12] = 1024;
                *(_DWORD *)&v88[14] = 468;
                *(_WORD *)&v88[18] = 2048;
                *(void *)&v88[20] = v23;
                __int16 v89 = 2048;
                unint64_t v90 = v56;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_73:
                v74[0] = 0;
                long long v84 = 0u;
                long long v85 = 0u;
                long long v82 = 0u;
                long long v83 = 0u;
                long long v81 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)long long v88 = 136315906;
                *(void *)&v88[4] = "insert";
                *(_WORD *)&v88[12] = 1024;
                *(_DWORD *)&v88[14] = 855;
                *(_WORD *)&v88[18] = 2048;
                *(void *)&v88[20] = 0;
                __int16 v89 = 2048;
                unint64_t v90 = 0;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_74:
                v74[0] = 0;
                long long v84 = 0u;
                long long v85 = 0u;
                long long v82 = 0u;
                long long v83 = 0u;
                long long v81 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)long long v88 = 136315906;
                *(void *)&v88[4] = "operator[]";
                *(_WORD *)&v88[12] = 1024;
                *(_DWORD *)&v88[14] = 789;
                *(_WORD *)&v88[18] = 2048;
                *(void *)&v88[20] = v36;
                __int16 v89 = 2048;
                unint64_t v90 = v29;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_75:
                uint64_t v80 = 0;
                long long v84 = 0u;
                long long v85 = 0u;
                long long v82 = 0u;
                long long v83 = 0u;
                long long v81 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)long long v88 = 136315906;
                *(void *)&v88[4] = "operator[]";
                *(_WORD *)&v88[12] = 1024;
                *(_DWORD *)&v88[14] = 468;
                *(_WORD *)&v88[18] = 2048;
                *(void *)&v88[20] = v36;
                __int16 v89 = 2048;
                unint64_t v90 = (unint64_t)v23;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_76:
                uint64_t v80 = 0;
                long long v84 = 0u;
                long long v85 = 0u;
                long long v82 = 0u;
                long long v83 = 0u;
                long long v81 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)long long v88 = 136315906;
                *(void *)&v88[4] = "operator[]";
                *(_WORD *)&v88[12] = 1024;
                *(_DWORD *)&v88[14] = 468;
                *(_WORD *)&v88[18] = 2048;
                *(void *)&v88[20] = 0;
                __int16 v89 = 2048;
                unint64_t v90 = 0;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
              }
            }
LABEL_68:
            ++v36;
            re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v74);
            uint64_t v44 = v75;
          }
          while (v75 != -1);
        }
      }
LABEL_69:
      re::FunctionConstantsEnumerator::calculateDerivedFields(v40);
    }
  }
  re::HashBrown<re::DynamicString,re::VariedFunctionConstant,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::deinit((uint64_t)v76);
}

uint64_t re::FunctionConstantsEnumerator::printDebugData(re::FunctionConstantsEnumerator *this)
{
  puts("    variations:");
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    uint64_t v3 = 88 * v2;
    uint64_t v4 = *((void *)this + 2) + 56;
    do
    {
      if (*(unsigned char *)(v4 - 48)) {
        unint64_t v5 = *(const char **)(v4 - 40);
      }
      else {
        unint64_t v5 = (const char *)(v4 - 47);
      }
      printf("      %s %zu", v5, *(void *)v4);
      if (*(unsigned char *)(v4 + 24)) {
        putchar(10);
      }
      else {
        puts(" no default");
      }
      v4 += 88;
      v3 -= 88;
    }
    while (v3);
  }
  return printf("    permutations: %zu\n", *((void *)this + 4));
}

char *re::createVertexFetchArgumentBuffer<re::mtl::RenderCommandEncoder>@<X0>(id *a1@<X0>, id *a2@<X1>, re *a3@<X2>, void *a4@<X8>)
{
  id v7 = objc_msgSend(*a1, sel_newBufferWithLength_options_, 120, 0);
  *a4 = v7;
  uint64_t v8 = (char *)objc_msgSend(v7, sel_contents);
  int v21 = 0;
  memset(v20, 0, sizeof(v20));
  long long v19 = 0u;
  long long v17 = 0u;
  memset(v18, 0, sizeof(v18));
  memset(v16, 0, sizeof(v16));
  long long v15 = 0u;
  memset(v14, 0, sizeof(v14));
  re::createVertexFetchFunctionKey(a3, (uint64_t)v14);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x2B3FAC222C23CAEDLL, *(uint64_t *)&v14[0], SWORD4(v14[0]), 0);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x16172F2CA64F41FLL, *(uint64_t *)((char *)v14 + 12), SWORD2(v14[1]), 1);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x2ACCEB6695018FABLL, *((uint64_t *)&v14[1] + 1), v15, 2);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x2ED0816D3076E801, *(uint64_t *)((char *)&v15 + 4), SWORD6(v15), 3);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x3CB5CD20F43A4EDALL, *(uint64_t *)&v16[0], SWORD4(v16[0]), 4);
  uint64_t v9 = re::internal::compileTimeHornerHash<26ul>(0, 0, 25);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, v9 & 0x7FFFFFFFFFFFFFFFLL, *(uint64_t *)((char *)v16 + 12), SWORD2(v16[1]), 5);
  unint64_t v10 = re::internal::compileTimeHornerHash<17ul>(31, (uint64_t)"lightmapTexcoord", 0, 0, 16);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, v10 & 0x7FFFFFFFFFFFFFFFLL, *((uint64_t *)&v16[1] + 1), v17, 6);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x30989BAE345, *(uint64_t *)((char *)&v17 + 4), SWORD6(v17), 7);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x5E27ADA1858CLL, *(uint64_t *)&v18[0], SWORD4(v18[0]), 8);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x5E27ADA1858DLL, *(uint64_t *)((char *)v18 + 12), SWORD2(v18[1]), 9);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x5E27ADA1858ELL, *((uint64_t *)&v18[1] + 1), v19, 10);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x5E27ADA1858FLL, *(uint64_t *)((char *)&v19 + 4), SWORD6(v19), 11);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x5E27ADA18590, *(uint64_t *)&v20[0], SWORD4(v20[0]), 12);
  re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x5E27ADA18591, *(uint64_t *)((char *)v20 + 12), SWORD2(v20[1]), 13);
  uint64_t v11 = *((void *)&v20[1] + 1);
  __int16 v12 = v21;
  return re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(v8, a3, a2, 0x5E27ADA18592, v11, v12, 14);
}

unint64_t re::createVertexFetchFunctionKey@<X0>(re *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = re::createKeyDesc(this, 0x2B3FAC222C23CAEDLL);
  *(_DWORD *)(a2 + 8) = v5;
  *(void *)(a2 + 12) = re::createKeyDesc(this, 0x16172F2CA64F41FLL);
  *(_DWORD *)(a2 + 20) = v6;
  *(void *)(a2 + 24) = re::createKeyDesc(this, 0x2ACCEB6695018FABLL);
  *(_DWORD *)(a2 + 32) = v7;
  *(void *)(a2 + 36) = re::createKeyDesc(this, 0x2ED0816D3076E801);
  *(_DWORD *)(a2 + 44) = v8;
  *(void *)(a2 + 48) = re::createKeyDesc(this, 0x3CB5CD20F43A4EDALL);
  *(_DWORD *)(a2 + 56) = v9;
  uint64_t v10 = re::internal::compileTimeHornerHash<26ul>(0, 0, 25);
  *(void *)(a2 + 60) = re::createKeyDesc(this, v10 & 0x7FFFFFFFFFFFFFFFLL);
  *(_DWORD *)(a2 + 68) = v11;
  unint64_t v12 = re::internal::compileTimeHornerHash<17ul>(31, (uint64_t)"lightmapTexcoord", 0, 0, 16);
  *(void *)(a2 + 72) = re::createKeyDesc(this, v12 & 0x7FFFFFFFFFFFFFFFLL);
  *(_DWORD *)(a2 + 80) = v13;
  *(void *)(a2 + 84) = re::createKeyDesc(this, 0x30989BAE345);
  *(_DWORD *)(a2 + 92) = v14;
  *(void *)(a2 + 96) = re::createKeyDesc(this, 0x5E27ADA1858CLL);
  *(_DWORD *)(a2 + 104) = v15;
  *(void *)(a2 + 108) = re::createKeyDesc(this, 0x5E27ADA1858DLL);
  *(_DWORD *)(a2 + 116) = v16;
  *(void *)(a2 + 120) = re::createKeyDesc(this, 0x5E27ADA1858ELL);
  *(_DWORD *)(a2 + 128) = v17;
  *(void *)(a2 + 132) = re::createKeyDesc(this, 0x5E27ADA1858FLL);
  *(_DWORD *)(a2 + 140) = v18;
  *(void *)(a2 + 144) = re::createKeyDesc(this, 0x5E27ADA18590);
  *(_DWORD *)(a2 + 152) = v19;
  *(void *)(a2 + 156) = re::createKeyDesc(this, 0x5E27ADA18591);
  *(_DWORD *)(a2 + 164) = v20;
  unint64_t result = re::createKeyDesc(this, 0x5E27ADA18592);
  *(void *)(a2 + 168) = result;
  *(_DWORD *)(a2 + 176) = v22;
  return result;
}

char *re::fillArgBufferForSemantic<re::mtl::RenderCommandEncoder>(char *result, re::AttributeTable *a2, id *a3, uint64_t a4, uint64_t a5, __int16 a6, int a7)
{
  int v8 = result;
  if ((a6 & 0xFF00) == 0)
  {
    int v15 = 0;
LABEL_11:
    *(void *)&v8[8 * a7] = v15;
    return result;
  }
  int v11 = a2;
  do
  {
    unint64_t v12 = v11;
    int v11 = (re::AttributeTable *)*((void *)v11 + 1);
  }
  while (v11 && !*((void *)v12 + 9));
  uint64_t v19 = a4 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v13 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)v12 + 6, &v19);
  if (v13 == -1) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = *(unsigned __int8 *)(*((void *)v12 + 7) + 16 * v13 + 8);
  }
  uint64_t v16 = re::AttributeTable::buffers(a2);
  if (v17 > v14)
  {
    int v18 = (void *)(v16 + 16 * v14);
    objc_msgSend(*a3, sel_useResource_usage_stages_, *v18, 1, 1);
    unint64_t result = (char *)objc_msgSend((id)*v18, sel_gpuAddress);
    int v15 = &result[*((unsigned int *)v18 + 2)];
    goto LABEL_11;
  }
  re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v14, v17);
  unint64_t result = (char *)_os_crash();
  __break(1u);
  return result;
}

char *re::createVertexFetchArgumentBuffer<re::mtl::ComputeCommandEncoder>@<X0>(id *a1@<X0>, id *a2@<X1>, re *a3@<X2>, void *a4@<X8>)
{
  id v7 = objc_msgSend(*a1, sel_newBufferWithLength_options_, 120, 0);
  *a4 = v7;
  int v8 = (char *)objc_msgSend(v7, sel_contents);
  int v21 = 0;
  memset(v20, 0, sizeof(v20));
  long long v19 = 0u;
  long long v17 = 0u;
  memset(v18, 0, sizeof(v18));
  memset(v16, 0, sizeof(v16));
  long long v15 = 0u;
  memset(v14, 0, sizeof(v14));
  re::createVertexFetchFunctionKey(a3, (uint64_t)v14);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x2B3FAC222C23CAEDLL, *(uint64_t *)&v14[0], SWORD4(v14[0]), 0);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x16172F2CA64F41FLL, *(uint64_t *)((char *)v14 + 12), SWORD2(v14[1]), 1);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x2ACCEB6695018FABLL, *((uint64_t *)&v14[1] + 1), v15, 2);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x2ED0816D3076E801, *(uint64_t *)((char *)&v15 + 4), SWORD6(v15), 3);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x3CB5CD20F43A4EDALL, *(uint64_t *)&v16[0], SWORD4(v16[0]), 4);
  uint64_t v9 = re::internal::compileTimeHornerHash<26ul>(0, 0, 25);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, v9 & 0x7FFFFFFFFFFFFFFFLL, *(uint64_t *)((char *)v16 + 12), SWORD2(v16[1]), 5);
  unint64_t v10 = re::internal::compileTimeHornerHash<17ul>(31, (uint64_t)"lightmapTexcoord", 0, 0, 16);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, v10 & 0x7FFFFFFFFFFFFFFFLL, *((uint64_t *)&v16[1] + 1), v17, 6);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x30989BAE345, *(uint64_t *)((char *)&v17 + 4), SWORD6(v17), 7);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x5E27ADA1858CLL, *(uint64_t *)&v18[0], SWORD4(v18[0]), 8);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x5E27ADA1858DLL, *(uint64_t *)((char *)v18 + 12), SWORD2(v18[1]), 9);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x5E27ADA1858ELL, *((uint64_t *)&v18[1] + 1), v19, 10);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x5E27ADA1858FLL, *(uint64_t *)((char *)&v19 + 4), SWORD6(v19), 11);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x5E27ADA18590, *(uint64_t *)&v20[0], SWORD4(v20[0]), 12);
  re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x5E27ADA18591, *(uint64_t *)((char *)v20 + 12), SWORD2(v20[1]), 13);
  uint64_t v11 = *((void *)&v20[1] + 1);
  __int16 v12 = v21;
  return re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(v8, a3, a2, 0x5E27ADA18592, v11, v12, 14);
}

char *re::fillArgBufferForSemantic<re::mtl::ComputeCommandEncoder>(char *result, re::AttributeTable *a2, id *a3, uint64_t a4, uint64_t a5, __int16 a6, int a7)
{
  int v8 = result;
  if ((a6 & 0xFF00) == 0)
  {
    long long v15 = 0;
LABEL_11:
    *(void *)&v8[8 * a7] = v15;
    return result;
  }
  uint64_t v11 = a2;
  do
  {
    __int16 v12 = v11;
    uint64_t v11 = (re::AttributeTable *)*((void *)v11 + 1);
  }
  while (v11 && !*((void *)v12 + 9));
  uint64_t v19 = a4 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v13 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)v12 + 6, &v19);
  if (v13 == -1) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = *(unsigned __int8 *)(*((void *)v12 + 7) + 16 * v13 + 8);
  }
  uint64_t v16 = re::AttributeTable::buffers(a2);
  if (v17 > v14)
  {
    int v18 = (void *)(v16 + 16 * v14);
    [*a3 useResource:*v18 usage:1];
    unint64_t result = (char *)objc_msgSend((id)*v18, sel_gpuAddress);
    long long v15 = &result[*((unsigned int *)v18 + 2)];
    goto LABEL_11;
  }
  re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v14, v17);
  unint64_t result = (char *)_os_crash();
  __break(1u);
  return result;
}

unint64_t re::createKeyDesc(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v3 = a1;
  do
  {
    uint64_t v4 = v3;
    uint64_t v3 = (void *)v3[1];
  }
  while (v3 && !v4[9]);
  *(void *)&v12[0] = a2 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v5 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(v4 + 6, v12);
  if (v5 == -1) {
    return 0;
  }
  int v6 = (unsigned __int8 *)(v4[7] + 16 * v5 + 8);
  do
  {
    id v7 = v2;
    uint64_t v2 = (void *)v2[1];
    unint64_t v8 = v7[4];
    if (v2) {
      BOOL v9 = v8 == 0;
    }
    else {
      BOOL v9 = 0;
    }
  }
  while (v9);
  unint64_t v10 = *v6;
  if (v8 <= v10)
  {
    memset(v12, 0, sizeof(v12));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(unsigned int *)(v7[5] + 16 * v10 + 8) | ((unint64_t)*(unsigned __int16 *)(v7[5] + 16 * v10) << 32);
}

id re::fillConstantsForAttribute(id *a1, uint64_t a2, __int16 a3, unsigned int a4)
{
  HIDWORD(v7) = a3;
  LODWORD(v7) = HIBYTE(a3);
  *(void *)((char *)&v7 + 4) = a2;
  objc_msgSend(*a1, sel_setConstantValue_type_atIndex_, (char *)&v7 + 12, 33, a4, v7);
  objc_msgSend(*a1, sel_setConstantValue_type_atIndex_, (char *)&v7 + 8, 33, a4 + 1);
  objc_msgSend(*a1, sel_setConstantValue_type_atIndex_, (char *)&v7 + 4, 33, a4 + 2);
  return objc_msgSend(*a1, sel_setConstantValue_type_atIndex_, &v7, 33, a4 + 3);
}

void re::getOrCreateVertexFetchFunction(uint64_t a1@<X0>, id *a2@<X1>, uint64_t a3@<X2>, const char *a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  unint64_t v12 = re::Hash<re::CachedStandardVertexFetchFunctionKey>::operator()((uint64_t)v61, a3);
  if (!*(void *)(a1 + 136)
    || (uint64_t v13 = *(unsigned int *)(*(void *)(a1 + 144) + 4 * (v12 % *(unsigned int *)(a1 + 160))),
        v13 == 0x7FFFFFFF))
  {
LABEL_6:
    long long v15 = re::globalAllocators((re *)v12);
    uint64_t v16 = (ArcSharedObject *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15[2] + 32))(v15[2], 208, 8);
    *(_OWORD *)uint64_t v16 = 0u;
    *((_OWORD *)v16 + 1) = 0u;
    *((_OWORD *)v16 + 2) = 0u;
    *((_OWORD *)v16 + 3) = 0u;
    *((_OWORD *)v16 + 4) = 0u;
    *((_OWORD *)v16 + 5) = 0u;
    *((_OWORD *)v16 + 6) = 0u;
    *((_OWORD *)v16 + 7) = 0u;
    *((_OWORD *)v16 + 8) = 0u;
    *((_OWORD *)v16 + 9) = 0u;
    *((_OWORD *)v16 + 10) = 0u;
    *((_OWORD *)v16 + 11) = 0u;
    *((_OWORD *)v16 + 12) = 0u;
    ArcSharedObject::ArcSharedObject(v16, 0);
    *(void *)uint64_t v17 = &unk_26E713B68;
    *(void *)(v17 + 16) = 0;
    *a6 = v17;
    atomic_store(1u, (unsigned __int8 *)(v17 + 204));
    long long v18 = *(_OWORD *)a3;
    long long v19 = *(_OWORD *)(a3 + 16);
    long long v20 = *(_OWORD *)(a3 + 32);
    *(_OWORD *)(v17 + 72) = *(_OWORD *)(a3 + 48);
    *(_OWORD *)(v17 + 56) = v20;
    *(_OWORD *)(v17 + 40) = v19;
    *(_OWORD *)(v17 + 24) = v18;
    long long v21 = *(_OWORD *)(a3 + 64);
    long long v22 = *(_OWORD *)(a3 + 80);
    long long v23 = *(_OWORD *)(a3 + 96);
    *(_OWORD *)(v17 + 136) = *(_OWORD *)(a3 + 112);
    *(_OWORD *)(v17 + 120) = v23;
    *(_OWORD *)(v17 + 104) = v22;
    *(_OWORD *)(v17 + 88) = v21;
    long long v24 = *(_OWORD *)(a3 + 128);
    long long v25 = *(_OWORD *)(a3 + 144);
    long long v26 = *(_OWORD *)(a3 + 160);
    *(_DWORD *)(v17 + 200) = *(_DWORD *)(a3 + 176);
    *(_OWORD *)(v17 + 184) = v26;
    *(_OWORD *)(v17 + 168) = v25;
    *(_OWORD *)(v17 + 152) = v24;
    id v27 = a2[31];
    re::ShaderManager::makeFunctionDescriptor((re::ShaderManager *)a2, &v67);
    objc_msgSend(v67, sel_setName_, objc_msgSend(NSString, sel_stringWithCString_encoding_, "re::vertexfetch::fetchStandardVertexInAttributes", 4));
    id v28 = objc_msgSend(objc_msgSend(MEMORY[0x263F128B0], sel_alloc), sel_init);
    *(void *)uint64_t v61 = v28;
    re::fillConstantsForAttribute((id *)v61, *(void *)a3, *(_DWORD *)(a3 + 8), 0);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 12), *(_DWORD *)(a3 + 20), 4u);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 24), *(_DWORD *)(a3 + 32), 8u);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 36), *(_DWORD *)(a3 + 44), 0xCu);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 48), *(_DWORD *)(a3 + 56), 0x10u);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 60), *(_DWORD *)(a3 + 68), 0x14u);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 72), *(_DWORD *)(a3 + 80), 0x18u);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 84), *(_DWORD *)(a3 + 92), 0x1Cu);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 96), *(_DWORD *)(a3 + 104), 0x20u);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 108), *(_DWORD *)(a3 + 116), 0x24u);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 120), *(_DWORD *)(a3 + 128), 0x28u);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 132), *(_DWORD *)(a3 + 140), 0x2Cu);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 144), *(_DWORD *)(a3 + 152), 0x30u);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 156), *(_DWORD *)(a3 + 164), 0x34u);
    re::fillConstantsForAttribute((id *)v61, *(void *)(a3 + 168), *(_DWORD *)(a3 + 176), 0x38u);
    objc_msgSend(v67, sel_setConstantValues_, v28);
    unint64_t v29 = (_anonymous_namespace_ *)objc_msgSend(v67, sel_setOptions_, 1);
    if (v28) {

    }
    uint64_t v30 = *a6;
    *(void *)uint64_t v61 = v30;
    if (v30) {
      id v31 = (id)(v30 + 8);
    }
    id v32 = v27;
    *(void *)&v61[8] = v32;
    *(void *)&v61[16] = v67;
    uint64_t v62 = a2;
    unint64_t v33 = re::DynamicString::DynamicString((re::DynamicString *)&v63, (const re::DynamicString *)&v65);
    uint64_t v69 = re::globalAllocators(v33)[2];
    uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v69 + 32))(v69, 72, 0);
    *(void *)uint64_t v34 = &unk_26E713B10;
    *(void *)(v34 + 8) = *(void *)v61;
    long long v35 = *(_OWORD *)&v61[8];
    *(_OWORD *)uint64_t v61 = 0u;
    *(_OWORD *)(v34 + 16) = v35;
    *(void *)(v34 + 32) = v62;
    *(_OWORD *)(v34 + 56) = 0u;
    *(void *)(v34 + 40) = v63;
    *(void *)(v34 + 48) = 0;
    *(void *)&v61[16] = 0;
    uint64_t v36 = *((void *)&v63 + 1);
    *(_OWORD *)(v34 + 56) = v64;
    long long v64 = 0uLL;
    uint64_t v37 = *(void *)(v34 + 48);
    *(void *)(v34 + 48) = v36;
    *(void *)&long long v63 = 0;
    *((void *)&v63 + 1) = v37;
    uint64_t v70 = v34;
    re::ShaderManager::scheduleAsyncFuncOnCompilationQueue((uint64_t)a2, 1, a5, (uint64_t)v68);
    re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v68);
    if ((void)v63)
    {
      if (BYTE8(v63)) {
        (*(void (**)(void))(*(void *)v63 + 40))();
      }
      long long v63 = 0u;
      long long v64 = 0u;
    }
    if (*(void *)&v61[16])
    {

      *(void *)&v61[16] = 0;
    }

    if (*(void *)v61) {
    unint64_t v38 = re::Hash<re::CachedStandardVertexFetchFunctionKey>::operator()((uint64_t)v61, a3);
    }
    unint64_t v39 = v38;
    if (*(void *)(a1 + 136))
    {
      unint64_t v40 = v38 % *(unsigned int *)(a1 + 160);
      uint64_t v41 = *(unsigned int *)(*(void *)(a1 + 144) + 4 * v40);
      if (v41 != 0x7FFFFFFF)
      {
        uint64_t v42 = *(void *)(a1 + 152);
        while (!re::EqualTo<re::CachedStandardVertexFetchFunctionKey>::operator()((uint64_t)v61, v42 + 200 * v41 + 12, a3))
        {
          uint64_t v42 = *(void *)(a1 + 152);
          uint64_t v41 = *(_DWORD *)(v42 + 200 * v41 + 8) & 0x7FFFFFFF;
          if (v41 == 0x7FFFFFFF) {
            goto LABEL_25;
          }
        }
        goto LABEL_33;
      }
    }
    else
    {
      LODWORD(v40) = 0;
    }
LABEL_25:
    unsigned int v43 = *(_DWORD *)(a1 + 172);
    if (v43 == 0x7FFFFFFF)
    {
      unsigned int v43 = *(_DWORD *)(a1 + 168);
      unsigned int v44 = v43;
      if (v43 == *(_DWORD *)(a1 + 160))
      {
        re::HashTable<re::CachedStandardVertexFetchFunctionKey,re::SharedPtr<re::CachedVertexFetchFunction>,re::Hash<re::CachedStandardVertexFetchFunctionKey>,re::EqualTo<re::CachedStandardVertexFetchFunctionKey>,true,false>::setCapacity(a1 + 136, 2 * *(_DWORD *)(a1 + 164));
        LODWORD(v40) = v39 % *(unsigned int *)(a1 + 160);
        unsigned int v44 = *(_DWORD *)(a1 + 168);
      }
      *(_DWORD *)(a1 + 168) = v44 + 1;
      uint64_t v45 = *(void *)(a1 + 152);
      int v46 = *(_DWORD *)(v45 + 200 * v43 + 8);
    }
    else
    {
      uint64_t v45 = *(void *)(a1 + 152);
      int v46 = *(_DWORD *)(v45 + 200 * v43 + 8);
      *(_DWORD *)(a1 + 172) = v46 & 0x7FFFFFFF;
    }
    uint64_t v47 = 200 * v43;
    *(_DWORD *)(v45 + v47 + 8) = v46 | 0x80000000;
    *(_DWORD *)(*(void *)(a1 + 152) + v47 + 8) = *(_DWORD *)(*(void *)(a1 + 152) + v47 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 144) + 4 * v40);
    *(void *)(*(void *)(a1 + 152) + v47) = v39;
    uint64_t v48 = *(void *)(a1 + 152) + v47;
    long long v50 = *(_OWORD *)a3;
    long long v49 = *(_OWORD *)(a3 + 16);
    long long v51 = *(_OWORD *)(a3 + 48);
    *(_OWORD *)(v48 + 44) = *(_OWORD *)(a3 + 32);
    *(_OWORD *)(v48 + 60) = v51;
    long long v53 = *(_OWORD *)(a3 + 96);
    long long v52 = *(_OWORD *)(a3 + 112);
    long long v54 = *(_OWORD *)(a3 + 80);
    *(_OWORD *)(v48 + 76) = *(_OWORD *)(a3 + 64);
    *(_OWORD *)(v48 + 92) = v54;
    *(_OWORD *)(v48 + 108) = v53;
    *(_OWORD *)(v48 + 124) = v52;
    int v55 = *(_DWORD *)(a3 + 176);
    long long v57 = *(_OWORD *)(a3 + 144);
    long long v56 = *(_OWORD *)(a3 + 160);
    *(_OWORD *)(v48 + 140) = *(_OWORD *)(a3 + 128);
    *(_OWORD *)(v48 + 156) = v57;
    *(_OWORD *)(v48 + 172) = v56;
    *(_DWORD *)(v48 + 188) = v55;
    *(_OWORD *)(v48 + 12) = v50;
    *(_OWORD *)(v48 + 28) = v49;
    uint64_t v58 = *a6;
    *(void *)(*(void *)(a1 + 152) + v47 + 192) = *a6;
    if (v58) {
      id v59 = (id)(v58 + 8);
    }
    *(_DWORD *)(*(void *)(a1 + 144) + 4 * v40) = v43;
    ++*(_DWORD *)(a1 + 164);
    ++*(_DWORD *)(a1 + 176);
LABEL_33:
    if (v65 && (v66 & 1) != 0) {
      (*(void (**)(void))(*(void *)v65 + 40))();
    }
    if (v67) {

    }
    return;
  }
  uint64_t v14 = *(void *)(a1 + 152);
  while (1)
  {
    unint64_t v12 = re::EqualTo<re::CachedStandardVertexFetchFunctionKey>::operator()((uint64_t)v61, v14 + 200 * v13 + 12, a3);
    uint64_t v14 = *(void *)(a1 + 152);
    if (v12) {
      break;
    }
    uint64_t v13 = *(_DWORD *)(v14 + 200 * v13 + 8) & 0x7FFFFFFF;
    if (v13 == 0x7FFFFFFF) {
      goto LABEL_6;
    }
  }
  *a6 = 0;
  uint64_t v60 = *(void *)(v14 + 200 * v13 + 192);
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a6, v60);
}

void re::createVertexFetchComputePipeline(id *this@<X0>, re::CachedVertexFetchFunction *a2@<X1>, void *a3@<X8>)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  unint64_t v8 = re::globalAllocators((re *)this);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8[2] + 32))(v8[2], 40, 8);
  *(_OWORD *)uint64_t v9 = 0u;
  *(void *)(v9 + 32) = 0;
  *(_OWORD *)(v9 + 16) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v9, 0);
  *unint64_t v10 = &unk_26E713BC8;
  v10[3] = 0;
  *(void *)(v9 + 16) = 0;
  *a3 = v10;
  id v34 = this[2];
  uint64_t v11 = (_anonymous_namespace_ *)objc_msgSend(objc_msgSend(MEMORY[0x263EFF8C0], sel_alloc), sel_initWithObjects_count_, &v34, 1);
  LOBYTE(v41) = 0;
  uint64_t v46 = 0;
  memset(v44, 0, sizeof(v44));
  int v45 = 0;
  int v47 = 16843009;
  uint64_t v48 = 0;
  char v49 = 1;
  if (*((unsigned char *)this + 33))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    uint64_t v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 53;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 45))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    uint64_t v14 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 65589;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 57))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    long long v15 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 131125;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 69))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    uint64_t v16 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 196661;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 81))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    uint64_t v17 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 262197;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 117))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    long long v18 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 327733;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 129))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    long long v19 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 393269;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 141))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    long long v20 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 458805;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 153))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    long long v21 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 524341;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 165))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    long long v22 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 589877;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 177))
  {
    *(_OWORD *)long long v35 = 0u;
    long long v36 = 0u;
    long long v23 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 655413;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 189))
  {
    v35[1] = 0;
    long long v36 = 0uLL;
    long long v24 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 720949;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    unint64_t v12 = (_anonymous_namespace_ *)v35[0];
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      unint64_t v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  if (*((unsigned char *)this + 201))
  {
    v35[1] = 0;
    long long v36 = 0uLL;
    long long v25 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v35, 1);
    int v37 = 786485;
    re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v44, (re::DynamicString *)v35);
    if (v38)
    {
      if (v39)
      {
        (*(void (**)(void))(*(void *)v38 + 40))();
        uint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      uint64_t v38 = 0;
    }
    if (v35[0] && ((uint64_t)v35[1] & 1) != 0) {
      (*(void (**)(void))(*(void *)v35[0] + 40))();
    }
  }
  ComputePipelineState = (id *)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)&v41);
  re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v44);
  if (v43[0])
  {
    if (v43[1]) {
      (*(void (**)(void))(*(void *)v43[0] + 40))();
    }
    memset(v43, 0, sizeof(v43));
  }
  if (_BYTE)v41 && *((void *)&v41 + 1) && (v42) {
    (*(void (**)(void))(**((void **)&v41 + 1) + 40))();
  }
  v35[0] = 0;
  id v33 = objc_msgSend(*ComputePipelineState, sel_newComputePipelineStateWithAdditionalBinaryFunctions_error_, v11, v35);
  id v27 = (re *)objc_msgSend(v33, sel_threadExecutionWidth);
  *(_DWORD *)(v9 + 32) = v27;
  if (v35[0])
  {
    id v28 = *re::graphicsLogObjects(v27);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      id v32 = objc_msgSend(objc_msgSend(v35[0], sel_localizedDescription), sel_cStringUsingEncoding_, 4);
      LODWORD(v41) = 136315138;
      *(void *)((char *)&v41 + 4) = v32;
      _os_log_error_impl(&dword_233120000, v28, OS_LOG_TYPE_ERROR, "Failed to create manual vertex fetch compute pipeline. %s", (uint8_t *)&v41, 0xCu);
    }
  }
  NS::SharedPtr<MTL::Texture>::operator=((void **)(v9 + 16), &v33);
  id v29 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A88], sel_alloc), sel_init);
  objc_msgSend(v29, sel_setFunctionCount_, 1);
  id v30 = objc_msgSend(v33, sel_newVisibleFunctionTableWithDescriptor_, v29);
  *(void *)&long long v41 = v30;
  id v31 = objc_msgSend(v33, sel_functionHandleWithFunction_, this[2]);
  objc_msgSend(v30, sel_setFunction_atIndex_, v31, 0);
  NS::SharedPtr<MTL::Texture>::operator=((void **)(v9 + 24), (void **)&v41);
  if (v31) {

  }
  if ((void)v41) {
  if (v29)
  }

  if (v33) {
  if (v11)
  }

  if (v34) {
}
  }

uint64_t re::internal::compileTimeHornerHash<26ul>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  unint64_t v4 = a3 - a2;
  switch(a3 - a2)
  {
    case 0:
      return v4;
    case 1:
      goto LABEL_4;
    case 2:
      uint64_t v5 = 961 * a1 - aVertdistanceto[a2] + 32 * aVertdistanceto[a2];
      uint64_t v3 = a2 + 1;
      return v5 + aVertdistanceto[v3];
    case 3:
      uint64_t v5 = 29791 * a1 + 961 * aVertdistanceto[a2] - aVertdistanceto[a2 + 1] + 32 * aVertdistanceto[a2 + 1];
      uint64_t v3 = a2 + 2;
      return v5 + aVertdistanceto[v3];
    case 4:
      uint64_t v5 = 923521 * a1
         + 29791 * aVertdistanceto[a2]
         + 961 * aVertdistanceto[a2 + 1]
         - aVertdistanceto[a2 + 2]
         + 32 * aVertdistanceto[a2 + 2];
      uint64_t v3 = a2 + 3;
      return v5 + aVertdistanceto[v3];
    case 5:
      uint64_t v5 = 28629151 * a1
         + 923521 * aVertdistanceto[a2]
         + 29791 * aVertdistanceto[a2 + 1]
         + 961 * aVertdistanceto[a2 + 2]
         - aVertdistanceto[a2 + 3]
         + 32 * aVertdistanceto[a2 + 3];
      uint64_t v3 = a2 + 4;
      return v5 + aVertdistanceto[v3];
    case 6:
      uint64_t v5 = 887503681 * a1
         + 28629151 * aVertdistanceto[a2]
         + 923521 * aVertdistanceto[a2 + 1]
         + 29791 * aVertdistanceto[a2 + 2]
         + 961 * aVertdistanceto[a2 + 3]
         - aVertdistanceto[a2 + 4]
         + 32 * aVertdistanceto[a2 + 4];
      uint64_t v3 = a2 + 5;
      return v5 + aVertdistanceto[v3];
    case 7:
      uint64_t v5 = 0x667E12CDFLL * a1
         + 887503681 * aVertdistanceto[a2]
         + 28629151 * aVertdistanceto[a2 + 1]
         + 923521 * aVertdistanceto[a2 + 2]
         + 29791 * aVertdistanceto[a2 + 3]
         + 961 * aVertdistanceto[a2 + 4]
         - aVertdistanceto[a2 + 5]
         + 32 * aVertdistanceto[a2 + 5];
      uint64_t v3 = a2 + 6;
      return v5 + aVertdistanceto[v3];
    case 8:
      uint64_t v5 = 0xC694446F01 * a1
         + 0x667E12CDFLL * aVertdistanceto[a2]
         + 887503681 * aVertdistanceto[a2 + 1]
         + 28629151 * aVertdistanceto[a2 + 2]
         + 923521 * aVertdistanceto[a2 + 3]
         + 29791 * aVertdistanceto[a2 + 4]
         + 961 * aVertdistanceto[a2 + 5]
         - aVertdistanceto[a2 + 6]
         + 32 * aVertdistanceto[a2 + 6];
      uint64_t v3 = a2 + 7;
      return v5 + aVertdistanceto[v3];
    case 9:
      uint64_t v5 = 0x180BF449711FLL * a1
         + 0xC694446F01 * aVertdistanceto[a2]
         + 0x667E12CDFLL * aVertdistanceto[a2 + 1]
         + 887503681 * aVertdistanceto[a2 + 2]
         + 28629151 * aVertdistanceto[a2 + 3]
         + 923521 * aVertdistanceto[a2 + 4]
         + 29791 * aVertdistanceto[a2 + 5]
         + 961 * aVertdistanceto[a2 + 6]
         - aVertdistanceto[a2 + 7]
         + 32 * aVertdistanceto[a2 + 7];
      uint64_t v3 = a2 + 8;
      return v5 + aVertdistanceto[v3];
    case 10:
      uint64_t v5 = 0x2E97294E4B2C1 * a1
         + 0x180BF449711FLL * aVertdistanceto[a2]
         + 0xC694446F01 * aVertdistanceto[a2 + 1]
         + 0x667E12CDFLL * aVertdistanceto[a2 + 2]
         + 887503681 * aVertdistanceto[a2 + 3]
         + 28629151 * aVertdistanceto[a2 + 4]
         + 923521 * aVertdistanceto[a2 + 5]
         + 29791 * aVertdistanceto[a2 + 6]
         + 961 * aVertdistanceto[a2 + 7]
         - aVertdistanceto[a2 + 8]
         + 32 * aVertdistanceto[a2 + 8];
      uint64_t v3 = a2 + 9;
      return v5 + aVertdistanceto[v3];
    default:
      uint64_t v7 = a2 + (v4 >> 1);
      uint64_t v8 = re::internal::compileTimeHornerHash<26ul>(a1, a2, v7 - 1);
      uint64_t v3 = a3 - 1;
      a1 = re::internal::compileTimeHornerHash<26ul>(aVertdistanceto[v7 - 1] - v8 + 32 * v8, v7, a3 - 1);
LABEL_4:
      uint64_t v5 = 31 * a1;
      return v5 + aVertdistanceto[v3];
  }
}

double re::internal::Callable<re::getOrCreateVertexFetchFunction(re::MeshManager *,re::ShaderManager *,re::CachedStandardVertexFetchFunctionKey const&,char const*,unsigned long long)::$_0,void ()(void)>::Callable(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(void *)a1 = &unk_26E713B10;
  *(void *)(a1 + 8) = v2;
  long long v3 = *(_OWORD *)(a2 + 1);
  *a2 = 0;
  a2[1] = 0;
  *(_OWORD *)(a1 + 16) = v3;
  a2[2] = 0;
  *(void *)(a1 + 32) = a2[3];
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 64) = a2[7];
  uint64_t v5 = a2[5];
  *(void *)(a1 + 40) = a2[4];
  a2[4] = 0;
  uint64_t v6 = a2[6];
  a2[7] = 0;
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 56);
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = v6;
  a2[5] = v8;
  a2[6] = v7;
  return result;
}

uint64_t re::internal::Callable<re::getOrCreateVertexFetchFunction(re::MeshManager *,re::ShaderManager *,re::CachedStandardVertexFetchFunctionKey const&,char const*,unsigned long long)::$_0,void ()(void)>::~Callable(uint64_t a1)
{
  *(void *)a1 = &unk_26E713B10;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {

    *(void *)(a1 + 24) = 0;
  }

  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {

    *(void *)(a1 + 8) = 0;
  }
  return a1;
}

void re::internal::Callable<re::getOrCreateVertexFetchFunction(re::MeshManager *,re::ShaderManager *,re::CachedStandardVertexFetchFunctionKey const&,char const*,unsigned long long)::$_0,void ()(void)>::~Callable(uint64_t a1)
{
  *(void *)a1 = &unk_26E713B10;
  re::DynamicString::deinit((re::DynamicString *)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {

    *(void *)(a1 + 24) = 0;
  }

  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {

    *(void *)(a1 + 8) = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

void re::internal::Callable<re::getOrCreateVertexFetchFunction(re::MeshManager *,re::ShaderManager *,re::CachedStandardVertexFetchFunctionKey const&,char const*,unsigned long long)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v2 = mach_absolute_time();
  re::mtl::Library::makeFunctionWithDescriptor((id *)(a1 + 16), *(void **)(a1 + 24), &v13);
  uint64_t v3 = mach_absolute_time();
  uint64_t v4 = v3;
  double v5 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    uint64_t v3 = mach_timebase_info((mach_timebase_info_t)info);
    if (v3)
    {
      double v8 = NAN;
      goto LABEL_6;
    }
    LODWORD(v6) = *(_DWORD *)info;
    LODWORD(v7) = *(_DWORD *)&info[4];
    double v5 = (double)v6 / (double)v7;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v5;
  }
  double v8 = v5 * (double)(v4 - v2);
LABEL_6:
  uint64_t v9 = *re::graphicsLogObjects((re *)v3);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 48)) {
      uint64_t v10 = *(void *)(a1 + 56);
    }
    else {
      uint64_t v10 = a1 + 49;
    }
    *(_DWORD *)info = 136315394;
    *(void *)&info[4] = v10;
    __int16 v15 = 1024;
    int v16 = (int)(v8 / 1000000.0);
    _os_log_impl(&dword_233120000, v9, OS_LOG_TYPE_DEFAULT, "Manual vertex fetch function compilation completed for %s in %d", info, 0x12u);
  }
  uint64_t v11 = *(void *)(a1 + 8);
  if (v13)
  {
    NS::SharedPtr<MTL::Texture>::operator=((void **)(v11 + 16), &v13);
    unsigned __int8 v12 = 0;
    uint64_t v11 = *(void *)(a1 + 8);
  }
  else
  {
    unsigned __int8 v12 = 2;
  }
  atomic_store(v12, (unsigned __int8 *)(v11 + 204));
  MEMORY[0x237DBC9B0](*(void *)(a1 + 8) + 204);
  if (v13) {
}
  }

void *re::internal::Callable<re::getOrCreateVertexFetchFunction(re::MeshManager *,re::ShaderManager *,re::CachedStandardVertexFetchFunctionKey const&,char const*,unsigned long long)::$_0,void ()(void)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *a2 = &unk_26E713B10;
  a2[1] = v4;
  if (v4) {
    id v5 = (id)(v4 + 8);
  }
  a2[2] = *(id *)(a1 + 16);
  id v6 = *(id *)(a1 + 24);
  uint64_t v7 = *(void *)(a1 + 32);
  a2[3] = v6;
  a2[4] = v7;
  re::DynamicString::DynamicString((re::DynamicString *)(a2 + 5), (const re::DynamicString *)(a1 + 40));
  return a2;
}

double re::internal::Callable<re::getOrCreateVertexFetchFunction(re::MeshManager *,re::ShaderManager *,re::CachedStandardVertexFetchFunctionKey const&,char const*,unsigned long long)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  return re::internal::Callable<re::getOrCreateVertexFetchFunction(re::MeshManager *,re::ShaderManager *,re::CachedStandardVertexFetchFunctionKey const&,char const*,unsigned long long)::$_0,void ()(void)>::Callable(a2, (uint64_t *)(a1 + 8));
}

uint64_t re::internal::Callable<re::getOrCreateVertexFetchFunction(re::MeshManager *,re::ShaderManager *,re::CachedStandardVertexFetchFunctionKey const&,char const*,unsigned long long)::$_0,void ()(void)>::size()
{
  return 72;
}

void re::CachedVertexFetchFunction::~CachedVertexFetchFunction(re::CachedVertexFetchFunction *this)
{
  *(void *)this = &unk_26E713B68;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {

    *((void *)this + 2) = 0;
  }
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26E713B68;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {

    *((void *)this + 2) = 0;
  }
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SharedPersistentObject<re::CachedVertexFetchFunction>::allocator(re *a1)
{
  return re::globalAllocators(a1)[2];
}

void re::HashTable<re::CachedStandardVertexFetchFunctionKey,re::SharedPtr<re::CachedVertexFetchFunction>,re::Hash<re::CachedStandardVertexFetchFunctionKey>,re::EqualTo<re::CachedStandardVertexFetchFunctionKey>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v34, 0, 36);
      *(void *)&v34[36] = 0x7FFFFFFFLL;
      re::HashTable<re::CachedStandardVertexFetchFunctionKey,re::SharedPtr<re::CachedVertexFetchFunction>,re::Hash<re::CachedStandardVertexFetchFunctionKey>,re::EqualTo<re::CachedStandardVertexFetchFunctionKey>,true,false>::init((uint64_t)v34, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v34;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v34[8];
      *(_OWORD *)id v34 = v5;
      *(void *)&v34[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v34[24];
      *(_OWORD *)&v34[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v34[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        uint64_t v14 = (void *)(v6 + 192);
        do
        {
          if ((*(_DWORD *)(v14 - 23) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 24);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            unsigned int v18 = *(_DWORD *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              unsigned int v18 = *(_DWORD *)(a1 + 32);
              unsigned int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<re::CachedStandardVertexFetchFunctionKey,re::SharedPtr<re::CachedVertexFetchFunction>,re::Hash<re::CachedStandardVertexFetchFunctionKey>,re::EqualTo<re::CachedStandardVertexFetchFunctionKey>,true,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                unsigned int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 200 * v18 + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 200 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 200 * v18 + 8) = v21 | 0x80000000;
            uint64_t v22 = *(void *)(a1 + 16) + 200 * v18;
            *(_DWORD *)(v22 + 8) = *(_DWORD *)(v22 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 200 * v18) = v15;
            uint64_t v23 = *(void *)(a1 + 16) + 200 * v18;
            long long v24 = *(_OWORD *)((char *)v14 - 180);
            long long v25 = *(_OWORD *)((char *)v14 - 164);
            long long v26 = *(_OWORD *)((char *)v14 - 148);
            *(_OWORD *)(v23 + 60) = *(_OWORD *)((char *)v14 - 132);
            *(_OWORD *)(v23 + 44) = v26;
            *(_OWORD *)(v23 + 28) = v25;
            *(_OWORD *)(v23 + 12) = v24;
            long long v27 = *(_OWORD *)((char *)v14 - 116);
            long long v28 = *(_OWORD *)((char *)v14 - 100);
            long long v29 = *(_OWORD *)((char *)v14 - 84);
            *(_OWORD *)(v23 + 124) = *(_OWORD *)((char *)v14 - 68);
            *(_OWORD *)(v23 + 108) = v29;
            *(_OWORD *)(v23 + 92) = v28;
            *(_OWORD *)(v23 + 76) = v27;
            long long v30 = *(_OWORD *)((char *)v14 - 52);
            long long v31 = *(_OWORD *)((char *)v14 - 36);
            long long v32 = *(_OWORD *)((char *)v14 - 20);
            *(_DWORD *)(v23 + 188) = *((_DWORD *)v14 - 1);
            *(_OWORD *)(v23 + 172) = v32;
            *(_OWORD *)(v23 + 156) = v31;
            *(_OWORD *)(v23 + 140) = v30;
            *(void *)(*(void *)(a1 + 16) + 200 * v18 + 192) = *v14;
            *uint64_t v14 = 0;
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 25;
        }
        while (v11 < v10);
      }
      re::HashTable<re::CachedStandardVertexFetchFunctionKey,re::SharedPtr<re::CachedVertexFetchPipeline>,re::Hash<re::CachedStandardVertexFetchFunctionKey>,re::EqualTo<re::CachedStandardVertexFetchFunctionKey>,true,false>::deinit((uint64_t *)v34);
    }
  }
  else
  {
    if (a2) {
      signed int v33 = a2;
    }
    else {
      signed int v33 = 3;
    }
  }
}

void re::HashTable<re::CachedStandardVertexFetchFunctionKey,re::SharedPtr<re::CachedVertexFetchFunction>,re::Hash<re::CachedStandardVertexFetchFunctionKey>,re::EqualTo<re::CachedStandardVertexFetchFunctionKey>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    long long v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unsigned int v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 200 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::VertexFetchComputePipeline::~VertexFetchComputePipeline(re::VertexFetchComputePipeline *this)
{
  *(void *)this = &unk_26E713BC8;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {

    *((void *)this + 3) = 0;
  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3)
  {

    *((void *)this + 2) = 0;
  }
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26E713BC8;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {

    *((void *)this + 3) = 0;
  }
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v3)
  {

    *((void *)this + 2) = 0;
  }
  *(void *)this = &unk_26E6DECE0;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SharedPersistentObject<re::VertexFetchComputePipeline>::allocator(re *a1)
{
  return re::globalAllocators(a1)[2];
}

re::JiggleDeformerModelBuilder *re::JiggleDeformerModelBuilder::JiggleDeformerModelBuilder(re::JiggleDeformerModelBuilder *this, re::Allocator *a2, unsigned int a3, unsigned int a4, DeformationModelData *a5)
{
  *(void *)this = a5;
  signed int v9 = (void *)re::DeformationModelData::create<re::JiggleDeformer,re::JiggleDeformerModel>((uint64_t)a5, (uint64_t)a2);
  re::FixedArray<re::StringID>::init<>(v9, (uint64_t)a2, a4);
  re::FixedArray<re::StringID>::init<>(v9 + 3, (uint64_t)a2, a4);
  re::FixedArray<int>::init<>(v9 + 6, (uint64_t)a2, a4);
  re::FixedArray<int>::init<>(v9 + 9, (uint64_t)a2, a4);
  re::FixedArray<unsigned short>::init<unsigned short const&>(v9 + 12, (uint64_t)a2, a3, &re::JiggleDeformerModel::kInvalidIndex);
  return this;
}

uint64_t re::DeformationModelData::create<re::JiggleDeformer,re::JiggleDeformerModel>(uint64_t a1, uint64_t a2)
{
  v8[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 120, 8);
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(void *)(v4 + 112) = 0;
  v6[0] = &unk_26E713C98;
  v6[1] = a2;
  v6[3] = v6;
  uint64_t v7 = v4;
  v8[3] = v8;
  v8[0] = &unk_26E713C98;
  v8[1] = a2;
  std::unique_ptr<void,std::function<void ()(void *)>>::operator=[abi:nn180100]((uint64_t *)(a1 + 680), &v7);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100](&v7);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](v6);
  return *(void *)(a1 + 680);
}

unint64_t *re::JiggleDeformerModelBuilder::setData(re::JiggleDeformerModelBuilder *this, unsigned int a2, unsigned int a3, const re::StringID *a4, const re::StringID *a5, float a6, float a7)
{
  uint64_t v7 = *(void **)(*(void *)this + 680);
  if (v7[13] <= (unint64_t)a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_8;
  }
  *(_WORD *)(v7[14] + 2 * a2) = a3;
  unint64_t v8 = a3;
  if (v7[1] <= (unint64_t)a3)
  {
LABEL_8:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_9;
  }
  re::StringID::operator=((unint64_t *)(v7[2] + 16 * a3), (uint64_t *)a4);
  if (v7[4] <= v8)
  {
LABEL_9:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_10;
  }
  double result = re::StringID::operator=((unint64_t *)(v7[5] + 16 * v8), (uint64_t *)a5);
  if (v7[7] <= v8)
  {
LABEL_10:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_11:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(float *)(v7[8] + 4 * v8) = a6;
  if (v7[10] <= v8) {
    goto LABEL_11;
  }
  *(float *)(v7[11] + 4 * v8) = a7;
  return result;
}

uint64_t re::JiggleDeformer::init(uint64_t this, re::RenderManager *a2)
{
  if (!*(unsigned char *)(this + 8))
  {
    uint64_t v3 = this;
    *(unsigned char *)(this + 8) = 1;
    *(void *)(this + 16) = a2;
    uint64_t v4 = this + 24;
    v3 += 80;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)v3, 0);
    ++*(_DWORD *)(v3 + 24);
    *(_DWORD *)(v3 + 44) = 64;
    unint64_t v6 = re::DataArray<unsigned long>::allocBlock((void *)v3);
    v9[0] = 0;
    uint64_t v15 = 0;
    memset(v13, 0, sizeof(v13));
    int v14 = 0;
    char v16 = 0;
    char v17 = 0;
    uint64_t v18 = 0;
    char v19 = 0;
    ComputePipelineState = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)v9);
    NS::SharedPtr<MTL::Texture>::operator=((void **)(v3 + 120), ComputePipelineState);
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v13);
    this = v12[0];
    if (v12[0])
    {
      if (v12[1]) {
        this = (*(uint64_t (**)(void))(*(void *)v12[0] + 40))();
      }
      memset(v12, 0, sizeof(v12));
    }
    if (v9[0])
    {
      this = v10;
      if (v10)
      {
        if (v11) {
          return (*(uint64_t (**)(void))(*(void *)v10 + 40))();
        }
      }
    }
  }
  return this;
}

int64x2_t re::JiggleDeformer::addDeformationInstance@<Q0>(re::JiggleDeformer *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *((void *)this + 8);
  if (v5)
  {
    unint64_t v6 = *(void *)re::BucketArray<unsigned long,64ul>::operator[]((uint64_t)this + 24, v5 - 1);
    re::BucketArray<unsigned long,64ul>::operator[]((uint64_t)this + 24, *((void *)this + 8) - 1);
    --*((void *)this + 8);
    ++*((_DWORD *)this + 18);
  }
  else
  {
    unint64_t v6 = *((void *)this + 23);
    unint64_t v7 = *((void *)this + 19);
    if (v6 + 1 > v7 << 6)
    {
      re::BucketArray<re::JiggleDeformer::DynamicsState,64ul>::setBucketsCapacity((void *)this + 18, (v6 + 64) >> 6);
      unint64_t v7 = *((void *)this + 19);
    }
    if (v7 <= v6 >> 6)
    {
LABEL_26:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (*((unsigned char *)this + 160)) {
      unint64_t v8 = (char *)this + 168;
    }
    else {
      unint64_t v8 = (char *)*((void *)this + 22);
    }
    uint64_t v9 = *(void *)&v8[8 * (v6 >> 6)];
    ++*((void *)this + 23);
    ++*((_DWORD *)this + 48);
    uint64_t v10 = (void *)(v9 + 16 * (v6 & 0x3F));
    *uint64_t v10 = 0;
    v10[1] = 0;
  }
  int v11 = *((_DWORD *)this + 34);
  if ((v11 + 1) >> 24) {
    int v12 = 1;
  }
  else {
    int v12 = v11 + 1;
  }
  *((_DWORD *)this + 34) = v12;
  uint64_t v13 = *((unsigned __int16 *)this + 66);
  unint64_t v14 = *((unsigned __int16 *)this + 67);
  if (v13 != 0xFFFF || v14 != 0xFFFF)
  {
    if (*((void *)this + 12) > v14)
    {
      uint64_t v18 = (void *)(*((void *)this + 14) + 16 * v14);
      *(_DWORD *)(v18[1] + 4 * v13) = v12;
      char v17 = (_DWORD *)(*v18 + 8 * v13);
      *((_DWORD *)this + 33) = *v17;
      goto LABEL_22;
    }
    goto LABEL_24;
  }
  if (*((_DWORD *)this + 32) >= *((_DWORD *)this + 31)) {
    re::DataArray<unsigned long>::allocBlock((void *)this + 10);
  }
  uint64_t v15 = *((void *)this + 12);
  unint64_t v14 = (unsigned __int16)(v15 - 1);
  if (!v15)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_24:
    uint64_t v20 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v21) = 136315906;
    *(void *)((char *)&v21 + 4) = "operator[]";
    WORD6(v21) = 1024;
    HIWORD(v21) = 789;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_25;
  }
  uint64_t v13 = *((unsigned int *)this + 32);
  if (v13 >= 0x10000)
  {
LABEL_25:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v13, v20, v21);
    _os_crash();
    __break(1u);
    goto LABEL_26;
  }
  char v16 = (void *)(*((void *)this + 14) + 16 * v14);
  *((_DWORD *)this + 32) = v13 + 1;
  *(_DWORD *)(v16[1] + 4 * v13) = *((_DWORD *)this + 34);
  char v17 = (_DWORD *)(*v16 + 8 * v13);
LABEL_22:
  ++*((_DWORD *)this + 30);
  *(void *)char v17 = v6;
  int64x2_t result = vdupq_n_s64(2uLL);
  *(void *)a3 = (v14 << 16) | ((unint64_t)(*((_DWORD *)this + 34) & 0xFFFFFF) << 32) | v13;
  *(int64x2_t *)(a3 + 8) = result;
  *(unsigned char *)(a3 + 24) = 1;
  *(void *)(a3 + 32) = -1;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  return result;
}

_DWORD *re::JiggleDeformer::removeDeformationInstance(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = a1 + 80;
  unint64_t v5 = *(void *)re::DataArray<unsigned long>::get(a1 + 80, a2);
  unint64_t v6 = *(void *)(a1 + 64);
  unint64_t v7 = *(void *)(a1 + 32);
  if (v6 + 1 > v7 << 6)
  {
    re::BucketArray<unsigned long,64ul>::setBucketsCapacity((uint64_t *)(a1 + 24), (v6 + 64) >> 6);
    unint64_t v7 = *(void *)(a1 + 32);
  }
  if (v7 <= v6 >> 6)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 40)) {
    uint64_t v8 = a1 + 48;
  }
  else {
    uint64_t v8 = *(void *)(a1 + 56);
  }
  uint64_t v9 = *(void *)(v8 + 8 * (v6 >> 6));
  ++*(void *)(a1 + 64);
  ++*(_DWORD *)(a1 + 72);
  *(void *)(v9 + 8 * (v6 & 0x3F)) = v5;
  uint64_t v10 = (id *)re::BucketArray<re::JiggleDeformer::DynamicsState,64ul>::operator[](a1 + 144, v5);

  *uint64_t v10 = 0;
  v10[1] = 0;
  return re::DataArray<unsigned long>::destroy(v4, a2);
}

uint64_t re::DataArray<unsigned long>::get(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(*(void *)(a1 + 32) + 16 * HIWORD(a2)) + 8 * (unsigned __int16)a2;
}

uint64_t re::JiggleDeformer::allocateBuffers(re *a1, re::FrameContext *a2, unsigned int a3, void *a4, uint64_t a5)
{
  uint64_t v103 = *MEMORY[0x263EF8340];
  *(void *)a5 |= 2uLL;
  *(unsigned char *)(a5 + 9) = 1;
  re::globalAllocators(a1);
  uint64_t v8 = *((void *)a2 + 3);
  uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 24, 8);
  int v11 = (void *)*((void *)a2 + 3);
  unint64_t v12 = *(void *)(*a4 + 48);
  v10[1] = v12;
  v10[2] = 0;
  *uint64_t v10 = v11;
  if (v12)
  {
    if (v12 >= 0x276276276276277)
    {
LABEL_53:
      re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 104, v12);
      _os_crash();
      __break(1u);
LABEL_54:
      re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    int v11 = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*(void *)v11 + 32))(v11, 104 * v12, 8);
    v10[2] = v11;
    if (!v11) {
      goto LABEL_54;
    }
    unint64_t v5 = (unint64_t)v11;
    if (v12 != 1)
    {
      bzero(v11, 104 * v12 - 104);
      v5 += 104 * v12 - 104;
    }
    *(void *)(v5 + 96) = 0;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)unint64_t v5 = 0u;
    *(_OWORD *)(v5 + 16) = 0u;
  }
  *((void *)&v99 + 1) = re::globalAllocators((re *)v11)[2];
  *(void *)&long long v100 = &v98;
  *(void *)&long long v98 = &unk_26E713C40;
  uint64_t v75 = (*(uint64_t (**)(uint64_t, void *, long long *))(*(void *)v8 + 16))(v8, v10, &v98);
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)&v98);
  uint64_t v73 = *(void *)(*a4 + 48);
  if (v73)
  {
    unint64_t v14 = 0;
    uint64_t v72 = a4;
    while (1)
    {
      uint64_t v15 = a2;
      re::DeformationInstanceIterator::Instance::Instance(&v85, a4, v14);
      char v16 = v88;
      uint64_t v17 = re::DeformationInstanceIterator::Instance::meshPart((uint64_t)&v85, *(void *)(*((void *)a1 + 2) + 32));
      uint64_t v18 = re::DeformationVertexBufferState::inputVertexCount(v16, 1u);
      char v19 = *(void **)(*(void *)(v87 + 344) + 680);
      unint64_t v20 = *(unsigned __int16 *)(v87 + 392);
      unint64_t v21 = v19[13];
      if (v21 <= v20) {
        break;
      }
      unint64_t v5 = *(unsigned __int16 *)(v19[14] + 2 * v20);
      unint64_t v20 = v19[4];
      if (v20 <= v5) {
        goto LABEL_47;
      }
      uint64_t v22 = v18;
      unint64_t v77 = v14;
      uint64_t v78 = (uint64_t)v16;
      uint64_t v23 = 12 * v18;
      re::StringID::StringID((re::StringID *)v84, (const StringID *)(v19[5] + 16 * v5));
      long long v24 = (void *)v17;
      do
      {
        long long v25 = v24;
        long long v24 = (void *)v24[1];
      }
      while (v24 && !v25[9]);
      uint64_t v79 = (re::AttributeTable *)v17;
      *(void *)&long long v98 = v84[0] >> 1;
      uint64_t v26 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(v25 + 6, &v98);
      if (v26 == -1) {
        long long v27 = 0;
      }
      else {
        long long v27 = (unsigned __int8 *)(v25[7] + 16 * v26 + 8);
      }
      int v28 = re::DeformationInstanceIterator::Instance::handle((re::DeformationInstanceIterator::Instance *)&v85);
      long long v29 = (unint64_t *)re::DataArray<unsigned long>::get((uint64_t)a1 + 80, v28);
      long long v30 = (void **)re::BucketArray<re::JiggleDeformer::DynamicsState,64ul>::operator[]((uint64_t)a1 + 144, *v29);
      if (!*v30)
      {
        long long v31 = v79;
        do
        {
          long long v32 = v31;
          long long v31 = (re::AttributeTable *)*((void *)v31 + 1);
        }
        while (v31 && !*((void *)v32 + 9));
        *(void *)&long long v98 = 0x2B3FAC222C23CAEDLL;
        uint64_t v33 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)v32 + 6, &v98);
        if (v33 == -1) {
          id v34 = 0;
        }
        else {
          id v34 = (unsigned __int8 *)(*((void *)v32 + 7) + 16 * v33 + 8);
        }
        unint64_t v12 = *((void *)a1 + 2);
        uint64_t v35 = re::AttributeTable::buffers(v79);
        unint64_t v37 = *v34;
        if (v36 <= v37) {
          goto LABEL_52;
        }
        *(void *)&long long v98 = objc_msgSend(*(id *)(v12 + 184), sel_newBufferWithBytes_length_options_, (char *)objc_msgSend(*(id *)(v35 + 16 * v37), sel_contents)+ *(unsigned int *)(v35 + 16 * v37 + 8), v23, 0);
        NS::SharedPtr<MTL::Texture>::operator=(v30, (void **)&v98);
        if ((void)v98) {
      }
        }
      uint64_t v38 = v30 + 1;
      if (!v30[1])
      {
        *(void *)&long long v98 = objc_msgSend(*(id *)(*((void *)a1 + 2) + 184), sel_newBufferWithLength_options_, v23, 0);
        NS::SharedPtr<MTL::Texture>::operator=(v30 + 1, (void **)&v98);
        if ((void)v98) {
      }
        }
      unint64_t v20 = v19[7];
      if (v20 <= v5) {
        goto LABEL_48;
      }
      unint64_t v20 = v19[10];
      if (v20 <= v5) {
        goto LABEL_49;
      }
      unint64_t v20 = v86;
      unint64_t v12 = *(void *)(v75 + 8);
      if (v12 <= v86) {
        goto LABEL_50;
      }
      int v39 = *(_DWORD *)(v19[8] + 4 * v5);
      int v40 = **(_DWORD **)(*(void *)(v87 + 352) + 160);
      int v41 = *(_DWORD *)(v19[11] + 4 * v5);
      uint64_t v42 = *(void *)(v75 + 16);
      uint64_t v43 = v42 + 104 * v86;
      a2 = v15;
      re::FrameContext::perFrameAlloc(v15, 0x10uLL, 4uLL, (uint64_t)&v98);
      uint64_t v44 = v98;
      uint64_t v45 = v99;
      uint64_t v46 = *((void *)&v98 + 1);
      int v47 = (_DWORD *)(v98 + DWORD2(v98));
      *int v47 = v22;
      v47[1] = v39;
      v47[2] = v41;
      v47[3] = v40;
      *(void *)uint64_t v43 = v44;
      *(void *)(v43 + 8) = v46;
      *(void *)(v43 + 16) = v45;
      *(void *)&long long v98 = *v30;
      DWORD2(v98) = 0;
      HIDWORD(v98) = objc_msgSend(*v30, sel_length);
      NS::SharedPtr<MTL::Texture>::operator=((void **)(v43 + 24), (void **)&v98);
      *(void *)(v43 + 32) = *((void *)&v98 + 1);
      if ((void)v98) {

      }
      *(void *)&long long v98 = *v38;
      DWORD2(v98) = 0;
      HIDWORD(v98) = objc_msgSend(*v38, sel_length);
      unint64_t v12 = v42 + 104 * v20;
      NS::SharedPtr<MTL::Texture>::operator=((void **)(v12 + 40), (void **)&v98);
      *(void *)(v12 + 48) = *((void *)&v98 + 1);
      if ((void)v98) {

      }
      size_t v48 = 4 * v22;
      re::FrameContext::perFrameAlloc(v15, 4 * v22, 4uLL, (uint64_t)&v98);
      uint64_t v49 = v98;
      uint64_t v51 = DWORD2(v98);
      unsigned int v50 = HIDWORD(v98);
      uint64_t v52 = v99;
      uint64_t v53 = v42 + 104 * v20;
      *(void *)(v53 + 80) = v98;
      *(_DWORD *)(v53 + 88) = v51;
      *(_DWORD *)(v53 + 92) = v50;
      *(void *)(v53 + 96) = v52;
      long long v54 = (void *)(v49 + v51);
      a4 = v72;
      if (v27)
      {
        uint64_t v55 = re::AttributeTable::buffers(v79);
        unint64_t v57 = *v27;
        if (v56 <= v57) {
          goto LABEL_51;
        }
        memcpy(v54, (char *)objc_msgSend(*(id *)(v55 + 16 * v57), sel_contents) + *(unsigned int *)(v55 + 16 * v57 + 8), v48);
      }
      else if (v50 >= 4)
      {
        memset_pattern16((void *)(v49 + v51), &unk_2343E10A0, v50 & 0xFFFFFFFC);
      }
      re::FrameContext::perFrameAlloc(v15, v48, 4uLL, (uint64_t)&v98);
      uint64_t v58 = v98;
      uint64_t v59 = DWORD2(v98);
      unsigned int v60 = HIDWORD(v98);
      uint64_t v61 = v99;
      uint64_t v62 = v42 + 104 * v20;
      *(void *)(v62 + 56) = v98;
      *(_DWORD *)(v62 + 64) = v59;
      *(_DWORD *)(v62 + 68) = v60;
      *(void *)(v62 + 72) = v61;
      if (v60 >= 4) {
        memset_pattern16((void *)(v58 + v59), &unk_2343E10A0, v60 & 0xFFFFFFFC);
      }
      uint64_t v63 = v87;
      uint64_t v64 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](*v85 + 8, v86);
      uint64_t v65 = *(void **)(v63 + 360);
      uint64_t v66 = v72[2];
      __int16 v81 = 257;
      int v80 = 65548;
      unint64_t v5 = 30;
      char v83 = 30;
      int v82 = 0;
      unsigned int v67 = re::DeformationBufferAllocator::alloc(v65, v66, 1, (uint64_t)&v80, *(unsigned __int8 *)(v64 + 16), v23);
      uint64_t v68 = re::DeformationBufferAllocator::allocationData(*(re::DeformationBufferAllocator **)(v63 + 360), *(unsigned __int8 *)(v64 + 16), v67);
      LOWORD(v91) = 257;
      int v90 = 65548;
      LOBYTE(v92) = 30;
      HIDWORD(v91) = 0;
      id v69 = objc_msgSend(*(id *)(v68 + 24), sel_contents);
      uint64_t v70 = *(void *)(v68 + 24);
      *(void *)&long long v98 = v69;
      *((void *)&v98 + 1) = *(void *)(v68 + 32);
      *(void *)&long long v99 = v70;
      re::DeformationVertexBufferState::setOutputBuffer(v78, 1u, a3, (uint64_t)&v98, (uint64_t)&v90);
      re::StringID::destroyString((re::StringID *)v84);
      unint64_t v14 = v77 + 1;
      if (v77 + 1 == v73) {
        return v75;
      }
    }
    v84[0] = 0;
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v98 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v90 = 136315906;
    uint64_t v91 = "operator[]";
    __int16 v92 = 1024;
    int v93 = 476;
    __int16 v94 = 2048;
    unint64_t v95 = v20;
    __int16 v96 = 2048;
    unint64_t v97 = v21;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_47:
    v84[0] = 0;
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v98 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v90 = 136315906;
    uint64_t v91 = "operator[]";
    __int16 v92 = 1024;
    int v93 = 476;
    __int16 v94 = 2048;
    unint64_t v95 = v5;
    __int16 v96 = 2048;
    unint64_t v97 = v20;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_48:
    uint64_t v89 = 0;
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v98 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v90 = 136315906;
    uint64_t v91 = "operator[]";
    __int16 v92 = 1024;
    int v93 = 476;
    __int16 v94 = 2048;
    unint64_t v95 = v5;
    __int16 v96 = 2048;
    unint64_t v97 = v20;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_49:
    uint64_t v89 = 0;
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v98 = 0u;
    unint64_t v12 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v90 = 136315906;
    uint64_t v91 = "operator[]";
    __int16 v92 = 1024;
    int v93 = 476;
    __int16 v94 = 2048;
    unint64_t v95 = v5;
    __int16 v96 = 2048;
    unint64_t v97 = v20;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_50:
    uint64_t v89 = 0;
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v98 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v90 = 136315906;
    uint64_t v91 = "operator[]";
    __int16 v92 = 1024;
    int v93 = 468;
    __int16 v94 = 2048;
    unint64_t v95 = v20;
    __int16 v96 = 2048;
    unint64_t v97 = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_51:
    re::internal::assertLog((re::internal *)6, v56, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v57, v56);
    _os_crash();
    __break(1u);
LABEL_52:
    re::internal::assertLog((re::internal *)6, v36, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v37, v36);
    _os_crash();
    __break(1u);
    goto LABEL_53;
  }
  return v75;
}

uint64_t re::JiggleDeformer::deformGPU(uint64_t a1, uint64_t a2, void **this, void *a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  re::mtl::ComputeCommandEncoder::pushDebugGroup(this, (re::ns *)"Jiggle Deformer");
  unsigned int v8 = objc_msgSend(*(id *)(a1 + 200), sel_maxTotalThreadsPerThreadgroup);
  uint64_t v23 = a4;
  uint64_t v22 = *(void *)(*a4 + 48);
  if (v22)
  {
    unint64_t v9 = 0;
    unint64_t v10 = v8;
    uint64_t v21 = v8 - 1;
    do
    {
      re::DeformationInstanceIterator::Instance::Instance(&v24, v23, v9);
      int v11 = v26;
      uint64_t v12 = re::DeformationVertexBufferState::inputVertexCount(v26, 1u);
      unint64_t v13 = v25;
      unint64_t v14 = *(void *)(a2 + 8);
      if (v14 <= v25)
      {
        uint64_t v27 = 0;
        memset(v31, 0, sizeof(v31));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int v28 = 136315906;
        *(void *)&v28[4] = "operator[]";
        *(_WORD *)&v28[12] = 1024;
        *(_DWORD *)&v28[14] = 468;
        *(_WORD *)&v28[18] = 2048;
        *(void *)&v28[20] = v13;
        __int16 v29 = 2048;
        unint64_t v30 = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v15 = *(void *)(a2 + 16) + 104 * v25;
      unint64_t v16 = (v21 + v12) / v10;
      [*this setComputePipelineState:*(void *)(a1 + 200)];
      LOBYTE(v31[0]) = 1;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v11, 1u);
      uint64_t v17 = *(void *)(v11[24]
                      + 32
                      * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v11 + 23, (unsigned __int8 *)v31)+ 24);
      LOBYTE(v31[0]) = 1;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v11, 1u);
      objc_msgSend(*this, "setBuffer:offset:atIndex:", v17, *(unsigned int *)(v11[24]+ 32* re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v11 + 23, (unsigned __int8 *)v31)+ 16), 0);
      LOBYTE(v31[0]) = 1;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v11, 1u);
      uint64_t v18 = *(void *)(v11[8]
                      + 32
                      * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v11 + 7, (unsigned __int8 *)v31)+ 24);
      LOBYTE(v31[0]) = 1;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v11, 1u);
      objc_msgSend(*this, "setBuffer:offset:atIndex:", v18, *(unsigned int *)(v11[8]+ 32* re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v11 + 7, (unsigned __int8 *)v31)+ 16), 1);
      [*this setBuffer:*(void *)(v15 + 24) offset:*(unsigned int *)(v15 + 32) atIndex:2];
      [*this setBuffer:*(void *)(v15 + 40) offset:*(unsigned int *)(v15 + 48) atIndex:3];
      [*this setBuffer:*(void *)(v15 + 72) offset:*(unsigned int *)(v15 + 64) atIndex:4];
      [*this setBuffer:*(void *)(v15 + 96) offset:*(unsigned int *)(v15 + 88) atIndex:5];
      [*this setBuffer:*(void *)(v15 + 16) offset:*(unsigned int *)(v15 + 8) atIndex:6];
      char v19 = *this;
      *(void *)&v31[0] = v16;
      *(int64x2_t *)((char *)v31 + 8) = vdupq_n_s64(1uLL);
      *(void *)int v28 = v10;
      *(_OWORD *)&v28[8] = *(_OWORD *)((char *)v31 + 8);
      [v19 dispatchThreadgroups:v31 threadsPerThreadgroup:v28];
      ++v9;
    }
    while (v22 != v9);
  }
  return [*this popDebugGroup];
}

void re::JiggleDeformer::deformCPU(uint64_t a1, uint64_t a2)
{
}

re::StringID *re::JiggleDeformerModelUtil::envelopeBufferNameForJiggleDataIndex@<X0>(re::JiggleDeformerModelUtil *this@<X0>, const DeformationModelData *a2@<X1>, re::StringID *a3@<X8>)
{
  uint64_t v3 = *((void *)this + 85);
  if (v3 && *(void *)(v3 + 32) > (unint64_t)a2) {
    return re::StringID::StringID(a3, (const StringID *)(*(void *)(v3 + 40) + 16 * a2));
  }
  else {
    return re::StringID::invalid(a3);
  }
}

re::StringID *re::JiggleDeformerModelUtil::massBufferNameForJiggleDataIndex@<X0>(re::JiggleDeformerModelUtil *this@<X0>, const DeformationModelData *a2@<X1>, re::StringID *a3@<X8>)
{
  uint64_t v3 = *((void *)this + 85);
  if (v3 && *(void *)(v3 + 8) > (unint64_t)a2) {
    return re::StringID::StringID(a3, (const StringID *)(*(void *)(v3 + 16) + 16 * a2));
  }
  else {
    return re::StringID::invalid(a3);
  }
}

uint64_t re::JiggleDeformerModelUtil::computeJiggleDeformerModelSizeExcludingMetalBuffers(re::JiggleDeformerModelUtil *this, const DeformationModelData *a2)
{
  uint64_t v2 = (void *)*((void *)this + 85);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2[1];
  uint64_t v4 = 4 * (v2[7] + v2[10]) + 16 * v3 + 120;
  if (v3)
  {
    unint64_t v5 = (const char **)(v2[2] + 8);
    do
    {
      if (*(unsigned char *)(v5 - 1)) {
        size_t v6 = strlen(*v5) + 1;
      }
      else {
        size_t v6 = 0;
      }
      v4 += v6;
      v5 += 2;
      --v3;
    }
    while (v3);
  }
  uint64_t v7 = v2[4];
  uint64_t v8 = v4 + 16 * v7;
  if (v7)
  {
    unint64_t v9 = (const char **)(v2[5] + 8);
    do
    {
      if (*(unsigned char *)(v9 - 1)) {
        size_t v10 = strlen(*v9) + 1;
      }
      else {
        size_t v10 = 0;
      }
      v8 += v10;
      v9 += 2;
      --v7;
    }
    while (v7);
  }
  return v8;
}

void re::internal::Callable<re::JiggleDeformer::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::~Callable()
{
}

void re::internal::Callable<re::JiggleDeformer::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::operator()(uint64_t a1, void **a2)
{
  uint64_t v2 = *a2;
  if (**a2)
  {
    uint64_t v3 = v2[1];
    if (v3)
    {
      uint64_t v4 = 104 * v3;
      unint64_t v5 = (id *)(v2[2] + 40);
      do
      {
        if (*v5)
        {

          id *v5 = 0;
        }
        size_t v6 = *(v5 - 2);
        if (v6)
        {

          *(v5 - 2) = 0;
        }
        v5 += 13;
        v4 -= 104;
      }
      while (v4);
      (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, v2[2]);
      v2[1] = 0;
      v2[2] = 0;
    }
    void *v2 = 0;
  }
}

void *re::internal::Callable<re::JiggleDeformer::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::cloneInto(uint64_t a1, void *a2)
{
  int64x2_t result = a2;
  *a2 = &unk_26E713C40;
  return result;
}

void *re::internal::Callable<re::JiggleDeformer::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::moveInto(uint64_t a1, void *a2)
{
  int64x2_t result = a2;
  *a2 = &unk_26E713C40;
  return result;
}

uint64_t re::internal::Callable<re::JiggleDeformer::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::size()
{
  return 16;
}

void _ZNSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14JiggleDeformerENS2_19JiggleDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14JiggleDeformerENS2_19JiggleDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEv(uint64_t a1)
{
  int64x2_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *int64x2_t result = &unk_26E713C98;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14JiggleDeformerENS2_19JiggleDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEPNS0_6__baseISI_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E713C98;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14JiggleDeformerENS2_19JiggleDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EEclEOSE_(uint64_t result, uint64_t **a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 12);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 9);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 6);
    re::FixedArray<re::StringID>::deinit(v2 + 3);
    re::FixedArray<re::StringID>::deinit(v2);
    uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v3 + 40);
    return v4(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14JiggleDeformerENS2_19JiggleDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14JiggleDeformerENS2_19JiggleDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE11target_typeEv()
{
}

uint64_t *re::BucketArray<unsigned long,64ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  int64x2_t result = re::BucketArray<unsigned long,64ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<unsigned long,64ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 6)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        int64x2_t result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*v3 + 32))(*v3, 512, 0);
        int64x2_t result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        unint64_t v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

_anonymous_namespace_ *re::DataArray<unsigned long>::allocBlock(void *a1)
{
  uint64_t v3 = 8 * *((unsigned int *)a1 + 11);
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(void *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  uint64_t v6 = v4;
  uint64_t v1 = 4 * *((unsigned int *)a1 + 11);
  int64x2_t result = (_anonymous_namespace_ *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(void *)(*a1 + 8));
    int64x2_t result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  unint64_t v9 = result;
  unint64_t v11 = a1[1];
  unint64_t v10 = a1[2];
  if (v10 >= v11)
  {
    unint64_t v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        unint64_t v13 = 2 * v11;
        if (!v11) {
          unint64_t v13 = 8;
        }
        if (v13 <= v12) {
          unint64_t v14 = v12;
        }
        else {
          unint64_t v14 = v13;
        }
        int64x2_t result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v14);
      }
      else
      {
        int64x2_t result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    unint64_t v10 = a1[2];
  }
  uint64_t v15 = (uint64_t *)(a1[4] + 16 * v10);
  uint64_t *v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

void *re::BucketArray<re::JiggleDeformer::DynamicsState,64ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  int64x2_t result = re::BucketArray<re::JiggleDeformer::DynamicsState,64ul>::setBucketsCapacity((void *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::JiggleDeformer::DynamicsState,64ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 6)
    {
      while (1)
      {
        unint64_t v4 = v3[1];
        if (v4 <= a2) {
          break;
        }
        int64x2_t result = (void *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        uint64_t v5 = v3 + 3;
        do
        {
          int64x2_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 1024, 0);
          uint64_t v6 = result;
          if (*v3)
          {
            unint64_t v7 = v3[1];
            int v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              unint64_t v9 = *v5;
              BOOL v11 = v7 >= *v5;
              unint64_t v10 = v7 + 1;
              BOOL v11 = !v11 || v9 >= v10;
              if (v11) {
                goto LABEL_24;
              }
              unint64_t v12 = 2 * v9;
              goto LABEL_20;
            }
            unint64_t v10 = v7 + 1;
            if (v10 >= 3)
            {
              unint64_t v12 = 4;
LABEL_20:
              if (v12 <= v10) {
                unint64_t v14 = v10;
              }
              else {
                unint64_t v14 = v12;
              }
              int64x2_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              int v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v13 = v3[1] + 1;
            int64x2_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            int v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_24:
          uint64_t v15 = v3 + 3;
          if ((v8 & 1) == 0) {
            uint64_t v15 = (void *)v3[4];
          }
          unint64_t v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

BOOL re::LateLatch::shouldApplyHeadPoseLateLatching(re::LateLatch *this)
{
  {
    re::Defaults::BOOLValue((re::Defaults *)"enableHeadPoseLateLatching", v4, v7);
    if (v7[0]) {
      char v5 = v7[1];
    }
    else {
      char v5 = 1;
    }
    re::LateLatch::shouldApplyHeadPoseLateLatching(void)::kEnable = v5;
  }
  v6[0] = 0x95A75B43D56D48D6;
  v6[1] = "overrides:enableHeadPoseLateLatching";
  if (re::s_debugSettingsManager
    && (v7[0] = 0, !re::DebugSettingsManager::getWithErrorCode<BOOL>(re::s_debugSettingsManager, v6, v7)))
  {
    int v1 = v7[0];
  }
  else
  {
    int v1 = re::LateLatch::shouldApplyHeadPoseLateLatching(void)::kEnable;
  }
  BOOL v2 = v1 != 0;
  re::StringID::destroyString((re::StringID *)v6);
  return v2;
}

BOOL re::LateLatch::shouldApplyAnchorLateLatching(re::LateLatch *this)
{
  {
    re::Defaults::BOOLValue((re::Defaults *)"enableAnchorLateLatching", v4, v7);
    if (v7[0]) {
      char v5 = v7[1];
    }
    else {
      char v5 = 1;
    }
    re::LateLatch::shouldApplyAnchorLateLatching(void)::kEnable = v5;
  }
  v6[0] = 0x2BE47D8679B6881ELL;
  v6[1] = "overrides:enableAnchorLateLatching";
  if (re::s_debugSettingsManager
    && (v7[0] = 0, !re::DebugSettingsManager::getWithErrorCode<BOOL>(re::s_debugSettingsManager, v6, v7)))
  {
    int v1 = v7[0];
  }
  else
  {
    int v1 = re::LateLatch::shouldApplyAnchorLateLatching(void)::kEnable;
  }
  BOOL v2 = v1 != 0;
  re::StringID::destroyString((re::StringID *)v6);
  return v2;
}

BOOL re::LateLatch::shouldUseLegacyCodepathForHeadPoseLateLatching(re::LateLatch *this)
{
  {
    re::Defaults::BOOLValue((re::Defaults *)"useLegacyHeadPoseLateLatching", v4, v7);
    if (v7[0]) {
      char v5 = v7[1];
    }
    else {
      char v5 = 0;
    }
    re::LateLatch::shouldUseLegacyCodepathForHeadPoseLateLatching(void)::kEnable = v5;
  }
  v6[0] = 0x4B73D1551D23FEA4;
  v6[1] = "overrides:useLegacyHeadPoseLateLatching";
  if (re::s_debugSettingsManager
    && (v7[0] = 0, !re::DebugSettingsManager::getWithErrorCode<BOOL>(re::s_debugSettingsManager, v6, v7)))
  {
    int v1 = v7[0];
  }
  else
  {
    int v1 = re::LateLatch::shouldUseLegacyCodepathForHeadPoseLateLatching(void)::kEnable;
  }
  BOOL v2 = v1 != 0;
  re::StringID::destroyString((re::StringID *)v6);
  return v2;
}

re::LateLatch *re::ViewConstantsLateLatch::copyOriginalViewConstants(uint64_t a1, _OWORD *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  int64x2_t result = (re::LateLatch *)re::LateLatch::shouldApplyHeadPoseLateLatching((re::LateLatch *)a1);
  if (result)
  {
    if (re::LateLatch::shouldUseLegacyCodepathForHeadPoseLateLatching(result))
    {
      memcpy(v14, a2, sizeof(v14));
      char v5 = (void *)(a1 + 256);
      if (*(unsigned char *)a1)
      {
        return (re::LateLatch *)memmove(v5, a2, 0x400uLL);
      }
      else
      {
        *(unsigned char *)a1 = 1;
        return (re::LateLatch *)memcpy(v5, v14, 0x400uLL);
      }
    }
    else
    {
      long long v6 = a2[32];
      long long v7 = a2[33];
      long long v8 = a2[34];
      long long v9 = a2[35];
      long long v10 = a2[36];
      long long v11 = a2[37];
      long long v12 = a2[39];
      __src[6] = a2[38];
      __src[7] = v12;
      __src[4] = v10;
      __src[5] = v11;
      __src[0] = v6;
      __src[1] = v7;
      __src[2] = v8;
      __src[3] = v9;
      return (re::LateLatch *)re::DynamicArray<re::FixedInlineArray<re::Matrix4x4<float>,2ul>>::add((_anonymous_namespace_ *)(a1 + 1360), __src);
    }
  }
  return result;
}

void *re::DynamicArray<re::FixedInlineArray<re::Matrix4x4<float>,2ul>>::add(_anonymous_namespace_ *this, void *__src)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::FixedInlineArray<re::Matrix4x4<float>,2ul>>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  char v5 = (_OWORD *)(*((void *)this + 4) + (v4 << 7));
  v5[6] = 0u;
  v5[7] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  _OWORD *v5 = 0u;
  v5[1] = 0u;
  int64x2_t result = memmove(v5, __src, 0x80uLL);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

re::LateLatch *re::ViewConstantsLateLatch::trackViewConstantsBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int64x2_t result = (re::LateLatch *)re::LateLatch::shouldApplyHeadPoseLateLatching((re::LateLatch *)a1);
  if (!result) {
    return result;
  }
  int64x2_t result = (re::LateLatch *)re::LateLatch::shouldUseLegacyCodepathForHeadPoseLateLatching(result);
  uint64_t v8 = *a4;
  uint64_t v9 = a4[1];
  if (!result)
  {
    if (!v9) {
      return result;
    }
    uint64_t v21 = 16 * v9;
    for (char i = (int *)(v8 + 12); ; i += 4)
    {
      if (*(i - 3) != 1) {
        goto LABEL_54;
      }
      uint64_t v23 = *(i - 2);
      if (v23)
      {
        if (v23 > 0x100)
        {
          if (v23 <= 0x300)
          {
            uint64_t v25 = 0;
            uint64_t v26 = 0;
            unsigned int v28 = *i + v23;
LABEL_36:
            if (v28 >= 0x320)
            {
              uint64_t v24 = a2 - v23 + *(i - 1) + 768;
              if (v26) {
                goto LABEL_42;
              }
            }
            else
            {
              uint64_t v24 = 0;
              if (v26) {
                goto LABEL_42;
              }
            }
            goto LABEL_40;
          }
          uint64_t v24 = 0;
          uint64_t v25 = 0;
          uint64_t v26 = 0;
          goto LABEL_40;
        }
        uint64_t v26 = 0;
        int v27 = *i;
      }
      else
      {
        int v27 = *i;
        if (*i >= 0x80) {
          uint64_t v26 = a2 + *(i - 1);
        }
        else {
          uint64_t v26 = 0;
        }
      }
      unsigned int v28 = v27 + v23;
      if (v28 >= 0x180)
      {
        uint64_t v25 = a2 - v23 + *(i - 1) + 256;
        goto LABEL_36;
      }
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      if (v26) {
        goto LABEL_42;
      }
LABEL_40:
      if (v25 || v24)
      {
LABEL_42:
        int v29 = *(_DWORD *)(a1 + 1376);
        unint64_t v30 = *(void *)(a1 + 1336);
        unint64_t v31 = *(void *)(a1 + 1328);
        if (v30 >= v31)
        {
          unint64_t v32 = v30 + 1;
          if (v31 < v30 + 1)
          {
            if (*(void *)(a1 + 1320))
            {
              unint64_t v33 = 2 * v31;
              if (!v31) {
                unint64_t v33 = 8;
              }
              if (v33 <= v32) {
                unint64_t v34 = v32;
              }
              else {
                unint64_t v34 = v33;
              }
              int64x2_t result = (re::LateLatch *)re::DynamicArray<re::EvaluationRegister>::setCapacity((void *)(a1 + 1320), v34);
            }
            else
            {
              int64x2_t result = (re::LateLatch *)re::DynamicArray<re::EvaluationRegister>::setCapacity((void *)(a1 + 1320), v32);
              ++*(_DWORD *)(a1 + 1344);
            }
          }
          unint64_t v30 = *(void *)(a1 + 1336);
        }
        uint64_t v35 = *(void *)(a1 + 1352) + 32 * v30;
        *(void *)uint64_t v35 = v26;
        *(void *)(v35 + 8) = v25;
        *(void *)(v35 + 16) = v24;
        *(_DWORD *)(v35 + 24) = v29 - 1;
        *(void *)(a1 + 1336) = v30 + 1;
        ++*(_DWORD *)(a1 + 1344);
      }
LABEL_54:
      v21 -= 16;
      if (!v21) {
        return result;
      }
    }
  }
  if (v9)
  {
    uint64_t v10 = 16 * v9;
    long long v11 = (unsigned int *)(v8 + 8);
    do
    {
      if (*(v11 - 2) == 1)
      {
        int v13 = *(v11 - 1);
        uint64_t v12 = *v11;
        unsigned int v14 = v11[1];
        unint64_t v15 = *(void *)(a1 + 1296);
        unint64_t v16 = *(void *)(a1 + 1288);
        if (v15 >= v16)
        {
          unint64_t v17 = v15 + 1;
          if (v16 < v15 + 1)
          {
            if (*(void *)(a1 + 1280))
            {
              unint64_t v18 = 2 * v16;
              if (!v16) {
                unint64_t v18 = 8;
              }
              if (v18 <= v17) {
                unint64_t v19 = v17;
              }
              else {
                unint64_t v19 = v18;
              }
              int64x2_t result = (re::LateLatch *)re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(a1 + 1280), v19);
            }
            else
            {
              int64x2_t result = (re::LateLatch *)re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(a1 + 1280), v17);
              ++*(_DWORD *)(a1 + 1304);
            }
          }
          unint64_t v15 = *(void *)(a1 + 1296);
        }
        uint64_t v20 = *(void *)(a1 + 1312) + 16 * v15;
        *(void *)uint64_t v20 = a2 + v12;
        *(_DWORD *)(v20 + 8) = v13;
        *(_DWORD *)(v20 + 12) = v14;
        *(void *)(a1 + 1296) = v15 + 1;
        ++*(_DWORD *)(a1 + 1304);
      }
      v11 += 4;
      v10 -= 16;
    }
    while (v10);
  }
  return result;
}

void re::ViewConstantsLateLatch::patchTrackedViewConstantsBuffers(void *a1, float32x4_t *a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,long long __dst,long long a30,long long a31,long long a32,long long a33,long long a34,long long a35,long long a36)
{
  LODWORD(v36) = a4;
  STACK[0xE98] = *MEMORY[0x263EF8340];
  BOOL shouldApplyHeadPoseLateLatching = re::LateLatch::shouldApplyHeadPoseLateLatching((re::LateLatch *)a1);
  if (shouldApplyHeadPoseLateLatching)
  {
    BOOL v41 = a1[172] && a1[167] != 0;
    p_dst = (long long *)(*(unsigned char *)a1 && (unint64_t)(a1[162] != 0));
    BOOL shouldUseLegacyCodepathForHeadPoseLateLatching = re::LateLatch::shouldUseLegacyCodepathForHeadPoseLateLatching((re::LateLatch *)shouldApplyHeadPoseLateLatching);
    int v44 = shouldUseLegacyCodepathForHeadPoseLateLatching ? (int)p_dst : v41;
    if (v44 == 1)
    {
      if (re::LateLatch::shouldUseLegacyCodepathForHeadPoseLateLatching((re::LateLatch *)shouldUseLegacyCodepathForHeadPoseLateLatching))
      {
        *(_OWORD *)&STACK[0xE30] = 0uLL;
        *(_OWORD *)&STACK[0xE40] = 0uLL;
        *(_OWORD *)&STACK[0xE10] = 0uLL;
        *(_OWORD *)&STACK[0xE20] = 0uLL;
        *(_OWORD *)&STACK[0xDF0] = 0uLL;
        *(_OWORD *)&STACK[0xE00] = 0uLL;
        *(_OWORD *)&STACK[0xDD0] = 0uLL;
        *(_OWORD *)&STACK[0xDE0] = 0uLL;
        p_dst = &__dst;
        memcpy(&__dst, a1 + 32, 0x400uLL);
        if (*(void *)(a3 + 8) >= (unint64_t)(int)v36) {
          int v47 = (_OWORD *)(int)v36;
        }
        else {
          int v47 = *(_OWORD **)(a3 + 8);
        }
        if (v47)
        {
          unint64_t v36 = 0;
          while (v36 != 2)
          {
            size_t v48 = &__dst + 4 * v36;
            uint64_t v49 = &STACK[0xDD0] + 8 * v36;
            long long v50 = v48[33];
            *(_OWORD *)uint64_t v49 = v48[32];
            *((_OWORD *)v49 + 1) = v50;
            long long v51 = v48[35];
            *((_OWORD *)v49 + 2) = v48[34];
            *((_OWORD *)v49 + 3) = v51;
            unint64_t v52 = *(void *)(a3 + 8);
            if (v52 <= v36) {
              goto LABEL_64;
            }
            uint64_t v53 = 0;
            float32x4_t v54 = *a2;
            v54.i32[3] = 1.0;
            simd_float4x4 v55 = *(simd_float4x4 *)(*(void *)a3 + (v36 << 6));
            *(_OWORD *)&STACK[0xD90] = xmmword_23435FD50;
            *(_OWORD *)&STACK[0xDA0] = xmmword_23435FD60;
            *(_OWORD *)&STACK[0xDB0] = xmmword_23435FD80;
            *(float32x4_t *)&STACK[0xDC0] = v54;
            do
            {
              *(float32x4_t *)((char *)&STACK[0xE50] + v53) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v55.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&STACK[0xD90]+ v53))), (float32x4_t)v55.columns[1], *(float32x2_t *)((char *)&STACK[0xD90] + v53), 1), (float32x4_t)v55.columns[2], *(float32x4_t *)((char *)&STACK[0xD90] + v53), 2), (float32x4_t)v55.columns[3], *(float32x4_t *)((char *)&STACK[0xD90] + v53), 3);
              v53 += 16;
            }
            while (v53 != 64);
            uint64_t v56 = 0;
            long long v57 = *(_OWORD *)&STACK[0xE50];
            long long v58 = *(_OWORD *)&STACK[0xE60];
            long long v59 = *(_OWORD *)&STACK[0xE70];
            long long v60 = *(_OWORD *)&STACK[0xE80];
            uint64_t v61 = &__dst + 4 * v36;
            *uint64_t v61 = *(_OWORD *)&STACK[0xE50];
            v61[1] = v58;
            v61[2] = v59;
            v61[3] = v60;
            float32x4_t v62 = *(float32x4_t *)v49;
            float32x4_t v63 = *((float32x4_t *)v49 + 1);
            float32x4_t v64 = *((float32x4_t *)v49 + 2);
            float32x4_t v65 = *((float32x4_t *)v49 + 3);
            *(_OWORD *)&STACK[0xD90] = v57;
            *(_OWORD *)&STACK[0xDA0] = v58;
            *(_OWORD *)&STACK[0xDB0] = v59;
            *(_OWORD *)&STACK[0xDC0] = v60;
            do
            {
              *(float32x4_t *)((char *)&STACK[0xE50] + v56) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v62, COERCE_FLOAT(*(_OWORD *)((char *)&STACK[0xD90]+ v56))), v63, *(float32x2_t *)((char *)&STACK[0xD90] + v56), 1), v64, *(float32x4_t *)((char *)&STACK[0xD90] + v56), 2), v65, *(float32x4_t *)((char *)&STACK[0xD90] + v56), 3);
              v56 += 16;
            }
            while (v56 != 64);
            long long v66 = *(_OWORD *)&STACK[0xE60];
            long long v67 = *(_OWORD *)&STACK[0xE70];
            long long v68 = *(_OWORD *)&STACK[0xE80];
            id v69 = &__dst + 4 * v36;
            v69[16] = *(_OWORD *)&STACK[0xE50];
            v69[17] = v66;
            v69[18] = v67;
            v69[19] = v68;
            simd_float4x4 v105 = __invert_f4(v55);
            *((float32x4_t *)&STACK[0xBA0] + v36++) = vsubq_f32((float32x4_t)v105.columns[3], *a2);
            if ((_OWORD *)v36 == v47) {
              goto LABEL_25;
            }
          }
          goto LABEL_62;
        }
LABEL_25:
        uint64_t v70 = a1[162];
        if (v70)
        {
          uint64_t v71 = a1[164];
          uint64_t v72 = v71 + 16 * v70;
          do
          {
            memcpy(*(void **)v71, (char *)&__dst + *(unsigned int *)(v71 + 8), *(unsigned int *)(v71 + 12));
            v71 += 16;
          }
          while (v71 != v72);
        }
      }
      else
      {
        a35 = 0uLL;
        a36 = 0uLL;
        a33 = 0uLL;
        a34 = 0uLL;
        a31 = 0uLL;
        a32 = 0uLL;
        __dst = 0uLL;
        a30 = 0uLL;
        *(_OWORD *)&STACK[0xD90] = 0uLL;
        *(_OWORD *)&STACK[0xDA0] = 0uLL;
        if (*(void *)(a3 + 8) >= (unint64_t)(int)v36) {
          unint64_t v36 = (int)v36;
        }
        else {
          unint64_t v36 = *(void *)(a3 + 8);
        }
        if (v36)
        {
          for (p_dst = 0; p_dst != (long long *)v36; p_dst = (long long *)((char *)p_dst + 1))
          {
            unint64_t v73 = *(void *)(a3 + 8);
            if (v73 <= (unint64_t)p_dst) {
              goto LABEL_63;
            }
            uint64_t v74 = 0;
            float32x4_t v75 = *a2;
            v75.i32[3] = 1.0;
            simd_float4x4 v76 = *(simd_float4x4 *)(*(void *)a3 + ((void)p_dst << 6));
            *(_OWORD *)&STACK[0xE50] = xmmword_23435FD50;
            *(_OWORD *)&STACK[0xE60] = xmmword_23435FD60;
            *(_OWORD *)&STACK[0xE70] = xmmword_23435FD80;
            *(float32x4_t *)&STACK[0xE80] = v75;
            do
            {
              *(float32x4_t *)((char *)&STACK[0xDD0] + v74) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v76.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&STACK[0xE50]+ v74))), (float32x4_t)v76.columns[1], *(float32x2_t *)((char *)&STACK[0xE50] + v74), 1), (float32x4_t)v76.columns[2], *(float32x4_t *)((char *)&STACK[0xE50] + v74), 2), (float32x4_t)v76.columns[3], *(float32x4_t *)((char *)&STACK[0xE50] + v74), 3);
              v74 += 16;
            }
            while (v74 != 64);
            if (p_dst == (long long *)2)
            {
LABEL_65:
              re::internal::assertLog((re::internal *)6, v45, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, 2, 2);
              _os_crash();
              __break(1u);
            }
            long long v77 = *(_OWORD *)&STACK[0xDE0];
            long long v78 = *(_OWORD *)&STACK[0xDF0];
            long long v79 = *(_OWORD *)&STACK[0xE00];
            int v80 = &__dst + 4 * (void)p_dst;
            *int v80 = *(_OWORD *)&STACK[0xDD0];
            v80[1] = v77;
            v80[2] = v78;
            void v80[3] = v79;
            simd_float4x4 v106 = __invert_f4(v76);
            *((float32x4_t *)&STACK[0xD90] + (unint64_t)p_dst) = vsubq_f32((float32x4_t)v106.columns[3], *a2);
          }
        }
        uint64_t v81 = a1[167];
        if (v81)
        {
          uint64_t v82 = a1[169];
          uint64_t v83 = v82 + 32 * v81;
          do
          {
            if (v36)
            {
              for (unint64_t i = 0; i != v36; ++i)
              {
                if (*(void *)v82)
                {
                  if (i >= 2)
                  {
                    re::internal::assertLog((re::internal *)6, v45, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, i, 2);
                    _os_crash();
                    __break(1u);
LABEL_59:
                    *(_OWORD *)&STACK[0xE00] = 0u;
                    *(_OWORD *)&STACK[0xE10] = 0u;
                    *(_OWORD *)&STACK[0xDE0] = 0u;
                    *(_OWORD *)&STACK[0xDF0] = 0u;
                    *(_OWORD *)&STACK[0xDD0] = 0u;
                    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                    LODWORD(STACK[0xE50]) = 136315906;
                    STACK[0xE54] = (unint64_t)"operator[]";
                    LOWORD(STACK[0xE5C]) = 1024;
                    LODWORD(STACK[0xE5E]) = 797;
                    LOWORD(STACK[0xE62]) = 2048;
                    STACK[0xE64] = a3;
                    LOWORD(STACK[0xE6C]) = 2048;
                    STACK[0xE6E] = (unint64_t)a2;
                    _os_log_send_and_compose_impl();
                    _os_crash_msg();
                    __break(1u);
LABEL_60:
                    re::internal::assertLog((re::internal *)6, v45, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 242, i, 2);
                    _os_crash();
                    __break(1u);
LABEL_61:
                    re::internal::assertLog((re::internal *)6, v45, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, i, 2);
                    _os_crash();
                    __break(1u);
LABEL_62:
                    re::internal::assertLog((re::internal *)6, v46, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, 2, 2);
                    _os_crash();
                    __break(1u);
LABEL_63:
                    re::internal::assertLog((re::internal *)6, v45, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, p_dst, v73);
                    _os_crash();
                    __break(1u);
LABEL_64:
                    re::internal::assertLog((re::internal *)6, v46, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v36, v52);
                    _os_crash();
                    __break(1u);
                    goto LABEL_65;
                  }
                  long long v85 = &__dst + 4 * i;
                  unint64_t v86 = (long long *)(*(void *)v82 + (i << 6));
                  long long v87 = v85[1];
                  *unint64_t v86 = *v85;
                  v86[1] = v87;
                  long long v88 = v85[3];
                  v86[2] = v85[2];
                  v86[3] = v88;
                }
                uint64_t v89 = *(void *)(v82 + 8);
                if (v89)
                {
                  a3 = *(unsigned int *)(v82 + 24);
                  a2 = (float32x4_t *)a1[172];
                  if ((unint64_t)a2 <= a3) {
                    goto LABEL_59;
                  }
                  if (i >= 2) {
                    goto LABEL_60;
                  }
                  uint64_t v90 = 0;
                  uint64_t v91 = (float32x4_t *)(a1[174] + (a3 << 7) + (i << 6));
                  float32x4_t v92 = *v91;
                  float32x4_t v93 = v91[1];
                  float32x4_t v94 = v91[2];
                  float32x4_t v95 = v91[3];
                  __int16 v96 = &__dst + 4 * i;
                  long long v97 = v96[1];
                  long long v98 = v96[2];
                  long long v99 = v96[3];
                  *(_OWORD *)&STACK[0xE50] = *v96;
                  *(_OWORD *)&STACK[0xE60] = v97;
                  *(_OWORD *)&STACK[0xE70] = v98;
                  *(_OWORD *)&STACK[0xE80] = v99;
                  do
                  {
                    *(float32x4_t *)((char *)&STACK[0xDD0] + v90) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v92, COERCE_FLOAT(*(_OWORD *)((char *)&STACK[0xE50] + v90))), v93, *(float32x2_t *)((char *)&STACK[0xE50] + v90), 1), v94, *(float32x4_t *)((char *)&STACK[0xE50] + v90), 2), v95, *(float32x4_t *)((char *)&STACK[0xE50] + v90), 3);
                    v90 += 16;
                  }
                  while (v90 != 64);
                  long long v100 = *(_OWORD *)&STACK[0xDE0];
                  long long v101 = *(_OWORD *)&STACK[0xDF0];
                  long long v102 = *(_OWORD *)&STACK[0xE00];
                  uint64_t v103 = (_OWORD *)(v89 + (i << 6));
                  *uint64_t v103 = *(_OWORD *)&STACK[0xDD0];
                  v103[1] = v100;
                  v103[2] = v101;
                  v103[3] = v102;
                }
                uint64_t v104 = *(void *)(v82 + 16);
                if (v104)
                {
                  if (i >= 2) {
                    goto LABEL_61;
                  }
                  *(_OWORD *)(v104 + 16 * i) = *((_OWORD *)&STACK[0xD90] + i);
                }
              }
            }
            v82 += 32;
          }
          while (v82 != v83);
        }
      }
    }
  }
}

void re::InstanceConstantsLateLatch::trackInstanceConstantsBuffer(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned __int8 a5)
{
  if (re::LateLatch::shouldApplyAnchorLateLatching(a1))
  {
    uint64_t v9 = a4[1];
    if (v9)
    {
      uint64_t v10 = *a4;
      uint64_t v11 = 16 * v9;
      uint64_t v12 = (unsigned int *)(v10 + 8);
      do
      {
        if (*(v12 - 2) == 3 && !*(v12 - 1) && v12[1] >= 0x70)
        {
          v13.n128_u64[0] = a2 + *v12;
          v13.n128_u8[8] = a5;
          re::DynamicArray<re::RigNodeConstraint>::add(a1, &v13);
        }
        v12 += 4;
        v11 -= 16;
      }
      while (v11);
    }
  }
}

double re::InstanceConstantsLateLatch::patchTrackedInstanceConstantsBuffers(re::LateLatch *a1, os_unfair_lock_s *a2, uint64_t a3, float32x4_t *a4)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (re::LateLatch::shouldApplyAnchorLateLatching(a1))
  {
    re::LateLatchingManager::getLateLatchPoseCorrections(a2, a3, (uint64_t)&v31);
    uint64_t v10 = *((void *)a1 + 2);
    if (v10)
    {
      uint64_t v11 = (unsigned __int8 *)*((void *)a1 + 4);
      uint64_t v12 = &v11[16 * v10];
      do
      {
        uint64_t v13 = v11[8];
        if (v39)
        {
          if (v36[0])
          {
            unint64_t v14 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v13) ^ ((0xBF58476D1CE4E5B9 * v13) >> 27));
            uint64_t v15 = *(unsigned int *)(v36[1] + 4 * ((v14 ^ (v14 >> 31)) % v38));
            if (v15 != 0x7FFFFFFF)
            {
              while (*(unsigned __int8 *)(v37 + 80 * v15 + 4) != v13)
              {
                LODWORD(v15) = *(_DWORD *)(v37 + 80 * v15) & 0x7FFFFFFF;
                if (v15 == 0x7FFFFFFF) {
                  goto LABEL_14;
                }
              }
              unint64_t v17 = (float32x4_t *)(v37 + 80 * v15 + 16);
LABEL_17:
              uint64_t v20 = 0;
              uint64_t v21 = *(void *)v11;
              long long v22 = *(_OWORD *)(*(void *)v11 + 32);
              float32x4_t v23 = vaddq_f32(*(float32x4_t *)(*(void *)v11 + 48), *a4);
              v23.i32[3] = HIDWORD(*(_OWORD *)(*(void *)v11 + 48));
              *(float32x4_t *)(v21 + 48) = v23;
              float32x4_t v24 = *v17;
              float32x4_t v25 = v17[1];
              float32x4_t v26 = v17[2];
              float32x4_t v27 = v17[3];
              long long v28 = *(_OWORD *)(v21 + 16);
              v40[0] = *(_OWORD *)v21;
              v40[1] = v28;
              v40[2] = v22;
              v40[3] = v23;
              do
              {
                buf.columns[v20] = (simd_float3)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v24, COERCE_FLOAT(v40[v20])), v25, *(float32x2_t *)&v40[v20], 1), v26, (float32x4_t)v40[v20], 2), v27, (float32x4_t)v40[v20], 3);
                ++v20;
              }
              while (v20 != 4);
              simd_float3x3 v44 = buf;
              float32x4_t v29 = v42;
              *(simd_float3 *)uint64_t v21 = buf.columns[0];
              *(simd_float3 *)(v21 + 16) = v44.columns[1];
              *(simd_float3 *)(v21 + 32) = v44.columns[2];
              *(float32x4_t *)(v21 + 48) = v29;
              float32x4_t v30 = vsubq_f32(v29, *a4);
              v30.i32[3] = v29.i32[3];
              *(float32x4_t *)(v21 + 48) = v30;
              simd_float3x3 v45 = __invert_f3(v44);
              *(_DWORD *)(v21 + 72) = v45.columns[2].i32[0];
              *(_DWORD *)(v21 + 88) = v45.columns[2].i32[1];
              *(_DWORD *)(v21 + 104) = v45.columns[2].i32[2];
              *(void *)(v21 + 64) = vzip1q_s32((int32x4_t)v45.columns[0], (int32x4_t)v45.columns[1]).u64[0];
              *(void *)(v21 + 80) = vtrn2q_s32((int32x4_t)v45.columns[0], (int32x4_t)v45.columns[1]).u64[0];
              *(void *)(v21 + 96) = vzip1q_s32(vdupq_laneq_s32((int32x4_t)v45.columns[0], 2), vdupq_laneq_s32((int32x4_t)v45.columns[1], 2)).u64[0];
              goto LABEL_20;
            }
          }
        }
        else if (v33)
        {
          uint64_t v16 = 80 * v33;
          unint64_t v17 = (float32x4_t *)&v35;
          while (v17[-1].u8[0] != v13)
          {
            v17 += 5;
            v16 -= 80;
            if (!v16) {
              goto LABEL_14;
            }
          }
          goto LABEL_17;
        }
LABEL_14:
        unint64_t v18 = *re::graphicsLogObjects((re *)v9);
        BOOL v9 = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
        if (v9)
        {
          __int32 v19 = v11[8];
          buf.columns[0].i32[0] = 67109120;
          buf.columns[0].i32[1] = v19;
          _os_log_error_impl(&dword_233120000, v18, OS_LOG_TYPE_ERROR, "Failed to obtain late-latch state for anchor ID '%u'", (uint8_t *)&buf, 8u);
        }
LABEL_20:
        v11 += 16;
      }
      while (v11 != v12);
    }
    uint64_t v33 = 0;
    ++v34;
    re::HashTable<unsigned char,re::Matrix4x4<float>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,false,false>::deinit(v36);
    uint64_t v31 = 0;
    int v32 = 0;
    return re::HashTable<unsigned char,re::Matrix4x4<float>,re::Hash<unsigned char>,re::EqualTo<unsigned char>,false,false>::deinit(v36);
  }
  return result;
}

re::VFXLateLatch *re::VFXLateLatch::VFXLateLatch(re::VFXLateLatch *this, re::Allocator *a2)
{
  *((void *)this + 4) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *(void *)this = a2;
  re::DynamicArray<re::PatchHandler>::setCapacity(this, 0);
  ++*((_DWORD *)this + 6);
  if (*((void *)this + 1) <= 0x1FuLL) {
    re::DynamicArray<re::PatchHandler>::setCapacity(this, 0x20uLL);
  }
  return this;
}

__n128 re::DynamicArray<re::PatchHandler>::add(_anonymous_namespace_ *this, __n128 *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::PatchHandler>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  __n128 result = *a2;
  *(__n128 *)(*((void *)this + 4) + 16 * v4) = *a2;
  *((void *)this + 2) = v4 + 1;
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::VFXLateLatch::patchTrackedVFXDrawCalls(re::LateLatch *a1, __n128 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = re::LateLatch::shouldApplyHeadPoseLateLatching(a1);
  if (result)
  {
    uint64_t v9 = *((void *)a1 + 2);
    if (v9)
    {
      uint64_t v10 = (uint64_t **)(*((void *)a1 + 4) + 8);
      uint64_t v11 = 16 * v9;
      do
      {
        uint64_t v12 = *v10;
        if (*v10)
        {
          uint64_t result = *v12;
          if (*v12) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(result + 16))(result, a3, a4, *a2);
          }
        }
        v10 += 2;
        v11 -= 16;
      }
      while (v11);
    }
  }
  return result;
}

void *re::DynamicArray<re::FixedInlineArray<re::Matrix4x4<float>,2ul>>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::FixedInlineArray<re::Matrix4x4<float>,2ul>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::FixedInlineArray<re::Matrix4x4<float>,2ul>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::PatchHandler>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::PatchHandler>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::PatchHandler>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::MeshBoundingBoxes::init(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)a1 = *a3;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a2;
  uint64_t v5 = (void *)(a1 + 16);
  BOOL v6 = (_anonymous_namespace_ *)re::DynamicOverflowArray<unsigned int,8ul>::setCapacity((void *)(a1 + 16), 0);
  int v7 = *(_DWORD *)(a1 + 32) + 2;
  *(_DWORD *)(a1 + 32) = v7;
  unint64_t v8 = a3[1];
  unint64_t v9 = *(void *)(a1 + 24);
  if (v9 < v8)
  {
    if (*v5)
    {
      if ((v7 & 1) == 0)
      {
LABEL_4:
        unint64_t v10 = *(void *)(a1 + 40);
LABEL_9:
        if (v10 < v8) {
          re::DynamicOverflowArray<unsigned int,8ul>::setCapacity(v5, v8);
        }
        unint64_t v12 = *(void *)(a1 + 24);
        if (v12 < v8)
        {
          do
          {
            uint64_t v13 = a1 + 40;
            if ((*(unsigned char *)(a1 + 32) & 1) == 0) {
              uint64_t v13 = *(void *)(a1 + 48);
            }
            *(_DWORD *)(v13 + 4 * v12++) = 0;
          }
          while (v8 != v12);
        }
        goto LABEL_15;
      }
    }
    else
    {
      re::DynamicOverflowArray<unsigned int,8ul>::setCapacity(v5, v8);
      int v11 = *(_DWORD *)(a1 + 32) + 2;
      *(_DWORD *)(a1 + 32) = v11;
      if ((v11 & 1) == 0) {
        goto LABEL_4;
      }
    }
    unint64_t v10 = 8;
    goto LABEL_9;
  }
  if (v9 > v8)
  {
LABEL_15:
    *(void *)(a1 + 24) = v8;
    int v7 = *(_DWORD *)(a1 + 32) + 2;
    *(_DWORD *)(a1 + 32) = v7;
    unint64_t v8 = a3[1];
  }
  if (v8 <= 0x40) {
    size_t v14 = 4 * v8;
  }
  else {
    size_t v14 = 256;
  }
  if (v7) {
    uint64_t v15 = (void *)(a1 + 40);
  }
  else {
    uint64_t v15 = *(void **)(a1 + 48);
  }
  if (a3[1] >= 0x41uLL)
  {
    int v17 = 128;
    unint64_t v18 = 64;
    do
    {
      if (*(void *)(a1 + 24) <= v18)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v19 = a1 + 40;
      if ((*(unsigned char *)(a1 + 32) & 1) == 0) {
        uint64_t v19 = *(void *)(a1 + 48);
      }
      *(_DWORD *)(v19 + 4 * v18++) = v17;
      v17 += 2;
    }
    while (v18 < a3[1]);
  }
  return result;
}

void *re::allocInfo_ProtectionOptionsService(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_411, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_411))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF97178, "ProtectionOptionsService");
    __cxa_guard_release(&_MergedGlobals_411);
  }
  return &unk_26AF97178;
}

void re::initInfo_ProtectionOptionsService(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x5EBCAF223B8CB20;
  v5[1] = "ProtectionOptionsService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 8) = &re::initInfo_ProtectionOptionsService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

uint64_t re::introspect_ProtectionOptionsService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ProtectionOptionsService", (uint64_t (*)(re::internal *))re::allocInfo_ProtectionOptionsService, (re::IntrospectionBase *(*)(void))re::initInfo_ProtectionOptionsService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ProtectionOptionsService>, this);
}

uint64_t re::DrawCallMeshPartsDetails::DrawCallMeshPartsDetails(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = a2;
  re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::setCapacity((void *)(a1 + 8), 0);
  ++*(_DWORD *)(a1 + 32);
  v10[0] = *(unsigned char *)a5;
  if (v10[0]) {
    int v11 = *(_DWORD *)(a5 + 4);
  }
  re::DrawCallMeshPartsDetails::appendPerMeshPartDetails(a1, a3, a4, (uint64_t)v10);
  return a1;
}

void *re::DrawCallMeshPartsDetails::appendPerMeshPartDetails(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v17[0] = 0;
  if (a3)
  {
    re::DynamicString::format(*(re::DynamicString **)a1, (re::Allocator *)"%s", (re::DynamicString *)&v14, a3);
    LOBYTE(v8) = 1;
    uint64_t v9 = v14;
    uint64_t v11 = v16;
    long long v10 = v15;
    re::Optional<re::DynamicString>::operator=(v17, &v8);
    if (_BYTE)v8 && v9 && (v10) {
      (*(void (**)(void))(*(void *)v9 + 40))();
    }
    uint64_t v8 = a2;
    LOBYTE(v9) = v17[0];
    if (v17[0]) {
      re::DynamicString::DynamicString((re::DynamicString *)&v10, (const re::DynamicString *)&v18);
    }
  }
  else
  {
    uint64_t v8 = a2;
    LOBYTE(v9) = 0;
  }
  if (*(unsigned char *)a4) {
    int v13 = *(_DWORD *)(a4 + 4);
  }
  uint64_t result = re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::add((void *)(a1 + 8), (uint64_t)&v8);
  if ((_BYTE)v9)
  {
    uint64_t result = (void *)v10;
    if ((void)v10)
    {
      if (BYTE8(v10)) {
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
      }
    }
  }
  if (v17[0])
  {
    uint64_t result = v18;
    if (v18)
    {
      if (v19) {
        return (void *)(*(uint64_t (**)(void *, uint64_t))(*v18 + 40))(v18, v20);
      }
    }
  }
  return result;
}

void *re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::add(void *this, uint64_t a2)
{
  unint64_t v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  uint64_t v5 = v3[4];
  uint64_t v6 = v5 + 56 * v4;
  *(void *)uint64_t v6 = *(void *)a2;
  int v7 = *(unsigned __int8 *)(a2 + 8);
  *(unsigned char *)(v6 + 8) = v7;
  if (v7)
  {
    uint64_t v8 = v5 + 56 * v4;
    *(_OWORD *)(v8 + 16) = 0u;
    *(_OWORD *)(v8 + 32) = 0u;
    *(void *)(v8 + 40) = *(void *)(a2 + 40);
    uint64_t v9 = *(void *)(a2 + 24);
    *(void *)(v8 + 16) = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = 0;
    uint64_t v10 = *(void *)(a2 + 32);
    *(void *)(a2 + 40) = 0;
    uint64_t v12 = *(void *)(v8 + 24);
    uint64_t v11 = *(void *)(v8 + 32);
    *(void *)(v8 + 24) = v9;
    *(void *)(v8 + 32) = v10;
    *(void *)(a2 + 24) = v12;
    *(void *)(a2 + 32) = v11;
  }
  int v13 = *(unsigned __int8 *)(a2 + 48);
  *(unsigned char *)(v5 + 56 * v4 + 48) = v13;
  if (v13) {
    *(_DWORD *)(v5 + 56 * v4 + 52) = *(_DWORD *)(a2 + 52);
  }
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

uint64_t re::DrawCallRecorderGroup::DrawCallRecorderGroup(uint64_t a1, const char *a2, const char *a3, uint64_t a4)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((void *)a1, 0);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  re::DynamicString::setCapacity((void *)(a1 + 32), 0);
  *(void *)(a1 + 64) = a4;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(void *)(a1 + 72) = a4;
  re::DynamicArray<re::DrawCallRecorderGroup::SortingContext>::setCapacity((void *)(a1 + 72), 0);
  ++*(_DWORD *)(a1 + 96);
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(void *)(a1 + 148) = 0x7FFFFFFFLL;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 160) = a4;
  re::DynamicArray<re::EncodedDrawCallDetails>::setCapacity((void *)(a1 + 160), 0);
  ++*(_DWORD *)(a1 + 184);
  *(unsigned char *)(a1 + 208) = 0;
  if (!a2) {
    a2 = "nullptr";
  }
  uint64_t v11 = a2;
  size_t v12 = strlen(a2);
  re::DynamicString::operator=((re::DynamicString *)a1, (uint64_t)&v11);
  if (!a3) {
    a3 = "nullptr";
  }
  size_t v9 = strlen(a3);
  uint64_t v11 = a3;
  size_t v12 = v9;
  re::DynamicString::operator=((re::DynamicString *)(a1 + 32), (uint64_t)&v11);
  return a1;
}

uint64_t re::DrawCallRecorderGroup::allocateSortingDebugContextAndReturnIndex(re::DrawCallRecorderGroup *this)
{
  uint64_t v1 = *((void *)this + 11);
  unint64_t v2 = (void *)((char *)this + 72);
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  int32x4_t v6 = 0u;
  long long v7 = 0u;
  memset(v5, 0, sizeof(v5));
  re::DynamicString::setCapacity(v5, 0);
  *(void *)&long long v3 = 0x7F0000007FLL;
  *((void *)&v3 + 1) = 0x7F0000007FLL;
  int32x4_t v6 = vdupq_n_s32(0x7F800000u);
  long long v7 = v3;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  LOBYTE(v12) = 0;
  re::DynamicArray<re::DrawCallRecorderGroup::SortingContext>::add(v2, (uint64_t)v5);
  if (*(void *)&v5[0] && (BYTE8(v5[0]) & 1) != 0) {
    (*(void (**)(void))(**(void **)&v5[0] + 40))();
  }
  return v1;
}

void *re::DynamicArray<re::DrawCallRecorderGroup::SortingContext>::add(void *this, uint64_t a2)
{
  long long v3 = this;
  unint64_t v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::DrawCallRecorderGroup::SortingContext>::growCapacity(this, v4 + 1);
    unint64_t v4 = v3[2];
  }
  uint64_t v5 = v3[4];
  uint64_t v6 = v5 + 160 * v4;
  *(_OWORD *)uint64_t v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(void *)(v6 + 24) = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 8);
  *(void *)uint64_t v6 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v8 = *(void *)(a2 + 16);
  *(void *)(a2 + 24) = 0;
  uint64_t v10 = *(void *)(v6 + 8);
  uint64_t v9 = *(void *)(v6 + 16);
  *(void *)(v6 + 8) = v7;
  *(void *)(v6 + 16) = v8;
  *(void *)(a2 + 8) = v10;
  *(void *)(a2 + 16) = v9;
  long long v11 = *(_OWORD *)(a2 + 64);
  long long v12 = *(_OWORD *)(a2 + 80);
  long long v13 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v6 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(v6 + 112) = v13;
  *(_OWORD *)(v6 + 64) = v11;
  *(_OWORD *)(v6 + 80) = v12;
  long long v14 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v6 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v6 + 48) = v14;
  LODWORD(v8) = *(unsigned __int8 *)(a2 + 128);
  *(unsigned char *)(v6 + 128) = v8;
  if (v8) {
    *(_OWORD *)(v5 + 160 * v4 + 144) = *(_OWORD *)(a2 + 144);
  }
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

re::DynamicString *re::DrawCallRecorderGroup::getSortingContext@<X0>(re::DynamicString *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*(unsigned char *)a2 && (unint64_t v4 = *(unsigned int *)(a2 + 4), *((void *)result + 11) > v4))
  {
    uint64_t v5 = *((void *)result + 13);
    uint64_t v6 = v5 + 160 * v4;
    *(unsigned char *)a3 = 1;
    uint64_t result = re::DynamicString::DynamicString((re::DynamicString *)(a3 + 16), (const re::DynamicString *)v6);
    long long v7 = *(_OWORD *)(v6 + 48);
    *(_OWORD *)(a3 + 48) = *(_OWORD *)(v6 + 32);
    *(_OWORD *)(a3 + 64) = v7;
    long long v8 = *(_OWORD *)(v6 + 64);
    long long v9 = *(_OWORD *)(v6 + 80);
    long long v10 = *(_OWORD *)(v6 + 112);
    *(_OWORD *)(a3 + 112) = *(_OWORD *)(v6 + 96);
    *(_OWORD *)(a3 + 128) = v10;
    *(_OWORD *)(a3 + 80) = v8;
    *(_OWORD *)(a3 + 96) = v9;
    int v11 = *(unsigned __int8 *)(v6 + 128);
    *(unsigned char *)(a3 + 144) = v11;
    if (v11) {
      *(_OWORD *)(a3 + 160) = *(_OWORD *)(v5 + 160 * v4 + 144);
    }
  }
  else
  {
    *(unsigned char *)a3 = 0;
  }
  return result;
}

uint64_t re::DrawCallRecorderGroup::getMutableSortingContext(uint64_t a1, unsigned int a2)
{
  if (*(void *)(a1 + 88) <= (unint64_t)a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(a1 + 104) + 160 * a2;
}

unint64_t re::HashTable<unsigned int,re::DrawCallMeshPartsDetails,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add(uint64_t a1, _DWORD *a2, void *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  unint64_t v8 = v7 ^ (v7 >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned int,re::DrawCallMeshPartsDetails,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    unint64_t v12 = *(void *)(a1 + 16) + ((unint64_t)v13 << 6);
    return v12 + 16;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(_DWORD *)(v11 + (v10 << 6) + 12) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + (v10 << 6) + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  unint64_t v12 = v11 + (v10 << 6);
  return v12 + 16;
}

uint64_t re::DrawCallRecorderGroup::recordEncodedDrawCall(uint64_t a1, uint64_t a2, const char *a3, unsigned __int8 *a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  unsigned int v13 = *(re::Allocator **)(a1 + 64);
  long long v14 = re::DynamicString::DynamicString((re::DynamicString *)&v64, "", v13);
  long long v67 = 0u;
  long long v66 = 0u;
  long long v15 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v66, 0);
  long long v68 = 0u;
  long long v69 = 0u;
  re::DynamicString::setCapacity(&v68, 0);
  v70[0] = 0;
  *(void *)&v82[1] = 134217472;
  *(void *)&v82[9] = 134217472;
  re::DynamicString::DynamicString((re::DynamicString *)v83, "", v13);
  unsigned __int8 v84 = 0;
  if (a3) {
    uint64_t v16 = a3;
  }
  else {
    uint64_t v16 = "nullptr";
  }
  long long v59 = v16;
  *(void *)&long long v60 = strlen(v16);
  re::DynamicString::operator=((re::DynamicString *)&v64, (uint64_t)&v59);
  re::DynamicString::format(*(re::DynamicString **)(a1 + 64), (re::Allocator *)"Unknown", (re::DynamicString *)&v59);
  int v18 = *a4;
  int v17 = (re::DynamicString *)(a4 + 8);
  if (v18) {
    char v19 = v17;
  }
  else {
    char v19 = (re::DynamicString *)&v59;
  }
  re::DynamicString::operator=((re::DynamicString *)&v66, v19);
  if (v59 && (v60 & 1) != 0) {
    (*(void (**)(void))(*(void *)v59 + 40))();
  }
  re::DynamicString::format(*(re::DynamicString **)(a1 + 64), (re::Allocator *)"Unknown", (re::DynamicString *)&v59);
  int v21 = *a5;
  uint64_t v20 = (re::DynamicString *)(a5 + 8);
  if (v21) {
    long long v22 = v20;
  }
  else {
    long long v22 = (re::DynamicString *)&v59;
  }
  re::DynamicString::operator=((re::DynamicString *)&v68, v22);
  if (v59 && (v60 & 1) != 0) {
    (*(void (**)(void))(*(void *)v59 + 40))();
  }
  if (v70[0] || *(unsigned char *)a6)
  {
    if (!v70[0] || *(unsigned char *)a6)
    {
      if (v70[0] || !*(unsigned char *)a6)
      {
        long long v24 = *(_OWORD *)(a6 + 24);
        long long v71 = *(_OWORD *)(a6 + 8);
        long long v72 = v24;
        long long v73 = *(_OWORD *)(a6 + 40);
        int v74 = *(_DWORD *)(a6 + 56);
        if (v75 || *(unsigned char *)(a6 + 60))
        {
          if (!v75 || *(unsigned char *)(a6 + 60))
          {
            if (!v75) {
              char v75 = *(unsigned char *)(a6 + 60) != 0;
            }
            char v76 = *(unsigned char *)(a6 + 61);
          }
          else
          {
            char v75 = 0;
          }
        }
        re::DynamicArray<re::RenderAttachmentState>::operator=((uint64_t)&v77, (uint64_t *)(a6 + 64));
      }
      else
      {
        v70[0] = 1;
        long long v23 = *(_OWORD *)(a6 + 24);
        long long v71 = *(_OWORD *)(a6 + 8);
        long long v72 = v23;
        long long v73 = *(_OWORD *)(a6 + 40);
        int v74 = *(_DWORD *)(a6 + 56);
        char v75 = *(unsigned char *)(a6 + 60);
        if (v75) {
          char v76 = *(unsigned char *)(a6 + 61);
        }
        re::DynamicArray<re::RenderAttachmentState>::DynamicArray((uint64_t)&v77, (uint64_t *)(a6 + 64));
      }
    }
    else
    {
      if (v77)
      {
        if (v81) {
          (*(void (**)(void))(*(void *)v77 + 40))();
        }
        uint64_t v81 = 0;
        uint64_t v78 = 0;
        uint64_t v79 = 0;
        uint64_t v77 = 0;
        ++v80;
      }
      v70[0] = 0;
    }
  }
  v82[0] = *(unsigned char *)(a2 + 72);
  *(_OWORD *)&v82[1] = *(_OWORD *)a7;
  v82[17] = *(unsigned char *)(a7 + 16);
  char v89 = a9;
  if (*(unsigned char *)(a2 + 48))
  {
    if (*(void *)(a1 + 112))
    {
      unint64_t v25 = *(unsigned int *)(a2 + 52);
      unint64_t v26 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) >> 27));
      uint64_t v27 = *(unsigned int *)(*(void *)(a1 + 120) + 4 * ((v26 ^ (v26 >> 31)) % *(unsigned int *)(a1 + 136)));
      if (v27 != 0x7FFFFFFF)
      {
        uint64_t v28 = *(void *)(a1 + 128);
        int v29 = *(_DWORD *)(v28 + (v27 << 6) + 12);
        if (v29 != v25)
        {
          uint64_t v32 = v27;
          while (1)
          {
            uint64_t v32 = *(_DWORD *)(v28 + (v32 << 6) + 8) & 0x7FFFFFFF;
            if (v32 == 0x7FFFFFFF) {
              goto LABEL_62;
            }
            if (*(_DWORD *)(v28 + (v32 << 6) + 12) == v25)
            {
              while (v29 != v25)
              {
                uint64_t v27 = *(_DWORD *)(v28 + (v27 << 6) + 8) & 0x7FFFFFFF;
                if (v27 == 0x7FFFFFFF)
                {
                  LODWORD(v27) = 0x7FFFFFFF;
                  goto LABEL_43;
                }
                int v29 = *(_DWORD *)(v28 + (v27 << 6) + 12);
              }
              break;
            }
          }
        }
LABEL_43:
        uint64_t v30 = v28 + ((unint64_t)v27 << 6);
        LOBYTE(v59) = 1;
        *(void *)&long long v60 = *(void *)(v30 + 16);
        re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::DynamicArray((uint64_t)&v60 + 8, (uint64_t *)(v30 + 24));
        if (v84 | v59)
        {
          if (v84 && !(_BYTE)v59)
          {
            re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::deinit((uint64_t)&v85 + 8);
            unsigned __int8 v84 = 0;
            if (!(_BYTE)v59) {
              goto LABEL_62;
            }
            goto LABEL_61;
          }
          if (!v84 && (_BYTE)v59)
          {
            unsigned __int8 v84 = 1;
            long long v85 = v60;
            long long v86 = v61;
            *((void *)&v60 + 1) = 0;
            long long v61 = 0uLL;
            uint64_t v88 = v63;
            uint64_t v63 = 0;
            ++v62;
            int v87 = 1;
LABEL_61:
            re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::deinit((uint64_t)&v60 + 8);
            goto LABEL_62;
          }
          *(void *)&long long v85 = v60;
          uint64_t v33 = *((void *)&v85 + 1);
          if (*((void *)&v85 + 1) && *((void *)&v60 + 1) && *((void *)&v85 + 1) != *((void *)&v60 + 1))
          {
            re::internal::assertLog((re::internal *)4, v31, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
            uint64_t result = _os_crash();
            __break(1u);
            return result;
          }
          *((void *)&v85 + 1) = *((void *)&v60 + 1);
          *((void *)&v60 + 1) = v33;
          long long v34 = v86;
          long long v86 = v61;
          long long v61 = v34;
          uint64_t v35 = v88;
          uint64_t v88 = v63;
          uint64_t v63 = v35;
          ++v62;
          ++v87;
          if ((_BYTE)v59) {
            goto LABEL_61;
          }
        }
      }
    }
  }
LABEL_62:
  re::DynamicString::format(*(re::DynamicString **)(a1 + 64), (re::Allocator *)"Unknown", (re::DynamicString *)&v59);
  unint64_t v36 = *(char *)(a2 + 3);
  if (v36 <= 2)
  {
    uint64_t v37 = off_264BE7650[v36];
    size_t v38 = strlen(v37);
    long long v57 = v37;
    uint64_t v58 = v38;
    re::DynamicString::operator=((re::DynamicString *)&v59, (uint64_t)&v57);
  }
  if (v60) {
    int v39 = (char *)*((void *)&v60 + 1);
  }
  else {
    int v39 = (char *)&v60 + 1;
  }
  re::DynamicString::format(*(re::DynamicString **)(a1 + 64), (re::Allocator *)"InstanceCount: %zu InstanceOffset: %d VertexCount: %d IndexCount: %d TechniqueIndex: %d DrawCallType: %s", (re::DynamicString *)&v57, a8, *(unsigned int *)(a2 + 40), *(unsigned int *)(a2 + 16), *(unsigned int *)(a2 + 20), *(unsigned int *)(a2 + 44), v39);
  re::DynamicString::operator=((re::DynamicString *)v83, (re::DynamicString *)&v57);
  int v40 = (_anonymous_namespace_ *)v57;
  if (v57 && (v58 & 1) != 0) {
    int v40 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v57 + 40))();
  }
  if (a9)
  {
    long long v57 = "(VFX, details unavailable)";
    uint64_t v58 = 26;
    int v40 = re::DynamicString::operator=((re::DynamicString *)v83, (uint64_t)&v57);
  }
  unint64_t v41 = *(void *)(a1 + 168);
  unint64_t v42 = *(void *)(a1 + 176);
  if (v42 >= v41)
  {
    if (v41 < v42 + 1)
    {
      if (*(void *)(a1 + 160))
      {
        uint64_t v43 = 2 * v41;
        BOOL v44 = v41 == 0;
        unint64_t v45 = 8;
        if (!v44) {
          unint64_t v45 = v43;
        }
        if (v45 <= v42 + 1) {
          unint64_t v46 = v42 + 1;
        }
        else {
          unint64_t v46 = v45;
        }
        re::DynamicArray<re::EncodedDrawCallDetails>::setCapacity((void *)(a1 + 160), v46);
      }
      else
      {
        re::DynamicArray<re::EncodedDrawCallDetails>::setCapacity((void *)(a1 + 160), v42 + 1);
        ++*(_DWORD *)(a1 + 184);
      }
    }
    unint64_t v42 = *(void *)(a1 + 176);
  }
  uint64_t v47 = *(void *)(a1 + 192);
  uint64_t v48 = v47 + 320 * v42;
  re::DynamicString::DynamicString((re::DynamicString *)v48, (const re::DynamicString *)&v64);
  re::DynamicString::DynamicString((re::DynamicString *)(v48 + 32), (const re::DynamicString *)&v66);
  re::DynamicString::DynamicString((re::DynamicString *)(v48 + 64), (const re::DynamicString *)&v68);
  re::Optional<re::TechniqueState>::Optional(v48 + 96, v70);
  long long v49 = *(_OWORD *)v82;
  *(_WORD *)(v48 + 216) = *(_WORD *)&v82[16];
  *(_OWORD *)(v48 + 200) = v49;
  re::DynamicString::DynamicString((re::DynamicString *)(v48 + 224), (const re::DynamicString *)v83);
  int v50 = v84;
  *(unsigned char *)(v48 + 256) = v84;
  if (v50)
  {
    uint64_t v51 = v47 + 320 * v42;
    *(void *)(v51 + 264) = v85;
    re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::DynamicArray(v51 + 272, (uint64_t *)&v85 + 1);
  }
  *(unsigned char *)(v47 + 320 * v42 + 312) = v89;
  ++*(void *)(a1 + 176);
  ++*(_DWORD *)(a1 + 184);
  if (v59 && (v60 & 1) != 0) {
    (*(void (**)(void))(*(void *)v59 + 40))();
  }
  if (v84) {
    re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::deinit((uint64_t)&v85 + 8);
  }
  if (v83[0])
  {
    if (v83[1]) {
      (*(void (**)(void))(*(void *)v83[0] + 40))();
    }
    memset(v83, 0, sizeof(v83));
  }
  if (v70[0] && v77)
  {
    if (v81) {
      (*(void (**)(void))(*(void *)v77 + 40))();
    }
    uint64_t v81 = 0;
    uint64_t v78 = 0;
    uint64_t v79 = 0;
    uint64_t v77 = 0;
    ++v80;
  }
  if ((void)v68)
  {
    if (BYTE8(v68)) {
      (*(void (**)(void))(*(void *)v68 + 40))();
    }
    long long v68 = 0u;
    long long v69 = 0u;
  }
  if ((void)v66)
  {
    if (BYTE8(v66)) {
      (*(void (**)(void))(*(void *)v66 + 40))();
    }
    long long v66 = 0u;
    long long v67 = 0u;
  }
  uint64_t result = v64;
  if (v64)
  {
    if (v65) {
      return (*(uint64_t (**)(void))(*(void *)v64 + 40))();
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    unint64_t v6 = a2[2];
    if (v6 >= *(void *)(a1 + 16))
    {
      re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::setCapacity((void *)a1, a2[2]);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::DrawCallMeshPartsDetails::PerMeshPartDetails *,re::DrawCallMeshPartsDetails::PerMeshPartDetails *,re::DrawCallMeshPartsDetails::PerMeshPartDetails *>((unsigned __int8 *)a2[4], (unsigned __int8 *)(a2[4] + 56 * *(void *)(a1 + 16)), *(void *)(a1 + 32));
      uint64_t v10 = *(void *)(a1 + 16);
      if (v10 != v6)
      {
        uint64_t v11 = a2[4];
        uint64_t v12 = v11 + 56 * v6;
        uint64_t v13 = *(void *)(a1 + 32);
        uint64_t v14 = 56 * v10;
        do
        {
          uint64_t v15 = v11 + v14;
          uint64_t v16 = v13 + v14;
          *(void *)uint64_t v16 = *(void *)(v11 + v14);
          int v17 = *(unsigned __int8 *)(v11 + v14 + 8);
          *(unsigned char *)(v16 + 8) = v17;
          if (v17) {
            re::DynamicString::DynamicString((re::DynamicString *)(v16 + 16), (const re::DynamicString *)(v15 + 16));
          }
          int v18 = *(unsigned __int8 *)(v15 + 48);
          *(unsigned char *)(v16 + 48) = v18;
          if (v18) {
            *(_DWORD *)(v13 + v14 + 52) = *(_DWORD *)(v11 + v14 + 52);
          }
          v11 += 56;
          v13 += 56;
        }
        while (v15 + 56 != v12);
      }
    }
    else
    {
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::DrawCallMeshPartsDetails::PerMeshPartDetails *,re::DrawCallMeshPartsDetails::PerMeshPartDetails *,re::DrawCallMeshPartsDetails::PerMeshPartDetails *>((unsigned __int8 *)a2[4], (unsigned __int8 *)(a2[4] + 56 * v6), *(void *)(a1 + 32));
      uint64_t v7 = *(void *)(a1 + 16);
      if (v6 != v7)
      {
        uint64_t v8 = -56 * v6 + 56 * v7;
        unint64_t v9 = (re::DynamicString *)(56 * v6 + *(void *)(a1 + 32) + 16);
        do
        {
          if (*((unsigned char *)v9 - 8)) {
            re::DynamicString::deinit(v9);
          }
          unint64_t v9 = (re::DynamicString *)((char *)v9 + 56);
          v8 -= 56;
        }
        while (v8);
      }
    }
    *(void *)(a1 + 16) = v6;
  }
  return a1;
}

void *re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x38uLL))
        {
          uint64_t v2 = 56 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 56 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_22;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 56, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_22:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 56 * v9;
        uint64_t v11 = v8 + 32;
        uint64_t v12 = v7 + 4;
        do
        {
          uint64_t v13 = v11 - 32;
          *(v12 - 4) = *(void *)(v11 - 32);
          int v14 = *(unsigned __int8 *)(v11 - 24);
          *((unsigned char *)v12 - 24) = v14;
          if (v14)
          {
            *((_OWORD *)v12 - 1) = 0u;
            *(_OWORD *)uint64_t v12 = 0u;
            v12[1] = *(void *)(v11 + 8);
            *(void *)(v11 + 8) = 0;
            uint64_t v15 = *(v12 - 1);
            uint64_t v16 = *(void *)(v11 - 8);
            *(v12 - 2) = *(void *)(v11 - 16);
            *(v12 - 1) = v16;
            *(void *)(v11 - 16) = 0;
            uint64_t v17 = *v12;
            *uint64_t v12 = *(void *)v11;
            *(void *)(v11 - 8) = v15;
            *(void *)uint64_t v11 = v17;
          }
          int v18 = *(unsigned __int8 *)(v11 + 16);
          *((unsigned char *)v12 + 16) = v18;
          if (v18) {
            *((_DWORD *)v12 + 5) = *(_DWORD *)(v11 + 20);
          }
          if (*(unsigned char *)(v11 - 24)) {
            re::DynamicString::deinit((re::DynamicString *)(v11 - 16));
          }
          v11 += 56;
          v12 += 7;
        }
        while (v13 + 56 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_22;
    }
  }
  return result;
}

unsigned __int8 *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::DrawCallMeshPartsDetails::PerMeshPartDetails *,re::DrawCallMeshPartsDetails::PerMeshPartDetails *,re::DrawCallMeshPartsDetails::PerMeshPartDetails *>(unsigned __int8 *result, unsigned __int8 *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v4 = a3 + 48;
    unint64_t v5 = result + 52;
    do
    {
      *(void *)(v4 - 48) = *(void *)(v5 - 52);
      uint64_t v6 = v5 - 44;
      uint64_t result = re::Optional<re::DynamicString>::operator=((unsigned char *)(v4 - 40), v5 - 44);
      int v7 = *(v5 - 4);
      if (*(unsigned char *)v4) {
        BOOL v8 = 0;
      }
      else {
        BOOL v8 = v7 == 0;
      }
      if (!v8)
      {
        if (*(unsigned char *)v4) {
          BOOL v9 = v7 == 0;
        }
        else {
          BOOL v9 = 0;
        }
        if (v9)
        {
          *(unsigned char *)uint64_t v4 = 0;
        }
        else
        {
          if (!*(unsigned char *)v4)
          {
            if (*(v5 - 4)) {
              *(unsigned char *)uint64_t v4 = 1;
            }
          }
          *(_DWORD *)(v4 + 4) = *(_DWORD *)v5;
        }
      }
      v4 += 56;
      v5 += 56;
    }
    while (v6 + 48 != a2);
  }
  return result;
}

void *re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::EncodedDrawCallDetails>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::EncodedDrawCallDetails>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x140uLL))
        {
          uint64_t v2 = 320 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 320 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_26;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 320, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_26:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = 0;
        uint64_t v11 = v8 + 320 * v9;
        long long v12 = 0uLL;
        do
        {
          uint64_t v13 = v8 + v10;
          int v14 = &v7[v10 / 8];
          *(_OWORD *)int v14 = v12;
          *((_OWORD *)v14 + 1) = v12;
          v14[3] = *(void *)(v8 + v10 + 24);
          uint64_t v15 = *(void *)(v8 + v10 + 8);
          *int v14 = *(void *)(v8 + v10);
          *(void *)uint64_t v13 = 0;
          uint64_t v16 = *(void *)(v8 + v10 + 16);
          *(void *)(v13 + 24) = 0;
          uint64_t v18 = v7[v10 / 8 + 1];
          uint64_t v17 = v7[v10 / 8 + 2];
          v14[1] = v15;
          _OWORD v14[2] = v16;
          *(void *)(v13 + 8) = v18;
          *(void *)(v13 + 16) = v17;
          *((_OWORD *)v14 + 2) = v12;
          *((_OWORD *)v14 + 3) = v12;
          v14[7] = *(void *)(v8 + v10 + 56);
          uint64_t v19 = *(void *)(v8 + v10 + 40);
          v14[4] = *(void *)(v8 + v10 + 32);
          *(void *)(v13 + 32) = 0;
          uint64_t v20 = *(void *)(v8 + v10 + 48);
          *(void *)(v13 + 56) = 0;
          uint64_t v22 = v7[v10 / 8 + 5];
          uint64_t v21 = v7[v10 / 8 + 6];
          v14[5] = v19;
          v14[6] = v20;
          *(void *)(v13 + 40) = v22;
          *(void *)(v13 + 48) = v21;
          *((_OWORD *)v14 + 4) = v12;
          *((_OWORD *)v14 + 5) = v12;
          v14[11] = *(void *)(v8 + v10 + 88);
          uint64_t v23 = *(void *)(v8 + v10 + 72);
          v14[8] = *(void *)(v8 + v10 + 64);
          *(void *)(v13 + 64) = 0;
          uint64_t v24 = *(void *)(v8 + v10 + 80);
          *(void *)(v13 + 88) = 0;
          uint64_t v26 = v7[v10 / 8 + 9];
          uint64_t v25 = v7[v10 / 8 + 10];
          v14[9] = v23;
          v14[10] = v24;
          *(void *)(v13 + 72) = v26;
          *(void *)(v13 + 80) = v25;
          LODWORD(v24) = *(unsigned __int8 *)(v8 + v10 + 96);
          *((unsigned char *)v14 + 96) = v24;
          if (v24)
          {
            long long v27 = *(_OWORD *)(v13 + 104);
            long long v28 = *(_OWORD *)(v13 + 120);
            long long v29 = *(_OWORD *)(v13 + 136);
            *((_DWORD *)v14 + 38) = *(_DWORD *)(v13 + 152);
            *(_OWORD *)(v14 + 17) = v29;
            *(_OWORD *)(v14 + 15) = v28;
            *(_OWORD *)(v14 + 13) = v27;
            int v30 = *(unsigned __int8 *)(v13 + 156);
            *((unsigned char *)v14 + 156) = v30;
            if (v30) {
              BYTE5(v7[v10 / 8 + 19]) = *(unsigned char *)(v8 + v10 + 157);
            }
            uint64_t v31 = &v7[v10 / 8];
            uint64_t v32 = v8 + v10;
            v31[24] = 0;
            v31[21] = 0;
            v31[22] = 0;
            v31[20] = 0;
            *((_DWORD *)v31 + 46) = 0;
            uint64_t v33 = *(void *)(v8 + v10 + 168);
            v31[20] = *(void *)(v8 + v10 + 160);
            v31[21] = v33;
            *(void *)(v32 + 160) = 0;
            *(void *)(v32 + 168) = 0;
            uint64_t v34 = v7[v10 / 8 + 22];
            v31[22] = *(void *)(v8 + v10 + 176);
            *(void *)(v32 + 176) = v34;
            uint64_t v35 = v7[v10 / 8 + 24];
            v31[24] = *(void *)(v8 + v10 + 192);
            *(void *)(v32 + 192) = v35;
            *(_DWORD *)(v32 + 184) = *(_DWORD *)(v8 + v10 + 184) + 1;
            *((_DWORD *)v31 + 46) = LODWORD(v7[v10 / 8 + 23]) + 1;
          }
          long long v36 = *(_OWORD *)(v13 + 200);
          *((_WORD *)v14 + 108) = *(_WORD *)(v13 + 216);
          *(_OWORD *)(v14 + 25) = v36;
          *((_OWORD *)v14 + 14) = v12;
          *((_OWORD *)v14 + 15) = v12;
          v14[31] = *(void *)(v13 + 248);
          uint64_t v37 = *(void *)(v13 + 232);
          v14[28] = *(void *)(v13 + 224);
          *(void *)(v13 + 224) = 0;
          uint64_t v38 = *(void *)(v13 + 240);
          *(void *)(v13 + 248) = 0;
          uint64_t v40 = v14[29];
          uint64_t v39 = v14[30];
          v14[29] = v37;
          v14[30] = v38;
          *(void *)(v13 + 232) = v40;
          *(void *)(v13 + 240) = v39;
          LODWORD(v38) = *(unsigned __int8 *)(v13 + 256);
          *((unsigned char *)v14 + 256) = v38;
          if (v38)
          {
            unint64_t v41 = &v7[v10 / 8];
            uint64_t v42 = v8 + v10;
            uint64_t v43 = *(void *)(v8 + v10 + 264);
            v41[38] = 0;
            v41[33] = v43;
            v41[34] = 0;
            v41[35] = 0;
            v41[36] = 0;
            *((_DWORD *)v41 + 74) = 0;
            uint64_t v44 = *(void *)(v8 + v10 + 280);
            v41[34] = *(void *)(v8 + v10 + 272);
            v41[35] = v44;
            *(void *)(v42 + 272) = 0;
            *(void *)(v42 + 280) = 0;
            uint64_t v45 = v7[v10 / 8 + 36];
            v41[36] = *(void *)(v8 + v10 + 288);
            *(void *)(v42 + 288) = v45;
            uint64_t v46 = v7[v10 / 8 + 38];
            v41[38] = *(void *)(v8 + v10 + 304);
            *(void *)(v42 + 304) = v46;
            *(_DWORD *)(v42 + 296) = *(_DWORD *)(v8 + v10 + 296) + 1;
            *((_DWORD *)v41 + 74) = LODWORD(v7[v10 / 8 + 37]) + 1;
          }
          *((unsigned char *)v14 + 312) = *(unsigned char *)(v13 + 312);
          if (*(unsigned char *)(v13 + 256)) {
            re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::deinit(v8 + v10 + 272);
          }
          re::DynamicString::deinit((re::DynamicString *)(v13 + 224));
          if (*(unsigned char *)(v13 + 96)) {
            re::DynamicArray<unsigned long>::deinit(v8 + v10 + 160);
          }
          re::DynamicString::deinit((re::DynamicString *)(v13 + 64));
          re::DynamicString::deinit((re::DynamicString *)(v13 + 32));
          re::DynamicString::deinit((re::DynamicString *)v13);
          v10 += 320;
          long long v12 = 0uLL;
        }
        while (v13 + 320 != v11);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_26;
    }
  }
  return result;
}

void *re::DynamicArray<re::DrawCallRecorderGroup::SortingContext>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::DrawCallRecorderGroup::SortingContext>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA0uLL))
        {
          uint64_t v2 = 160 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 160 * a2, 16);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 160, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 160 * v9;
        uint64_t v11 = v7;
        do
        {
          *(_OWORD *)uint64_t v11 = 0u;
          *((_OWORD *)v11 + 1) = 0u;
          v11[3] = *(void *)(v8 + 24);
          uint64_t v12 = *(void *)(v8 + 8);
          *uint64_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          uint64_t v13 = *(void *)(v8 + 16);
          *(void *)(v8 + 24) = 0;
          uint64_t v15 = v11[1];
          uint64_t v14 = v11[2];
          v11[1] = v12;
          v11[2] = v13;
          *(void *)(v8 + 8) = v15;
          *(void *)(v8 + 16) = v14;
          long long v16 = *(_OWORD *)(v8 + 64);
          long long v17 = *(_OWORD *)(v8 + 80);
          long long v18 = *(_OWORD *)(v8 + 112);
          *((_OWORD *)v11 + 6) = *(_OWORD *)(v8 + 96);
          *((_OWORD *)v11 + 7) = v18;
          *((_OWORD *)v11 + 4) = v16;
          *((_OWORD *)v11 + 5) = v17;
          long long v19 = *(_OWORD *)(v8 + 48);
          *((_OWORD *)v11 + 2) = *(_OWORD *)(v8 + 32);
          *((_OWORD *)v11 + 3) = v19;
          LODWORD(v13) = *(unsigned __int8 *)(v8 + 128);
          *((unsigned char *)v11 + 128) = v13;
          if (v13) {
            *((_OWORD *)v11 + 9) = *(_OWORD *)(v8 + 144);
          }
          re::DynamicString::deinit((re::DynamicString *)v8);
          v8 += 160;
          v11 += 20;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

void *re::DynamicArray<re::DrawCallRecorderGroup::SortingContext>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::DrawCallRecorderGroup::SortingContext>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::DrawCallRecorderGroup::SortingContext>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::HashTable<unsigned int,re::DrawCallMeshPartsDetails,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, void *a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned int,re::DrawCallMeshPartsDetails,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + (v10 << 6) + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + (v10 << 6)) = a3;
  *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 12) = *a4;
  uint64_t v14 = *(void *)(a1 + 16) + (v10 << 6);
  *(void *)(v14 + 16) = *a5;
  re::DynamicArray<re::DrawCallMeshPartsDetails::PerMeshPartDetails>::DynamicArray(v14 + 24, a5 + 1);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<unsigned int,re::DrawCallMeshPartsDetails,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v27, 0, 36);
      *(void *)&v27[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v27, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v27;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v27[8];
      *(_OWORD *)long long v27 = v5;
      *(void *)&v27[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v27[24];
      *(_OWORD *)&v27[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v27[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        uint64_t v14 = v6 + 32;
        do
        {
          if ((*(_DWORD *)(v14 - 24) & 0x80000000) != 0)
          {
            unint64_t v15 = *(void *)(v14 - 32);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<unsigned int,re::DrawCallMeshPartsDetails,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + (v18 << 6) + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + (v18 << 6) + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + (v18 << 6) + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + (v18 << 6) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v18 << 6) + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + (v18 << 6)) = v15;
            *(_DWORD *)(*(void *)(a1 + 16) + (v18 << 6) + 12) = *(_DWORD *)(v14 - 20);
            uint64_t v22 = *(void *)(a1 + 16) + (v18 << 6);
            uint64_t v23 = *(void *)(v14 - 16);
            *(void *)(v22 + 56) = 0;
            *(void *)(v22 + 16) = v23;
            *(void *)(v22 + 24) = 0;
            *(void *)(v22 + 32) = 0;
            *(void *)(v22 + 40) = 0;
            *(_DWORD *)(v22 + 48) = 0;
            *(void *)(v22 + 24) = *(void *)(v14 - 8);
            *(void *)(v14 - 8) = 0;
            *(void *)(v22 + 32) = *(void *)v14;
            *(void *)uint64_t v14 = 0;
            uint64_t v24 = *(void *)(v22 + 40);
            *(void *)(v22 + 40) = *(void *)(v14 + 8);
            *(void *)(v14 + 8) = v24;
            uint64_t v25 = *(void *)(v22 + 56);
            *(void *)(v22 + 56) = *(void *)(v14 + 24);
            *(void *)(v14 + 24) = v25;
            ++*(_DWORD *)(v14 + 16);
            ++*(_DWORD *)(v22 + 48);
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 64;
        }
        while (v11 < v10);
      }
      re::HashTable<unsigned int,re::DrawCallMeshPartsDetails,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)v27);
    }
  }
  else
  {
    if (a2) {
      signed int v26 = a2;
    }
    else {
      signed int v26 = 3;
    }
  }
}

double re::ConstantSetupHelper::populateInstanceConstants(uint64_t a1, uint64_t a2, float32x4_t *a3, int a4, float a5)
{
  simd_float3x3 v12 = *(simd_float3x3 *)a2;
  float32x4_t v8 = vsubq_f32(*(float32x4_t *)(a2 + 48), *a3);
  v8.i32[3] = HIDWORD(*(_OWORD *)(a2 + 48));
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(simd_float3 *)(a1 + 16) = v12.columns[1];
  *(simd_float3 *)(a1 + 32) = v12.columns[2];
  *(float32x4_t *)(a1 + 48) = v8;
  simd_float3x3 v13 = __invert_f3(v12);
  int32x4_t v9 = vdupq_laneq_s32((int32x4_t)v13.columns[0], 2);
  *(_DWORD *)(a1 + 72) = v13.columns[2].i32[0];
  unint64_t v10 = vzip1q_s32((int32x4_t)v13.columns[0], (int32x4_t)v13.columns[1]).u64[0];
  *(void *)&double result = vtrn2q_s32((int32x4_t)v13.columns[0], (int32x4_t)v13.columns[1]).u64[0];
  *(void *)(a1 + 64) = v10;
  *(_DWORD *)(a1 + 88) = v13.columns[2].i32[1];
  *(double *)(a1 + 80) = result;
  *(_DWORD *)(a1 + 104) = v13.columns[2].i32[2];
  *(void *)(a1 + 96) = vzip1q_s32(v9, vdupq_laneq_s32((int32x4_t)v13.columns[1], 2)).u64[0];
  *(float *)(a1 + 116) = a5;
  *(_DWORD *)(a1 + 120) = a4;
  return result;
}

float32_t re::ConstantSetupHelper::populateViewConstants(uint64_t a1, float32x4_t *a2, float32x4_t *a3, _OWORD *a4, float32x4_t *a5, unint64_t a6, int a7, uint64_t a8, int32x2_t a9, int32x2_t a10, int32x2_t a11, unsigned __int8 a12, int a13, _OWORD *a14, float32x4_t *a15, float32x4_t *a16)
{
  unsigned int v18 = a6;
  uint64_t v24 = 0;
  float32x4_t v25 = *a5;
  v25.i32[3] = 1.0;
  float32x4_t v26 = *a2;
  float32x4_t v27 = a2[1];
  float32x4_t v28 = a2[2];
  float32x4_t v29 = a2[3];
  long long v83 = xmmword_23435FD50;
  long long v84 = xmmword_23435FD60;
  long long v85 = xmmword_23435FD80;
  float32x4_t v86 = v25;
  do
  {
    *(long long *)((char *)&v87 + v24) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v26, COERCE_FLOAT(*(long long *)((char *)&v83 + v24))), v27, *(float32x2_t *)((char *)&v83 + v24), 1), v28, *(float32x4_t *)((char *)&v83 + v24), 2), v29, *(float32x4_t *)((char *)&v83 + v24), 3);
    v24 += 16;
  }
  while (v24 != 64);
  unint64_t v30 = HIDWORD(a6);
  long long v31 = v88;
  long long v32 = v89;
  long long v33 = v90;
  *(_OWORD *)a1 = v87;
  *(_OWORD *)(a1 + 16) = v31;
  *(_OWORD *)(a1 + 32) = v32;
  *(_OWORD *)(a1 + 48) = v33;
  float32x4_t v34 = *a3;
  float32x4_t v35 = a3[1];
  float32x4_t v36 = a3[3];
  *(float32x4_t *)(a1 + 544) = a3[2];
  *(float32x4_t *)(a1 + 560) = v36;
  *(float32x4_t *)(a1 + 512) = v34;
  *(float32x4_t *)(a1 + 528) = v35;
  simd_float4x4 v91 = __invert_f4(*(simd_float4x4 *)a3->f32);
  uint64_t v37 = 0;
  *(simd_float4x4 *)(a1 + 640) = v91;
  float32x4_t v38 = *a3;
  float32x4_t v39 = a3[1];
  float32x4_t v40 = a3[2];
  float32x4_t v41 = a3[3];
  long long v42 = *(_OWORD *)(a1 + 16);
  long long v43 = *(_OWORD *)(a1 + 32);
  float32x4_t v44 = *(float32x4_t *)(a1 + 48);
  long long v83 = *(_OWORD *)a1;
  long long v84 = v42;
  long long v85 = v43;
  float32x4_t v86 = v44;
  do
  {
    *(long long *)((char *)&v87 + v37) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v38, COERCE_FLOAT(*(long long *)((char *)&v83 + v37))), v39, *(float32x2_t *)((char *)&v83 + v37), 1), v40, *(float32x4_t *)((char *)&v83 + v37), 2), v41, *(float32x4_t *)((char *)&v83 + v37), 3);
    v37 += 16;
  }
  while (v37 != 64);
  long long v45 = v88;
  long long v46 = v89;
  long long v47 = v90;
  *(_OWORD *)(a1 + 256) = v87;
  *(_OWORD *)(a1 + 272) = v45;
  *(_OWORD *)(a1 + 288) = v46;
  *(_OWORD *)(a1 + 304) = v47;
  simd_float4x4 v92 = __invert_f4(*(simd_float4x4 *)a2->f32);
  *(float32x4_t *)(a1 + 768) = vsubq_f32((float32x4_t)v92.columns[3], *a5);
  *(_OWORD *)(a1 + 832) = *a4;
  *(float32x2_t *)v92.columns[1].f32 = vcvt_f32_s32((int32x2_t)__PAIR64__(v30, v18));
  __asm { FMOV            V8.2S, #1.0 }
  *(float32x2_t *)&v92.columns[1].u32[2] = vdiv_f32(_D8, *(float32x2_t *)v92.columns[1].f32);
  *(_OWORD *)(a1 + 864) = *a4;
  *(simd_float4 *)(a1 + 880) = v92.columns[1];
  if (a7 >= 2)
  {
    uint64_t v53 = 0;
    float32x4_t v54 = *a5;
    v54.i32[3] = 1.0;
    float32x4_t v55 = a2[4];
    float32x4_t v56 = a2[5];
    float32x4_t v57 = a2[6];
    float32x4_t v58 = a2[7];
    long long v83 = xmmword_23435FD50;
    long long v84 = xmmword_23435FD60;
    long long v85 = xmmword_23435FD80;
    float32x4_t v86 = v54;
    do
    {
      *(long long *)((char *)&v87 + v53) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v55, COERCE_FLOAT(*(long long *)((char *)&v83 + v53))), v56, *(float32x2_t *)((char *)&v83 + v53), 1), v57, *(float32x4_t *)((char *)&v83 + v53), 2), v58, *(float32x4_t *)((char *)&v83 + v53), 3);
      v53 += 16;
    }
    while (v53 != 64);
    long long v59 = v88;
    long long v60 = v89;
    long long v61 = v90;
    *(_OWORD *)(a1 + 64) = v87;
    *(_OWORD *)(a1 + 80) = v59;
    *(_OWORD *)(a1 + 96) = v60;
    *(_OWORD *)(a1 + 112) = v61;
    float32x4_t v62 = a3[4];
    float32x4_t v63 = a3[5];
    float32x4_t v64 = a3[7];
    *(float32x4_t *)(a1 + 608) = a3[6];
    *(float32x4_t *)(a1 + 624) = v64;
    *(float32x4_t *)(a1 + 576) = v62;
    *(float32x4_t *)(a1 + 592) = v63;
    simd_float4x4 v93 = __invert_f4(*(simd_float4x4 *)a3[4].f32);
    uint64_t v65 = 0;
    *(simd_float4x4 *)(a1 + 704) = v93;
    float32x4_t v66 = a3[4];
    float32x4_t v67 = a3[5];
    float32x4_t v68 = a3[6];
    float32x4_t v69 = a3[7];
    long long v70 = *(_OWORD *)(a1 + 80);
    long long v71 = *(_OWORD *)(a1 + 96);
    float32x4_t v72 = *(float32x4_t *)(a1 + 112);
    long long v83 = *(_OWORD *)(a1 + 64);
    long long v84 = v70;
    long long v85 = v71;
    float32x4_t v86 = v72;
    do
    {
      *(long long *)((char *)&v87 + v65) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v66, COERCE_FLOAT(*(long long *)((char *)&v83 + v65))), v67, *(float32x2_t *)((char *)&v83 + v65), 1), v68, *(float32x4_t *)((char *)&v83 + v65), 2), v69, *(float32x4_t *)((char *)&v83 + v65), 3);
      v65 += 16;
    }
    while (v65 != 64);
    long long v73 = v88;
    long long v74 = v89;
    long long v75 = v90;
    *(_OWORD *)(a1 + 320) = v87;
    *(_OWORD *)(a1 + 336) = v73;
    *(_OWORD *)(a1 + 352) = v74;
    *(_OWORD *)(a1 + 368) = v75;
    simd_float4x4 v94 = __invert_f4(*(simd_float4x4 *)a2[4].f32);
    *(float32x4_t *)(a1 + 784) = vsubq_f32((float32x4_t)v94.columns[3], *a5);
    *(_OWORD *)(a1 + 848) = a4[1];
  }
  *(_OWORD *)(a1 + 912) = *(_OWORD *)(a8 + 4);
  *(_DWORD *)(a1 + 936) = *(_DWORD *)(a8 + 48);
  uint64_t v76 = *(void *)(a8 + 36);
  HIDWORD(v76) = *(_DWORD *)a8;
  *(void *)(a1 + 928) = v76;
  *(_DWORD *)(a1 + 940) = a7;
  *(_DWORD *)(a1 + 944) = a12;
  *(_DWORD *)(a1 + 952) = a13;
  *(float32x2_t *)&long long v77 = vcvt_f32_s32(a9);
  *((float32x2_t *)&v77 + 1) = vdiv_f32(_D8, *(float32x2_t *)&v77);
  *(_OWORD *)(a1 + 896) = v77;
  *(float32x2_t *)&long long v78 = vcvt_f32_s32(a10);
  *((float32x2_t *)&v78 + 1) = vdiv_f32(_D8, *(float32x2_t *)&v78);
  *(float32x2_t *)&long long v79 = vcvt_f32_s32(a11);
  *((float32x2_t *)&v79 + 1) = vdiv_f32(_D8, *(float32x2_t *)&v79);
  *(_OWORD *)(a1 + 800) = v78;
  *(_OWORD *)(a1 + 816) = v79;
  *(_OWORD *)(a1 + 960) = *a14;
  *(_DWORD *)(a1 + 976) = 0;
  *(_OWORD *)(a1 + 992) = 0u;
  float32x4_t v80 = *a16;
  float32x4_t v81 = vmulq_f32(*a16, vsubq_f32(*a15, *a5));
  float32_t result = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 2), vaddq_f32(v81, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 1))).f32[0];
  v80.f32[3] = result;
  *(float32x4_t *)(a1 + 1008) = v80;
  return result;
}

void re::DebugSettingsManager::init(re::DebugSettingsManager *this)
{
  *((unsigned char *)this + 112) = 1;
}

void re::DebugSettingsManager::registerSetting(re::DebugSettingsManager *this, const char *a2)
{
  *(void *)&v17.var0 = 0;
  v17.var1 = "";
  unint64_t v4 = *(void *)&v17.var0;
  unint64_t v5 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * ((*(void *)&v17.var0 >> 31) ^ (*(void *)&v17.var0 >> 1))) ^ ((0xBF58476D1CE4E5B9
                                                                                                * ((*(void *)&v17.var0 >> 31) ^ (*(void *)&v17.var0 >> 1))) >> 27));
  unint64_t v6 = v5 ^ (v5 >> 31);
  if (!*(void *)this)
  {
    LODWORD(v7) = 0;
    goto LABEL_10;
  }
  unint64_t v7 = v6 % *((unsigned int *)this + 6);
  uint64_t v8 = *(unsigned int *)(*((void *)this + 1) + 4 * v7);
  if (v8 == 0x7FFFFFFF)
  {
LABEL_10:
    uint64_t v12 = *((unsigned int *)this + 9);
    if (v12 == 0x7FFFFFFF)
    {
      uint64_t v12 = *((unsigned int *)this + 8);
      int v13 = v12;
      if (v12 == *((_DWORD *)this + 6))
      {
        re::HashTable<re::StringID,re::Optional<std::variant<int,float,BOOL>>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity((uint64_t)this, 2 * *((_DWORD *)this + 7));
        LODWORD(v7) = v6 % *((unsigned int *)this + 6);
        int v13 = *((_DWORD *)this + 8);
      }
      *((_DWORD *)this + 8) = v13 + 1;
      uint64_t v14 = *((void *)this + 2);
      int v15 = *(_DWORD *)(v14 + 40 * v12);
    }
    else
    {
      uint64_t v14 = *((void *)this + 2);
      int v15 = *(_DWORD *)(v14 + 40 * v12);
      *((_DWORD *)this + 9) = v15 & 0x7FFFFFFF;
    }
    uint64_t v16 = 40 * v12;
    *(_DWORD *)(v14 + v16) = v15 | 0x80000000;
    *(_DWORD *)(*((void *)this + 2) + v16) = *(_DWORD *)(*((void *)this + 2) + 40 * v12) & 0x80000000 | *(_DWORD *)(*((void *)this + 1) + 4 * v7);
    re::StringID::StringID((re::StringID *)(*((void *)this + 2) + 40 * v12 + 8), &v17);
    *(unsigned char *)(*((void *)this + 2) + 40 * v12 + 24) = 0;
    *(_DWORD *)(*((void *)this + 1) + 4 * v7) = v12;
    ++*((_DWORD *)this + 7);
    ++*((_DWORD *)this + 10);
    goto LABEL_16;
  }
  uint64_t v9 = *((void *)this + 2);
  var1 = v17.var1;
  while (1)
  {
    if ((*(void *)(v9 + 40 * v8 + 8) ^ v4) <= 1)
    {
      unint64_t v11 = *(const char **)(v9 + 40 * v8 + 16);
      if (v11 == var1 || !strcmp(v11, var1)) {
        break;
      }
    }
    uint64_t v8 = *(_DWORD *)(v9 + 40 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF) {
      goto LABEL_10;
    }
  }
LABEL_16:
  re::StringID::destroyString((re::StringID *)&v17);
}

void re::HashTable<re::StringID,re::Optional<std::variant<int,float,BOOL>>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v27, 0, 36);
      *(void *)&v27[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v27, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v27;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v27[8];
      *(_OWORD *)float32x4_t v27 = v5;
      *(void *)&v27[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v27[24];
      *(_OWORD *)&v27[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v27[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        uint64_t v14 = (void *)(v6 + 28);
        do
        {
          if ((*((_DWORD *)v14 - 7) & 0x80000000) != 0)
          {
            unint64_t v15 = 0xBF58476D1CE4E5B9 * ((*(void *)((char *)v14 - 20) >> 31) ^ (*(void *)((char *)v14 - 20) >> 1));
            unint64_t v16 = (0x94D049BB133111EBLL * (v15 ^ (v15 >> 27))) ^ ((0x94D049BB133111EBLL * (v15 ^ (v15 >> 27))) >> 31);
            unint64_t v17 = *(unsigned int *)(a1 + 24);
            unint64_t v18 = v16 % v17;
            uint64_t v19 = *(unsigned int *)(a1 + 36);
            if (v19 == 0x7FFFFFFF)
            {
              uint64_t v19 = *(unsigned int *)(a1 + 32);
              int v20 = v19;
              if (v19 == v17)
              {
                re::HashTable<re::StringID,re::Optional<std::variant<int,float,BOOL>>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, (2 * v12));
                unint64_t v18 = v16 % *(unsigned int *)(a1 + 24);
                int v20 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v20 + 1;
              uint64_t v21 = *(void *)(a1 + 16);
              int v22 = *(_DWORD *)(v21 + 40 * v19);
            }
            else
            {
              uint64_t v21 = *(void *)(a1 + 16);
              int v22 = *(_DWORD *)(v21 + 40 * v19);
              *(_DWORD *)(a1 + 36) = v22 & 0x7FFFFFFF;
            }
            uint64_t v23 = 40 * v19;
            *(_DWORD *)(v21 + v23) = v22 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + v23) = *(_DWORD *)(*(void *)(a1 + 16) + 40 * v19) & 0x80000000 | *(_DWORD *)(v13 + 4 * v18);
            re::StringID::StringID((re::StringID *)(*(void *)(a1 + 16) + 40 * v19 + 8), (const StringID *)((char *)v14 - 20));
            uint64_t v24 = *(void *)(a1 + 16);
            int v25 = *((unsigned __int8 *)v14 - 4);
            *(unsigned char *)(v24 + 40 * v19 + 24) = v25;
            if (v25) {
              *(void *)(v24 + 40 * v19 + 28) = *v14;
            }
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v18) = v19;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 5;
        }
        while (v11 < v10);
      }
      re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)v27);
    }
  }
  else
  {
    if (a2) {
      signed int v26 = a2;
    }
    else {
      signed int v26 = 3;
    }
  }
}

uint64_t *re::mtl::introspect_CompareFunction(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97200, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF97200);
    if (v31)
    {
      long long v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "Never";
      qword_26AF97378 = (uint64_t)v33;
      float32x4_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 1;
      *((void *)v35 + 2) = "Less";
      qword_26AF97380 = (uint64_t)v35;
      float32x4_t v36 = re::introspectionAllocator(v35);
      uint64_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)uint64_t v37 = 1;
      *((void *)v37 + 1) = 2;
      *((void *)v37 + 2) = "Equal";
      qword_26AF97388 = (uint64_t)v37;
      float32x4_t v38 = re::introspectionAllocator(v37);
      float32x4_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float32x4_t v39 = 1;
      *((void *)v39 + 1) = 3;
      *((void *)v39 + 2) = "LessEqual";
      qword_26AF97390 = (uint64_t)v39;
      float32x4_t v40 = re::introspectionAllocator(v39);
      float32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float32x4_t v41 = 1;
      *((void *)v41 + 1) = 4;
      *((void *)v41 + 2) = "Greater";
      qword_26AF97398 = (uint64_t)v41;
      long long v42 = re::introspectionAllocator(v41);
      long long v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)long long v43 = 1;
      *((void *)v43 + 1) = 5;
      *((void *)v43 + 2) = "NotEqual";
      qword_26AF973A0 = (uint64_t)v43;
      float32x4_t v44 = re::introspectionAllocator(v43);
      long long v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)long long v45 = 1;
      *((void *)v45 + 1) = 6;
      *((void *)v45 + 2) = "GreaterEqual";
      qword_26AF973A8 = (uint64_t)v45;
      long long v46 = re::introspectionAllocator(v45);
      uint64_t v47 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *(void *)(v47 + 8) = 7;
      *(void *)(v47 + 16) = "Always";
      qword_26AF973B0 = v47;
      __cxa_guard_release(&qword_26AF97200);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97208, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97208))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF97478, "CompareFunction", 1, 1, 1, 1);
    qword_26AF97478 = (uint64_t)&unk_26E715E00;
    qword_26AF974B8 = (uint64_t)&re::mtl::introspect_CompareFunction(BOOL)::enumTable;
    dword_26AF97488 = 9;
    __cxa_guard_release(&qword_26AF97208);
  }
  if (v2)
  {
    if (_MergedGlobals_412) {
      return &qword_26AF97478;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v53);
    char v3 = _MergedGlobals_412;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v53);
    if (v3) {
      return &qword_26AF97478;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (_MergedGlobals_412)
    {
LABEL_34:
      float32x4_t v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF97478;
    }
  }
  _MergedGlobals_412 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF97478, a2);
  uint64_t v49 = 0xA476CA4CF3E2F7ALL;
  int v50 = "CompareFunction";
  v53[0] = 0x31CD534126;
  v53[1] = "uint8_t";
  long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v53);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v53);
    long long v9 = (unsigned int *)qword_26AF974B8;
    v52[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v53, &v49, 1, 1, (uint64_t)v52);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                unint64_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v51.var0 = 2 * v15;
          v51.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v53, v19, &v51);
          re::StringID::destroyString((re::StringID *)&v51);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            int v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  int v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v51.var0 = 2 * v23;
            v51.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v53, v27, &v51);
            re::StringID::destroyString((re::StringID *)&v51);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v53, v28);
    xmmword_26AF97498 = (__int128)v51;
    re::StringID::destroyString((re::StringID *)&v49);
    if (v2) {
      return &qword_26AF97478;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v53);
  re::internal::assertLog((re::internal *)5, v48, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "CompareFunction", v49, v50);
  float32_t result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t *re::mtl::introspect_BlendFactor(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97210, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF97210);
    if (v31)
    {
      long long v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "Zero";
      qword_26AF978B8 = (uint64_t)v33;
      float32x4_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 1;
      *((void *)v35 + 2) = "One";
      qword_26AF978C0 = (uint64_t)v35;
      float32x4_t v36 = re::introspectionAllocator(v35);
      uint64_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)uint64_t v37 = 1;
      *((void *)v37 + 1) = 2;
      *((void *)v37 + 2) = "SourceColor";
      qword_26AF978C8 = (uint64_t)v37;
      float32x4_t v38 = re::introspectionAllocator(v37);
      float32x4_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float32x4_t v39 = 1;
      *((void *)v39 + 1) = 3;
      *((void *)v39 + 2) = "OneMinusSourceColor";
      qword_26AF978D0 = (uint64_t)v39;
      float32x4_t v40 = re::introspectionAllocator(v39);
      float32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float32x4_t v41 = 1;
      *((void *)v41 + 1) = 4;
      *((void *)v41 + 2) = "SourceAlpha";
      qword_26AF978D8 = (uint64_t)v41;
      long long v42 = re::introspectionAllocator(v41);
      long long v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)long long v43 = 1;
      *((void *)v43 + 1) = 5;
      *((void *)v43 + 2) = "OneMinusSourceAlpha";
      qword_26AF978E0 = (uint64_t)v43;
      float32x4_t v44 = re::introspectionAllocator(v43);
      long long v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)long long v45 = 1;
      *((void *)v45 + 1) = 6;
      *((void *)v45 + 2) = "DestinationColor";
      qword_26AF978E8 = (uint64_t)v45;
      long long v46 = re::introspectionAllocator(v45);
      uint64_t v47 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *((void *)v47 + 1) = 7;
      *((void *)v47 + 2) = "OneMinusDestinationColor";
      qword_26AF978F0 = (uint64_t)v47;
      uint64_t v48 = re::introspectionAllocator(v47);
      uint64_t v49 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v48 + 32))(v48, 24, 8);
      *(_DWORD *)uint64_t v49 = 1;
      *((void *)v49 + 1) = 8;
      *((void *)v49 + 2) = "DestinationAlpha";
      qword_26AF978F8 = (uint64_t)v49;
      int v50 = re::introspectionAllocator(v49);
      StringID v51 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v50 + 32))(v50, 24, 8);
      *(_DWORD *)StringID v51 = 1;
      *((void *)v51 + 1) = 9;
      *((void *)v51 + 2) = "OneMinusDestinationAlpha";
      qword_26AF97900 = (uint64_t)v51;
      unint64_t v52 = re::introspectionAllocator(v51);
      uint64_t v53 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v52 + 32))(v52, 24, 8);
      *(_DWORD *)uint64_t v53 = 1;
      *((void *)v53 + 1) = 10;
      *((void *)v53 + 2) = "SourceAlphaSaturated";
      qword_26AF97908 = (uint64_t)v53;
      float32x4_t v54 = re::introspectionAllocator(v53);
      float32x4_t v55 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v54 + 32))(v54, 24, 8);
      *(_DWORD *)float32x4_t v55 = 1;
      *((void *)v55 + 1) = 11;
      *((void *)v55 + 2) = "BlendColor";
      qword_26AF97910 = (uint64_t)v55;
      float32x4_t v56 = re::introspectionAllocator(v55);
      float32x4_t v57 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v56 + 32))(v56, 24, 8);
      *(_DWORD *)float32x4_t v57 = 1;
      *((void *)v57 + 1) = 12;
      *((void *)v57 + 2) = "OneMinusBlendColor";
      qword_26AF97918 = (uint64_t)v57;
      float32x4_t v58 = re::introspectionAllocator(v57);
      long long v59 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v58 + 32))(v58, 24, 8);
      *(_DWORD *)long long v59 = 1;
      *((void *)v59 + 1) = 13;
      *((void *)v59 + 2) = "BlendAlpha";
      qword_26AF97920 = (uint64_t)v59;
      long long v60 = re::introspectionAllocator(v59);
      long long v61 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v60 + 32))(v60, 24, 8);
      *(_DWORD *)long long v61 = 1;
      *((void *)v61 + 1) = 14;
      *((void *)v61 + 2) = "OneMinusBlendAlpha";
      qword_26AF97928 = (uint64_t)v61;
      float32x4_t v62 = re::introspectionAllocator(v61);
      float32x4_t v63 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v62 + 32))(v62, 24, 8);
      *(_DWORD *)float32x4_t v63 = 1;
      *((void *)v63 + 1) = 15;
      *((void *)v63 + 2) = "Source1Color";
      qword_26AF97930 = (uint64_t)v63;
      float32x4_t v64 = re::introspectionAllocator(v63);
      uint64_t v65 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v64 + 32))(v64, 24, 8);
      *(_DWORD *)uint64_t v65 = 1;
      *((void *)v65 + 1) = 16;
      *((void *)v65 + 2) = "OneMinusSource1Color";
      qword_26AF97938 = (uint64_t)v65;
      float32x4_t v66 = re::introspectionAllocator(v65);
      float32x4_t v67 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v66 + 32))(v66, 24, 8);
      *(_DWORD *)float32x4_t v67 = 1;
      *((void *)v67 + 1) = 17;
      *((void *)v67 + 2) = "Source1Alpha";
      qword_26AF97940 = (uint64_t)v67;
      float32x4_t v68 = re::introspectionAllocator(v67);
      uint64_t v69 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v68 + 32))(v68, 24, 8);
      *(_DWORD *)uint64_t v69 = 1;
      *(void *)(v69 + 8) = 18;
      *(void *)(v69 + 16) = "OneMinusSource1Alpha";
      qword_26AF97948 = v69;
      __cxa_guard_release(&qword_26AF97210);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97218, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97218))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF974C0, "BlendFactor", 4, 4, 1, 1);
    qword_26AF974C0 = (uint64_t)&unk_26E715E00;
    qword_26AF97500 = (uint64_t)&re::mtl::introspect_BlendFactor(BOOL)::enumTable;
    dword_26AF974D0 = 9;
    __cxa_guard_release(&qword_26AF97218);
  }
  if (v2)
  {
    if (byte_26AF971F1) {
      return &qword_26AF974C0;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v75);
    char v3 = byte_26AF971F1;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v75);
    if (v3) {
      return &qword_26AF974C0;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (byte_26AF971F1)
    {
LABEL_34:
      float32x4_t v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF974C0;
    }
  }
  byte_26AF971F1 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF974C0, a2);
  uint64_t v71 = 0x1954B877535D9C0;
  float32x4_t v72 = "BlendFactor";
  v75[0] = 208862;
  v75[1] = "int";
  long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v75);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v75);
    long long v9 = (unsigned int *)qword_26AF97500;
    v74[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v75, &v71, 1, 1, (uint64_t)v74);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                unint64_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v73.var0 = 2 * v15;
          v73.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v75, v19, &v73);
          re::StringID::destroyString((re::StringID *)&v73);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            int v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  int v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v73.var0 = 2 * v23;
            v73.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v75, v27, &v73);
            re::StringID::destroyString((re::StringID *)&v73);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v75, v28);
    xmmword_26AF974E0 = (__int128)v73;
    re::StringID::destroyString((re::StringID *)&v71);
    if (v2) {
      return &qword_26AF974C0;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v75);
  re::internal::assertLog((re::internal *)5, v70, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "BlendFactor", v71, v72);
  float32_t result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

void *re::mtl::introspect_BlendOperation(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      unint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "Add";
      re::mtl::introspect_BlendOperation(BOOL)::enumAttributes = (uint64_t)v11;
      int v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "Subtract";
      qword_2687A0528 = (uint64_t)v13;
      uint64_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *((void *)v15 + 1) = 2;
      *((void *)v15 + 2) = "ReverseSubtract";
      qword_2687A0530 = (uint64_t)v15;
      char v16 = re::introspectionAllocator(v15);
      unint64_t v17 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 24, 8);
      *(_DWORD *)unint64_t v17 = 1;
      *((void *)v17 + 1) = 3;
      *((void *)v17 + 2) = "Min";
      qword_2687A0538 = (uint64_t)v17;
      int v18 = re::introspectionAllocator(v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v18 + 32))(v18, 24, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = 4;
      *(void *)(v19 + 16) = "Max";
      qword_2687A0540 = v19;
    }
  }
  {
    int v20 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_BlendOperation(BOOL)::info, "BlendOperation", 4, 4, 1, 1);
    *(void *)int v20 = &unk_26E715E00;
    *((void *)v20 + 8) = &re::mtl::introspect_BlendOperation(BOOL)::enumTable;
    *((_DWORD *)v20 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_BlendOperation(BOOL)::isInitialized) {
      return &re::mtl::introspect_BlendOperation(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v22);
    char v3 = re::mtl::introspect_BlendOperation(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v22);
    if (v3) {
      return &re::mtl::introspect_BlendOperation(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_BlendOperation(BOOL)::isInitialized)
    {
LABEL_9:
      long long v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_BlendOperation(BOOL)::info;
    }
  }
  re::mtl::introspect_BlendOperation(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_BlendOperation(BOOL)::info, a2);
  v21[0] = 0x3CA077184A19D86CLL;
  v21[1] = (uint64_t)"BlendOperation";
  xmmword_2687A0570 = v22;
  re::StringID::destroyString((re::StringID *)v21);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_BlendOperation(BOOL)::info;
}

uint64_t *re::mtl::introspect_ColorWriteMask(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97220, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF97220);
    if (v31)
    {
      long long v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "None";
      qword_26AF97838 = (uint64_t)v33;
      float32x4_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 1;
      *((void *)v35 + 2) = "Alpha";
      qword_26AF97840 = (uint64_t)v35;
      float32x4_t v36 = re::introspectionAllocator(v35);
      uint64_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)uint64_t v37 = 1;
      *((void *)v37 + 1) = 2;
      *((void *)v37 + 2) = "Blue";
      qword_26AF97848 = (uint64_t)v37;
      float32x4_t v38 = re::introspectionAllocator(v37);
      float32x4_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float32x4_t v39 = 1;
      *((void *)v39 + 1) = 4;
      *((void *)v39 + 2) = "Green";
      qword_26AF97850 = (uint64_t)v39;
      float32x4_t v40 = re::introspectionAllocator(v39);
      float32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float32x4_t v41 = 1;
      *((void *)v41 + 1) = 8;
      *((void *)v41 + 2) = "Red";
      qword_26AF97858 = (uint64_t)v41;
      long long v42 = re::introspectionAllocator(v41);
      long long v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)long long v43 = 1;
      *((void *)v43 + 1) = 12;
      *((void *)v43 + 2) = "RedGreen";
      qword_26AF97860 = (uint64_t)v43;
      float32x4_t v44 = re::introspectionAllocator(v43);
      long long v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)long long v45 = 1;
      *((void *)v45 + 1) = 10;
      *((void *)v45 + 2) = "RedBlue";
      qword_26AF97868 = (uint64_t)v45;
      long long v46 = re::introspectionAllocator(v45);
      uint64_t v47 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *((void *)v47 + 1) = 6;
      *((void *)v47 + 2) = "GreenBlue";
      qword_26AF97870 = (uint64_t)v47;
      uint64_t v48 = re::introspectionAllocator(v47);
      uint64_t v49 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v48 + 32))(v48, 24, 8);
      *(_DWORD *)uint64_t v49 = 1;
      *((void *)v49 + 1) = 9;
      *((void *)v49 + 2) = "RedAlpha";
      qword_26AF97878 = (uint64_t)v49;
      int v50 = re::introspectionAllocator(v49);
      StringID v51 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v50 + 32))(v50, 24, 8);
      *(_DWORD *)StringID v51 = 1;
      *((void *)v51 + 1) = 5;
      *((void *)v51 + 2) = "GreenAlpha";
      qword_26AF97880 = (uint64_t)v51;
      unint64_t v52 = re::introspectionAllocator(v51);
      uint64_t v53 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v52 + 32))(v52, 24, 8);
      *(_DWORD *)uint64_t v53 = 1;
      *((void *)v53 + 1) = 3;
      *((void *)v53 + 2) = "BlueAlpha";
      qword_26AF97888 = (uint64_t)v53;
      float32x4_t v54 = re::introspectionAllocator(v53);
      float32x4_t v55 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v54 + 32))(v54, 24, 8);
      *(_DWORD *)float32x4_t v55 = 1;
      *((void *)v55 + 1) = 14;
      *((void *)v55 + 2) = "RedGreenBlue";
      qword_26AF97890 = (uint64_t)v55;
      float32x4_t v56 = re::introspectionAllocator(v55);
      float32x4_t v57 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v56 + 32))(v56, 24, 8);
      *(_DWORD *)float32x4_t v57 = 1;
      *((void *)v57 + 1) = 13;
      *((void *)v57 + 2) = "RedGreenAlpha";
      qword_26AF97898 = (uint64_t)v57;
      float32x4_t v58 = re::introspectionAllocator(v57);
      long long v59 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v58 + 32))(v58, 24, 8);
      *(_DWORD *)long long v59 = 1;
      *((void *)v59 + 1) = 11;
      *((void *)v59 + 2) = "RedBlueAlpha";
      qword_26AF978A0 = (uint64_t)v59;
      long long v60 = re::introspectionAllocator(v59);
      long long v61 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v60 + 32))(v60, 24, 8);
      *(_DWORD *)long long v61 = 1;
      *((void *)v61 + 1) = 7;
      *((void *)v61 + 2) = "GreenBlueAlpha";
      qword_26AF978A8 = (uint64_t)v61;
      float32x4_t v62 = re::introspectionAllocator(v61);
      uint64_t v63 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v62 + 32))(v62, 24, 8);
      *(_DWORD *)uint64_t v63 = 1;
      *(void *)(v63 + 8) = 15;
      *(void *)(v63 + 16) = "All";
      qword_26AF978B0 = v63;
      __cxa_guard_release(&qword_26AF97220);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97228, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97228))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF97508, "ColorWriteMask", 4, 4, 1, 1);
    qword_26AF97508 = (uint64_t)&unk_26E715E00;
    qword_26AF97548 = (uint64_t)&re::mtl::introspect_ColorWriteMask(BOOL)::enumTable;
    dword_26AF97518 = 9;
    __cxa_guard_release(&qword_26AF97228);
  }
  if (v2)
  {
    if (byte_26AF971F2) {
      return &qword_26AF97508;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v69);
    char v3 = byte_26AF971F2;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v69);
    if (v3) {
      return &qword_26AF97508;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (byte_26AF971F2)
    {
LABEL_34:
      float32x4_t v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF97508;
    }
  }
  byte_26AF971F2 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF97508, a2);
  uint64_t v65 = 0x28E7E0D0848E4ED0;
  float32x4_t v66 = "ColorWriteMask";
  v69[0] = 208862;
  v69[1] = "int";
  long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v69);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v69);
    long long v9 = (unsigned int *)qword_26AF97548;
    v68[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v69, &v65, 1, 1, (uint64_t)v68);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                unint64_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v67.var0 = 2 * v15;
          v67.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v69, v19, &v67);
          re::StringID::destroyString((re::StringID *)&v67);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            long long v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  int v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v67.var0 = 2 * v23;
            v67.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v69, v27, &v67);
            re::StringID::destroyString((re::StringID *)&v67);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v69, v28);
    xmmword_26AF97528 = (__int128)v67;
    re::StringID::destroyString((re::StringID *)&v65);
    if (v2) {
      return &qword_26AF97508;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v69);
  re::internal::assertLog((re::internal *)5, v64, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "ColorWriteMask", v65, v66);
  float32_t result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

void *re::mtl::introspect_CullMode(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      unint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "CullModeNone";
      re::mtl::introspect_CullMode(BOOL)::enumAttributes = (uint64_t)v11;
      int v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "CullModeFront";
      qword_2687A05B0 = (uint64_t)v13;
      uint64_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = 2;
      *(void *)(v15 + 16) = "CullModeBack";
      qword_2687A05B8 = v15;
    }
  }
  {
    char v16 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_CullMode(BOOL)::info, "CullMode", 1, 1, 1, 1);
    *(void *)char v16 = &unk_26E715E00;
    *((void *)v16 + 8) = &re::mtl::introspect_CullMode(BOOL)::enumTable;
    *((_DWORD *)v16 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_CullMode(BOOL)::isInitialized) {
      return &re::mtl::introspect_CullMode(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    char v3 = re::mtl::introspect_CullMode(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    if (v3) {
      return &re::mtl::introspect_CullMode(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_CullMode(BOOL)::isInitialized)
    {
LABEL_9:
      long long v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_CullMode(BOOL)::info;
    }
  }
  re::mtl::introspect_CullMode(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_CullMode(BOOL)::info, a2);
  v17[0] = 0x38C37139CAALL;
  v17[1] = (uint64_t)"CullMode";
  xmmword_2687A05E8 = v18;
  re::StringID::destroyString((re::StringID *)v17);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_CullMode(BOOL)::info;
}

void *re::mtl::introspect_TextureUsage(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      unint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "Unknown";
      re::mtl::introspect_TextureUsage(BOOL)::enumAttributes = (uint64_t)v11;
      int v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "ShaderRead";
      qword_2687A0628 = (uint64_t)v13;
      uint64_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *((void *)v15 + 1) = 2;
      *((void *)v15 + 2) = "ShaderWrite";
      qword_2687A0630 = (uint64_t)v15;
      char v16 = re::introspectionAllocator(v15);
      unint64_t v17 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 24, 8);
      *(_DWORD *)unint64_t v17 = 1;
      *((void *)v17 + 1) = 4;
      *((void *)v17 + 2) = "RenderTarget";
      qword_2687A0638 = (uint64_t)v17;
      long long v18 = re::introspectionAllocator(v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v18 + 32))(v18, 24, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = 16;
      *(void *)(v19 + 16) = "PixelFormatView";
      qword_2687A0640 = v19;
    }
  }
  {
    int v20 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_TextureUsage(BOOL)::info, "TextureUsage", 4, 4, 1, 1);
    *(void *)int v20 = &unk_26E715E00;
    *((void *)v20 + 8) = &re::mtl::introspect_TextureUsage(BOOL)::enumTable;
    *((_DWORD *)v20 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_TextureUsage(BOOL)::isInitialized) {
      return &re::mtl::introspect_TextureUsage(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v22);
    char v3 = re::mtl::introspect_TextureUsage(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v22);
    if (v3) {
      return &re::mtl::introspect_TextureUsage(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_TextureUsage(BOOL)::isInitialized)
    {
LABEL_9:
      long long v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_TextureUsage(BOOL)::info;
    }
  }
  re::mtl::introspect_TextureUsage(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_TextureUsage(BOOL)::info, a2);
  v21[0] = 0x3DA0ACA55F420ACCLL;
  v21[1] = (uint64_t)"TextureUsage";
  xmmword_2687A0670 = v22;
  re::StringID::destroyString((re::StringID *)v21);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_TextureUsage(BOOL)::info;
}

void *re::mtl::introspect_VertexStepFunction(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      unint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "Constant";
      re::mtl::introspect_VertexStepFunction(BOOL)::enumAttributes = (uint64_t)v11;
      int v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "PerVertex";
      qword_2687A06B0 = (uint64_t)v13;
      uint64_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *((void *)v15 + 1) = 2;
      *((void *)v15 + 2) = "PerInstance";
      qword_2687A06B8 = (uint64_t)v15;
      char v16 = re::introspectionAllocator(v15);
      unint64_t v17 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 24, 8);
      *(_DWORD *)unint64_t v17 = 1;
      *((void *)v17 + 1) = 3;
      *((void *)v17 + 2) = "PerPatch";
      qword_2687A06C0 = (uint64_t)v17;
      long long v18 = re::introspectionAllocator(v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v18 + 32))(v18, 24, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = 4;
      *(void *)(v19 + 16) = "PerPatchControlPoint";
      qword_2687A06C8 = v19;
    }
  }
  {
    int v20 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_VertexStepFunction(BOOL)::info, "VertexStepFunction", 1, 1, 1, 1);
    *(void *)int v20 = &unk_26E715E00;
    *((void *)v20 + 8) = &re::mtl::introspect_VertexStepFunction(BOOL)::enumTable;
    *((_DWORD *)v20 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_VertexStepFunction(BOOL)::isInitialized) {
      return &re::mtl::introspect_VertexStepFunction(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v22);
    char v3 = re::mtl::introspect_VertexStepFunction(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v22);
    if (v3) {
      return &re::mtl::introspect_VertexStepFunction(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_VertexStepFunction(BOOL)::isInitialized)
    {
LABEL_9:
      long long v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_VertexStepFunction(BOOL)::info;
    }
  }
  re::mtl::introspect_VertexStepFunction(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_VertexStepFunction(BOOL)::info, a2);
  v21[0] = 0xF4871ED6F7417D50;
  v21[1] = (uint64_t)"VertexStepFunction";
  xmmword_2687A06F8 = v22;
  re::StringID::destroyString((re::StringID *)v21);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_VertexStepFunction(BOOL)::info;
}

uint64_t *re::mtl::introspect_VertexFormat(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97230, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF97230);
    if (v31)
    {
      long long v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "Invalid";
      qword_26AF97950 = (uint64_t)v33;
      float32x4_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 45;
      *((void *)v35 + 2) = "UChar";
      qword_26AF97958 = (uint64_t)v35;
      float32x4_t v36 = re::introspectionAllocator(v35);
      uint64_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)uint64_t v37 = 1;
      *((void *)v37 + 1) = 1;
      *((void *)v37 + 2) = "UChar2";
      qword_26AF97960 = (uint64_t)v37;
      float32x4_t v38 = re::introspectionAllocator(v37);
      float32x4_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float32x4_t v39 = 1;
      *((void *)v39 + 1) = 2;
      *((void *)v39 + 2) = "UChar3";
      qword_26AF97968 = (uint64_t)v39;
      float32x4_t v40 = re::introspectionAllocator(v39);
      float32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float32x4_t v41 = 1;
      *((void *)v41 + 1) = 3;
      *((void *)v41 + 2) = "UChar4";
      qword_26AF97970 = (uint64_t)v41;
      long long v42 = re::introspectionAllocator(v41);
      long long v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)long long v43 = 1;
      *((void *)v43 + 1) = 46;
      *((void *)v43 + 2) = "Char";
      qword_26AF97978 = (uint64_t)v43;
      float32x4_t v44 = re::introspectionAllocator(v43);
      long long v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)long long v45 = 1;
      *((void *)v45 + 1) = 4;
      *((void *)v45 + 2) = "Char2";
      qword_26AF97980 = (uint64_t)v45;
      long long v46 = re::introspectionAllocator(v45);
      uint64_t v47 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *((void *)v47 + 1) = 5;
      *((void *)v47 + 2) = "Char3";
      qword_26AF97988 = (uint64_t)v47;
      uint64_t v48 = re::introspectionAllocator(v47);
      uint64_t v49 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v48 + 32))(v48, 24, 8);
      *(_DWORD *)uint64_t v49 = 1;
      *((void *)v49 + 1) = 6;
      *((void *)v49 + 2) = "Char4";
      qword_26AF97990 = (uint64_t)v49;
      int v50 = re::introspectionAllocator(v49);
      StringID v51 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v50 + 32))(v50, 24, 8);
      *(_DWORD *)StringID v51 = 1;
      *((void *)v51 + 1) = 47;
      *((void *)v51 + 2) = "UCharNormalized";
      qword_26AF97998 = (uint64_t)v51;
      unint64_t v52 = re::introspectionAllocator(v51);
      uint64_t v53 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v52 + 32))(v52, 24, 8);
      *(_DWORD *)uint64_t v53 = 1;
      *((void *)v53 + 1) = 7;
      *((void *)v53 + 2) = "UChar2Normalized";
      qword_26AF979A0 = (uint64_t)v53;
      float32x4_t v54 = re::introspectionAllocator(v53);
      float32x4_t v55 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v54 + 32))(v54, 24, 8);
      *(_DWORD *)float32x4_t v55 = 1;
      *((void *)v55 + 1) = 8;
      *((void *)v55 + 2) = "UChar3Normalized";
      qword_26AF979A8 = (uint64_t)v55;
      float32x4_t v56 = re::introspectionAllocator(v55);
      float32x4_t v57 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v56 + 32))(v56, 24, 8);
      *(_DWORD *)float32x4_t v57 = 1;
      *((void *)v57 + 1) = 9;
      *((void *)v57 + 2) = "UChar4Normalized";
      qword_26AF979B0 = (uint64_t)v57;
      float32x4_t v58 = re::introspectionAllocator(v57);
      long long v59 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v58 + 32))(v58, 24, 8);
      *(_DWORD *)long long v59 = 1;
      *((void *)v59 + 1) = 42;
      *((void *)v59 + 2) = "UChar4Normalized_BGRA";
      qword_26AF979B8 = (uint64_t)v59;
      long long v60 = re::introspectionAllocator(v59);
      long long v61 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v60 + 32))(v60, 24, 8);
      *(_DWORD *)long long v61 = 1;
      *((void *)v61 + 1) = 48;
      *((void *)v61 + 2) = "CharNormalized";
      qword_26AF979C0 = (uint64_t)v61;
      float32x4_t v62 = re::introspectionAllocator(v61);
      uint64_t v63 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v62 + 32))(v62, 24, 8);
      *(_DWORD *)uint64_t v63 = 1;
      *((void *)v63 + 1) = 10;
      *((void *)v63 + 2) = "Char2Normalized";
      qword_26AF979C8 = (uint64_t)v63;
      uint64_t v64 = re::introspectionAllocator(v63);
      uint64_t v65 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v64 + 32))(v64, 24, 8);
      *(_DWORD *)uint64_t v65 = 1;
      *((void *)v65 + 1) = 11;
      *((void *)v65 + 2) = "Char3Normalized";
      qword_26AF979D0 = (uint64_t)v65;
      float32x4_t v66 = re::introspectionAllocator(v65);
      StringID v67 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v66 + 32))(v66, 24, 8);
      *(_DWORD *)StringID v67 = 1;
      *((void *)v67 + 1) = 12;
      *((void *)v67 + 2) = "Char4Normalized";
      qword_26AF979D8 = (uint64_t)v67;
      float32x4_t v68 = re::introspectionAllocator(v67);
      uint64_t v69 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v68 + 32))(v68, 24, 8);
      *(_DWORD *)uint64_t v69 = 1;
      *((void *)v69 + 1) = 49;
      *((void *)v69 + 2) = "UShort";
      qword_26AF979E0 = (uint64_t)v69;
      uint64_t v70 = re::introspectionAllocator(v69);
      uint64_t v71 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v70 + 32))(v70, 24, 8);
      *(_DWORD *)uint64_t v71 = 1;
      *((void *)v71 + 1) = 13;
      *((void *)v71 + 2) = "UShort2";
      qword_26AF979E8 = (uint64_t)v71;
      float32x4_t v72 = re::introspectionAllocator(v71);
      StringID v73 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v72 + 32))(v72, 24, 8);
      *(_DWORD *)StringID v73 = 1;
      *((void *)v73 + 1) = 14;
      *((void *)v73 + 2) = "UShort3";
      qword_26AF979F0 = (uint64_t)v73;
      long long v74 = re::introspectionAllocator(v73);
      long long v75 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v74 + 32))(v74, 24, 8);
      *(_DWORD *)long long v75 = 1;
      *((void *)v75 + 1) = 15;
      *((void *)v75 + 2) = "UShort4";
      qword_26AF979F8 = (uint64_t)v75;
      uint64_t v76 = re::introspectionAllocator(v75);
      long long v77 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v76 + 32))(v76, 24, 8);
      *(_DWORD *)long long v77 = 1;
      *((void *)v77 + 1) = 50;
      *((void *)v77 + 2) = "Short";
      qword_26AF97A00 = (uint64_t)v77;
      long long v78 = re::introspectionAllocator(v77);
      long long v79 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v78 + 32))(v78, 24, 8);
      *(_DWORD *)long long v79 = 1;
      *((void *)v79 + 1) = 16;
      *((void *)v79 + 2) = "Short2";
      qword_26AF97A08 = (uint64_t)v79;
      float32x4_t v80 = re::introspectionAllocator(v79);
      float32x4_t v81 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v80 + 32))(v80, 24, 8);
      *(_DWORD *)float32x4_t v81 = 1;
      *((void *)v81 + 1) = 17;
      *((void *)v81 + 2) = "Short3";
      qword_26AF97A10 = (uint64_t)v81;
      uint64_t v82 = re::introspectionAllocator(v81);
      long long v83 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v82 + 32))(v82, 24, 8);
      *(_DWORD *)long long v83 = 1;
      *((void *)v83 + 1) = 18;
      *((void *)v83 + 2) = "Short4";
      qword_26AF97A18 = (uint64_t)v83;
      long long v84 = re::introspectionAllocator(v83);
      long long v85 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v84 + 32))(v84, 24, 8);
      *(_DWORD *)long long v85 = 1;
      *((void *)v85 + 1) = 51;
      *((void *)v85 + 2) = "UShortNormalized";
      qword_26AF97A20 = (uint64_t)v85;
      float32x4_t v86 = re::introspectionAllocator(v85);
      long long v87 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v86 + 32))(v86, 24, 8);
      *(_DWORD *)long long v87 = 1;
      *((void *)v87 + 1) = 19;
      *((void *)v87 + 2) = "UShort2Normalized";
      qword_26AF97A28 = (uint64_t)v87;
      long long v88 = re::introspectionAllocator(v87);
      long long v89 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v88 + 32))(v88, 24, 8);
      *(_DWORD *)long long v89 = 1;
      *((void *)v89 + 1) = 20;
      *((void *)v89 + 2) = "UShort3Normalized";
      qword_26AF97A30 = (uint64_t)v89;
      long long v90 = re::introspectionAllocator(v89);
      simd_float4x4 v91 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v90 + 32))(v90, 24, 8);
      *(_DWORD *)simd_float4x4 v91 = 1;
      *((void *)v91 + 1) = 21;
      *((void *)v91 + 2) = "UShort4Normalized";
      qword_26AF97A38 = (uint64_t)v91;
      simd_float4x4 v92 = re::introspectionAllocator(v91);
      simd_float4x4 v93 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v92 + 32))(v92, 24, 8);
      *(_DWORD *)simd_float4x4 v93 = 1;
      *((void *)v93 + 1) = 52;
      *((void *)v93 + 2) = "ShortNormalized";
      qword_26AF97A40 = (uint64_t)v93;
      simd_float4x4 v94 = re::introspectionAllocator(v93);
      float32x4_t v95 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v94 + 32))(v94, 24, 8);
      *(_DWORD *)float32x4_t v95 = 1;
      *((void *)v95 + 1) = 22;
      *((void *)v95 + 2) = "Short2Normalized";
      qword_26AF97A48 = (uint64_t)v95;
      __int16 v96 = re::introspectionAllocator(v95);
      long long v97 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v96 + 32))(v96, 24, 8);
      *(_DWORD *)long long v97 = 1;
      *((void *)v97 + 1) = 23;
      *((void *)v97 + 2) = "Short3Normalized";
      qword_26AF97A50 = (uint64_t)v97;
      long long v98 = re::introspectionAllocator(v97);
      long long v99 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v98 + 32))(v98, 24, 8);
      *(_DWORD *)long long v99 = 1;
      *((void *)v99 + 1) = 24;
      *((void *)v99 + 2) = "Short4Normalized";
      qword_26AF97A58 = (uint64_t)v99;
      long long v100 = re::introspectionAllocator(v99);
      long long v101 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v100 + 32))(v100, 24, 8);
      *(_DWORD *)long long v101 = 1;
      *((void *)v101 + 1) = 53;
      *((void *)v101 + 2) = "Half";
      qword_26AF97A60 = (uint64_t)v101;
      long long v102 = re::introspectionAllocator(v101);
      uint64_t v103 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v102 + 32))(v102, 24, 8);
      *(_DWORD *)uint64_t v103 = 1;
      *((void *)v103 + 1) = 25;
      *((void *)v103 + 2) = "Half2";
      qword_26AF97A68 = (uint64_t)v103;
      uint64_t v104 = re::introspectionAllocator(v103);
      simd_float4x4 v105 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v104 + 32))(v104, 24, 8);
      *(_DWORD *)simd_float4x4 v105 = 1;
      *((void *)v105 + 1) = 26;
      *((void *)v105 + 2) = "Half3";
      qword_26AF97A70 = (uint64_t)v105;
      simd_float4x4 v106 = re::introspectionAllocator(v105);
      long long v107 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v106 + 32))(v106, 24, 8);
      *(_DWORD *)long long v107 = 1;
      *((void *)v107 + 1) = 27;
      *((void *)v107 + 2) = "Half4";
      qword_26AF97A78 = (uint64_t)v107;
      uint64_t v108 = re::introspectionAllocator(v107);
      v109 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v108 + 32))(v108, 24, 8);
      *(_DWORD *)v109 = 1;
      *((void *)v109 + 1) = 28;
      *((void *)v109 + 2) = "Float";
      qword_26AF97A80 = (uint64_t)v109;
      v110 = re::introspectionAllocator(v109);
      v111 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v110 + 32))(v110, 24, 8);
      *(_DWORD *)v111 = 1;
      *((void *)v111 + 1) = 29;
      *((void *)v111 + 2) = "Float2";
      qword_26AF97A88 = (uint64_t)v111;
      v112 = re::introspectionAllocator(v111);
      v113 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v112 + 32))(v112, 24, 8);
      *(_DWORD *)v113 = 1;
      *((void *)v113 + 1) = 30;
      *((void *)v113 + 2) = "Float3";
      qword_26AF97A90 = (uint64_t)v113;
      v114 = re::introspectionAllocator(v113);
      v115 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v114 + 32))(v114, 24, 8);
      *(_DWORD *)v115 = 1;
      *((void *)v115 + 1) = 31;
      *((void *)v115 + 2) = "Float4";
      qword_26AF97A98 = (uint64_t)v115;
      v116 = re::introspectionAllocator(v115);
      v117 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v116 + 32))(v116, 24, 8);
      *(_DWORD *)v117 = 1;
      *((void *)v117 + 1) = 32;
      *((void *)v117 + 2) = "Int";
      qword_26AF97AA0 = (uint64_t)v117;
      v118 = re::introspectionAllocator(v117);
      v119 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v118 + 32))(v118, 24, 8);
      *(_DWORD *)v119 = 1;
      *((void *)v119 + 1) = 33;
      *((void *)v119 + 2) = "Int2";
      qword_26AF97AA8 = (uint64_t)v119;
      v120 = re::introspectionAllocator(v119);
      v121 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v120 + 32))(v120, 24, 8);
      *(_DWORD *)v121 = 1;
      *((void *)v121 + 1) = 34;
      *((void *)v121 + 2) = "Int3";
      qword_26AF97AB0 = (uint64_t)v121;
      v122 = re::introspectionAllocator(v121);
      v123 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v122 + 32))(v122, 24, 8);
      *(_DWORD *)v123 = 1;
      *((void *)v123 + 1) = 35;
      *((void *)v123 + 2) = "Int4";
      qword_26AF97AB8 = (uint64_t)v123;
      v124 = re::introspectionAllocator(v123);
      v125 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v124 + 32))(v124, 24, 8);
      *(_DWORD *)v125 = 1;
      *((void *)v125 + 1) = 36;
      *((void *)v125 + 2) = "UInt";
      qword_26AF97AC0 = (uint64_t)v125;
      v126 = re::introspectionAllocator(v125);
      v127 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v126 + 32))(v126, 24, 8);
      *(_DWORD *)v127 = 1;
      *((void *)v127 + 1) = 37;
      *((void *)v127 + 2) = "UInt2";
      qword_26AF97AC8 = (uint64_t)v127;
      v128 = re::introspectionAllocator(v127);
      v129 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v128 + 32))(v128, 24, 8);
      *(_DWORD *)v129 = 1;
      *((void *)v129 + 1) = 38;
      *((void *)v129 + 2) = "UInt3";
      qword_26AF97AD0 = (uint64_t)v129;
      v130 = re::introspectionAllocator(v129);
      uint64_t v131 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v130 + 32))(v130, 24, 8);
      *(_DWORD *)uint64_t v131 = 1;
      *(void *)(v131 + 8) = 39;
      *(void *)(v131 + 16) = "UInt4";
      qword_26AF97AD8 = v131;
      __cxa_guard_release(&qword_26AF97230);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97238, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97238))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF97550, "VertexFormat", 1, 1, 1, 1);
    qword_26AF97550 = (uint64_t)&unk_26E715E00;
    qword_26AF97590 = (uint64_t)&re::mtl::introspect_VertexFormat(BOOL)::enumTable;
    dword_26AF97560 = 9;
    __cxa_guard_release(&qword_26AF97238);
  }
  if (v2)
  {
    if (byte_26AF971F3) {
      return &qword_26AF97550;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v137);
    char v3 = byte_26AF971F3;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v137);
    if (v3) {
      return &qword_26AF97550;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (byte_26AF971F3)
    {
LABEL_34:
      float32x4_t v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF97550;
    }
  }
  byte_26AF971F3 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF97550, a2);
  uint64_t v133 = 0x3F089ECB224C3DB6;
  v134 = "VertexFormat";
  v137[0] = 0x31CD534126;
  v137[1] = "uint8_t";
  long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v137);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v137);
    long long v9 = (unsigned int *)qword_26AF97590;
    v136[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v137, &v133, 1, 1, (uint64_t)v136);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                unint64_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v135.var0 = 2 * v15;
          v135.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v137, v19, &v135);
          re::StringID::destroyString((re::StringID *)&v135);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            long long v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  int v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v135.var0 = 2 * v23;
            v135.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v137, v27, &v135);
            re::StringID::destroyString((re::StringID *)&v135);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v137, v28);
    xmmword_26AF97570 = (__int128)v135;
    re::StringID::destroyString((re::StringID *)&v133);
    if (v2) {
      return &qword_26AF97550;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v137);
  re::internal::assertLog((re::internal *)5, v132, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "VertexFormat", v133, v134);
  float32_t result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t *re::mtl::introspect_PixelFormat(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97240, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF97240);
    if (v31)
    {
      long long v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "Invalid";
      qword_26AF97AE0 = (uint64_t)v33;
      float32x4_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 1;
      *((void *)v35 + 2) = "A8Unorm";
      qword_26AF97AE8 = (uint64_t)v35;
      float32x4_t v36 = re::introspectionAllocator(v35);
      uint64_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)uint64_t v37 = 1;
      *((void *)v37 + 1) = 10;
      *((void *)v37 + 2) = "R8Unorm";
      qword_26AF97AF0 = (uint64_t)v37;
      float32x4_t v38 = re::introspectionAllocator(v37);
      float32x4_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float32x4_t v39 = 1;
      *((void *)v39 + 1) = 11;
      *((void *)v39 + 2) = "R8Unorm_sRGB";
      qword_26AF97AF8 = (uint64_t)v39;
      float32x4_t v40 = re::introspectionAllocator(v39);
      float32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float32x4_t v41 = 1;
      *((void *)v41 + 1) = 12;
      *((void *)v41 + 2) = "R8Snorm";
      qword_26AF97B00 = (uint64_t)v41;
      long long v42 = re::introspectionAllocator(v41);
      long long v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)long long v43 = 1;
      *((void *)v43 + 1) = 13;
      *((void *)v43 + 2) = "R8Uint";
      qword_26AF97B08 = (uint64_t)v43;
      float32x4_t v44 = re::introspectionAllocator(v43);
      long long v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)long long v45 = 1;
      *((void *)v45 + 1) = 14;
      *((void *)v45 + 2) = "R8Sint";
      qword_26AF97B10 = (uint64_t)v45;
      long long v46 = re::introspectionAllocator(v45);
      uint64_t v47 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *((void *)v47 + 1) = 20;
      *((void *)v47 + 2) = "R16Unorm";
      qword_26AF97B18 = (uint64_t)v47;
      uint64_t v48 = re::introspectionAllocator(v47);
      uint64_t v49 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v48 + 32))(v48, 24, 8);
      *(_DWORD *)uint64_t v49 = 1;
      *((void *)v49 + 1) = 22;
      *((void *)v49 + 2) = "R16Snorm";
      qword_26AF97B20 = (uint64_t)v49;
      int v50 = re::introspectionAllocator(v49);
      StringID v51 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v50 + 32))(v50, 24, 8);
      *(_DWORD *)StringID v51 = 1;
      *((void *)v51 + 1) = 23;
      *((void *)v51 + 2) = "R16Uint";
      qword_26AF97B28 = (uint64_t)v51;
      unint64_t v52 = re::introspectionAllocator(v51);
      uint64_t v53 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v52 + 32))(v52, 24, 8);
      *(_DWORD *)uint64_t v53 = 1;
      *((void *)v53 + 1) = 24;
      *((void *)v53 + 2) = "R16Sint";
      qword_26AF97B30 = (uint64_t)v53;
      float32x4_t v54 = re::introspectionAllocator(v53);
      float32x4_t v55 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v54 + 32))(v54, 24, 8);
      *(_DWORD *)float32x4_t v55 = 1;
      *((void *)v55 + 1) = 25;
      *((void *)v55 + 2) = "R16Float";
      qword_26AF97B38 = (uint64_t)v55;
      float32x4_t v56 = re::introspectionAllocator(v55);
      float32x4_t v57 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v56 + 32))(v56, 24, 8);
      *(_DWORD *)float32x4_t v57 = 1;
      *((void *)v57 + 1) = 30;
      *((void *)v57 + 2) = "RG8Unorm";
      qword_26AF97B40 = (uint64_t)v57;
      float32x4_t v58 = re::introspectionAllocator(v57);
      long long v59 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v58 + 32))(v58, 24, 8);
      *(_DWORD *)long long v59 = 1;
      *((void *)v59 + 1) = 31;
      *((void *)v59 + 2) = "RG8Unorm_sRGB";
      qword_26AF97B48 = (uint64_t)v59;
      long long v60 = re::introspectionAllocator(v59);
      long long v61 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v60 + 32))(v60, 24, 8);
      *(_DWORD *)long long v61 = 1;
      *((void *)v61 + 1) = 32;
      *((void *)v61 + 2) = "RG8Snorm";
      qword_26AF97B50 = (uint64_t)v61;
      float32x4_t v62 = re::introspectionAllocator(v61);
      uint64_t v63 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v62 + 32))(v62, 24, 8);
      *(_DWORD *)uint64_t v63 = 1;
      *((void *)v63 + 1) = 33;
      *((void *)v63 + 2) = "RG8Uint";
      qword_26AF97B58 = (uint64_t)v63;
      uint64_t v64 = re::introspectionAllocator(v63);
      uint64_t v65 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v64 + 32))(v64, 24, 8);
      *(_DWORD *)uint64_t v65 = 1;
      *((void *)v65 + 1) = 34;
      *((void *)v65 + 2) = "RG8Sint";
      qword_26AF97B60 = (uint64_t)v65;
      float32x4_t v66 = re::introspectionAllocator(v65);
      StringID v67 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v66 + 32))(v66, 24, 8);
      *(_DWORD *)StringID v67 = 1;
      *((void *)v67 + 1) = 40;
      *((void *)v67 + 2) = "B5G6R5Unorm";
      qword_26AF97B68 = (uint64_t)v67;
      float32x4_t v68 = re::introspectionAllocator(v67);
      uint64_t v69 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v68 + 32))(v68, 24, 8);
      *(_DWORD *)uint64_t v69 = 1;
      *((void *)v69 + 1) = 41;
      *((void *)v69 + 2) = "A1BGR5Unorm";
      qword_26AF97B70 = (uint64_t)v69;
      uint64_t v70 = re::introspectionAllocator(v69);
      uint64_t v71 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v70 + 32))(v70, 24, 8);
      *(_DWORD *)uint64_t v71 = 1;
      *((void *)v71 + 1) = 42;
      *((void *)v71 + 2) = "ABGR4Unorm";
      qword_26AF97B78 = (uint64_t)v71;
      float32x4_t v72 = re::introspectionAllocator(v71);
      StringID v73 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v72 + 32))(v72, 24, 8);
      *(_DWORD *)StringID v73 = 1;
      *((void *)v73 + 1) = 43;
      *((void *)v73 + 2) = "BGR5A1Unorm";
      qword_26AF97B80 = (uint64_t)v73;
      long long v74 = re::introspectionAllocator(v73);
      long long v75 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v74 + 32))(v74, 24, 8);
      *(_DWORD *)long long v75 = 1;
      *((void *)v75 + 1) = 53;
      *((void *)v75 + 2) = "R32Uint";
      qword_26AF97B88 = (uint64_t)v75;
      uint64_t v76 = re::introspectionAllocator(v75);
      long long v77 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v76 + 32))(v76, 24, 8);
      *(_DWORD *)long long v77 = 1;
      *((void *)v77 + 1) = 54;
      *((void *)v77 + 2) = "R32Sint";
      qword_26AF97B90 = (uint64_t)v77;
      long long v78 = re::introspectionAllocator(v77);
      long long v79 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v78 + 32))(v78, 24, 8);
      *(_DWORD *)long long v79 = 1;
      *((void *)v79 + 1) = 55;
      *((void *)v79 + 2) = "R32Float";
      qword_26AF97B98 = (uint64_t)v79;
      float32x4_t v80 = re::introspectionAllocator(v79);
      float32x4_t v81 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v80 + 32))(v80, 24, 8);
      *(_DWORD *)float32x4_t v81 = 1;
      *((void *)v81 + 1) = 60;
      *((void *)v81 + 2) = "RG16Unorm";
      qword_26AF97BA0 = (uint64_t)v81;
      uint64_t v82 = re::introspectionAllocator(v81);
      long long v83 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v82 + 32))(v82, 24, 8);
      *(_DWORD *)long long v83 = 1;
      *((void *)v83 + 1) = 62;
      *((void *)v83 + 2) = "RG16Snorm";
      qword_26AF97BA8 = (uint64_t)v83;
      long long v84 = re::introspectionAllocator(v83);
      long long v85 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v84 + 32))(v84, 24, 8);
      *(_DWORD *)long long v85 = 1;
      *((void *)v85 + 1) = 63;
      *((void *)v85 + 2) = "RG16Uint";
      qword_26AF97BB0 = (uint64_t)v85;
      float32x4_t v86 = re::introspectionAllocator(v85);
      long long v87 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v86 + 32))(v86, 24, 8);
      *(_DWORD *)long long v87 = 1;
      *((void *)v87 + 1) = 64;
      *((void *)v87 + 2) = "RG16Sint";
      qword_26AF97BB8 = (uint64_t)v87;
      long long v88 = re::introspectionAllocator(v87);
      long long v89 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v88 + 32))(v88, 24, 8);
      *(_DWORD *)long long v89 = 1;
      *((void *)v89 + 1) = 65;
      *((void *)v89 + 2) = "RG16Float";
      qword_26AF97BC0 = (uint64_t)v89;
      long long v90 = re::introspectionAllocator(v89);
      simd_float4x4 v91 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v90 + 32))(v90, 24, 8);
      *(_DWORD *)simd_float4x4 v91 = 1;
      *((void *)v91 + 1) = 70;
      *((void *)v91 + 2) = "RGBA8Unorm";
      qword_26AF97BC8 = (uint64_t)v91;
      simd_float4x4 v92 = re::introspectionAllocator(v91);
      simd_float4x4 v93 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v92 + 32))(v92, 24, 8);
      *(_DWORD *)simd_float4x4 v93 = 1;
      *((void *)v93 + 1) = 71;
      *((void *)v93 + 2) = "RGBA8Unorm_sRGB";
      qword_26AF97BD0 = (uint64_t)v93;
      simd_float4x4 v94 = re::introspectionAllocator(v93);
      float32x4_t v95 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v94 + 32))(v94, 24, 8);
      *(_DWORD *)float32x4_t v95 = 1;
      *((void *)v95 + 1) = 72;
      *((void *)v95 + 2) = "RGBA8Snorm";
      qword_26AF97BD8 = (uint64_t)v95;
      __int16 v96 = re::introspectionAllocator(v95);
      long long v97 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v96 + 32))(v96, 24, 8);
      *(_DWORD *)long long v97 = 1;
      *((void *)v97 + 1) = 73;
      *((void *)v97 + 2) = "RGBA8Uint";
      qword_26AF97BE0 = (uint64_t)v97;
      long long v98 = re::introspectionAllocator(v97);
      long long v99 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v98 + 32))(v98, 24, 8);
      *(_DWORD *)long long v99 = 1;
      *((void *)v99 + 1) = 74;
      *((void *)v99 + 2) = "RGBA8Sint";
      qword_26AF97BE8 = (uint64_t)v99;
      long long v100 = re::introspectionAllocator(v99);
      long long v101 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v100 + 32))(v100, 24, 8);
      *(_DWORD *)long long v101 = 1;
      *((void *)v101 + 1) = 80;
      *((void *)v101 + 2) = "BGRA8Unorm";
      qword_26AF97BF0 = (uint64_t)v101;
      long long v102 = re::introspectionAllocator(v101);
      uint64_t v103 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v102 + 32))(v102, 24, 8);
      *(_DWORD *)uint64_t v103 = 1;
      *((void *)v103 + 1) = 81;
      *((void *)v103 + 2) = "BGRA8Unorm_sRGB";
      qword_26AF97BF8 = (uint64_t)v103;
      uint64_t v104 = re::introspectionAllocator(v103);
      simd_float4x4 v105 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v104 + 32))(v104, 24, 8);
      *(_DWORD *)simd_float4x4 v105 = 1;
      *((void *)v105 + 1) = 90;
      *((void *)v105 + 2) = "RGB10A2Unorm";
      qword_26AF97C00 = (uint64_t)v105;
      simd_float4x4 v106 = re::introspectionAllocator(v105);
      long long v107 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v106 + 32))(v106, 24, 8);
      *(_DWORD *)long long v107 = 1;
      *((void *)v107 + 1) = 91;
      *((void *)v107 + 2) = "RGB10A2Uint";
      qword_26AF97C08 = (uint64_t)v107;
      uint64_t v108 = re::introspectionAllocator(v107);
      v109 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v108 + 32))(v108, 24, 8);
      *(_DWORD *)v109 = 1;
      *((void *)v109 + 1) = 92;
      *((void *)v109 + 2) = "RG11B10Float";
      qword_26AF97C10 = (uint64_t)v109;
      v110 = re::introspectionAllocator(v109);
      v111 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v110 + 32))(v110, 24, 8);
      *(_DWORD *)v111 = 1;
      *((void *)v111 + 1) = 93;
      *((void *)v111 + 2) = "RGB9E5Float";
      qword_26AF97C18 = (uint64_t)v111;
      v112 = re::introspectionAllocator(v111);
      v113 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v112 + 32))(v112, 24, 8);
      *(_DWORD *)v113 = 1;
      *((void *)v113 + 1) = 554;
      *((void *)v113 + 2) = "BGR10_XR";
      qword_26AF97C20 = (uint64_t)v113;
      v114 = re::introspectionAllocator(v113);
      v115 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v114 + 32))(v114, 24, 8);
      *(_DWORD *)v115 = 1;
      *((void *)v115 + 1) = 555;
      *((void *)v115 + 2) = "BGR10_XR_sRGB";
      qword_26AF97C28 = (uint64_t)v115;
      v116 = re::introspectionAllocator(v115);
      v117 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v116 + 32))(v116, 24, 8);
      *(_DWORD *)v117 = 1;
      *((void *)v117 + 1) = 103;
      *((void *)v117 + 2) = "RG32Uint";
      qword_26AF97C30 = (uint64_t)v117;
      v118 = re::introspectionAllocator(v117);
      v119 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v118 + 32))(v118, 24, 8);
      *(_DWORD *)v119 = 1;
      *((void *)v119 + 1) = 104;
      *((void *)v119 + 2) = "RG32Sint";
      qword_26AF97C38 = (uint64_t)v119;
      v120 = re::introspectionAllocator(v119);
      v121 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v120 + 32))(v120, 24, 8);
      *(_DWORD *)v121 = 1;
      *((void *)v121 + 1) = 105;
      *((void *)v121 + 2) = "RG32Float";
      qword_26AF97C40 = (uint64_t)v121;
      v122 = re::introspectionAllocator(v121);
      v123 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v122 + 32))(v122, 24, 8);
      *(_DWORD *)v123 = 1;
      *((void *)v123 + 1) = 110;
      *((void *)v123 + 2) = "RGBA16Unorm";
      qword_26AF97C48 = (uint64_t)v123;
      v124 = re::introspectionAllocator(v123);
      v125 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v124 + 32))(v124, 24, 8);
      *(_DWORD *)v125 = 1;
      *((void *)v125 + 1) = 112;
      *((void *)v125 + 2) = "RGBA16Snorm";
      qword_26AF97C50 = (uint64_t)v125;
      v126 = re::introspectionAllocator(v125);
      v127 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v126 + 32))(v126, 24, 8);
      *(_DWORD *)v127 = 1;
      *((void *)v127 + 1) = 113;
      *((void *)v127 + 2) = "RGBA16Uint";
      qword_26AF97C58 = (uint64_t)v127;
      v128 = re::introspectionAllocator(v127);
      v129 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v128 + 32))(v128, 24, 8);
      *(_DWORD *)v129 = 1;
      *((void *)v129 + 1) = 114;
      *((void *)v129 + 2) = "RGBA16Sint";
      qword_26AF97C60 = (uint64_t)v129;
      v130 = re::introspectionAllocator(v129);
      uint64_t v131 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v130 + 32))(v130, 24, 8);
      *(_DWORD *)uint64_t v131 = 1;
      *((void *)v131 + 1) = 115;
      *((void *)v131 + 2) = "RGBA16Float";
      qword_26AF97C68 = (uint64_t)v131;
      uint64_t v132 = re::introspectionAllocator(v131);
      uint64_t v133 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v132 + 32))(v132, 24, 8);
      *(_DWORD *)uint64_t v133 = 1;
      *((void *)v133 + 1) = 552;
      *((void *)v133 + 2) = "BGRA10_XR";
      qword_26AF97C70 = (uint64_t)v133;
      v134 = re::introspectionAllocator(v133);
      StringID v135 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v134 + 32))(v134, 24, 8);
      *(_DWORD *)StringID v135 = 1;
      *((void *)v135 + 1) = 553;
      *((void *)v135 + 2) = "BGRA10_XR_sRGB";
      qword_26AF97C78 = (uint64_t)v135;
      v136 = re::introspectionAllocator(v135);
      v137 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v136 + 32))(v136, 24, 8);
      *(_DWORD *)v137 = 1;
      *((void *)v137 + 1) = 123;
      *((void *)v137 + 2) = "RGBA32Uint";
      qword_26AF97C80 = (uint64_t)v137;
      v138 = re::introspectionAllocator(v137);
      v139 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v138 + 32))(v138, 24, 8);
      *(_DWORD *)v139 = 1;
      *((void *)v139 + 1) = 124;
      *((void *)v139 + 2) = "RGBA32Sint";
      qword_26AF97C88 = (uint64_t)v139;
      v140 = re::introspectionAllocator(v139);
      v141 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v140 + 32))(v140, 24, 8);
      *(_DWORD *)v141 = 1;
      *((void *)v141 + 1) = 125;
      *((void *)v141 + 2) = "RGBA32Float";
      qword_26AF97C90 = (uint64_t)v141;
      v142 = re::introspectionAllocator(v141);
      v143 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v142 + 32))(v142, 24, 8);
      *(_DWORD *)v143 = 1;
      *((void *)v143 + 1) = 130;
      *((void *)v143 + 2) = "BC1_RGBA";
      qword_26AF97C98 = (uint64_t)v143;
      v144 = re::introspectionAllocator(v143);
      v145 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v144 + 32))(v144, 24, 8);
      *(_DWORD *)v145 = 1;
      *((void *)v145 + 1) = 131;
      *((void *)v145 + 2) = "BC1_RGBA_sRGB";
      qword_26AF97CA0 = (uint64_t)v145;
      v146 = re::introspectionAllocator(v145);
      v147 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v146 + 32))(v146, 24, 8);
      *(_DWORD *)v147 = 1;
      *((void *)v147 + 1) = 132;
      *((void *)v147 + 2) = "BC2_RGBA";
      qword_26AF97CA8 = (uint64_t)v147;
      v148 = re::introspectionAllocator(v147);
      v149 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v148 + 32))(v148, 24, 8);
      *(_DWORD *)v149 = 1;
      *((void *)v149 + 1) = 133;
      *((void *)v149 + 2) = "BC2_RGBA_sRGB";
      qword_26AF97CB0 = (uint64_t)v149;
      v150 = re::introspectionAllocator(v149);
      v151 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v150 + 32))(v150, 24, 8);
      *(_DWORD *)v151 = 1;
      *((void *)v151 + 1) = 134;
      *((void *)v151 + 2) = "BC3_RGBA";
      qword_26AF97CB8 = (uint64_t)v151;
      v152 = re::introspectionAllocator(v151);
      v153 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v152 + 32))(v152, 24, 8);
      *(_DWORD *)v153 = 1;
      *((void *)v153 + 1) = 135;
      *((void *)v153 + 2) = "BC3_RGBA_sRGB";
      qword_26AF97CC0 = (uint64_t)v153;
      v154 = re::introspectionAllocator(v153);
      v155 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v154 + 32))(v154, 24, 8);
      *(_DWORD *)v155 = 1;
      *((void *)v155 + 1) = 140;
      *((void *)v155 + 2) = "BC4_RUnorm";
      qword_26AF97CC8 = (uint64_t)v155;
      v156 = re::introspectionAllocator(v155);
      v157 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v156 + 32))(v156, 24, 8);
      *(_DWORD *)v157 = 1;
      *((void *)v157 + 1) = 141;
      *((void *)v157 + 2) = "BC4_RSnorm";
      qword_26AF97CD0 = (uint64_t)v157;
      v158 = re::introspectionAllocator(v157);
      v159 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v158 + 32))(v158, 24, 8);
      *(_DWORD *)v159 = 1;
      *((void *)v159 + 1) = 142;
      *((void *)v159 + 2) = "BC5_RGUnorm";
      qword_26AF97CD8 = (uint64_t)v159;
      v160 = re::introspectionAllocator(v159);
      v161 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v160 + 32))(v160, 24, 8);
      *(_DWORD *)v161 = 1;
      *((void *)v161 + 1) = 143;
      *((void *)v161 + 2) = "BC5_RGSnorm";
      qword_26AF97CE0 = (uint64_t)v161;
      v162 = re::introspectionAllocator(v161);
      v163 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v162 + 32))(v162, 24, 8);
      *(_DWORD *)v163 = 1;
      *((void *)v163 + 1) = 150;
      *((void *)v163 + 2) = "BC6H_RGBFloat";
      qword_26AF97CE8 = (uint64_t)v163;
      v164 = re::introspectionAllocator(v163);
      v165 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v164 + 32))(v164, 24, 8);
      *(_DWORD *)v165 = 1;
      *((void *)v165 + 1) = 151;
      *((void *)v165 + 2) = "BC6H_RGBUfloat";
      qword_26AF97CF0 = (uint64_t)v165;
      v166 = re::introspectionAllocator(v165);
      v167 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v166 + 32))(v166, 24, 8);
      *(_DWORD *)v167 = 1;
      *((void *)v167 + 1) = 152;
      *((void *)v167 + 2) = "BC7_RGBAUnorm";
      qword_26AF97CF8 = (uint64_t)v167;
      v168 = re::introspectionAllocator(v167);
      v169 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v168 + 32))(v168, 24, 8);
      *(_DWORD *)v169 = 1;
      *((void *)v169 + 1) = 153;
      *((void *)v169 + 2) = "BC7_RGBAUnorm_sRGB";
      qword_26AF97D00 = (uint64_t)v169;
      v170 = re::introspectionAllocator(v169);
      v171 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v170 + 32))(v170, 24, 8);
      *(_DWORD *)v171 = 1;
      *((void *)v171 + 1) = 160;
      *((void *)v171 + 2) = "PVRTC_RGB_2BPP";
      qword_26AF97D08 = (uint64_t)v171;
      v172 = re::introspectionAllocator(v171);
      v173 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v172 + 32))(v172, 24, 8);
      *(_DWORD *)v173 = 1;
      *((void *)v173 + 1) = 161;
      *((void *)v173 + 2) = "PVRTC_RGB_2BPP_sRGB";
      qword_26AF97D10 = (uint64_t)v173;
      v174 = re::introspectionAllocator(v173);
      v175 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v174 + 32))(v174, 24, 8);
      *(_DWORD *)v175 = 1;
      *((void *)v175 + 1) = 162;
      *((void *)v175 + 2) = "PVRTC_RGB_4BPP";
      qword_26AF97D18 = (uint64_t)v175;
      v176 = re::introspectionAllocator(v175);
      v177 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v176 + 32))(v176, 24, 8);
      *(_DWORD *)v177 = 1;
      *((void *)v177 + 1) = 163;
      *((void *)v177 + 2) = "PVRTC_RGB_4BPP_sRGB";
      qword_26AF97D20 = (uint64_t)v177;
      v178 = re::introspectionAllocator(v177);
      v179 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v178 + 32))(v178, 24, 8);
      *(_DWORD *)v179 = 1;
      *((void *)v179 + 1) = 164;
      *((void *)v179 + 2) = "PVRTC_RGBA_2BPP";
      qword_26AF97D28 = (uint64_t)v179;
      v180 = re::introspectionAllocator(v179);
      v181 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v180 + 32))(v180, 24, 8);
      *(_DWORD *)v181 = 1;
      *((void *)v181 + 1) = 165;
      *((void *)v181 + 2) = "PVRTC_RGBA_2BPP_sRGB";
      qword_26AF97D30 = (uint64_t)v181;
      v182 = re::introspectionAllocator(v181);
      v183 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v182 + 32))(v182, 24, 8);
      *(_DWORD *)v183 = 1;
      *((void *)v183 + 1) = 166;
      *((void *)v183 + 2) = "PVRTC_RGBA_4BPP";
      qword_26AF97D38 = (uint64_t)v183;
      v184 = re::introspectionAllocator(v183);
      v185 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v184 + 32))(v184, 24, 8);
      *(_DWORD *)v185 = 1;
      *((void *)v185 + 1) = 167;
      *((void *)v185 + 2) = "PVRTC_RGBA_4BPP_sRGB";
      qword_26AF97D40 = (uint64_t)v185;
      v186 = re::introspectionAllocator(v185);
      v187 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v186 + 32))(v186, 24, 8);
      *(_DWORD *)v187 = 1;
      *((void *)v187 + 1) = 170;
      *((void *)v187 + 2) = "EAC_R11Unorm";
      qword_26AF97D48 = (uint64_t)v187;
      v188 = re::introspectionAllocator(v187);
      v189 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v188 + 32))(v188, 24, 8);
      *(_DWORD *)v189 = 1;
      *((void *)v189 + 1) = 172;
      *((void *)v189 + 2) = "EAC_R11Snorm";
      qword_26AF97D50 = (uint64_t)v189;
      v190 = re::introspectionAllocator(v189);
      v191 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v190 + 32))(v190, 24, 8);
      *(_DWORD *)v191 = 1;
      *((void *)v191 + 1) = 174;
      *((void *)v191 + 2) = "EAC_RG11Unorm";
      qword_26AF97D58 = (uint64_t)v191;
      v192 = re::introspectionAllocator(v191);
      v193 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v192 + 32))(v192, 24, 8);
      *(_DWORD *)v193 = 1;
      *((void *)v193 + 1) = 176;
      *((void *)v193 + 2) = "EAC_RG11Snorm";
      qword_26AF97D60 = (uint64_t)v193;
      v194 = re::introspectionAllocator(v193);
      v195 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v194 + 32))(v194, 24, 8);
      *(_DWORD *)v195 = 1;
      *((void *)v195 + 1) = 178;
      *((void *)v195 + 2) = "EAC_RGBA8";
      qword_26AF97D68 = (uint64_t)v195;
      v196 = re::introspectionAllocator(v195);
      v197 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v196 + 32))(v196, 24, 8);
      *(_DWORD *)v197 = 1;
      *((void *)v197 + 1) = 179;
      *((void *)v197 + 2) = "EAC_RGBA8_sRGB";
      qword_26AF97D70 = (uint64_t)v197;
      v198 = re::introspectionAllocator(v197);
      v199 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v198 + 32))(v198, 24, 8);
      *(_DWORD *)v199 = 1;
      *((void *)v199 + 1) = 180;
      *((void *)v199 + 2) = "ETC2_RGB8";
      qword_26AF97D78 = (uint64_t)v199;
      v200 = re::introspectionAllocator(v199);
      v201 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v200 + 32))(v200, 24, 8);
      *(_DWORD *)v201 = 1;
      *((void *)v201 + 1) = 181;
      *((void *)v201 + 2) = "ETC2_RGB8_sRGB";
      qword_26AF97D80 = (uint64_t)v201;
      v202 = re::introspectionAllocator(v201);
      v203 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v202 + 32))(v202, 24, 8);
      *(_DWORD *)v203 = 1;
      *((void *)v203 + 1) = 182;
      *((void *)v203 + 2) = "ETC2_RGB8A1";
      qword_26AF97D88 = (uint64_t)v203;
      v204 = re::introspectionAllocator(v203);
      v205 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v204 + 32))(v204, 24, 8);
      *(_DWORD *)v205 = 1;
      *((void *)v205 + 1) = 183;
      *((void *)v205 + 2) = "ETC2_RGB8A1_sRGB";
      qword_26AF97D90 = (uint64_t)v205;
      v206 = re::introspectionAllocator(v205);
      v207 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v206 + 32))(v206, 24, 8);
      *(_DWORD *)v207 = 1;
      *((void *)v207 + 1) = 186;
      *((void *)v207 + 2) = "ASTC_4x4_sRGB";
      qword_26AF97D98 = (uint64_t)v207;
      v208 = re::introspectionAllocator(v207);
      v209 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v208 + 32))(v208, 24, 8);
      *(_DWORD *)v209 = 1;
      *((void *)v209 + 1) = 187;
      *((void *)v209 + 2) = "ASTC_5x4_sRGB";
      qword_26AF97DA0 = (uint64_t)v209;
      v210 = re::introspectionAllocator(v209);
      v211 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v210 + 32))(v210, 24, 8);
      *(_DWORD *)v211 = 1;
      *((void *)v211 + 1) = 188;
      *((void *)v211 + 2) = "ASTC_5x5_sRGB";
      qword_26AF97DA8 = (uint64_t)v211;
      v212 = re::introspectionAllocator(v211);
      v213 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v212 + 32))(v212, 24, 8);
      *(_DWORD *)v213 = 1;
      *((void *)v213 + 1) = 189;
      *((void *)v213 + 2) = "ASTC_6x5_sRGB";
      qword_26AF97DB0 = (uint64_t)v213;
      v214 = re::introspectionAllocator(v213);
      v215 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v214 + 32))(v214, 24, 8);
      *(_DWORD *)v215 = 1;
      *((void *)v215 + 1) = 190;
      *((void *)v215 + 2) = "ASTC_6x6_sRGB";
      qword_26AF97DB8 = (uint64_t)v215;
      v216 = re::introspectionAllocator(v215);
      v217 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v216 + 32))(v216, 24, 8);
      *(_DWORD *)v217 = 1;
      *((void *)v217 + 1) = 192;
      *((void *)v217 + 2) = "ASTC_8x5_sRGB";
      qword_26AF97DC0 = (uint64_t)v217;
      v218 = re::introspectionAllocator(v217);
      v219 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v218 + 32))(v218, 24, 8);
      *(_DWORD *)v219 = 1;
      *((void *)v219 + 1) = 193;
      *((void *)v219 + 2) = "ASTC_8x6_sRGB";
      qword_26AF97DC8 = (uint64_t)v219;
      v220 = re::introspectionAllocator(v219);
      v221 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v220 + 32))(v220, 24, 8);
      *(_DWORD *)v221 = 1;
      *((void *)v221 + 1) = 194;
      *((void *)v221 + 2) = "ASTC_8x8_sRGB";
      qword_26AF97DD0 = (uint64_t)v221;
      v222 = re::introspectionAllocator(v221);
      v223 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v222 + 32))(v222, 24, 8);
      *(_DWORD *)v223 = 1;
      *((void *)v223 + 1) = 195;
      *((void *)v223 + 2) = "ASTC_10x5_sRGB";
      qword_26AF97DD8 = (uint64_t)v223;
      v224 = re::introspectionAllocator(v223);
      v225 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v224 + 32))(v224, 24, 8);
      *(_DWORD *)v225 = 1;
      *((void *)v225 + 1) = 196;
      *((void *)v225 + 2) = "ASTC_10x6_sRGB";
      qword_26AF97DE0 = (uint64_t)v225;
      v226 = re::introspectionAllocator(v225);
      v227 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v226 + 32))(v226, 24, 8);
      *(_DWORD *)v227 = 1;
      *((void *)v227 + 1) = 197;
      *((void *)v227 + 2) = "ASTC_10x8_sRGB";
      qword_26AF97DE8 = (uint64_t)v227;
      v228 = re::introspectionAllocator(v227);
      v229 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v228 + 32))(v228, 24, 8);
      *(_DWORD *)v229 = 1;
      *((void *)v229 + 1) = 198;
      *((void *)v229 + 2) = "ASTC_10x10_sRGB";
      qword_26AF97DF0 = (uint64_t)v229;
      v230 = re::introspectionAllocator(v229);
      v231 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v230 + 32))(v230, 24, 8);
      *(_DWORD *)v231 = 1;
      *((void *)v231 + 1) = 199;
      *((void *)v231 + 2) = "ASTC_12x10_sRGB";
      qword_26AF97DF8 = (uint64_t)v231;
      v232 = re::introspectionAllocator(v231);
      v233 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v232 + 32))(v232, 24, 8);
      *(_DWORD *)v233 = 1;
      *((void *)v233 + 1) = 200;
      *((void *)v233 + 2) = "ASTC_12x12_sRGB";
      qword_26AF97E00 = (uint64_t)v233;
      v234 = re::introspectionAllocator(v233);
      v235 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v234 + 32))(v234, 24, 8);
      *(_DWORD *)v235 = 1;
      *((void *)v235 + 1) = 204;
      *((void *)v235 + 2) = "ASTC_4x4_LDR";
      qword_26AF97E08 = (uint64_t)v235;
      v236 = re::introspectionAllocator(v235);
      v237 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v236 + 32))(v236, 24, 8);
      *(_DWORD *)v237 = 1;
      *((void *)v237 + 1) = 205;
      *((void *)v237 + 2) = "ASTC_5x4_LDR";
      qword_26AF97E10 = (uint64_t)v237;
      v238 = re::introspectionAllocator(v237);
      v239 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v238 + 32))(v238, 24, 8);
      *(_DWORD *)v239 = 1;
      *((void *)v239 + 1) = 206;
      *((void *)v239 + 2) = "ASTC_5x5_LDR";
      qword_26AF97E18 = (uint64_t)v239;
      v240 = re::introspectionAllocator(v239);
      v241 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v240 + 32))(v240, 24, 8);
      *(_DWORD *)v241 = 1;
      *((void *)v241 + 1) = 207;
      *((void *)v241 + 2) = "ASTC_6x5_LDR";
      qword_26AF97E20 = (uint64_t)v241;
      v242 = re::introspectionAllocator(v241);
      v243 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v242 + 32))(v242, 24, 8);
      *(_DWORD *)v243 = 1;
      *((void *)v243 + 1) = 208;
      *((void *)v243 + 2) = "ASTC_6x6_LDR";
      qword_26AF97E28 = (uint64_t)v243;
      v244 = re::introspectionAllocator(v243);
      v245 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v244 + 32))(v244, 24, 8);
      *(_DWORD *)v245 = 1;
      *((void *)v245 + 1) = 210;
      *((void *)v245 + 2) = "ASTC_8x5_LDR";
      qword_26AF97E30 = (uint64_t)v245;
      v246 = re::introspectionAllocator(v245);
      v247 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v246 + 32))(v246, 24, 8);
      *(_DWORD *)v247 = 1;
      *((void *)v247 + 1) = 211;
      *((void *)v247 + 2) = "ASTC_8x6_LDR";
      qword_26AF97E38 = (uint64_t)v247;
      v248 = re::introspectionAllocator(v247);
      v249 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v248 + 32))(v248, 24, 8);
      *(_DWORD *)v249 = 1;
      *((void *)v249 + 1) = 212;
      *((void *)v249 + 2) = "ASTC_8x8_LDR";
      qword_26AF97E40 = (uint64_t)v249;
      v250 = re::introspectionAllocator(v249);
      v251 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v250 + 32))(v250, 24, 8);
      *(_DWORD *)v251 = 1;
      *((void *)v251 + 1) = 213;
      *((void *)v251 + 2) = "ASTC_10x5_LDR";
      qword_26AF97E48 = (uint64_t)v251;
      v252 = re::introspectionAllocator(v251);
      v253 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v252 + 32))(v252, 24, 8);
      *(_DWORD *)v253 = 1;
      *((void *)v253 + 1) = 214;
      *((void *)v253 + 2) = "ASTC_10x6_LDR";
      qword_26AF97E50 = (uint64_t)v253;
      v254 = re::introspectionAllocator(v253);
      v255 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v254 + 32))(v254, 24, 8);
      *(_DWORD *)v255 = 1;
      *((void *)v255 + 1) = 215;
      *((void *)v255 + 2) = "ASTC_10x8_LDR";
      qword_26AF97E58 = (uint64_t)v255;
      v256 = re::introspectionAllocator(v255);
      v257 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v256 + 32))(v256, 24, 8);
      *(_DWORD *)v257 = 1;
      *((void *)v257 + 1) = 216;
      *((void *)v257 + 2) = "ASTC_10x10_LDR";
      qword_26AF97E60 = (uint64_t)v257;
      v258 = re::introspectionAllocator(v257);
      v259 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v258 + 32))(v258, 24, 8);
      *(_DWORD *)v259 = 1;
      *((void *)v259 + 1) = 217;
      *((void *)v259 + 2) = "ASTC_12x10_LDR";
      qword_26AF97E68 = (uint64_t)v259;
      v260 = re::introspectionAllocator(v259);
      v261 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v260 + 32))(v260, 24, 8);
      *(_DWORD *)v261 = 1;
      *((void *)v261 + 1) = 218;
      *((void *)v261 + 2) = "ASTC_12x12_LDR";
      qword_26AF97E70 = (uint64_t)v261;
      v262 = re::introspectionAllocator(v261);
      v263 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v262 + 32))(v262, 24, 8);
      *(_DWORD *)v263 = 1;
      *((void *)v263 + 1) = 222;
      *((void *)v263 + 2) = "ASTC_4x4_HDR";
      qword_26AF97E78 = (uint64_t)v263;
      v264 = re::introspectionAllocator(v263);
      v265 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v264 + 32))(v264, 24, 8);
      *(_DWORD *)v265 = 1;
      *((void *)v265 + 1) = 223;
      *((void *)v265 + 2) = "ASTC_5x4_HDR";
      qword_26AF97E80 = (uint64_t)v265;
      v266 = re::introspectionAllocator(v265);
      v267 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v266 + 32))(v266, 24, 8);
      *(_DWORD *)v267 = 1;
      *((void *)v267 + 1) = 224;
      *((void *)v267 + 2) = "ASTC_5x5_HDR";
      qword_26AF97E88 = (uint64_t)v267;
      v268 = re::introspectionAllocator(v267);
      v269 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v268 + 32))(v268, 24, 8);
      *(_DWORD *)v269 = 1;
      *((void *)v269 + 1) = 225;
      *((void *)v269 + 2) = "ASTC_6x5_HDR";
      qword_26AF97E90 = (uint64_t)v269;
      v270 = re::introspectionAllocator(v269);
      v271 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v270 + 32))(v270, 24, 8);
      *(_DWORD *)v271 = 1;
      *((void *)v271 + 1) = 226;
      *((void *)v271 + 2) = "ASTC_6x6_HDR";
      qword_26AF97E98 = (uint64_t)v271;
      v272 = re::introspectionAllocator(v271);
      v273 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v272 + 32))(v272, 24, 8);
      *(_DWORD *)v273 = 1;
      *((void *)v273 + 1) = 228;
      *((void *)v273 + 2) = "ASTC_8x5_HDR";
      qword_26AF97EA0 = (uint64_t)v273;
      v274 = re::introspectionAllocator(v273);
      v275 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v274 + 32))(v274, 24, 8);
      *(_DWORD *)v275 = 1;
      *((void *)v275 + 1) = 229;
      *((void *)v275 + 2) = "ASTC_8x6_HDR";
      qword_26AF97EA8 = (uint64_t)v275;
      v276 = re::introspectionAllocator(v275);
      v277 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v276 + 32))(v276, 24, 8);
      *(_DWORD *)v277 = 1;
      *((void *)v277 + 1) = 230;
      *((void *)v277 + 2) = "ASTC_8x8_HDR";
      qword_26AF97EB0 = (uint64_t)v277;
      v278 = re::introspectionAllocator(v277);
      v279 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v278 + 32))(v278, 24, 8);
      *(_DWORD *)v279 = 1;
      *((void *)v279 + 1) = 231;
      *((void *)v279 + 2) = "ASTC_10x5_HDR";
      qword_26AF97EB8 = (uint64_t)v279;
      v280 = re::introspectionAllocator(v279);
      v281 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v280 + 32))(v280, 24, 8);
      *(_DWORD *)v281 = 1;
      *((void *)v281 + 1) = 232;
      *((void *)v281 + 2) = "ASTC_10x6_HDR";
      qword_26AF97EC0 = (uint64_t)v281;
      v282 = re::introspectionAllocator(v281);
      v283 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v282 + 32))(v282, 24, 8);
      *(_DWORD *)v283 = 1;
      *((void *)v283 + 1) = 233;
      *((void *)v283 + 2) = "ASTC_10x8_HDR";
      qword_26AF97EC8 = (uint64_t)v283;
      v284 = re::introspectionAllocator(v283);
      v285 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v284 + 32))(v284, 24, 8);
      *(_DWORD *)v285 = 1;
      *((void *)v285 + 1) = 234;
      *((void *)v285 + 2) = "ASTC_10x10_HDR";
      qword_26AF97ED0 = (uint64_t)v285;
      v286 = re::introspectionAllocator(v285);
      v287 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v286 + 32))(v286, 24, 8);
      *(_DWORD *)v287 = 1;
      *((void *)v287 + 1) = 235;
      *((void *)v287 + 2) = "ASTC_12x10_HDR";
      qword_26AF97ED8 = (uint64_t)v287;
      v288 = re::introspectionAllocator(v287);
      v289 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v288 + 32))(v288, 24, 8);
      *(_DWORD *)v289 = 1;
      *((void *)v289 + 1) = 236;
      *((void *)v289 + 2) = "ASTC_12x12_HDR";
      qword_26AF97EE0 = (uint64_t)v289;
      v290 = re::introspectionAllocator(v289);
      v291 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v290 + 32))(v290, 24, 8);
      *(_DWORD *)v291 = 1;
      *((void *)v291 + 1) = 240;
      *((void *)v291 + 2) = "GBGR422";
      qword_26AF97EE8 = (uint64_t)v291;
      v292 = re::introspectionAllocator(v291);
      v293 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v292 + 32))(v292, 24, 8);
      *(_DWORD *)v293 = 1;
      *((void *)v293 + 1) = 241;
      *((void *)v293 + 2) = "BGRG422";
      qword_26AF97EF0 = (uint64_t)v293;
      v294 = re::introspectionAllocator(v293);
      v295 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v294 + 32))(v294, 24, 8);
      *(_DWORD *)v295 = 1;
      *((void *)v295 + 1) = 250;
      *((void *)v295 + 2) = "Depth16Unorm";
      qword_26AF97EF8 = (uint64_t)v295;
      v296 = re::introspectionAllocator(v295);
      v297 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v296 + 32))(v296, 24, 8);
      *(_DWORD *)v297 = 1;
      *((void *)v297 + 1) = 252;
      *((void *)v297 + 2) = "Depth32Float";
      qword_26AF97F00 = (uint64_t)v297;
      v298 = re::introspectionAllocator(v297);
      v299 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v298 + 32))(v298, 24, 8);
      *(_DWORD *)v299 = 1;
      *((void *)v299 + 1) = 253;
      *((void *)v299 + 2) = "Stencil8";
      qword_26AF97F08 = (uint64_t)v299;
      v300 = re::introspectionAllocator(v299);
      v301 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v300 + 32))(v300, 24, 8);
      *(_DWORD *)v301 = 1;
      *((void *)v301 + 1) = 255;
      *((void *)v301 + 2) = "Depth24Unorm_Stencil8";
      qword_26AF97F10 = (uint64_t)v301;
      v302 = re::introspectionAllocator(v301);
      v303 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v302 + 32))(v302, 24, 8);
      *(_DWORD *)v303 = 1;
      *((void *)v303 + 1) = 260;
      *((void *)v303 + 2) = "Depth32Float_Stencil8";
      qword_26AF97F18 = (uint64_t)v303;
      v304 = re::introspectionAllocator(v303);
      v305 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v304 + 32))(v304, 24, 8);
      *(_DWORD *)v305 = 1;
      *((void *)v305 + 1) = 261;
      *((void *)v305 + 2) = "X32_Stencil8";
      qword_26AF97F20 = (uint64_t)v305;
      v306 = re::introspectionAllocator(v305);
      uint64_t v307 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v306 + 32))(v306, 24, 8);
      *(_DWORD *)uint64_t v307 = 1;
      *(void *)(v307 + 8) = 262;
      *(void *)(v307 + 16) = "X24_Stencil8";
      qword_26AF97F28 = v307;
      __cxa_guard_release(&qword_26AF97240);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97248, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97248))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF97598, "PixelFormat", 4, 4, 1, 1);
    qword_26AF97598 = (uint64_t)&unk_26E715E00;
    qword_26AF975D8 = (uint64_t)&re::mtl::introspect_PixelFormat(BOOL)::enumTable;
    dword_26AF975A8 = 9;
    __cxa_guard_release(&qword_26AF97248);
  }
  if (v2)
  {
    if (byte_26AF971F4) {
      return &qword_26AF97598;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v313);
    char v3 = byte_26AF971F4;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v313);
    if (v3) {
      return &qword_26AF97598;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (byte_26AF971F4)
    {
LABEL_34:
      float32x4_t v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF97598;
    }
  }
  byte_26AF971F4 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF97598, a2);
  uint64_t v309 = 0x1E660D208CFC3FALL;
  v310 = "PixelFormat";
  v313[0] = 208862;
  v313[1] = "int";
  long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v313);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v313);
    long long v9 = (unsigned int *)qword_26AF975D8;
    v312[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v313, &v309, 1, 1, (uint64_t)v312);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                unint64_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v311.var0 = 2 * v15;
          v311.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v313, v19, &v311);
          re::StringID::destroyString((re::StringID *)&v311);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            long long v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  int v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v311.var0 = 2 * v23;
            v311.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v313, v27, &v311);
            re::StringID::destroyString((re::StringID *)&v311);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v313, v28);
    xmmword_26AF975B8 = (__int128)v311;
    re::StringID::destroyString((re::StringID *)&v309);
    if (v2) {
      return &qword_26AF97598;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v313);
  re::internal::assertLog((re::internal *)5, v308, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "PixelFormat", v309, v310);
  float32_t result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t *re::mtl::introspect_TextureType(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97250, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF97250);
    if (v31)
    {
      long long v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "Texture1D";
      qword_26AF97340 = (uint64_t)v33;
      float32x4_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 1;
      *((void *)v35 + 2) = "Texture1DArray";
      qword_26AF97348 = (uint64_t)v35;
      float32x4_t v36 = re::introspectionAllocator(v35);
      uint64_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)uint64_t v37 = 1;
      *((void *)v37 + 1) = 2;
      *((void *)v37 + 2) = "Texture2D";
      qword_26AF97350 = (uint64_t)v37;
      float32x4_t v38 = re::introspectionAllocator(v37);
      float32x4_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float32x4_t v39 = 1;
      *((void *)v39 + 1) = 3;
      *((void *)v39 + 2) = "Texture2DArray";
      qword_26AF97358 = (uint64_t)v39;
      float32x4_t v40 = re::introspectionAllocator(v39);
      float32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float32x4_t v41 = 1;
      *((void *)v41 + 1) = 4;
      *((void *)v41 + 2) = "Texture2DMultisample";
      qword_26AF97360 = (uint64_t)v41;
      long long v42 = re::introspectionAllocator(v41);
      long long v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)long long v43 = 1;
      *((void *)v43 + 1) = 5;
      *((void *)v43 + 2) = "TextureCube";
      qword_26AF97368 = (uint64_t)v43;
      float32x4_t v44 = re::introspectionAllocator(v43);
      uint64_t v45 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)uint64_t v45 = 1;
      *(void *)(v45 + 8) = 7;
      *(void *)(v45 + 16) = "Texture3D";
      qword_26AF97370 = v45;
      __cxa_guard_release(&qword_26AF97250);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97258, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97258))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF975E0, "TextureType", 4, 4, 1, 1);
    qword_26AF975E0 = (uint64_t)&unk_26E715E00;
    qword_26AF97620 = (uint64_t)&re::mtl::introspect_TextureType(BOOL)::enumTable;
    dword_26AF975F0 = 9;
    __cxa_guard_release(&qword_26AF97258);
  }
  if (v2)
  {
    if (byte_26AF971F5) {
      return &qword_26AF975E0;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v51);
    char v3 = byte_26AF971F5;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v51);
    if (v3) {
      return &qword_26AF975E0;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (byte_26AF971F5)
    {
LABEL_34:
      float32x4_t v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF975E0;
    }
  }
  byte_26AF971F5 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF975E0, a2);
  uint64_t v47 = 0x1FCECCB8732F5AALL;
  uint64_t v48 = "TextureType";
  v51[0] = 208862;
  v51[1] = "int";
  long long v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v51);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v51);
    long long v9 = (unsigned int *)qword_26AF97620;
    v50[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v51, &v47, 1, 1, (uint64_t)v50);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                unint64_t v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v49.var0 = 2 * v15;
          v49.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v51, v19, &v49);
          re::StringID::destroyString((re::StringID *)&v49);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            long long v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  int v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v49.var0 = 2 * v23;
            v49.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v51, v27, &v49);
            re::StringID::destroyString((re::StringID *)&v49);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v51, v28);
    xmmword_26AF97600 = (__int128)v49;
    re::StringID::destroyString((re::StringID *)&v47);
    if (v2) {
      return &qword_26AF975E0;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v51);
  re::internal::assertLog((re::internal *)5, v46, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "TextureType", v47, v48);
  float32_t result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

void re::mtl::introspect_TextureSwizzle(re::mtl *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97260, memory_order_acquire) & 1) == 0)
  {
    char v24 = (re *)__cxa_guard_acquire(&qword_26AF97260);
    if (v24)
    {
      int v25 = re::introspectionAllocator(v24);
      int v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)int v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "Zero";
      qword_26AF972E0 = (uint64_t)v26;
      uint64_t v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "One";
      qword_26AF972E8 = (uint64_t)v28;
      float32x4_t v29 = re::introspectionAllocator(v28);
      unint64_t v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)unint64_t v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "Red";
      qword_26AF972F0 = (uint64_t)v30;
      long long v31 = re::introspectionAllocator(v30);
      long long v32 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)long long v32 = 1;
      *((void *)v32 + 1) = 3;
      *((void *)v32 + 2) = "Green";
      qword_26AF972F8 = (uint64_t)v32;
      long long v33 = re::introspectionAllocator(v32);
      float32x4_t v34 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 24, 8);
      *(_DWORD *)float32x4_t v34 = 1;
      *((void *)v34 + 1) = 4;
      *((void *)v34 + 2) = "Blue";
      qword_26AF97300 = (uint64_t)v34;
      float32x4_t v35 = re::introspectionAllocator(v34);
      uint64_t v36 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v35 + 32))(v35, 24, 8);
      *(_DWORD *)uint64_t v36 = 1;
      *(void *)(v36 + 8) = 5;
      *(void *)(v36 + 16) = "Alpha";
      qword_26AF97308 = v36;
      __cxa_guard_release(&qword_26AF97260);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97268, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97268))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF97628, "TextureSwizzle", 1, 1, 1, 1);
    qword_26AF97628 = (uint64_t)&unk_26E715E00;
    qword_26AF97668 = (uint64_t)&re::mtl::introspect_TextureSwizzle(BOOL)::enumTable;
    dword_26AF97638 = 9;
    __cxa_guard_release(&qword_26AF97268);
  }
  if ((byte_26AF971F6 & 1) == 0)
  {
    byte_26AF971F6 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF97628, a2);
    uint64_t v38 = 0x582818C9D1EBD686;
    float32x4_t v39 = "TextureSwizzle";
    v42[0] = 0x31CD534126;
    v42[1] = "uint8_t";
    int v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v42);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v42);
      uint64_t v4 = (unsigned int *)qword_26AF97668;
      v41[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v42, &v38, 1, 1, (uint64_t)v41);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            long long v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  int v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v40.var0 = 2 * v10;
            v40.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v42, v14, &v40);
            re::StringID::destroyString((re::StringID *)&v40);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              unint64_t v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    int v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v40.var0 = 2 * v18;
              v40.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v42, v22, &v40);
              re::StringID::destroyString((re::StringID *)&v40);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v42, v23);
      xmmword_26AF97648 = (__int128)v40;
      re::StringID::destroyString((re::StringID *)&v38);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v42);
      re::internal::assertLog((re::internal *)5, v37, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "TextureSwizzle", v38, v39);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::mtl::allocInfo_TextureSwizzleChannels(re::mtl *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97270, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97270))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF97748, "TextureSwizzleChannels");
    __cxa_guard_release(&qword_26AF97270);
  }
  return &unk_26AF97748;
}

void re::mtl::initInfo_TextureSwizzleChannels(re::mtl *this, re::IntrospectionBase *a2)
{
  v18[0] = 0x5A47A4A43A050066;
  v18[1] = "TextureSwizzleChannels";
  re::StringID::destroyString((re::StringID *)v18);
  *((_OWORD *)this + 2) = v19;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97278, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF97278);
    if (v4)
    {
      long long v5 = (re::mtl *)re::introspectionAllocator(v4);
      re::mtl::introspect_TextureSwizzle(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re::mtl *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "red";
      *(void *)(v7 + 16) = &qword_26AF97628;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF972C0 = v7;
      uint64_t v8 = (re::mtl *)re::introspectionAllocator((re *)v7);
      re::mtl::introspect_TextureSwizzle(v8, v9);
      uint64_t v10 = (*(uint64_t (**)(re::mtl *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "green";
      *(void *)(v10 + 16) = &qword_26AF97628;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x100000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF972C8 = v10;
      char v11 = (re::mtl *)re::introspectionAllocator((re *)v10);
      re::mtl::introspect_TextureSwizzle(v11, v12);
      uint64_t v13 = (*(uint64_t (**)(re::mtl *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *(void *)(v13 + 8) = "blue";
      *(void *)(v13 + 16) = &qword_26AF97628;
      *(void *)(v13 + 24) = 0;
      *(void *)(v13 + 32) = 0x200000003;
      *(_DWORD *)(v13 + 40) = 0;
      *(void *)(v13 + 48) = 0;
      *(void *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_26AF972D0 = v13;
      uint64_t v14 = (re::mtl *)re::introspectionAllocator((re *)v13);
      re::mtl::introspect_TextureSwizzle(v14, v15);
      uint64_t v16 = (*(uint64_t (**)(re::mtl *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "alpha";
      *(void *)(v16 + 16) = &qword_26AF97628;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x300000004;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF972D8 = v16;
      __cxa_guard_release(&qword_26AF97278);
    }
  }
  *((void *)this + 2) = 0x400000008;
  *((_DWORD *)this + 6) = 1;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF972C0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::mtl::TextureSwizzleChannels>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::mtl::TextureSwizzleChannels>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::mtl::TextureSwizzleChannels>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::mtl::TextureSwizzleChannels>;
  re::IntrospectionRegistry::add(this, v3);
  long long v17 = v19;
}

double re::internal::defaultConstruct<re::mtl::TextureSwizzleChannels>(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(void *)&double result = 84148994;
  *a3 = 84148994;
  return result;
}

double re::internal::defaultConstructV2<re::mtl::TextureSwizzleChannels>(_DWORD *a1)
{
  *(void *)&double result = 84148994;
  *a1 = 84148994;
  return result;
}

uint64_t re::mtl::introspect_TextureSwizzleChannels(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"TextureSwizzleChannels", (uint64_t (*)(re::internal *))re::mtl::allocInfo_TextureSwizzleChannels, (re::IntrospectionBase *(*)(void))re::mtl::initInfo_TextureSwizzleChannels, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::mtl::TextureSwizzleChannels>, this);
}

uint64_t *re::mtl::introspect_StencilOperation(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97280, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF97280);
    if (v31)
    {
      long long v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "Keep";
      qword_26AF973B8 = (uint64_t)v33;
      float32x4_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 1;
      *((void *)v35 + 2) = "Zero";
      qword_26AF973C0 = (uint64_t)v35;
      uint64_t v36 = re::introspectionAllocator(v35);
      uint64_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)uint64_t v37 = 1;
      *((void *)v37 + 1) = 2;
      *((void *)v37 + 2) = "Replace";
      qword_26AF973C8 = (uint64_t)v37;
      uint64_t v38 = re::introspectionAllocator(v37);
      float32x4_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float32x4_t v39 = 1;
      *((void *)v39 + 1) = 3;
      *((void *)v39 + 2) = "IncrementClamp";
      qword_26AF973D0 = (uint64_t)v39;
      StringID v40 = re::introspectionAllocator(v39);
      float32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float32x4_t v41 = 1;
      *((void *)v41 + 1) = 4;
      *((void *)v41 + 2) = "DecrementClamp";
      qword_26AF973D8 = (uint64_t)v41;
      long long v42 = re::introspectionAllocator(v41);
      long long v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)long long v43 = 1;
      *((void *)v43 + 1) = 5;
      *((void *)v43 + 2) = "Invert";
      qword_26AF973E0 = (uint64_t)v43;
      float32x4_t v44 = re::introspectionAllocator(v43);
      uint64_t v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)uint64_t v45 = 1;
      *((void *)v45 + 1) = 6;
      *((void *)v45 + 2) = "IncrementWrap";
      qword_26AF973E8 = (uint64_t)v45;
      uint64_t v46 = re::introspectionAllocator(v45);
      uint64_t v47 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *(void *)(v47 + 8) = 7;
      *(void *)(v47 + 16) = "DecrementWrap";
      qword_26AF973F0 = v47;
      __cxa_guard_release(&qword_26AF97280);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97288, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97288))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF97670, "StencilOperation", 1, 1, 1, 1);
    qword_26AF97670 = (uint64_t)&unk_26E715E00;
    qword_26AF976B0 = (uint64_t)&re::mtl::introspect_StencilOperation(BOOL)::enumTable;
    dword_26AF97680 = 9;
    __cxa_guard_release(&qword_26AF97288);
  }
  if (v2)
  {
    if (byte_26AF971F7) {
      return &qword_26AF97670;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v53);
    char v3 = byte_26AF971F7;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v53);
    if (v3) {
      return &qword_26AF97670;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (byte_26AF971F7)
    {
LABEL_34:
      float32x4_t v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF97670;
    }
  }
  byte_26AF971F7 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF97670, a2);
  uint64_t v49 = 0xFB14E724CF1ABE56;
  int v50 = "StencilOperation";
  v53[0] = 0x31CD534126;
  v53[1] = "uint8_t";
  uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v53);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v53);
    long long v9 = (unsigned int *)qword_26AF976B0;
    v52[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v53, &v49, 1, 1, (uint64_t)v52);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                long long v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v51.var0 = 2 * v15;
          v51.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v53, v19, &v51);
          re::StringID::destroyString((re::StringID *)&v51);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            uint64_t v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  int v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v51.var0 = 2 * v23;
            v51.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v53, v27, &v51);
            re::StringID::destroyString((re::StringID *)&v51);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v53, v28);
    xmmword_26AF97690 = (__int128)v51;
    re::StringID::destroyString((re::StringID *)&v49);
    if (v2) {
      return &qword_26AF97670;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v53);
  re::internal::assertLog((re::internal *)5, v48, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "StencilOperation", v49, v50);
  double result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

void *re::mtl::introspect_LoadAction(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      uint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "DontCare";
      re::mtl::introspect_LoadAction(BOOL)::enumAttributes = (uint64_t)v11;
      int v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "Load";
      qword_2687A0738 = (uint64_t)v13;
      uint64_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = 2;
      *(void *)(v15 + 16) = "Clear";
      qword_2687A0740 = v15;
    }
  }
  {
    char v16 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_LoadAction(BOOL)::info, "LoadAction", 4, 4, 1, 1);
    *(void *)char v16 = &unk_26E715E00;
    *((void *)v16 + 8) = &re::mtl::introspect_LoadAction(BOOL)::enumTable;
    *((_DWORD *)v16 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_LoadAction(BOOL)::isInitialized) {
      return &re::mtl::introspect_LoadAction(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    char v3 = re::mtl::introspect_LoadAction(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    if (v3) {
      return &re::mtl::introspect_LoadAction(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_LoadAction(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_LoadAction(BOOL)::info;
    }
  }
  re::mtl::introspect_LoadAction(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_LoadAction(BOOL)::info, a2);
  v17[0] = 0xEF852949E8DB8;
  v17[1] = (uint64_t)"LoadAction";
  xmmword_2687A0770 = v18;
  re::StringID::destroyString((re::StringID *)v17);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_LoadAction(BOOL)::info;
}

void *re::mtl::allocInfo_Viewport(re::mtl *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97290, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF97290))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF977C0, "Viewport");
    __cxa_guard_release(&qword_26AF97290);
  }
  return &unk_26AF977C0;
}

void re::mtl::initInfo_Viewport(re::mtl *this, re::IntrospectionBase *a2)
{
  v30[0] = 0x47A965CB98CLL;
  v30[1] = "Viewport";
  re::StringID::destroyString((re::StringID *)v30);
  *((_OWORD *)this + 2) = v31;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97298, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF97298);
    if (v4)
    {
      long long v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "originX";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF97310 = v8;
      long long v9 = re::introspectionAllocator((re *)v8);
      unint64_t v11 = re::introspect_float((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "originY";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF97318 = v12;
      uint64_t v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::introspect_float((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "width";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x800000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF97320 = v16;
      long long v17 = re::introspectionAllocator((re *)v16);
      uint64_t v19 = re::introspect_float((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "height";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0xC00000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF97328 = v20;
      uint64_t v21 = re::introspectionAllocator((re *)v20);
      uint64_t v23 = re::introspect_float((re *)1, v22);
      uint64_t v24 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v21 + 32))(v21, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "zNear";
      *(void *)(v24 + 16) = v23;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0x1000000005;
      *(_DWORD *)(v24 + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_26AF97330 = v24;
      int v25 = re::introspectionAllocator((re *)v24);
      uint64_t v27 = re::introspect_float((re *)1, v26);
      uint64_t v28 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 72, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *(void *)(v28 + 8) = "zFar";
      *(void *)(v28 + 16) = v27;
      *(void *)(v28 + 24) = 0;
      *(void *)(v28 + 32) = 0x1400000006;
      *(_DWORD *)(v28 + 40) = 0;
      *(void *)(v28 + 48) = 0;
      *(void *)(v28 + 56) = 0;
      *(_DWORD *)(v28 + 64) = 0;
      qword_26AF97338 = v28;
      __cxa_guard_release(&qword_26AF97298);
    }
  }
  *((void *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 6;
  *((void *)this + 8) = &qword_26AF97310;
  *((void *)this + 9) = re::internal::defaultConstruct<re::mtl::Viewport>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::mtl::Viewport>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::mtl::Viewport>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::mtl::Viewport>;
  re::IntrospectionRegistry::add(this, v3);
  long long v29 = v31;
}

void re::internal::defaultConstruct<re::mtl::Viewport>(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0x3F80000000000000;
}

void *re::internal::defaultConstructV2<re::mtl::Viewport>(void *result)
{
  *double result = 0;
  result[1] = 0;
  result[2] = 0x3F80000000000000;
  return result;
}

uint64_t re::mtl::introspect_Viewport(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Viewport", (uint64_t (*)(re::internal *))re::mtl::allocInfo_Viewport, (re::IntrospectionBase *(*)(void))re::mtl::initInfo_Viewport, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::mtl::Viewport>, this);
}

void *re::mtl::introspect_TriangleFillMode(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      uint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "Fill";
      re::mtl::introspect_TriangleFillMode(BOOL)::enumAttributes = (uint64_t)v11;
      uint64_t v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *(void *)(v13 + 8) = 1;
      *(void *)(v13 + 16) = "Line";
      qword_2687A07B0 = v13;
    }
  }
  {
    uint64_t v14 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_TriangleFillMode(BOOL)::info, "TriangleFillMode", 1, 1, 1, 1);
    *(void *)uint64_t v14 = &unk_26E715E00;
    *((void *)v14 + 8) = &re::mtl::introspect_TriangleFillMode(BOOL)::enumTable;
    *((_DWORD *)v14 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_TriangleFillMode(BOOL)::isInitialized) {
      return &re::mtl::introspect_TriangleFillMode(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    char v3 = re::mtl::introspect_TriangleFillMode(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v3) {
      return &re::mtl::introspect_TriangleFillMode(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_TriangleFillMode(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_TriangleFillMode(BOOL)::info;
    }
  }
  re::mtl::introspect_TriangleFillMode(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_TriangleFillMode(BOOL)::info, a2);
  v15[0] = 0x7681134D4FCCA81CLL;
  v15[1] = (uint64_t)"TriangleFillMode";
  xmmword_2687A07E0 = v16;
  re::StringID::destroyString((re::StringID *)v15);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_TriangleFillMode(BOOL)::info;
}

void *re::mtl::introspect_IndexType(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      uint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "UInt16";
      re::mtl::introspect_IndexType(BOOL)::enumAttributes = (uint64_t)v11;
      uint64_t v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *(void *)(v13 + 8) = 1;
      *(void *)(v13 + 16) = "UInt32";
      qword_2687A0820 = v13;
    }
  }
  {
    uint64_t v14 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_IndexType(BOOL)::info, "IndexType", 1, 1, 1, 1);
    *(void *)uint64_t v14 = &unk_26E715E00;
    *((void *)v14 + 8) = &re::mtl::introspect_IndexType(BOOL)::enumTable;
    *((_DWORD *)v14 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_IndexType(BOOL)::isInitialized) {
      return &re::mtl::introspect_IndexType(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    char v3 = re::mtl::introspect_IndexType(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v3) {
      return &re::mtl::introspect_IndexType(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_IndexType(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_IndexType(BOOL)::info;
    }
  }
  re::mtl::introspect_IndexType(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_IndexType(BOOL)::info, a2);
  v15[0] = 0x76EC8EA12618;
  v15[1] = (uint64_t)"IndexType";
  xmmword_2687A0850 = v16;
  re::StringID::destroyString((re::StringID *)v15);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_IndexType(BOOL)::info;
}

void *re::mtl::introspect_MultisampleDepthResolveFilter(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      uint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "Sample0";
      re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::enumAttributes = (uint64_t)v11;
      uint64_t v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "Min";
      qword_2687A0890 = (uint64_t)v13;
      uint64_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = 2;
      *(void *)(v15 + 16) = "Max";
      qword_2687A0898 = v15;
    }
  }
  {
    long long v16 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::info, "MultisampleDepthResolveFilter", 4, 4, 1, 1);
    *(void *)long long v16 = &unk_26E715E00;
    *((void *)v16 + 8) = &re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::enumTable;
    *((_DWORD *)v16 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::isInitialized) {
      return &re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    char v3 = re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    if (v3) {
      return &re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::info;
    }
  }
  re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::info, a2);
  v17[0] = 0x623525B3D9212FC8;
  v17[1] = (uint64_t)"MultisampleDepthResolveFilter";
  xmmword_2687A08C8 = v18;
  re::StringID::destroyString((re::StringID *)v17);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_MultisampleDepthResolveFilter(BOOL)::info;
}

void *re::mtl::introspect_MultisampleStencilResolveFilter(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      uint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "Sample0";
      re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::enumAttributes = (uint64_t)v11;
      uint64_t v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *(void *)(v13 + 8) = 1;
      *(void *)(v13 + 16) = "DepthResolvedSample";
      qword_2687A0908 = v13;
    }
  }
  {
    uint64_t v14 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::info, "MultisampleStencilResolveFilter", 4, 4, 1, 1);
    *(void *)uint64_t v14 = &unk_26E715E00;
    *((void *)v14 + 8) = &re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::enumTable;
    *((_DWORD *)v14 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::isInitialized) {
      return &re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    char v3 = re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v3) {
      return &re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::info;
    }
  }
  re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::info, a2);
  v15[0] = 0x57DB6309EED0C996;
  v15[1] = (uint64_t)"MultisampleStencilResolveFilter";
  xmmword_2687A0938 = v16;
  re::StringID::destroyString((re::StringID *)v15);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_MultisampleStencilResolveFilter(BOOL)::info;
}

uint64_t *re::mtl::introspect_SamplerAddressMode(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF972A0, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF972A0);
    if (v31)
    {
      long long v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "ClampToEdge";
      qword_26AF973F8 = (uint64_t)v33;
      float32x4_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 0;
      *((void *)v35 + 2) = "Clamp";
      qword_26AF97400 = (uint64_t)v35;
      uint64_t v36 = re::introspectionAllocator(v35);
      uint64_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)uint64_t v37 = 1;
      *((void *)v37 + 1) = 1;
      *((void *)v37 + 2) = "MirrorClampToEdge";
      qword_26AF97408 = (uint64_t)v37;
      uint64_t v38 = re::introspectionAllocator(v37);
      float32x4_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float32x4_t v39 = 1;
      *((void *)v39 + 1) = 1;
      *((void *)v39 + 2) = "Mirror";
      qword_26AF97410 = (uint64_t)v39;
      StringID v40 = re::introspectionAllocator(v39);
      float32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float32x4_t v41 = 1;
      *((void *)v41 + 1) = 2;
      *((void *)v41 + 2) = "Repeat";
      qword_26AF97418 = (uint64_t)v41;
      long long v42 = re::introspectionAllocator(v41);
      long long v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)long long v43 = 1;
      *((void *)v43 + 1) = 3;
      *((void *)v43 + 2) = "MirrorRepeat";
      qword_26AF97420 = (uint64_t)v43;
      float32x4_t v44 = re::introspectionAllocator(v43);
      uint64_t v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)uint64_t v45 = 1;
      *((void *)v45 + 1) = 4;
      *((void *)v45 + 2) = "ClampToZero";
      qword_26AF97428 = (uint64_t)v45;
      uint64_t v46 = re::introspectionAllocator(v45);
      uint64_t v47 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *(void *)(v47 + 8) = 5;
      *(void *)(v47 + 16) = "ClampToBorderColor";
      qword_26AF97430 = v47;
      __cxa_guard_release(&qword_26AF972A0);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF972A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF972A8))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF976B8, "SamplerAddressMode", 4, 4, 1, 1);
    qword_26AF976B8 = (uint64_t)&unk_26E715E00;
    qword_26AF976F8 = (uint64_t)&re::mtl::introspect_SamplerAddressMode(BOOL)::enumTable;
    dword_26AF976C8 = 9;
    __cxa_guard_release(&qword_26AF972A8);
  }
  if (v2)
  {
    if (byte_26AF971F8) {
      return &qword_26AF976B8;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v53);
    char v3 = byte_26AF971F8;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v53);
    if (v3) {
      return &qword_26AF976B8;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (byte_26AF971F8)
    {
LABEL_34:
      long long v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF976B8;
    }
  }
  byte_26AF971F8 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF976B8, a2);
  uint64_t v49 = 0xF558394B10E0FD5ELL;
  int v50 = "SamplerAddressMode";
  v53[0] = 208862;
  v53[1] = "int";
  uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v53);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v53);
    long long v9 = (unsigned int *)qword_26AF976F8;
    v52[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v53, &v49, 1, 1, (uint64_t)v52);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                long long v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v51.var0 = 2 * v15;
          v51.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v53, v19, &v51);
          re::StringID::destroyString((re::StringID *)&v51);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            uint64_t v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  int v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v51.var0 = 2 * v23;
            v51.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v53, v27, &v51);
            re::StringID::destroyString((re::StringID *)&v51);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v53, v28);
    xmmword_26AF976D8 = (__int128)v51;
    re::StringID::destroyString((re::StringID *)&v49);
    if (v2) {
      return &qword_26AF976B8;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v53);
  re::internal::assertLog((re::internal *)5, v48, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "SamplerAddressMode", v49, v50);
  double result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

void *re::mtl::introspect_SamplerBorderColor(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      uint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "TransparentBlack";
      re::mtl::introspect_SamplerBorderColor(BOOL)::enumAttributes = (uint64_t)v11;
      uint64_t v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "OpaqueBlack";
      qword_2687A0978 = (uint64_t)v13;
      uint64_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = 2;
      *(void *)(v15 + 16) = "OpaqueWhite";
      qword_2687A0980 = v15;
    }
  }
  {
    char v16 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_SamplerBorderColor(BOOL)::info, "SamplerBorderColor", 4, 4, 1, 1);
    *(void *)char v16 = &unk_26E715E00;
    *((void *)v16 + 8) = &re::mtl::introspect_SamplerBorderColor(BOOL)::enumTable;
    *((_DWORD *)v16 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_SamplerBorderColor(BOOL)::isInitialized) {
      return &re::mtl::introspect_SamplerBorderColor(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    char v3 = re::mtl::introspect_SamplerBorderColor(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    if (v3) {
      return &re::mtl::introspect_SamplerBorderColor(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_SamplerBorderColor(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_SamplerBorderColor(BOOL)::info;
    }
  }
  re::mtl::introspect_SamplerBorderColor(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_SamplerBorderColor(BOOL)::info, a2);
  v17[0] = 0xF560323C0B41AB1ELL;
  v17[1] = (uint64_t)"SamplerBorderColor";
  xmmword_2687A09B0 = v18;
  re::StringID::destroyString((re::StringID *)v17);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_SamplerBorderColor(BOOL)::info;
}

void *re::mtl::introspect_SamplerMinMagFilter(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      uint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "Nearest";
      re::mtl::introspect_SamplerMinMagFilter(BOOL)::enumAttributes = (uint64_t)v11;
      uint64_t v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *(void *)(v13 + 8) = 1;
      *(void *)(v13 + 16) = "Linear";
      qword_2687A09F0 = v13;
    }
  }
  {
    uint64_t v14 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info, "SamplerMinMagFilter", 4, 4, 1, 1);
    *(void *)uint64_t v14 = &unk_26E715E00;
    *((void *)v14 + 8) = &re::mtl::introspect_SamplerMinMagFilter(BOOL)::enumTable;
    *((_DWORD *)v14 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_SamplerMinMagFilter(BOOL)::isInitialized) {
      return &re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    char v3 = re::mtl::introspect_SamplerMinMagFilter(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v3) {
      return &re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_SamplerMinMagFilter(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    }
  }
  re::mtl::introspect_SamplerMinMagFilter(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info, a2);
  v15[0] = 0xBE442AE103A9B102;
  v15[1] = (uint64_t)"SamplerMinMagFilter";
  xmmword_2687A0A20 = v16;
  re::StringID::destroyString((re::StringID *)v15);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
}

void *re::mtl::introspect_SamplerMipFilter(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      uint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "NotMipmapped";
      re::mtl::introspect_SamplerMipFilter(BOOL)::enumAttributes = (uint64_t)v11;
      uint64_t v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "Nearest";
      qword_2687A0A60 = (uint64_t)v13;
      uint64_t v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *(void *)(v15 + 8) = 2;
      *(void *)(v15 + 16) = "Linear";
      qword_2687A0A68 = v15;
    }
  }
  {
    long long v16 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_SamplerMipFilter(BOOL)::info, "SamplerMipFilter", 4, 4, 1, 1);
    *(void *)long long v16 = &unk_26E715E00;
    *((void *)v16 + 8) = &re::mtl::introspect_SamplerMipFilter(BOOL)::enumTable;
    *((_DWORD *)v16 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_SamplerMipFilter(BOOL)::isInitialized) {
      return &re::mtl::introspect_SamplerMipFilter(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    char v3 = re::mtl::introspect_SamplerMipFilter(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    if (v3) {
      return &re::mtl::introspect_SamplerMipFilter(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_SamplerMipFilter(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_SamplerMipFilter(BOOL)::info;
    }
  }
  re::mtl::introspect_SamplerMipFilter(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_SamplerMipFilter(BOOL)::info, a2);
  v17[0] = 0xFF8F91A9E51F7C8;
  v17[1] = (uint64_t)"SamplerMipFilter";
  xmmword_2687A0A98 = v18;
  re::StringID::destroyString((re::StringID *)v17);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_SamplerMipFilter(BOOL)::info;
}

uint64_t *re::mtl::introspect_SamplerCompareFunction(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF972B0, memory_order_acquire) & 1) == 0)
  {
    long long v31 = (re *)__cxa_guard_acquire(&qword_26AF972B0);
    if (v31)
    {
      long long v32 = re::introspectionAllocator(v31);
      long long v33 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v32 + 32))(v32, 24, 8);
      *(_DWORD *)long long v33 = 1;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = "Never";
      qword_26AF97438 = (uint64_t)v33;
      float32x4_t v34 = re::introspectionAllocator(v33);
      float32x4_t v35 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v34 + 32))(v34, 24, 8);
      *(_DWORD *)float32x4_t v35 = 1;
      *((void *)v35 + 1) = 1;
      *((void *)v35 + 2) = "Less";
      qword_26AF97440 = (uint64_t)v35;
      uint64_t v36 = re::introspectionAllocator(v35);
      uint64_t v37 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v36 + 32))(v36, 24, 8);
      *(_DWORD *)uint64_t v37 = 1;
      *((void *)v37 + 1) = 2;
      *((void *)v37 + 2) = "Equal";
      qword_26AF97448 = (uint64_t)v37;
      uint64_t v38 = re::introspectionAllocator(v37);
      float32x4_t v39 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v38 + 32))(v38, 24, 8);
      *(_DWORD *)float32x4_t v39 = 1;
      *((void *)v39 + 1) = 3;
      *((void *)v39 + 2) = "LessEqual";
      qword_26AF97450 = (uint64_t)v39;
      StringID v40 = re::introspectionAllocator(v39);
      float32x4_t v41 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v40 + 32))(v40, 24, 8);
      *(_DWORD *)float32x4_t v41 = 1;
      *((void *)v41 + 1) = 4;
      *((void *)v41 + 2) = "Greater";
      qword_26AF97458 = (uint64_t)v41;
      long long v42 = re::introspectionAllocator(v41);
      long long v43 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v42 + 32))(v42, 24, 8);
      *(_DWORD *)long long v43 = 1;
      *((void *)v43 + 1) = 5;
      *((void *)v43 + 2) = "NotEqual";
      qword_26AF97460 = (uint64_t)v43;
      float32x4_t v44 = re::introspectionAllocator(v43);
      uint64_t v45 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v44 + 32))(v44, 24, 8);
      *(_DWORD *)uint64_t v45 = 1;
      *((void *)v45 + 1) = 6;
      *((void *)v45 + 2) = "GreaterEqual";
      qword_26AF97468 = (uint64_t)v45;
      uint64_t v46 = re::introspectionAllocator(v45);
      uint64_t v47 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v46 + 32))(v46, 24, 8);
      *(_DWORD *)uint64_t v47 = 1;
      *(void *)(v47 + 8) = 7;
      *(void *)(v47 + 16) = "Always";
      qword_26AF97470 = v47;
      __cxa_guard_release(&qword_26AF972B0);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF972B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF972B8))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF97700, "SamplerCompareFunction", 4, 4, 1, 1);
    qword_26AF97700 = (uint64_t)&unk_26E715E00;
    qword_26AF97740 = (uint64_t)&re::mtl::introspect_SamplerCompareFunction(BOOL)::enumTable;
    dword_26AF97710 = 9;
    __cxa_guard_release(&qword_26AF972B8);
  }
  if (v2)
  {
    if (byte_26AF971F9) {
      return &qword_26AF97700;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v53);
    char v3 = byte_26AF971F9;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v53);
    if (v3) {
      return &qword_26AF97700;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (byte_26AF971F9)
    {
LABEL_34:
      long long v29 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v29);
      return &qword_26AF97700;
    }
  }
  byte_26AF971F9 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF97700, a2);
  uint64_t v49 = 0xB5BF6CF331CEE5AALL;
  int v50 = "SamplerCompareFunction";
  v53[0] = 208862;
  v53[1] = "int";
  uint64_t v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v53);
  if (v7)
  {
    uint64_t v8 = *v7;
    re::StringID::destroyString((re::StringID *)v53);
    long long v9 = (unsigned int *)qword_26AF97740;
    v52[1] = v8;
    re::TypeBuilder::beginEnumType((uint64_t)v53, &v49, 1, 1, (uint64_t)v52);
    unint64_t v11 = *v9;
    if (v11)
    {
      for (unint64_t i = 0; i < v11; ++i)
      {
        uint64_t v13 = *(void *)(*((void *)v9 + 1) + 8 * i);
        if (*(_DWORD *)v13 == 1)
        {
          uint64_t v14 = *(char **)(v13 + 16);
          if (v14)
          {
            uint64_t v15 = *v14;
            if (*v14)
            {
              char v16 = v14[1];
              if (v16)
              {
                long long v17 = (unsigned __int8 *)(v14 + 2);
                do
                {
                  uint64_t v15 = 31 * v15 + v16;
                  int v18 = *v17++;
                  char v16 = v18;
                }
                while (v18);
              }
            }
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v19 = *(void *)(v13 + 8);
          *(void *)&v51.var0 = 2 * v15;
          v51.var1 = v14;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v53, v19, &v51);
          re::StringID::destroyString((re::StringID *)&v51);
          unint64_t v11 = *v9;
        }
      }
      if (v11)
      {
        for (unint64_t j = 0; j < v11; ++j)
        {
          uint64_t v21 = *(void *)(*((void *)v9 + 1) + 8 * j);
          if (*(_DWORD *)v21 == 2)
          {
            uint64_t v22 = *(char **)(v21 + 16);
            if (v22)
            {
              uint64_t v23 = *v22;
              if (*v22)
              {
                char v24 = v22[1];
                if (v24)
                {
                  int v25 = (unsigned __int8 *)(v22 + 2);
                  do
                  {
                    uint64_t v23 = 31 * v23 + v24;
                    int v26 = *v25++;
                    char v24 = v26;
                  }
                  while (v26);
                }
              }
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v27 = *(void *)(v21 + 8);
            *(void *)&v51.var0 = 2 * v23;
            v51.var1 = v22;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v53, v27, &v51);
            re::StringID::destroyString((re::StringID *)&v51);
            unint64_t v11 = *v9;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v53, v28);
    xmmword_26AF97720 = (__int128)v51;
    re::StringID::destroyString((re::StringID *)&v49);
    if (v2) {
      return &qword_26AF97700;
    }
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v53);
  re::internal::assertLog((re::internal *)5, v48, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "SamplerCompareFunction", v49, v50);
  double result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

void *re::mtl::introspect_RenderStage(re::mtl *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      uint64_t v10 = re::introspectionAllocator(v9);
      unint64_t v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)unint64_t v11 = 1;
      *((void *)v11 + 1) = 1;
      *((void *)v11 + 2) = "Vertex";
      re::mtl::introspect_RenderStage(BOOL)::enumAttributes = (uint64_t)v11;
      uint64_t v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *(void *)(v13 + 8) = 2;
      *(void *)(v13 + 16) = "Fragment";
      qword_2687A0AD8 = v13;
    }
  }
  {
    uint64_t v14 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::mtl::introspect_RenderStage(BOOL)::info, "RenderStage", 4, 4, 1, 1);
    *(void *)uint64_t v14 = &unk_26E715E00;
    *((void *)v14 + 8) = &re::mtl::introspect_RenderStage(BOOL)::enumTable;
    *((_DWORD *)v14 + 4) = 9;
  }
  if (v2)
  {
    if (re::mtl::introspect_RenderStage(BOOL)::isInitialized) {
      return &re::mtl::introspect_RenderStage(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    char v3 = re::mtl::introspect_RenderStage(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v3) {
      return &re::mtl::introspect_RenderStage(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::mtl::introspect_RenderStage(BOOL)::isInitialized)
    {
LABEL_9:
      uint64_t v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::mtl::introspect_RenderStage(BOOL)::info;
    }
  }
  re::mtl::introspect_RenderStage(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::mtl::introspect_RenderStage(BOOL)::info, a2);
  v15[0] = 0x1F136AA037B8DD0;
  v15[1] = (uint64_t)"RenderStage";
  xmmword_2687A0B08 = v16;
  re::StringID::destroyString((re::StringID *)v15);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::mtl::introspect_RenderStage(BOOL)::info;
}

re::SmoothDeformerModelBuilder *re::SmoothDeformerModelBuilder::SmoothDeformerModelBuilder(re::SmoothDeformerModelBuilder *this, re::Allocator *a2, uint64_t a3, unint64_t a4, DeformationModelData *a5)
{
  *(void *)this = a5;
  long long v9 = (void *)re::DeformationModelData::create<re::SmoothDeformer,re::SmoothDeformerModel>((uint64_t)a5, (uint64_t)a2);
  re::FixedArray<re::StringID>::init<>(v9, (uint64_t)a2, a4);
  re::FixedArray<unsigned short>::init<unsigned short const&>(v9 + 3, (uint64_t)a2, a3, &re::SmoothDeformerModel::kInvalidIndex);
  return this;
}

uint64_t re::DeformationModelData::create<re::SmoothDeformer,re::SmoothDeformerModel>(uint64_t a1, uint64_t a2)
{
  v8[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 48, 8);
  *uint64_t v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v6[0] = &unk_26E713DD8;
  v6[1] = a2;
  v6[3] = v6;
  uint64_t v7 = v4;
  v8[3] = v8;
  v8[0] = &unk_26E713DD8;
  v8[1] = a2;
  std::unique_ptr<void,std::function<void ()(void *)>>::operator=[abi:nn180100]((uint64_t *)(a1 + 440), (uint64_t *)&v7);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v7);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](v6);
  return *(void *)(a1 + 440);
}

unint64_t *re::SmoothDeformerModelBuilder::setEnvelopeBufferName(re::SmoothDeformerModelBuilder *this, unint64_t a2, unint64_t a3, const re::StringID *a4)
{
  uint64_t v4 = *(void **)(*(void *)this + 440);
  if (v4[4] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_7:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(_WORD *)(v4[5] + 2 * a2) = a3;
  if (v4[1] <= a3) {
    goto LABEL_7;
  }
  long long v5 = (unint64_t *)(v4[2] + 16 * a3);
  return re::StringID::operator=(v5, (uint64_t *)a4);
}

uint64_t re::SmoothDeformer::init(uint64_t this, re::RenderManager *a2)
{
  if (!*(unsigned char *)(this + 24))
  {
    uint64_t v3 = this;
    *(unsigned char *)(this + 24) = 1;
    *(void *)(this + 8) = *((void *)a2 + 4);
    if (*((unsigned char *)a2 + 263))
    {
      v5[0] = 0;
      uint64_t v11 = 0;
      memset(v9, 0, sizeof(v9));
      int v10 = 0;
      char v12 = 0;
      char v13 = 0;
      uint64_t v14 = 0;
      char v15 = 0;
      ComputePipelineState = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)v5);
      NS::SharedPtr<MTL::Texture>::operator=((void **)(v3 + 16), ComputePipelineState);
      *(unsigned char *)(v3 + 25) = 1;
      re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v9);
      this = v8[0];
      if (v8[0])
      {
        if (v8[1]) {
          this = (*(uint64_t (**)(void))(*(void *)v8[0] + 40))();
        }
        memset(v8, 0, sizeof(v8));
      }
      if (v5[0])
      {
        this = v6;
        if (v6)
        {
          if (v7) {
            return (*(uint64_t (**)(void))(*(void *)v6 + 40))();
          }
        }
      }
    }
  }
  return this;
}

int64x2_t re::SmoothDeformer::addDeformationInstance@<Q0>(re::SmoothDeformer *this@<X0>, unsigned char *a2@<X1>, uint64_t a3@<X8>)
{
  if (*a2)
  {
    BOOL v3 = 0;
  }
  else if (*((unsigned char *)this + 24))
  {
    BOOL v3 = *((unsigned char *)this + 25) != 0;
  }
  else
  {
    BOOL v3 = 1;
  }
  *(void *)a3 = 0xFFFFFFFFLL;
  int64x2_t result = vdupq_n_s64(2uLL);
  *(int64x2_t *)(a3 + 8) = result;
  *(unsigned char *)(a3 + 24) = v3;
  *(void *)(a3 + 32) = -1;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  return result;
}

uint64_t re::SmoothDeformer::allocateBuffers(re *a1, re::FrameContext *a2, unsigned int a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v6 = a4;
  uint64_t v117 = *MEMORY[0x263EF8340];
  uint64_t v8 = *a4;
  unint64_t v9 = *(void *)(*a4 + 48);
  re::globalAllocators(a1);
  uint64_t v10 = *((void *)a2 + 3);
  char v12 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
  long long v99 = a2;
  char v13 = (_OWORD *)*((void *)a2 + 3);
  v12[1] = v9;
  v12[2] = 0;
  *char v12 = v13;
  if (v9)
  {
    if (v9 >> 57)
    {
LABEL_70:
      re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 128, v9);
      _os_crash();
      __break(1u);
      goto LABEL_71;
    }
    char v13 = (_OWORD *)(*(uint64_t (**)(_OWORD *, unint64_t, uint64_t))(*(void *)v13 + 32))(v13, v9 << 7, 8);
    v12[2] = v13;
    if (!v13)
    {
LABEL_71:
      re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_72:
      re::internal::assertLog((re::internal *)5, v72, "assertion failure: '%s' (%s:line %i) Invalid deformation execution mode: %u.", "!\"Unreachable code\"", "allocateBuffers", 194, a3);
      _os_crash();
      __break(1u);
    }
    char v15 = v13;
    if (v9 != 1)
    {
      bzero(v13, (v9 << 7) - 128);
      v15 += 8 * v9 - 8;
    }
    v15[6] = 0u;
    v15[7] = 0u;
    v15[4] = 0u;
    v15[5] = 0u;
    uint64_t v15[2] = 0u;
    v15[3] = 0u;
    _OWORD *v15 = 0u;
    v15[1] = 0u;
  }
  unint64_t v16 = (unint64_t)&v112;
  *((void *)&v113 + 1) = re::globalAllocators((re *)v13)[2];
  *(void *)&long long v114 = &v112;
  *(void *)&long long v112 = &unk_26E713D80;
  uint64_t v17 = (*(uint64_t (**)(uint64_t, void *, long long *))(*(void *)v10 + 16))(v10, v12, &v112);
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)&v112);
  if (v9)
  {
    unint64_t v18 = 0;
    unint64_t v91 = v9;
    uint64_t v92 = v8 + 8;
    __int16 v96 = v6;
    uint64_t v90 = v17;
    while (1)
    {
      uint64_t v19 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v92, v18);
      unint64_t v20 = *(void *)(v19 + 8);
      unint64_t v21 = v6[6];
      if (v21 <= v20) {
        break;
      }
      uint64_t v22 = v19;
      uint64_t v23 = (void *)(v6[5] + 312 * v20);
      uint64_t v24 = re::BucketArray<re::ActiveDeformation,8ul>::operator[](v6[1], v20);
      long long v98 = *(_DWORD **)(*(void *)(v24 + 352) + 112);
      LOBYTE(v112) = 1;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v23, 1u);
      unsigned int v25 = *(_DWORD *)(v23[8]
                      + 32
                      * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v23 + 7, (unsigned __int8 *)&v112)+ 20);
      LOBYTE(v112) = 1;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v23, 1u);
      uint64_t v26 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v23 + 15, (unsigned __int8 *)&v112);
      uint64_t v6 = *(uint64_t **)(v17 + 8);
      if ((unint64_t)v6 <= v18) {
        goto LABEL_62;
      }
      unsigned int v27 = *(unsigned __int16 *)(v23[16] + 20 * v26 + 4);
      unint64_t v9 = *(void *)(v17 + 16);
      uint64_t v28 = re::DataArray<re::MeshModel>::get(*((void *)a1 + 1) + 8, *(void *)(*(void *)(v24 + 368) + 16));
      unint64_t v16 = *(unsigned __int16 *)(v24 + 392);
      unint64_t v5 = *(void *)(v28 + 56);
      if (v5 <= v16) {
        goto LABEL_63;
      }
      long long v29 = (re::AttributeTable *)(*(void *)(v28 + 64) + 560 * *(unsigned __int16 *)(v24 + 392));
      unint64_t v30 = *(void **)(*(void *)(v24 + 344) + 440);
      uint64_t v95 = v22;
      if (v30)
      {
        unint64_t v5 = v30[4];
        if (v5 <= v16) {
          goto LABEL_64;
        }
        unint64_t v16 = *(unsigned __int16 *)(v30[5] + 2 * v16);
        unint64_t v5 = v30[1];
        if (v5 <= v16) {
          goto LABEL_65;
        }
        re::StringID::StringID((re::StringID *)&v112, (const StringID *)(v30[2] + 16 * v16));
        long long v31 = v29;
        do
        {
          long long v32 = v31;
          long long v31 = (re::AttributeTable *)*((void *)v31 + 1);
        }
        while (v31 && !*((void *)v32 + 9));
        *(void *)simd_float4x4 v105 = (unint64_t)v112 >> 1;
        uint64_t v33 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)v32 + 6, v105);
        if (v33 == -1) {
          float32x4_t v34 = 0;
        }
        else {
          float32x4_t v34 = (unsigned __int8 *)(*((void *)v32 + 7) + 16 * v33 + 8);
        }
        re::StringID::destroyString((re::StringID *)&v112);
      }
      else
      {
        float32x4_t v34 = 0;
      }
      uint64_t v35 = v25 / v27;
      re::FrameContext::perFrameAlloc(v99, 4 * v35, 4uLL, (uint64_t)&v112);
      uint64_t v36 = v112;
      uint64_t v38 = DWORD2(v112);
      unsigned int v37 = HIDWORD(v112);
      uint64_t v39 = v113;
      unint64_t v40 = v9 + (v18 << 7);
      *(void *)(v40 + 80) = v112;
      *(_DWORD *)(v40 + 88) = v38;
      *(_DWORD *)(v40 + 92) = v37;
      *(void *)(v40 + 96) = v39;
      float32x4_t v41 = (void *)(v36 + v38);
      if (v34)
      {
        uint64_t v42 = re::AttributeTable::buffers(v29);
        unint64_t v44 = *v34;
        if (v43 <= v44) {
          goto LABEL_66;
        }
        memcpy(v41, (char *)objc_msgSend(*(id *)(v42 + 16 * v44), sel_contents) + *(unsigned int *)(v42 + 16 * v44 + 8), 4 * v35);
      }
      else if (v37 >= 4)
      {
        memset_pattern16((void *)(v36 + v38), &unk_2343E10A0, v37 & 0xFFFFFFFC);
      }
      unint64_t v5 = 4 * (v35 + 2 * v35);
      unint64_t v16 = v9 + (v18 << 7);
      uint64_t v45 = v29;
      do
      {
        uint64_t v46 = v45;
        uint64_t v45 = (re::AttributeTable *)*((void *)v45 + 1);
      }
      while (v45 && !*((void *)v46 + 9));
      int v94 = v35;
      *(void *)&long long v112 = 0x68D02E008A94F13DLL;
      uint64_t v47 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)v46 + 6, &v112);
      if (v47 == -1) {
        uint64_t v48 = 0;
      }
      else {
        uint64_t v48 = (unsigned __int8 *)(*((void *)v46 + 7) + 16 * v47 + 8);
      }
      uint64_t v49 = v29;
      do
      {
        int v50 = v49;
        uint64_t v49 = (re::AttributeTable *)*((void *)v49 + 1);
      }
      while (v49 && !*((void *)v50 + 9));
      *(void *)&long long v112 = 0x3A18F0C88F5C28F6;
      uint64_t v51 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)v50 + 6, &v112);
      if (v51 == -1) {
        unint64_t v52 = 0;
      }
      else {
        unint64_t v52 = (unsigned __int8 *)(*((void *)v50 + 7) + 16 * v51 + 8);
      }
      unint64_t v97 = v5;
      uint64_t v53 = v29;
      do
      {
        float32x4_t v54 = v53;
        uint64_t v53 = (re::AttributeTable *)*((void *)v53 + 1);
      }
      while (v53 && !*((void *)v54 + 9));
      *(void *)&long long v112 = 0x68D02E0360163291;
      uint64_t v55 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)v54 + 6, &v112);
      if (v55 != -1 && v48 && v52)
      {
        uint64_t v56 = v55;
        if (v98)
        {
          int v57 = *v98;
          float v58 = *((float *)v98 + 1);
        }
        else
        {
          float v58 = 0.5;
          int v57 = 10;
        }
        uint64_t v59 = *((void *)v54 + 7);
        *(_DWORD *)unint64_t v16 = v57;
        unint64_t v16 = v9 + (v18 << 7);
        *(float *)(v16 + 4) = v58;
        uint64_t v60 = re::AttributeTable::buffers(v29);
        unint64_t v62 = *v48;
        if (v61 <= v62) {
          goto LABEL_67;
        }
        *(void *)(v16 + 104) = v60 + 16 * v62;
        uint64_t v63 = re::AttributeTable::buffers(v29);
        unint64_t v65 = *v52;
        if (v64 <= v65) {
          goto LABEL_68;
        }
        float32x4_t v66 = (void *)(v9 + (v18 << 7));
        v66[14] = v63 + 16 * v65;
        uint64_t v67 = re::AttributeTable::buffers(v29);
        unint64_t v69 = *(unsigned __int8 *)(v59 + 16 * v56 + 8);
        if (v68 <= v69) {
          goto LABEL_69;
        }
        v66[15] = v67 + 16 * v69;
        unint64_t v5 = v97;
        re::FrameContext::perFrameAlloc(v99, v97, 4uLL, (uint64_t)&v112);
        uint64_t v70 = v113;
        uint64_t v71 = *((void *)&v112 + 1);
        v66[4] = v112;
        v66[5] = v71;
        v66[6] = v70;
        re::FrameContext::perFrameAlloc(v99, v97, 4uLL, (uint64_t)&v112);
        uint64_t v73 = v113;
        uint64_t v74 = *((void *)&v112 + 1);
        v66[7] = v112;
        v66[8] = v74;
        v66[9] = v73;
        if (a3 == 1)
        {
          long long v75 = *(void **)(v24 + 360);
          uint64_t v76 = v96[2];
          __int16 v101 = 257;
          int v100 = 65548;
          unint64_t v16 = 30;
          char v103 = 30;
          int v102 = 0;
          unsigned int v77 = re::DeformationBufferAllocator::alloc(v75, v76, 1, (uint64_t)&v100, *(unsigned __int8 *)(v95 + 16), v97);
          uint64_t v78 = re::DeformationBufferAllocator::allocationData(*(re::DeformationBufferAllocator **)(v24 + 360), *(unsigned __int8 *)(v95 + 16), v77);
          *(_WORD *)&v105[4] = 257;
          *(_DWORD *)simd_float4x4 v105 = 65548;
          LOBYTE(v106) = 30;
          *(_DWORD *)&v105[8] = 0;
          id v79 = objc_msgSend(*(id *)(v78 + 24), sel_contents);
          uint64_t v80 = *(void *)(v78 + 24);
          *(void *)&long long v112 = v79;
          *((void *)&v112 + 1) = *(void *)(v78 + 32);
          *(void *)&long long v113 = v80;
          re::DeformationVertexBufferState::setOutputBuffer((uint64_t)v23, 1u, 1, (uint64_t)&v112, (uint64_t)v105);
          if (v98) {
            float v81 = *((float *)v98 + 1);
          }
          else {
            float v81 = 0.5;
          }
          re::FrameContext::perFrameAlloc(v99, 8uLL, 4uLL, (uint64_t)&v112);
          uint64_t v82 = v112;
          uint64_t v83 = v113;
          long long v84 = (void *)(v9 + (v18 << 7));
          uint64_t v85 = *((void *)&v112 + 1);
          float32x4_t v86 = (float *)(v112 + DWORD2(v112));
          *(_DWORD *)float32x4_t v86 = v94;
          v86[1] = v81;
          v84[1] = v82;
          void v84[2] = v85;
          v84[3] = v83;
        }
        else
        {
          if (a3) {
            goto LABEL_72;
          }
          re::FrameContext::perFrameAlloc(v99, v97, 0x10uLL, (uint64_t)&v112);
          *(_WORD *)&v105[4] = 257;
          *(_DWORD *)simd_float4x4 v105 = 65548;
          LOBYTE(v106) = 30;
          *(_DWORD *)&v105[8] = 0;
          re::DeformationVertexBufferState::setOutputBuffer((uint64_t)v23, 1u, 0, (uint64_t)&v112, (uint64_t)v105);
        }
      }
      ++v18;
      uint64_t v17 = v90;
      uint64_t v6 = v96;
      if (v18 == v91) {
        goto LABEL_60;
      }
    }
    re::internal::assertLog((re::internal *)6, v20, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, *(void *)(v19 + 8), v21);
    _os_crash();
    __break(1u);
LABEL_62:
    uint64_t v104 = 0;
    long long v116 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)simd_float4x4 v105 = 136315906;
    *(void *)&v105[4] = "operator[]";
    __int16 v106 = 1024;
    int v107 = 468;
    __int16 v108 = 2048;
    unint64_t v109 = v18;
    __int16 v110 = 2048;
    unint64_t v111 = (unint64_t)v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_63:
    uint64_t v104 = 0;
    long long v116 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)simd_float4x4 v105 = 136315906;
    *(void *)&v105[4] = "operator[]";
    __int16 v106 = 1024;
    int v107 = 476;
    __int16 v108 = 2048;
    unint64_t v109 = v16;
    __int16 v110 = 2048;
    unint64_t v111 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_64:
    uint64_t v104 = 0;
    long long v116 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)simd_float4x4 v105 = 136315906;
    *(void *)&v105[4] = "operator[]";
    __int16 v106 = 1024;
    int v107 = 476;
    __int16 v108 = 2048;
    unint64_t v109 = v16;
    __int16 v110 = 2048;
    unint64_t v111 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_65:
    uint64_t v104 = 0;
    long long v116 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)simd_float4x4 v105 = 136315906;
    *(void *)&v105[4] = "operator[]";
    __int16 v106 = 1024;
    int v107 = 476;
    __int16 v108 = 2048;
    unint64_t v109 = v16;
    __int16 v110 = 2048;
    unint64_t v111 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_66:
    re::internal::assertLog((re::internal *)6, v43, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v44, v43);
    _os_crash();
    __break(1u);
LABEL_67:
    re::internal::assertLog((re::internal *)6, v61, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v62, v61);
    _os_crash();
    __break(1u);
LABEL_68:
    re::internal::assertLog((re::internal *)6, v64, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v65, v64);
    _os_crash();
    __break(1u);
LABEL_69:
    re::internal::assertLog((re::internal *)6, v68, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v69, v68);
    _os_crash();
    __break(1u);
    goto LABEL_70;
  }
LABEL_60:
  *(void *)a5 |= 2uLL;
  *(unsigned char *)(a5 + 9) = 1;
  return v17;
}

uint64_t re::SmoothDeformer::deformGPU(uint64_t a1, uint64_t a2, void **this, uint64_t *a4)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  re::mtl::ComputeCommandEncoder::pushDebugGroup(this, (re::ns *)"Perform Smoothing");
  long long v31 = a4;
  uint64_t v8 = *a4;
  uint64_t v34 = *(void *)(*a4 + 48);
  if (v34)
  {
    unint64_t v9 = 0;
    uint64_t v32 = a2;
    uint64_t v33 = v8 + 8;
    do
    {
      uint64_t v10 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v33, v9);
      unint64_t v12 = *(void *)(a2 + 8);
      if (v12 <= v9)
      {
        memset(v53, 0, sizeof(v53));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)int v50 = 136315906;
        *(void *)&v50[4] = "operator[]";
        *(_WORD *)&v50[12] = 1024;
        *(_DWORD *)&v50[14] = 468;
        *(_WORD *)&v50[18] = 2048;
        *(void *)&v50[20] = v9;
        __int16 v51 = 2048;
        unint64_t v52 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_25:
        re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v4, v15);
        _os_crash();
        __break(1u);
      }
      uint64_t v13 = *(void *)(a2 + 16);
      uint64_t v14 = v13 + (v9 << 7);
      if (*(void *)(v14 + 104))
      {
        if (*(void *)(v14 + 112))
        {
          uint64_t v49 = (void **)(v13 + (v9 << 7) + 120);
          if (*v49)
          {
            unint64_t v4 = *(void *)(v10 + 8);
            unint64_t v15 = v31[6];
            if (v15 <= v4) {
              goto LABEL_25;
            }
            uint64_t v16 = v31[5];
            uint64_t v17 = (void *)(v16 + 312 * v4);
            LOBYTE(v53[0]) = 1;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v17, 1u);
            uint64_t v36 = v17 + 7;
            uint64_t v35 = v17 + 8;
            unsigned int v18 = *(_DWORD *)(v17[8]
                            + 32
                            * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v17 + 7, (unsigned __int8 *)v53)+ 20);
            LOBYTE(v53[0]) = 1;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v17, 1u);
            uint64_t v43 = (uint64_t)v17;
            uint64_t v19 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v17 + 15, (unsigned __int8 *)v53);
            if (*(_DWORD *)v14)
            {
              unsigned int v20 = *(unsigned __int16 *)(v17[16] + 20 * v19 + 4);
              unsigned int v21 = objc_msgSend(*(id *)(a1 + 16), sel_maxTotalThreadsPerThreadgroup);
              if (*(_DWORD *)v14)
              {
                unsigned int v22 = 0;
                uint64_t v23 = v13 + (v9 << 7);
                float32x4_t v41 = (unsigned int *)(v23 + 40);
                uint64_t v42 = v23 + 32;
                uint64_t v39 = (unsigned int *)(v23 + 64);
                uint64_t v40 = v23 + 56;
                uint64_t v24 = v16 + 312 * v4;
                unsigned int v37 = (void *)(v24 + 192);
                uint64_t v38 = (void *)(v24 + 184);
                uint64_t v46 = v23 + 8;
                uint64_t v47 = v23 + 80;
                uint64_t v45 = (v18 / v20 + v21 - 1) / v21;
                uint64_t v44 = v21;
                do
                {
                  [*this setComputePipelineState:*(void *)(a1 + 16)];
                  if (v22)
                  {
                    if (v22)
                    {
                      uint64_t v25 = *(void *)(v42 + 16);
                      uint64_t v26 = v41;
                    }
                    else
                    {
                      uint64_t v25 = *(void *)(v40 + 16);
                      uint64_t v26 = v39;
                    }
                  }
                  else
                  {
                    LOBYTE(v53[0]) = 1;
                    unint64_t v4 = v43;
                    re::DeformationVertexBufferState::ensureVertexBufferInitialized(v43, 1u);
                    uint64_t v25 = *(void *)(*v35
                                    + 32
                                    * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v36, (unsigned __int8 *)v53)+ 24);
                    LOBYTE(v53[0]) = 1;
                    re::DeformationVertexBufferState::ensureVertexBufferInitialized(v43, 1u);
                    uint64_t v26 = (unsigned int *)(*v35
                                         + 32
                                         * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v36, (unsigned __int8 *)v53)+ 16);
                  }
                  [*this setBuffer:v25 offset:*v26 atIndex:1];
                  if (v22 == *(_DWORD *)v14 - 1)
                  {
                    LOBYTE(v53[0]) = 1;
                    re::DeformationVertexBufferState::ensureVertexBufferInitialized(v43, 1u);
                    unint64_t v4 = (unint64_t)v37;
                    uint64_t v27 = *(void *)(*v37
                                    + 32
                                    * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v38, (unsigned __int8 *)v53)+ 24);
                    LOBYTE(v53[0]) = 1;
                    re::DeformationVertexBufferState::ensureVertexBufferInitialized(v43, 1u);
                    uint64_t v28 = (unsigned int *)(*v37
                                         + 32
                                         * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v38, (unsigned __int8 *)v53)+ 16);
                  }
                  else if (v22)
                  {
                    uint64_t v27 = *(void *)(v40 + 16);
                    uint64_t v28 = v39;
                  }
                  else
                  {
                    uint64_t v27 = *(void *)(v42 + 16);
                    uint64_t v28 = v41;
                  }
                  [*this setBuffer:v27 offset:*v28 atIndex:0];
                  [*this setBuffer:**(void **)(v14 + 104) offset:*(unsigned int *)(*(void *)(v14 + 104) + 8) atIndex:2];
                  [*this setBuffer:**(void **)(v14 + 112) offset:*(unsigned int *)(*(void *)(v14 + 112) + 8) atIndex:3];
                  [*this setBuffer:**v49 offset:*((unsigned int *)*v49 + 2) atIndex:4];
                  [*this setBuffer:*(void *)(v47 + 16) offset:*(unsigned int *)(v47 + 8) atIndex:5];
                  [*this setBuffer:*(void *)(v46 + 16) offset:*(unsigned int *)(v46 + 8) atIndex:6];
                  long long v29 = *this;
                  *(void *)&v53[0] = v45;
                  *(int64x2_t *)((char *)v53 + 8) = vdupq_n_s64(1uLL);
                  *(void *)int v50 = v44;
                  *(_OWORD *)&v50[8] = *(_OWORD *)((char *)v53 + 8);
                  [v29 dispatchThreadgroups:v53 threadsPerThreadgroup:v50];
                  ++v22;
                }
                while (v22 < *(_DWORD *)v14);
              }
            }
          }
        }
      }
      ++v9;
      a2 = v32;
    }
    while (v9 != v34);
  }
  return [*this popDebugGroup];
}

void re::SmoothDeformer::deformCPU(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  uint64_t v72 = *(void *)(*a3 + 48);
  if (v72)
  {
    uint64_t v3 = a2;
    unint64_t v4 = 0;
    uint64_t v73 = *a3 + 8;
    while (1)
    {
      uint64_t v5 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v73, v4);
      if (*(void *)(v3 + 8) <= v4) {
        goto LABEL_37;
      }
      uint64_t v7 = *(void *)(v3 + 16);
      unint64_t v74 = v4;
      uint64_t v8 = v7 + (v4 << 7);
      unint64_t v9 = (uint64_t *)(v8 + 104);
      if (*(void *)(v8 + 104))
      {
        uint64_t v10 = (uint64_t *)(v8 + 112);
        if (*(void *)(v8 + 112))
        {
          uint64_t v11 = v7 + (v74 << 7);
          uint64_t v13 = *(void *)(v11 + 120);
          unint64_t v12 = (uint64_t *)(v11 + 120);
          if (v13)
          {
            unint64_t v14 = *(void *)(v5 + 8);
            unint64_t v15 = a3[6];
            if (v15 <= v14) {
              goto LABEL_38;
            }
            uint64_t v16 = (void *)(a3[5] + 312 * v14);
            LOBYTE(v75[0]) = 1;
            uint64_t v70 = (unsigned int *)v8;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v16, 1u);
            unsigned int v69 = *(_DWORD *)(v16[8]
                            + 32
                            * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v16 + 7, (unsigned __int8 *)v75)+ 20);
            LOBYTE(v75[0]) = 1;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v16, 1u);
            unsigned int v17 = *(unsigned __int16 *)(v16[16]
                                      + 20
                                      * re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v16 + 15, (unsigned __int8 *)v75)+ 4);
            uint64_t v18 = *v9;
            uint64_t v67 = (char *)objc_msgSend(*(id *)v18, sel_contents);
            uint64_t v63 = *(unsigned int *)(v18 + 8);
            uint64_t v19 = *v10;
            unsigned int v20 = (char *)objc_msgSend(*(id *)v19, sel_contents);
            uint64_t v21 = *(unsigned int *)(v19 + 8);
            uint64_t v22 = *v12;
            uint64_t v23 = (char *)objc_msgSend(*(id *)v22, sel_contents);
            uint64_t v24 = *(unsigned int *)(v22 + 8);
            uint64_t v25 = v7 + (v74 << 7);
            uint64_t v26 = *(void *)(v25 + 80);
            uint64_t v27 = *(unsigned int *)(v25 + 88);
            LOBYTE(v75[0]) = 1;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v16, 1u);
            uint64_t v28 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v16 + 23, (unsigned __int8 *)v75);
            unsigned int v32 = v69;
            unsigned int v33 = *v70;
            if (*v70) {
              break;
            }
          }
        }
      }
LABEL_31:
      unint64_t v4 = v74 + 1;
      uint64_t v3 = a2;
      if (v74 + 1 == v72) {
        return;
      }
    }
    unsigned int v34 = v17;
    int v35 = 0;
    uint64_t v36 = &v67[v63];
    unsigned int v37 = &v20[v21];
    uint64_t v38 = &v23[v24];
    uint64_t v39 = v26 + v27;
    uint64_t v40 = v16[24] + 32 * v28;
    float32x4_t v41 = (char *)(*(void *)(v40 + 8) + *(unsigned int *)(v40 + 16));
    unsigned int v42 = *(_DWORD *)(v40 + 20);
    unint64_t v43 = v42 / 0xCuLL;
    unsigned int v44 = *(_DWORD *)(v25 + 44);
    uint64_t v45 = (char *)(*(void *)(v25 + 32) + *(unsigned int *)(v25 + 40));
    unint64_t v46 = v44 / 0xCuLL;
    uint64_t v47 = (float *)(v25 + 4);
    unsigned int v62 = v44;
    if (v69 / v34 <= 1) {
      uint64_t v48 = 1;
    }
    else {
      uint64_t v48 = v69 / v34;
    }
    unsigned int v65 = v34;
    uint64_t v64 = v39;
    while (v32 < v34)
    {
LABEL_28:
      if (v44 >= 0xC)
      {
        int v68 = v35;
        memmove(v41, v45, 12 * v46);
        unsigned int v44 = v62;
        uint64_t v39 = v64;
        int v35 = v68;
        unsigned int v34 = v65;
        unsigned int v32 = v69;
        unsigned int v33 = *v70;
      }
      if (++v35 >= v33) {
        goto LABEL_31;
      }
    }
    unint64_t v49 = 0;
    while (1)
    {
      int v50 = v49 ? *(_DWORD *)&v37[4 * v49 - 4] : 0;
      unsigned int v51 = *(_DWORD *)&v37[4 * v49];
      unsigned int v52 = v50 + 1;
      if (v52 < v51) {
        break;
      }
      double v55 = 0.0;
      float32x4_t v54 = 0uLL;
LABEL_25:
      if (v49 == v43) {
        goto LABEL_35;
      }
      if (v49 == v46) {
        goto LABEL_36;
      }
      uint64_t v59 = &v41[12 * v49];
      v29.i64[0] = *(void *)v59;
      v29.i32[2] = *((_DWORD *)v59 + 2);
      float32x4_t v60 = vaddq_f32(v29, vmulq_n_f32(vmulq_n_f32(vdivq_f32(v54, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v55, 0)), *v47), *(float *)(v39 + 4 * v49)));
      unint64_t v61 = &v45[12 * v49];
      *(void *)unint64_t v61 = v60.i64[0];
      *((_DWORD *)v61 + 2) = v60.i32[2];
      if (++v49 == v48) {
        goto LABEL_28;
      }
    }
    uint64_t v53 = &v41[12 * v49];
    float32x4_t v54 = 0uLL;
    double v55 = 0.0;
    while (1)
    {
      unsigned int v56 = *(_DWORD *)&v36[4 * v52];
      if (v43 <= v56) {
        break;
      }
      if (v49 >= v43) {
        goto LABEL_34;
      }
      float v57 = *(float *)&v38[4 * v52];
      float v58 = &v41[12 * v56];
      v30.i64[0] = *(void *)v58;
      v30.i32[2] = *((_DWORD *)v58 + 2);
      v31.i64[0] = *(void *)v53;
      v31.i32[2] = *((_DWORD *)v53 + 2);
      float32x4_t v30 = vmulq_n_f32(vsubq_f32(v30, v31), v57);
      float32x4_t v54 = vaddq_f32(v54, v30);
      *(float *)&double v55 = *(float *)&v55 + v57;
      if (v51 == ++v52) {
        goto LABEL_25;
      }
    }
    re::internal::assertLog((re::internal *)6, v39, *(double *)v54.i64, v55, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, *(unsigned int *)&v36[4 * v52], v42 / 0xCuLL);
    _os_crash();
    __break(1u);
LABEL_34:
    re::internal::assertLog((re::internal *)6, v39, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v49, v42 / 0xCuLL);
    _os_crash();
    __break(1u);
LABEL_35:
    re::internal::assertLog((re::internal *)6, v39, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v42 / 0xCuLL, v42 / 0xCuLL);
    _os_crash();
    __break(1u);
LABEL_36:
    re::internal::assertLog((re::internal *)6, v39, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v46, v46);
    _os_crash();
    __break(1u);
LABEL_37:
    memset(v75, 0, sizeof(v75));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_38:
    re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v14, v15);
    _os_crash();
    __break(1u);
  }
}

re::StringID *re::SmoothDeformerModelUtil::envelopeBufferNameForSmoothDataIndex@<X0>(re::SmoothDeformerModelUtil *this@<X0>, const DeformationModelData *a2@<X1>, re::StringID *a3@<X8>)
{
  uint64_t v3 = *((void *)this + 55);
  if (v3 && *(void *)(v3 + 8) > (unint64_t)a2) {
    return re::StringID::StringID(a3, (const StringID *)(*(void *)(v3 + 16) + 16 * a2));
  }
  else {
    return re::StringID::invalid(a3);
  }
}

uint64_t re::SmoothDeformerModelUtil::computeSmoothDeformerModelSizeExcludingMetalBuffers(re::SmoothDeformerModelUtil *this, const DeformationModelData *a2)
{
  int v2 = (void *)*((void *)this + 55);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2[1];
  uint64_t v4 = 2 * v2[4] + 16 * v3 + 48;
  if (v3)
  {
    uint64_t v5 = (const char **)(v2[2] + 8);
    do
    {
      if (*(unsigned char *)(v5 - 1)) {
        size_t v6 = strlen(*v5) + 1;
      }
      else {
        size_t v6 = 0;
      }
      v4 += v6;
      v5 += 2;
      --v3;
    }
    while (v3);
  }
  return v4;
}

void re::SmoothDeformer::~SmoothDeformer(re::SmoothDeformer *this)
{
  int v2 = (void *)*((void *)this + 2);
  if (v2)
  {

    *((void *)this + 2) = 0;
  }
}

{
  void *v2;
  uint64_t vars8;

  int v2 = (void *)*((void *)this + 2);
  if (v2)
  {

    *((void *)this + 2) = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

void re::internal::Callable<re::SmoothDeformer::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::~Callable()
{
}

uint64_t re::internal::Callable<re::SmoothDeformer::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::operator()(uint64_t a1, uint64_t **a2)
{
  int v2 = *a2;
  uint64_t result = **a2;
  if (result)
  {
    if (v2[1])
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 40))(result, v2[2]);
      v2[1] = 0;
      v2[2] = 0;
    }
    uint64_t *v2 = 0;
  }
  return result;
}

void *re::internal::Callable<re::SmoothDeformer::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t result = a2;
  *a2 = &unk_26E713D80;
  return result;
}

void *re::internal::Callable<re::SmoothDeformer::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t result = a2;
  *a2 = &unk_26E713D80;
  return result;
}

uint64_t re::internal::Callable<re::SmoothDeformer::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::size()
{
  return 16;
}

void _ZNSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14SmoothDeformerENS2_19SmoothDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14SmoothDeformerENS2_19SmoothDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26E713DD8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14SmoothDeformerENS2_19SmoothDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEPNS0_6__baseISI_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E713DD8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14SmoothDeformerENS2_19SmoothDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EEclEOSE_(uint64_t result, void **a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 3);
    re::FixedArray<re::StringID>::deinit(v2);
    uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)v3 + 40);
    return v4(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14SmoothDeformerENS2_19SmoothDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_14SmoothDeformerENS2_19SmoothDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE11target_typeEv()
{
}

float32x2_t re::TonemapUserParameters::computeDirectParameters@<D0>(re::TonemapUserParameters *this@<X0>, float32x2_t *a2@<X8>)
{
  float v4 = *((float *)this + 1);
  if (v4 > 1.0) {
    float v4 = 1.0;
  }
  if (v4 < 0.0) {
    float v4 = 0.0;
  }
  float v5 = powf(v4, 2.2);
  float v6 = *(float *)this;
  if (*(float *)this > 1.0) {
    float v6 = 1.0;
  }
  if (v6 < 0.0) {
    float v6 = 0.0;
  }
  float v7 = *((float *)this + 4);
  if (v7 > 1.0) {
    float v7 = 1.0;
  }
  if (v7 < 0.0) {
    float v7 = 0.0;
  }
  float v21 = v7;
  float v9 = *((float *)this + 2);
  float v8 = *((float *)this + 3);
  if (v8 > 1.0) {
    float v8 = 1.0;
  }
  if (v8 < 0.0) {
    float v8 = 0.0;
  }
  if (v9 > 10.0) {
    float v9 = 10.0;
  }
  if (v9 >= 0.0) {
    float v10 = v9;
  }
  else {
    float v10 = 0.0;
  }
  float v20 = v10;
  float32_t v11 = v5 * 0.5;
  float32_t v12 = (float)(v5 * 0.5) + (float)(v6 * (float)(0.0 - (float)(v5 * 0.5)));
  float v13 = (float)(1.0 - v12) + (float)(v8 * (float)(0.0 - (float)(1.0 - v12)));
  float32_t v14 = (float)(v5 * 0.5) + v13;
  float32_t v15 = v12 + v13;
  float32_t v16 = (float)(exp2f(v10) + (float)((float)(v5 * 0.5) + (float)(1.0 - v12))) + -1.0;
  __int32 v17 = *((_DWORD *)this + 5);
  a2[2].f32[0] = v16;
  a2[2].i32[1] = v17;
  a2->f32[0] = v11;
  a2->f32[1] = v12;
  a2[1].f32[0] = v14;
  a2[1].f32[1] = v15;
  v18.i32[1] = 1056964608;
  v18.f32[0] = v16 + v16;
  float32x2_t result = vmul_n_f32(vmul_n_f32(v18, v21), v20);
  a2[3] = result;
  return result;
}

float re::TonemapUserParameters::computeRenderParameters@<S0>(re::TonemapUserParameters *this@<X0>, uint64_t a2@<X8>)
{
  memset(v13, 0, sizeof(v13));
  re::TonemapUserParameters::computeDirectParameters(this, (float32x2_t *)v13);
  re::TonemapUserParameters::computeRenderParametersImpl((float *)this, (float *)v13, a2);
  float v4 = *(float *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = 1065353216;
  *(_DWORD *)(a2 + 124) = 1065353216;
  if (*((unsigned char *)this + 44))
  {
    int v5 = *((_DWORD *)this + 12);
    if (v5 == 2)
    {
      float v9 = *((float *)this + 10);
    }
    else
    {
      if (v5 == 1)
      {
        float v8 = *((float *)this + 13) * 0.18;
      }
      else
      {
        float v6 = 1.0;
        if (v5)
        {
LABEL_12:
          *(float *)(a2 + 128) = 1.0 / *((float *)this + 13);
          goto LABEL_13;
        }
        float v7 = re::computeTonemappingInverse((float *)a2, *((float *)this + 13));
        float v8 = re::computeTonemapping((float *)a2, v7 * 0.18);
      }
      float v9 = v8 / 0.13;
    }
    float v10 = *((float *)this + 9);
    float v6 = (float)(v10 * re::computeTonemappingInverse((float *)a2, v9 * 0.13)) / 0.18;
    goto LABEL_12;
  }
  if (*((unsigned char *)this + 32)) {
    float v6 = (float)(re::computeTonemappingInverse((float *)a2, *((float *)this + 10) * 0.13) * *((float *)this + 9)) / 0.18;
  }
  else {
    float v6 = 1.0;
  }
LABEL_13:
  float v11 = v4 * v6;
  *(float *)(a2 + 24) = v11;
  float result = 1.0 / v11;
  *(float *)(a2 + 124) = result;
  return result;
}

float re::TonemapUserParameters::computeRenderParametersImpl@<S0>(float *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  *(unsigned char *)(a3 + 120) = 1;
  float v5 = a2[1];
  float v6 = a2[3];
  float v7 = a2[5];
  float v41 = a2[7];
  float v42 = a2[4];
  float v8 = *a2 * (float)(1.0 / v42);
  float v43 = a2[2] * (float)(1.0 / v42);
  float v9 = 1.0;
  if ((float)(v43 - v8) != 0.0) {
    float v9 = (float)(v6 - v5) / (float)(v43 - v8);
  }
  float v40 = a2[6];
  *(float *)(a3 + 68) = (float)-(float)(v5 + (float)((float)-v9 * v8)) / v9;
  *(void *)(a3 + 72) = 0x3F80000000000000;
  *(_DWORD *)(a3 + 80) = 1065353216;
  *(float *)(a3 + 84) = v7 * logf(v9);
  *(float *)(a3 + 88) = v7;
  float v39 = v5 - (float)(v9 * v8);
  float v37 = v7 + -1.0;
  float v38 = v7 * v9;
  float v10 = (float)(v7 * v9) * powf(v39 + (float)(v9 * v8), v7 + -1.0);
  float v11 = powf(v5, v7);
  if (v11 >= 0.00001) {
    float v12 = v11;
  }
  else {
    float v12 = 0.00001;
  }
  float v13 = powf(v6, v7);
  if (v13 >= 0.00001) {
    float v14 = v13;
  }
  else {
    float v14 = 0.00001;
  }
  float v15 = powf(v41 + 1.0, v7) + -1.0;
  *(float *)a3 = v42;
  *(float *)(a3 + 4) = 1.0 / v42;
  *(float *)(a3 + 8) = v8;
  *(float *)(a3 + 12) = v43;
  *(float *)(a3 + 16) = v12;
  *(float *)(a3 + 20) = v14;
  float v16 = (float)(v8 * v10) / v12;
  float v17 = logf(v12);
  float v18 = logf(v8);
  *(_OWORD *)(a3 + 44) = xmmword_2343854A0;
  *(float *)(a3 + 60) = v17 - (float)(v16 * v18);
  *(float *)(a3 + 64) = v16;
  float v19 = v15 + 1.0;
  float v20 = v19 - v14;
  float v21 = 0.0;
  BOOL v22 = (float)(v19 - v14) <= 0.0;
  float v23 = 0.0;
  float v24 = 0.0;
  float v25 = 0.0;
  float v26 = 0.0;
  if (!v22)
  {
    float v24 = (float)((float)(1.0 / v42) * v40) + 1.0;
    float v25 = (float)((float)(v24 - v43) * (float)(v38 * powf(v39 + (float)(v9 * v43), v37))) / v20;
    float v27 = logf(v20);
    float v28 = logf(v24 - v43);
    float v21 = 0.0;
    float v26 = v27 - (float)(v25 * v28);
    float v23 = -1.0;
  }
  *(float *)(a3 + 100) = v23;
  *(float *)(a3 + 104) = v23;
  *(float *)(a3 + 92) = v24;
  *(float *)(a3 + 96) = v19;
  *(float *)(a3 + 108) = v26;
  *(float *)(a3 + 112) = v25;
  float v29 = v23 * (float)(1.0 - v24);
  if (v29 > 0.0)
  {
    float v30 = logf(v29);
    float v21 = expf(v26 + (float)(v25 * v30));
  }
  uint64_t v31 = 0;
  float v32 = 1.0 / (float)(v19 + (float)(v21 * v23));
  do
  {
    uint64_t v33 = a3 + v31;
    *(float *)(v33 + 48) = v32 * *(float *)(a3 + v31 + 48);
    *(float *)(v33 + 56) = v32 * *(float *)(a3 + v31 + 56);
    v31 += 24;
  }
  while (v31 != 72);
  *(float *)(a3 + 24) = exp2f(a1[7]);
  float v34 = a1[6];
  float v35 = powf(0.18 / a1[9], 1.0 - v34);
  *(float *)(a3 + 28) = v35;
  *(float *)(a3 + 32) = v34;
  float result = 1.0 / v35;
  *(float *)(a3 + 36) = result;
  *(float *)(a3 + 40) = 1.0 / v34;
  *(_DWORD *)(a3 + 128) = 1065353216;
  return result;
}

float re::computeTonemappingInverse(float *a1, float a2)
{
  float v3 = 1.0;
  if (a2 <= 1.0) {
    float v3 = a2;
  }
  float v4 = 0.0;
  if (v3 < 0.0) {
    float v3 = 0.0;
  }
  if (v3 <= a1[5]) {
    unsigned int v5 = v3 > a1[4];
  }
  else {
    unsigned int v5 = 2;
  }
  float v6 = &a1[6 * v5];
  float v7 = v6[13];
  float v8 = v6[11];
  float v9 = (float)(v3 - v6[12]) / v6[14];
  if (v9 > 0.0)
  {
    float v10 = &a1[6 * v5];
    float v12 = v10[15];
    float v11 = v10[16];
    float v13 = logf(v9);
    float v4 = expf((float)(v13 - v12) / v11);
  }
  return (float)(*a1 * powf(a1[9] * (float)(v8 + (float)(v4 / v7)), a1[10])) / a1[6];
}

float re::computeTonemapping(float *a1, float a2)
{
  float v3 = (float)(powf(a1[6] * a2, a1[8]) * a1[7]) * a1[1];
  if (v3 <= a1[3]) {
    unsigned int v4 = v3 > a1[2];
  }
  else {
    unsigned int v4 = 2;
  }
  unsigned int v5 = &a1[6 * v4];
  float v6 = v5[14];
  float v7 = v5[12];
  float v8 = (float)(v3 - v5[11]) * v5[13];
  float v9 = 0.0;
  if (v8 > 0.0)
  {
    float v10 = &a1[6 * v4];
    float v12 = v10[15];
    float v11 = v10[16];
    float v13 = logf(v8);
    float v9 = expf(v12 + (float)(v11 * v13));
  }
  return v7 + (float)(v9 * v6);
}

void re::computeTonemappingInverseAccelerated(float *a1, const float *__A, float *a3, unint64_t a4)
{
  float v6 = __A;
  float v23 = a1;
  if (a4)
  {
    float v8 = __A;
    unint64_t v9 = a4;
    do
    {
      unint64_t v10 = v9 >> 1;
      float v11 = (float *)&v8[v9 >> 1];
      float v13 = *v11;
      float v12 = v11 + 1;
      v9 += ~(v9 >> 1);
      if (v13 < a1[4]) {
        float v8 = v12;
      }
      else {
        unint64_t v9 = v10;
      }
    }
    while (v9);
    vDSP_Length v14 = v8 - __A;
    re::computeTonemappingInverseAccelerated(re::TonemapParameters const&,float *,float *,unsigned long)::$_0::operator()(&v23, 0, __A, a3, v14);
    float v15 = a1[5];
    float v16 = v6;
    unint64_t v17 = a4;
    do
    {
      unint64_t v18 = v17 >> 1;
      float v19 = (float *)&v16[v17 >> 1];
      float v21 = *v19;
      float v20 = v19 + 1;
      v17 += ~(v17 >> 1);
      if (v21 < v15) {
        float v16 = v20;
      }
      else {
        unint64_t v17 = v18;
      }
    }
    while (v17);
    float v6 = v8;
  }
  else
  {
    re::computeTonemappingInverseAccelerated(re::TonemapParameters const&,float *,float *,unsigned long)::$_0::operator()(&v23, 0, __A, a3, 0);
    vDSP_Length v14 = 0;
    float v16 = v6;
  }
  BOOL v22 = &a3[v14];
  re::computeTonemappingInverseAccelerated(re::TonemapParameters const&,float *,float *,unsigned long)::$_0::operator()(&v23, 1, v6, v22, v16 - v6);
  re::computeTonemappingInverseAccelerated(re::TonemapParameters const&,float *,float *,unsigned long)::$_0::operator()(&v23, 2, v16, (float *)((char *)v22 + (char *)v16 - (char *)v6), a4 - (v14 + v16 - v6));
}

void re::computeTonemappingInverseAccelerated(re::TonemapParameters const&,float *,float *,unsigned long)::$_0::operator()(float **a1, int a2, const float *__A, float *a4, vDSP_Length __N)
{
  float v7 = *a1;
  float v8 = &(*a1)[6 * a2];
  float v23 = v8[11];
  float v22 = 1.0 / v8[13];
  float v21 = -v8[15];
  float v20 = 1.0 / v8[16];
  float v19 = 1.0 / v8[14];
  float __B = -v8[12];
  float v17 = *v7 / v7[6];
  vDSP_vsadd(__A, 1, &__B, a4, 1, __N);
  vDSP_vsmul(a4, 1, &v19, a4, 1, __N);
  float __N_4 = 0.0;
  if (__N)
  {
    vDSP_Length v9 = __N;
    unint64_t v10 = a4;
    do
    {
      vDSP_Length v11 = v9 >> 1;
      float v12 = &v10[v9 >> 1];
      float v14 = *v12;
      float v13 = v12 + 1;
      v9 += ~(v9 >> 1);
      if (v14 > 0.0) {
        vDSP_Length v9 = v11;
      }
      else {
        unint64_t v10 = v13;
      }
    }
    while (v9);
  }
  else
  {
    unint64_t v10 = a4;
  }
  vDSP_vramp(&__N_4, &__N_4, a4, 1, (int)(v10 - a4));
  int __Na = __N - ((unint64_t)((char *)v10 - (char *)a4) >> 2);
  vvlogf(v10, v10, &__Na);
  vDSP_vsadd(v10, 1, &v21, v10, 1, __Na);
  vDSP_vsmul(v10, 1, &v20, v10, 1, __Na);
  vvexpf(v10, v10, &__Na);
  vDSP_vsmul(a4, 1, &v22, a4, 1, __N);
  vDSP_vsadd(a4, 1, &v23, a4, 1, __N);
  vDSP_vsmul(a4, 1, &v17, a4, 1, __N);
}

BOOL re::haveSamePreBlendLUT(re *this, const re::TonemapUserParameters *a2, const re::TonemapUserParameters *a3)
{
  return *(float *)this == *(float *)a2
      && *((float *)this + 1) == *((float *)a2 + 1)
      && *((float *)this + 2) == *((float *)a2 + 2)
      && *((float *)this + 3) == *((float *)a2 + 3)
      && *((float *)this + 4) == *((float *)a2 + 4)
      && *((float *)this + 5) == *((float *)a2 + 5)
      && *((float *)this + 6) == *((float *)a2 + 6)
      && *((unsigned __int8 *)this + 44) == *((unsigned __int8 *)a2 + 44)
      && *((_DWORD *)this + 12) == *((_DWORD *)a2 + 12)
      && *((float *)this + 13) == *((float *)a2 + 13);
}

BOOL re::haveSameExposure(re *this, const re::TonemapUserParameters *a2, const re::TonemapUserParameters *a3)
{
  return *((float *)this + 7) == *((float *)a2 + 7)
      && *((unsigned __int8 *)this + 32) == *((unsigned __int8 *)a2 + 32)
      && *((float *)this + 9) == *((float *)a2 + 9)
      && *((float *)this + 10) == *((float *)a2 + 10)
      && *((unsigned __int8 *)this + 44) == *((unsigned __int8 *)a2 + 44)
      && *((_DWORD *)this + 12) == *((_DWORD *)a2 + 12)
      && *((float *)this + 13) == *((float *)a2 + 13);
}

void *re::allocInfo_TonemapUserParameters(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_413, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_413))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF97F90, "TonemapUserParameters");
    __cxa_guard_release(&_MergedGlobals_413);
  }
  return &unk_26AF97F90;
}

void re::initInfo_TonemapUserParameters(re *this, re::IntrospectionBase *a2)
{
  v46[0] = 0xA8AD3C79569E427ELL;
  v46[1] = "TonemapUserParameters";
  re::StringID::destroyString((re::StringID *)v46);
  *((_OWORD *)this + 2) = v47;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF97F38, memory_order_acquire) & 1) == 0)
  {
    unsigned int v4 = (re *)__cxa_guard_acquire(&qword_26AF97F38);
    if (v4)
    {
      unsigned int v5 = re::introspectionAllocator(v4);
      float v7 = re::introspect_float((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "toeStrength";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF97F40 = v8;
      vDSP_Length v9 = re::introspectionAllocator((re *)v8);
      vDSP_Length v11 = re::introspect_float((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "toeLength";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x400000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF97F48 = v12;
      float v13 = re::introspectionAllocator((re *)v12);
      float v15 = re::introspect_float((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "shoulderStrength";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x800000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF97F50 = v16;
      float v17 = re::introspectionAllocator((re *)v16);
      float v19 = re::introspect_float((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "shoulderLength";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0xC00000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF97F58 = v20;
      float v21 = re::introspectionAllocator((re *)v20);
      float v23 = re::introspect_float((re *)1, v22);
      uint64_t v24 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v21 + 32))(v21, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "shoulderAngle";
      *(void *)(v24 + 16) = v23;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0x1000000005;
      *(_DWORD *)(v24 + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_26AF97F60 = v24;
      float v25 = re::introspectionAllocator((re *)v24);
      float v27 = re::introspect_float((re *)1, v26);
      uint64_t v28 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 72, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *(void *)(v28 + 8) = "gamma";
      *(void *)(v28 + 16) = v27;
      *(void *)(v28 + 24) = 0;
      *(void *)(v28 + 32) = 0x1400000006;
      *(_DWORD *)(v28 + 40) = 0;
      *(void *)(v28 + 48) = 0;
      *(void *)(v28 + 56) = 0;
      *(_DWORD *)(v28 + 64) = 0;
      qword_26AF97F68 = v28;
      float v29 = re::introspectionAllocator((re *)v28);
      uint64_t v31 = re::introspect_float((re *)1, v30);
      uint64_t v32 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 72, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *(void *)(v32 + 8) = "exposure";
      *(void *)(v32 + 16) = v31;
      *(void *)(v32 + 24) = 0;
      *(void *)(v32 + 32) = 0x1C00000008;
      *(_DWORD *)(v32 + 40) = 0;
      *(void *)(v32 + 48) = 0;
      *(void *)(v32 + 56) = 0;
      *(_DWORD *)(v32 + 64) = 0;
      qword_26AF97F70 = v32;
      uint64_t v33 = re::introspectionAllocator((re *)v32);
      float v35 = re::introspect_BOOL((re *)1, v34);
      uint64_t v36 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 72, 8);
      *(_DWORD *)uint64_t v36 = 1;
      *(void *)(v36 + 8) = "enableExposureCompensation";
      *(void *)(v36 + 16) = v35;
      *(void *)(v36 + 24) = 0;
      *(void *)(v36 + 32) = 0x2000000009;
      *(_DWORD *)(v36 + 40) = 0;
      *(void *)(v36 + 48) = 0;
      *(void *)(v36 + 56) = 0;
      *(_DWORD *)(v36 + 64) = 0;
      qword_26AF97F78 = v36;
      float v37 = re::introspectionAllocator((re *)v36);
      float v39 = re::introspect_float((re *)1, v38);
      uint64_t v40 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v37 + 32))(v37, 72, 8);
      *(_DWORD *)uint64_t v40 = 1;
      *(void *)(v40 + 8) = "exposureCompensationInputScalar";
      *(void *)(v40 + 16) = v39;
      *(void *)(v40 + 24) = 0;
      *(void *)(v40 + 32) = 0x240000000ALL;
      *(_DWORD *)(v40 + 40) = 0;
      *(void *)(v40 + 48) = 0;
      *(void *)(v40 + 56) = 0;
      *(_DWORD *)(v40 + 64) = 0;
      qword_26AF97F80 = v40;
      float v41 = re::introspectionAllocator((re *)v40);
      float v43 = re::introspect_float((re *)1, v42);
      uint64_t v44 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v41 + 32))(v41, 72, 8);
      *(_DWORD *)uint64_t v44 = 1;
      *(void *)(v44 + 8) = "exposureCompensationTargetScalar";
      *(void *)(v44 + 16) = v43;
      *(void *)(v44 + 24) = 0;
      *(void *)(v44 + 32) = 0x280000000BLL;
      *(_DWORD *)(v44 + 40) = 0;
      *(void *)(v44 + 48) = 0;
      *(void *)(v44 + 56) = 0;
      *(_DWORD *)(v44 + 64) = 0;
      qword_26AF97F88 = v44;
      __cxa_guard_release(&qword_26AF97F38);
    }
  }
  *((void *)this + 2) = 0x3C00000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 10;
  *((void *)this + 8) = &qword_26AF97F40;
  *((void *)this + 9) = re::internal::defaultConstruct<re::TonemapUserParameters>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::TonemapUserParameters>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::TonemapUserParameters>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::TonemapUserParameters>;
  re::IntrospectionRegistry::add(this, v3);
  long long v45 = v47;
}

double re::internal::defaultConstruct<re::TonemapUserParameters>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = xmmword_23436C470;
  *(_OWORD *)(a3 + 16) = xmmword_2343679C0;
  *(unsigned char *)(a3 + 32) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(a3 + 36) = result;
  *(unsigned char *)(a3 + 44) = 0;
  *(void *)(a3 + 48) = 0x3F80000000000000;
  *(unsigned char *)(a3 + 56) = 0;
  return result;
}

double re::internal::defaultConstructV2<re::TonemapUserParameters>(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_23436C470;
  *(_OWORD *)(a1 + 16) = xmmword_2343679C0;
  *(unsigned char *)(a1 + 32) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(a1 + 36) = result;
  *(unsigned char *)(a1 + 44) = 0;
  *(void *)(a1 + 48) = 0x3F80000000000000;
  *(unsigned char *)(a1 + 56) = 0;
  return result;
}

uint64_t re::introspect_TonemapUserParameters(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"TonemapUserParameters", (uint64_t (*)(re::internal *))re::allocInfo_TonemapUserParameters, (re::IntrospectionBase *(*)(void))re::initInfo_TonemapUserParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::TonemapUserParameters>, this);
}

uint64_t re::RenderGraphBuilder::RenderGraphBuilder(uint64_t a1, re::RenderGraphResourceDescriptions *a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v7 = a1 + 8;
  uint64_t v8 = a1 + 48;
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v9 = a1 + 88;
  uint64_t v10 = a1 + 128;
  *(_OWORD *)(a1 + 56) = 0u;
  uint64_t v11 = a1 + 168;
  *(_DWORD *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_DWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 188) = 0u;
  *(void *)(a1 + 204) = 0x7FFFFFFFLL;
  *(void *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  re::RenderGraphResourceDescriptions::swap((re::RenderGraphResourceDescriptions *)a1, a2);
  *(void *)(a1 + 296) = v7;
  *(void *)(a1 + 304) = v8;
  *(void *)(a1 + 312) = v9;
  *(void *)(a1 + 320) = v10;
  *(void *)(a1 + 328) = v11;
  *(void *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_DWORD *)(a1 + 360) = 0;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 396) = 0u;
  *(void *)(a1 + 412) = 0x7FFFFFFFLL;
  *(void *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_DWORD *)(a1 + 448) = 0;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_DWORD *)(a1 + 488) = 0;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_DWORD *)(a1 + 528) = 0;
  *(_DWORD *)(a1 + 568) = 0;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_DWORD *)(a1 + 592) = 0;
  *(_DWORD *)(a1 + 607) = 0;
  *(void *)(a1 + 600) = 0;
  *(void *)(a1 + 648) = 0;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_DWORD *)(a1 + 640) = 0;
  *(void *)(a1 + 632) = 0;
  uint64_t v12 = *(void *)(a3 + 8);
  *(void *)(a1 + 616) = *(void *)a3;
  *(void *)(a1 + 624) = v12;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  uint64_t v13 = *(void *)(a1 + 632);
  *(void *)(a1 + 632) = *(void *)(a3 + 16);
  *(void *)(a3 + 16) = v13;
  uint64_t v14 = *(void *)(a1 + 648);
  *(void *)(a1 + 648) = *(void *)(a3 + 32);
  *(void *)(a3 + 32) = v14;
  ++*(_DWORD *)(a3 + 24);
  ++*(_DWORD *)(a1 + 640);
  *(void *)(a1 + 656) = a4;
  return a1;
}

void re::RenderGraphBuilder::~RenderGraphBuilder(re::RenderGraphBuilder *this)
{
  re::DynamicArray<re::RenderGraphScopeOutput>::deinit((uint64_t)this + 616);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 544);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 504);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 464);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 424);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 47);
  re::DynamicArray<re::RenderGraphResourceSetup>::deinit((uint64_t)this + 336);
  re::RenderGraphResourceDescriptions::~RenderGraphResourceDescriptions(this);
}

uint64_t re::RenderGraphBuilder::createCompiledGraph(re *a1, uint64_t a2)
{
  unsigned int v4 = re::globalAllocators(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[2] + 32))(v4[2], 832, 8);
  uint64_t v6 = *((void *)a1 + 82);
  return re::RenderGraphCompiled::RenderGraphCompiled(v5, a1, (uint64_t)a1 + 616, (uint64_t)a1 + 336, a2, v6);
}

void re::RenderGraphBuilder::read(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  int v6 = *(_DWORD *)(a2 + 8);
  if (v6 == -1)
  {
    if (*(unsigned char *)(a3 + 4)) {
      return;
    }
    goto LABEL_10;
  }
  int v7 = *(_DWORD *)(a2 + 12);
  if (v7 != -1 || *(unsigned char *)(a3 + 4) == 0)
  {
    if (v7 != -1)
    {
LABEL_12:
      int v12 = *(_DWORD *)(a3 + 8);
      int v11 = *(_DWORD *)(a3 + 12);
      int v14 = *(_DWORD *)a3;
      int v15 = v11;
      long long v16 = xmmword_23435FBB0;
      __int16 v17 = 0;
      int v18 = 0;
      int v19 = 0;
      int v20 = v12;
      char v21 = 0;
      int v22 = v6;
      re::DynamicArray<re::RigTransform>::add((_anonymous_namespace_ *)(a1 + 464), (uint64_t)&v14);
      if (*(_DWORD *)(a3 + 12) != 12)
      {
        uint64_t v13 = re::RenderGraphCompiled::targetDescription(a1, a2);
        *(_DWORD *)(v13 + 64) |= 1u;
      }
      return;
    }
LABEL_10:
    uint64_t v9 = *re::graphicsLogObjects((re *)a1);
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    int v6 = *(_DWORD *)(a2 + 8);
    if (v10)
    {
      int v14 = 67109120;
      int v15 = v6;
      _os_log_error_impl(&dword_233120000, v9, OS_LOG_TYPE_ERROR, "Attempting to read from an invalid non-optional target (%u).", (uint8_t *)&v14, 8u);
      int v6 = *(_DWORD *)(a2 + 8);
    }
    goto LABEL_12;
  }
}

uint64_t re::RenderGraphBuilder::write(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (void *)result;
  uint64_t v20 = *MEMORY[0x263EF8340];
  int v6 = *(_DWORD *)(a2 + 8);
  if (v6 == -1)
  {
    if (*(unsigned char *)(a3 + 33)) {
      return result;
    }
    goto LABEL_10;
  }
  int v7 = *(_DWORD *)(a2 + 12);
  if (v7 != -1 || *(unsigned char *)(a3 + 33) == 0)
  {
    if (v7 != -1)
    {
LABEL_12:
      v13[0] = *(void *)a3;
      long long v14 = xmmword_23435FBB0;
      __int16 v15 = *(_WORD *)(a3 + 32);
      uint64_t v16 = *(void *)(a3 + 36);
      int v17 = 2;
      char v18 = 0;
      int v19 = v6;
      re::DynamicArray<re::RigTransform>::add((_anonymous_namespace_ *)(v5 + 58), (uint64_t)v13);
      *(_OWORD *)(v5[62] + (v5[60] << 6) - 48) = *(_OWORD *)(a3 + 16);
      double result = re::RenderGraphCompiled::targetDescription((uint64_t)v5, a2);
      if (*(_DWORD *)(a3 + 4) == 5) {
        int v11 = 2;
      }
      else {
        int v11 = 4;
      }
      *(_DWORD *)(result + 64) |= v11;
      uint64_t v12 = *(void *)(result + 88);
      if (v12 != -1) {
        v5[73] |= v12;
      }
      return result;
    }
LABEL_10:
    uint64_t v9 = *re::graphicsLogObjects((re *)result);
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    int v6 = *(_DWORD *)(a2 + 8);
    if (v10)
    {
      LODWORD(v13[0]) = 67109120;
      HIDWORD(v13[0]) = v6;
      _os_log_error_impl(&dword_233120000, v9, OS_LOG_TYPE_ERROR, "Attempting to write to an invalid non-optional target (%u).", (uint8_t *)v13, 8u);
      int v6 = *(_DWORD *)(a2 + 8);
    }
    goto LABEL_12;
  }
  return result;
}

double re::RenderGraphBuilder::read(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  int v5 = *(_DWORD *)(a2 + 8);
  if (v5 == -1)
  {
    if (*(unsigned char *)(a3 + 4)) {
      return result;
    }
    goto LABEL_10;
  }
  int v6 = *(_DWORD *)(a2 + 12);
  if (v6 != -1 || *(unsigned char *)(a3 + 4) == 0)
  {
    if (v6 != -1)
    {
LABEL_12:
      v11[0] = 0;
      long long v12 = xmmword_23435FBB0;
      __int16 v13 = 0;
      uint64_t v14 = 0;
      int v15 = 2;
      char v16 = 0;
      int v17 = v5;
      *(void *)&double result = re::DynamicArray<re::RigTransform>::add((_anonymous_namespace_ *)(a1 + 464), (uint64_t)v11).n128_u64[0];
      return result;
    }
LABEL_10:
    uint64_t v8 = *re::graphicsLogObjects((re *)a1);
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    int v5 = *(_DWORD *)(a2 + 8);
    if (v9)
    {
      LODWORD(v11[0]) = 67109120;
      HIDWORD(v11[0]) = v5;
      _os_log_error_impl(&dword_233120000, v8, OS_LOG_TYPE_ERROR, "Attempting to read from an invalid non-optional buffer (%u).", (uint8_t *)v11, 8u);
      int v5 = *(_DWORD *)(a2 + 8);
    }
    goto LABEL_12;
  }
  return result;
}

void re::RenderGraphBuilder::write(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  int v6 = *(_DWORD *)(a2 + 8);
  if (v6 == -1)
  {
    if (*(unsigned char *)(a3 + 33)) {
      return;
    }
LABEL_10:
    BOOL v9 = *re::graphicsLogObjects((re *)a1);
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    int v6 = *(_DWORD *)(a2 + 8);
    if (v10)
    {
      *(_DWORD *)simd_float3x3 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v6;
      _os_log_error_impl(&dword_233120000, v9, OS_LOG_TYPE_ERROR, "Attempting to write to an invalid non-optional buffer (%u).", buf, 8u);
      int v6 = *(_DWORD *)(a2 + 8);
    }
    goto LABEL_12;
  }
  int v7 = *(_DWORD *)(a2 + 12);
  if (v7 == -1 && *(unsigned char *)(a3 + 33) != 0) {
    return;
  }
  if (v7 == -1) {
    goto LABEL_10;
  }
LABEL_12:
  int v11 = *(_DWORD *)(a3 + 4);
  if (v11 == 1) {
    int v11 = 11;
  }
  *(_DWORD *)simd_float3x3 buf = *(_DWORD *)a3;
  *(_DWORD *)&uint8_t buf[4] = v11;
  long long v16 = xmmword_23435FBB0;
  LOWORD(v17) = 0;
  *(void *)((char *)&v17 + 4) = 0;
  HIDWORD(v17) = 2;
  LOBYTE(v18) = 0;
  DWORD1(v18) = v6;
  re::DynamicArray<re::RigTransform>::add((_anonymous_namespace_ *)(a1 + 58), (uint64_t)buf);
  uint64_t v12 = a1[39];
  unint64_t v13 = *(unsigned int *)(a2 + 12);
  if (*(void *)(v12 + 16) <= v13)
  {
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    *(_OWORD *)simd_float3x3 buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v14 = *(void *)(*(void *)(v12 + 32) + 48 * v13 + 32);
  if (v14 != -1) {
    a1[73] |= v14;
  }
}

uint64_t re::RenderGraphBuilder::handleAutoMsaaTargets(re::RenderGraphBuilder *this)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t v23 = 0;
  v20[1] = 0;
  uint64_t v21 = 0;
  v20[0] = 0;
  int v22 = 0;
  re::DynamicArray<re::RigTransform>::setCapacity(v20, 3uLL);
  uint64_t v2 = *((void *)this + 60);
  if (v2)
  {
    uint64_t v3 = v2 << 6;
    unsigned int v4 = (_DWORD *)(*((void *)this + 62) + 52);
    while (1)
    {
      unint64_t v5 = *v4;
      uint64_t v6 = *((void *)this + 37);
      unint64_t v7 = *(void *)(v6 + 16);
      if (v7 <= v5) {
        break;
      }
      uint64_t v8 = *(void *)(v6 + 32);
      if (!*(_DWORD *)(v8 + 48 * v5))
      {
        uint64_t v9 = *((void *)this + 38);
        unint64_t v5 = *(unsigned int *)(v8 + 48 * v5 + 28);
        unint64_t v7 = *(void *)(v9 + 16);
        if (v7 <= v5) {
          goto LABEL_19;
        }
        uint64_t v10 = *(void *)(v9 + 32) + 112 * v5;
        int v12 = *(_DWORD *)(v10 + 80);
        int v11 = (_DWORD *)(v10 + 80);
        if (v12 != -1)
        {
          long long v13 = *(_OWORD *)(v4 - 1);
          long long v15 = *(_OWORD *)(v4 - 13);
          long long v14 = *(_OWORD *)(v4 - 9);
          long long v35 = *(_OWORD *)(v4 - 5);
          long long v36 = v13;
          long long v33 = v15;
          long long v34 = v14;
          if ((DWORD1(v15) - 1) <= 2)
          {
            DWORD1(v33) = DWORD1(v15) + 5;
            re::DynamicArray<re::RigTransform>::add((_anonymous_namespace_ *)v20, (uint64_t)&v33);
            *unsigned int v4 = *v11;
          }
        }
      }
      v4 += 16;
      v3 -= 64;
      if (!v3) {
        goto LABEL_11;
      }
    }
    uint64_t v24 = 0;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v25 = 136315906;
    float v26 = "operator[]";
    __int16 v27 = 1024;
    int v28 = 789;
    __int16 v29 = 2048;
    unint64_t v30 = v5;
    __int16 v31 = 2048;
    unint64_t v32 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_19:
    uint64_t v24 = 0;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v25 = 136315906;
    float v26 = "operator[]";
    __int16 v27 = 1024;
    int v28 = 789;
    __int16 v29 = 2048;
    unint64_t v30 = v5;
    __int16 v31 = 2048;
    unint64_t v32 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_11:
  if (v21)
  {
    long long v16 = (re::RenderGraphBuilder *)((char *)this + 464);
    uint64_t v17 = v23;
    uint64_t v18 = v21 << 6;
    do
    {
      re::DynamicArray<re::RigTransform>::add(v16, v17);
      v17 += 64;
      v18 -= 64;
    }
    while (v18);
  }
  uint64_t result = v20[0];
  if (v20[0])
  {
    if (v23) {
      return (*(uint64_t (**)(void))(*(void *)v20[0] + 40))();
    }
  }
  return result;
}

uint64_t re::RenderGraphBuilder::handleProgrammableBlendingTargets(re::RenderGraphBuilder *this)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v18 = 0;
  v15[1] = 0;
  uint64_t v16 = 0;
  v15[0] = 0;
  int v17 = 0;
  re::DynamicArray<re::RigTransform>::setCapacity(v15, 8uLL);
  uint64_t v2 = *((void *)this + 60);
  if (v2)
  {
    uint64_t v3 = (long long *)*((void *)this + 62);
    uint64_t v4 = v2 << 6;
    do
    {
      uint64_t v5 = *((void *)this + 37);
      unint64_t v6 = *((unsigned int *)v3 + 13);
      unint64_t v7 = *(void *)(v5 + 16);
      if (v7 <= v6)
      {
        uint64_t v19 = 0;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v28 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v20 = 136315906;
        uint64_t v21 = "operator[]";
        __int16 v22 = 1024;
        int v23 = 789;
        __int16 v24 = 2048;
        unint64_t v25 = v6;
        __int16 v26 = 2048;
        unint64_t v27 = v7;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (!*(_DWORD *)(*(void *)(v5 + 32) + 48 * v6)
        && *((_DWORD *)v3 + 1) == 1
        && ((*((unsigned __int8 *)this + 609) >> *(_DWORD *)v3) & 1) != 0)
      {
        long long v9 = v3[1];
        long long v8 = v3[2];
        long long v10 = *v3;
        *(void *)&long long v31 = *((void *)v3 + 6);
        long long v29 = v9;
        long long v30 = v8;
        long long v28 = v10;
        DWORD1(v28) = 10;
        re::DynamicArray<re::RigTransform>::add((_anonymous_namespace_ *)v15, (uint64_t)&v28);
      }
      v3 += 4;
      v4 -= 64;
    }
    while (v4);
  }
  if (v16)
  {
    int v11 = (re::RenderGraphBuilder *)((char *)this + 464);
    uint64_t v12 = v18;
    uint64_t v13 = v16 << 6;
    do
    {
      re::DynamicArray<re::RigTransform>::add(v11, v12);
      v12 += 64;
      v13 -= 64;
    }
    while (v13);
  }
  uint64_t result = v15[0];
  if (v15[0])
  {
    if (v18) {
      return (*(uint64_t (**)(void))(*(void *)v15[0] + 40))();
    }
  }
  return result;
}

void *re::RenderGraphBuilder::handleForceResolve(void *this)
{
  uint64_t v1 = this[60];
  if (v1)
  {
    uint64_t v2 = this[37];
    uint64_t v3 = v1 << 6;
    unint64_t v4 = *(void *)(v2 + 16);
    for (unint64_t i = (unsigned int *)(this[62] + 52); ; i += 16)
    {
      unint64_t v6 = *i;
      if (v4 <= v6) {
        break;
      }
      uint64_t v7 = *(void *)(v2 + 32);
      if (!*(_DWORD *)(v7 + 48 * v6))
      {
        uint64_t v8 = this[38];
        unint64_t v9 = *(unsigned int *)(v7 + 48 * v6 + 28);
        if (*(void *)(v8 + 16) <= v9) {
          goto LABEL_13;
        }
        uint64_t v10 = *(void *)(v8 + 32) + 112 * v9;
        int v12 = *(_DWORD *)(v10 + 80);
        int v11 = (_DWORD *)(v10 + 80);
        if (v12 != -1 && *(i - 12) - 6 <= 2) {
          *int v11 = -1;
        }
      }
      v3 -= 64;
      if (!v3) {
        return this;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return this;
}

double re::RenderGraphBuilder::setVisibilityResultsBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a2 + 8);
  if (v3 == -1 || *(_DWORD *)(a2 + 12) == -1)
  {
    unint64_t v6 = *re::graphicsLogObjects((re *)a1);
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    int v3 = *(_DWORD *)(a2 + 8);
    if (v7)
    {
      LODWORD(v9[0]) = 67109120;
      HIDWORD(v9[0]) = v3;
      _os_log_error_impl(&dword_233120000, v6, OS_LOG_TYPE_ERROR, "Attempting to use an invalid buffer for visibility results (%u).", (uint8_t *)v9, 8u);
      int v3 = *(_DWORD *)(a2 + 8);
    }
  }
  v9[0] = 0x900000000;
  long long v10 = xmmword_23435FBB0;
  __int16 v11 = 0;
  int v12 = 0;
  int v13 = 0;
  int v14 = 2;
  char v15 = 0;
  int v16 = v3;
  *(void *)&double result = re::DynamicArray<re::RigTransform>::add((_anonymous_namespace_ *)(a1 + 464), (uint64_t)v9).n128_u64[0];
  return result;
}

void *re::RenderGraphBuilder::startNode(re::RenderGraphBuilder *this, re::RenderGraphNodeBase *a2)
{
  unint64_t v6 = a2;
  int v3 = (char *)this + 424;
  *((void *)this + 55) = 0;
  ++*((_DWORD *)this + 112);
  *((void *)this + 60) = 0;
  ++*((_DWORD *)this + 122);
  *((void *)this + 65) = 0;
  ++*((_DWORD *)this + 132);
  *((void *)this + 70) = 0;
  ++*((_DWORD *)this + 142);
  *((void *)this + 73) = 0;
  *((_DWORD *)this + 148) = 0;
  *((void *)this + 75) = 0;
  *(_DWORD *)(v3 + 183) = 0;
  re::DynamicArray<re::TransitionCondition *>::add(v3, &v6);
  if ((*(uint64_t (**)(re::RenderGraphNodeBase *))(*(void *)v6 + 16))(v6))
  {
    uint64_t v5 = 0;
    re::DynamicArray<unsigned long>::add((void *)this + 63, &v5);
  }
  double result = (void *)(*(uint64_t (**)(re::RenderGraphNodeBase *))(*(void *)v6 + 24))(v6);
  if (result)
  {
    uint64_t v5 = 0;
    return re::DynamicArray<unsigned long>::add((void *)this + 68, &v5);
  }
  return result;
}

void re::RenderGraphBuilder::finishNode(re::RenderGraphBuilder *this, re::RenderGraphNodeBase *a2)
{
  *((void *)this + 55) = 0;
  ++*((_DWORD *)this + 112);
  *((void *)this + 60) = 0;
  ++*((_DWORD *)this + 122);
  *((void *)this + 65) = 0;
  ++*((_DWORD *)this + 132);
  *((void *)this + 70) = 0;
  ++*((_DWORD *)this + 142);
  *((void *)this + 73) = 0;
  *((_DWORD *)this + 148) = 0;
  *((void *)this + 75) = 0;
  *(_DWORD *)((char *)this + 607) = 0;
}

__n128 re::DynamicArray<re::RenderGraphResourceSetup>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::RenderGraphResourceSetup>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 192 * v4;
  re::DynamicArray<char const*>::DynamicArray(v5, (uint64_t *)a2);
  re::DynamicArray<re::RenderGraphResourceOperation>::DynamicArray(v5 + 40, (uint64_t *)(a2 + 40));
  re::DynamicArray<unsigned long>::DynamicArray(v5 + 80, (uint64_t *)(a2 + 80));
  re::DynamicArray<unsigned long>::DynamicArray(v5 + 120, (uint64_t *)(a2 + 120));
  __n128 result = *(__n128 *)(a2 + 160);
  *(_OWORD *)(v5 + 171) = *(_OWORD *)(a2 + 171);
  *(__n128 *)(v5 + 160) = result;
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

__n128 re::RenderGraphBuilder::resourceFromIndex@<Q0>(re::RenderGraphBuilder *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *((void *)this + 37);
  if (*(void *)(v4 + 16) <= (unint64_t)a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v5 = *(void *)(v4 + 32) + 48 * a2;
  *(_DWORD *)a3 = *(_DWORD *)v5;
  re::StringID::StringID((re::StringID *)(a3 + 8), (const StringID *)(v5 + 8));
  __n128 result = *(__n128 *)(v5 + 24);
  *(void *)(a3 + 40) = *(void *)(v5 + 40);
  *(__n128 *)(a3 + 24) = result;
  return result;
}

uint64_t re::RenderGraphCompiled::RenderGraphCompiled(uint64_t a1, re::RenderGraphResourceDescriptions *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v11 = a1 + 8;
  uint64_t v12 = a1 + 48;
  *(_OWORD *)(a1 + 56) = 0u;
  uint64_t v13 = a1 + 88;
  uint64_t v14 = a1 + 128;
  *(_DWORD *)(a1 + 72) = 0;
  uint64_t v15 = a1 + 168;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_DWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 188) = 0u;
  *(void *)(a1 + 204) = 0x7FFFFFFFLL;
  *(_DWORD *)(a1 + 240) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  re::RenderGraphResourceDescriptions::swap((re::RenderGraphResourceDescriptions *)a1, a2);
  *(void *)(a1 + 296) = v11;
  *(void *)(a1 + 304) = v12;
  *(void *)(a1 + 312) = v13;
  *(void *)(a1 + 320) = v14;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 328) = v15;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 360) = 0;
  uint64_t v16 = *(void *)(a4 + 8);
  *(void *)(a1 + 336) = *(void *)a4;
  *(void *)(a1 + 344) = v16;
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  uint64_t v17 = *(void *)(a1 + 352);
  *(void *)(a1 + 352) = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = v17;
  uint64_t v18 = *(void *)(a1 + 368);
  *(void *)(a1 + 368) = *(void *)(a4 + 32);
  *(void *)(a4 + 32) = v18;
  ++*(_DWORD *)(a4 + 24);
  ++*(_DWORD *)(a1 + 360);
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 376) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  *(void *)(a1 + 608) = 0;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + re::DynamicArray<re::RenderGraphResourceSetup>::add((re::RenderGraphBuilder *)((char *)this + 336), (uint64_t)this + 424) = 0u;
  *(_DWORD *)(a1 + 440) = 0;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 480) = 0;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_DWORD *)(a1 + 520) = 0;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_DWORD *)(a1 + 560) = 0;
  *(_DWORD *)(a1 + 600) = 0;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  uint64_t v19 = *(void *)(a6 + 8);
  *(void *)(a1 + 576) = *(void *)a6;
  *(void *)(a1 + 584) = v19;
  *(void *)a6 = 0;
  *(void *)(a6 + 8) = 0;
  uint64_t v20 = *(void *)(a1 + 592);
  *(void *)(a1 + 592) = *(void *)(a6 + 16);
  *(void *)(a6 + 16) = v20;
  uint64_t v21 = *(void *)(a1 + 608);
  *(void *)(a1 + 608) = *(void *)(a6 + 32);
  *(void *)(a6 + 32) = v21;
  ++*(_DWORD *)(a6 + 24);
  ++*(_DWORD *)(a1 + 600);
  *(void *)(a1 + 648) = 0;
  *(void *)(a1 + 616) = 0;
  *(void *)(a1 + 632) = 0;
  *(void *)(a1 + 624) = 0;
  *(_DWORD *)(a1 + 640) = 0;
  uint64_t v22 = *(void *)(a5 + 8);
  *(void *)(a1 + 616) = *(void *)a5;
  *(void *)(a1 + 624) = v22;
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  uint64_t v23 = *(void *)(a1 + 632);
  *(void *)(a1 + 632) = *(void *)(a5 + 16);
  *(void *)(a5 + 16) = v23;
  uint64_t v24 = *(void *)(a1 + 648);
  *(void *)(a1 + 648) = *(void *)(a5 + 32);
  *(void *)(a5 + 32) = v24;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(a1 + 640);
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_DWORD *)(a1 + 688) = 0;
  *(void *)(a1 + 692) = 0x7FFFFFFFLL;
  *(void *)(a1 + 704) = 0;
  *(void *)(a1 + 720) = 0;
  *(void *)(a1 + 712) = 0;
  *(_DWORD *)(a1 + 728) = 0;
  *(void *)(a1 + 776) = 0;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_DWORD *)(a1 + 768) = 0;
  uint64_t v25 = *(void *)(a3 + 8);
  *(void *)(a1 + 744) = *(void *)a3;
  *(void *)(a1 + 752) = v25;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  uint64_t v26 = *(void *)(a1 + 760);
  *(void *)(a1 + 760) = *(void *)(a3 + 16);
  *(void *)(a3 + 16) = v26;
  uint64_t v27 = *(void *)(a1 + 776);
  *(void *)(a1 + 776) = *(void *)(a3 + 32);
  *(void *)(a3 + 32) = v27;
  ++*(_DWORD *)(a3 + 24);
  ++*(_DWORD *)(a1 + 768);
  *(void *)(a1 + 784) = 0;
  *(void *)(a1 + 800) = 0;
  *(void *)(a1 + 792) = 0;
  *(_DWORD *)(a1 + 808) = 0;
  *(void *)(a1 + 824) = 0;
  *(void *)(a1 + 816) = 0;
  return a1;
}

void *re::DynamicArray<re::RenderGraphResourceSetup>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::RenderGraphResourceSetup>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::RenderGraphResourceSetup>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::DynamicArray<re::RenderGraphResourceSetup>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      __n128 result = (void *)*result;
      if (!*v5)
      {
        __n128 result = (void *)re::DynamicArray<re::RenderGraphResourceSetup>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xC0uLL))
        {
          uint64_t v2 = 192 * a2;
          __n128 result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 192 * a2, 8);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 192, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        __n128 result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        unint64_t v10 = 0;
        uint64_t v11 = v8 + 192 * v9;
        do
        {
          uint64_t v12 = v8 + v10;
          uint64_t v13 = &v7[v10 / 8];
          v13[4] = 0;
          v13[1] = 0;
          void v13[2] = 0;
          void *v13 = 0;
          *((_DWORD *)v13 + 6) = 0;
          uint64_t v14 = *(void *)(v8 + v10 + 8);
          void *v13 = *(void *)(v8 + v10);
          v13[1] = v14;
          *(void *)uint64_t v12 = 0;
          *(void *)(v12 + 8) = 0;
          uint64_t v15 = v7[v10 / 8 + 2];
          void v13[2] = *(void *)(v8 + v10 + 16);
          *(void *)(v12 + 16) = v15;
          uint64_t v16 = v7[v10 / 8 + 4];
          v13[4] = *(void *)(v8 + v10 + 32);
          *(void *)(v12 + 32) = v16;
          *(_DWORD *)(v12 + 24) = *(_DWORD *)(v8 + v10 + 24) + 1;
          LODWORD(v16) = LODWORD(v7[v10 / 8 + 3]) + 1;
          v13[9] = 0;
          v13[6] = 0;
          v13[7] = 0;
          v13[5] = 0;
          *((_DWORD *)v13 + 16) = 0;
          uint64_t v17 = *(void *)(v8 + v10 + 40);
          *((_DWORD *)v13 + 6) = v16;
          uint64_t v18 = *(void *)(v8 + v10 + 48);
          v13[5] = v17;
          *(void *)(v8 + v10 + 40) = 0;
          v13[6] = v18;
          *(void *)(v12 + 48) = 0;
          uint64_t v19 = v7[v10 / 8 + 7];
          v13[7] = *(void *)(v8 + v10 + 56);
          *(void *)(v12 + 56) = v19;
          uint64_t v20 = v7[v10 / 8 + 9];
          v13[9] = *(void *)(v8 + v10 + 72);
          *(void *)(v12 + 72) = v20;
          *(_DWORD *)(v12 + 64) = *(_DWORD *)(v8 + v10 + 64) + 1;
          *((_DWORD *)v13 + 16) = LODWORD(v7[v10 / 8 + 8]) + 1;
          v13[14] = 0;
          v13[11] = 0;
          v13[12] = 0;
          v13[10] = 0;
          *((_DWORD *)v13 + 26) = 0;
          uint64_t v21 = *(void *)(v8 + v10 + 88);
          v13[10] = *(void *)(v8 + v10 + 80);
          *(void *)(v8 + v10 + 80) = 0;
          v13[11] = v21;
          *(void *)(v12 + 88) = 0;
          uint64_t v22 = v7[v10 / 8 + 12];
          v13[12] = *(void *)(v8 + v10 + 96);
          *(void *)(v12 + 96) = v22;
          uint64_t v23 = v7[v10 / 8 + 14];
          v13[14] = *(void *)(v8 + v10 + 112);
          *(void *)(v12 + 112) = v23;
          *(_DWORD *)(v12 + 104) = *(_DWORD *)(v8 + v10 + 104) + 1;
          LODWORD(v23) = LODWORD(v7[v10 / 8 + 13]) + 1;
          v13[19] = 0;
          v13[16] = 0;
          v13[17] = 0;
          v13[15] = 0;
          *((_DWORD *)v13 + 36) = 0;
          uint64_t v24 = (uint64_t *)(v8 + v10 + 120);
          uint64_t v25 = *v24;
          *((_DWORD *)v13 + 26) = v23;
          uint64_t v26 = *(void *)(v8 + v10 + 128);
          v13[15] = v25;
          *uint64_t v24 = 0;
          v13[16] = v26;
          *(void *)(v12 + 128) = 0;
          uint64_t v27 = v7[v10 / 8 + 17];
          v13[17] = *(void *)(v8 + v10 + 136);
          *(void *)(v12 + 136) = v27;
          uint64_t v28 = v7[v10 / 8 + 19];
          v13[19] = *(void *)(v8 + v10 + 152);
          *(void *)(v12 + 152) = v28;
          *(_DWORD *)(v12 + 144) = *(_DWORD *)(v8 + v10 + 144) + 1;
          *((_DWORD *)v13 + 36) = LODWORD(v7[v10 / 8 + 18]) + 1;
          long long v29 = *(_OWORD *)(v8 + v10 + 160);
          *(_OWORD *)((char *)v13 + 171) = *(_OWORD *)(v8 + v10 + 171);
          *((_OWORD *)v13 + 10) = v29;
          re::DynamicArray<unsigned long>::deinit((uint64_t)v24);
          re::DynamicArray<unsigned long>::deinit(v8 + v10 + 80);
          re::DynamicArray<unsigned long>::deinit(v8 + v10 + 40);
          re::DynamicArray<unsigned long>::deinit(v8 + v10);
          v10 += 192;
        }
        while (v12 + 192 != v11);
        uint64_t v8 = v5[4];
      }
      __n128 result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

re::OffsetsDeformerModelBuilder *re::OffsetsDeformerModelBuilder::OffsetsDeformerModelBuilder(re::OffsetsDeformerModelBuilder *this, re::Allocator *a2, uint64_t a3, unint64_t a4, DeformationModelData *a5)
{
  *(void *)this = a5;
  uint64_t v9 = (void *)re::DeformationModelData::create<re::OffsetsDeformer,re::OffsetsDeformerModel>((uint64_t)a5, (uint64_t)a2);
  re::FixedArray<re::StringID>::init<>(v9, (uint64_t)a2, a4);
  re::FixedArray<unsigned short>::init<unsigned short const&>(v9 + 3, (uint64_t)a2, a3, &re::OffsetsDeformerModel::kInvalidIndex);
  return this;
}

uint64_t re::DeformationModelData::create<re::OffsetsDeformer,re::OffsetsDeformerModel>(uint64_t a1, uint64_t a2)
{
  void v8[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 48, 8);
  *uint64_t v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v6[0] = &unk_26E713EC0;
  v6[1] = a2;
  v6[3] = v6;
  unint64_t v7 = v4;
  v8[3] = v8;
  v8[0] = &unk_26E713EC0;
  v8[1] = a2;
  std::unique_ptr<void,std::function<void ()(void *)>>::operator=[abi:nn180100]((uint64_t *)(a1 + 400), (uint64_t *)&v7);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v7);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](v6);
  return *(void *)(a1 + 400);
}

unint64_t *re::OffsetsDeformerModelBuilder::setEnvelopeBufferName(re::OffsetsDeformerModelBuilder *this, unint64_t a2, unint64_t a3, const re::StringID *a4)
{
  uint64_t v4 = *(void **)(*(void *)this + 400);
  if (v4[4] <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_7:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(_WORD *)(v4[5] + 2 * a2) = a3;
  if (v4[1] <= a3) {
    goto LABEL_7;
  }
  uint64_t v5 = (unint64_t *)(v4[2] + 16 * a3);
  return re::StringID::operator=(v5, (uint64_t *)a4);
}

uint64_t re::OffsetsDeformer::init(uint64_t this, re::RenderManager *a2)
{
  v39[1] = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(this + 8))
  {
    uint64_t v3 = this;
    *(unsigned char *)(this + 8) = 1;
    *(void *)(this + 16) = *((void *)a2 + 4);
    if (*((unsigned char *)a2 + 259))
    {
      char v4 = 0;
      uint64_t v5 = 0;
      __int16 v38 = 256;
      v39[0] = 0x100000000;
      do
      {
        char v6 = 0;
        uint64_t v7 = 0;
        char v16 = v4;
        uint64_t v8 = *((unsigned __int8 *)&v38 + v5);
        do
        {
          char v9 = v6;
          uint64_t v10 = *((unsigned int *)v39 + v7);
          v27[0] = 0;
          uint64_t v33 = 0;
          memset(v31, 0, sizeof(v31));
          int v32 = 0;
          char v34 = 0;
          char v35 = 0;
          uint64_t v36 = 0;
          char v37 = 0;
          memset(v22, 0, sizeof(v22));
          uint64_t v12 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v22, 0);
          uint64_t v24 = 0;
          uint64_t v25 = 0;
          uint64_t v26 = 0;
          re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v22, v8);
          int v23 = 53;
          uint64_t v13 = (_anonymous_namespace_ *)re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v31, (re::DynamicString *)v22);
          memset(v17, 0, sizeof(v17));
          uint64_t v14 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v17, 0);
          uint64_t v19 = 0;
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v17, v10);
          int v18 = 65565;
          re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v31, (re::DynamicString *)v17);
          ComputePipelineState = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)v27);
          NS::SharedPtr<MTL::Texture>::operator=((void **)(v3 + 16 * v8 + 8 * v10 + 24), ComputePipelineState);
          if (v19)
          {
            if (v20)
            {
              (*(void (**)(void))(*(void *)v19 + 40))();
              uint64_t v20 = 0;
              uint64_t v21 = 0;
            }
            uint64_t v19 = 0;
          }
          if (*(void *)&v17[0] && (BYTE8(v17[0]) & 1) != 0) {
            (*(void (**)(void))(**(void **)&v17[0] + 40))();
          }
          if (v24)
          {
            if (v25)
            {
              (*(void (**)(void))(*(void *)v24 + 40))();
              uint64_t v25 = 0;
              uint64_t v26 = 0;
            }
            uint64_t v24 = 0;
          }
          if (*(void *)&v22[0] && (BYTE8(v22[0]) & 1) != 0) {
            (*(void (**)(void))(**(void **)&v22[0] + 40))();
          }
          re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v31);
          this = v30[0];
          if (v30[0])
          {
            if (v30[1]) {
              this = (*(uint64_t (**)(void))(*(void *)v30[0] + 40))();
            }
            memset(v30, 0, sizeof(v30));
          }
          if (v27[0])
          {
            this = v28;
            if (v28)
            {
              if (v29) {
                this = (*(uint64_t (**)(void))(*(void *)v28 + 40))();
              }
            }
          }
          char v6 = 1;
          uint64_t v7 = 1;
        }
        while ((v9 & 1) == 0);
        char v4 = 1;
        uint64_t v5 = 1;
      }
      while ((v16 & 1) == 0);
      *(unsigned char *)(v3 + 9) = 1;
    }
  }
  return this;
}

double re::OffsetsDeformer::addDeformationInstance@<D0>(re::OffsetsDeformer *this@<X0>, unsigned char *a2@<X1>, uint64_t a3@<X8>)
{
  if (*a2)
  {
    BOOL v3 = 0;
  }
  else if (*((unsigned char *)this + 8))
  {
    BOOL v3 = *((unsigned char *)this + 9) != 0;
  }
  else
  {
    BOOL v3 = 1;
  }
  *(void *)a3 = 0xFFFFFFFFLL;
  *(void *)&double result = 3;
  *(_OWORD *)(a3 + 8) = xmmword_2343AE840;
  *(unsigned char *)(a3 + 24) = v3;
  *(void *)(a3 + 32) = -1;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  return result;
}

uint64_t re::OffsetsDeformer::allocateBuffers(uint64_t a1, re::FrameContext *a2, unsigned int a3, void *a4)
{
  uint64_t v108 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(*a4 + 48);
  if (v4)
  {
    uint64_t v6 = a1;
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    uint64_t v76 = *(void *)(*a4 + 48);
    while (1)
    {
      re::DeformationInstanceIterator::Instance::Instance(&v91, a4, v8);
      char v9 = *(long long **)(*(void *)(v93 + 352) + 104);
      if (!v9) {
        goto LABEL_54;
      }
      uint64_t v10 = (re::AttributeTable *)re::DeformationInstanceIterator::Instance::meshPart((uint64_t)&v91, *(void *)(v6 + 16));
      uint64_t v11 = v10;
      do
      {
        uint64_t v12 = v11;
        uint64_t v11 = (re::AttributeTable *)*((void *)v11 + 1);
      }
      while (v11 && !*((void *)v12 + 9));
      *(void *)&long long v103 = 0x2DB839E585F57D8ALL;
      uint64_t v13 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)v12 + 6, &v103);
      if (v13 == -1) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = (unsigned __int8 *)(*((void *)v12 + 7) + 16 * v13 + 8);
      }
      unsigned int v15 = *((_DWORD *)v10 + 132);
      BOOL v16 = v14 != 0 && v15 <= *((_DWORD *)v10 + 117);
      if (!v16) {
        unsigned int v15 = *((_DWORD *)v10 + 117);
      }
      if (12 * v15 != *((_DWORD *)v9 + 37)) {
        goto LABEL_54;
      }
      uint64_t v17 = v94;
      if (v16)
      {
        uint64_t v18 = re::AttributeTable::buffers(v10);
        unint64_t v20 = *v14;
        if (v19 <= v20) {
          goto LABEL_60;
        }
        uint64_t v21 = v18 + 16 * v20;
      }
      else
      {
        uint64_t v21 = 0;
      }
      uint64_t v22 = *(void **)(*(void *)(v93 + 344) + 400);
      uint64_t v82 = (uint64_t)v17;
      if (v22)
      {
        unint64_t v23 = *(unsigned __int16 *)(v93 + 392);
        unint64_t v24 = v22[4];
        if (v24 <= v23)
        {
          uint64_t v95 = 0;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v105 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int16 v96 = 136315906;
          *(void *)&v96[4] = "operator[]";
          __int16 v97 = 1024;
          int v98 = 476;
          __int16 v99 = 2048;
          unint64_t v100 = v23;
          __int16 v101 = 2048;
          unint64_t v102 = v24;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_59:
          uint64_t v95 = 0;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v105 = 0u;
          long long v103 = 0u;
          long long v104 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int16 v96 = 136315906;
          *(void *)&v96[4] = "operator[]";
          __int16 v97 = 1024;
          int v98 = 476;
          __int16 v99 = 2048;
          unint64_t v100 = v23;
          __int16 v101 = 2048;
          unint64_t v102 = v24;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_60:
          re::internal::assertLog((re::internal *)6, v19, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v20, v19);
          _os_crash();
          __break(1u);
LABEL_61:
          re::internal::assertLog((re::internal *)6, v31, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v32, v31);
          _os_crash();
          __break(1u);
LABEL_62:
          re::internal::assertLog((re::internal *)5, v31, "assertion failure: '%s' (%s:line %i) Invalid deformation execution mode: %u.", "!\"Unreachable code\"", "allocateBuffers", 222, a3);
          _os_crash();
          __break(1u);
        }
        unint64_t v23 = *(unsigned __int16 *)(v22[5] + 2 * v23);
        unint64_t v24 = v22[1];
        if (v24 <= v23) {
          goto LABEL_59;
        }
        re::StringID::StringID((re::StringID *)&v103, (const StringID *)(v22[2] + 16 * v23));
        uint64_t v25 = v10;
        do
        {
          uint64_t v26 = v25;
          uint64_t v25 = (re::AttributeTable *)*((void *)v25 + 1);
        }
        while (v25 && !*((void *)v26 + 9));
        *(void *)__int16 v96 = (unint64_t)v103 >> 1;
        uint64_t v27 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)v26 + 6, v96);
        if (v27 == -1) {
          uint64_t v28 = 0;
        }
        else {
          uint64_t v28 = (unsigned __int8 *)(*((void *)v26 + 7) + 16 * v27 + 8);
        }
        re::StringID::destroyString((re::StringID *)&v103);
        uint64_t v29 = re::DeformationVertexBufferState::inputVertexCount(v17, 1u);
        if (v28)
        {
          uint64_t v30 = re::AttributeTable::buffers(v10);
          unint64_t v32 = *v28;
          if (v31 <= v32) {
            goto LABEL_61;
          }
          uint64_t v33 = (uint64_t *)(v30 + 16 * v32);
          uint64_t v34 = v33[1];
          uint64_t v81 = *v33;
          unsigned int v35 = a3;
          goto LABEL_33;
        }
      }
      else
      {
        uint64_t v29 = re::DeformationVertexBufferState::inputVertexCount(v17, 1u);
      }
      re::FrameContext::perFrameAlloc(a2, 4 * v29, 4uLL, (uint64_t)&v103);
      uint64_t v36 = DWORD2(v103);
      uint64_t v37 = HIDWORD(v103);
      uint64_t v38 = v104;
      if (HIDWORD(v103) >= 4) {
        memset_pattern16((void *)(v103 + DWORD2(v103)), &unk_2343E10A0, HIDWORD(v103) & 0xFFFFFFFC);
      }
      uint64_t v34 = v36 | (v37 << 32);
      unsigned int v35 = a3;
      uint64_t v81 = v38;
      if (!a3)
      {
        unint64_t v39 = 12 * v29;
        uint64_t v40 = *((void *)v9 + 18);
        uint64_t v79 = *((void *)v9 + 17);
        int v80 = *((_DWORD *)v9 + 32);
LABEL_38:
        re::FrameContext::perFrameAlloc(a2, v39, 0x10uLL, (uint64_t)&v103);
        *(_WORD *)&v96[4] = 257;
        *(_DWORD *)__int16 v96 = 65548;
        LOBYTE(v97) = 30;
        *(_DWORD *)&v96[8] = 0;
        unsigned int v51 = (_anonymous_namespace_ *)re::DeformationVertexBufferState::setOutputBuffer(v82, 1u, 0, (uint64_t)&v103, (uint64_t)v96);
        uint64_t v54 = 0;
        uint64_t v52 = 0;
        uint64_t v53 = 0;
        goto LABEL_39;
      }
LABEL_33:
      unint64_t v39 = 12 * v29;
      uint64_t v40 = *((void *)v9 + 18);
      uint64_t v79 = *((void *)v9 + 17);
      int v80 = *((_DWORD *)v9 + 32);
      if (v35 != 1)
      {
        if (v35) {
          goto LABEL_62;
        }
        goto LABEL_38;
      }
      uint64_t v41 = v34;
      uint64_t v42 = v93;
      uint64_t v43 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](*v91 + 8, v92);
      uint64_t v44 = *(void **)(v42 + 360);
      uint64_t v45 = a4[2];
      __int16 v88 = 257;
      int v87 = 65548;
      char v90 = 30;
      int v89 = 0;
      unsigned int v46 = re::DeformationBufferAllocator::alloc(v44, v45, 1, (uint64_t)&v87, *(unsigned __int8 *)(v43 + 16), 12 * v29);
      long long v47 = *(re::DeformationBufferAllocator **)(v42 + 360);
      uint64_t v34 = v41;
      uint64_t v48 = re::DeformationBufferAllocator::allocationData(v47, *(unsigned __int8 *)(v43 + 16), v46);
      *(_WORD *)&v96[4] = 257;
      *(_DWORD *)__int16 v96 = 65548;
      LOBYTE(v97) = 30;
      *(_DWORD *)&v96[8] = 0;
      id v49 = objc_msgSend(*(id *)(v48 + 24), sel_contents);
      uint64_t v50 = *(void *)(v48 + 24);
      *(void *)&long long v103 = v49;
      *((void *)&v103 + 1) = *(void *)(v48 + 32);
      *(void *)&long long v104 = v50;
      re::DeformationVertexBufferState::setOutputBuffer(v82, 1u, 1, (uint64_t)&v103, (uint64_t)v96);
      long long v83 = *v9;
      long long v74 = v9[2];
      long long v75 = v9[1];
      long long v72 = v9[4];
      long long v73 = v9[3];
      long long v70 = v9[6];
      long long v71 = v9[5];
      long long v69 = v9[7];
      re::FrameContext::perFrameAlloc(a2, 0x90uLL, 0x10uLL, (uint64_t)&v103);
      uint64_t v53 = *((void *)&v103 + 1);
      uint64_t v52 = v103;
      uint64_t v54 = v104;
      uint64_t v55 = v103 + DWORD2(v103);
      *(_OWORD *)uint64_t v55 = v83;
      *(_OWORD *)(v55 + 16) = v75;
      *(_OWORD *)(v55 + 32) = v74;
      *(_OWORD *)(v55 + 48) = v73;
      *(_OWORD *)(v55 + 64) = v72;
      *(_OWORD *)(v55 + 80) = v71;
      *(_OWORD *)(v55 + 96) = v70;
      *(_OWORD *)(v55 + 112) = v69;
      *(_DWORD *)(v55 + 128) = v29;
LABEL_39:
      if (!v7)
      {
        uint64_t v84 = v53;
        uint64_t v7 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(**((void **)a2 + 3) + 32))(*((void **)a2 + 3), 40, 8);
        unsigned int v56 = (void *)*((void *)a2 + 3);
        unint64_t v57 = *(void *)(*a4 + 48);
        *(void *)(v7 + 32) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(void *)(v7 + 8) = 0;
        *(void *)(v7 + 16) = 0;
        *(void *)uint64_t v7 = v56;
        unsigned int v51 = (_anonymous_namespace_ *)re::DynamicArray<re::KeyValuePair<unsigned long,re::OffsetsDeformer::PerFrameOffsetData>>::setCapacity((void *)v7, v57);
        uint64_t v53 = v84;
        ++*(_DWORD *)(v7 + 24);
      }
      unint64_t v58 = v92;
      unint64_t v59 = *(void *)(v7 + 8);
      unint64_t v60 = *(void *)(v7 + 16);
      if (v60 >= v59)
      {
        uint64_t v61 = v21;
        unint64_t v62 = v60 + 1;
        if (v59 < v60 + 1)
        {
          uint64_t v85 = v53;
          if (*(void *)v7)
          {
            uint64_t v63 = 2 * v59;
            BOOL v64 = v59 == 0;
            unint64_t v65 = 8;
            if (!v64) {
              unint64_t v65 = v63;
            }
            if (v65 <= v62) {
              unint64_t v66 = v62;
            }
            else {
              unint64_t v66 = v65;
            }
            re::DynamicArray<re::KeyValuePair<unsigned long,re::OffsetsDeformer::PerFrameOffsetData>>::setCapacity((void *)v7, v66);
          }
          else
          {
            re::DynamicArray<re::KeyValuePair<unsigned long,re::OffsetsDeformer::PerFrameOffsetData>>::setCapacity((void *)v7, v62);
            ++*(_DWORD *)(v7 + 24);
          }
          uint64_t v53 = v85;
        }
        unint64_t v60 = *(void *)(v7 + 16);
        uint64_t v21 = v61;
      }
      uint64_t v67 = *(void *)(v7 + 32) + 80 * v60;
      *(void *)uint64_t v67 = v58;
      *(void *)(v67 + 8) = v79;
      *(void *)(v67 + 16) = v40;
      *(void *)(v67 + 24) = v81;
      *(void *)(v67 + 32) = v34;
      *(void *)(v67 + 40) = v52;
      *(void *)(v67 + 48) = v53;
      *(void *)(v67 + 56) = v54;
      *(_DWORD *)(v67 + 64) = v80;
      *(void *)(v67 + 72) = v21;
      ++*(void *)(v7 + 16);
      ++*(_DWORD *)(v7 + 24);
      uint64_t v4 = v76;
      uint64_t v6 = a1;
LABEL_54:
      if (++v8 == v4) {
        return v7;
      }
    }
  }
  return 0;
}

uint64_t re::OffsetsDeformer::deformGPU(uint64_t result, uint64_t a2, void **this, void *a4)
{
  if (a2)
  {
    uint64_t v6 = result;
    re::mtl::ComputeCommandEncoder::pushDebugGroup(this, (re::ns *)"Perform Offset");
    uint64_t v7 = *(void *)(a2 + 16);
    if (v7)
    {
      uint64_t v8 = *(void *)(a2 + 32);
      uint64_t v9 = v8 + 80 * v7;
      do
      {
        re::DeformationInstanceIterator::Instance::Instance(v19, a4, *(void *)v8);
        uint64_t v10 = v20;
        int v11 = re::DeformationVertexBufferState::inputVertexCount(v20, 1u);
        uint64_t v12 = v6 + 16 * (*(void *)(v8 + 72) != 0) + 8 * *(unsigned int *)(v8 + 64);
        unsigned int v13 = objc_msgSend(*(id *)(v12 + 24), sel_maxTotalThreadsPerThreadgroup);
        [*this setComputePipelineState:*(void *)(v12 + 24)];
        LOBYTE(v23) = 1;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v10, 1u);
        uint64_t v14 = *(void *)(v10[24]
                        + 32
                        * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v10 + 23, (unsigned __int8 *)&v23)+ 24);
        LOBYTE(v23) = 1;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v10, 1u);
        objc_msgSend(*this, "setBuffer:offset:atIndex:", v14, *(unsigned int *)(v10[24]+ 32* re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v10 + 23, (unsigned __int8 *)&v23)+ 16), 0);
        LOBYTE(v23) = 1;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v10, 1u);
        uint64_t v15 = *(void *)(v10[8]
                        + 32
                        * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v10 + 7, (unsigned __int8 *)&v23)+ 24);
        LOBYTE(v23) = 1;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v10, 1u);
        objc_msgSend(*this, "setBuffer:offset:atIndex:", v15, *(unsigned int *)(v10[8]+ 32* re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v10 + 7, (unsigned __int8 *)&v23)+ 16), 1);
        [*this setBuffer:*(void *)(v8 + 8) offset:*(unsigned int *)(v8 + 16) atIndex:2];
        [*this setBuffer:*(void *)(v8 + 24) offset:*(unsigned int *)(v8 + 32) atIndex:3];
        uint64_t v16 = *(void *)(v8 + 72);
        if (v16) {
          [*this setBuffer:*(void *)v16 offset:*(unsigned int *)(v16 + 8) atIndex:4];
        }
        [*this setBuffer:*(void *)(v8 + 56) offset:*(unsigned int *)(v8 + 48) atIndex:5];
        uint64_t v17 = *this;
        uint64_t v23 = (v13 + v11 - 1) / v13;
        int64x2_t v24 = vdupq_n_s64(1uLL);
        uint64_t v21 = v13;
        int64x2_t v22 = v24;
        [v17 dispatchThreadgroups:&v23 threadsPerThreadgroup:&v21];
        v8 += 80;
      }
      while (v8 != v9);
    }
    return [*this popDebugGroup];
  }
  return result;
}

void re::OffsetsDeformer::deformCPU(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 16);
    if (v3)
    {
      uint64_t v4 = *(void *)(a2 + 32);
      uint64_t v36 = v4 + 80 * v3;
      for (unint64_t i = &selRef_taskToken; ; unint64_t i = &selRef_taskToken)
      {
        re::DeformationInstanceIterator::Instance::Instance(v52, a3, *(void *)v4);
        uint64_t v6 = *(id **)(v4 + 72);
        if (v6) {
          uint64_t v6 = (id *)((char *)[*v6 i[234]] + *((unsigned int *)v6 + 2));
        }
        uint64_t v7 = v53;
        unint64_t v8 = re::DeformationVertexBufferState::inputVertexCount(v53, 1u);
        uint64_t v9 = (char *)[*(id *)(v4 + 24) i[234]];
        uint64_t v38 = *(unsigned int *)(v4 + 32);
        unint64_t v39 = v9;
        LOBYTE(v49) = 1;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v7, 1u);
        uint64_t v10 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v7 + 15, (unsigned __int8 *)&v49);
        uint64_t v11 = v7[16];
        id v49 = 0;
        __int16 v50 = 0;
        int v51 = 0;
        re::VertexUnpacker::setVertexFormat((uint64_t)&v49, (const VertexBufferFormat *)(v11 + 20 * v10 + 4));
        int v12 = *(_DWORD *)(v4 + 64);
        unsigned int v13 = *(float32x4_t **)(*(void *)(v52[2] + 352) + 104);
        float32x4_t v43 = v13[1];
        float32x4_t v44 = *v13;
        float32x4_t v41 = v13[3];
        float32x4_t v42 = v13[2];
        float32x4_t v48 = v13[4];
        float32x4_t v46 = v13[6];
        float32x4_t v47 = v13[5];
        float32x4_t v45 = v13[7];
        uint64_t v14 = (char *)[*(id *)(v4 + 8) i[234]];
        uint64_t v40 = v4;
        uint64_t v15 = *(unsigned int *)(v4 + 16);
        v54[0] = 1;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v7, 1u);
        uint64_t v16 = v7[8]
            + 32
            * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v7 + 7, v54);
        uint64_t v17 = *(void *)(v16 + 8);
        uint64_t v18 = *(unsigned int *)(v16 + 16);
        v54[0] = 1;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v7, 1u);
        uint64_t v19 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v7 + 23, v54);
        if (v8) {
          break;
        }
LABEL_18:
        uint64_t v4 = v40 + 80;
        if (v40 + 80 == v36) {
          return;
        }
      }
      uint64_t v20 = 0;
      uint64_t v21 = &v14[v15];
      uint64_t v22 = v17 + v18;
      uint64_t v23 = v7[24] + 32 * v19;
      unsigned int v24 = *(_DWORD *)(v23 + 20);
      uint64_t v25 = (_DWORD *)(*(void *)(v23 + 8) + *(unsigned int *)(v23 + 16) + 8);
      while (1)
      {
        unint64_t v26 = v6 ? *((unsigned int *)v6 + v20) : v20;
        uint64_t v27 = v49(v22, v20);
        if (v8 <= v26) {
          break;
        }
        v30.i64[0] = v27;
        v30.i64[1] = v28;
        unint64_t v31 = &v21[12 * v26];
        v29.i64[0] = *(void *)v31;
        v29.i32[2] = *((_DWORD *)v31 + 2);
        if (v12 == 1)
        {
          float32x4_t v32 = v29;
        }
        else
        {
          float32x4_t v32 = 0uLL;
          if (!v12)
          {
            float32x4_t v33 = vaddq_f32(v41, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v44, v30.f32[0]), v43, *(float32x2_t *)v30.f32, 1), v42, v30, 2));
            float32x4_t v32 = vaddq_f32(vdivq_f32(v33, (float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 3)), v29);
          }
        }
        if (v24 / 0xCuLL == v20) {
          goto LABEL_21;
        }
        float32x4_t v34 = vaddq_f32(v45, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v48, v32.f32[0]), v47, *(float32x2_t *)v32.f32, 1), v46, v32, 2));
        float32x4_t v35 = vmlaq_n_f32(vmulq_n_f32(vdivq_f32(v34, (float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 3)), *(float *)&v39[4 * v26 + v38]), v30, 1.0 - *(float *)&v39[4 * v26 + v38]);
        *((void *)v25 - 1) = v35.i64[0];
        *uint64_t v25 = v35.i32[2];
        ++v20;
        v25 += 3;
        if (v8 == v20) {
          goto LABEL_18;
        }
      }
      re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v26, v8);
      _os_crash();
      __break(1u);
LABEL_21:
      re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v24 / 0xCuLL, v24 / 0xCuLL);
      _os_crash();
      __break(1u);
    }
  }
}

re::StringID *re::OffsetsDeformerModelUtil::envelopeBufferNameForOffsetsDataIndex@<X0>(re::OffsetsDeformerModelUtil *this@<X0>, const DeformationModelData *a2@<X1>, re::StringID *a3@<X8>)
{
  uint64_t v3 = *((void *)this + 50);
  if (v3 && *(void *)(v3 + 8) > (unint64_t)a2) {
    return re::StringID::StringID(a3, (const StringID *)(*(void *)(v3 + 16) + 16 * a2));
  }
  else {
    return re::StringID::invalid(a3);
  }
}

uint64_t re::OffsetsDeformerModelUtil::computeOffsetsDeformerModelSizeExcludingMetalBuffers(re::OffsetsDeformerModelUtil *this, const DeformationModelData *a2)
{
  uint64_t v2 = (void *)*((void *)this + 50);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2[1];
  uint64_t v4 = 2 * v2[4] + 16 * v3 + 48;
  if (v3)
  {
    uint64_t v5 = (const char **)(v2[2] + 8);
    do
    {
      if (*(unsigned char *)(v5 - 1)) {
        size_t v6 = strlen(*v5) + 1;
      }
      else {
        size_t v6 = 0;
      }
      v4 += v6;
      v5 += 2;
      --v3;
    }
    while (v3);
  }
  return v4;
}

void re::OffsetsDeformer::~OffsetsDeformer(re::OffsetsDeformer *this)
{
  for (uint64_t i = 48; i != 16; i -= 8)
  {
    uint64_t v3 = *(void **)((char *)this + i);
    if (v3)
    {

      *(void *)((char *)this + i) = 0;
    }
  }
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  uint64_t v2 = 48;
  while (1)
  {
    uint64_t v3 = *(void **)((char *)this + v2);
    if (v3)
    {

      *(void *)((char *)this + v2) = 0;
    }
    v2 -= 8;
    if (v2 == 16)
    {
      JUMPOUT(0x237DBCBD0);
    }
  }
}

void _ZNSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_15OffsetsDeformerENS2_20OffsetsDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_15OffsetsDeformerENS2_20OffsetsDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEv(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_26E713EC0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_15OffsetsDeformerENS2_20OffsetsDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEPNS0_6__baseISI_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E713EC0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_15OffsetsDeformerENS2_20OffsetsDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EEclEOSE_(uint64_t result, void **a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    re::FixedArray<CoreIKTransform>::deinit(v2 + 3);
    re::FixedArray<re::StringID>::deinit(v2);
    uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)v3 + 40);
    return v4(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_15OffsetsDeformerENS2_20OffsetsDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_15OffsetsDeformerENS2_20OffsetsDeformerModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE11target_typeEv()
{
}

void *re::DynamicArray<re::KeyValuePair<unsigned long,re::OffsetsDeformer::PerFrameOffsetData>>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (*v5)
      {
        if (!a2)
        {
          uint64_t v7 = 0;
          if (!v3) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x50uLL))
        {
          uint64_t v2 = 80 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 80 * v5[2]);
            double result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
      }
      else
      {
        double result = (void *)re::DynamicArray<re::KeyValuePair<unsigned long,re::OffsetsDeformer::PerFrameOffsetData>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::DeformationVertexBufferState::makeFromMeshInstance@<X0>(re::DeformationVertexBufferState *this@<X0>, re::RenderManager *a2@<X1>, const re::MeshInstance *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v4 = a3;
  uint64_t result = re::DataArray<re::MeshModel>::get(*((void *)this + 4) + 8, *((void *)a2 + 2));
  unsigned int v7 = v4;
  if (*(void *)(result + 56) <= (unint64_t)v4)
  {
LABEL_10:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v8 = 0;
  uint64_t v9 = (re::AttributeTable *)(*(void *)(result + 64) + 560 * v7);
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(unsigned char *)(a4 + 32) = 0;
  *(_OWORD *)(a4 + 72) = 0u;
  *(_OWORD *)(a4 + 88) = 0u;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_OWORD *)(a4 + 136) = 0u;
  *(_OWORD *)(a4 + 152) = 0u;
  *(_OWORD *)(a4 + 168) = 0u;
  *(_OWORD *)(a4 + 184) = 0u;
  *(_OWORD *)(a4 + 200) = 0u;
  *(_OWORD *)(a4 + 216) = 0u;
  *(_OWORD *)(a4 + 232) = 0u;
  *(_OWORD *)(a4 + 248) = 0u;
  *(_OWORD *)(a4 + 56) = 0u;
  *(_OWORD *)(a4 + 264) = 0u;
  *(_OWORD *)(a4 + 280) = 0u;
  *(_OWORD *)(a4 + 296) = 0u;
  *(void *)(a4 + 40) = (char *)v9 + 476;
  *(void *)(a4 + 48) = v9;
  do
  {
    unint64_t v10 = *((unsigned __int8 *)v9 + v8 + 476);
    if (v10 == 255) {
      goto LABEL_7;
    }
    uint64_t result = re::AttributeTable::buffers(v9);
    if (v11 <= v10)
    {
      re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, v11);
      _os_crash();
      __break(1u);
      goto LABEL_10;
    }
    if (*(_DWORD *)(result + 16 * v10 + 12))
    {
      unsigned int v12 = re::Bitset<64>::toWordIndex(a4, v8);
      *(void *)(a4 + 8 * v12) |= 1 << v8;
      uint64_t result = re::Bitset<64>::toWordIndex(a4 + 8, v8);
      *(void *)(a4 + 8 + 8 * result) |= 1 << v8;
    }
LABEL_7:
    ++v8;
  }
  while (v8 != 24);
  return result;
}

unsigned __int8 *re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::addNew(_anonymous_namespace_ *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t result = (unsigned __int8 *)re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(a1, a2);
  if (result == (unsigned __int8 *)-1)
  {
    return re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::internalAdd(a1, a2, a3);
  }
  return result;
}

{
  uint64_t v6;
  uint64_t vars8;

  uint64_t v6 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(a1, a2);
  if (v6 != -1) {
    return (unsigned __int8 *)(*((void *)a1 + 1) + 32 * v6 + 8);
  }
  return re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::internalAdd(a1, a2, a3);
}

unsigned __int8 *re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::addNew(_anonymous_namespace_ *a1, unsigned __int8 *a2, int *a3)
{
  uint64_t v6 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(a1, a2);
  if (v6 != -1) {
    return (unsigned __int8 *)(*((void *)a1 + 1) + 20 * v6 + 4);
  }
  return re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::internalAdd(a1, a2, a3);
}

uint64_t re::DeformationVertexBufferState::resetVertexBufferChangedState(uint64_t this)
{
  uint64_t v1 = (void *)this;
  unint64_t v2 = *(void *)(this + 16);
  *(void *)this = *(void *)(this + 8);
  if (v2)
  {
    for (unint64_t i = __clz(__rbit64(v2)); ; unint64_t i = __clz(__rbit64(v1[2] & (-2 << i))))
    {
      unsigned __int8 v15 = i;
      uint64_t v4 = v1[24]
         + 32
         * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v1 + 23, &v15);
      uint64_t v5 = v1[8]
         + 32
         * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v1 + 7, &v15);
      uint64_t v6 = *(void *)(v4 + 24);
      *(_OWORD *)(v5 + 8) = *(_OWORD *)(v4 + 8);
      *(void *)(v5 + 24) = v6;
      uint64_t v7 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v1 + 31, &v15);
      uint64_t v8 = v1[32];
      uint64_t v9 = v8 + 20 * v7;
      this = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v1 + 15, &v15);
      uint64_t v10 = v1[16];
      uint64_t v11 = v10 + 20 * this;
      __int16 v12 = *(_WORD *)(v9 + 8);
      *(_DWORD *)(v11 + 4) = *(_DWORD *)(v9 + 4);
      *(_WORD *)(v11 + 8) = v12;
      if (v11 != v9)
      {
        uint64_t v13 = v8 + 20 * v7;
        uint64_t v14 = v10 + 20 * this;
        *(_DWORD *)(v14 + 12) = *(_DWORD *)(v13 + 12);
        *(unsigned char *)(v14 + 16) = *(unsigned char *)(v13 + 16);
      }
      if (i == 63 || (v1[2] & (-2 << i)) == 0) {
        break;
      }
    }
  }
  v1[2] = 0;
  return this;
}

void re::DeformationVertexBufferState::buildAttributeTable(re::DeformationVertexBufferState *this, re::AttributeTable *a2)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  int v30 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v31 = 0;
  memset(v26, 0, sizeof(v26));
  int v27 = 0;
  int v34 = 1;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v35 = 0;
  int v38 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  int v42 = 0;
  uint64_t v41 = 0;
  uint64_t v46 = 0;
  int v47 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  int v45 = 0;
  char v48 = 0;
  uint64_t v3 = *((void *)this + 6);
  uint64_t v25 = v3;
  if (*((void *)this + 3))
  {
    do
    {
      uint64_t v5 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 && !*(void *)(v5 + 128));
    re::BufferTable::operator=((uint64_t)&v26[1] + 8, v5 + 48);
    unint64_t v7 = *((void *)this + 3);
    if (v7)
    {
      unint64_t v8 = __clz(__rbit64(v7));
      if (v8 > 0x17)
      {
LABEL_8:
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 242, v8, 24, v25, *(void *)&v26[0]);
        _os_crash();
        __break(1u);
      }
      else
      {
        while (1)
        {
          unint64_t v9 = *(unsigned __int8 *)(*((void *)this + 5) + v8);
          LOBYTE(v58[0]) = v8;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)this, v8);
          uint64_t v10 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)this + 23, (unsigned __int8 *)v58);
          uint64_t v11 = *(void *)(*((void *)this + 24) + 32 * v10 + 16);
          *(void *)&v58[0] = *(void *)(*((void *)this + 24) + 32 * v10 + 24);
          *((void *)&v58[0] + 1) = v11;
          re::BufferTable::setBuffer((re::BufferTable *)((char *)&v26[1] + 8), v9, (const BufferView *)v58);
          if ((*((void *)this + 3) & (-2 << v8)) == 0) {
            break;
          }
          unint64_t v8 = __clz(__rbit64(*((void *)this + 3) & (-2 << v8)));
          if (v8 > 0x17) {
            goto LABEL_8;
          }
        }
      }
    }
    if (*((unsigned char *)this + 32))
    {
      uint64_t v12 = *((void *)this + 6);
      do
      {
        uint64_t v13 = v12;
        uint64_t v12 = *(void *)(v12 + 8);
      }
      while (v12 && !*(void *)(v13 + 32));
      re::FixedArray<re::VertexBufferFormat>::operator=(v26, v13 + 24);
      unint64_t v15 = *((void *)this + 3);
      if (v15)
      {
        unint64_t v16 = __clz(__rbit64(v15));
        if (v16 > 0x17)
        {
LABEL_20:
          re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 242, v16, 24);
          _os_crash();
          __break(1u);
        }
        else
        {
          while (1)
          {
            unint64_t v17 = *(unsigned __int8 *)(*((void *)this + 5) + v16);
            LOBYTE(v58[0]) = v16;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)this, v16);
            uint64_t v18 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)this + 31, (unsigned __int8 *)v58);
            uint64_t v19 = *((void *)&v26[0] + 1);
            if (*((void *)&v26[0] + 1) <= v17)
            {
              uint64_t v49 = 0;
              memset(v58, 0, sizeof(v58));
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v50 = 136315906;
              int v51 = "operator[]";
              __int16 v52 = 1024;
              int v53 = 468;
              __int16 v54 = 2048;
              unint64_t v55 = v17;
              __int16 v56 = 2048;
              uint64_t v57 = v19;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            uint64_t v20 = *((void *)this + 32);
            uint64_t v21 = v20 + 20 * v18;
            uint64_t v22 = *(void *)&v26[1] + 16 * v17;
            int v23 = *(_DWORD *)(v21 + 4);
            v21 += 4;
            *(_WORD *)(v22 + 4) = *(_WORD *)(v21 + 4);
            *(_DWORD *)uint64_t v22 = v23;
            if (v22 != v21)
            {
              uint64_t v24 = v20 + 20 * v18;
              *(_DWORD *)(v22 + 8) = *(_DWORD *)(v24 + 12);
              *(unsigned char *)(v22 + 12) = *(unsigned char *)(v24 + 16);
            }
            if ((*((void *)this + 3) & (-2 << v16)) == 0) {
              break;
            }
            unint64_t v16 = __clz(__rbit64(*((void *)this + 3) & (-2 << v16)));
            if (v16 > 0x17) {
              goto LABEL_20;
            }
          }
        }
      }
    }
  }
  re::AttributeTableBuilder::makeAttributeTableAndReset((re::AttributeTableBuilder *)&v25, a2);
  re::AttributeTableBuilder::~AttributeTableBuilder((re::AttributeTableBuilder *)&v25);
}

uint64_t re::BufferTable::setBuffer(re::BufferTable *this, unint64_t a2, const BufferView *a3)
{
  if (*((_DWORD *)this + 70) <= a2) {
    *((_DWORD *)this + 70) = a2 + 1;
  }
  id v7 = 0;
  re::BufferTable::setBufferRef((void **)this, a2, &v7);
  if (v7) {

  }
  re::BufferTable::setBufferView(this, a2, *(void *)a3, *((void *)a3 + 1));
  return re::BufferTable::setBufferIndirectResources(this, a2, 0, 0);
}

void *re::FixedArray<re::VertexBufferFormat>::operator=(void *a1, uint64_t a2)
{
  if (a1 != (void *)a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*a1)
    {
      if (!v4) {
        return a1;
      }
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::VertexBufferFormat>::init<>((uint64_t)a1, v4, *(void *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::VertexBufferFormat>::copy((uint64_t)a1, a2);
    }
  }
  return a1;
}

unsigned __int8 *re::DeformationVertexBufferState::ensureVertexBufferInitialized(uint64_t a1, unsigned __int8 a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  unsigned __int8 v27 = a2;
  uint64_t v5 = (_anonymous_namespace_ *)(a1 + 56);
  uint64_t result = (unsigned __int8 *)re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(a1 + 56), &v27);
  if (result == (unsigned __int8 *)-1)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (!v8) {
      goto LABEL_15;
    }
    if (v27 >= 0x18uLL)
    {
      re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 242, v27, 24);
      _os_crash();
      __break(1u);
    }
    else
    {
      unint64_t v3 = *(unsigned __int8 *)(v8 + v27);
      if (v3 == 255) {
        goto LABEL_15;
      }
      uint64_t v9 = re::AttributeTable::buffers(*(re::AttributeTable **)(a1 + 48));
      if (v10 > v3)
      {
        if (*(_DWORD *)(v9 + 16 * v3 + 12))
        {
          uint64_t v11 = re::AttributeTable::buffers(*(re::AttributeTable **)(a1 + 48));
          if (v12 > v3)
          {
            uint64_t v13 = v11;
            uint64_t v14 = (id *)(v11 + 16 * v3);
            uint64_t v15 = *(void *)(a1 + 48);
            do
            {
              uint64_t v16 = v15;
              uint64_t v15 = *(void *)(v15 + 8);
              unint64_t v2 = *(void *)(v16 + 32);
              if (v15) {
                BOOL v17 = v2 == 0;
              }
              else {
                BOOL v17 = 0;
              }
            }
            while (v17);
            if (v2 > v3)
            {
              uint64_t v18 = (int *)(*(void *)(v16 + 40) + 16 * v3);
              id v19 = objc_msgSend(*v14, sel_contents);
              id v20 = *v14;
              *(void *)&long long v37 = v19;
              *((void *)&v37 + 1) = *(void *)(v13 + 16 * v3 + 8);
              *(void *)&long long v38 = v20;
              uint64_t v21 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::addNew((_anonymous_namespace_ *)(a1 + 184), &v27, (uint64_t)&v37);
              re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::addNew(v5, &v27, (uint64_t)v21);
              uint64_t v22 = (_anonymous_namespace_ *)(a1 + 120);
              int v23 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::addNew((_anonymous_namespace_ *)(a1 + 248), &v27, v18);
              goto LABEL_18;
            }
LABEL_24:
            uint64_t v28 = 0;
            long long v40 = 0u;
            long long v41 = 0u;
            long long v38 = 0u;
            long long v39 = 0u;
            long long v37 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v29 = 136315906;
            int v30 = "operator[]";
            __int16 v31 = 1024;
            int v32 = 476;
            __int16 v33 = 2048;
            unint64_t v34 = v3;
            __int16 v35 = 2048;
            unint64_t v36 = v2;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
LABEL_23:
          re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, v12);
          _os_crash();
          __break(1u);
          goto LABEL_24;
        }
LABEL_15:
        long long v37 = 0uLL;
        *(void *)&long long v38 = 0;
        uint64_t v24 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::addNew((_anonymous_namespace_ *)(a1 + 184), &v27, (uint64_t)&v37);
        re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::addNew(v5, &v27, (uint64_t)v24);
        uint64_t v22 = (_anonymous_namespace_ *)(a1 + 120);
        LODWORD(v37) = 0x10000;
        WORD2(v37) = 256;
        uint64_t v25 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(a1 + 248), &v27);
        if (v25 != -1)
        {
          unint64_t v26 = (int *)(*(void *)(a1 + 256) + 20 * v25 + 4);
          return re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::addNew(v22, &v27, v26);
        }
        int v23 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::internalAdd((_anonymous_namespace_ *)(a1 + 248), &v27, (uint64_t)&v37);
LABEL_18:
        unint64_t v26 = (int *)v23;
        return re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::addNew(v22, &v27, v26);
      }
    }
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3, v10);
    _os_crash();
    __break(1u);
    goto LABEL_23;
  }
  return result;
}

unint64_t *re::BufferInitializationOptions::initializeGPUVertexBuffers(unint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (!*result) {
    return result;
  }
  uint64_t v8 = (id *)a2;
  unint64_t v9 = __clz(__rbit64(*result));
  uint64_t v10 = a3 + 8;
  for (i = result; ; unint64_t v9 = __clz(__rbit64(*i & (-2 << v9))))
  {
    uint64_t v11 = *((unsigned __int8 *)result + v9 + 8);
    if (v11 == 2) {
      break;
    }
    if (v11 != 1) {
      goto LABEL_24;
    }
    uint64_t v29 = *(void *)(a3 + 48);
    if (v29)
    {
      unint64_t v12 = 0;
      while (1)
      {
        uint64_t v13 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v10, v12);
        unint64_t v15 = *(void *)(v13 + 8);
        if (a5 <= v15) {
          break;
        }
        unint64_t v5 = a4 + 312 * v15 + 8;
        if ((*(void *)(v5 + 8 * re::Bitset<64>::toWordIndex(v5, v9)) & (1 << v9)) != 0)
        {
          unint64_t v5 = a4 + 312 * v15;
          unsigned __int8 v30 = v9;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized(v5, v9);
          uint64_t v16 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v5 + 56), &v30);
          BOOL v17 = v8;
          unint64_t v18 = a5;
          uint64_t v19 = *(void *)(v5 + 64);
          unsigned __int8 v31 = v9;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized(v5, v9);
          uint64_t v20 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v5 + 184), &v31);
          uint64_t v21 = v19 + 32 * v16;
          a5 = v18;
          uint64_t v8 = v17;
          [*v17 copyFromBuffer:*(void *)(v21 + 24) sourceOffset:*(unsigned int *)(v21 + 16) toBuffer:*(void *)(*(void *)(v5 + 192) + 32 * v20 + 24) destinationOffset:*(unsigned int *)(*(void *)(v5 + 192) + 32 * v20 + 16) size:*(unsigned int *)(*(void *)(v5 + 192) + 32 * v20 + 20)];
        }
        if (v29 == ++v12) {
          goto LABEL_18;
        }
      }
      re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, *(void *)(v13 + 8), a5);
      _os_crash();
      __break(1u);
      goto LABEL_23;
    }
LABEL_18:
    uint64_t result = i;
    if (v9 == 63 || (*i & (-2 << v9)) == 0) {
      return result;
    }
  }
  uint64_t v22 = *(void *)(a3 + 48);
  if (!v22) {
    goto LABEL_18;
  }
  unint64_t v23 = 0;
  while (1)
  {
    unint64_t v5 = *(void *)(re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v10, v23) + 8);
    if (a5 <= v5) {
      break;
    }
    if ((*(void *)(a4 + 312 * v5 + 8 + 8 * re::Bitset<64>::toWordIndex(a4 + 312 * v5 + 8, v9)) & (1 << v9)) != 0)
    {
      uint64_t v25 = a4 + 312 * v5;
      unsigned __int8 v32 = v9;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized(v25, v9);
      uint64_t v26 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v25 + 184), &v32);
      objc_msgSend(*v8, "fillBuffer:range:value:", *(void *)(*(void *)(v25 + 192) + 32 * v26 + 24), *(unsigned int *)(*(void *)(v25 + 192) + 32 * v26 + 16), *(unsigned int *)(*(void *)(v25 + 192) + 32 * v26 + 20), 0);
    }
    if (v22 == ++v23) {
      goto LABEL_18;
    }
  }
LABEL_23:
  re::internal::assertLog((re::internal *)6, v24, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v5, a5);
  _os_crash();
  __break(1u);
LABEL_24:
  re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid buffer initialization type: %u.", "!\"Unreachable code\"", "initializeGPUVertexBuffers", 212, v11);
  uint64_t result = (unint64_t *)_os_crash();
  __break(1u);
  return result;
}

unint64_t *re::BufferInitializationOptions::initializeCPUVertexBuffers(unint64_t *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (!*result) {
    return result;
  }
  unint64_t v6 = __clz(__rbit64(*result));
  uint64_t v7 = a2 + 8;
  for (i = result; ; unint64_t v6 = __clz(__rbit64(*i & (-2 << v6))))
  {
    uint64_t v8 = *((unsigned __int8 *)result + v6 + 8);
    if (v8 == 2) {
      break;
    }
    if (v8 != 1) {
      goto LABEL_24;
    }
    uint64_t v9 = *(void *)(a2 + 48);
    if (v9)
    {
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v7, v10);
        unint64_t v13 = *(void *)(v11 + 8);
        if (a4 <= v13) {
          break;
        }
        if ((*(void *)(a3 + 312 * v13 + 8 + 8 * re::Bitset<64>::toWordIndex(a3 + 312 * v13 + 8, v6)) & (1 << v6)) != 0)
        {
          uint64_t v14 = (void *)(a3 + 312 * v13);
          unsigned __int8 v24 = v6;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v14, v6);
          uint64_t v15 = v14[8]
              + 32
              * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v14 + 7, &v24);
          unsigned __int8 v25 = v6;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v14, v6);
          uint64_t v16 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v14 + 23, &v25);
          memcpy((void *)(*(void *)(v14[24] + 32 * v16 + 8) + *(unsigned int *)(v14[24] + 32 * v16 + 16)), (const void *)(*(void *)(v15 + 8) + *(unsigned int *)(v15 + 16)), *(unsigned int *)(v14[24] + 32 * v16 + 20));
        }
        if (v9 == ++v10) {
          goto LABEL_18;
        }
      }
      re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, *(void *)(v11 + 8), a4);
      _os_crash();
      __break(1u);
      goto LABEL_23;
    }
LABEL_18:
    uint64_t result = i;
    if (v6 == 63 || (*i & (-2 << v6)) == 0) {
      return result;
    }
  }
  uint64_t v17 = *(void *)(a2 + 48);
  if (!v17) {
    goto LABEL_18;
  }
  unint64_t v18 = 0;
  while (1)
  {
    unint64_t v13 = *(void *)(re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v7, v18) + 8);
    if (a4 <= v13) {
      break;
    }
    if ((*(void *)(a3 + 312 * v13 + 8 + 8 * re::Bitset<64>::toWordIndex(a3 + 312 * v13 + 8, v6)) & (1 << v6)) != 0)
    {
      uint64_t v20 = a3 + 312 * v13;
      unsigned __int8 v26 = v6;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized(v20, v6);
      uint64_t v21 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v20 + 184), &v26);
      bzero((void *)(*(void *)(*(void *)(v20 + 192) + 32 * v21 + 8)+ *(unsigned int *)(*(void *)(v20 + 192) + 32 * v21 + 16)), *(unsigned int *)(*(void *)(v20 + 192) + 32 * v21 + 20));
    }
    if (v17 == ++v18) {
      goto LABEL_18;
    }
  }
LABEL_23:
  re::internal::assertLog((re::internal *)6, v19, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v13, a4);
  _os_crash();
  __break(1u);
LABEL_24:
  re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid buffer initialization type: %u.", "!\"Unreachable code\"", "initializeCPUVertexBuffers", 259, v8);
  uint64_t result = (unint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t re::DeformationInstanceIterator::Instance::Instance(void *a1, void *a2, unint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  a1[2] = 0;
  a1[3] = 0;
  unint64_t v4 = *(void *)(re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](*a2 + 8, a3) + 8);
  a1[2] = re::BucketArray<re::ActiveDeformation,8ul>::operator[](*(void *)(*a1 + 8), v4);
  unint64_t v6 = *(void *)(*a1 + 48);
  if (v6 <= v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v4, v6);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    a1[3] = *(void *)(*a1 + 40) + 312 * v4;
    return (uint64_t)a1;
  }
  return result;
}

uint64_t re::DeformationInstanceIterator::Instance::handle(re::DeformationInstanceIterator::Instance *this)
{
  uint64_t v2 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](**(void **)this + 8, *((void *)this + 1));
  uint64_t v4 = *((void *)this + 2);
  unint64_t v5 = *(unsigned __int8 *)(v2 + 16);
  unint64_t v6 = *(void *)(v4 + 336);
  if (v6 > v5) {
    return *(void *)(*(void *)(v4 + 328) + (v5 << 6));
  }
  re::internal::assertLog((re::internal *)6, v3, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, *(unsigned __int8 *)(v2 + 16), v6);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::DeformationInstanceIterator::Instance::meshPart(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = re::DataArray<re::MeshModel>::get(a2 + 8, *(void *)(*(void *)(*(void *)(a1 + 16) + 368) + 16));
  if (*(void *)(v3 + 56) <= (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 16) + 392))
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(void *)(v3 + 64) + 560 * *(unsigned __int16 *)(*(void *)(a1 + 16) + 392);
}

void re::ConstantTableCollection::fill(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, long long **a5)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a4 + 8);
  if (v8)
  {
    uint64_t v9 = *(unsigned int **)a4;
    uint64_t v10 = *(void *)a4 + 16 * v8;
    do
    {
      uint64_t v11 = *v9;
      uint64_t v12 = v9[1];
      uint64_t v14 = v9[2];
      size_t v13 = v9[3];
      if (v11 == 11)
      {
        if (!*(void *)(a1 + 128))
        {
          *(void *)unsigned __int8 v26 = 0;
          memset(v25, 0, 80);
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v33[0]) = 136315906;
          *(void *)((char *)v33 + 4) = "operator[]";
          WORD6(v33[0]) = 1024;
          *(_DWORD *)((char *)v33 + 14) = 797;
          WORD1(v33[1]) = 2048;
          *(void *)((char *)&v33[1] + 4) = 0;
          WORD6(v33[1]) = 2048;
          *(void *)((char *)&v33[1] + 14) = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_20:
          uint64_t v24 = 0;
          memset(v33, 0, sizeof(v33));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unsigned __int8 v26 = 136315906;
          *(void *)&v26[4] = "operator[]";
          __int16 v27 = 1024;
          int v28 = 797;
          __int16 v29 = 2048;
          uint64_t v30 = 0;
          __int16 v31 = 2048;
          uint64_t v32 = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        uint64_t v15 = *(void *)(a1 + 144);
      }
      else
      {
        uint64_t v15 = a1 + 8 * v11;
      }
      uint64_t v16 = (*(uint64_t (**)(void))(**(void **)v15 + 16))();
      memcpy((void *)(a2 + v14), (const void *)(v16 + v12), v13);
      v9 += 4;
    }
    while (v9 != (unsigned int *)v10);
  }
  uint64_t v17 = a5[1];
  if (v17)
  {
    unint64_t v18 = *a5;
    uint64_t v19 = 16 * (void)v17;
    do
    {
      long long v23 = *v18;
      re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v25);
      if (v23 == 11)
      {
        if (!*(void *)(a1 + 128)) {
          goto LABEL_20;
        }
        uint64_t v20 = *(void *)(a1 + 144);
      }
      else
      {
        uint64_t v20 = a1 + 8 * v23;
      }
      uint64_t v21 = (*(uint64_t (**)(void))(**(void **)v20 + 16))();
      uint64_t v22 = *(void *)&v33[1];
      memcpy((void *)(a2 + DWORD2(v23)), *(const void **)&v33[1], HIDWORD(v23));
      if (*(void *)&v33[0])
      {
        if (*((void *)&v33[0] + 1)) {
          (*(void (**)(void, uint64_t))(**(void **)&v33[0] + 40))(*(void *)&v33[0], v22);
        }
      }
      re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v25);
      ++v18;
      v19 -= 16;
    }
    while (v19);
  }
}

__int16 re::anonymous namespace'::castToHalfBuffer@<H0>(uint64_t a1@<X0>, int *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  unint64_t v5 = *(unsigned int *)(a1 + 12);
  uint64_t v6 = v5 >> 1;
  *a4 = a3;
  a4[1] = v5 >> 1;
  a4[2] = 0;
  if (v5 >= 2)
  {
    uint64_t v8 = v6;
    uint64_t v9 = (_WORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 32))(a3, 2 * v6, 2);
    a4[2] = v9;
    if (v9)
    {
      uint64_t v11 = v9;
      uint64_t v12 = v9;
      if (v6 != 1)
      {
        bzero(v9, v8 * 2 - 2);
        uint64_t v12 = &v11[v8 - 1];
      }
      *uint64_t v12 = 0;
      if (v6 <= 1) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v6;
      }
      for (uint64_t i = v6; i; --i)
      {
        int v15 = *a2++;
        _S0 = v15;
        __asm { FCVT            H0, S0 }
        *v11++ = result;
        if (!--v13) {
          return result;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
  return result;
}

void re::ConstantTableCollection::fillInstanceArray(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, long long **a6, uint64_t a7)
{
  if (a5)
  {
    for (uint64_t i = 0; i != a5; ++i)
    {
      uint64_t v13 = i * a4;
      uint64_t v14 = a6[1];
      if (v14)
      {
        int v15 = *a6;
        uint64_t v16 = 16 * (void)v14;
        do
        {
          long long v17 = *v15++;
          *(_OWORD *)__int16 v27 = v17;
          InstanceArraySourcePtr = (const void *)re::ConstantTableCollection::getInstanceArraySourcePtr(a1, v27, i);
          memcpy((void *)(a2 + v13 + v27[2]), InstanceArraySourcePtr, v27[3]);
          v16 -= 16;
        }
        while (v16);
      }
      uint64_t v19 = *(void *)(a7 + 8);
      if (v19)
      {
        uint64_t v20 = *(_OWORD **)a7;
        uint64_t v21 = a2 + v13;
        uint64_t v22 = 16 * v19;
        do
        {
          *(_OWORD *)int v28 = *v20;
          re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v27);
          long long v23 = (int *)re::ConstantTableCollection::getInstanceArraySourcePtr(a1, v28, i);
          memcpy((void *)(v21 + v28[2]), (const void *)v26[2], v28[3]);
          if (v26[0]) {
            BOOL v24 = v26[1] == 0;
          }
          else {
            BOOL v24 = 1;
          }
          if (!v24) {
            (*(void (**)(void))(*(void *)v26[0] + 40))();
          }
          re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v27);
          ++v20;
          v22 -= 16;
        }
        while (v22);
      }
    }
  }
}

uint64_t re::ConstantTableCollection::getInstanceArraySourcePtr(uint64_t a1, unsigned int *a2, int a3)
{
  uint64_t v4 = *a2;
  if (v4 == 11)
  {
    if (*(void *)(a1 + 128) <= (unint64_t)a3)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v6 = *(void *)(*(void *)(a1 + 144) + 8 * a3);
    goto LABEL_7;
  }
  if (v4 != 3)
  {
    uint64_t v6 = *(void *)(a1 + 8 * v4);
LABEL_7:
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
    return v5 + a2[1];
  }
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24)) + ((uint64_t)a3 << 8);
  return v5 + a2[1];
}

uint64_t re::AttributeTableBuilder::makeAttributeTable(re::AttributeTableBuilder *this, re::AttributeTable *a2)
{
  uint64_t v3 = (char *)this + 8;
  *((void *)a2 + 1) = *(void *)this;
  re::BufferTable::operator=((uint64_t)a2 + 48, (uint64_t)this + 32);
  re::FixedArray<re::VertexBufferFormat>::operator=((void *)a2 + 3, (uint64_t)v3);
  uint64_t v4 = a2;
  do
  {
    uint64_t v5 = v4;
    uint64_t v4 = (re::AttributeTable *)*((void *)v4 + 1);
  }
  while (v4 && !*((void *)v5 + 4));
  uint64_t v6 = a2;
  do
  {
    uint64_t v7 = v6;
    uint64_t v6 = (re::AttributeTable *)*((void *)v6 + 1);
  }
  while (v6 && !*((void *)v7 + 9));
  *((void *)a2 + 2) = result;
  return result;
}

uint64_t re::anonymous namespace'::makeHashForAttributeTableHelper(uint64_t a1, uint64_t *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  v15[0] = a2;
  unint64_t v2 = a2[2];
  if (v2 < 0x10) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = *a2;
  unint64_t v6 = v2 >> 4;
  while (1)
  {
    unsigned __int16 v7 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v5 + v4)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
    v15[1] = (unsigned __int16)~v7;
    if (v7 != 0xFFFF) {
      break;
    }
    v4 += 16;
    if (!--v6) {
      return 0;
    }
  }
  uint64_t v8 = __clz(__rbit64((unsigned __int16)~v7)) + v4;
  uint64_t v16 = v8;
  if (v8 == -1) {
    return 0;
  }
  uint64_t v9 = 0;
  do
  {
    uint64_t v11 = *(void *)(v15[0] + 8);
    unint64_t v12 = *(unsigned __int8 *)(v11 + 16 * v8 + 8);
    unint64_t v13 = *(void *)(a1 + 8);
    if (v13 <= v12)
    {
      uint64_t v17 = 0;
      long long v29 = 0u;
      long long v30 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v26 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v18 = 136315906;
      uint64_t v19 = "operator[]";
      __int16 v20 = 1024;
      int v21 = 476;
      __int16 v22 = 2048;
      unint64_t v23 = v12;
      __int16 v24 = 2048;
      unint64_t v25 = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v14 = *(void *)(v11 + 16 * v8);
    v9 ^= v14 ^ re::VertexBufferFormat::hash((unsigned __int16 *)(*(void *)(a1 + 16) + 16 * v12), 0, 0, 0, 0, 0);
    re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v15);
    uint64_t v8 = v16;
  }
  while (v16 != -1);
  return v9;
}

uint64_t re::AttributeTableBuilder::makeAttributeTableAndReset(re::AttributeTableBuilder *this, re::AttributeTable *a2)
{
  uint64_t v4 = (uint64_t *)((char *)this + 8);
  *((void *)a2 + 1) = *(void *)this;
  uint64_t v5 = (re::AttributeTableBuilder *)((char *)this + 32);
  re::BufferTable::operator=((uint64_t)a2 + 48, (uint64_t)this + 32);
  re::FixedArray<float>::operator=((uint64_t *)a2 + 3, v4);
  unint64_t v6 = a2;
  do
  {
    unsigned __int16 v7 = v6;
    unint64_t v6 = (re::AttributeTable *)*((void *)v6 + 1);
  }
  while (v6 && !*((void *)v7 + 4));
  uint64_t v8 = a2;
  do
  {
    uint64_t v9 = v8;
    uint64_t v8 = (re::AttributeTable *)*((void *)v8 + 1);
  }
  while (v8 && !*((void *)v9 + 9));
  *(void *)this = 0;
  re::FixedArray<CoreIKTransform>::deinit(v4);
  uint64_t result = re::BufferTable::deinit(v5);
  *((unsigned char *)this + 320) = 0;
  return result;
}

void re::DynamicTextureTableAdd(void *a1, void *a2, id *a3)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  unint64_t v6 = (_anonymous_namespace_ *)(a1 + 1);
  uint64_t v7 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(a1 + 1, a2);
  if (v7 == -1)
  {
    BYTE1(v29) = a1[11];
    LOBYTE(v29) = objc_msgSend(*a3, sel_protectionOptions);
    if (re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(v6, a2) == -1)re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::internalAdd(v6, a2, &v29); {
    v37[0] = *a3;
    }
    LOBYTE(v37[1]) = 0;
    LOBYTE(v38[1]) = 0;
    re::DynamicArray<re::TextureViews<NS::SharedPtr<MTL::Texture>>>::add(a1 + 9, (uint64_t)v37);
    if (LOBYTE(v37[1]) && v38[0])
    {

      v38[0] = 0;
    }
    if (v37[0]) {
  }
    }
  else
  {
    uint64_t v8 = a1[2] + 16 * v7;
    id v9 = *a3;
    unsigned int v12 = *(unsigned __int8 *)(v8 + 9);
    uint64_t v10 = (unsigned char *)(v8 + 9);
    uint64_t v11 = v12;
    id v23 = v9;
    LOBYTE(v24) = 0;
    char v26 = 0;
    unint64_t v13 = a1[11];
    if (v13 <= v12)
    {
      uint64_t v28 = 0;
      long long v40 = 0u;
      long long v41 = 0u;
      *(_OWORD *)long long v38 = 0u;
      long long v39 = 0u;
      *(_OWORD *)long long v37 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v29 = 136315906;
      long long v30 = "operator[]";
      __int16 v31 = 1024;
      int v32 = 789;
      __int16 v33 = 2048;
      uint64_t v34 = v11;
      __int16 v35 = 2048;
      unint64_t v36 = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    uint64_t v14 = a1[13];
    uint64_t v15 = v14 + 32 * v11;
    NS::SharedPtr<MTL::Texture>::operator=((void **)v15, &v23);
    re::Optional<NS::SharedPtr<MTL::Texture>>::operator=(v15 + 8, &v24);
    int v18 = *(unsigned __int8 *)(v15 + 24);
    uint64_t v17 = (unsigned char *)(v15 + 24);
    int v16 = v18;
    if (v18) {
      BOOL v19 = 0;
    }
    else {
      BOOL v19 = v26 == 0;
    }
    if (!v19)
    {
      if (v16) {
        BOOL v20 = v26 == 0;
      }
      else {
        BOOL v20 = 0;
      }
      if (v20)
      {
        *uint64_t v17 = 0;
      }
      else
      {
        if (v16) {
          BOOL v21 = 1;
        }
        else {
          BOOL v21 = v26 == 0;
        }
        if (!v21) {
          *uint64_t v17 = 1;
        }
        *(_DWORD *)(v14 + 32 * v11 + 25) = v27;
      }
    }
    if ((_BYTE)v24 && v25)
    {

      id v25 = 0;
    }
    if (v23) {

    }
    unsigned __int8 v22 = objc_msgSend(*a3, sel_protectionOptions);
    if (*(v10 - 1) != v22)
    {
      LOBYTE(v37[0]) = v22;
      BYTE1(v37[0]) = *v10;
      re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::replace(v6, a2, v37);
    }
  }
}

BOOL re::DynamicTextureTableRemove(re *this, re::TextureTable *a2, const re::WeakStringID *a3)
{
  uint64_t v5 = (uint64_t *)((char *)this + 8);
  uint64_t v6 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find((void *)this + 1, a2);
  if (v6 != -1)
  {
    uint64_t v7 = *((void *)this + 2) + 16 * v6;
    unsigned int v9 = *(unsigned __int8 *)(v7 + 9);
    uint64_t v8 = (unsigned __int8 *)(v7 + 9);
    re::DynamicArray<re::TextureViews<NS::SharedPtr<MTL::Texture>>>::removeStableAt((uint64_t)this + 72, v9);
    v18[0] = v5;
    unint64_t v10 = *((void *)this + 3);
    if (v10 >= 0x10)
    {
      uint64_t v11 = 0;
      uint64_t v12 = *v5;
      unint64_t v13 = v10 >> 4;
      while (1)
      {
        unsigned __int16 v14 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v12 + v11)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
        v18[1] = (unsigned __int16)~v14;
        if (v14 != 0xFFFF) {
          break;
        }
        v11 += 16;
        if (!--v13) {
          goto LABEL_11;
        }
      }
      uint64_t v15 = __clz(__rbit64((unsigned __int16)~v14)) + v11;
      for (i = v15; i != -1; uint64_t v15 = i)
      {
        re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::updateKvpsHash((uint64_t)v5, *((void *)this + 2) + 16 * v15);
        uint64_t v16 = *((void *)this + 2) + 16 * i;
        if (*(unsigned __int8 *)(v16 + 9) > *v8) {
          --*(unsigned char *)(v16 + 9);
        }
        re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::updateKvpsHash((uint64_t)v5, v16);
        re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v18);
      }
    }
LABEL_11:
    re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::remove(v5, a2);
    v18[0] = this;
    re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::rehashKeysWith<re::TextureTableImpl<NS::SharedPtr<MTL::Texture>>::rehashNames(void)::{lambda(re::IndexAndProtectionOptions)#1}>(v5, (uint64_t)v18);
  }
  return v6 != -1;
}

void re::DynamicArray<re::TextureViews<NS::SharedPtr<MTL::Texture>>>::removeStableAt(uint64_t a1, unint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 <= a2)
  {
    memset(v7, 0, sizeof(v7));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::TextureViews<NS::SharedPtr<MTL::Texture>> *,re::TextureViews<NS::SharedPtr<MTL::Texture>> *,re::TextureViews<NS::SharedPtr<MTL::Texture>> *>((uint64_t)v7, *(void *)(a1 + 32) + 32 * a2 + 32, *(void *)(a1 + 32) + 32 * v2, *(void *)(a1 + 32) + 32 * a2);
    unint64_t v2 = *(void *)(a1 + 16);
  }
  uint64_t v4 = *(void *)(a1 + 32) + 32 * v2;
  if (*(unsigned char *)(v4 - 24))
  {
    uint64_t v5 = *(void **)(v4 - 16);
    if (v5)
    {

      *(void *)(v4 - 16) = 0;
    }
  }
  uint64_t v6 = *(void **)(v4 - 32);
  if (v6)
  {

    *(void *)(v4 - 32) = 0;
  }
  --*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
}

BOOL re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::remove(uint64_t *a1, void *a2)
{
  uint64_t v3 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(a1, a2);
  uint64_t v4 = v3;
  if (v3 != -1)
  {
    uint64_t v5 = (int8x16_t *)(*a1 + (v3 & 0xFFFFFFFFFFFFFFF0));
    v6.i64[0] = -1;
    v6.i64[1] = -1;
    int8x8_t v7 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(*v5, v6), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    if (v7) {
      char v8 = -1;
    }
    else {
      char v8 = 0x80;
    }
    v5->i8[v3 & 0xF] = v8;
    re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::updateHashes((uint64_t)a1, a1[1] + 16 * v3);
    unint64_t v9 = a1[2];
    *(void *)(a1[1] + 16 * v4) = 0;
    uint64_t v10 = a1[4];
    if (v7) {
      ++v10;
    }
    unint64_t v11 = a1[3] - 1;
    a1[3] = v11;
    a1[4] = v10;
    if (v9 >= 0x11 && v11 < v9 >> 2) {
      re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::resize(a1, 0);
    }
  }
  return v4 != -1;
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::TextureViews<NS::SharedPtr<MTL::Texture>> *,re::TextureViews<NS::SharedPtr<MTL::Texture>> *,re::TextureViews<NS::SharedPtr<MTL::Texture>> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      NS::SharedPtr<MTL::Texture>::operator=((void **)a4, (void **)v5);
      uint64_t v7 = v5 + 8;
      re::Optional<NS::SharedPtr<MTL::Texture>>::operator=(a4 + 8, (void **)(v5 + 8));
      int v8 = *(unsigned __int8 *)(v5 + 24);
      if (*(unsigned char *)(a4 + 24)) {
        BOOL v9 = 0;
      }
      else {
        BOOL v9 = v8 == 0;
      }
      if (!v9)
      {
        if (*(unsigned char *)(a4 + 24)) {
          BOOL v10 = v8 == 0;
        }
        else {
          BOOL v10 = 0;
        }
        if (v10)
        {
          *(unsigned char *)(a4 + 24) = 0;
        }
        else
        {
          if (!*(unsigned char *)(a4 + 24) && *(unsigned char *)(v5 + 24)) {
            *(unsigned char *)(a4 + 24) = 1;
          }
          *(_DWORD *)(a4 + 25) = *(_DWORD *)(v5 + 25);
        }
      }
      a4 += 32;
      v5 += 32;
    }
    while (v7 + 24 != a3);
    return a3;
  }
  return v5;
}

uint64_t re::BoundingBoxCalculation::init(uint64_t this, id *a2)
{
  if (!*(unsigned char *)(this + 32))
  {
    uint64_t v3 = this;
    *(unsigned char *)(this + 32) = 1;
    if (*((unsigned char *)a2 + 260))
    {
      if ([a2[23] supportsFamily:1006]) {
        uint64_t v4 = 1;
      }
      else {
        uint64_t v4 = [a2[23] supportsFamily:2002];
      }
      *(unsigned char *)(v3 + 34) = v4;
      v33[0] = 0;
      uint64_t v39 = 0;
      memset(v37, 0, sizeof(v37));
      int v38 = 0;
      char v40 = 0;
      char v41 = 0;
      uint64_t v42 = 0;
      char v43 = 0;
      memset(v28, 0, sizeof(v28));
      int8x16_t v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v28, 0);
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v28, *(unsigned int *)(v3 + 36));
      int v29 = 33;
      uint64_t v7 = (_anonymous_namespace_ *)re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v37, (re::DynamicString *)v28);
      memset(v23, 0, sizeof(v23));
      int v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v23, 0);
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v23, *(unsigned __int8 *)(v3 + 34));
      int v24 = 65589;
      re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v37, (re::DynamicString *)v23);
      ComputePipelineState = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)v33);
      BOOL v10 = NS::SharedPtr<MTL::Texture>::operator=((void **)(v3 + 8), ComputePipelineState);
      if (*(void *)(v3 + 8))
      {
        *(unsigned char *)(v3 + 33) = 1;
      }
      else
      {
        unint64_t v11 = *re::graphicsLogObjects((re *)v10);
        BOOL v10 = (void **)os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
        if (v10)
        {
          *(_WORD *)simd_float3x3 buf = 0;
          _os_log_impl(&dword_233120000, v11, OS_LOG_TYPE_DEFAULT, "Bounding box make pipeline function failed, disabling GPU bounding box calculations.", buf, 2u);
        }
      }
      if (*(unsigned char *)(v3 + 33))
      {
        id v12 = a2[23];
        if (v12)
        {
          *(void *)simd_float3x3 buf = 0;
          uint64_t v45 = 0;
          uint64_t v46 = 0;
          [v12 maxThreadsPerThreadgroup];
          unint64_t v13 = *(void *)buf;
        }
        else
        {
          unint64_t v13 = 0;
        }
        id v15 = objc_msgSend(*(id *)(v3 + 8), sel_maxTotalThreadsPerThreadgroup);
        if ((unint64_t)v15 >= v13) {
          unint64_t v16 = v13;
        }
        else {
          unint64_t v16 = (unint64_t)v15;
        }
        *(void *)(v3 + 16) = v16;
        uint64_t v17 = [a2[23] maxThreadgroupMemoryLength];
        unint64_t v18 = (v17 - (void)objc_msgSend(*(id *)(v3 + 8), sel_staticThreadgroupMemoryLength)) & 0xFFFFFFFFFFFFFF00;
        unint64_t v19 = v18 >> 5;
        BOOL v20 = *(void **)(v3 + 8);
        if (v18 >> 5 >= *(void *)(v3 + 16)) {
          unint64_t v19 = *(void *)(v3 + 16);
        }
        *(void *)(v3 + 16) = v19;
        *(void *)(v3 + 24) = v18;
        id v21 = objc_msgSend(v20, sel_threadExecutionWidth);
        unint64_t v22 = (void)objc_msgSend(*(id *)(v3 + 8), sel_threadExecutionWidth) * (void)v21;
        if (v22 >= *(void *)(v3 + 16)) {
          unint64_t v22 = *(void *)(v3 + 16);
        }
        *(void *)(v3 + 16) = v22;
      }
      else
      {
        unsigned __int16 v14 = *re::graphicsLogObjects((re *)v10);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)simd_float3x3 buf = 0;
          _os_log_impl(&dword_233120000, v14, OS_LOG_TYPE_DEFAULT, "Could not create GPU Bounding box reduction pipeline. Using CPU fallback", buf, 2u);
        }
      }
      if (v25)
      {
        if (v26)
        {
          (*(void (**)(void))(*(void *)v25 + 40))();
          uint64_t v26 = 0;
          uint64_t v27 = 0;
        }
        uint64_t v25 = 0;
      }
      if (*(void *)&v23[0] && (BYTE8(v23[0]) & 1) != 0) {
        (*(void (**)(void))(**(void **)&v23[0] + 40))();
      }
      if (v30)
      {
        if (v31)
        {
          (*(void (**)(void))(*(void *)v30 + 40))();
          uint64_t v31 = 0;
          uint64_t v32 = 0;
        }
        uint64_t v30 = 0;
      }
      if (*(void *)&v28[0] && (BYTE8(v28[0]) & 1) != 0) {
        (*(void (**)(void))(**(void **)&v28[0] + 40))();
      }
      re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v37);
      this = v36[0];
      if (v36[0])
      {
        if (v36[1]) {
          this = (*(uint64_t (**)(void))(*(void *)v36[0] + 40))();
        }
        memset(v36, 0, sizeof(v36));
      }
      if (v33[0])
      {
        this = v34;
        if (v34)
        {
          if (v35) {
            return (*(uint64_t (**)(void))(*(void *)v34 + 40))();
          }
        }
      }
    }
  }
  return this;
}

double re::BoundingBoxCalculation::addDeformationInstance@<D0>(re::BoundingBoxCalculation *this@<X0>, unsigned char *a2@<X1>, uint64_t a3@<X8>)
{
  if (*a2)
  {
    BOOL v3 = 0;
  }
  else if (*((unsigned char *)this + 32))
  {
    BOOL v3 = *((unsigned char *)this + 33) != 0;
  }
  else
  {
    BOOL v3 = 1;
  }
  *(void *)a3 = 0xFFFFFFFFLL;
  *(void *)&double result = 2;
  *(_OWORD *)(a3 + 8) = xmmword_234377680;
  *(unsigned char *)(a3 + 24) = v3;
  *(void *)(a3 + 32) = -1;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  return result;
}

uint64_t re::BoundingBoxCalculation::allocateBuffers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7 = *a4;
  *(unsigned char *)(a5 + 32) = 0;
  unint64_t v8 = a4[6];
  unint64_t v39 = v8;
  if (v8)
  {
    if (!is_mul_ok(v8, 0x28uLL) || 40 * v8 >= 0xFFFFFFFFFFFFFFF0) {
      goto LABEL_31;
    }
    uint64_t v9 = (*(uint64_t (**)(void, unint64_t, void))(**(void **)(a2 + 24) + 32))(*(void *)(a2 + 24), (40 * v8 + 16) | 7, 0);
    BOOL v10 = (void *)((v9 + 23) & 0xFFFFFFFFFFFFFFF8);
    *(v10 - 2) = v8;
    *(v10 - 1) = v9;
    bzero(v10, 40 * v8);
  }
  else
  {
    BOOL v10 = 0;
  }
  uint64_t v11 = *(void *)(v7 + 48);
  if (!v11) {
    return (uint64_t)v10;
  }
  unint64_t v12 = 0;
  while (1)
  {
    unint64_t v8 = *(void *)(re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v7 + 8, v12) + 8);
    uint64_t v13 = re::BucketArray<re::ActiveDeformation,8ul>::operator[](a4[1], v8);
    unint64_t v15 = a4[6];
    if (v15 <= v8) {
      break;
    }
    uint64_t v16 = v13;
    uint64_t v17 = (void *)(a4[5] + 312 * v8);
    LOBYTE(v40) = 1;
    re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v17, 1u);
    unsigned int v18 = *(_DWORD *)(v17[8]
                    + 32
                    * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v17 + 7, (unsigned __int8 *)&v40)+ 20);
    LOBYTE(v40) = 1;
    re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v17, 1u);
    uint64_t v19 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v17 + 15, (unsigned __int8 *)&v40);
    id v21 = *(uint64_t ***)(*(void *)(v16 + 352) + 56);
    if (v21)
    {
      if (v39 <= v8) {
        goto LABEL_30;
      }
      uint64_t v22 = v18 / *(unsigned __int16 *)(v17[16] + 20 * v19 + 4);
      id v23 = &v10[5 * v8];
      re::FrameContext::perFrameAlloc((re::FrameContext *)a2, 8uLL, 4uLL, (uint64_t)&v40);
      uint64_t v24 = v40;
      uint64_t v25 = v42;
      uint64_t v26 = v41;
      *(void *)(v40 + v41) = v22 | (v8 << 32);
      *id v23 = v24;
      v23[1] = v26;
      _OWORD v23[2] = v25;
      uint64_t v27 = *v21;
      uint64_t v28 = **v21;
      if (v28)
      {
        uint64_t v29 = (v28 - 1) & 7;
        if (1 - v28 >= 0) {
          uint64_t v29 = -((1 - v28) & 7);
        }
        unint64_t v30 = v27[v29 + 1] & 0xFFFFFFFFFFFFFFFLL;
        uint64_t v31 = *(void *)(a2 + 32);
        uint64_t v32 = v31 & 0xFFFFFFFFFFFFFFFLL;
        if (v30 != 0xFFFFFFFFFFFFFFFLL)
        {
          if (v32 == 0xFFFFFFFFFFFFFFFLL || v30 != v32) {
            goto LABEL_22;
          }
          do
LABEL_20:
            uint64_t v33 = --v28 & 7;
          while ((v27[v33 + 1] & 0xFFFFFFFFFFFFFFFuLL) > v30);
          goto LABEL_26;
        }
      }
      else
      {
        uint64_t v31 = *(void *)(a2 + 32);
        uint64_t v32 = v31 & 0xFFFFFFFFFFFFFFFLL;
      }
      unint64_t v30 = 0xFFFFFFFFFFFFFFFLL;
      if (v32 == 0xFFFFFFFFFFFFFFFLL) {
        goto LABEL_20;
      }
LABEL_22:
      *uint64_t v27 = v28 + 1;
      BOOL v34 = -v28 < 0;
      uint64_t v35 = -v28 & 7;
      uint64_t v36 = v28 & 7;
      if (v34) {
        uint64_t v33 = v36;
      }
      else {
        uint64_t v33 = -v35;
      }
      v27[v33 + 1] = v31;
LABEL_26:
      long long v37 = (char *)&v10[5 * v8];
      *((void *)v37 + 3) = v27[v33 + 9];
      *((void *)v37 + 4) = 0x2000000000;
    }
    if (++v12 == v11) {
      return (uint64_t)v10;
    }
  }
  re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v15);
  _os_crash();
  __break(1u);
LABEL_30:
  re::internal::assertLog((re::internal *)6, v20, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v8, v39);
  _os_crash();
  __break(1u);
LABEL_31:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 40, v8);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::BoundingBoxCalculation::deformGPU(uint64_t a1, uint64_t a2, void **this, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v8 = *a4;
  unint64_t v30 = a4[6];
  re::mtl::ComputeCommandEncoder::pushDebugGroup(this, (re::ns *)"Perform Bounding Box Reduction Calculation");
  uint64_t v29 = *(void *)(v8 + 48);
  if (!v29) {
    return [*this popDebugGroup];
  }
  unint64_t v9 = 0;
  uint64_t v27 = v4;
  uint64_t v28 = v8 + 8;
  uint64_t v26 = a2;
  while (1)
  {
    uint64_t v10 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v28, v9);
    unint64_t v12 = *(void *)(v10 + 8);
    if (v30 <= v12) {
      break;
    }
    uint64_t v13 = a2 + 40 * v12;
    if (*(_DWORD *)(v13 + 12))
    {
      unint64_t v14 = v4[6];
      if (v14 <= v12) {
        goto LABEL_16;
      }
      uint64_t v15 = v4[5] + 312 * v12;
      v33.i8[0] = 1;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized(v15, 1u);
      unint64_t v16 = (unint64_t)objc_msgSend(*(id *)(*(void *)(v15 + 64)+ 32* re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v15 + 56), (unsigned __int8 *)&v33)+ 24), sel_length)/ *(unsigned int *)(a1 + 40);
      unsigned int v17 = sqrtf((float)v16);
      if (*(unsigned char *)(a1 + 34)) {
        int v18 = v16;
      }
      else {
        int v18 = v17;
      }
      unsigned int v19 = objc_msgSend(*(id *)(a1 + 8), sel_threadExecutionWidth);
      unsigned int v20 = (v19 + v18 - 1) & -v19;
      unsigned int v21 = *(_DWORD *)(a1 + 16);
      if (v20 >= v21) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = v20;
      }
      [*this setComputePipelineState:*(void *)(a1 + 8)];
      v33.i8[0] = 1;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized(v15, 1u);
      uint64_t v23 = *(void *)(*(void *)(v15 + 64)
                      + 32
                      * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v15 + 56), (unsigned __int8 *)&v33)+ 24);
      v33.i8[0] = 1;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized(v15, 1u);
      a2 = v26;
      objc_msgSend(*this, "setBuffer:offset:atIndex:", v23, *(unsigned int *)(*(void *)(v15 + 64)+ 32* re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v15 + 56), (unsigned __int8 *)&v33)+ 16), 0);
      [*this setBuffer:*(void *)(v13 + 16) offset:*(unsigned int *)(v13 + 8) atIndex:1];
      [*this setBuffer:*(void *)(a2 + 40 * v12 + 24) offset:*(unsigned int *)(a2 + 40 * v12 + 32) atIndex:2];
      [*this setThreadgroupMemoryLength:16 * v22 atIndex:0];
      [*this setThreadgroupMemoryLength:16 * v22 atIndex:1];
      uint64_t v24 = *this;
      int64x2_t v32 = vdupq_n_s64(1uLL);
      int64x2_t v33 = v32;
      uint64_t v34 = 1;
      uint64_t v31 = v22;
      uint64_t v4 = v27;
      [v24 dispatchThreadgroups:&v33 threadsPerThreadgroup:&v31];
    }
    if (v29 == ++v9) {
      return [*this popDebugGroup];
    }
  }
  re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, *(void *)(v10 + 8), v30);
  _os_crash();
  __break(1u);
LABEL_16:
  re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v12, v14);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void re::BoundingBoxCalculation::deformCPU(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v34 = *(void *)(*a3 + 48);
  if (!v34) {
    return;
  }
  BOOL v3 = a3;
  unint64_t v4 = 0;
  unint64_t v32 = a3[6];
  uint64_t v33 = *a3 + 8;
  int32x4_t v35 = vdupq_n_s32(0x7F800000u);
  while (1)
  {
    uint64_t v5 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v33, v4);
    unint64_t v7 = *(void *)(v5 + 8);
    unint64_t v8 = v3[6];
    if (v8 <= v7) {
      break;
    }
    unint64_t v9 = (void *)(v3[5] + 312 * v7);
    unsigned __int8 v40 = 1;
    re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v9, 1u);
    uint64_t v10 = v9 + 8;
    unsigned int v11 = *(_DWORD *)(v9[8]
                    + 32
                    * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v9 + 7, &v40)+ 20);
    unsigned __int8 v41 = 1;
    re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v9, 1u);
    unsigned int v12 = *(unsigned __int16 *)(v9[16]
                              + 20
                              * re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v9 + 15, &v41)+ 4);
    unsigned __int8 v42 = 1;
    re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v9, 1u);
    uint64_t v14 = *(unsigned __int8 *)(v9[16]
                             + 20
                             * re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v9 + 15, &v42)+ 16);
    if (v14 > 0x19)
    {
      if (v14 == 26) {
        goto LABEL_13;
      }
      if (v14 != 30) {
        goto LABEL_26;
      }
    }
    else if (v14 == 8)
    {
    }
    else
    {
      if (v14 != 11) {
        goto LABEL_26;
      }
    }
    unint64_t v16 = v15;
LABEL_13:
    v43[0] = 1;
    re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v9, 1u);
    uint64_t v17 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v9 + 7, v43);
    v19.i64[0] = 0x7F0000007FLL;
    v19.i64[1] = 0x7F0000007FLL;
    float32x4_t v20 = (float32x4_t)v35;
    if (v11 >= v12)
    {
      uint64_t v21 = 0;
      uint64_t v22 = *(void *)(*v10 + 32 * v17 + 8) + *(unsigned int *)(*v10 + 32 * v17 + 16);
      if (v11 / v12 <= 1) {
        uint64_t v23 = 1;
      }
      else {
        uint64_t v23 = v11 / v12;
      }
      float32x4_t v20 = (float32x4_t)v35;
      do
      {
        float32x4_t v36 = v20;
        float32x4_t v38 = v19;
        uint64_t v24 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v22, v21);
        float32x4_t v25 = v36;
        float32x4_t v26 = v38;
        v27.i64[0] = v24;
        v27.i64[1] = v18;
        v25.i32[3] = 0;
        float32x4_t v20 = vminnmq_f32(v25, v27);
        v26.i32[3] = 0;
        float32x4_t v19 = vmaxnmq_f32(v26, v27);
        ++v21;
      }
      while (v23 != v21);
    }
    if (v32 <= v7) {
      goto LABEL_25;
    }
    uint64_t v28 = *(void **)(a2 + 40 * v7 + 24);
    if (v28)
    {
      float32x4_t v39 = v19;
      float32x4_t v37 = v20;
      uint64_t v29 = (float32x4_t *)((char *)objc_msgSend(v28, sel_contents) + *(unsigned int *)(a2 + 40 * v7 + 32));
      *uint64_t v29 = v37;
      v29[1] = v39;
    }
    ++v4;
    BOOL v3 = a3;
    if (v4 == v34) {
      return;
    }
  }
  re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, *(void *)(v5 + 8), v8);
  _os_crash();
  __break(1u);
LABEL_25:
  re::internal::assertLog((re::internal *)6, v18, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, v32);
  _os_crash();
  __break(1u);
LABEL_26:
  re::internal::assertLog((re::internal *)5, v13, "assertion failure: '%s' (%s:line %i) Unsupported packed vertex format: %u.", "!\"Unreachable code\"", "vertexUnpackFunctionForFormat", 54, v14);
  _os_crash();
  __break(1u);
}

void re::BoundingBoxCalculation::~BoundingBoxCalculation(re::BoundingBoxCalculation *this)
{
  unint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {

    *((void *)this + 1) = 0;
  }
}

{
  void *v2;
  uint64_t vars8;

  unint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {

    *((void *)this + 1) = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

double re::anonymous namespace'::unpackHalf3Data(re::_anonymous_namespace_ *this, const void *a2, float16x4_t a3)
{
  BOOL v3 = (char *)this + 8 * (void)a2;
  a3.i32[0] = *(_DWORD *)v3;
  *(void *)&double result = vcvtq_f32_f16(a3).u64[0];
  _H1 = *((_WORD *)v3 + 2);
  __asm { FCVT            S1, H1 }
  return result;
}

int8x8_t re::anonymous namespace'::unpackChar3NormalizedData(re::_anonymous_namespace_ *this, const void *a2)
{
  unint64_t v2 = (char *)this + 4 * (void)a2;
  v3.i32[0] = *v2;
  v3.i32[1] = v2[1];
  float32x2_t v4 = vdiv_f32(vcvt_f32_s32(v3), (float32x2_t)vdup_n_s32(0x42FE0000u));
  __asm { FMOV            V1.2S, #1.0 }
  return vbsl_s8((int8x8_t)vcgt_f32(v4, _D1), (int8x8_t)_D1, (int8x8_t)v4);
}

float32x2_t re::anonymous namespace'::unpackUChar3NormalizedData(re::_anonymous_namespace_ *this, const void *a2)
{
  unint64_t v2 = (unsigned __int8 *)this + 4 * (void)a2;
  v3.i32[0] = *v2;
  v3.i32[1] = v2[1];
  return vdiv_f32(vcvt_f32_u32(v3), (float32x2_t)vdup_n_s32(0x437F0000u));
}

uint64_t re::anonymous namespace'::unpackFloat3Data(re::_anonymous_namespace_ *this, const void *a2)
{
  return *(void *)((char *)this + 12 * (void)a2);
}

uint64_t re::CombinedDynamicFunctionConstants::hash(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = 0x9E3779B97F4A7C17;
  uint64_t v3 = 0x9E3779B97F4A7C17;
  if (*(void *)a1) {
    uint64_t v3 = *(void *)(*(void *)a1 + 48) - 0x61C8864680B583E9;
  }
  unint64_t v4 = *((void *)a1 + 1);
  if (v4) {
    unint64_t v4 = *(void *)(v4 + 48);
  }
  uint64_t v5 = *((void *)a1 + 2);
  if (v5) {
    uint64_t v2 = *(void *)(v5 + 48) - 0x61C8864680B583E9;
  }
  uint64_t v6 = a1 + 24;
  int v8 = *a2;
  unint64_t v7 = a2 + 1;
  if (v8) {
    uint64_t v6 = v7;
  }
  unint64_t v9 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * *v6) ^ ((0xBF58476D1CE4E5B9 * *v6) >> 27));
  unint64_t v10 = (v3 + ((v9 ^ (v9 >> 31)) << 6) + ((v9 ^ (v9 >> 31)) >> 2)) ^ v9 ^ (v9 >> 31);
  return ((((v4 >> 2) + (v4 << 6) + v2) ^ v4) - 0x61C8864680B583E9 + (v10 << 6) + (v10 >> 2)) ^ v10;
}

void re::CombinedDynamicFunctionConstants::combinedMap(uint64_t *a1@<X0>, unsigned __int8 *a2@<X1>, _anonymous_namespace_ *a3@<X8>)
{
  uint64_t v6 = 0;
  uint64_t v29 = *MEMORY[0x263EF8340];
  *((_OWORD *)a3 + 2) = 0u;
  *((_OWORD *)a3 + 3) = 0u;
  *(_OWORD *)a3 = 0u;
  *((_OWORD *)a3 + 1) = 0u;
  int8x16_t v27 = vextq_s8(*(int8x16_t *)(a1 + 1), *(int8x16_t *)(a1 + 1), 8uLL);
  uint64_t v28 = *a1;
  int8x16_t v7 = (int8x16_t)xmmword_2343680E0;
  do
  {
    int v8 = (uint64_t *)v27.i64[v6];
    if (v8)
    {
      uint64_t v24 = v27.i64[v6];
      uint64_t v25 = 0;
      unint64_t v9 = v8[2];
      if (v9 >= 0x10)
      {
        uint64_t v10 = 0;
        uint64_t v11 = *v8;
        unint64_t v12 = v9 >> 4;
        while (1)
        {
          unsigned __int16 v13 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v11 + v10)), v7)))), (int8x8_t)0x3830282018100800).u16[0];
          uint64_t v25 = (unsigned __int16)~v13;
          if (v13 != 0xFFFF) {
            break;
          }
          v10 += 16;
          if (!--v12) {
            goto LABEL_10;
          }
        }
        uint64_t v14 = __clz(__rbit64((unsigned __int16)~v13)) + v10;
        for (i = v14; i != -1; uint64_t v14 = i)
        {
          re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::addOrReplace(a3, (void *)(*(void *)(v24 + 8) + 16 * v14), (_DWORD *)(*(void *)(v24 + 8) + 16 * v14 + 8));
          re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(&v24);
          int8x16_t v7 = (int8x16_t)xmmword_2343680E0;
        }
      }
    }
LABEL_10:
    ++v6;
  }
  while (v6 != 3);
  {
    re::CombinedDynamicFunctionConstants::combinedMap(re::Optional<re::FunctionConstantRenderFeatures>)const::kRenderFeatureHashes[0] = re::hashString((re *)"EnableDitherFade", v20);
    qword_2687A0B48 = re::hashString((re *)"EnableClipping", v21);
    qword_2687A0B50 = re::hashString((re *)"RenderForBlur", v22);
    unk_2687A0B58 = 0;
    qword_2687A0B60 = 0;
    unk_2687A0B68 = 0;
  }
  uint64_t v15 = 0;
  unint64_t v16 = (unsigned __int8 *)(a1 + 3);
  int v18 = *a2;
  uint64_t v17 = a2 + 1;
  if (v18) {
    unint64_t v16 = v17;
  }
  unsigned int v19 = *v16;
  do
  {
    if ((v19 >> v15))
    {
      uint64_t v24 = re::CombinedDynamicFunctionConstants::combinedMap(re::Optional<re::FunctionConstantRenderFeatures>)const::kRenderFeatureHashes[v15];
      int v23 = 1;
      re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::addOrReplace(a3, &v24, &v23);
    }
    ++v15;
  }
  while (v15 != 6);
}

uint64_t re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::addOrReplace(_anonymous_namespace_ *a1, void *a2, _DWORD *a3)
{
  uint64_t v6 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(a1, a2);
  if (v6 == -1)
  {
    return re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::internalAdd(a1, a2, a3);
  }
  else
  {
    uint64_t v7 = v6;
    re::HashBrown<re::WeakStringID,unsigned int,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<unsigned int>,false>::updateKvpsHash((uint64_t)a1, *((void *)a1 + 1) + 16 * v6);
    uint64_t v8 = *((void *)a1 + 1) + 16 * v7;
    *(_DWORD *)(v8 + 8) = *a3;
    re::HashBrown<re::WeakStringID,unsigned int,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<unsigned int>,false>::updateKvpsHash((uint64_t)a1, v8);
    return *((void *)a1 + 1) + 16 * v7 + 8;
  }
}

uint64_t re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::addOrReplace(_anonymous_namespace_ *a1, void *a2, int *a3)
{
  uint64_t v6 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(a1, a2);
  if (v6 == -1)
  {
    return re::HashBrown<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,re::Hash<unsigned int>,false>::internalAdd(a1, a2, a3);
  }
  else
  {
    uint64_t v7 = v6;
    re::HashBrown<re::WeakStringID,unsigned int,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<unsigned int>,false>::updateKvpsHash((uint64_t)a1, *((void *)a1 + 1) + 16 * v6);
    uint64_t v8 = *((void *)a1 + 1) + 16 * v7;
    *(_DWORD *)(v8 + 8) = *a3;
    re::HashBrown<re::WeakStringID,unsigned int,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<unsigned int>,false>::updateKvpsHash((uint64_t)a1, v8);
    return *((void *)a1 + 1) + 16 * v7 + 8;
  }
}

void re::MeshManager::init(re::MeshManager *this, id *a2, int a3, int a4)
{
  *(void *)this = a2;
  id v7 = (id)[a2[23] newCommandQueue];

  uint64_t v8 = (void *)*((void *)this + 23);
  *((void *)this + 23) = v7;

  re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)this + 1, 0);
  ++*((_DWORD *)this + 8);
  *((_DWORD *)this + 13) = a3;
  re::DataArray<re::MeshModel>::allocBlock((unsigned int *)this + 2);
  uint64_t v11 = (char *)this + 72;
  re::DynamicArray<re::RigNodeConstraint>::setCapacity(v11, 0);
  ++*((_DWORD *)v11 + 6);
  *((_DWORD *)v11 + 11) = a4;
  re::DataArray<re::MeshInstance>::allocBlock((unsigned int *)v11);
}

unint64_t re::DataArray<re::MeshModel>::create<re::MeshModel>(uint64_t a1, uint64_t *a2)
{
  int v4 = *(_DWORD *)(a1 + 56);
  if ((v4 + 1) >> 24) {
    int v5 = 1;
  }
  else {
    int v5 = v4 + 1;
  }
  *(_DWORD *)(a1 + 56) = v5;
  uint64_t v6 = *(unsigned __int16 *)(a1 + 52);
  unint64_t v7 = *(unsigned __int16 *)(a1 + 54);
  if (v6 == 0xFFFF && v7 == 0xFFFF)
  {
    if (*(_DWORD *)(a1 + 48) >= *(_DWORD *)(a1 + 44)) {
      re::DataArray<re::MeshModel>::allocBlock((unsigned int *)a1);
    }
    uint64_t v11 = *(void *)(a1 + 16);
    unint64_t v7 = (unsigned __int16)(v11 - 1);
    if (v11)
    {
      uint64_t v6 = *(unsigned int *)(a1 + 48);
      if (v6 < 0x10000)
      {
        unint64_t v12 = (void *)(*(void *)(a1 + 32) + 16 * v7);
        *(_DWORD *)(a1 + 48) = v6 + 1;
        *(_DWORD *)(v12[1] + 4 * v6) = *(_DWORD *)(a1 + 56);
        uint64_t v10 = (_DWORD *)(*v12 + 816 * v6);
        goto LABEL_15;
      }
LABEL_18:
      re::internal::assertLog((re::internal *)5, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v6, v14, v15);
      _os_crash();
      __break(1u);
    }
LABEL_17:
    uint64_t v14 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(void *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 789;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_18;
  }
  if (*(void *)(a1 + 16) <= v7)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_17;
  }
  unint64_t v9 = (void *)(*(void *)(a1 + 32) + 16 * v7);
  *(_DWORD *)(v9[1] + 4 * v6) = v5;
  uint64_t v10 = (_DWORD *)(*v9 + 816 * v6);
  *(_DWORD *)(a1 + 52) = *v10;
LABEL_15:
  ++*(_DWORD *)(a1 + 40);
  re::MeshModel::MeshModel((uint64_t)v10, a2);
  return (v7 << 16) | ((unint64_t)(*(_DWORD *)(a1 + 56) & 0xFFFFFF) << 32) | v6;
}

unint64_t re::DataArray<re::MeshInstance>::create<re::MeshInstance>(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 56);
  if ((v4 + 1) >> 24) {
    int v5 = 1;
  }
  else {
    int v5 = v4 + 1;
  }
  *(_DWORD *)(a1 + 56) = v5;
  uint64_t v6 = *(unsigned __int16 *)(a1 + 52);
  unint64_t v7 = *(unsigned __int16 *)(a1 + 54);
  if (v6 == 0xFFFF && v7 == 0xFFFF)
  {
    if (*(_DWORD *)(a1 + 48) >= *(_DWORD *)(a1 + 44)) {
      re::DataArray<re::MeshInstance>::allocBlock((unsigned int *)a1);
    }
    uint64_t v11 = *(void *)(a1 + 16);
    unint64_t v7 = (unsigned __int16)(v11 - 1);
    if (v11)
    {
      uint64_t v6 = *(unsigned int *)(a1 + 48);
      if (v6 < 0x10000)
      {
        unint64_t v12 = (void *)(*(void *)(a1 + 32) + 16 * v7);
        *(_DWORD *)(a1 + 48) = v6 + 1;
        *(_DWORD *)(v12[1] + 4 * v6) = *(_DWORD *)(a1 + 56);
        uint64_t v10 = *v12 + 144 * v6;
        goto LABEL_15;
      }
LABEL_18:
      re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v6, v20, v21);
      _os_crash();
      __break(1u);
    }
LABEL_17:
    uint64_t v20 = 0;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v21) = 136315906;
    *(void *)((char *)&v21 + 4) = "operator[]";
    WORD6(v21) = 1024;
    HIWORD(v21) = 789;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_18;
  }
  if (*(void *)(a1 + 16) <= v7)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_17;
  }
  unint64_t v9 = (void *)(*(void *)(a1 + 32) + 16 * v7);
  *(_DWORD *)(v9[1] + 4 * v6) = v5;
  uint64_t v10 = *v9 + 144 * v6;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)v10;
LABEL_15:
  ++*(_DWORD *)(a1 + 40);
  uint64_t v13 = *(void *)a2;
  *(void *)uint64_t v10 = *(void *)v10 & 0xFFFFFFFFFFFFFFFELL | *(void *)a2 & 1;
  *(void *)uint64_t v10 = *(void *)a2 & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
  *(void *)(v10 + 8) = *(void *)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = "";
  long long v14 = *(_OWORD *)(a2 + 32);
  long long v16 = *(_OWORD *)(a2 + 64);
  long long v15 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v10 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v10 + 64) = v16;
  *(_OWORD *)(v10 + 32) = v14;
  *(_OWORD *)(v10 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v10 + 80) = v15;
  *(void *)(v10 + 104) = 0;
  *(void *)(v10 + 112) = 0;
  *(void *)(v10 + 96) = 0;
  *(void *)(v10 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = 0;
  *(void *)(v10 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = 0;
  uint64_t v17 = *(void *)(v10 + 112);
  *(void *)(v10 + 112) = *(void *)(a2 + 112);
  *(void *)(a2 + 112) = v17;
  *(void *)(v10 + 120) = 0;
  *(void *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = 0;
  *(void *)(v10 + 120) = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = 0;
  *(void *)(v10 + 128) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = 0;
  uint64_t v18 = *(void *)(v10 + 136);
  *(void *)(v10 + 136) = *(void *)(a2 + 136);
  *(void *)(a2 + 136) = v18;
  return (v7 << 16) | ((unint64_t)(*(_DWORD *)(a1 + 56) & 0xFFFFFF) << 32) | v6;
}

uint64_t (***re::MeshManager::destroyModel(uint64_t a1, uint64_t a2))(void)
{
  _OWORD v7[5] = *MEMORY[0x263EF8340];
  ValidAllocator = re::getValidAllocator((re *)(*(void *)(*(void *)(*(void *)a1 + 136) + 24) & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)*(void *)(*(void *)(*(void *)a1 + 136) + 16) << 60)));
  int v5 = *(void **)a1;
  char v7[2] = a2;
  v7[3] = ValidAllocator;
  v7[0] = &unk_26E713FF8;
  v7[1] = a1;
  v7[4] = v7;
  re::RenderManager::addDelayedDestructor(v5, (uint64_t)v7);
  return re::MoveOnlyFunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v7);
}

uint64_t (***re::MeshManager::destroyInstance(uint64_t a1, uint64_t a2))(void)
{
  _OWORD v7[5] = *MEMORY[0x263EF8340];
  ValidAllocator = re::getValidAllocator((re *)(*(void *)(*(void *)(*(void *)a1 + 136) + 24) & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)*(void *)(*(void *)(*(void *)a1 + 136) + 16) << 60)));
  int v5 = *(void **)a1;
  char v7[2] = a2;
  v7[3] = ValidAllocator;
  v7[0] = &unk_26E714048;
  v7[1] = a1;
  v7[4] = v7;
  re::RenderManager::addDelayedDestructor(v5, (uint64_t)v7);
  return re::MoveOnlyFunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v7);
}

uint64_t (***re::MeshManager::destroyCollection(uint64_t (***result)(void), void *a2))(void)
{
  uint64_t v3 = (uint64_t)result;
  uint64_t v4 = a2[2];
  if (v4)
  {
    int v5 = (uint64_t *)a2[4];
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t v7 = *v5++;
      double result = re::MeshManager::destroyInstance(v3, v7);
      v6 -= 8;
    }
    while (v6);
  }
  uint64_t v8 = a2[7];
  if (v8)
  {
    unint64_t v9 = (uint64_t *)a2[9];
    uint64_t v10 = 8 * v8;
    do
    {
      uint64_t v11 = *v9++;
      double result = re::MeshManager::destroyModel(v3, v11);
      v10 -= 8;
    }
    while (v10);
  }
  return result;
}

uint64_t re::MeshManager::findMaxMaterialIndex(uint64_t a1, void *a2)
{
  uint64_t v4 = a2[7];
  if (v4)
  {
    int v5 = (void *)a2[9];
    uint64_t v6 = &v5[v4];
    uint64_t v7 = 0xFFFFFFFFLL;
    do
    {
      uint64_t v8 = re::DataArray<re::MeshModel>::get(a1 + 8, *v5);
      uint64_t v9 = *(void *)(v8 + 56);
      if (v9)
      {
        uint64_t v10 = 560 * v9;
        uint64_t v11 = (unsigned __int16 *)(*(void *)(v8 + 64) + 474);
        do
        {
          if ((int)v7 <= *v11) {
            uint64_t v7 = *v11;
          }
          else {
            uint64_t v7 = v7;
          }
          v11 += 280;
          v10 -= 560;
        }
        while (v10);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  else
  {
    uint64_t v7 = 0xFFFFFFFFLL;
  }
  uint64_t v12 = a2[2];
  if (v12)
  {
    uint64_t v13 = (void *)a2[4];
    long long v14 = &v13[v12];
    uint64_t v15 = a1 + 72;
    do
    {
      uint64_t v16 = re::DataArray<re::MeshInstance>::get(v15, *v13);
      uint64_t v17 = *(void *)(v16 + 104);
      if (v17)
      {
        uint64_t v18 = *(int **)(v16 + 112);
        uint64_t v19 = 4 * v17;
        do
        {
          int v21 = *v18++;
          unsigned int v20 = v21;
          if ((int)v7 <= v21) {
            uint64_t v7 = v20;
          }
          else {
            uint64_t v7 = v7;
          }
          v19 -= 4;
        }
        while (v19);
      }
      ++v13;
    }
    while (v13 != v14);
  }
  return v7;
}

void re::internal::MoveOnlyCallable<re::MeshManager::destroyModel(re::DataArrayHandle<re::MeshModel>)::$_0,void ()(void)>::~MoveOnlyCallable()
{
}

void re::internal::MoveOnlyCallable<re::MeshManager::destroyModel(re::DataArrayHandle<re::MeshModel>)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = re::DataArray<re::MeshModel>::tryGet(v2 + 8, *(void *)(a1 + 16));
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 56);
    if (v4)
    {
      int v5 = *(void **)(v3 + 64);
      uint64_t v6 = &v5[70 * v4];
      do
      {
        if (*v5)
        {
          if (objc_isUniquelyReferenced())
          {
            uint64_t v7 = *v5 + 24;
            unint64_t v8 = re::Hash<re::CachedStandardVertexFetchFunctionKey>::operator()((uint64_t)&v25, v7);
            if (*(void *)(v2 + 136))
            {
              unint64_t v9 = v8 % *(unsigned int *)(v2 + 160);
              uint64_t v10 = *(unsigned int *)(*(void *)(v2 + 144) + 4 * v9);
              if (v10 != 0x7FFFFFFF)
              {
                if (re::EqualTo<re::CachedStandardVertexFetchFunctionKey>::operator()((uint64_t)&v26, *(void *)(v2 + 152) + 200 * v10 + 12, v7))
                {
                  *(_DWORD *)(*(void *)(v2 + 144) + 4 * v9) = *(_DWORD *)(*(void *)(v2 + 152)
                                                                          + 200 * v10
                                                                          + 8) & 0x7FFFFFFF;
LABEL_13:
                  uint64_t v13 = *(void *)(v2 + 152);
                  uint64_t v14 = v13 + 200 * v10;
                  int v17 = *(_DWORD *)(v14 + 8);
                  uint64_t v15 = (int *)(v14 + 8);
                  int v16 = v17;
                  if (v17 < 0)
                  {
                    int *v15 = v16 & 0x7FFFFFFF;
                    uint64_t v18 = v13 + 200 * v10;
                    uint64_t v21 = *(void *)(v18 + 192);
                    unsigned int v20 = (void *)(v18 + 192);
                    uint64_t v19 = v21;
                    if (v21)
                    {

                      *unsigned int v20 = 0;
                    }
                  }
                  uint64_t v22 = *(void *)(v2 + 152) + 200 * v10;
                  int v23 = *(_DWORD *)(v2 + 176);
                  *(_DWORD *)(v22 + 8) = *(_DWORD *)(v22 + 8) & 0x80000000 | *(_DWORD *)(v2 + 172);
                  --*(_DWORD *)(v2 + 164);
                  *(_DWORD *)(v2 + 172) = v10;
                  *(_DWORD *)(v2 + 176) = v23 + 1;
                }
                else
                {
                  while (1)
                  {
                    uint64_t v11 = v10;
                    uint64_t v12 = *(void *)(v2 + 152);
                    uint64_t v10 = *(_DWORD *)(v12 + 200 * v10 + 8) & 0x7FFFFFFF;
                    if (v10 == 0x7FFFFFFF) {
                      break;
                    }
                    if (re::EqualTo<re::CachedStandardVertexFetchFunctionKey>::operator()((uint64_t)&v26, v12 + 200 * v10 + 12, v7))
                    {
                      *(_DWORD *)(*(void *)(v2 + 152) + 200 * v11 + 8) = *(_DWORD *)(*(void *)(v2 + 152)
                                                                                     + 200 * v11
                                                                                     + 8) & 0x80000000 | *(_DWORD *)(*(void *)(v2 + 152) + 200 * v10 + 8) & 0x7FFFFFFF;
                      goto LABEL_13;
                    }
                  }
                }
              }
            }
          }
        }
        v5 += 70;
      }
      while (v5 != v6);
    }
    unint64_t v24 = *(void *)(a1 + 16);
    re::DataArray<re::MeshModel>::destroy(v2 + 8, v24);
  }
}

uint64_t re::internal::MoveOnlyCallable<re::MeshManager::destroyModel(re::DataArrayHandle<re::MeshModel>)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E713FF8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::MoveOnlyCallable<re::MeshManager::destroyModel(re::DataArrayHandle<re::MeshModel>)::$_0,void ()(void)>::size()
{
  return 24;
}

void re::internal::MoveOnlyCallable<re::MeshManager::destroyInstance(re::DataArrayHandle<re::MeshInstance>)::$_0,void ()(void)>::~MoveOnlyCallable()
{
}

void re::internal::MoveOnlyCallable<re::MeshManager::destroyInstance(re::DataArrayHandle<re::MeshInstance>)::$_0,void ()(void)>::operator()(uint64_t a1)
{
}

uint64_t re::internal::MoveOnlyCallable<re::MeshManager::destroyInstance(re::DataArrayHandle<re::MeshInstance>)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E714048;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::MoveOnlyCallable<re::MeshManager::destroyInstance(re::DataArrayHandle<re::MeshInstance>)::$_0,void ()(void)>::size()
{
  return 24;
}

void re::DataArray<re::MeshModel>::allocBlock(unsigned int *a1)
{
  uint64_t v2 = 816 * a1[11];
  v5.n128_u64[0] = (*(uint64_t (**)(void, uint64_t, void))(**(void **)a1 + 32))(*(void *)a1, v2, 0);
  if (v5.n128_u64[0])
  {
    uint64_t v2 = 4 * a1[11];
    v5.n128_u64[1] = (*(uint64_t (**)(void, uint64_t, void))(**(void **)a1 + 32))(*(void *)a1, v2, 0);
    if (v5.n128_u64[1])
    {
      re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)a1, &v5);
      a1[12] = 0;
      return;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, v3, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v2, *(void *)(*(void *)a1 + 8), 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)6, v4, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v2, *(void *)(*(void *)a1 + 8));
  _os_crash();
  __break(1u);
}

void re::DataArray<re::MeshInstance>::allocBlock(unsigned int *a1)
{
  uint64_t v2 = 144 * a1[11];
  v5.n128_u64[0] = (*(uint64_t (**)(void, uint64_t, void))(**(void **)a1 + 32))(*(void *)a1, v2, 0);
  if (v5.n128_u64[0])
  {
    uint64_t v2 = 4 * a1[11];
    v5.n128_u64[1] = (*(uint64_t (**)(void, uint64_t, void))(**(void **)a1 + 32))(*(void *)a1, v2, 0);
    if (v5.n128_u64[1])
    {
      re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)a1, &v5);
      a1[12] = 0;
      return;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, v3, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v2, *(void *)(*(void *)a1 + 8), 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)6, v4, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v2, *(void *)(*(void *)a1 + 8));
  _os_crash();
  __break(1u);
}

uint64_t re::getOrCreateDepthStencilState(uint64_t a1, uint64_t a2, uint64_t a3, uint8x8_t a4)
{
  uint64_t v88 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)a3) {
    unint64_t v7 = re::Hash<re::DynamicString>::operator()((uint64_t)v55, a3 + 8);
  }
  else {
    unint64_t v7 = 0;
  }
  uint64_t v8 = *(unsigned __int16 *)(a3 + 49);
  if (!*(unsigned char *)(a3 + 54)) {
    uint64_t v8 = 0;
  }
  if (*(unsigned char *)(a3 + 55)) {
    v8 |= ((unint64_t)*(unsigned __int8 *)(a3 + 52) << 24) | ((unint64_t)*(unsigned __int8 *)(a3 + 51) << 16);
  }
  if (!*(unsigned char *)(a3 + 54))
  {
    unint64_t v9 = 0;
    if (!*(unsigned char *)(a3 + 55)) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  unint64_t v9 = *(unsigned __int8 *)(a3 + 40) | (16 * *(unsigned __int8 *)(a3 + 41)) | ((unint64_t)*(unsigned __int8 *)(a3 + 42) << 8) | ((unint64_t)*(unsigned __int8 *)(a3 + 43) << 12);
  if (*(unsigned char *)(a3 + 55))
  {
LABEL_10:
    a4.i32[0] = *(_DWORD *)(a3 + 44);
    uint32x4_t v10 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a4));
    v11.i64[0] = v10.u32[0];
    v11.i64[1] = v10.u32[1];
    v12.i64[0] = 255;
    v12.i64[1] = 255;
    uint64x2_t v13 = (uint64x2_t)vandq_s8(v11, v12);
    v11.i64[0] = v10.u32[2];
    v11.i64[1] = v10.u32[3];
    int8x16_t v14 = vorrq_s8((int8x16_t)vshlq_u64(v13, (uint64x2_t)xmmword_2343E7240), (int8x16_t)vshlq_u64((uint64x2_t)vandq_s8(v11, v12), (uint64x2_t)xmmword_2343E7230));
    v9 |= *(void *)&vorr_s8(*(int8x8_t *)v14.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL));
  }
LABEL_11:
  unint64_t v15 = ((unint64_t)*(unsigned __int8 *)(a3 + 54) << 48) | ((unint64_t)*(unsigned __int8 *)(a3 + 55) << 56) | v8 | ((unint64_t)*(unsigned __int8 *)(a3 + 53) << 32) | ((unint64_t)*(unsigned __int8 *)(a3 + 48) << 40);
  unint64_t v16 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) >> 27));
  unint64_t v17 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) >> 27));
  unint64_t v18 = ((((((v7 << 6) + (v7 >> 2) - 0x61C8864680B583E9) ^ v7)
         + ((v16 ^ (v16 >> 31)) << 6)
         + ((v16 ^ (v16 >> 31)) >> 2)
         - 0x61C8864680B583E9) ^ v16 ^ (v16 >> 31))
       + ((v17 ^ (v17 >> 31)) << 6)
       + ((v17 ^ (v17 >> 31)) >> 2)
       - 0x61C8864680B583E9) ^ v17 ^ (v17 >> 31);
  if (*(void *)a2)
  {
    uint64_t v19 = *(unsigned int *)(*(void *)(a2 + 8) + 4 * (v18 % *(unsigned int *)(a2 + 24)));
    if (v19 != 0x7FFFFFFF)
    {
      uint64_t v30 = *(void *)(a2 + 16);
      if (*(void *)(v30 + 24 * v19 + 8) == v18) {
        return v30 + 24 * v19 + 16;
      }
      while (1)
      {
        LODWORD(v19) = *(_DWORD *)(v30 + 24 * v19) & 0x7FFFFFFF;
        if (v19 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v30 + 24 * v19 + 8) == v18) {
          return v30 + 24 * v19 + 16;
        }
      }
    }
  }
  id v20 = objc_msgSend(objc_msgSend(MEMORY[0x263F128A0], sel_alloc), sel_init);
  if (*(unsigned char *)a3)
  {
    if (*(void *)(a3 + 16)) {
      uint64_t v21 = *(void *)(a3 + 24);
    }
    else {
      uint64_t v21 = a3 + 17;
    }
    objc_msgSend(v20, sel_setLabel_, objc_msgSend(NSString, sel_stringWithCString_encoding_, v21, 4));
  }
  objc_msgSend(v20, sel_setDepthWriteEnabled_, *(unsigned __int8 *)(a3 + 53));
  objc_msgSend(v20, sel_setDepthCompareFunction_, *(unsigned __int8 *)(a3 + 48));
  if (*(unsigned char *)(a3 + 54))
  {
    id v22 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A20], sel_alloc), sel_init);
    objc_msgSend(v22, sel_setStencilCompareFunction_, *(unsigned __int8 *)(a3 + 40));
    objc_msgSend(v22, sel_setDepthFailureOperation_, *(unsigned __int8 *)(a3 + 41));
    objc_msgSend(v22, sel_setStencilFailureOperation_, *(unsigned __int8 *)(a3 + 42));
    objc_msgSend(v22, sel_setDepthStencilPassOperation_, *(unsigned __int8 *)(a3 + 43));
    objc_msgSend(v22, sel_setReadMask_, *(unsigned __int8 *)(a3 + 49));
    objc_msgSend(v22, sel_setWriteMask_, *(unsigned __int8 *)(a3 + 50));
    objc_msgSend(v20, sel_setFrontFaceStencil_, v22);
    if (v22) {
  }
    }
  if (*(unsigned char *)(a3 + 55))
  {
    id v23 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A20], sel_alloc), sel_init);
    objc_msgSend(v23, sel_setStencilCompareFunction_, *(unsigned __int8 *)(a3 + 44));
    objc_msgSend(v23, sel_setDepthFailureOperation_, *(unsigned __int8 *)(a3 + 45));
    objc_msgSend(v23, sel_setStencilFailureOperation_, *(unsigned __int8 *)(a3 + 46));
    objc_msgSend(v23, sel_setDepthStencilPassOperation_, *(unsigned __int8 *)(a3 + 47));
    objc_msgSend(v23, sel_setReadMask_, *(unsigned __int8 *)(a3 + 51));
    objc_msgSend(v23, sel_setWriteMask_, *(unsigned __int8 *)(a3 + 52));
    objc_msgSend(v20, sel_setBackFaceStencil_, v23);
    if (v23) {
  }
    }
  id v54 = 0;
  *(void *)unint64_t v55 = objc_msgSend(*(id *)(a1 + 184), sel_newDepthStencilStateWithDescriptor_, v20);
  NS::SharedPtr<MTL::Texture>::operator=(&v54, (void **)v55);
  unint64_t v24 = *(re **)v55;
  if (*(void *)v55) {

  }
  if (!v54)
  {
    char v25 = *re::graphicsLogObjects(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      if (*(unsigned char *)a3)
      {
        if (*(unsigned char *)(a3 + 16)) {
          float32x4_t v39 = *(const char **)(a3 + 24);
        }
        else {
          float32x4_t v39 = (const char *)(a3 + 17);
        }
      }
      else
      {
        float32x4_t v39 = "<Unnamed>";
      }
      int v40 = *(unsigned __int8 *)(a3 + 53);
      int v41 = *(unsigned __int8 *)(a3 + 48);
      int v42 = *(unsigned __int8 *)(a3 + 54);
      int v43 = *(unsigned __int8 *)(a3 + 40);
      int v44 = *(unsigned __int8 *)(a3 + 41);
      int v45 = *(unsigned __int8 *)(a3 + 42);
      int v46 = *(unsigned __int8 *)(a3 + 43);
      int v47 = *(unsigned __int8 *)(a3 + 49);
      int v48 = *(unsigned __int8 *)(a3 + 55);
      int v49 = *(unsigned __int8 *)(a3 + 44);
      int v50 = *(unsigned __int8 *)(a3 + 45);
      int v51 = *(unsigned __int8 *)(a3 + 46);
      int v52 = *(unsigned __int8 *)(a3 + 47);
      int v53 = *(unsigned __int8 *)(a3 + 51);
      *(_DWORD *)unint64_t v55 = 136319234;
      *(void *)&v55[4] = v39;
      __int16 v56 = 1024;
      int v57 = v40;
      __int16 v58 = 1024;
      int v59 = v41;
      __int16 v60 = 1024;
      int v61 = v42;
      __int16 v62 = 1024;
      int v63 = v43;
      __int16 v64 = 1024;
      int v65 = v44;
      __int16 v66 = 1024;
      int v67 = v45;
      __int16 v68 = 1024;
      int v69 = v46;
      __int16 v70 = 1024;
      int v71 = v47;
      __int16 v72 = 1024;
      int v73 = v47;
      __int16 v74 = 1024;
      int v75 = v48;
      __int16 v76 = 1024;
      int v77 = v49;
      __int16 v78 = 1024;
      int v79 = v50;
      __int16 v80 = 1024;
      int v81 = v51;
      __int16 v82 = 1024;
      int v83 = v52;
      __int16 v84 = 1024;
      int v85 = v53;
      __int16 v86 = 1024;
      int v87 = v53;
      _os_log_error_impl(&dword_233120000, v25, OS_LOG_TYPE_ERROR, "Failed to create depth-stencil state. Descriptor parameters:  label: %s  depth write enabled: %u  depth cmp: %u  frontStencilEnabled: %u    frontStencilCmp: %u    frontStencilDepthFailOp: %u    frontStencilStencilFailOp: %u    frontStencilDepthStencilPassOp: %u    frontStencilReadMask: %u    frontStencilWriteMask: %u  backStencilEnabled: %u    backStencilCmp: %u    backStencilDepthFailOp: %u    backStencilStencilFailOp: %u    backStencilDepthStencilPassOp: %u    backStencilReadMask: %u    backStencilWriteMask: %u", v55, 0x6Cu);
    }
  }
  if (!*(void *)a2)
  {
    LODWORD(v26) = 0;
    goto LABEL_41;
  }
  unint64_t v26 = v18 % *(unsigned int *)(a2 + 24);
  uint64_t v27 = *(unsigned int *)(*(void *)(a2 + 8) + 4 * v26);
  if (v27 == 0x7FFFFFFF)
  {
LABEL_41:
    uint64_t v32 = *(unsigned int *)(a2 + 36);
    if (v32 == 0x7FFFFFFF)
    {
      uint64_t v32 = *(unsigned int *)(a2 + 32);
      int v33 = v32;
      if (v32 == *(_DWORD *)(a2 + 24))
      {
        re::HashTable<unsigned long,re::CachedTileRenderPipelineState,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(a2, 2 * *(_DWORD *)(a2 + 28));
        LODWORD(v26) = v18 % *(unsigned int *)(a2 + 24);
        int v33 = *(_DWORD *)(a2 + 32);
      }
      *(_DWORD *)(a2 + 32) = v33 + 1;
      uint64_t v34 = *(void *)(a2 + 16);
      int v35 = *(_DWORD *)(v34 + 24 * v32);
    }
    else
    {
      uint64_t v34 = *(void *)(a2 + 16);
      int v35 = *(_DWORD *)(v34 + 24 * v32);
      *(_DWORD *)(a2 + 36) = v35 & 0x7FFFFFFF;
    }
    uint64_t v36 = 24 * v32;
    *(_DWORD *)(v34 + v36) = v35 | 0x80000000;
    *(_DWORD *)(*(void *)(a2 + 16) + v36) = *(_DWORD *)(*(void *)(a2 + 16) + 24 * v32) & 0x80000000 | *(_DWORD *)(*(void *)(a2 + 8) + 4 * v26);
    *(void *)(*(void *)(a2 + 16) + 24 * v32 + 8) = v18;
    uint64_t v37 = *(void *)(a2 + 16) + 24 * v32;
    *(void *)(v37 + 16) = v54;
    *(_DWORD *)(*(void *)(a2 + 8) + 4 * v26) = v32;
    ++*(_DWORD *)(a2 + 28);
    ++*(_DWORD *)(a2 + 40);
    uint64_t v29 = *(void *)(a2 + 16) + 24 * v32;
    goto LABEL_47;
  }
  uint64_t v28 = *(void *)(a2 + 16);
  while (*(void *)(v28 + 24 * v27 + 8) != v18)
  {
    LODWORD(v27) = *(_DWORD *)(v28 + 24 * v27) & 0x7FFFFFFF;
    if (v27 == 0x7FFFFFFF) {
      goto LABEL_41;
    }
  }
  uint64_t v29 = v28 + 24 * v27;
LABEL_47:
  uint64_t v31 = v29 + 16;
  if (v54) {

  }
  if (v20) {
  return v31;
  }
}

uint64_t re::removeNameMappedProtectedTexture<re::DynamicArray<re::TextureViews<re::TextureHandle>>>(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t result = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(a2, a1);
  if (result != -1)
  {
    uint64_t v7 = a2[1] + 16 * result;
    re::DynamicArray<re::TextureViews<re::TextureHandle>>::removeStableAt(a3, *(unsigned __int8 *)(v7 + 9));
    unsigned __int8 v8 = *(unsigned char *)(v7 + 9);
    re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::mapValues<void re::removeNameMappedProtectedTexture<re::DynamicArray<re::TextureViews<re::TextureHandle>>>(re::WeakStringID,re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>&,re::DynamicArray<re::TextureViews<re::TextureHandle>> &)::{lambda(re::IndexAndProtectionOptions&)#1}>(a2, &v8);
    return re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::remove(a2, a1);
  }
  return result;
}

void re::DynamicArray<re::TextureViews<re::TextureHandle>>::removeStableAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4 + 40 * a2 + 40 != v4 + 40 * v2)
    {
      uint64_t v5 = 40 * a2;
      uint64_t v6 = 40 * v2 - 40;
      do
      {
        uint64_t v7 = v4 + v5;
        re::TextureHandle::operator=((re::TextureHandle *)(v4 + v5), (re::TextureHandle *)(v4 + v5 + 40));
        re::Optional<NS::SharedPtr<MTL::Texture>>::operator=(v7 + 16, (void **)(v7 + 56));
        int v8 = *(unsigned __int8 *)(v4 + v5 + 72);
        if (*(unsigned char *)(v4 + v5 + 32)) {
          BOOL v9 = 0;
        }
        else {
          BOOL v9 = v8 == 0;
        }
        if (!v9)
        {
          if (*(unsigned char *)(v4 + v5 + 32)) {
            BOOL v10 = v8 == 0;
          }
          else {
            BOOL v10 = 0;
          }
          if (v10)
          {
            *(unsigned char *)(v7 + 32) = 0;
          }
          else
          {
            if (*(unsigned char *)(v4 + v5 + 32)) {
              BOOL v11 = 1;
            }
            else {
              BOOL v11 = v8 == 0;
            }
            if (!v11) {
              *(unsigned char *)(v7 + 32) = 1;
            }
            *(_DWORD *)(v4 + v5 + 33) = *(_DWORD *)(v4 + v5 + 73);
          }
        }
        v4 += 40;
        v6 -= 40;
      }
      while (v5 != v6);
      unint64_t v2 = *(void *)(a1 + 16);
    }
  }
  uint64_t v12 = *(void *)(a1 + 32) + 40 * v2;
  if (*(unsigned char *)(v12 - 24))
  {
    uint64x2_t v13 = *(void **)(v12 - 16);
    if (v13)
    {

      *(void *)(v12 - 16) = 0;
    }
  }
  re::TextureHandle::invalidate((re::TextureHandle *)(v12 - 40));
  --*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
}

uint64_t *re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::mapValues<void re::removeNameMappedProtectedTexture<re::DynamicArray<re::TextureViews<re::TextureHandle>>>(re::WeakStringID,re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>&,re::DynamicArray<re::TextureViews<re::TextureHandle>> &)::{lambda(re::IndexAndProtectionOptions&)#1}>(uint64_t *result, unsigned __int8 *a2)
{
  v11[0] = result;
  unint64_t v2 = result[2];
  if (v2 >= 0x10)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = 0;
    uint64_t v6 = *result;
    unint64_t v7 = v2 >> 4;
    while (1)
    {
      unsigned __int16 v8 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v6 + v5)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      v11[1] = (unsigned __int16)~v8;
      if (v8 != 0xFFFF) {
        break;
      }
      v5 += 16;
      if (!--v7) {
        return result;
      }
    }
    uint64_t v9 = __clz(__rbit64((unsigned __int16)~v8)) + v5;
    for (i = v9; i != -1; uint64_t v9 = i)
    {
      re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::updateKvpsHash(v4, *(void *)(v4 + 8) + 16 * v9);
      uint64_t v10 = *(void *)(v4 + 8) + 16 * i;
      if (*(unsigned __int8 *)(v10 + 9) >= *a2) {
        --*(unsigned char *)(v10 + 9);
      }
      re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::updateKvpsHash(v4, v10);
      uint64_t result = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v11);
    }
  }
  return result;
}

uint64_t re::removeNameMappedConstant(void *a1, uint64_t *a2, void *a3, uint64_t a4)
{
  uint64_t result = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(a2, a1);
  if (result != -1)
  {
    uint64_t v9 = a2[1] + 16 * result;
    if (*(unsigned __int8 *)(v9 + 10) == a4)
    {
      uint64_t v10 = (unsigned __int16 *)(v9 + 8);
      uint64_t v11 = *(unsigned __int16 *)(v9 + 8);
      if (((a4 + 3) & 0xFFFFFFFFFFFFFFFCLL) >= a3[2] - v11) {
        unint64_t v12 = a3[2] - v11;
      }
      else {
        unint64_t v12 = (a4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      }
      re::DynamicArray<unsigned char>::removeManyStableAt(a3, v11, v12);
      v20[0] = a2;
      unint64_t v13 = a2[2];
      if (v13 >= 0x10)
      {
        uint64_t v14 = 0;
        uint64_t v15 = *a2;
        unint64_t v16 = v13 >> 4;
        while (1)
        {
          unsigned __int16 v17 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v15 + v14)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
          v20[1] = (unsigned __int16)~v17;
          if (v17 != 0xFFFF) {
            break;
          }
          v14 += 16;
          if (!--v16) {
            return re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::remove(a2, a1);
          }
        }
        uint64_t v18 = __clz(__rbit64((unsigned __int16)~v17)) + v14;
        for (i = v18; i != -1; uint64_t v18 = i)
        {
          re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::updateKvpsHash((uint64_t)a2, a2[1] + 16 * v18);
          uint64_t v19 = a2[1] + 16 * i;
          if (*(unsigned __int16 *)(v19 + 8) > *v10) {
            *(_WORD *)(v19 + 8) -= v12;
          }
          re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::updateKvpsHash((uint64_t)a2, v19);
          re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v20);
        }
      }
      return re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::remove(a2, a1);
    }
  }
  return result;
}

void *re::DynamicArray<unsigned char>::removeManyStableAt(void *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = result;
    unint64_t v5 = a2 + a3 - 1;
    unint64_t v6 = result[2];
    if (v5 >= v6)
    {
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v5 < v6 - 1)
    {
      uint64_t v7 = result[4];
      uint64_t result = (void *)(v7 + a2);
      unsigned __int16 v8 = (unsigned char *)(v7 + a2 + a3);
      uint64_t v9 = (unsigned char *)(v7 + v6);
      if (v9 != v8)
      {
        uint64_t result = memmove(result, v8, v9 - v8);
        unint64_t v6 = v4[2];
      }
    }
    v4[2] = v6 - a3;
    ++*((_DWORD *)v4 + 6);
  }
  return result;
}

BOOL re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::remove(uint64_t *a1, void *a2)
{
  uint64_t v3 = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(a1, a2);
  uint64_t v4 = v3;
  if (v3 != -1)
  {
    unint64_t v5 = (int8x16_t *)(*a1 + (v3 & 0xFFFFFFFFFFFFFFF0));
    v6.i64[0] = -1;
    v6.i64[1] = -1;
    int8x8_t v7 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(*v5, v6), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    if (v7) {
      char v8 = -1;
    }
    else {
      char v8 = 0x80;
    }
    v5->i8[v3 & 0xF] = v8;
    re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::updateHashes((uint64_t)a1, a1[1] + 16 * v3);
    unint64_t v9 = a1[2];
    *(void *)(a1[1] + 16 * v4) = 0;
    uint64_t v10 = a1[4];
    if (v7) {
      ++v10;
    }
    unint64_t v11 = a1[3] - 1;
    a1[3] = v11;
    a1[4] = v10;
    if (v9 >= 0x11 && v11 < v9 >> 2) {
      re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::resize(a1, 0);
    }
  }
  return v4 != -1;
}

uint64_t re::removeNameMappedConstant(void *a1, uint64_t *a2, void *a3)
{
  uint64_t result = re::HashBrown<re::WeakStringID,re::IndexAndProtectionOptions,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::IndexAndProtectionOptions>,false>::find(a2, a1);
  if (result != -1)
  {
    uint64_t v7 = a2[1] + 16 * result;
    unsigned int v10 = *(unsigned __int16 *)(v7 + 8);
    unint64_t v9 = (unsigned __int16 *)(v7 + 8);
    uint64_t v8 = v10;
    unint64_t v11 = a3[2] - v10;
    if (((*((unsigned __int8 *)v9 + 2) + 3) & 0x1FCu) >= v11) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = (*((unsigned __int8 *)v9 + 2) + 3) & 0x1FC;
    }
    re::DynamicArray<unsigned char>::removeManyStableAt(a3, v8, v12);
    v20[0] = a2;
    unint64_t v13 = a2[2];
    if (v13 >= 0x10)
    {
      uint64_t v14 = 0;
      uint64_t v15 = *a2;
      unint64_t v16 = v13 >> 4;
      while (1)
      {
        unsigned __int16 v17 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v15 + v14)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
        v20[1] = (unsigned __int16)~v17;
        if (v17 != 0xFFFF) {
          break;
        }
        v14 += 16;
        if (!--v16) {
          return re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::remove(a2, a1);
        }
      }
      uint64_t v18 = __clz(__rbit64((unsigned __int16)~v17)) + v14;
      for (i = v18; i != -1; uint64_t v18 = i)
      {
        re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::updateKvpsHash((uint64_t)a2, a2[1] + 16 * v18);
        uint64_t v19 = a2[1] + 16 * i;
        if (*(unsigned __int16 *)(v19 + 8) > *v9) {
          *(_WORD *)(v19 + 8) -= v12;
        }
        re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::updateKvpsHash((uint64_t)a2, v19);
        re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v20);
      }
    }
    return re::HashBrown<re::WeakStringID,re::ConstantLocation,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<re::ConstantLocation>,false>::remove(a2, a1);
  }
  return result;
}

re::ShadowRenderManager *re::ShadowRenderManager::ShadowRenderManager(re::ShadowRenderManager *this, const re::RenderManager *a2)
{
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  int64x2_t v8 = vdupq_n_s64(1uLL);
  int v9 = 0;
  re::generatePatchPlane((uint64_t)a2, (uint64_t)&v8, (uint64_t *)this + 32);
  int64x2_t v6 = vdupq_n_s64(0x1EuLL);
  int v7 = 0;
  re::generatePatchPlane((uint64_t)a2, (uint64_t)&v6, (uint64_t *)this + 37);
  *((_DWORD *)this + 90) = 0;
  *((void *)this + 44) = 0;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_DWORD *)this + 100) = 0;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + re::DynamicArray<re::RenderGraphResourceSetup>::add((re::RenderGraphBuilder *)((char *)this + 336), (uint64_t)this + 424) = 0u;
  *(_OWORD *)((char *)this + 436) = 0u;
  *(void *)((char *)this + 452) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 30) = 0u;
  *((_DWORD *)this + 124) = 0;
  *(void *)((char *)this + 500) = 0x7FFFFFFFLL;
  *((void *)this + 68) = 0;
  *((_OWORD *)this + 32) = 0u;
  *((_DWORD *)this + 134) = 0;
  *((void *)this + 66) = 0;
  uint64_t v4 = re::MeshShadowGenerationQueue::MeshShadowGenerationQueue((re::ShadowRenderManager *)((char *)this + 552));
  *((void *)this + 89) = 0;
  *(_OWORD *)((char *)this + 696) = 0u;
  *((_OWORD *)this + 45) = 0u;
  *((_OWORD *)this + 46) = 0u;
  *((void *)this + 94) = 0x7FFFFFFF00000000;
  *((_DWORD *)this + 190) = 0;
  *((void *)this + 97) = 0;
  *((void *)this + 96) = 0;
  *((_DWORD *)this + 198) = 0;
  *((void *)this + 98) = 0;
  *((_OWORD *)this + 50) = 0u;
  *((_OWORD *)this + 51) = 0u;
  *(_OWORD *)((char *)this + 828) = 0u;
  *(void *)((char *)this + 844) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 856) = 0u;
  *(_OWORD *)((char *)this + 872) = 0u;
  *((void *)this + 111) = 0;
  return this;
}

double re::WorldOrderedShadows::create@<D0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  v45[11] = *MEMORY[0x263EF8340];
  memset(v34, 0, 36);
  *(void *)&v34[36] = 0x7FFFFFFFLL;
  uint64_t v5 = *((void *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 32 * v5;
    int v7 = (uint64_t *)(*((void *)a1 + 4) + 8);
    do
    {
      uint64_t v8 = *v7;
      v7 += 4;
      v45[0] = v8;
      uint64_t v30 = 0;
      uint64_t v4 = (_anonymous_namespace_ *)re::HashTable<unsigned long long,re::WorldOrderedShadows::Range,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add((uint64_t)v34, v45, &v30);
      ++*((_DWORD *)v4 + 1);
      v6 -= 32;
    }
    while (v6);
  }
  unsigned int v9 = *(_DWORD *)&v34[32];
  if (*(_DWORD *)&v34[32])
  {
    uint64_t v10 = 0;
    unint64_t v11 = (int *)(*(void *)&v34[16] + 8);
    while (1)
    {
      int v12 = *v11;
      v11 += 8;
      if (v12 < 0) {
        break;
      }
      if (*(unsigned int *)&v34[32] == ++v10)
      {
        LODWORD(v10) = *(_DWORD *)&v34[32];
        break;
      }
    }
  }
  else
  {
    LODWORD(v10) = 0;
  }
  if (*(_DWORD *)&v34[32] == v10)
  {
    unint64_t v13 = 0;
  }
  else
  {
    LODWORD(v13) = 0;
    uint64_t v14 = v10;
    uint64_t v15 = *(void *)&v34[16];
    do
    {
      uint64_t v16 = v15 + 32 * v14;
      int v17 = *(_DWORD *)(v16 + 28);
      *(_DWORD *)(v16 + 24) = v13;
      *(_DWORD *)(v16 + 28) = 0;
      unint64_t v13 = (v17 + v13);
      uint64_t v15 = *(void *)&v34[16];
      if (v9 <= (int)v10 + 1) {
        unsigned int v18 = v10 + 1;
      }
      else {
        unsigned int v18 = v9;
      }
      int v19 = v10;
      while (1)
      {
        uint64_t v14 = (v19 + 1);
        if (v18 - 1 == v19) {
          break;
        }
        ++v19;
        LODWORD(v10) = v14;
        if ((*(_DWORD *)(*(void *)&v34[16] + 32 * v14 + 8) & 0x80000000) != 0) {
          goto LABEL_21;
        }
      }
      LODWORD(v10) = v18;
LABEL_21:
      ;
    }
    while (v9 != v10);
  }
  uint64_t v33 = 0;
  long long v31 = 0uLL;
  int v32 = 0;
  re::DynamicArray<re::EvaluationRegister>::setCapacity(&v30, v13);
  ++v32;
  re::DynamicArray<re::AllocatedShadowHandle>::resizeUninitialized(&v30, v13);
  uint64_t v20 = *((void *)a1 + 2);
  if (v20)
  {
    uint64_t v21 = (uint64_t *)*((void *)a1 + 4);
    id v22 = &v21[4 * v20];
    do
    {
      uint64_t v24 = *v21;
      unint64_t v23 = v21[1];
      long long v36 = *((_OWORD *)v21 + 1);
      char v25 = (_DWORD *)re::HashTable<re::ecs2::Entity const*,re::SharedPtr<re::ecs2::CAMeshCodirectionalGroup>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)v34, v23);
      unint64_t v26 = (v25[1] + *v25);
      uint64_t v27 = *((void *)&v31 + 1);
      if (*((void *)&v31 + 1) <= v26)
      {
        uint64_t v35 = 0;
        memset(v45, 0, 80);
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v37 = 136315906;
        float32x4_t v38 = "operator[]";
        __int16 v39 = 1024;
        int v40 = 789;
        __int16 v41 = 2048;
        unint64_t v42 = v26;
        __int16 v43 = 2048;
        uint64_t v44 = v27;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v28 = v33 + 32 * v26;
      *(void *)uint64_t v28 = v24;
      *(void *)(v28 + 8) = v23;
      *(void *)(v28 + 16) = v36;
      *(_DWORD *)(v28 + 24) = DWORD2(v36);
      ++v25[1];
      v21 += 4;
    }
    while (v21 != v22);
  }
  *(void *)a2 = v30;
  *(_OWORD *)(a2 + 8) = v31;
  *(void *)(a2 + 32) = v33;
  *(_DWORD *)(a2 + 24) = 1;
  *(_DWORD *)(a2 + 80) = 0;
  *(_OWORD *)(a2 + 40) = *(_OWORD *)v34;
  *(_OWORD *)uint64_t v34 = 0uLL;
  *(void *)(a2 + 56) = *(void *)&v34[16];
  *(void *)&v34[16] = 0;
  *(_OWORD *)(a2 + 64) = *(_OWORD *)&v34[24];
  *(_OWORD *)&v34[24] = xmmword_23436F740;
  return re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v34);
}

double re::WorldOrderedShadows::create@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v55[11] = *MEMORY[0x263EF8340];
  memset(v44, 0, 36);
  *(void *)&v44[36] = 0x7FFFFFFFLL;
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  if (v5)
  {
    uint64_t v6 = 0;
    int v7 = (int *)(*(void *)(a1 + 16) + 8);
    while (1)
    {
      int v8 = *v7;
      v7 += 18;
      if (v8 < 0) {
        break;
      }
      if (v5 == ++v6)
      {
        LODWORD(v6) = *(_DWORD *)(a1 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if (v5 != v6)
  {
    uint64_t v9 = v6;
    uint64_t v10 = *(void *)(a1 + 16);
    do
    {
      v55[0] = *(void *)(v10 + 72 * v9 + 48);
      int v40 = 0;
      uint64_t v4 = (_anonymous_namespace_ *)re::HashTable<unsigned long long,re::WorldOrderedShadows::Range,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add((uint64_t)v44, v55, &v40);
      ++*((_DWORD *)v4 + 1);
      uint64_t v10 = *(void *)(a1 + 16);
      if (*(_DWORD *)(a1 + 32) <= (v6 + 1)) {
        int v11 = v6 + 1;
      }
      else {
        int v11 = *(_DWORD *)(a1 + 32);
      }
      int v12 = v6;
      while (1)
      {
        uint64_t v9 = (v12 + 1);
        if (v11 - 1 == v12) {
          break;
        }
        ++v12;
        LODWORD(v6) = v9;
        if ((*(_DWORD *)(v10 + 72 * v9 + 8) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v6) = v11;
LABEL_17:
      ;
    }
    while (v5 != v6);
  }
  unsigned int v13 = *(_DWORD *)&v44[32];
  if (*(_DWORD *)&v44[32])
  {
    uint64_t v14 = 0;
    uint64_t v15 = (int *)(*(void *)&v44[16] + 8);
    while (1)
    {
      int v16 = *v15;
      v15 += 8;
      if (v16 < 0) {
        break;
      }
      if (*(unsigned int *)&v44[32] == ++v14)
      {
        LODWORD(v14) = *(_DWORD *)&v44[32];
        break;
      }
    }
  }
  else
  {
    LODWORD(v14) = 0;
  }
  if (*(_DWORD *)&v44[32] == v14)
  {
    unint64_t v17 = 0;
  }
  else
  {
    LODWORD(v17) = 0;
    uint64_t v18 = v14;
    uint64_t v19 = *(void *)&v44[16];
    do
    {
      uint64_t v20 = v19 + 32 * v18;
      int v21 = *(_DWORD *)(v20 + 28);
      *(_DWORD *)(v20 + 24) = v17;
      *(_DWORD *)(v20 + 28) = 0;
      unint64_t v17 = (v21 + v17);
      uint64_t v19 = *(void *)&v44[16];
      if (v13 <= (int)v14 + 1) {
        unsigned int v22 = v14 + 1;
      }
      else {
        unsigned int v22 = v13;
      }
      int v23 = v14;
      while (1)
      {
        uint64_t v18 = (v23 + 1);
        if (v22 - 1 == v23) {
          break;
        }
        ++v23;
        LODWORD(v14) = v18;
        if ((*(_DWORD *)(*(void *)&v44[16] + 32 * v18 + 8) & 0x80000000) != 0) {
          goto LABEL_35;
        }
      }
      LODWORD(v14) = v22;
LABEL_35:
      ;
    }
    while (v13 != v14);
  }
  uint64_t v43 = 0;
  long long v41 = 0uLL;
  int v42 = 0;
  re::DynamicArray<re::EvaluationRegister>::setCapacity(&v40, v17);
  ++v42;
  re::DynamicArray<re::AllocatedShadowHandle>::resizeUninitialized(&v40, v17);
  uint64_t v24 = *(unsigned int *)(a1 + 32);
  if (v24)
  {
    uint64_t v25 = 0;
    unint64_t v26 = (int *)(*(void *)(a1 + 16) + 8);
    while (1)
    {
      int v27 = *v26;
      v26 += 18;
      if (v27 < 0) {
        break;
      }
      if (v24 == ++v25)
      {
        LODWORD(v25) = *(_DWORD *)(a1 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v25) = 0;
  }
  if (v24 != v25)
  {
    uint64_t v28 = v25;
    uint64_t v29 = *(void *)(a1 + 16);
    do
    {
      uint64_t v30 = v29 + 72 * v28;
      uint64_t v32 = *(void *)(v30 + 40);
      unint64_t v31 = *(void *)(v30 + 48);
      long long v46 = *(_OWORD *)(v30 + 56);
      uint64_t v33 = (_DWORD *)re::HashTable<re::ecs2::Entity const*,re::SharedPtr<re::ecs2::CAMeshCodirectionalGroup>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)v44, v31);
      unint64_t v34 = (v33[1] + *v33);
      uint64_t v35 = *((void *)&v41 + 1);
      if (*((void *)&v41 + 1) <= v34)
      {
        uint64_t v45 = 0;
        memset(v55, 0, 80);
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v47 = 136315906;
        int v48 = "operator[]";
        __int16 v49 = 1024;
        int v50 = 789;
        __int16 v51 = 2048;
        unint64_t v52 = v34;
        __int16 v53 = 2048;
        uint64_t v54 = v35;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v36 = v43 + 32 * v34;
      *(void *)uint64_t v36 = v32;
      *(void *)(v36 + 8) = v31;
      *(void *)(v36 + 16) = v46;
      *(_DWORD *)(v36 + 24) = DWORD2(v46);
      ++v33[1];
      uint64_t v29 = *(void *)(a1 + 16);
      if (*(_DWORD *)(a1 + 32) <= (v25 + 1)) {
        int v37 = v25 + 1;
      }
      else {
        int v37 = *(_DWORD *)(a1 + 32);
      }
      while (1)
      {
        uint64_t v28 = (v25 + 1);
        if (v37 - 1 == v25) {
          break;
        }
        LODWORD(v25) = v25 + 1;
        int v38 = v28;
        if ((*(_DWORD *)(v29 + 72 * v28 + 8) & 0x80000000) != 0) {
          goto LABEL_52;
        }
      }
      int v38 = v37;
LABEL_52:
      LODWORD(v25) = v38;
    }
    while (v24 != v38);
  }
  *(void *)a2 = v40;
  *(_OWORD *)(a2 + 8) = v41;
  *(void *)(a2 + 32) = v43;
  *(_DWORD *)(a2 + 24) = 1;
  *(_DWORD *)(a2 + 80) = 0;
  *(_OWORD *)(a2 + 40) = *(_OWORD *)v44;
  *(_OWORD *)uint64_t v44 = 0uLL;
  *(void *)(a2 + 56) = *(void *)&v44[16];
  *(void *)&v44[16] = 0;
  *(_OWORD *)(a2 + 64) = *(_OWORD *)&v44[24];
  *(_OWORD *)&v44[24] = xmmword_23436F740;
  return re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v44);
}

void re::PersistentShadowState::consumeMeshShadowUpdate(uint64_t a1)
{
  MEMORY[0x270FA5388](a1);
  unint64_t v538 = v3;
  unint64_t v539 = v4;
  v574 = v5;
  unint64_t v6 = v1;
  uint64_t v537 = v7;
  uint64_t v697 = *MEMORY[0x263EF8340];
  unsigned int v622 = 0;
  long long v620 = 0u;
  long long v621 = 0u;
  uint64_t v623 = 0x7FFFFFFFLL;
  v616 = (float32x4_t *)v2;
  uint64_t v8 = *(void *)(v2 + 304);
  if (v8)
  {
    uint64_t v9 = *(unint64_t **)(v2 + 320);
    uint64_t v10 = &v9[v8];
    do
    {
      int v11 = *re::shadowLogObjects((re *)v1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v12 = *v9;
        buf[0].n128_u32[0] = 134217984;
        *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v12;
        _os_log_impl(&dword_233120000, v11, OS_LOG_TYPE_DEFAULT, "PersistentShadowState: Removing cluster %llu", (uint8_t *)buf, 0xCu);
      }
      unint64_t v1 = re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(v6 + 128, *v9);
      if (v1) {
        goto LABEL_9;
      }
      unsigned int v13 = *re::shadowLogObjects((re *)v1);
      unint64_t v1 = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
      if (v1)
      {
        unint64_t v18 = *v9;
        buf[0].n128_u32[0] = 134217984;
        *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v18;
        _os_log_error_impl(&dword_233120000, v13, OS_LOG_TYPE_ERROR, "PersistentShadowState: Got a removed cluster that has not been added %llu", (uint8_t *)buf, 0xCu);
      }
      if (!re::internal::shadows::g_allowMultipleShadowRemovals)
      {
LABEL_9:
        uint64_t v14 = *(void *)(v6 + 192);
        if (v14)
        {
          uint64_t v15 = *(unint64_t **)(v6 + 208);
          uint64_t v16 = 16 * v14;
          do
          {
            buf[0].n128_u64[0] = *v9;
            buf[0].n128_u64[1] = *v15;
            unint64_t v17 = *v15;
            v15 += 2;
            buf[1].n128_u8[0] = v17 != 0;
            unint64_t v1 = re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::add((uint64_t)&v620, (uint64_t)buf);
            v16 -= 16;
          }
          while (v16);
        }
      }
      ++v9;
    }
    while (v9 != v10);
  }
  uint64_t v19 = v616;
  uint64_t v20 = v616[6].i64[1];
  if (v20)
  {
    int v21 = (unint64_t *)__src;
    unsigned int v22 = (unint64_t *)v616[7].i64[1];
    int v23 = &v22[v20];
    do
    {
      uint64_t v24 = *re::shadowLogObjects((re *)v1);
      unint64_t v1 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
      if (v1)
      {
        unint64_t v25 = *v22;
        buf[0].n128_u32[0] = 134217984;
        *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v25;
        _os_log_impl(&dword_233120000, v24, OS_LOG_TYPE_DEFAULT, "PersistentShadowState: Removing world %llu", (uint8_t *)buf, 0xCu);
      }
      uint64_t v26 = *(void *)(v6 + 208);
      uint64_t v27 = *(void *)(v6 + 192);
      if (v27)
      {
        uint64_t v28 = 16 * v27;
        uint64_t v29 = *(void *)(v6 + 208);
        while (*(void *)v29 != *v22 || *(unsigned char *)(v29 + 8) != (*v22 != 0))
        {
          v29 += 16;
          v28 -= 16;
          if (!v28)
          {
            uint64_t v29 = v26 + 16 * v27;
            break;
          }
        }
      }
      else
      {
        uint64_t v29 = *(void *)(v6 + 208);
      }
      if (v27 != (v29 - v26) >> 4) {
        goto LABEL_28;
      }
      uint64_t v30 = *re::shadowLogObjects((re *)v1);
      unint64_t v1 = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
      if (v1)
      {
        unint64_t v38 = *v22;
        buf[0].n128_u32[0] = 134217984;
        *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v38;
        _os_log_error_impl(&dword_233120000, v30, OS_LOG_TYPE_ERROR, "PersistentShadowState: Got a removed world that has not been added %llu", (uint8_t *)buf, 0xCu);
      }
      if (!re::internal::shadows::g_allowMultipleShadowRemovals)
      {
LABEL_28:
        uint64_t v31 = *(unsigned int *)(v6 + 160);
        if (v31)
        {
          uint64_t v32 = 0;
          uint64_t v33 = (_DWORD *)(*(void *)(v6 + 144) + 8);
          while ((*v33 & 0x80000000) == 0)
          {
            v33 += 92;
            if (v31 == ++v32)
            {
              LODWORD(v32) = *(_DWORD *)(v6 + 160);
              break;
            }
          }
        }
        else
        {
          LODWORD(v32) = 0;
        }
        if (v31 != v32)
        {
          uint64_t v34 = v32;
          uint64_t v35 = *(void *)(v6 + 144);
          do
          {
            buf[0].n128_u64[0] = *(void *)(v35 + 368 * v34 + 16);
            buf[0].n128_u64[1] = *v22;
            buf[1].n128_u8[0] = *v22 != 0;
            unint64_t v1 = re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::add((uint64_t)&v620, (uint64_t)buf);
            uint64_t v35 = *(void *)(v6 + 144);
            if (*(_DWORD *)(v6 + 160) <= (v32 + 1)) {
              int v36 = v32 + 1;
            }
            else {
              int v36 = *(_DWORD *)(v6 + 160);
            }
            int v37 = v32;
            while (1)
            {
              uint64_t v34 = (v37 + 1);
              if (v36 - 1 == v37) {
                break;
              }
              ++v37;
              LODWORD(v32) = v34;
              if ((*(_DWORD *)(v35 + 368 * v34 + 8) & 0x80000000) != 0) {
                goto LABEL_44;
              }
            }
            LODWORD(v32) = v36;
LABEL_44:
            ;
          }
          while (v31 != v32);
        }
      }
      ++v22;
    }
    while (v22 != v23);
    uint64_t v19 = v616;
    uint64_t v39 = v616[6].i64[1];
    if (v39)
    {
      int v40 = (void *)v616[7].i64[1];
      long long v41 = &v40[v39];
      unint64_t v42 = *(void *)(v6 + 192);
      do
      {
        uint64_t v43 = *(void *)(v6 + 208);
        uint64_t v44 = v43 + 16 * v42;
        if (v42)
        {
          uint64_t v45 = 16 * v42;
          uint64_t v46 = *(void *)(v6 + 208);
          while (*(void *)v46 != *v40 || *(unsigned char *)(v46 + 8) != (*v40 != 0))
          {
            v46 += 16;
            v45 -= 16;
            if (!v45)
            {
              uint64_t v46 = v43 + 16 * v42;
              break;
            }
          }
        }
        else
        {
          uint64_t v46 = *(void *)(v6 + 208);
        }
        unint64_t v47 = (v46 - v43) >> 4;
        if (v47 != v42)
        {
          if (v42 <= v47)
          {
            v686.columns[0].i64[0] = 0;
            simd_float4 v646 = 0u;
            int32x4_t v645 = 0u;
            long long v644 = 0u;
            memset(buf, 0, sizeof(buf));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)__src = 136315906;
            *(void *)&__src[4] = "removeAt";
            *(_WORD *)&__src[12] = 1024;
            *(_DWORD *)&__src[14] = 931;
            *(_WORD *)&__src[18] = 2048;
            *(void *)&__src[20] = v47;
            *(_WORD *)&__src[28] = 2048;
            *(void *)&__src[30] = v42;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_464:
            v641.i64[0] = 0;
            simd_float4 v646 = 0u;
            int32x4_t v645 = 0u;
            long long v644 = 0u;
            memset(buf, 0, sizeof(buf));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)v695 = 136315906;
            *(void *)&v695[4] = "operator[]";
            *(_WORD *)&v695[12] = 1024;
            *(_DWORD *)&v695[14] = 789;
            *(_WORD *)&v695[18] = 2048;
            *(void *)&v695[20] = v21;
            *(_WORD *)&v695[28] = 2048;
            *(void *)&v695[30] = v23;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          if (--v42 > v47)
          {
            uint64_t v48 = v43 + 16 * v47;
            uint64_t v49 = *(void *)(v44 - 16);
            *(unsigned char *)(v48 + 8) = *(unsigned char *)(v44 - 8);
            *(void *)uint64_t v48 = v49;
            unint64_t v42 = *(void *)(v6 + 192) - 1;
          }
          *(void *)(v6 + 192) = v42;
          ++*(_DWORD *)(v6 + 200);
        }
        ++v40;
      }
      while (v40 != v41);
    }
  }
  uint64_t v50 = v19[19].i64[0];
  if (v50)
  {
    __int16 v51 = (uint64_t *)v616[20].i64[0];
    unint64_t v52 = &v51[v50];
    do
    {
      if (*(void *)(v6 + 128))
      {
        uint64_t v53 = *v51;
        unint64_t v54 = 0xBF58476D1CE4E5B9 * (*v51 ^ ((unint64_t)*v51 >> 30));
        unint64_t v55 = ((0x94D049BB133111EBLL * (v54 ^ (v54 >> 27))) ^ ((0x94D049BB133111EBLL * (v54 ^ (v54 >> 27))) >> 31))
            % *(unsigned int *)(v6 + 152);
        uint64_t v56 = *(void *)(v6 + 136);
        uint64_t v57 = *(unsigned int *)(v56 + 4 * v55);
        if (v57 != 0x7FFFFFFF)
        {
          uint64_t v58 = *(void *)(v6 + 144);
          if (*(void *)(v58 + 368 * v57 + 16) == v53)
          {
            *(_DWORD *)(v56 + 4 * v55) = *(_DWORD *)(v58 + 368 * v57 + 8) & 0x7FFFFFFF;
LABEL_70:
            uint64_t v60 = *(void *)(v6 + 144);
            uint64_t v61 = v60 + 368 * v57;
            int v64 = *(_DWORD *)(v61 + 8);
            int v63 = (int *)(v61 + 8);
            int v62 = v64;
            if (v64 < 0)
            {
              *int v63 = v62 & 0x7FFFFFFF;
              re::DynamicArray<unsigned long>::deinit(v60 + 368 * v57 + 32);
              uint64_t v60 = *(void *)(v6 + 144);
              int v62 = *(_DWORD *)(v60 + 368 * v57 + 8);
            }
            *(_DWORD *)(v60 + 368 * v57 + 8) = *(_DWORD *)(v6 + 164) | v62 & 0x80000000;
            --*(_DWORD *)(v6 + 156);
            int v65 = *(_DWORD *)(v6 + 168) + 1;
            *(_DWORD *)(v6 + 164) = v57;
            *(_DWORD *)(v6 + 168) = v65;
          }
          else
          {
            while (1)
            {
              uint64_t v59 = v57;
              uint64_t v57 = *(_DWORD *)(v58 + 368 * v57 + 8) & 0x7FFFFFFF;
              if (v57 == 0x7FFFFFFF) {
                break;
              }
              if (*(void *)(v58 + 368 * v57 + 16) == v53)
              {
                *(_DWORD *)(v58 + 368 * v59 + 8) = *(_DWORD *)(v58 + 368 * v59 + 8) & 0x80000000 | *(_DWORD *)(v58 + 368 * v57 + 8) & 0x7FFFFFFF;
                goto LABEL_70;
              }
            }
          }
        }
      }
      ++v51;
    }
    while (v51 != v52);
  }
  uint64_t v66 = v622;
  if (v622)
  {
    uint64_t v67 = 0;
    __int16 v68 = (int *)(v621 + 8);
    while (1)
    {
      int v69 = *v68;
      v68 += 10;
      if (v69 < 0) {
        break;
      }
      if (v622 == ++v67)
      {
        LODWORD(v67) = v622;
        break;
      }
    }
  }
  else
  {
    LODWORD(v67) = 0;
  }
  if (v622 != v67)
  {
    uint64_t v152 = v67;
    uint64_t v153 = v621;
    uint64_t v154 = v6 + 80;
    do
    {
      v155 = (unint64_t *)(v153 + 40 * v152 + 16);
      uint64_t v156 = re::HashTable<re::ShadowPair,re::AllocatedShadowHandle,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::tryGet(v154, (uint64_t)v155);
      if (v156) {
        goto LABEL_200;
      }
      uint64_t v166 = v66;
      v167 = *re::shadowLogObjects(0);
      if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR))
      {
        unint64_t v178 = *v155;
        unint64_t v179 = *(void *)(v153 + 40 * v152 + 24);
        buf[0].n128_u32[0] = 134218240;
        *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v178;
        buf[0].n128_u16[6] = 2048;
        *(unint64_t *)((char *)&buf[0].n128_u64[1] + 6) = v179;
        _os_log_error_impl(&dword_233120000, v167, OS_LOG_TYPE_ERROR, "PersistentShadowState: Received a request to remove shadow that doesnt exist (%llu, %llu)", (uint8_t *)buf, 0x16u);
      }
      uint64_t v66 = v166;
      uint64_t v154 = v6 + 80;
      if (!re::internal::shadows::g_allowMultipleShadowRemovals)
      {
LABEL_200:
        re::ShadowTileManager::releaseTile((void *)v6, (unsigned __int16 *)(v156 + 24));
        unint64_t v157 = re::Hash<re::ShadowPair>::operator()((uint64_t)buf, v155);
        if (*(void *)(v6 + 80))
        {
          unint64_t v158 = v157 % *(unsigned int *)(v6 + 104);
          uint64_t v159 = *(void *)(v6 + 88);
          uint64_t v160 = *(unsigned int *)(v159 + 4 * v158);
          if (v160 != 0x7FFFFFFF)
          {
            uint64_t v161 = *(void *)(v6 + 96);
            uint64_t v162 = v153 + 40 * v152;
            uint64_t v163 = *(void *)(v162 + 24);
            int v164 = *(unsigned __int8 *)(v162 + 32);
            uint64_t v165 = 0x7FFFFFFFLL;
            while (*(void *)(v161 + 72 * v160 + 16) != *v155
                 || *(void *)(v161 + 72 * v160 + 24) != v163
                 || *(unsigned __int8 *)(v161 + 72 * v160 + 32) != v164)
            {
              uint64_t v165 = v160;
              uint64_t v160 = *(_DWORD *)(v161 + 72 * v160 + 8) & 0x7FFFFFFF;
              if (v160 == 0x7FFFFFFF) {
                goto LABEL_218;
              }
            }
            int v168 = *(_DWORD *)(v161 + 72 * v160 + 8) & 0x7FFFFFFF;
            if (v165 == 0x7FFFFFFF) {
              *(_DWORD *)(v159 + 4 * v158) = v168;
            }
            else {
              *(_DWORD *)(v161 + 72 * v165 + 8) = *(_DWORD *)(v161 + 72 * v165 + 8) & 0x80000000 | v168;
            }
            uint64_t v169 = *(void *)(v6 + 96);
            uint64_t v170 = v169 + 72 * v160;
            int v173 = *(_DWORD *)(v170 + 8);
            v172 = (int *)(v170 + 8);
            int v171 = v173;
            if (v173 < 0)
            {
              int *v172 = v171 & 0x7FFFFFFF;
              uint64_t v169 = *(void *)(v6 + 96);
              int v171 = *(_DWORD *)(v169 + 72 * v160 + 8);
            }
            *(_DWORD *)(v169 + 72 * v160 + 8) = *(_DWORD *)(v6 + 116) | v171 & 0x80000000;
            --*(_DWORD *)(v6 + 108);
            int v174 = *(_DWORD *)(v6 + 120) + 1;
            *(_DWORD *)(v6 + 116) = v160;
            *(_DWORD *)(v6 + 120) = v174;
          }
        }
LABEL_218:
        long long v175 = *(_OWORD *)v155;
        *(void *)&__src[16] = *(void *)(v153 + 40 * v152 + 32);
        *(_OWORD *)__src = v175;
        re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::remove(v6 + 216, (uint64_t)__src);
        buf[0] = *(__n128 *)__src;
        buf[1].n128_u64[0] = *(void *)&__src[16];
        re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::remove(v6 + 312, (uint64_t)buf);
      }
      uint64_t v153 = v621;
      if (v622 <= (int)v67 + 1) {
        unsigned int v176 = v67 + 1;
      }
      else {
        unsigned int v176 = v622;
      }
      while (1)
      {
        uint64_t v152 = (v67 + 1);
        if (v176 - 1 == v67) {
          break;
        }
        LODWORD(v67) = v67 + 1;
        unsigned int v177 = v152;
        if ((*(_DWORD *)(v621 + 40 * v152 + 8) & 0x80000000) != 0) {
          goto LABEL_226;
        }
      }
      unsigned int v177 = v176;
LABEL_226:
      LODWORD(v67) = v177;
    }
    while (v66 != v177);
  }
  uint64_t v70 = (uint64_t)re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v636);
  uint64_t v71 = v616[9].i64[0];
  __asm { FMOV            V0.2S, #1.0 }
  float32x2_t v618 = _D0;
  if (v71)
  {
    uint64_t v76 = v616[10].i64[0];
    uint64_t v614 = v76 + 224 * v71;
    int32x4_t v613 = vdupq_n_s32(0x7F800000u);
    do
    {
      unint64_t v77 = *(void *)(v76 + 192);
      *(void *)__src = v77;
      BOOL v78 = re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(v6 + 128, v77);
      BOOL v79 = v78;
      if (!v78)
      {
        __int16 v80 = *re::shadowLogObjects((re *)v78);
        if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
        {
          buf[0].n128_u32[0] = 134217984;
          *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v77;
          _os_log_impl(&dword_233120000, v80, OS_LOG_TYPE_DEFAULT, "PersistentShadowState: Inserting cluster %llu", (uint8_t *)buf, 0xCu);
        }
      }
      int v81 = (_OWORD *)re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v6 + 128, v77);
      if (!v81)
      {
        memset(v658, 0, 96);
        long long v657 = 0u;
        long long v656 = 0u;
        float32x2_t v654 = 0;
        long long v644 = 0u;
        memset(buf, 0, sizeof(buf));
        int32x4_t v645 = v613;
        v94.i64[0] = 0x7F0000007FLL;
        v94.i64[1] = 0x7F0000007FLL;
        simd_float4 v646 = v94;
        int32x4_t v647 = v613;
        simd_float4 v648 = v94;
        simd_float4 v649 = 0u;
        simd_float4 v650 = 0u;
        simd_float4 v651 = 0u;
        simd_float4 v652 = 0u;
        simd_float4 v653 = 0u;
        float32x2_t v655 = v618;
        int v81 = (_OWORD *)re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v6 + 128, (uint64_t *)__src, (uint64_t)buf);
        if (buf[0].n128_u64[0])
        {
          if ((void)v644) {
            (*(void (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
          }
        }
      }
      uint64_t v70 = re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v81, v76);
      long long v83 = *(_OWORD *)(v76 + 64);
      long long v82 = *(_OWORD *)(v76 + 80);
      v81[3] = *(_OWORD *)(v76 + 48);
      v81[4] = v83;
      v81[5] = v82;
      long long v84 = *(_OWORD *)(v76 + 144);
      long long v86 = *(_OWORD *)(v76 + 96);
      long long v85 = *(_OWORD *)(v76 + 112);
      v81[8] = *(_OWORD *)(v76 + 128);
      v81[9] = v84;
      v81[6] = v86;
      v81[7] = v85;
      long long v87 = *(_OWORD *)(v76 + 208);
      long long v89 = *(_OWORD *)(v76 + 160);
      long long v88 = *(_OWORD *)(v76 + 176);
      v81[12] = *(_OWORD *)(v76 + 192);
      v81[13] = v87;
      v81[10] = v89;
      v81[11] = v88;
      uint64_t v90 = *(void *)(v6 + 192);
      if (v90)
      {
        int v91 = !v79;
        uint64_t v92 = *(void *)(v6 + 208);
        uint64_t v93 = 16 * v90;
        do
        {
          unint64_t v634 = *(void *)v92;
          unsigned __int8 v635 = *(unsigned char *)(v92 + 8);
          buf[0].n128_u64[0] = v77;
          buf[0].n128_u64[1] = v634;
          buf[1].n128_u8[0] = v635;
          uint64_t v70 = re::MeshShadowGenerationQueue::enqueue(v6 + 216, buf, v91);
          v92 += 16;
          v93 -= 16;
        }
        while (v93);
      }
      v76 += 224;
    }
    while (v76 != v614);
  }
  uint64_t v95 = v616[11].i64[1];
  if (v95)
  {
    __int16 v96 = (_OWORD *)(v616[12].i64[1] + 80);
    uint64_t v97 = 112 * v95;
    int32x4_t v615 = vdupq_n_s32(0x7F800000u);
    do
    {
      unint64_t v98 = *((void *)v96 - 10);
      *(void *)__src = v98;
      uint64_t v70 = re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v6 + 128, v98);
      if (v70)
      {
        uint64_t v99 = v70;
      }
      else
      {
        memset(v658, 0, 96);
        long long v657 = 0u;
        long long v656 = 0u;
        float32x2_t v654 = 0;
        long long v644 = 0u;
        memset(buf, 0, sizeof(buf));
        int32x4_t v645 = v615;
        v100.i64[0] = 0x7F0000007FLL;
        v100.i64[1] = 0x7F0000007FLL;
        simd_float4 v646 = v100;
        int32x4_t v647 = v615;
        simd_float4 v648 = v100;
        simd_float4 v649 = 0u;
        simd_float4 v650 = 0u;
        simd_float4 v651 = 0u;
        simd_float4 v652 = 0u;
        simd_float4 v653 = 0u;
        float32x2_t v655 = v618;
        uint64_t v99 = re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v6 + 128, (uint64_t *)__src, (uint64_t)buf);
        uint64_t v70 = buf[0].n128_u64[0];
        if (buf[0].n128_u64[0] && (void)v644) {
          uint64_t v70 = (*(uint64_t (**)(void))(*(void *)buf[0].n128_u64[0] + 40))();
        }
        unint64_t v98 = *((void *)v96 - 10);
      }
      *(void *)(v99 + 224) = v98;
      int v101 = *((unsigned __int8 *)v96 - 64);
      if (*(unsigned char *)(v99 + 240)) {
        _ZF = 0;
      }
      else {
        _ZF = v101 == 0;
      }
      if (!_ZF)
      {
        if (*(unsigned char *)(v99 + 240)) {
          BOOL v103 = v101 == 0;
        }
        else {
          BOOL v103 = 0;
        }
        if (v103)
        {
          *(unsigned char *)(v99 + 240) = 0;
        }
        else
        {
          if (*(unsigned char *)(v99 + 240)) {
            BOOL v104 = 1;
          }
          else {
            BOOL v104 = v101 == 0;
          }
          if (!v104) {
            *(unsigned char *)(v99 + 240) = 1;
          }
          long long v105 = *(v96 - 2);
          *(_OWORD *)(v99 + 256) = *(v96 - 3);
          *(_OWORD *)(v99 + 272) = v105;
        }
      }
      int v106 = *((unsigned __int8 *)v96 - 16);
      if (*(unsigned char *)(v99 + 288)) {
        BOOL v107 = 0;
      }
      else {
        BOOL v107 = v106 == 0;
      }
      if (!v107)
      {
        if (*(unsigned char *)(v99 + 288)) {
          BOOL v108 = v106 == 0;
        }
        else {
          BOOL v108 = 0;
        }
        if (v108)
        {
          *(unsigned char *)(v99 + 288) = 0;
        }
        else
        {
          if (*(unsigned char *)(v99 + 288)) {
            BOOL v109 = 1;
          }
          else {
            BOOL v109 = v106 == 0;
          }
          if (!v109) {
            *(unsigned char *)(v99 + 288) = 1;
          }
          long long v110 = v96[1];
          *(_OWORD *)(v99 + 304) = *v96;
          *(_OWORD *)(v99 + 320) = v110;
        }
      }
      v96 += 7;
      v97 -= 112;
    }
    while (v97);
  }
  uint64_t v111 = v616[1].i64[1];
  if (v111)
  {
    long long v112 = (unint64_t *)v616[2].i64[1];
    long long v113 = &v112[v111];
    do
    {
      unint64_t v114 = *v112;
      long long v115 = *re::shadowLogObjects((re *)v70);
      uint64_t v70 = os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT);
      if (v70)
      {
        buf[0].n128_u32[0] = 134217984;
        *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v114;
        _os_log_impl(&dword_233120000, v115, OS_LOG_TYPE_DEFAULT, "PersistentShadowState: Adding world %llu", (uint8_t *)buf, 0xCu);
      }
      unint64_t v116 = *(void *)(v6 + 184);
      unint64_t v117 = *(void *)(v6 + 192);
      if (v117 >= v116)
      {
        unint64_t v118 = v117 + 1;
        if (v116 < v117 + 1)
        {
          if (*(void *)(v6 + 176))
          {
            uint64_t v119 = 2 * v116;
            _ZF = v116 == 0;
            unint64_t v120 = 8;
            if (!_ZF) {
              unint64_t v120 = v119;
            }
            if (v120 <= v118) {
              unint64_t v121 = v118;
            }
            else {
              unint64_t v121 = v120;
            }
            uint64_t v70 = (uint64_t)re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(v6 + 176), v121);
          }
          else
          {
            uint64_t v70 = (uint64_t)re::DynamicArray<re::RigNodeConstraint>::setCapacity((void *)(v6 + 176), v118);
            ++*(_DWORD *)(v6 + 200);
          }
        }
        unint64_t v117 = *(void *)(v6 + 192);
      }
      uint64_t v122 = *(void *)(v6 + 208) + 16 * v117;
      *(void *)uint64_t v122 = v114;
      *(unsigned char *)(v122 + 8) = v114 != 0;
      ++*(void *)(v6 + 192);
      ++*(_DWORD *)(v6 + 200);
      uint64_t v123 = *(unsigned int *)(v6 + 160);
      if (v123)
      {
        uint64_t v124 = 0;
        v125 = (_DWORD *)(*(void *)(v6 + 144) + 8);
        while ((*v125 & 0x80000000) == 0)
        {
          v125 += 92;
          if (v123 == ++v124)
          {
            LODWORD(v124) = *(_DWORD *)(v6 + 160);
            break;
          }
        }
      }
      else
      {
        LODWORD(v124) = 0;
      }
      if (v123 != v124)
      {
        uint64_t v126 = v124;
        uint64_t v127 = *(void *)(v6 + 144);
        do
        {
          buf[0].n128_u64[0] = *(void *)(v127 + 368 * v126 + 16);
          buf[0].n128_u64[1] = v114;
          buf[1].n128_u8[0] = v114 != 0;
          uint64_t v70 = re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::add(v6 + 216, (uint64_t)buf);
          uint64_t v127 = *(void *)(v6 + 144);
          if (*(_DWORD *)(v6 + 160) <= (v124 + 1)) {
            int v128 = v124 + 1;
          }
          else {
            int v128 = *(_DWORD *)(v6 + 160);
          }
          int v129 = v124;
          while (1)
          {
            uint64_t v126 = (v129 + 1);
            if (v128 - 1 == v129) {
              break;
            }
            ++v129;
            LODWORD(v124) = v126;
            if ((*(_DWORD *)(v127 + 368 * v126 + 8) & 0x80000000) != 0) {
              goto LABEL_165;
            }
          }
          LODWORD(v124) = v128;
LABEL_165:
          ;
        }
        while (v123 != v124);
      }
      ++v112;
    }
    while (v112 != v113);
  }
  uint64_t v130 = v616[4].i64[0];
  if (v130)
  {
    uint64_t v131 = (unint64_t *)v616[5].i64[0];
    uint64_t v132 = &v131[v130];
    uint64_t v133 = *(unsigned int *)(v6 + 160);
    do
    {
      uint64_t v134 = 0;
      if (v133)
      {
        StringID v135 = (_DWORD *)(*(void *)(v6 + 144) + 8);
        while ((*v135 & 0x80000000) == 0)
        {
          v135 += 92;
          if (v133 == ++v134)
          {
            LODWORD(v134) = v133;
            break;
          }
        }
      }
      if (v133 == v134)
      {
        uint64_t v136 = v133;
      }
      else
      {
        unint64_t v137 = *v131;
        uint64_t v138 = v134;
        BOOL v139 = *v131 != 0;
        uint64_t v140 = *(void *)(v6 + 144);
        do
        {
          buf[0].n128_u64[0] = *(void *)(v140 + 368 * v138 + 16);
          buf[0].n128_u64[1] = v137;
          buf[1].n128_u8[0] = v139;
          uint64_t v70 = re::MeshShadowGenerationBacklog::pushBack((_anonymous_namespace_ *)(v6 + 264), buf);
          uint64_t v136 = *(unsigned int *)(v6 + 160);
          uint64_t v140 = *(void *)(v6 + 144);
          if (v136 <= (int)v134 + 1) {
            int v141 = v134 + 1;
          }
          else {
            int v141 = *(_DWORD *)(v6 + 160);
          }
          int v142 = v134;
          while (1)
          {
            uint64_t v138 = (v142 + 1);
            if (v141 - 1 == v142) {
              break;
            }
            ++v142;
            LODWORD(v134) = v138;
            if ((*(_DWORD *)(v140 + 368 * v138 + 8) & 0x80000000) != 0) {
              goto LABEL_185;
            }
          }
          LODWORD(v134) = v141;
LABEL_185:
          ;
        }
        while (v133 != v134);
      }
      ++v131;
      uint64_t v133 = v136;
    }
    while (v131 != v132);
  }
  int v632 = 0;
  long long v631 = 0u;
  long long v630 = 0u;
  uint64_t v633 = 0x7FFFFFFFLL;
  int v628 = 0;
  memset(v627, 0, sizeof(v627));
  uint64_t v629 = 0x7FFFFFFFLL;
  re::MeshShadowGenerationQueue::getEnqueued((re::MeshShadowGenerationQueue *)(v6 + 216), (uint64_t)v624);
  unsigned int v603 = v626;
  uint64_t v144 = 0;
  if (v626)
  {
    v145 = (int *)(v625 + 8);
    while (1)
    {
      int v146 = *v145;
      v145 += 10;
      if (v146 < 0) {
        break;
      }
      if (v626 == ++v144)
      {
        LODWORD(v144) = v626;
        break;
      }
    }
  }
  if (v626 != v144)
  {
    uint64_t v180 = v144;
    uint64_t v564 = v6 + 128;
    uint64_t i64 = (uint64_t)v574[4].i64;
    uint64_t v181 = v625;
    while (1)
    {
      v182 = (uint64_t *)(v181 + 40 * v180 + 16);
      uint64_t v183 = re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v564, v182);
      uint64_t v184 = re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v564, v182);
      if (v184) {
        v186 = (float32x4_t *)(v184 + 224);
      }
      else {
        v186 = 0;
      }
      if (v183) {
        BOOL v187 = v184 == 0;
      }
      else {
        BOOL v187 = 1;
      }
      if (v187)
      {
        uint64_t v188 = v181 + 40 * v180 + 16;
LABEL_377:
        re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::add((uint64_t)v627, v188);
        goto LABEL_387;
      }
      uint64_t v189 = v183;
      uint64_t v553 = v181;
      uint64_t v190 = v181 + 40 * v180;
      int v193 = *(unsigned __int8 *)(v190 + 32);
      v191 = (unsigned __int8 *)(v190 + 32);
      int v192 = v193;
      uint64_t v195 = *(void *)(v183 + 128);
      v194 = (float32x4_t *)(v183 + 128);
      v185.i64[0] = v195;
      float32x4_t v196 = v194[1];
      float32x4_t v197 = v194[2];
      float32x4_t v198 = v185;
      v198.i32[2] = v194->i32[2];
      float32x4_t v199 = vmulq_f32(v198, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v197, (int8x16_t)v197, 0xCuLL), (int8x16_t)v197, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v196, (int32x4_t)v196), (int8x16_t)v196, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v197, (int32x4_t)v197), (int8x16_t)v197, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v196, (int8x16_t)v196, 0xCuLL), (int8x16_t)v196, 8uLL)));
      BOOL v200 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v199, 2), vaddq_f32(v199, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v199.f32, 1))).f32[0] <= 0.0;
      float32x4_t v201 = vmulq_f32(v198, v198);
      float32x4_t v202 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v201.f32, 1);
      float v203 = -1.0;
      if (!v200) {
        float v203 = 1.0;
      }
      float32x4_t v204 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v201, 2), vaddq_f32(v201, v202));
      v204.f32[0] = sqrtf(v204.f32[0]);
      float32x4_t v205 = vmulq_f32(v196, v196);
      float32x4_t v206 = vmulq_f32(v197, v197);
      v204.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v205, 2), vaddq_f32(v205, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v205.f32, 1))).f32[0]);
      v204.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v206, 2), vaddq_f32(v206, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v206.f32, 1))).f32[0]);
      float32x4_t v207 = vmulq_n_f32(v204, v203);
      float32x4_t v208 = vmulq_f32(v207, v207);
      uint64_t v586 = v189;
      v541 = v191;
      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v208, 2), vaddq_f32(v208, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v208.f32, 1))).f32[0]) >= 1.0e-10)
      {
        float32x4_t v612 = v616[34];
        float32x4_t v213 = vabsq_f32(v612);
        v583 = v186;
        if (fmaxf(fmaxf(v213.f32[0], v213.f32[2]), v213.f32[1]) == v213.f32[1])
        {
          v185.i32[2] = v194->i32[2];
          float32x4_t v214 = vaddq_f32(vmlaq_f32(vmulq_f32(v185, (float32x4_t)0), (float32x4_t)0, v196), v197);
        }
        else
        {
          float32x4_t v214 = (float32x4_t)xmmword_23435FD60;
        }
        float32x4_t v215 = vsubq_f32((float32x4_t)0, v612);
        int32x4_t v216 = (int32x4_t)vmulq_f32(v215, v215);
        v216.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v216, 2), vadd_f32(*(float32x2_t *)v216.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v216.i8, 1))).u32[0];
        float32x2_t v217 = vrsqrte_f32((float32x2_t)v216.u32[0]);
        float32x2_t v218 = vmul_f32(v217, vrsqrts_f32((float32x2_t)v216.u32[0], vmul_f32(v217, v217)));
        float32x4_t v219 = vmulq_n_f32(v215, vmul_f32(v218, vrsqrts_f32((float32x2_t)v216.u32[0], vmul_f32(v218, v218))).f32[0]);
        float32x4_t v220 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v219, (int32x4_t)v219), (int8x16_t)v219, 0xCuLL);
        float32x4_t v221 = vmlaq_f32(vmulq_f32(v220, vnegq_f32(v214)), v219, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v214, (int32x4_t)v214), (int8x16_t)v214, 0xCuLL));
        float32x4_t v222 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v221, (int32x4_t)v221), (int8x16_t)v221, 0xCuLL);
        int32x4_t v223 = (int32x4_t)vmulq_f32(v221, v221);
        v223.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v223.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v223, 2), *(float32x2_t *)v223.i8)).u32[0];
        float32x2_t v224 = vrsqrte_f32((float32x2_t)v223.u32[0]);
        float32x2_t v225 = vmul_f32(v224, vrsqrts_f32((float32x2_t)v223.u32[0], vmul_f32(v224, v224)));
        float32x4_t v226 = vmulq_n_f32(v222, vmul_f32(v225, vrsqrts_f32((float32x2_t)v223.u32[0], vmul_f32(v225, v225))).f32[0]);
        float32x4_t v227 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v226, (int32x4_t)v226), (int8x16_t)v226, 0xCuLL), vnegq_f32(v219)), v226, v220);
        float32x4_t v228 = vmulq_f32(v226, (float32x4_t)0);
        float32x4_t v229 = vmulq_f32(v227, (float32x4_t)0);
        float32x2_t v230 = (float32x2_t)vext_s8(*(int8x8_t *)v228.f32, *(int8x8_t *)v229.f32, 4uLL);
        v229.i32[0] = v228.i32[2];
        *(float32x2_t *)v228.f32 = vadd_f32(*(float32x2_t *)v229.f32, vadd_f32((float32x2_t)__PAIR64__(v229.u32[2], v228.u32[0]), v230));
        float32x4_t v231 = vmulq_f32(v219, (float32x4_t)0);
        v232.i64[0] = __PAIR64__(v227.u32[0], v226.u32[1]);
        v233.i64[0] = __PAIR64__(v227.u32[1], v226.u32[2]);
        v226.i32[1] = v227.i32[2];
        v226.i64[1] = v219.u32[0];
        v232.i64[1] = v219.u32[1];
        v233.i64[1] = v219.u32[2];
        v227.i64[0] = vnegq_f32(v228).u64[0];
        v227.f32[2] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v231, 2), vaddq_f32(v231, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v231.f32, 1))).f32[0];
        v227.i32[3] = 1.0;
        float32x4_t v607 = v226;
        float32x4_t v609 = v233;
        *(float32x4_t *)v695 = v226;
        *(float32x4_t *)&v695[16] = v232;
        float32x4_t v611 = v232;
        *(float32x4_t *)&v695[32] = v233;
        simd_float4 v696 = (simd_float4)v227;
        float32x4_t v605 = v227;
        uint64_t v234 = v189 + 48;
        re::AABB::transform((float32x4_t *)(v189 + 48), v194, (uint64_t)v692);
        float32x4_t v595 = *(float32x4_t *)v692;
        float32x4_t v597 = *(float32x4_t *)&v692[16];
        float32x4_t v235 = vsubq_f32(*(float32x4_t *)&v692[16], *(float32x4_t *)v692);
        v235.i32[3] = 0;
        float32x4_t v236 = vmaxnmq_f32(v235, (float32x4_t)0);
        v237.i64[0] = 0xBF000000BF000000;
        v237.i64[1] = 0xBF000000BF000000;
        v238.i64[0] = 0x3F0000003F000000;
        v238.i64[1] = 0x3F0000003F000000;
        float32x4_t v641 = vmulq_f32(v236, v237);
        float32x4_t v642 = vmulq_f32(v236, v238);
        re::AABB::transform(&v641, (float32x4_t *)v695, (uint64_t)&v639);
        float32x4_t v600 = v639;
        float32x4_t v602 = v640;
        re::BoundingSphere::BoundingSphere(&v637, v234, v194);
        uint32x4_t v239 = (uint32x4_t)vcgtq_f32(v595, v597);
        v239.i32[3] = v239.i32[2];
        float32x4_t v240 = 0uLL;
        if ((vmaxvq_u32(v239) & 0x80000000) == 0)
        {
          v241.i64[0] = 0x3F0000003F000000;
          v241.i64[1] = 0x3F0000003F000000;
          float32x4_t v240 = vmulq_f32(vaddq_f32(v597, v595), v241);
        }
        uint64_t v242 = 0;
        float32x4_t v243 = vsubq_f32(v602, v600);
        v243.i32[3] = 0;
        float v244 = v637.f32[3];
        float v245 = vmuls_lane_f32(0.5, vmaxnmq_f32(v243, (float32x4_t)0), 2);
        float v246 = v637.f32[3] + (float)(v637.f32[3] - v245);
        float32x4_t v247 = vnegq_f32(vsubq_f32(v240, vmulq_n_f32(v612, v246)));
        v247.i32[3] = 1.0;
        v686.columns[0] = (simd_float4)xmmword_23435FD50;
        v686.columns[1] = (simd_float4)xmmword_23435FD60;
        v686.columns[2] = (simd_float4)xmmword_23435FD80;
        v686.columns[3] = (simd_float4)v247;
        do
        {
          *(float32x4_t *)&__src[v242 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v607, COERCE_FLOAT(*(_OWORD *)&v686.columns[v242])), v611, *(float32x2_t *)v686.columns[v242].f32, 1), v609, (float32x4_t)v686.columns[v242], 2), v605, (float32x4_t)v686.columns[v242], 3);
          ++v242;
        }
        while (v242 != 4);
        uint64_t v248 = 0;
        float v249 = v244 + v244;
        float v250 = v249 * 1.001;
        float v251 = (float)(v616[27].f32[3] / 10.0) * 256.0;
        float v252 = v249 / v616[27].f32[2];
        if (v251 < v252) {
          float v251 = v252;
        }
        float v592 = v251;
        float v601 = v250;
        *(float *)&unsigned int v253 = 0.0 / (float)(0.0 - v250);
        v254.i32[1] = 0;
        v254.i64[1] = 0;
        v254.f32[0] = 2.0 / v251;
        v255.i32[0] = 0;
        v255.i64[1] = 0;
        v255.i32[1] = v254.i32[0];
        v256.i64[0] = 0;
        v256.i32[3] = 0;
        v256.f32[2] = 1.0 / (float)(0.0 - v250);
        v257.i64[0] = 0;
        v257.i64[1] = __PAIR64__(1.0, v253);
        simd_float4 v608 = *(simd_float4 *)&__src[16];
        simd_float4 v610 = *(simd_float4 *)__src;
        simd_float4x4 v686 = *(simd_float4x4 *)__src;
        simd_float4 v604 = *(simd_float4 *)&__src[48];
        simd_float4 v606 = *(simd_float4 *)&__src[32];
        uint64_t v189 = v586;
        v186 = v583;
        do
        {
          *(float32x4_t *)&__src[v248 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v254, COERCE_FLOAT(*(_OWORD *)&v686.columns[v248])), v255, *(float32x2_t *)v686.columns[v248].f32, 1), v256, (float32x4_t)v686.columns[v248], 2), v257, (float32x4_t)v686.columns[v248], 3);
          ++v248;
        }
        while (v248 != 4);
        uint64_t v258 = 0;
        float32x4_t v209 = *(float32x4_t *)__src;
        float32x4_t v210 = *(float32x4_t *)&__src[16];
        float v599 = fmaxf(v592 * 10.0, 10.0) / v592;
        v259.i64[0] = 0;
        v259.i32[3] = 0;
        v259.f32[2] = 1.0 / v599;
        float32x4_t v211 = *(float32x4_t *)&__src[32];
        float32x4_t v212 = *(float32x4_t *)&__src[48];
        v686.columns[0] = (simd_float4)xmmword_23435FD50;
        v686.columns[1] = (simd_float4)xmmword_23435FD60;
        v686.columns[2] = v259;
        v686.columns[3] = (simd_float4)xmmword_23435FBB0;
        do
        {
          *(float32x4_t *)&__src[v258 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v254, COERCE_FLOAT(*(_OWORD *)&v686.columns[v258])), v255, *(float32x2_t *)v686.columns[v258].f32, 1), v256, (float32x4_t)v686.columns[v258], 2), v257, (float32x4_t)v686.columns[v258], 3);
          ++v258;
        }
        while (v258 != 4);
        uint64_t v260 = 0;
        float32x4_t v261 = *(float32x4_t *)__src;
        float32x4_t v262 = *(float32x4_t *)&__src[16];
        float32x4_t v263 = *(float32x4_t *)&__src[32];
        float32x4_t v264 = *(float32x4_t *)&__src[48];
        v686.columns[0] = v610;
        v686.columns[1] = v608;
        v686.columns[2] = v606;
        v686.columns[3] = v604;
        do
        {
          *(float32x4_t *)&__src[v260 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v261, COERCE_FLOAT(*(_OWORD *)&v686.columns[v260])), v262, *(float32x2_t *)v686.columns[v260].f32, 1), v263, (float32x4_t)v686.columns[v260], 2), v264, (float32x4_t)v686.columns[v260], 3);
          ++v260;
        }
        while (v260 != 4);
        float32x4_t v590 = *(float32x4_t *)&__src[16];
        float32x4_t v591 = *(float32x4_t *)__src;
        float32x4_t v588 = *(float32x4_t *)&__src[48];
        float32x4_t v589 = *(float32x4_t *)&__src[32];
        float v552 = (float)(v246 - v245) / (float)(v599 * v601);
      }
      else
      {
        float v599 = 0.0;
        float32x4_t v209 = 0uLL;
        float32x4_t v210 = 0uLL;
        float32x4_t v211 = 0uLL;
        float32x4_t v212 = 0uLL;
        float32x4_t v590 = 0u;
        float32x4_t v591 = 0u;
        float32x4_t v588 = 0u;
        float32x4_t v589 = 0u;
        simd_float4 v608 = 0u;
        simd_float4 v610 = 0u;
        simd_float4 v604 = 0u;
        simd_float4 v606 = 0u;
        float32x4_t v612 = 0u;
        float v592 = 0.0;
        float v601 = 0.0;
        float v552 = 0.0;
      }
      v265 = *(unsigned char *)(v189 + 208) ? (unsigned int *)&v616[27].i32[1] : (unsigned int *)((char *)&v616[26].u64[1] + 4);
      unsigned int v581 = *v265;
      float32x4_t v596 = v210;
      float32x4_t v598 = v209;
      float32x4_t v593 = v212;
      float32x4_t v594 = v211;
      if (v192)
      {
        float v559 = NAN;
        float v266 = NAN;
        float v267 = INFINITY;
        if (!re::internal::shadows::g_enableMeshDepthFallbackWhenFlattening) {
          float v267 = NAN;
        }
        float v578 = v267;
      }
      else
      {
        v698.columns[1] = v608;
        v698.columns[0] = v610;
        v698.columns[3] = v604;
        v698.columns[2] = v606;
        simd_float4x4 v699 = __invert_f4(v698);
        if (v186[1].i8[0])
        {
          float32x4_t v268 = vmulq_f32(vsubq_f32((float32x4_t)v699.columns[3], v186[3]), v186[2]);
          float v266 = fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v268, 2), vaddq_f32(v268, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v268.f32, 1))).f32[0]);
        }
        else
        {
          float v266 = NAN;
        }
        float32x4_t v210 = v596;
        float32x4_t v209 = v598;
        float32x4_t v212 = v593;
        float32x4_t v211 = v594;
        uint64_t v189 = v586;
        if (v186[4].i8[0])
        {
          float32x4_t v269 = vmulq_f32(vsubq_f32((float32x4_t)v699.columns[3], v186[6]), v186[5]);
          float v559 = fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v269, 2), vaddq_f32(v269, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v269.f32, 1))).f32[0]);
        }
        else
        {
          float v559 = NAN;
        }
        float v578 = v266;
      }
      float v576 = v266;
      int v575 = v192;
      uint64_t v270 = 0;
      int v572 = re::internal::shadows::g_enableAbsoluteSpace;
      float v579 = v616[29].f32[1];
      float v558 = v616[29].f32[0];
      float v557 = v616[29].f32[2];
      unsigned int v271 = v616[26].u32[2];
      unsigned int v272 = v616[26].u32[1];
      float v273 = v616[26].f32[0];
      simd_float4 v274 = *(simd_float4 *)(v189 + 144);
      simd_float4 v275 = *(simd_float4 *)(v189 + 160);
      simd_float4 v276 = *(simd_float4 *)(v189 + 176);
      v686.columns[0] = *(simd_float4 *)(v189 + 128);
      v686.columns[1] = v274;
      v686.columns[2] = v275;
      v686.columns[3] = v276;
      do
      {
        *(float32x4_t *)&__src[v270 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v209, COERCE_FLOAT(*(_OWORD *)&v686.columns[v270])), v210, *(float32x2_t *)v686.columns[v270].f32, 1), v211, (float32x4_t)v686.columns[v270], 2), v212, (float32x4_t)v686.columns[v270], 3);
        ++v270;
      }
      while (v270 != 4);
      unsigned int v570 = v272;
      float v584 = (float)v272;
      *(_OWORD *)v692 = *(_OWORD *)__src;
      *(_OWORD *)&v692[16] = *(_OWORD *)&__src[16];
      float v277 = (float)(v273 * 3.0) * (float)(v584 / v584);
      long long v693 = *(_OWORD *)&__src[32];
      long long v694 = *(_OWORD *)&__src[48];
      v278 = (float32x2_t *)v189;
      re::AABB::transform((float32x4_t *)(v189 + 48), (float32x4_t *)v692, (uint64_t)&v641);
      float32x4_t v279 = *(float32x4_t *)v278[8].f32;
      float32x4_t v639 = *(float32x4_t *)v278[6].f32;
      float32x4_t v640 = v279;
      *(float32x2_t *)__src = vmaxnm_f32(vsub_f32(v278[8], v278[6]), 0);
      float v280 = re::MeshShadowCasterParams::PlaneProxyParams::calcShadowProxyThicknessInLocalCoord((float32x2_t *)__src, v194);
      float v281 = v616[36].f32[0];
      v639.f32[2] = (float)-(float)(v281 * v280) * 0.5;
      v640.f32[2] = (float)(v280 * v281) * 0.5;
      re::AABB::transform(&v639, (float32x4_t *)v692, (uint64_t)&v637);
      float v282 = ceilf(v277 * 2.4477);
      float32x2_t v283 = *(float32x2_t *)v641.f32;
      float32x2_t v284 = *(float32x2_t *)v642.f32;
      float32x2_t v285 = *(float32x2_t *)v637.f32;
      float32x2_t v286 = v638;
      bzero(__src, 0x3A0uLL);
      uint64_t v291 = 0;
      long long v292 = 0uLL;
      do
      {
        v293 = &__src[v291];
        v293[7] = 0uLL;
        v293[8] = 0uLL;
        v293[5] = 0uLL;
        v293[6] = 0uLL;
        v293[3] = 0uLL;
        v293[4] = 0uLL;
        v293[10] = 0uLL;
        v293[11] = 0uLL;
        v291 += 224;
        v293[12] = 0uLL;
        v293[13] = 0uLL;
      }
      while (v291 != 896);
      float v294 = v584;
      float v295 = v584 * 0.5;
      float v296 = v572 ? v601 : 1.0;
      *(float *)&long long v292 = (float)(v271 >> 1);
      float32x2_t v297 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v292, 0);
      float32x2_t v298 = vmla_n_f32(v297, v283, v295);
      float32x2_t v299 = vmla_n_f32(v297, v284, v295);
      float32x2_t v300 = vmla_n_f32(v297, v285, v295);
      *(float32x2_t *)&long long v292 = vmla_n_f32(v297, v286, v295);
      *(float *)&__src[896] = v277;
      *(_DWORD *)&__src[900] = v282;
      *(void *)&__src[904] = __PAIR64__(LODWORD(v599), LODWORD(v296));
      float v556 = v576 / v601;
      *(float *)&__src[912] = v576 / v601;
      uint64_t v301 = v616[27].u32[0];
      float v577 = v296;
      if (v301)
      {
        uint64_t v302 = 0;
        float32x2_t v303 = vadd_f32(v298, (float32x2_t)0x3F0000003F000000);
        float32x2_t v304 = vadd_f32(v299, (float32x2_t)0xBF000000BF000000);
        float32x2_t v305 = vadd_f32(v300, (float32x2_t)0x3F0000003F000000);
        unsigned int v306 = v581;
        *(float *)v288.i32 = (float)v581;
        *(float *)v287.i32 = (float)v282;
        float32x2_t v307 = vadd_f32(*(float32x2_t *)&v292, (float32x2_t)0xBF000000BF000000);
        float32x2_t v308 = vsub_f32(v304, v303);
        float32x2_t v309 = (float32x2_t)vdup_lane_s32(v288, 0);
        float32x2_t v310 = (float32x2_t)vdup_lane_s32(v287, 0);
        float v311 = 1.0;
        uint64_t v312 = v586;
        do
        {
          float32x2_t v313 = v304;
          float32x2_t v314 = v303;
          float32x2_t v315 = v308;
          float32x2_t v316 = v307;
          float32x2_t v317 = v305;
          if (v302)
          {
            v318 = &__src[224 * v302];
            float32x2_t v314 = vmul_f32(*(float32x2_t *)(v318 - 224), (float32x2_t)0x3F0000003F000000);
            float32x2_t v313 = vmul_f32(*(float32x2_t *)(v318 - 216), (float32x2_t)0x3F0000003F000000);
            float32x2_t v315 = vsub_f32(v313, v314);
            float32x2_t v317 = vmul_f32(*(float32x2_t *)(v318 - 208), (float32x2_t)0x3F0000003F000000);
            float32x2_t v316 = vmul_f32(*(float32x2_t *)(v318 - 200), (float32x2_t)0x3F0000003F000000);
          }
          float32x2_t v319 = vadd_f32(v315, v618);
          float32x2_t v320 = vadd_f32(vsub_f32(v316, v317), v618);
          float32x2_t v321 = vdiv_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v320, v309), (int8x8_t)v320, (int8x8_t)v309), v320);
          int v322 = *(unsigned __int8 *)(v586 + 208);
          if (*(unsigned char *)(v586 + 208))
          {
            float32x2_t v323 = vmul_f32(v319, v321);
            v319.f32[0] = (float)(v570 >> v302);
            float32x2_t v324 = (float32x2_t)vdup_lane_s32((int32x2_t)v319, 0);
            float32x2_t v325 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v323, v324), (int8x8_t)v324, (int8x8_t)v323);
          }
          else
          {
            float32x2_t v325 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v319, v309), (int8x8_t)v319, (int8x8_t)v309);
          }
          float32x2_t v326 = vadd_f32(v313, v314);
          *(float32x2_t *)v327.f32 = vmul_f32(v325, (float32x2_t)0x3F0000003F000000);
          *(float32x2_t *)v328.f32 = vmul_f32(v326, (float32x2_t)0x3F0000003F000000);
          *(float32x2_t *)&long long v290 = vadd_f32(vsub_f32(*(float32x2_t *)v328.f32, *(float32x2_t *)v327.f32), (float32x2_t)0x3F0000003F000000);
          *(void *)&__src[224 * v302] = v290;
          float32x2_t v329 = vmul_f32(vmul_f32(v320, v321), (float32x2_t)0x3F0000003F000000);
          float32x2_t v330 = vadd_f32(*(float32x2_t *)v328.f32, v329);
          v328.i64[1] = v328.i64[0];
          *(float32x2_t *)&v327.u32[2] = v329;
          v331 = &__src[224 * v302];
          v332.i64[0] = vaddq_f32(v328, v327).u64[0];
          v332.i64[1] = vsubq_f32(v328, v327).i64[1];
          float32x4_t v333 = vaddq_f32(v332, (float32x4_t)xmmword_2343E7260);
          *(float32x4_t *)(v331 + 8) = v333;
          *((float32x2_t *)v331 + 3) = vadd_f32(v330, (float32x2_t)0xBF000000BF000000);
          float v334 = *(float *)&v290 - *(float *)v287.i32;
          float v335 = *((float *)&v290 + 1) - *(float *)v287.i32;
          *((float *)v331 + 8) = *(float *)&v290 - *(float *)v287.i32;
          *((float *)v331 + 9) = *((float *)&v290 + 1) - *(float *)v287.i32;
          float32x2_t v336 = vadd_f32(*(float32x2_t *)v333.f32, v310);
          *((float32x2_t *)v331 + 5) = v336;
          __asm { FMOV            V24.4S, #1.0 }
          if (v302)
          {
            uint64_t v338 = 0;
            v339.i32[1] = 0;
            v339.i64[1] = 0;
            v339.f32[0] = v311 / (float)(v271 >> (v302 - 1));
            v340.i32[0] = 0;
            v340.i64[1] = 0;
            v340.f32[1] = v339.f32[0];
            v341 = (float32x2_t *)&__src[224 * (v302 - 1)];
            float32x2_t v342 = *v341;
            *(float32x2_t *)&long long v289 = vadd_f32(*v341, (float32x2_t)0x3F0000003F000000);
            *((float *)&v289 + 2) = v311;
            float v344 = v341[1].f32[0];
            float v343 = v341[1].f32[1];
            *(_OWORD *)v695 = xmmword_23435FD50;
            *(_OWORD *)&v695[16] = xmmword_23435FD60;
            *(_OWORD *)&v695[32] = v289;
            do
            {
              v686.columns[v338] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v339, COERCE_FLOAT(*(_OWORD *)&v695[v338 * 16])), v340, *(float32x2_t *)&v695[v338 * 16], 1), (float32x4_t)xmmword_23435FD80, *(float32x4_t *)&v695[v338 * 16], 2);
              ++v338;
            }
            while (v338 != 3);
            uint64_t v345 = 0;
            float v346 = (float)(v344 - v342.f32[0]) / (float)(v333.f32[0] - *(float *)&v290);
            float v347 = (float)(v343 - v342.f32[1]) / (float)(v333.f32[1] - *((float *)&v290 + 1));
            float32x4_t v348 = (float32x4_t)v686.columns[0];
            float32x4_t v349 = (float32x4_t)v686.columns[1];
            float32x4_t v350 = (float32x4_t)v686.columns[2];
            float v351 = v346;
            LODWORD(v352) = 0;
            *((float *)&v352 + 1) = v347;
            *(_OWORD *)v695 = LODWORD(v351);
            *(_OWORD *)&v695[16] = v352;
            *(_OWORD *)&v695[32] = xmmword_23435FD80;
            do
            {
              v686.columns[v345] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v348, COERCE_FLOAT(*(_OWORD *)&v695[v345 * 16])), v349, *(float32x2_t *)&v695[v345 * 16], 1), v350, *(float32x4_t *)&v695[v345 * 16], 2);
              ++v345;
            }
            while (v345 != 3);
            uint64_t v353 = 0;
            float32x4_t v354 = (float32x4_t)v686.columns[0];
            float32x4_t v355 = (float32x4_t)v686.columns[1];
            float32x4_t v356 = (float32x4_t)v686.columns[2];
            *(float32x2_t *)&long long v290 = vneg_f32(*(float32x2_t *)&v290);
            float v311 = 1.0;
            DWORD2(v290) = 1.0;
            *(_OWORD *)v695 = xmmword_23435FD50;
            *(_OWORD *)&v695[16] = xmmword_23435FD60;
            *(_OWORD *)&v695[32] = v290;
            do
            {
              v686.columns[v353] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v354, COERCE_FLOAT(*(_OWORD *)&v695[v353 * 16])), v355, *(float32x2_t *)&v695[v353 * 16], 1), v356, *(float32x4_t *)&v695[v353 * 16], 2);
              ++v353;
            }
            while (v353 != 3);
            uint64_t v357 = 0;
            uint64_t v358 = v686.columns[0].i64[0];
            simd_float4 v359 = v686.columns[1];
            v360 = &__src[224 * v302];
            *((_DWORD *)v360 + 14) = v686.columns[0].i32[2];
            *((_DWORD *)v360 + 18) = v359.i32[2];
            simd_float4 v361 = v686.columns[2];
            *((void *)v360 + 6) = v358;
            *((void *)v360 + 8) = v359.i64[0];
            *((void *)v360 + 10) = v361.i64[0];
            *((_DWORD *)v360 + 22) = v361.i32[2];
            v362 = &__src[224 * (v302 - 1)];
            float v363 = *((float *)v362 + 10);
            float v364 = *((float *)v362 + 11);
            float32x2_t v365 = *(float32x2_t *)(v362 + 32);
            *(float32x2_t *)v356.f32 = vadd_f32(v365, (float32x2_t)0x3F0000003F000000);
            v356.i32[2] = 1.0;
            *(_OWORD *)v695 = xmmword_23435FD50;
            *(_OWORD *)&v695[16] = xmmword_23435FD60;
            *(float32x4_t *)&v695[32] = v356;
            do
            {
              v686.columns[v357] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v339, COERCE_FLOAT(*(_OWORD *)&v695[v357 * 16])), v340, *(float32x2_t *)&v695[v357 * 16], 1), (float32x4_t)xmmword_23435FD80, *(float32x4_t *)&v695[v357 * 16], 2);
              ++v357;
            }
            while (v357 != 3);
            uint64_t v366 = 0;
            float32x4_t v367 = (float32x4_t)v686.columns[0];
            float32x4_t v368 = (float32x4_t)v686.columns[1];
            float32x4_t v369 = (float32x4_t)v686.columns[2];
            v365.f32[0] = (float)(v363 - v365.f32[0]) / (float)(v336.f32[0] - v334);
            LODWORD(v370) = 0;
            *((float *)&v370 + 1) = (float)(v364 - v365.f32[1]) / (float)(v336.f32[1] - v335);
            *(_OWORD *)v695 = v365.u32[0];
            *(_OWORD *)&v695[16] = v370;
            *(_OWORD *)&v695[32] = xmmword_23435FD80;
            do
            {
              v686.columns[v366] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v367, COERCE_FLOAT(*(_OWORD *)&v695[v366 * 16])), v368, *(float32x2_t *)&v695[v366 * 16], 1), v369, *(float32x4_t *)&v695[v366 * 16], 2);
              ++v366;
            }
            while (v366 != 3);
            uint64_t v371 = 0;
            float32x4_t v372 = (float32x4_t)v686.columns[0];
            float32x4_t v373 = (float32x4_t)v686.columns[1];
            float32x4_t v374 = (float32x4_t)v686.columns[2];
            *((void *)&v375 + 1) = *((void *)&_Q24 + 1);
            *(float *)&long long v375 = -v334;
            *((float *)&v375 + 1) = -v335;
            *(_OWORD *)v695 = xmmword_23435FD50;
            *(_OWORD *)&v695[16] = xmmword_23435FD60;
            *(_OWORD *)&v695[32] = v375;
            do
            {
              v686.columns[v371] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v372, COERCE_FLOAT(*(_OWORD *)&v695[v371 * 16])), v373, *(float32x2_t *)&v695[v371 * 16], 1), v374, *(float32x4_t *)&v695[v371 * 16], 2);
              ++v371;
            }
            while (v371 != 3);
            __int32 v376 = v686.columns[0].i32[2];
            simd_float4 v377 = v686.columns[1];
            simd_float4 v378 = v686.columns[2];
            v379 = &__src[224 * v302];
            *((void *)v379 + 12) = v686.columns[0].i64[0];
            *((_DWORD *)v379 + 26) = v376;
            *((_DWORD *)v379 + 30) = v377.i32[2];
            *((void *)v379 + 14) = v377.i64[0];
            *((void *)v379 + 16) = v378.i64[0];
            *((_DWORD *)v379 + 34) = v378.i32[2];
            char v380 = v302;
          }
          else
          {
            char v380 = 0;
          }
          uint64_t v381 = 0;
          float v382 = (float)(1 << v380);
          v383 = (float *)&__src[224 * v302];
          v383[36] = v334 * v382;
          v383[37] = v335 * v382;
          v383[38] = v382 * v336.f32[0];
          v383[39] = vmuls_lane_f32(v382, v336, 1);
          v384.i32[1] = 0;
          v384.i64[1] = 0;
          v385.i32[0] = 0;
          v385.i64[1] = 0;
          *((void *)&v386 + 1) = *((void *)&_Q24 + 1);
          *(float *)&long long v386 = v334 + 0.5;
          *((float *)&v386 + 1) = v335 + 0.5;
          HIDWORD(v289) = 0;
          HIDWORD(v290) = 0;
          *(_OWORD *)v695 = xmmword_23435FD50;
          *(_OWORD *)&v695[16] = xmmword_23435FD60;
          *(_OWORD *)&v695[32] = v386;
          do
          {
            v384.f32[0] = v311 / (float)(v271 >> v380);
            v385.f32[1] = v384.f32[0];
            v686.columns[v381] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v384, COERCE_FLOAT(*(_OWORD *)&v695[v381 * 16])), v385, *(float32x2_t *)&v695[v381 * 16], 1), (float32x4_t)xmmword_23435FD80, *(float32x4_t *)&v695[v381 * 16], 2);
            ++v381;
          }
          while (v381 != 3);
          uint64_t v387 = 0;
          float32x4_t v388 = (float32x4_t)v686.columns[0];
          float32x4_t v389 = (float32x4_t)v686.columns[1];
          float32x4_t v390 = (float32x4_t)v686.columns[2];
          LODWORD(v391) = 0;
          *((float *)&v391 + 1) = v311 / v382;
          *(_OWORD *)v695 = COERCE_UNSIGNED_INT(v311 / v382);
          *(_OWORD *)&v695[16] = v391;
          *(_OWORD *)&v695[32] = xmmword_23435FD80;
          do
          {
            v686.columns[v387] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v388, COERCE_FLOAT(*(_OWORD *)&v695[v387 * 16])), v389, *(float32x2_t *)&v695[v387 * 16], 1), v390, *(float32x4_t *)&v695[v387 * 16], 2);
            ++v387;
          }
          while (v387 != 3);
          uint64_t v392 = 0;
          float32x4_t v393 = (float32x4_t)v686.columns[0];
          float32x4_t v394 = (float32x4_t)v686.columns[1];
          float32x4_t v395 = (float32x4_t)v686.columns[2];
          *(float *)&_Q24 = -(float)(v334 * v382);
          *((float *)&_Q24 + 1) = -(float)(v335 * v382);
          *(_OWORD *)v695 = xmmword_23435FD50;
          *(_OWORD *)&v695[16] = xmmword_23435FD60;
          *(_OWORD *)&v695[32] = _Q24;
          do
          {
            v686.columns[v392] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v393, COERCE_FLOAT(*(_OWORD *)&v695[v392 * 16])), v394, *(float32x2_t *)&v695[v392 * 16], 1), v395, *(float32x4_t *)&v695[v392 * 16], 2);
            ++v392;
          }
          while (v392 != 3);
          __int32 v396 = v686.columns[0].i32[2];
          simd_float4 v397 = v686.columns[1];
          simd_float4 v398 = v686.columns[2];
          v399 = (float32x2_t *)&__src[224 * v302];
          v399[22] = *(float32x2_t *)v686.columns[0].f32;
          v399[23].i32[0] = v396;
          v399[25].i32[0] = v397.i32[2];
          v399[24] = *(float32x2_t *)v397.f32;
          v399[26] = *(float32x2_t *)v398.f32;
          v399[27].i32[0] = v398.i32[2];
          float v400 = (float)(v334 + v336.f32[0]) * 0.5;
          v397.f32[0] = (float)(v335 + v336.f32[1]) * 0.5;
          float v401 = (float)(v592 / v584) * v382;
          v402.f32[0] = v334 - v400;
          v402.f32[1] = v335 - v397.f32[0];
          v336.f32[0] = v336.f32[0] - v400;
          v336.f32[1] = v336.f32[1] - v397.f32[0];
          v399[20] = vmul_n_f32(v402, v401);
          v399[21] = vmul_n_f32(v336, v401);
          ++v302;
        }
        while (v302 != v301);
        v403.i32[1] = *(_DWORD *)&__src[148];
        float32x2_t v404 = *(float32x2_t *)&__src[152];
        float32x2_t v554 = *(float32x2_t *)&__src[144];
        float v296 = v577;
        float v294 = v584;
      }
      else
      {
        uint64_t v312 = v586;
        int v322 = *(unsigned __int8 *)(v586 + 208);
        v403.i32[1] = 0;
        float32x2_t v554 = 0;
        float32x2_t v404 = 0;
        unsigned int v306 = v581;
      }
      unint64_t v405 = 0;
      *(float *)v403.i32 = (float)v271;
      int32x2_t v555 = v403;
      float v406 = v294 / (float)v271;
      if ((int)v301 <= 1) {
        LODWORD(v301) = 1;
      }
      v407 = &__src[224 * (v301 - 1)];
      float32x2_t v408 = vsub_f32(v299, v298);
      float v409 = (float)v306;
      if (v408.f32[0] <= (float)v306) {
        float v410 = (float)v306;
      }
      else {
        float v410 = v408.f32[0];
      }
      if (v408.f32[1] <= v409) {
        float v411 = (float)v306;
      }
      else {
        float v411 = v408.f32[1];
      }
      float32x2_t v412 = vsub_f32(*(float32x2_t *)&v292, v300);
      if (v412.f32[0] <= v409) {
        float v413 = (float)v306;
      }
      else {
        float v413 = v412.f32[0];
      }
      v412.f32[0] = v413 / v412.f32[0];
      if (v412.f32[1] > v409) {
        float v409 = v412.f32[1];
      }
      float v414 = v408.f32[0] * v412.f32[0];
      if (v414 > v294) {
        float v414 = v294;
      }
      float v415 = v408.f32[1] * (float)(v409 / v412.f32[1]);
      if (v415 > v294) {
        float v415 = v294;
      }
      if (!v322)
      {
        float v414 = v410;
        float v415 = v411;
      }
      float32_t v416 = v406 * (float)(v415 / v408.f32[1]);
      v417.i32[1] = 0;
      v417.i64[1] = 0;
      v417.f32[0] = v406 * (float)(v414 / v408.f32[0]);
      v418.i32[0] = 0;
      v418.i64[1] = 0;
      v418.f32[1] = v416;
      float32x2_t v420 = *(float32x2_t *)(v407 + 144);
      float32x2_t v419 = *(float32x2_t *)(v407 + 152);
      *(float32x4_t *)v695 = v598;
      *(float32x4_t *)&v695[16] = v596;
      float v565 = v579 * v296;
      *(float32x4_t *)&v695[32] = v594;
      simd_float4 v696 = (simd_float4)v593;
      do
      {
        v686.columns[v405 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v417, COERCE_FLOAT(*(_OWORD *)&v695[v405])), v418, *(float32x2_t *)&v695[v405], 1), (float32x4_t)xmmword_23435FD80, *(float32x4_t *)&v695[v405], 2), (float32x4_t)xmmword_23435FBB0, *(float32x4_t *)&v695[v405], 3);
        v405 += 16;
      }
      while (v405 != 64);
      unint64_t v421 = 0;
      v422.i32[0] = 0;
      v422.i64[1] = 0;
      v422.f32[1] = v294 / (float)v271;
      simd_float4 v585 = v686.columns[1];
      simd_float4 v587 = v686.columns[0];
      simd_float4 v580 = v686.columns[3];
      simd_float4 v582 = v686.columns[2];
      *(float32x4_t *)v695 = v591;
      *(float32x4_t *)&v695[16] = v590;
      *(float32x4_t *)&v695[32] = v589;
      simd_float4 v696 = (simd_float4)v588;
      do
      {
        v686.columns[v421 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)LODWORD(v406), COERCE_FLOAT(*(_OWORD *)&v695[v421])), v422, *(float32x2_t *)&v695[v421], 1), (float32x4_t)xmmword_23435FD80, *(float32x4_t *)&v695[v421], 2), (float32x4_t)xmmword_23435FBB0, *(float32x4_t *)&v695[v421], 3);
        v421 += 16;
      }
      while (v421 != 64);
      unint64_t v423 = 0;
      simd_float4 v550 = v686.columns[1];
      simd_float4 v551 = v686.columns[0];
      simd_float4 v548 = v686.columns[3];
      simd_float4 v549 = v686.columns[2];
      *(float32x4_t *)v695 = v598;
      *(float32x4_t *)&v695[16] = v596;
      *(float32x4_t *)&v695[32] = v594;
      simd_float4 v696 = (simd_float4)v593;
      do
      {
        v686.columns[v423 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)LODWORD(v406), COERCE_FLOAT(*(_OWORD *)&v695[v423])), v422, *(float32x2_t *)&v695[v423], 1), (float32x4_t)xmmword_23435FD80, *(float32x4_t *)&v695[v423], 2), (float32x4_t)xmmword_23435FBB0, *(float32x4_t *)&v695[v423], 3);
        v423 += 16;
      }
      while (v423 != 64);
      simd_float4 v571 = v686.columns[1];
      simd_float4 v573 = v686.columns[0];
      simd_float4 v568 = v686.columns[3];
      simd_float4 v569 = v686.columns[2];
      uint64_t v424 = *(void *)(v312 + 16);
      simd_float4 v566 = (simd_float4)xmmword_23435FBB0;
      simd_float4 v567 = (simd_float4)xmmword_23435FD80;
      if (v424)
      {
        uint64_t v425 = 16 * v424;
        uint64_t v426 = *(void *)(v312 + 32);
        while (!*(unsigned char *)(v426 + 8))
        {
          v426 += 16;
          v425 -= 16;
          if (!v425) {
            goto LABEL_346;
          }
        }
      }
      else
      {
        uint64_t v426 = *(void *)(v312 + 32);
      }
      if (!v616[30].i8[8] || v426 == *(void *)(v312 + 32) + 16 * v424)
      {
LABEL_346:
        char v430 = 0;
        float v546 = 0.0;
        float v547 = 1.0;
      }
      else
      {
        float v428 = v616[30].f32[3];
        float v429 = v616[31].f32[0] - v428;
        char v430 = 1;
        float v546 = v296 / v429;
        float v547 = (float)-v428 / v429;
      }
      unsigned int v431 = *(_DWORD *)(v312 + 200);
      uint64_t v432 = *(void *)(v312 + 192);
      __int32 v433 = v616[31].i32[1];
      v700.columns[1] = v608;
      v700.columns[0] = v610;
      v700.columns[3] = v604;
      v700.columns[2] = v606;
      simd_float4x4 v701 = __invert_f4(v700);
      __asm { FMOV            V10.2S, #-1.0 }
      simd_float4 v562 = v701.columns[1];
      simd_float4 v563 = v701.columns[0];
      simd_float4 v560 = v701.columns[3];
      simd_float4 v561 = v701.columns[2];
      if (!v574) {
        break;
      }
      if (v575 || !re::internal::shadows::g_enableShadowFlattening || (simd_float4 v435 = v701.columns[1], v578 == INFINITY))
      {
        simd_float4 v542 = (simd_float4)xmmword_23435FD60;
        simd_float4 v543 = (simd_float4)xmmword_23435FD50;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98018, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_26AF98018))
        {
          xmmword_26AF98060 = xmmword_234385420;
          *(_OWORD *)algn_26AF98070 = xmmword_2343ACD40;
          xmmword_26AF98080 = xmmword_23435FD80;
          unk_26AF98090 = xmmword_2343ACD50;
          __cxa_guard_release(&qword_26AF98018);
        }
        unint64_t v469 = 0;
        float32x4_t v470 = (float32x4_t)xmmword_26AF98060;
        float32x4_t v471 = *(float32x4_t *)algn_26AF98070;
        float32x4_t v472 = (float32x4_t)xmmword_26AF98080;
        float32x4_t v473 = (float32x4_t)unk_26AF98090;
        *(simd_float4 *)v695 = v573;
        *(simd_float4 *)&v695[16] = v571;
        *(simd_float4 *)&v695[32] = v569;
        simd_float4 v696 = v568;
        do
        {
          v686.columns[v469 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v470, COERCE_FLOAT(*(_OWORD *)&v695[v469])), v471, *(float32x2_t *)&v695[v469], 1), v472, *(float32x4_t *)&v695[v469], 2), v473, *(float32x4_t *)&v695[v469], 3);
          v469 += 16;
        }
        while (v469 != 64);
        simd_float4x4 v702 = __invert_f4(v686);
        uint64_t v474 = 0;
        v475.i32[1] = v618.i32[1];
        *(float *)v475.i32 = (float)v616[26].u32[2];
        float32x2_t v476 = (float32x2_t)vdup_lane_s32(v475, 0);
        *(float32x2_t *)&long long v477 = vdiv_f32(vadd_f32(*(float32x2_t *)&__src[816], v618), v476);
        *(float32x2_t *)&long long v478 = vdiv_f32(vadd_f32(*(float32x2_t *)&__src[824], _D10), v476);
        v479.i64[0] = v477;
        v479.i64[1] = 0x3F80000000000000;
        unint64_t v480 = __PAIR64__(DWORD1(v478), v477);
        v481.i64[0] = __PAIR64__(DWORD1(v478), v477);
        v481.i64[1] = 0x3F80000000000000;
        v482.i64[0] = v478;
        v482.i64[1] = 0x3F80000000000000;
        *(void *)&long long v483 = __PAIR64__(DWORD1(v477), v478);
        v484.i64[0] = __PAIR64__(DWORD1(v477), v478);
        v484.i64[1] = 0x3F80000000000000;
        *((float *)&v477 + 2) = (float)((float)(4.6052 / v565) + 1.0) - v616[31].f32[2];
        HIDWORD(v477) = 1.0;
        v486.i64[1] = __PAIR64__(1.0, DWORD2(v477));
        v686.columns[0] = v479;
        v686.columns[1] = v481;
        *((void *)&v478 + 1) = __PAIR64__(1.0, DWORD2(v477));
        v686.columns[2] = v482;
        v686.columns[3] = v484;
        *((void *)&v483 + 1) = __PAIR64__(1.0, DWORD2(v477));
        long long v687 = v477;
        float32x4_t v688 = v486;
        long long v689 = v478;
        long long v690 = v483;
        float32x4_t v485 = (float32x4_t)vdupq_n_s32(0x7F800000u);
        v486.i64[0] = 0x7F0000007FLL;
        v486.i32[2] = 127;
        do
        {
          float32x4_t v487 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v702.columns[0], COERCE_FLOAT(*(_OWORD *)&v686.columns[v474])), (float32x4_t)v702.columns[1], *(float32x2_t *)v686.columns[v474].f32, 1), (float32x4_t)v702.columns[2], (float32x4_t)v686.columns[v474], 2), (float32x4_t)v702.columns[3], (float32x4_t)v686.columns[v474], 3);
          float32x4_t v488 = vdivq_f32(v487, (float32x4_t)vdupq_laneq_s32((int32x4_t)v487, 3));
          v485.i32[3] = 0;
          v488.i32[3] = 0;
          float32x4_t v485 = vminnmq_f32(v485, v488);
          v486.i32[3] = 0;
          float32x4_t v486 = vmaxnmq_f32(v486, v488);
          ++v474;
        }
        while (v474 != 8);
        char v464 = 1;
        float32x4_t v544 = v486;
        int32x4_t v545 = (int32x4_t)v485;
        goto LABEL_368;
      }
      float32x4_t v544 = (float32x4_t)v574[1];
      int32x4_t v545 = *v574;
      v436 = &off_23435F000;
      if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_414, memory_order_acquire) & 1) == 0)
      {
        int v503 = __cxa_guard_acquire(&_MergedGlobals_414);
        v701.columns[3] = v560;
        v701.columns[2] = v561;
        simd_float4 v435 = v562;
        v701.columns[0] = v563;
        v436 = &off_23435F000;
        if (v503)
        {
          xmmword_26AF98020 = xmmword_23435FD50;
          unk_26AF98030 = xmmword_23435FD60;
          xmmword_26AF98040 = xmmword_23435FD80;
          unk_26AF98050 = xmmword_2343ACD50;
          __cxa_guard_release(&_MergedGlobals_414);
          v701.columns[3] = v560;
          v701.columns[2] = v561;
          simd_float4 v435 = v562;
          v701.columns[0] = v563;
          v436 = &off_23435F000;
        }
      }
      unint64_t v437 = 0;
      v438.i64[0] = *(void *)&__src[832];
      v438.i64[1] = 0x3F80000000000000;
      int32x4_t v439 = vdupq_lane_s32(0, 0);
      int32x4_t v440 = v439;
      float32x2_t v441 = vsub_f32(*(float32x2_t *)&__src[840], *(float32x2_t *)&__src[832]);
      v439.i32[1] = v441.i32[1];
      v440.i32[0] = v441.i32[0];
      *(int32x4_t *)v695 = v440;
      *(int32x4_t *)&v695[16] = v439;
      *(_OWORD *)&v695[32] = 0uLL;
      simd_float4 v696 = (simd_float4)xmmword_23435FBB0;
      do
      {
        float32x4_t v442 = *((float32x4_t *)v436 + 216);
        v686.columns[v437 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_23435FD50, COERCE_FLOAT(*(_OWORD *)&v695[v437])), (float32x4_t)xmmword_23435FD60, *(float32x2_t *)&v695[v437], 1), v442, *(float32x4_t *)&v695[v437], 2), v438, *(float32x4_t *)&v695[v437], 3);
        v437 += 16;
      }
      while (v437 != 64);
      unint64_t v443 = 0;
      simd_float4 v444 = v686.columns[0];
      simd_float4 v445 = v686.columns[1];
      simd_float4 v446 = v686.columns[2];
      simd_float4 v447 = v686.columns[3];
      float32x4_t v448 = vmulq_n_f32(v612, v578);
      v448.i32[3] = 1.0;
      *(simd_float4 *)v695 = v701.columns[0];
      *(simd_float4 *)&v695[16] = v435;
      *(simd_float4 *)&v695[32] = v701.columns[2];
      simd_float4 v696 = v701.columns[3];
      do
      {
        v686.columns[v443 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_23435FD50, COERCE_FLOAT(*(_OWORD *)&v695[v443])), (float32x4_t)xmmword_23435FD60, *(float32x2_t *)&v695[v443], 1), v442, *(float32x4_t *)&v695[v443], 2), v448, *(float32x4_t *)&v695[v443], 3);
        v443 += 16;
      }
      while (v443 != 64);
      unint64_t v449 = 0;
      float32x4_t v450 = (float32x4_t)v686.columns[0];
      float32x4_t v451 = (float32x4_t)v686.columns[1];
      float32x4_t v452 = (float32x4_t)v686.columns[2];
      float32x4_t v453 = (float32x4_t)v686.columns[3];
      *(simd_float4 *)v695 = v444;
      *(simd_float4 *)&v695[16] = v445;
      *(simd_float4 *)&v695[32] = v446;
      simd_float4 v696 = v447;
      do
      {
        v686.columns[v449 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v450, COERCE_FLOAT(*(_OWORD *)&v695[v449])), v451, *(float32x2_t *)&v695[v449], 1), v452, *(float32x4_t *)&v695[v449], 2), v453, *(float32x4_t *)&v695[v449], 3);
        v449 += 16;
      }
      while (v449 != 64);
      unint64_t v454 = 0;
      float32x4_t v455 = (float32x4_t)v686.columns[0];
      float32x4_t v456 = (float32x4_t)v686.columns[1];
      float32x4_t v457 = (float32x4_t)v686.columns[2];
      float32x4_t v458 = (float32x4_t)v686.columns[3];
      *(_OWORD *)v695 = xmmword_26AF98020;
      *(_OWORD *)&v695[16] = unk_26AF98030;
      *(_OWORD *)&v695[32] = xmmword_26AF98040;
      simd_float4 v696 = (simd_float4)unk_26AF98050;
      float v459 = v559;
      float v460 = v577;
      int32x2_t v461 = v555;
      unsigned int v462 = v431;
      float32x2_t v463 = v554;
      do
      {
        v686.columns[v454 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v455, COERCE_FLOAT(*(_OWORD *)&v695[v454])), v456, *(float32x2_t *)&v695[v454], 1), v457, *(float32x4_t *)&v695[v454], 2), v458, *(float32x4_t *)&v695[v454], 3);
        v454 += 16;
      }
      while (v454 != 64);
      char v464 = 0;
      simd_float4 v542 = v686.columns[1];
      simd_float4 v543 = v686.columns[0];
      simd_float4 v566 = v686.columns[3];
      simd_float4 v567 = v686.columns[2];
      float v465 = v558;
      float v466 = v557;
      float v467 = v556;
LABEL_369:
      float32x2_t v489 = vmul_f32(vadd_f32(v420, v419), (float32x2_t)0x3F0000003F000000);
      float32x2_t v490 = vmul_f32(vadd_f32(v404, v463), (float32x2_t)0x3F0000003F000000);
      buf[0].n128_f32[2] = v459 / v601;
      buf[0].n128_f32[3] = v565;
      buf[1].n128_f32[0] = v460 * v465;
      buf[1].n128_f32[1] = v460 * v466;
      buf[1].n128_u64[1] = v462;
      *((float *)&v644 + 3) = v546;
      v645.i64[0] = __PAIR64__(v433, LODWORD(v547));
      simd_float4 v650 = v551;
      simd_float4 v651 = v550;
      simd_float4 v652 = v549;
      simd_float4 v653 = v548;
      float32x2_t v491 = (float32x2_t)vdup_lane_s32(v461, 0);
      float32x2_t v654 = vdiv_f32(vadd_f32(vsub_f32(v463, v490), _D10), v491);
      float32x2_t v655 = vsub_f32(vdiv_f32(vadd_f32(vsub_f32(v404, v490), v618), v491), v654);
      *(float32x2_t *)&long long v656 = vdiv_f32(vadd_f32(vsub_f32(v420, v489), (float32x2_t)0xBF000000BF000000), v491);
      *((float32x2_t *)&v656 + 1) = vsub_f32(vdiv_f32(vadd_f32(vsub_f32(v419, (float32x2_t)vdup_lane_s32((int32x2_t)v489, 0)), (float32x2_t)0x3F0000003F000000), v491), *(float32x2_t *)&v656);
      buf[0].n128_u64[0] = __PAIR64__(LODWORD(v599), LODWORD(v467));
      *(void *)&long long v644 = v432;
      BYTE8(v644) = v575;
      BYTE9(v644) = v430;
      WORD5(v644) = 0;
      simd_float4 v646 = v587;
      int32x4_t v647 = (int32x4_t)v585;
      simd_float4 v648 = v582;
      simd_float4 v649 = v580;
      *(float *)&long long v657 = v552;
      memcpy(v658, __src, 0x394uLL);
      float v659 = v578;
      simd_float4 v660 = v563;
      simd_float4 v661 = v562;
      simd_float4 v662 = v561;
      simd_float4 v663 = v560;
      float v664 = v601;
      int v665 = v575;
      float32x4_t v666 = v612;
      simd_float4 v667 = v573;
      simd_float4 v668 = v571;
      simd_float4 v669 = v569;
      simd_float4 v670 = v568;
      char v671 = v464;
      v672[0] = v545;
      v672[1] = v544;
      v673[0] = (float32x4_t)v543;
      v673[1] = (float32x4_t)v542;
      v673[2] = (float32x4_t)v567;
      v673[3] = (float32x4_t)v566;
      v673[4] = v598;
      v673[5] = v596;
      v673[6] = v594;
      v673[7] = v593;
      v673[8] = v591;
      v673[9] = v590;
      v673[10] = v589;
      v673[11] = v588;
      v673[12] = (float32x4_t)v610;
      v673[13] = (float32x4_t)v608;
      v673[14] = (float32x4_t)v606;
      v673[15] = (float32x4_t)v604;
      v673[16] = v612;
      float v674 = v552;
      float v675 = v601;
      float v676 = v592;
      float v677 = v599;
      simd_float4 v678 = v587;
      simd_float4 v679 = v585;
      simd_float4 v680 = v582;
      simd_float4 v681 = v580;
      float32x4_t v682 = vnegq_f32(v612);
      float v683 = v599;
      __int16 v684 = 0;
      int v685 = 0;
      if (v574)
      {
        uint64_t v492 = re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(i64, *(void *)(v553 + 40 * v180 + 24));
        if (v492
          || (uint64_t v492 = re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(i64, 0)) != 0)
        {
          uint64_t v493 = *(void *)(v492 + 16);
          if (!v493)
          {
LABEL_376:
            uint64_t v188 = (uint64_t)v182;
            goto LABEL_377;
          }
          v494 = *(uint64_t **)(v492 + 32);
          v495 = &v494[14 * v493];
          while (1)
          {
            uint64_t v497 = *v494;
            v496 = v494 + 2;
            *(void *)__src = v496;
            *(void *)&__src[8] = v497;
            if (re::isBoundingBoxInsidePlanes((uint64_t)v672, (uint64_t)__src, v673)) {
              break;
            }
            v494 = v496 + 12;
            if (v494 == v495) {
              goto LABEL_376;
            }
          }
        }
      }
      unint64_t v498 = re::Hash<re::ShadowPair>::operator()((uint64_t)__src, v182);
      if ((void)v630)
      {
        unint64_t v499 = v498 % DWORD2(v631);
        uint64_t v500 = *(unsigned int *)(*((void *)&v630 + 1) + 4 * v499);
        if (v500 != 0x7FFFFFFF)
        {
          while (*(void *)(v631 + 1824 * v500 + 16) != *v182
               || *(void *)(v631 + 1824 * v500 + 24) != *(void *)(v553 + 40 * v180 + 24)
               || *(unsigned __int8 *)(v631 + 1824 * v500 + 32) != *v541)
          {
            uint64_t v500 = *(_DWORD *)(v631 + 1824 * v500 + 8) & 0x7FFFFFFF;
            if (v500 == 0x7FFFFFFF) {
              goto LABEL_386;
            }
          }
          goto LABEL_387;
        }
      }
      else
      {
        LODWORD(v499) = 0;
      }
LABEL_386:
      re::HashTable<re::ShadowPair,re::ShadowInfo,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::addAsMove((uint64_t)&v630, v499, v498, (long long *)v182, buf);
      ++HIDWORD(v633);
LABEL_387:
      uint64_t v181 = v625;
      if (v626 <= (int)v144 + 1) {
        unsigned int v501 = v144 + 1;
      }
      else {
        unsigned int v501 = v626;
      }
      while (1)
      {
        uint64_t v180 = (v144 + 1);
        if (v501 - 1 == v144) {
          break;
        }
        LODWORD(v144) = v144 + 1;
        unsigned int v502 = v180;
        if ((*(_DWORD *)(v625 + 40 * v180 + 8) & 0x80000000) != 0) {
          goto LABEL_394;
        }
      }
      unsigned int v502 = v501;
LABEL_394:
      LODWORD(v144) = v502;
      if (v603 == v502) {
        goto LABEL_193;
      }
    }
    simd_float4 v542 = (simd_float4)xmmword_23435FD60;
    simd_float4 v543 = (simd_float4)xmmword_23435FD50;
    char v464 = 1;
    v468.i64[0] = 0x7F0000007FLL;
    v468.i64[1] = 0x7F0000007FLL;
    float32x4_t v544 = v468;
    int32x4_t v545 = vdupq_n_s32(0x7F800000u);
LABEL_368:
    float v459 = v559;
    float v465 = v558;
    float v466 = v557;
    float v467 = v556;
    float v460 = v577;
    int32x2_t v461 = v555;
    unsigned int v462 = v431;
    float32x2_t v463 = v554;
    goto LABEL_369;
  }
LABEL_193:
  re::MeshShadowGenerationQueue::dequeue(v6 + 216, v538, v539, (uint64_t)v627, (uint64_t)__src);
  unint64_t v147 = *(unsigned int *)&__src[28];
  v686.columns[2].i64[0] = 0;
  memset(&v686.columns[0].u32[2], 0, 20);
  re::DynamicArray<re::EvaluationRegister>::setCapacity(&v686, v147);
  ++v686.columns[1].i32[2];
  int v619 = *(_DWORD *)&__src[32];
  uint64_t v149 = 0;
  if (*(_DWORD *)&__src[32])
  {
    v150 = (int *)(*(void *)&__src[16] + 8);
    while (1)
    {
      int v151 = *v150;
      v150 += 10;
      if (v151 < 0) {
        break;
      }
      if (*(unsigned int *)&__src[32] == ++v149)
      {
        LODWORD(v149) = *(_DWORD *)&__src[32];
        break;
      }
    }
  }
  if (*(_DWORD *)&__src[32] != v149)
  {
    uint64_t v509 = v149;
    uint64_t v510 = *(void *)&__src[16];
    v617 = (void *)(v6 + 80);
    do
    {
      v511 = (long long *)(v510 + 40 * v509 + 16);
      unint64_t v512 = re::Hash<re::ShadowPair>::operator()((uint64_t)buf, v511);
      if ((void)v630)
      {
        uint64_t v513 = *(unsigned int *)(*((void *)&v630 + 1) + 4 * (v512 % DWORD2(v631)));
        if (v513 != 0x7FFFFFFF)
        {
          uint64_t v514 = v631;
          uint64_t v515 = v510 + 40 * v509;
          int v518 = *(unsigned __int8 *)(v515 + 32);
          v517 = (unsigned __int8 *)(v515 + 32);
          int v516 = v518;
          while (*(void *)(v631 + 1824 * v513 + 16) != *(void *)v511
               || *(void *)(v631 + 1824 * v513 + 24) != *((void *)v517 - 1)
               || *(unsigned __int8 *)(v631 + 1824 * v513 + 32) != v516)
          {
            uint64_t v513 = *(_DWORD *)(v631 + 1824 * v513 + 8) & 0x7FFFFFFF;
            if (v513 == 0x7FFFFFFF) {
              goto LABEL_425;
            }
          }
          uint64_t v521 = re::HashTable<re::ShadowPair,re::AllocatedShadowHandle,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::tryGet((uint64_t)v617, (uint64_t)v511);
          if (v521)
          {
            *(_OWORD *)&v692[7] = *(_OWORD *)v521;
            *(void *)&v692[23] = *(void *)(v521 + 16);
            int v21 = (unint64_t *)*(unsigned __int16 *)(v521 + 24);
            v639.i32[0] = *(_DWORD *)(v521 + 26);
            __int16 v522 = *(_WORD *)(v521 + 30);
LABEL_449:
            v639.i16[2] = v522;
            int v23 = *(unint64_t **)(v6 + 56);
            if (v23 <= v21) {
              goto LABEL_464;
            }
            v531 = (_anonymous_namespace_ *)memcpy((void *)(*(void *)(v6 + 72) + 1792 * v21), (const void *)(v514 + 1824 * v513 + 48), 0x6F0uLL);
            uint64_t v532 = v686.columns[1].i64[0];
            if (v686.columns[1].i64[0] >= (unint64_t)v686.columns[0].i64[1])
            {
              unint64_t v533 = v686.columns[1].i64[0] + 1;
              if (v686.columns[0].i64[1] < (unint64_t)(v686.columns[1].i64[0] + 1))
              {
                if (v686.columns[0].i64[0])
                {
                  unint64_t v534 = 8;
                  if (v686.columns[0].i64[1]) {
                    unint64_t v534 = 2 * v686.columns[0].i64[1];
                  }
                  if (v534 <= v533) {
                    unint64_t v535 = v686.columns[1].i64[0] + 1;
                  }
                  else {
                    unint64_t v535 = v534;
                  }
                  re::DynamicArray<re::EvaluationRegister>::setCapacity(&v686, v535);
                }
                else
                {
                  re::DynamicArray<re::EvaluationRegister>::setCapacity(&v686, v533);
                  ++v686.columns[1].i32[2];
                }
              }
              uint64_t v532 = v686.columns[1].i64[0];
            }
            uint64_t v536 = v686.columns[2].i64[0] + 32 * v532;
            *(_OWORD *)uint64_t v536 = *(_OWORD *)&v692[7];
            *(void *)(v536 + 16) = *(void *)&v692[23];
            *(_WORD *)(v536 + 24) = (_WORD)v21;
            *(_DWORD *)(v536 + 26) = v639.i32[0];
            *(_WORD *)(v536 + 30) = v639.i16[2];
            ++v686.columns[1].i64[0];
            ++v686.columns[1].i32[2];
            goto LABEL_425;
          }
          re::ShadowTileManager::acquireTile((void *)v6, (uint64_t)v695);
          if (v695[0])
          {
            buf[0] = (__n128)*v511;
            buf[1].n128_u64[0] = *((void *)v511 + 2);
            buf[1].n128_u32[2] = *(_DWORD *)&v695[2];
            unint64_t v523 = re::Hash<re::ShadowPair>::operator()((uint64_t)&v641, v511);
            if (*v617)
            {
              unint64_t v524 = v523 % *(unsigned int *)(v6 + 104);
              uint64_t v525 = *(unsigned int *)(*(void *)(v6 + 88) + 4 * v524);
              if (v525 != 0x7FFFFFFF)
              {
                uint64_t v526 = *(void *)(v6 + 96);
                while (*(void *)(v526 + 72 * v525 + 16) != *(void *)v511
                     || *(void *)(v526 + 72 * v525 + 24) != *((void *)v517 - 1)
                     || *(unsigned __int8 *)(v526 + 72 * v525 + 32) != *v517)
                {
                  uint64_t v525 = *(_DWORD *)(v526 + 72 * v525 + 8) & 0x7FFFFFFF;
                  if (v525 == 0x7FFFFFFF) {
                    goto LABEL_447;
                  }
                }
                uint64_t v528 = v526 + 72 * v525;
                goto LABEL_448;
              }
            }
            else
            {
              LODWORD(v524) = 0;
            }
LABEL_447:
            unsigned int v527 = re::HashTable<re::ShadowPair,re::AllocatedShadowHandle,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::addAsMove((uint64_t)v617, v524, v523, v511, (long long *)buf);
            ++*(_DWORD *)(v6 + 120);
            uint64_t v528 = *(void *)(v6 + 96) + 72 * v527;
LABEL_448:
            long long v530 = *(_OWORD *)(v528 + 40);
            uint64_t v529 = v528 + 40;
            *(_OWORD *)&v692[7] = v530;
            *(void *)&v692[23] = *(void *)(v529 + 16);
            int v21 = (unint64_t *)*(unsigned __int16 *)(v529 + 24);
            v639.i32[0] = *(_DWORD *)(v529 + 26);
            __int16 v522 = *(_WORD *)(v529 + 30);
            goto LABEL_449;
          }
          *(_OWORD *)v695 = *v511;
          *(void *)&v695[16] = *((void *)v511 + 2);
          buf[0] = *(__n128 *)v695;
          buf[1].n128_u64[0] = *(void *)&v695[16];
          re::MeshShadowGenerationBacklog::pushBack((_anonymous_namespace_ *)(v6 + 264), buf);
        }
      }
LABEL_425:
      uint64_t v510 = *(void *)&__src[16];
      if (*(_DWORD *)&__src[32] <= (v149 + 1)) {
        int v519 = v149 + 1;
      }
      else {
        int v519 = *(_DWORD *)&__src[32];
      }
      while (1)
      {
        uint64_t v509 = (v149 + 1);
        if (v519 - 1 == v149) {
          break;
        }
        LODWORD(v149) = v149 + 1;
        int v520 = v509;
        if ((*(_DWORD *)(*(void *)&__src[16] + 40 * v509 + 8) & 0x80000000) != 0) {
          goto LABEL_432;
        }
      }
      int v520 = v519;
LABEL_432:
      LODWORD(v149) = v520;
    }
    while (v619 != v520);
  }
  re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)__src);
  re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit(v624);
  re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)v627);
  re::HashTable<re::ShadowPair,re::ShadowInfo,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::deinit((uint64_t *)&v630);
  re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v636);
  *(_DWORD *)(v537 + 32) = 0;
  *(_OWORD *)uint64_t v537 = 0u;
  *(_OWORD *)(v537 + 16) = 0u;
  *(void *)(v537 + 36) = 0x7FFFFFFFLL;
  if ((void)v620)
  {
    if (HIDWORD(v621) <= 3) {
      signed int v504 = 3;
    }
    else {
      signed int v504 = HIDWORD(v621);
    }
    re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::init(v537, v620, v504);
    re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::clear(v537);
    if (*(_DWORD *)(v537 + 24) < HIDWORD(v621)) {
      re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::setCapacity(v537, HIDWORD(v621));
    }
    unint64_t v505 = v622;
    if (v622)
    {
      uint64_t v506 = 0;
      unint64_t v507 = 0;
      do
      {
        if ((*(_DWORD *)(v621 + v506 + 8) & 0x80000000) != 0)
        {
          re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::addAsCopy(v537, *(void *)(v621 + v506) % (unint64_t)*(unsigned int *)(v537 + 24), *(void *)(v621 + v506), v621 + v506 + 16, (long long *)(v621 + v506 + 16));
          unint64_t v505 = v622;
        }
        ++v507;
        v506 += 40;
      }
      while (v507 < v505);
    }
  }
  *(void *)(v537 + 48) = 0;
  *(void *)(v537 + 80) = 0;
  *(void *)(v537 + 56) = 0;
  *(void *)(v537 + 64) = 0;
  *(_DWORD *)(v537 + 72) = 0;
  if (v686.columns[0].i64[0])
  {
    unint64_t v508 = v686.columns[1].u64[0];
    *(void *)(v537 + 48) = v686.columns[0].i64[0];
    re::DynamicArray<re::EvaluationRegister>::setCapacity((void *)(v537 + 48), v508);
    ++*(_DWORD *)(v537 + 72);
    re::DynamicArray<re::AllocatedShadowHandle>::copy((void **)(v537 + 48), (uint64_t)&v686);
    if (v686.columns[0].i64[0])
    {
      if (v686.columns[2].i64[0]) {
        (*(void (**)(void))(*(void *)v686.columns[0].i64[0] + 40))();
      }
    }
  }
  re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)&v620);
}

BOOL re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + 368 * v3 + 16) == a2) {
    return 1;
  }
  do
  {
    LODWORD(v3) = *(_DWORD *)(v5 + 368 * v3 + 8) & 0x7FFFFFFF;
    BOOL result = v3 != 0x7FFFFFFF;
  }
  while (v3 != 0x7FFFFFFF && *(void *)(v5 + 368 * v3 + 16) != a2);
  return result;
}

unint64_t re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::add(uint64_t a1, uint64_t a2)
{
  unint64_t result = re::Hash<re::ShadowPair>::operator()((uint64_t)&v9, (void *)a2);
  unint64_t v5 = *(unsigned int *)(a1 + 24);
  if (!v5)
  {
    LODWORD(v6) = 0;
    goto LABEL_10;
  }
  unint64_t v6 = result % v5;
  uint64_t v7 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (result % v5));
  if (v7 == 0x7FFFFFFF)
  {
LABEL_10:
    unint64_t result = re::HashSetBase<re::ShadowPair,re::ShadowPair,re::internal::ValueAsKey<re::ShadowPair>,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::addAsCopy(a1, v6, result, a2, (long long *)a2);
    ++*(_DWORD *)(a1 + 40);
    return result;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  while (*(void *)(v8 + 40 * v7 + 16) != *(void *)a2
       || *(void *)(v8 + 40 * v7 + 24) != *(void *)(a2 + 8)
       || *(unsigned __int8 *)(v8 + 40 * v7 + 32) != *(unsigned __int8 *)(a2 + 16))
  {
    uint64_t v7 = *(_DWORD *)(v8 + 40 * v7 + 8) & 0x7FFFFFFF;
    if (v7 == 0x7FFFFFFF) {
      goto LABEL_10;
    }
  }
  return result;
}

uint64_t re::HashTable<re::ShadowPair,re::AllocatedShadowHandle,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = re::Hash<re::ShadowPair>::operator()((uint64_t)&v8, (void *)a2);
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if (v5 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  while (*(void *)(v6 + 72 * v5 + 16) != *(void *)a2
       || *(void *)(v6 + 72 * v5 + 24) != *(void *)(a2 + 8)
       || *(unsigned __int8 *)(v6 + 72 * v5 + 32) != *(unsigned __int8 *)(a2 + 16))
  {
    uint64_t v5 = *(_DWORD *)(v6 + 72 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF) {
      return 0;
    }
  }
  return v6 + 72 * v5 + 40;
}

uint64_t re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, unint64_t a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  uint64_t v3 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v3 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(void *)(v5 + 368 * v3 + 16) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 368 * v3 + 8) & 0x7FFFFFFF;
      if (v3 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v5 + 368 * v3 + 16) == a2) {
        return v5 + 368 * v3 + 32;
      }
    }
    return 0;
  }
  return v5 + 368 * v3 + 32;
}

uint64_t re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 368 * v13;
    return v12 + 32;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 368 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 368 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 368 * v10;
  return v12 + 32;
}

uint64_t re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v45, 0, 36);
          *(void *)&v45[36] = 0x7FFFFFFFLL;
          re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v45, v13, v12);
          long long v15 = *(_OWORD *)v45;
          *(_OWORD *)uint64_t v45 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v45[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v45[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v45[24];
          *(_OWORD *)&v45[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v45[32];
          *(_OWORD *)(a1 + 24) = v19;
          unint64_t v20 = v18;
          if (v18)
          {
            unint64_t v21 = 0;
            uint64_t v22 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v22 - 8) & 0x80000000) != 0) {
                re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)(v22 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v22 - 16), v22, v22 + 16);
              }
              ++v21;
              v22 += 368;
            }
            while (v21 < v20);
          }
          re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v45);
        }
      }
      else
      {
        if (v12) {
          signed int v25 = 2 * v11;
        }
        else {
          signed int v25 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 368 * v9 + 8);
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 368 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  uint64_t v26 = 368 * v9;
  *(_DWORD *)(v23 + v26 + 8) = v24 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v26 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + v26 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + v26) = a3;
  *(void *)(*(void *)(a1 + 16) + v26 + 16) = *a4;
  uint64_t v27 = *(void *)(a1 + 16);
  uint64_t v28 = v27 + v26;
  *(void *)(v28 + 64) = 0;
  *(_DWORD *)(v28 + 56) = 0;
  *(void *)(v28 + 40) = 0;
  *(void *)(v28 + 48) = 0;
  *(void *)(v28 + 32) = 0;
  *(void *)(v28 + 32) = *(void *)a5;
  *(void *)a5 = 0;
  *(void *)(v28 + 40) = *(void *)(a5 + 8);
  *(void *)(a5 + 8) = 0;
  uint64_t v29 = *(void *)(v27 + v26 + 48);
  *(void *)(v28 + 48) = *(void *)(a5 + 16);
  *(void *)(a5 + 16) = v29;
  uint64_t v30 = *(void *)(v28 + 64);
  *(void *)(v28 + 64) = *(void *)(a5 + 32);
  *(void *)(a5 + 32) = v30;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(v28 + 56);
  long long v31 = *(_OWORD *)(a5 + 48);
  long long v32 = *(_OWORD *)(a5 + 80);
  *(_OWORD *)(v28 + 96) = *(_OWORD *)(a5 + 64);
  *(_OWORD *)(v28 + 112) = v32;
  *(_OWORD *)(v28 + 80) = v31;
  long long v33 = *(_OWORD *)(a5 + 96);
  long long v34 = *(_OWORD *)(a5 + 112);
  long long v35 = *(_OWORD *)(a5 + 144);
  *(_OWORD *)(v28 + 160) = *(_OWORD *)(a5 + 128);
  *(_OWORD *)(v28 + 176) = v35;
  *(_OWORD *)(v28 + 128) = v33;
  *(_OWORD *)(v28 + 144) = v34;
  long long v36 = *(_OWORD *)(a5 + 160);
  long long v37 = *(_OWORD *)(a5 + 176);
  long long v38 = *(_OWORD *)(a5 + 208);
  *(_OWORD *)(v28 + 224) = *(_OWORD *)(a5 + 192);
  *(_OWORD *)(v28 + 240) = v38;
  *(_OWORD *)(v28 + 192) = v36;
  *(_OWORD *)(v28 + 208) = v37;
  *(void *)(v28 + 256) = *(void *)(a5 + 224);
  LODWORD(v30) = *(unsigned __int8 *)(a5 + 240);
  *(unsigned char *)(v28 + 272) = v30;
  if (v30)
  {
    long long v39 = *(_OWORD *)(a5 + 272);
    uint64_t v40 = v27 + 368 * v9;
    *(_OWORD *)(v40 + 288) = *(_OWORD *)(a5 + 256);
    *(_OWORD *)(v40 + 304) = v39;
  }
  int v41 = *(unsigned __int8 *)(a5 + 288);
  *(unsigned char *)(v27 + 368 * v9 + 320) = v41;
  if (v41)
  {
    long long v42 = *(_OWORD *)(a5 + 320);
    uint64_t v43 = v27 + 368 * v9;
    *(_OWORD *)(v43 + 336) = *(_OWORD *)(a5 + 304);
    *(_OWORD *)(v43 + 352) = v42;
  }
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 368 * v10, 16);
  if (v12)
  {
    BOOL v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::ShadowPair,re::ShadowInfo,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  uint64_t v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    unint64_t v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unint64_t v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      uint64_t v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  signed int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 1824 * v10, 16);
  if (v12)
  {
    BOOL v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &unk_2343655D0, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<unsigned long long,re::PersistentShadowState::ClusterInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(void *)(v6 + 368 * v4 + 16) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 368 * v4 + 8) & 0x7FFFFFFF;
      if (v4 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v6 + 368 * v4 + 16) == v2) {
        return v6 + 368 * v4 + 32;
      }
    }
    return 0;
  }
  return v6 + 368 * v4 + 32;
}

void *re::HashTable<re::ShadowPair,re::ShadowInfo,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, long long *a4, const void *a5)
{
  unsigned int v10 = *(_DWORD *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    unsigned int v10 = *(_DWORD *)(a1 + 32);
    unsigned int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      int v12 = *(_DWORD *)(a1 + 28);
      signed int v13 = 2 * v12;
      uint64_t v14 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v13) {
          BOOL v15 = v10 == v13;
        }
        else {
          BOOL v15 = 1;
        }
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v30, 0, 36);
          *(void *)&v30[36] = 0x7FFFFFFFLL;
          re::HashTable<re::ShadowPair,re::ShadowInfo,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::init((uint64_t)v30, v14, v13);
          long long v16 = *(_OWORD *)v30;
          *(_OWORD *)uint64_t v30 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          uint64_t v17 = *(void *)&v30[16];
          uint64_t v18 = *(void *)(a1 + 16);
          *(void *)&v30[16] = v18;
          *(void *)(a1 + 16) = v17;
          long long v20 = *(_OWORD *)&v30[24];
          *(_OWORD *)&v30[24] = *(_OWORD *)(a1 + 24);
          unsigned int v19 = *(_DWORD *)&v30[32];
          *(_OWORD *)(a1 + 24) = v20;
          uint64_t v21 = v19;
          if (v19)
          {
            uint64_t v22 = v18 + 48;
            do
            {
              if ((*(_DWORD *)(v22 - 40) & 0x80000000) != 0) {
                re::HashTable<re::ShadowPair,re::ShadowInfo,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::addAsMove(a1, *(void *)(v22 - 48) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v22 - 48), v22 - 32, v22);
              }
              v22 += 1824;
              --v21;
            }
            while (v21);
          }
          re::HashTable<re::ShadowPair,re::ShadowInfo,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::deinit((uint64_t *)v30);
        }
      }
      else
      {
        if (v13) {
          signed int v25 = 2 * v12;
        }
        else {
          signed int v25 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      unsigned int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 1824 * v10 + 8);
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 1824 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 1824 * v10 + 8) = v24 | 0x80000000;
  uint64_t v26 = 1824 * v10;
  *(_DWORD *)(*(void *)(a1 + 16) + v26 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + v26 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + v26) = a3;
  uint64_t v27 = *(void *)(a1 + 16) + v26;
  long long v28 = *a4;
  *(void *)(v27 + 32) = *((void *)a4 + 2);
  *(_OWORD *)(v27 + 16) = v28;
  unint64_t result = memcpy((void *)(*(void *)(a1 + 16) + v26 + 48), a5, 0x6F0uLL);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

uint64_t re::HashTable<re::ShadowPair,re::AllocatedShadowHandle,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, long long *a4, long long *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v11 = *(_DWORD *)(a1 + 28);
      signed int v12 = 2 * v11;
      uint64_t v13 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v12) {
          BOOL v14 = v9 == v12;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v31, 0, 36);
          *(void *)&v31[36] = 0x7FFFFFFFLL;
          re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init((uint64_t)v31, v13, v12);
          long long v15 = *(_OWORD *)v31;
          *(_OWORD *)long long v31 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          uint64_t v16 = *(void *)&v31[16];
          uint64_t v17 = *(void *)(a1 + 16);
          *(void *)&v31[16] = v17;
          *(void *)(a1 + 16) = v16;
          long long v19 = *(_OWORD *)&v31[24];
          *(_OWORD *)&unsigned char v31[24] = *(_OWORD *)(a1 + 24);
          unsigned int v18 = *(_DWORD *)&v31[32];
          *(_OWORD *)(a1 + 24) = v19;
          unint64_t v20 = v18;
          if (v18)
          {
            unint64_t v21 = 0;
            uint64_t v22 = v17 + 40;
            do
            {
              if ((*(_DWORD *)(v22 - 32) & 0x80000000) != 0) {
                re::HashTable<re::ShadowPair,re::AllocatedShadowHandle,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::addAsMove(a1, *(void *)(v22 - 40) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(v22 - 40), v22 - 24, v22);
              }
              ++v21;
              v22 += 72;
            }
            while (v21 < v20);
          }
          re::HashTable<re::ShadowPair,re::AllocatedShadowHandle,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::deinit((uint64_t *)v31);
        }
      }
      else
      {
        if (v12) {
          signed int v25 = 2 * v11;
        }
        else {
          signed int v25 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 72 * v9 + 8);
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 16);
    int v24 = *(_DWORD *)(v23 + 72 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 72 * v9 + 8) = v24 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 72 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 72 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 72 * v9) = a3;
  uint64_t v26 = *(void *)(a1 + 16) + 72 * v9;
  long long v27 = *a4;
  *(void *)(v26 + 32) = *((void *)a4 + 2);
  *(_OWORD *)(v26 + 16) = v27;
  uint64_t v28 = *(void *)(a1 + 16) + 72 * v9;
  long long v29 = *a5;
  *(_OWORD *)(v28 + 56) = a5[1];
  *(_OWORD *)(v28 + 40) = v29;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

double re::HashTable<re::ShadowPair,re::ShadowInfo,re::Hash<re::ShadowPair>,re::EqualTo<re::ShadowPair>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unsigned int v3 = *((_DWORD *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 1824 * v3;
      do
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0) {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        }
        v4 += 1824;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,re::WorldOrderedShadows::Range,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<unsigned long long,re::WorldOrderedShadows::Range,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 32 * v13;
    return v12 + 24;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 32 * v10 + 16) != v6)
  {
    uint64_t v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 32 * v10;
  return v12 + 24;
}

void *re::DynamicArray<re::AllocatedShadowHandle>::resizeUninitialized(void *result, unint64_t a2)
{
  unsigned int v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else if (result[1] < a2)
  {
    double result = re::DynamicArray<re::EvaluationRegister>::setCapacity(result, a2);
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::HashTable<unsigned long long,re::WorldOrderedShadows::Range,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::WorldOrderedShadows::Range,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 32 * v9) = a3;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(void *)(*(void *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,re::WorldOrderedShadows::Range,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)unsigned int v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      *(void *)&v13[16] = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v6;
      long long v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      unsigned int v9 = v7;
      if (v7)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(void *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,re::WorldOrderedShadows::Range,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(void *)(*(void *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(void *)(*(void *)&v13[16] + v10), (void *)(*(void *)&v13[16] + v10 + 16), (void *)(*(void *)&v13[16] + v10 + 24));
            unsigned int v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

void **re::DynamicArray<re::AllocatedShadowHandle>::copy(void **result, uint64_t a2)
{
  unsigned int v3 = result;
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::EvaluationRegister>::setCapacity(result, *(void *)(a2 + 16));
    long long v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 32 * (void)v5 - 4);
      long long v5 = v3[2];
    }
    double result = (void **)memcpy((char *)v3[4] + 32 * (void)v5, (const void *)(*(void *)(a2 + 32) + 32 * (void)v5), 32 * v4 - 32 * (void)v5);
  }
  else if (v4)
  {
    double result = (void **)memmove(result[4], *(const void **)(a2 + 32), 32 * v4 - 4);
  }
  v3[2] = (void *)v4;
  return result;
}

uint64_t re::SkinningModelBuilder::addSkinnedMeshPartData(uint64_t a1, unsigned int a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  unint64_t v32 = 0xA7268F0C3B45D55ELL;
  long long v33 = "skinningInfluences";
  uint64_t v13 = re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a7, &v32);
  re::StringID::destroyString((re::StringID *)&v32);
  unint64_t v32 = 0xF98D22D8F2059642;
  long long v33 = "influenceEndIndices";
  uint64_t v14 = re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a7, &v32);
  re::StringID::destroyString((re::StringID *)&v32);
  unint64_t v32 = 0x9E5069BE2D47B84ELL;
  long long v33 = "simplifiedSkinningInfluences";
  uint64_t v15 = re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a7, &v32);
  re::StringID::destroyString((re::StringID *)&v32);
  unint64_t v32 = 0xE79E9E6540401152;
  long long v33 = "simplifiedInfluenceEndIndices";
  uint64_t v16 = re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a7, &v32);
  re::StringID::destroyString((re::StringID *)&v32);
  uint64_t v17 = 0x100000000;
  if (!a3) {
    uint64_t v17 = 0;
  }
  uint64_t v18 = v17 | a2;
  if (a5) {
    uint64_t v19 = 0x10000000000;
  }
  else {
    uint64_t v19 = 0;
  }
  if (v13)
  {
    id v20 = *(id *)v13;
    uint64_t v21 = *(void *)(v13 + 8);
  }
  else
  {
    id v20 = 0;
    uint64_t v21 = 0;
  }
  uint64_t v22 = v18 | v19;
  if (v14)
  {
    id v23 = *(id *)v14;
    uint64_t v14 = *(void *)(v14 + 8);
  }
  else
  {
    id v23 = 0;
  }
  uint64_t v24 = v22 | (a4 << 48);
  if (v15)
  {
    id v25 = *(id *)v15;
    uint64_t v15 = *(void *)(v15 + 8);
  }
  else
  {
    id v25 = 0;
  }
  uint64_t v26 = v24 | (a6 << 56);
  if (v16)
  {
    id v27 = *(id *)v16;
    uint64_t v28 = *(void *)(v16 + 8);
  }
  else
  {
    id v27 = 0;
    uint64_t v28 = 0;
  }
  long long v29 = (void *)re::BucketArray<re::SkinningModelBuilder::PreparedSkinnedMeshPartData,4ul>::addUninitialized(a1 + 80);
  *long long v29 = v26;
  v29[1] = 0;
  v29[2] = 0;
  v29[3] = 0;
  v29[4] = v20;
  v29[5] = v21;
  v29[6] = 0;
  v29[7] = 0;
  v29[8] = v23;
  v29[9] = v14;
  v29[11] = 0;
  v29[12] = 0;
  v29[10] = 0;
  v29[13] = v25;
  v29[14] = v15;
  v29[15] = 0;
  v29[16] = 0;
  v29[17] = v27;
  v29[18] = v28;
  if (v27) {

  }
  if (v25) {
  if (v23)
  }

  if (v20) {
  return *(void *)(a1 + 120) - 1;
  }
}

uint64_t re::SkinningModelBuilder::buildDeformationModel(re::SkinningModelBuilder *this, id *a2, DeformationModelData *a3)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  re::SkinningModelBuilder::generatePreparedSkinnedMeshPartData(this, 1, a2);
  var0 = a3->var0[2].var0.var0;
  long long v5 = (uint64_t *)&a3->var0[2];
  if (var0) {
    (*(void (**)(void))(**(void **)this + 40))();
  }
  unsigned int v7 = *(void **)this;
  long long v8 = (_OWORD *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)this + 32))(*(void *)this, 48, 8);
  *long long v8 = 0u;
  v8[1] = 0u;
  v8[2] = 0u;
  long long v33 = &unk_26E714100;
  id v34 = v7;
  id v36 = &v33;
  *(void *)&long long v52 = (char *)&v50 + 8;
  *(void *)&long long v50 = v8;
  *((void *)&v50 + 1) = &unk_26E714100;
  *(void *)&long long v51 = v7;
  std::unique_ptr<void,std::function<void ()(void *)>>::operator=[abi:nn180100](v5, (uint64_t *)&v50);
  std::unique_ptr<void,std::function<void ()(void *)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v50);
  unsigned int v9 = (_anonymous_namespace_ *)std::__function::__value_func<void ()(void *)>::~__value_func[abi:nn180100](&v33);
  uint64_t v10 = (void *)*v5;
  unint64_t v11 = *((void *)this + 15);
  v10[1] = v11;
  if (v11)
  {
    if (v11 < 0x38E38E38E38E38FLL)
    {
      v10[2] = v13;
      if (!v13) {
        goto LABEL_24;
      }
      uint64_t v15 = v13;
      uint64_t v16 = (char *)this + 80;
      if (v11 != 1)
      {
        bzero(v13, 72 * v11 - 72);
        v15 += 72 * v11 - 72;
      }
      *((void *)v15 + 8) = 0;
      *((_OWORD *)v15 + 2) = 0u;
      *((_OWORD *)v15 + 3) = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      re::FixedArray<re::Slice<unsigned int>>::init<>(v10 + 3, *(void *)this, *((void *)this + 2));
      re::FixedArray<re::BufferSlice>::operator=((_anonymous_namespace_ *)(v10 + 3), (uint64_t *)this + 1);
      uint64_t v17 = 0;
      unint64_t v18 = 0;
      while (1)
      {
        uint64_t v19 = re::BucketArray<re::SkinningModelBuilder::PreparedSkinnedMeshPartData,4ul>::operator[]((uint64_t)v16, v18);
        int v20 = *(_DWORD *)v19;
        LODWORD(v33) = *(_DWORD *)(v19 + 4);
        HIDWORD(v33) = v20;
        id v21 = *(id *)(v19 + 64);
        uint64_t v22 = *(void *)(v19 + 72);
        id v34 = v21;
        uint64_t v35 = v22;
        id v23 = *(id *)(v19 + 32);
        uint64_t v24 = *(void *)(v19 + 40);
        id v36 = v23;
        uint64_t v37 = v24;
        id v25 = *(id *)(v19 + 136);
        uint64_t v26 = *(void *)(v19 + 144);
        id v38 = v25;
        uint64_t v39 = v26;
        id v27 = *(id *)(v19 + 104);
        uint64_t v28 = *(void *)(v19 + 112);
        id v40 = v27;
        uint64_t v41 = v28;
        unint64_t v29 = v10[1];
        if (v29 <= v18) {
          break;
        }
        uint64_t v30 = v10[2] + v17;
        *(void *)uint64_t v30 = v33;
        NS::SharedPtr<MTL::Texture>::operator=((void **)(v30 + 8), &v34);
        *(void *)(v30 + 16) = v35;
        NS::SharedPtr<MTL::Texture>::operator=((void **)(v30 + 24), &v36);
        *(void *)(v30 + 32) = v37;
        NS::SharedPtr<MTL::Texture>::operator=((void **)(v30 + 40), &v38);
        *(void *)(v30 + 48) = v39;
        NS::SharedPtr<MTL::Texture>::operator=((void **)(v30 + 56), &v40);
        *(void *)(v30 + 64) = v41;
        if (v40)
        {

          id v40 = 0;
        }
        if (v38)
        {

          id v38 = 0;
        }
        if (v36)
        {

          id v36 = 0;
        }
        if (v34) {

        }
        ++v18;
        v17 += 72;
        if (v11 == v18) {
          return 1;
        }
      }
      uint64_t v32 = 0;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v50 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v42 = 136315906;
      uint64_t v43 = "operator[]";
      __int16 v44 = 1024;
      int v45 = 468;
      __int16 v46 = 2048;
      unint64_t v47 = v18;
      __int16 v48 = 2048;
      unint64_t v49 = v29;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 72, v11, v32);
    _os_crash();
    __break(1u);
LABEL_24:
    re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
  re::FixedArray<re::Slice<unsigned int>>::init<>(v10 + 3, *(void *)this, *((void *)this + 2));
  re::FixedArray<re::BufferSlice>::operator=((_anonymous_namespace_ *)(v10 + 3), (uint64_t *)this + 1);
  return 1;
}

void re::SkinningModelBuilder::generatePreparedSkinnedMeshPartData(re::SkinningModelBuilder *this, int a2, id *a3)
{
  unint64_t v4 = *((void *)this + 8);
  long long v5 = (char *)this + 80;
  unint64_t v6 = *((void *)this + 15);
  if (v4 <= v6)
  {
    if (v6) {
      BOOL v12 = a2 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (!v12)
    {
      unint64_t v13 = 0;
      do
      {
        uint64_t v14 = re::BucketArray<re::SkinningModelBuilder::PreparedSkinnedMeshPartData,4ul>::operator[]((uint64_t)v5, v13);
        uint64_t v15 = v14;
        int v16 = *(_DWORD *)(v14 + 44);
        if (*(void *)(v14 + 16)) {
          BOOL v17 = v16 == 0;
        }
        else {
          BOOL v17 = 0;
        }
        if (v17)
        {
          id v18 = objc_msgSend(*a3, sel_newBufferWithBytes_length_options_, *(void *)(v14 + 24));
          id v30 = v18;
          LODWORD(v31) = 0;
          HIDWORD(v31) = objc_msgSend(v18, sel_length);
          NS::SharedPtr<MTL::Texture>::operator=((void **)(v15 + 32), &v30);
          uint64_t v19 = v30;
          *(void *)(v15 + 40) = v31;
          if (v19)
          {

            id v30 = 0;
          }
          if (v18) {

          }
          int v16 = *(_DWORD *)(v15 + 44);
        }
        if (*(void *)(v15 + 56)) {
          BOOL v20 = v16 == 0;
        }
        else {
          BOOL v20 = 0;
        }
        if (v20)
        {
          id v21 = objc_msgSend(*a3, sel_newBufferWithBytes_length_options_, *(void *)(v15 + 48));
          id v30 = v21;
          LODWORD(v31) = 0;
          HIDWORD(v31) = objc_msgSend(v21, sel_length);
          NS::SharedPtr<MTL::Texture>::operator=((void **)(v15 + 32), &v30);
          uint64_t v22 = v30;
          *(void *)(v15 + 40) = v31;
          if (v22)
          {

            id v30 = 0;
          }
          if (v21) {
        }
          }
        int v23 = *(_DWORD *)(v15 + 116);
        if (*(void *)(v15 + 88)) {
          BOOL v24 = v23 == 0;
        }
        else {
          BOOL v24 = 0;
        }
        if (v24)
        {
          id v25 = objc_msgSend(*a3, sel_newBufferWithBytes_length_options_, *(void *)(v15 + 96));
          id v30 = v25;
          LODWORD(v31) = 0;
          HIDWORD(v31) = objc_msgSend(v25, sel_length);
          NS::SharedPtr<MTL::Texture>::operator=((void **)(v15 + 104), &v30);
          uint64_t v26 = v30;
          *(void *)(v15 + 112) = v31;
          if (v26)
          {

            id v30 = 0;
          }
          if (v25) {

          }
          int v23 = *(_DWORD *)(v15 + 116);
        }
        if (*(void *)(v15 + 128) && !v23)
        {
          id v27 = objc_msgSend(*a3, sel_newBufferWithBytes_length_options_, *(void *)(v15 + 120));
          id v30 = v27;
          LODWORD(v31) = 0;
          HIDWORD(v31) = objc_msgSend(v27, sel_length);
          NS::SharedPtr<MTL::Texture>::operator=((void **)(v15 + 104), &v30);
          uint64_t v28 = v30;
          *(void *)(v15 + 112) = v31;
          if (v28)
          {

            id v30 = 0;
          }
          if (v27) {
        }
          }
        ++v13;
      }
      while (v6 != v13);
    }
  }
  else if (v4 <= 4 * *((void *)this + 11) {
         || (re::BucketArray<re::SkinningModelBuilder::PreparedSkinnedMeshPartData,4ul>::setBucketsCapacity((uint64_t *)this + 10, (v4 + 3) >> 2), (unint64_t v4 = *((void *)this + 8)) != 0))
  }
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = re::BucketArray<re::SkinningModelBuilder::RawSkinnedMeshPartData,4ul>::operator[]((uint64_t)this + 24, v8);
      uint64_t v10 = re::BucketArray<re::SkinningModelBuilder::PreparedSkinnedMeshPartData,4ul>::addUninitialized((uint64_t)v5);
      *(_OWORD *)(v10 + 20) = 0u;
      *(_OWORD *)(v10 + 36) = 0u;
      *(_OWORD *)(v10 + 52) = 0u;
      *(_OWORD *)(v10 + 68) = 0u;
      *(_OWORD *)(v10 + 84) = 0u;
      *(_OWORD *)(v10 + 100) = 0u;
      *(_OWORD *)(v10 + 116) = 0u;
      *(_OWORD *)(v10 + 132) = 0u;
      *(_DWORD *)(v10 + 148) = 0;
      *(_OWORD *)(v10 + 4) = 0u;
      *(_DWORD *)uint64_t v10 = *(_DWORD *)v9;
      re::SkinningModelBuilder::packInfluenceData((uint64_t *)this, a2, a3, (char *)(v10 + 4), (unsigned char *)(v10 + 6), (uint64_t *)(v10 + 8), v10 + 32, (int **)(v10 + 48), 0.0, v10 + 64, (void *)(v9 + 8), (int **)(v9 + 24), (uint64_t *)(v9 + 72));
      re::SkinningModelBuilder::packInfluenceData((uint64_t *)this, a2, a3, (char *)(v10 + 5), (unsigned char *)(v10 + 7), (uint64_t *)(v10 + 80), v10 + 104, (int **)(v10 + 120), v11, v10 + 136, (void *)(v9 + 40), (int **)(v9 + 56), (uint64_t *)(v9 + 72));
      ++v8;
    }
    while (v4 != v8);
  }
}

uint64_t re::FixedArray<re::BufferSlice>::operator=(_anonymous_namespace_ *a1, uint64_t *a2)
{
  if (!*(void *)a1)
  {
    unint64_t v4 = a2[1];
    if (!v4) {
      return (uint64_t)a1;
    }
  }
  uint64_t v5 = a2[1];
  if (*((void *)a1 + 1) == v5)
  {
    if (v5)
    {
      uint64_t v6 = *a2;
      uint64_t v7 = v6 + 16 * v5;
      uint64_t v8 = *((void *)a1 + 2);
      do
      {
        NS::SharedPtr<MTL::Texture>::operator=((void **)v8, (void **)v6);
        *(void *)(v8 + 8) = *(void *)(v6 + 8);
        v6 += 16;
        v8 += 16;
      }
      while (v6 != v7);
    }
    return (uint64_t)a1;
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a Slice of a different size", "m_size == other.size()", "copy", 378);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::SkinningModelBuilder::buildAttributeDescriptor(uint64_t *a1, uint64_t a2)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  re::SkinningModelBuilder::generatePreparedSkinnedMeshPartData((re::SkinningModelBuilder *)a1, 0, 0);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 1);
  unint64_t v5 = a1[15];
  uint64_t v26 = a1;
  uint64_t v6 = *a1;
  *(void *)(a2 + 16) = *a1;
  *(void *)(a2 + 24) = v5;
  if (v5)
  {
    if (v5 < 0x492492492492493)
    {
      uint64_t v7 = (_DWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v6 + 32))(v6, 56 * v5, 8);
      *(void *)(a2 + 32) = v7;
      if (!v7) {
        goto LABEL_25;
      }
      uint64_t v25 = (uint64_t)(a1 + 10);
      unint64_t v9 = v5 - 1;
      if (v5 == 1)
      {
        *uint64_t v7 = -1;
        uint64_t v10 = v7 + 11;
        double v11 = v7 + 1;
      }
      else
      {
        uint64_t v10 = v7 + 11;
        do
        {
          *(v10 - 11) = -1;
          *(_OWORD *)(v10 - 2) = 0uLL;
          *(_OWORD *)(v10 - 10) = 0uLL;
          *(_OWORD *)(v10 - 6) = 0uLL;
          v10[2] = 0;
          *uint64_t v10 = 0x7FFFFFFF;
          v10 += 14;
          --v9;
        }
        while (v9);
        *(v10 - 11) = -1;
        double v11 = v10 - 10;
      }
      uint64_t v12 = 0;
      unint64_t v13 = 0;
      v11[12] = 0;
      *((_OWORD *)v11 + 1) = 0u;
      *((_OWORD *)v11 + 2) = 0u;
      *(_OWORD *)double v11 = 0u;
      *uint64_t v10 = 0x7FFFFFFF;
      while (1)
      {
        uint64_t v14 = (_DWORD *)re::BucketArray<re::SkinningModelBuilder::PreparedSkinnedMeshPartData,4ul>::operator[](v25, v13);
        unint64_t v15 = *(void *)(a2 + 24);
        if (v15 <= v13) {
          break;
        }
        int v16 = v14;
        uint64_t v17 = *(void *)(a2 + 32) + v12;
        *(_DWORD *)uint64_t v17 = *v14;
        *(_DWORD *)(v17 + 4) = v14[1];
        re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(v17 + 8, *v26, 3);
        if (*(unsigned char *)(v17 + 4)) {
          uint64_t v18 = 4;
        }
        else {
          uint64_t v18 = 8;
        }
        *(void *)id v27 = 0xA7268F0C3B45D55ELL;
        *(void *)&unsigned char v27[8] = "skinningInfluences";
        uint64_t v20 = *((void *)v16 + 2);
        uint64_t v19 = *((void *)v16 + 3);
        *(void *)&v32[0] = v18;
        *((void *)&v32[0] + 1) = v19;
        *(void *)&v32[1] = v20;
        re::HashTable<re::StringID,re::DeformationAttributeData,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew(v17 + 8, (StringID *)v27, v32);
        re::StringID::destroyString((re::StringID *)v27);
        if (*((void *)v16 + 7))
        {
          *(void *)id v27 = 0xF98D22D8F2059642;
          *(void *)&unsigned char v27[8] = "influenceEndIndices";
          *(void *)&v32[0] = 4;
          *(long long *)((char *)v32 + 8) = *((_OWORD *)v16 + 3);
          re::HashTable<re::StringID,re::DeformationAttributeData,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew(v17 + 8, (StringID *)v27, v32);
          re::StringID::destroyString((re::StringID *)v27);
        }
        if (*(unsigned char *)(v17 + 5)) {
          uint64_t v21 = 4;
        }
        else {
          uint64_t v21 = 8;
        }
        *(void *)id v27 = 0x9E5069BE2D47B84ELL;
        *(void *)&unsigned char v27[8] = "simplifiedSkinningInfluences";
        uint64_t v23 = *((void *)v16 + 11);
        uint64_t v22 = *((void *)v16 + 12);
        *(void *)&v32[0] = v21;
        *((void *)&v32[0] + 1) = v22;
        *(void *)&v32[1] = v23;
        re::HashTable<re::StringID,re::DeformationAttributeData,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew(v17 + 8, (StringID *)v27, v32);
        re::StringID::destroyString((re::StringID *)v27);
        if (*((void *)v16 + 16))
        {
          *(void *)id v27 = 0xE79E9E6540401152;
          *(void *)&unsigned char v27[8] = "simplifiedInfluenceEndIndices";
          *(void *)&v32[0] = 4;
          *(long long *)((char *)v32 + 8) = *(_OWORD *)(v16 + 30);
          re::HashTable<re::StringID,re::DeformationAttributeData,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew(v17 + 8, (StringID *)v27, v32);
          re::StringID::destroyString((re::StringID *)v27);
        }
        ++v13;
        v12 += 56;
        if (v5 == v13) {
          return 1;
        }
      }
      memset(v32, 0, sizeof(v32));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)id v27 = 136315906;
      *(void *)&v27[4] = "operator[]";
      *(_WORD *)&v27[12] = 1024;
      *(_DWORD *)&v27[14] = 468;
      __int16 v28 = 2048;
      unint64_t v29 = v13;
      __int16 v30 = 2048;
      unint64_t v31 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)6, v4, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 56, v5);
    _os_crash();
    __break(1u);
LABEL_25:
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
  return 1;
}

uint64_t re::HashTable<re::StringID,re::DeformationAttributeData,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew(uint64_t a1, StringID *a2, long long *a3)
{
  unint64_t v6 = 0xBF58476D1CE4E5B9 * ((*(void *)&a2->var0 >> 31) ^ (*(void *)&a2->var0 >> 1));
  unint64_t v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v7 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    uint64_t result = re::HashTable<re::StringID,re::DeformationAttributeData,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return result;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (1)
  {
    uint64_t result = re::StringID::operator==((void *)(v10 + 48 * v9 + 8), a2);
    if (result) {
      return result;
    }
    uint64_t v9 = *(_DWORD *)(v10 + 48 * v9) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
}

uint64_t re::SkinningModelBuilder::packInfluenceData(uint64_t *a1, int a2, id *a3, char *a4, unsigned char *a5, uint64_t *a6, uint64_t a7, int **a8, double a9, uint64_t a10, void *a11, int **a12, uint64_t *a13)
{
  unint64_t v15 = a6;
  int v16 = a5;
  uint64_t v17 = a4;
  uint64_t v20 = a12[1];
  if (v20)
  {
    int v21 = **a12;
    uint64_t v22 = (uint64_t)v20 - 1;
    if (v22)
    {
      uint64_t v23 = *a12 + 1;
      int v24 = **a12;
      while (1)
      {
        int v26 = *v23++;
        int v25 = v26;
        if (v21 != v26 - v24) {
          break;
        }
        int v24 = v25;
        if (!--v22) {
          goto LABEL_9;
        }
      }
      int v21 = 0;
    }
LABEL_9:
    if (v21 >= 256 || v21 == 0) {
      char v27 = 0;
    }
    else {
      char v27 = v21;
    }
  }
  else
  {
    char v27 = 0;
  }
  uint64_t v29 = a11[1];
  if (!v29)
  {
    uint64_t v41 = 0;
    int v42 = 0;
    uint64_t v83 = 0;
    uint64_t v84 = 0;
    long long v85 = 0;
    int v81 = 0;
    uint64_t v82 = 0;
    char v43 = 1;
    BOOL v79 = 0;
    uint64_t v80 = 0;
    goto LABEL_77;
  }
  __int16 v30 = (const void *)*a11;
  unint64_t v31 = (float *)(*a11 + 4);
  uint64_t v32 = 1;
  LODWORD(a9) = 1.0;
  do
  {
    if (*((_DWORD *)v31 - 1) > 0x3FFu)
    {
      uint64_t v83 = 0;
      uint64_t v84 = 0;
      long long v85 = 0;
      int v81 = 0;
      uint64_t v82 = 0;
      BOOL v79 = 0;
      uint64_t v80 = 0;
      goto LABEL_34;
    }
    float v33 = *v31;
    v31 += 2;
    BOOL v34 = v33 >= 0.0;
    if (v33 > 1.0) {
      BOOL v34 = 0;
    }
  }
  while (v34 && v29 != v32++);
  uint64_t v83 = 0;
  uint64_t v84 = 0;
  long long v85 = 0;
  int v81 = 0;
  uint64_t v82 = 0;
  BOOL v79 = 0;
  uint64_t v80 = 0;
  if (!v34)
  {
LABEL_34:
    if (a13[1])
    {
      char v72 = v27;
      if (a2)
      {
        id v45 = objc_msgSend(*a3, sel_newBufferWithLength_options_, 8 * v29, 0, a9);
        id v76 = v45;
        LODWORD(v77) = 0;
        HIDWORD(v77) = objc_msgSend(v45, sel_length);
        NS::SharedPtr<MTL::Texture>::operator=(&v81, &v76);
        uint64_t v82 = v77;
        if (v76)
        {

          id v76 = 0;
        }
        unint64_t v15 = a6;
        if (v45) {

        }
        __int16 v46 = (char *)objc_msgSend(v81, sel_contents);
        __int16 v48 = &v46[v82];
      }
      else
      {
        re::FixedArray<BOOL>::init<>(&v83, *a1, 8 * v29);
        __int16 v48 = v85;
        unint64_t v15 = a6;
      }
      int v16 = a5;
      uint64_t v17 = a4;
      uint64_t v52 = 0;
      uint64_t v53 = a11[1];
      uint64_t v55 = *a13;
      unint64_t v54 = a13[1];
      uint64_t v56 = (int *)(*a11 + 4);
      uint64_t v57 = v48 + 4;
      do
      {
        if (v53 == v52)
        {
          re::internal::assertLog((re::internal *)6, v47, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v53, v53);
          _os_crash();
          __break(1u);
LABEL_86:
          re::internal::assertLog((re::internal *)6, v47, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v58, v54);
          _os_crash();
          __break(1u);
          goto LABEL_87;
        }
        unint64_t v58 = *(v56 - 1);
        if (v54 <= v58) {
          goto LABEL_86;
        }
        int v59 = *v56;
        v56 += 2;
        *(v57 - 1) = *(_DWORD *)(v55 + 4 * v58);
        *uint64_t v57 = v59;
        v57 += 2;
        ++v52;
      }
      while (v29 != v52);
      char v43 = 0;
LABEL_67:
      char v27 = v72;
      if (v72) {
        goto LABEL_68;
      }
      if (!a2) {
        goto LABEL_76;
      }
    }
    else
    {
      char v49 = v27;
      uint64_t v50 = *a1;
      v75[0] = v30;
      v75[1] = (const void *)(8 * v29);
      uint64_t v77 = 0;
      uint64_t v78 = 0;
      id v76 = 0;
      re::FixedArray<BOOL>::init<>(&v76, v50, 8 * v29);
      re::FixedArray<unsigned char>::copy(&v76, v75);
      re::FixedArray<float>::operator=(&v83, (uint64_t *)&v76);
      if (v76 && v77) {
        (*(void (**)(void))(*(void *)v76 + 40))();
      }
      if (!a2)
      {
        char v43 = 0;
        char v27 = v49;
        if (v49)
        {
          uint64_t v41 = 0;
          int v42 = 0;
          unint64_t v15 = a6;
          int v16 = a5;
          uint64_t v17 = a4;
        }
        else
        {
          unint64_t v15 = a6;
          int v16 = a5;
          uint64_t v17 = a4;
LABEL_76:
          int v42 = *a12;
          uint64_t v41 = 4 * (void)a12[1];
        }
        goto LABEL_77;
      }
      id v51 = objc_msgSend(*a3, sel_newBufferWithBytes_length_options_, v30, 8 * v29, 0);
      id v76 = v51;
      LODWORD(v77) = 0;
      HIDWORD(v77) = objc_msgSend(v51, sel_length);
      NS::SharedPtr<MTL::Texture>::operator=(&v81, &v76);
      uint64_t v82 = v77;
      if (v76)
      {

        id v76 = 0;
      }
      unint64_t v15 = a6;
      uint64_t v17 = a4;
      if (v51) {

      }
      char v43 = 0;
      char v27 = v49;
      int v16 = a5;
      if (v49)
      {
LABEL_68:
        uint64_t v41 = 0;
        int v42 = 0;
        goto LABEL_77;
      }
    }
    char v67 = v27;
    id v68 = objc_msgSend(*a3, sel_newBufferWithBytes_length_options_, *a12, 4 * (void)a12[1], 0);
    id v76 = v68;
    LODWORD(v77) = 0;
    HIDWORD(v77) = objc_msgSend(v68, sel_length);
    NS::SharedPtr<MTL::Texture>::operator=(&v79, &v76);
    uint64_t v80 = v77;
    if (v76)
    {

      id v76 = 0;
    }
    if (v68) {

    }
    uint64_t v41 = 0;
    int v42 = 0;
    char v27 = v67;
LABEL_77:
    *uint64_t v17 = v43;
    *int v16 = v27;
    re::FixedArray<float>::operator=(v15, &v83);
    NS::SharedPtr<MTL::Texture>::operator=((void **)a7, &v81);
    *(void *)(a7 + 8) = v82;
    *a8 = v42;
    a8[1] = (int *)v41;
    NS::SharedPtr<MTL::Texture>::operator=((void **)a10, &v79);
    int v69 = v79;
    *(void *)(a10 + 8) = v80;
    if (v69) {

    }
    if (v81) {
    uint64_t result = v83;
    }
    if (v83)
    {
      if (v84) {
        return (*(uint64_t (**)(void))(*(void *)v83 + 40))();
      }
    }
    return result;
  }
  char v72 = v27;
  uint64_t v36 = 4 * v29;
  if (a2)
  {
    id v37 = objc_msgSend(*a3, sel_newBufferWithLength_options_, v36, 0, a9);
    id v76 = v37;
    LODWORD(v77) = 0;
    HIDWORD(v77) = objc_msgSend(v37, sel_length);
    NS::SharedPtr<MTL::Texture>::operator=(&v81, &v76);
    uint64_t v82 = v77;
    if (v76)
    {

      id v76 = 0;
    }
    if (v37) {

    }
    id v38 = (char *)objc_msgSend(v81, sel_contents);
    id v40 = &v38[v82];
  }
  else
  {
    re::FixedArray<BOOL>::init<>(&v83, *a1, v36);
    id v40 = v85;
  }
  uint64_t v60 = 0;
  uint64_t v61 = a11[1];
  uint64_t v63 = *a13;
  unint64_t v62 = a13[1];
  int v64 = (float *)(*a11 + 4);
  uint64_t v17 = a4;
  while (v61 != v60)
  {
    *(float *)&uint64_t v65 = *(v64 - 1);
    if (v62)
    {
      uint64_t v65 = (int)v65;
      if (v62 <= (int)v65) {
        goto LABEL_88;
      }
      LODWORD(v65) = *(_DWORD *)(v63 + 4 * (int)v65);
    }
    float v66 = *v64;
    v64 += 2;
    *(_DWORD *)&v40[4 * v60++] = (float)((float)(v66 * 4194300.0) + 0.5) | (v65 << 22);
    if (v29 == v60)
    {
      char v43 = 1;
      goto LABEL_67;
    }
  }
LABEL_87:
  re::internal::assertLog((re::internal *)6, v39, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v61, v61);
  _os_crash();
  __break(1u);
LABEL_88:
  re::internal::assertLog((re::internal *)6, v39, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v65, v62);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void *re::SkinningModelUtil::inverseBindPoseBufferForPart@<X0>(void *this@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = (void *)this[10];
  if (!v4 || v4[1] <= a2 || (unint64_t v5 = *(unsigned int *)(v4[2] + 72 * a2 + 4), v5 == -1) || v4[4] <= v5)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    uint64_t v6 = v4[5] + 16 * v5;
    this = *(id *)v6;
    uint64_t v7 = *(void *)(v6 + 8);
    *a3 = this;
    a3[1] = v7;
  }
  return this;
}

void *re::SkinningModelUtil::skinnedEndIndicesBuffer@<X0>(void *this@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = this[10];
  if (v4 && *(void *)(v4 + 8) > a2)
  {
    uint64_t v5 = *(void *)(v4 + 16) + 72 * a2;
    this = *(id *)(v5 + 8);
    uint64_t v6 = *(void *)(v5 + 16);
    *a3 = this;
    a3[1] = v6;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return this;
}

uint64_t re::SkinningModelUtil::skinnedInfluenceDataBuffer(uint64_t a1, unint64_t a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (!v4 || *(void *)(v4 + 8) <= a2) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 16) + 72 * a2;
  *a3 = *(unsigned char *)v6;
  NS::SharedPtr<MTL::Texture>::operator=((void **)a4, (void **)(v6 + 24));
  *(void *)(a4 + 8) = *(void *)(v6 + 32);
  return 1;
}

void **re::SkinningDeformer::init(void **this, re::RenderManager *a2)
{
  if (!*((unsigned char *)this + 16))
  {
    uint64_t v2 = (re::SkinningDeformer *)this;
    char v3 = 0;
    char v4 = 1;
    *((unsigned char *)this + 16) = 1;
    do
    {
      char v5 = 0;
      char v6 = v4;
      char v7 = 1;
      do
      {
        char v8 = v7;
        LODWORD(v17) = 0;
        re::VertexFormatInfo::setVertexFormat((uint64_t)v16, (const VertexBufferFormat *)0xC, 0x1Eu);
        uint64_t v9 = v5 & 1;
        re::SkinningDeformer::getPerformSkinningPipeline(v2, 0, (const re::VertexFormatInfo *)v17, 0, 0, 0, v3 & 1, v9, 0);
        LODWORD(v17) = 0;
        re::VertexFormatInfo::setVertexFormat((uint64_t)v16, (const VertexBufferFormat *)0xC, 0x1Eu);
        unsigned int v15 = 0;
        re::VertexFormatInfo::setVertexFormat((uint64_t)v14, (const VertexBufferFormat *)0xC, 0x1Eu);
        char v5 = 1;
        re::SkinningDeformer::getPerformSkinningPipeline(v2, 1, (const re::VertexFormatInfo *)v17, (const re::VertexFormatInfo *)v15, 0, 0, v3 & 1, v9, 0);
        LODWORD(v17) = 0;
        re::VertexFormatInfo::setVertexFormat((uint64_t)v16, (const VertexBufferFormat *)0xC, 0x1Eu);
        unsigned int v15 = 0;
        re::VertexFormatInfo::setVertexFormat((uint64_t)v14, (const VertexBufferFormat *)0xC, 0x1Eu);
        unsigned int v13 = 0;
        re::VertexFormatInfo::setVertexFormat((uint64_t)v12, (const VertexBufferFormat *)0xC, 0x1Eu);
        re::SkinningDeformer::getPerformSkinningPipeline(v2, 2, (const re::VertexFormatInfo *)v17, (const re::VertexFormatInfo *)v15, (const re::VertexFormatInfo *)v13, 0, v3 & 1, v9, 0);
        LODWORD(v17) = 0;
        re::VertexFormatInfo::setVertexFormat((uint64_t)v16, (const VertexBufferFormat *)0xC, 0x1Eu);
        unsigned int v15 = 0;
        re::VertexFormatInfo::setVertexFormat((uint64_t)v14, (const VertexBufferFormat *)0xC, 0x1Eu);
        unsigned int v13 = 0;
        re::VertexFormatInfo::setVertexFormat((uint64_t)v12, (const VertexBufferFormat *)0xC, 0x1Eu);
        unsigned int v11 = 0;
        re::VertexFormatInfo::setVertexFormat((uint64_t)v10, (const VertexBufferFormat *)0xC, 0x1Eu);
        this = re::SkinningDeformer::getPerformSkinningPipeline(v2, 3, (const re::VertexFormatInfo *)v17, (const re::VertexFormatInfo *)v15, (const re::VertexFormatInfo *)v13, (const re::VertexFormatInfo *)v11, v3 & 1, v9, 0);
        char v7 = 0;
      }
      while ((v8 & 1) != 0);
      char v4 = 0;
      char v3 = 1;
    }
    while ((v6 & 1) != 0);
  }
  return this;
}

void **re::SkinningDeformer::getPerformSkinningPipeline(re::SkinningDeformer *this, uint64_t a2, const re::VertexFormatInfo *a3, const re::VertexFormatInfo *a4, const re::VertexFormatInfo *a5, const re::VertexFormatInfo *a6, uint64_t a7, uint64_t a8, BOOL a9)
{
  v69[3] = *MEMORY[0x263EF8340];
  uint64_t v9 = a3 | (4 * a4) | (16 * a5) | (a6 << 6);
  uint64_t v10 = a2;
  unsigned int v11 = (char *)this
      + 0x2000 * (unint64_t)a2
      + 32 * v9
      + 16 * a7
      + 8 * a8;
  uint64_t v13 = *((void *)v11 + 3);
  uint64_t v12 = (void **)(v11 + 24);
  if (!v13)
  {
    unint64_t v32 = a7;
    unint64_t v33 = a8;
    v54[0] = 0;
    uint64_t v60 = 0;
    memset(v58, 0, sizeof(v58));
    int v59 = 0;
    char v61 = 0;
    char v62 = 0;
    uint64_t v63 = 0;
    char v64 = 1;
    memset(v49, 0, sizeof(v49));
    uint64_t v20 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v49, 0);
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    uint64_t v53 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v49, v10);
    int v50 = 33;
    int v21 = (_anonymous_namespace_ *)re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v58, (re::DynamicString *)v49);
    memset(v44, 0, sizeof(v44));
    uint64_t v22 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v44, 0);
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v44, v9);
    int v45 = 65569;
    uint64_t v23 = (_anonymous_namespace_ *)re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v58, (re::DynamicString *)v44);
    memset(v39, 0, sizeof(v39));
    int v24 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v39, 0);
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v39, v32);
    int v40 = 131125;
    int v25 = (_anonymous_namespace_ *)re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v58, (re::DynamicString *)v39);
    memset(v34, 0, sizeof(v34));
    int v26 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v34, 0);
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)v34, v33);
    int v35 = 196661;
    char v27 = (re *)re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v58, (re::DynamicString *)v34);
    if (a9)
    {
      __int16 v28 = *re::graphicsLogObjects(v27);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)simd_float3x3 buf = 67109888;
        *(_DWORD *)&uint8_t buf[4] = a2;
        __int16 v66 = 1024;
        int v67 = v9;
        __int16 v68 = 1024;
        LODWORD(v69[0]) = a7;
        WORD2(v69[0]) = 1024;
        *(_DWORD *)((char *)v69 + 6) = a8;
        _os_log_impl(&dword_233120000, v28, OS_LOG_TYPE_DEFAULT, "Compiling performSkinning vfbc=%d ci=%d di=%d pi=%d", buf, 0x1Au);
      }
      re::DynamicString::format((re::DynamicString *)"vfbc=%d ci=%d di=%d pi=%d", (re::DynamicString *)buf, a2, v9, a7, a8);
      if (v66) {
        __int16 v30 = (re *)v69[0];
      }
      else {
        __int16 v30 = (re *)((char *)&v66 + 1);
      }
      re::REAnalyticsEventShaderPermutationsForPerformSkinning(v30, v29);
      if (*(void *)buf && (v66 & 1) != 0) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
    }
    ComputePipelineState = (void **)re::getOrCreateComputePipelineState(*((void *)this + 1), (uint64_t)v54);
    NS::SharedPtr<MTL::Texture>::operator=(v12, ComputePipelineState);
    if (v36)
    {
      if (v37)
      {
        (*(void (**)(void))(*(void *)v36 + 40))();
        uint64_t v37 = 0;
        uint64_t v38 = 0;
      }
      uint64_t v36 = 0;
    }
    if (*(void *)&v34[0] && (BYTE8(v34[0]) & 1) != 0) {
      (*(void (**)(void))(**(void **)&v34[0] + 40))();
    }
    if (v41)
    {
      if (v42)
      {
        (*(void (**)(void))(*(void *)v41 + 40))();
        uint64_t v42 = 0;
        uint64_t v43 = 0;
      }
      uint64_t v41 = 0;
    }
    if (*(void *)&v39[0] && (BYTE8(v39[0]) & 1) != 0) {
      (*(void (**)(void))(**(void **)&v39[0] + 40))();
    }
    if (v46)
    {
      if (v47)
      {
        (*(void (**)(void))(*(void *)v46 + 40))();
        uint64_t v47 = 0;
        uint64_t v48 = 0;
      }
      uint64_t v46 = 0;
    }
    if (*(void *)&v44[0] && (BYTE8(v44[0]) & 1) != 0) {
      (*(void (**)(void))(**(void **)&v44[0] + 40))();
    }
    if (v51)
    {
      if (v52)
      {
        (*(void (**)(void))(*(void *)v51 + 40))();
        uint64_t v52 = 0;
        uint64_t v53 = 0;
      }
      uint64_t v51 = 0;
    }
    if (*(void *)&v49[0] && (BYTE8(v49[0]) & 1) != 0) {
      (*(void (**)(void))(**(void **)&v49[0] + 40))();
    }
    re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v58);
    if (v57[0])
    {
      if (v57[1]) {
        (*(void (**)(void))(*(void *)v57[0] + 40))();
      }
      memset(v57, 0, sizeof(v57));
    }
    if (v54[0] && v55 && (v56 & 1) != 0) {
      (*(void (**)(void))(*(void *)v55 + 40))();
    }
  }
  return v12;
}

uint64_t re::SkinningDeformer::addDeformationInstance@<X0>(uint64_t this@<X0>, unsigned char *a2@<X1>, uint64_t a3@<X8>)
{
  if (a2[1]) {
    uint64_t v3 = 524318;
  }
  else {
    uint64_t v3 = 524290;
  }
  char v4 = *(unsigned char *)(*(void *)(this + 8) + 256) ^ 1 | *a2;
  *(void *)a3 = 0xFFFFFFFFLL;
  *(void *)(a3 + 8) = v3;
  *(void *)(a3 + 16) = v3;
  *(unsigned char *)(a3 + 24) = v4 ^ 1;
  *(void *)(a3 + 32) = -1;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  return this;
}

uint64_t re::SkinningDeformer::allocateBuffers(re::SkinningDeformer *a1, unint64_t a2, unsigned int a3, void *a4)
{
  unint64_t v4 = (unint64_t)a4;
  unint64_t v5 = a2;
  uint64_t v163 = *MEMORY[0x263EF8340];
  uint64_t v6 = *a4;
  uint64_t v107 = *(void *)(*a4 + 48);
  if (a3 == 1)
  {
    uint64_t v7 = *(void *)(a2 + 24);
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 32))(v7, 56, 8);
    *(void *)uint64_t v8 = 0;
    *(void *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 16) = 1;
    *(void *)(v8 + 32) = 0;
    *(void *)(v8 + 40) = 0;
    *(void *)(v8 + 24) = 0;
    *(_DWORD *)(v8 + 48) = 0;
    uint64_t v81 = v8;
  }
  else
  {
    uint64_t v81 = 0;
  }
  if (v107)
  {
    unint64_t v9 = 0;
    uint64_t v105 = v6 + 8;
    long long v115 = (void *)v4;
    uint64_t v99 = (re::FrameContext *)v5;
    do
    {
      uint64_t v10 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v105, v9);
      unint64_t v11 = *(void *)(v10 + 8);
      uint64_t v12 = (void *)re::BucketArray<re::ActiveDeformation,8ul>::operator[](*(void *)(v4 + 8), v11);
      unint64_t v14 = *(unsigned __int8 *)(v10 + 16);
      unint64_t v15 = v12[42];
      if (v15 <= v14)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, *(unsigned __int8 *)(v10 + 16), v15);
        _os_crash();
        __break(1u);
LABEL_63:
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v11, v17);
        _os_crash();
        __break(1u);
LABEL_64:
        *(void *)uint64_t v162 = 0;
        memset(v145, 0, sizeof(v145));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v157 = 136315906;
        *(void *)&v157[4] = "operator[]";
        *(_WORD *)&v157[12] = 1024;
        *(_DWORD *)&v157[14] = 476;
        *(_WORD *)&v157[18] = 2048;
        *(void *)&v157[20] = v104;
        *(_WORD *)&v157[28] = 2048;
        *(void *)&v157[30] = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_65:
        *(void *)uint64_t v162 = 0;
        memset(v145, 0, sizeof(v145));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v157 = 136315906;
        *(void *)&v157[4] = "operator[]";
        *(_WORD *)&v157[12] = 1024;
        *(_DWORD *)&v157[14] = 476;
        *(_WORD *)&v157[18] = 2048;
        *(void *)&v157[20] = v5;
        *(_WORD *)&v157[28] = 2048;
        *(void *)&v157[30] = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_66:
        *(void *)uint64_t v162 = 0;
        memset(v145, 0, sizeof(v145));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v157 = 136315906;
        *(void *)&v157[4] = "operator[]";
        *(_WORD *)&v157[12] = 1024;
        *(_DWORD *)&v157[14] = 476;
        *(_WORD *)&v157[18] = 2048;
        *(void *)&v157[20] = v4;
        *(_WORD *)&v157[28] = 2048;
        *(void *)&v157[30] = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_67:
        re::internal::assertLog((re::internal *)5, v57, "assertion failure: '%s' (%s:line %i) Unexpected vertex buffer index: %zu", "!\"Unreachable code\"", "allocateBuffers", 904, v5);
        _os_crash();
        __break(1u);
LABEL_68:
        re::internal::assertLog((re::internal *)5, v25, "assertion failure: '%s' (%s:line %i) Unsupported execution mode: %u.", "!\"Unreachable code\"", "allocateBuffers", 985, v30);
        _os_crash();
        __break(1u);
      }
      int v16 = v12;
      unint64_t v111 = v9;
      if (*(void *)(v12[44] + 40))
      {
        unint64_t v17 = *(void *)(v4 + 48);
        if (v17 <= v11) {
          goto LABEL_63;
        }
        int v101 = *(uint64_t **)(v12[44] + 40);
        unint64_t v5 = v12[41];
        uint64_t v18 = *(void *)(v4 + 40);
        uint64_t v19 = v12[46];
        uint64_t v20 = re::DataArray<re::MeshModel>::get(*(void *)(*((void *)a1 + 1) + 32) + 8, *(void *)(v19 + 16));
        unint64_t v4 = *(void *)(v20 + 56);
        unint64_t v104 = *((unsigned __int16 *)v16 + 196);
        if (v4 <= v104) {
          goto LABEL_64;
        }
        uint64_t v90 = v20;
        uint64_t v91 = v19;
        uint64_t v21 = v18 + 312 * v11;
        uint64_t v103 = *(void *)(v20 + 64);
        uint64_t v22 = *(void *)v21;
        uint64_t v113 = *(void *)(v5 + (v14 << 6) + 16);
        LOBYTE(v145[0]) = 1;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized(v21, 1u);
        uint64_t v23 = (void *)(v21 + 56);
        unsigned int v24 = *(_DWORD *)(*(void *)(v21 + 64)
                        + 32
                        * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v21 + 56), (unsigned __int8 *)v145)+ 20);
        LOBYTE(v145[0]) = 1;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized(v21, 1u);
        unint64_t v4 = v21 + 120;
        unsigned int v26 = *(unsigned __int16 *)(*(void *)(v21 + 128)
                                  + 20
                                  * re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v21 + 120), (unsigned __int8 *)v145)+ 4);
        unint64_t v116 = (uint64_t *)(v21 + 64);
        unsigned int v109 = v26;
        if ((*(unsigned char *)(v21 + 2) & 8) != 0)
        {
          LOBYTE(v145[0]) = 19;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized(v21, 0x13u);
          char v27 = (void *)(v21 + 56);
          unint64_t v28 = *(unsigned int *)(*(void *)(v21 + 64)
                                + 32
                                * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v23, (unsigned __int8 *)v145)+ 20);
          LOBYTE(v145[0]) = 19;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized(v21, 0x13u);
          unint64_t v29 = *(unsigned __int16 *)(*(void *)(v21 + 128)
                                    + 20
                                    * re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)v4, (unsigned __int8 *)v145)+ 4);
          if (v28 >= v29)
          {
            LOBYTE(v145[0]) = 21;
            unint64_t v100 = v28 / v29;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized(v21, 0x15u);
            uint64_t v23 = (void *)(v21 + 56);
            if (*(_DWORD *)(*v116
                           + 32
                           * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v27, (unsigned __int8 *)v145)+ 20))
            {
              LOBYTE(v145[0]) = 22;
              re::DeformationVertexBufferState::ensureVertexBufferInitialized(v21, 0x16u);
              BOOL v110 = *(_DWORD *)(*v116
                               + 32
                               * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v27, (unsigned __int8 *)v145)+ 20) != 0;
            }
            else
            {
              BOOL v110 = 0;
            }
          }
          else
          {
            unint64_t v100 = 0;
            BOOL v110 = 0;
            uint64_t v23 = (void *)(v21 + 56);
          }
          unsigned int v26 = v109;
        }
        else
        {
          unint64_t v100 = 0;
          BOOL v110 = 0;
        }
        uint64_t v108 = v24 / v26;
        unsigned int v30 = a3;
        if (a3)
        {
          unint64_t v114 = v113 & v22;
          if (a3 != 1) {
            goto LABEL_68;
          }
          unint64_t v31 = *(void **)(v16[43] + 80);
          unint64_t v5 = *((unsigned __int16 *)v16 + 196);
          unint64_t v14 = v31[1];
          if (v14 <= v5) {
            goto LABEL_65;
          }
          unsigned int v97 = v24;
          uint64_t v32 = v31[2];
          uint64_t v33 = v32 + 72 * *((unsigned __int16 *)v16 + 196);
          unint64_t v4 = *(unsigned int *)(v33 + 4);
          unint64_t v14 = v31[4];
          if (v14 <= v4) {
            goto LABEL_66;
          }
          long long v112 = v23;
          uint64_t v94 = v31[5];
          uint64_t v95 = *(unsigned int *)(v33 + 4);
          BOOL v34 = (unsigned __int8 *)(v32 + 72 * *((unsigned __int16 *)v16 + 196));
          unsigned int v35 = *((unsigned __int16 *)v16 + 196);
          unint64_t v5 = v34[2];
          long long v88 = v34 + 2;
          long long v89 = v34;
          uint64_t v93 = (uint64_t *)(v94 + 16 * v4);
          uint64_t v36 = (_DWORD *)v93 + 3;
          int v37 = *((_DWORD *)v93 + 3) >> 6;
          uint64_t v38 = (_OWORD *)(v103 + 560 * v104);
          *(_OWORD *)&v162[4] = v38[23];
          *(_OWORD *)&v162[20] = v38[24];
          *(_OWORD *)&v162[36] = v38[25];
          *(_OWORD *)&v162[52] = v38[26];
          re::FrameContext::perFrameAlloc(v99, 0x50uLL, 0x10uLL, (uint64_t)v145);
          uint64_t v82 = HIDWORD(v145[0]);
          uint64_t v83 = DWORD2(v145[0]);
          uint64_t v84 = *(void *)&v145[1];
          uint64_t v39 = *(void *)&v145[0] + DWORD2(v145[0]);
          *(unsigned char *)uint64_t v39 = v5;
          *(_DWORD *)(v39 + 4) = v37;
          *(_DWORD *)(v39 + 8) = v108;
          *(_OWORD *)(v39 + 28) = *(_OWORD *)&v162[16];
          *(_OWORD *)(v39 + 44) = *(_OWORD *)&v162[32];
          *(_OWORD *)(v39 + 60) = *(_OWORD *)&v162[48];
          *(_DWORD *)(v39 + 76) = *(_DWORD *)&v162[64];
          *(_OWORD *)(v39 + 12) = *(_OWORD *)v162;
          unsigned int v98 = v35;
          if (v110)
          {
            int v40 = v38 + 23;
            char v41 = *(unsigned char *)(v32 + 72 * v35 + 3);
            unint64_t v5 = *v36 >> 6;
            *(_OWORD *)((char *)v145 + 4) = *v40;
            *(_OWORD *)((char *)&v145[1] + 4) = v40[1];
            *(_OWORD *)((char *)&v145[2] + 4) = v40[2];
            *(_OWORD *)((char *)&v145[3] + 4) = v40[3];
            re::FrameContext::perFrameAlloc(v99, 0x50uLL, 0x10uLL, (uint64_t)v157);
            uint64_t v85 = *(unsigned int *)&v157[12];
            uint64_t v86 = *(void *)&v157[16];
            uint64_t v87 = *(unsigned int *)&v157[8];
            uint64_t v42 = *(void *)v157 + *(unsigned int *)&v157[8];
            *(unsigned char *)uint64_t v42 = v41;
            *(_DWORD *)(v42 + 4) = v5;
            *(_DWORD *)(v42 + 8) = v100;
            *(_OWORD *)(v42 + 28) = v145[1];
            *(_OWORD *)(v42 + 44) = v145[2];
            *(_OWORD *)(v42 + 60) = v145[3];
            *(_DWORD *)(v42 + 76) = v145[4];
            *(_OWORD *)(v42 + 12) = v145[0];
          }
          else
          {
            uint64_t v85 = 0;
            uint64_t v86 = 0;
            uint64_t v87 = 0;
          }
          int v45 = (void *)(v21 + 128);
          unint64_t v46 = *v36;
          if (*((_DWORD *)v101 + 3) == v46)
          {
            uint64_t v47 = *((unsigned int *)v101 + 2);
            uint64_t v102 = *v101;
            unint64_t v92 = v47 | (v46 << 32);
          }
          else
          {
            unint64_t v5 = (unint64_t)v99;
            re::FrameContext::perFrameAlloc(v99, v46, 0x10uLL, (uint64_t)v157);
            if (*(_DWORD *)&v157[12] >= 0x40u)
            {
              char v49 = (_OWORD *)(*(void *)v157 + *(unsigned int *)&v157[8]);
              unint64_t v50 = ((unint64_t)*(unsigned int *)&v157[12] >> 6) + 1;
              do
              {
                *char v49 = xmmword_23435FD50;
                v49[1] = xmmword_23435FD60;
                _OWORD v49[2] = xmmword_23435FD80;
                v49[3] = xmmword_23435FBB0;
                --v50;
                v49 += 4;
              }
              while (v50 > 1);
            }
            uint64_t v102 = *(void *)&v157[16];
            unint64_t v92 = *(void *)&v157[8];
            isSkinningAssignLoggingEnabled = (re *)re::DeformerFeatureFlags::isSkinningAssignLoggingEnabled(v48);
            if (isSkinningAssignLoggingEnabled)
            {
              uint64_t v52 = *re::graphicsLogObjects(isSkinningAssignLoggingEnabled);
              if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
              {
                uint64_t v76 = *((void *)v99 + 4) & 0xFFFFFFFFFFFFFFFLL;
                uint64_t v77 = *(void *)(v91 + 8);
                uint64_t v78 = *(void *)(v90 + 8);
                uint64_t v79 = *(void *)(v103 + 560 * v104 + 512);
                LODWORD(v145[0]) = 134218754;
                *(void *)((char *)v145 + 4) = v76;
                WORD6(v145[0]) = 2080;
                *(void *)((char *)v145 + 14) = v77;
                WORD3(v145[1]) = 2080;
                *((void *)&v145[1] + 1) = v78;
                LOWORD(v145[2]) = 2080;
                *(void *)((char *)&v145[2] + 2) = v79;
                _os_log_error_impl(&dword_233120000, v52, OS_LOG_TYPE_ERROR, "[DeformerLogging] Frame[%llu]: Mesh Instance[%s] Model[%s] Part[%s] missing pose data.", (uint8_t *)v145, 0x2Au);
              }
            }
          }
          __int16 v143 = 0;
          unsigned int v144 = 0;
          __int16 v141 = 0;
          memset(v142, 0, sizeof(v142));
          __int16 v139 = 0;
          memset(v140, 0, sizeof(v140));
          __int16 v137 = 0;
          memset(v138, 0, sizeof(v138));
          uint64_t v134 = 0;
          __int16 v135 = 0;
          memset(v136, 0, sizeof(v136));
          long long v133 = 0uLL;
          long long v132 = 0uLL;
          long long v131 = 0uLL;
          long long v130 = 0uLL;
          long long v129 = 0uLL;
          long long v128 = 0uLL;
          long long v127 = 0uLL;
          long long v126 = 0uLL;
          long long v125 = 0uLL;
          *(void *)unint64_t v157 = &v140[1];
          *(void *)&v157[8] = &v131;
          *(void *)&v157[16] = &v130;
          *(void *)&v157[24] = &v138[1];
          *(void *)&v157[32] = &v129;
          unint64_t v158 = &v128;
          uint64_t v159 = &v136[1];
          uint64_t v160 = 0;
          uint64_t v161 = &v127;
          uint64_t v53 = v112;
          if (v114)
          {
            uint64_t v54 = 0;
            unint64_t v5 = __clz(__rbit64(v114));
            while (1)
            {
              LOBYTE(v145[0]) = v5;
              re::DeformationVertexBufferState::ensureVertexBufferInitialized(v21, v5);
              uint64_t v55 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v53, (unsigned __int8 *)v145);
              uint64_t v56 = *v116;
              LOBYTE(v145[0]) = v5;
              re::DeformationVertexBufferState::ensureVertexBufferInitialized(v21, v5);
              uint64_t v58 = *v45
                  + 20
                  * re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v21 + 120), (unsigned __int8 *)v145);
              int v59 = *(_DWORD *)(v58 + 4);
              __int16 v122 = *(_WORD *)(v58 + 8);
              int v121 = v59;
              int v123 = *(_DWORD *)(v58 + 12);
              unsigned __int8 v60 = *(unsigned char *)(v58 + 16);
              unsigned __int8 v124 = v60;
              if (v5 - 2 >= 3)
              {
                if (v5 == 1)
                {
                  uint64_t v63 = &v132;
                  char v62 = &v133;
                  char v64 = (uint64_t *)&v142[1];
                }
                else
                {
                  if (v5 != 19) {
                    goto LABEL_67;
                  }
                  uint64_t v63 = &v125;
                  char v62 = &v126;
                  char v64 = &v134;
                }
                re::VertexFormatInfo::setVertexFormat((uint64_t)v64, (const VertexBufferFormat *)(unsigned __int16)v121, v60);
              }
              else
              {
                char v61 = (uint64_t *)&v157[24 * v54];
                char v62 = (long long *)v61[1];
                uint64_t v63 = (long long *)v61[2];
                re::VertexFormatInfo::setVertexFormat(*v61, (const VertexBufferFormat *)(unsigned __int16)v121, v60);
                uint64_t v54 = (v54 + 1);
                if (!v62) {
                  goto LABEL_49;
                }
              }
              uint64_t v65 = *(void *)(v56 + 32 * v55 + 16);
              *(void *)char v62 = *(void *)(v56 + 32 * v55 + 24);
              *((void *)v62 + 1) = v65;
LABEL_49:
              __int16 v66 = (void *)v16[45];
              uint64_t v67 = v115[2];
              int v117 = v121;
              __int16 v118 = v122;
              int v119 = v123;
              unsigned __int8 v120 = v124;
              unsigned int v68 = re::DeformationBufferAllocator::alloc(v66, v67, v5, (uint64_t)&v117, *(unsigned __int8 *)(v10 + 16), *(unsigned int *)(v56 + 32 * v55 + 20));
              uint64_t v69 = re::DeformationBufferAllocator::allocationData((re::DeformationBufferAllocator *)v16[45], *(unsigned __int8 *)(v10 + 16), v68);
              id v70 = objc_msgSend(*(id *)(v69 + 24), sel_contents);
              uint64_t v71 = *(void *)(v69 + 24);
              *(void *)&v145[0] = v70;
              *((void *)&v145[0] + 1) = *(void *)(v69 + 32);
              *(void *)&v145[1] = v71;
              re::DeformationVertexBufferState::setOutputBuffer(v21, v5, 1, (uint64_t)v145, (uint64_t)&v121);
              *(void *)uint64_t v63 = *(void *)(v69 + 24);
              *((void *)v63 + 1) = *(void *)(v69 + 32);
              if (v5 == 63 || (v114 & (-2 << v5)) == 0) {
                goto LABEL_53;
              }
              unint64_t v5 = __clz(__rbit64(v114 & (-2 << v5)));
              uint64_t v53 = v112;
              int v45 = (void *)(v21 + 128);
            }
          }
          uint64_t v54 = 0;
LABEL_53:
          if (v97 >= v109)
          {
            PerformSkinningPipeline = re::SkinningDeformer::getPerformSkinningPipeline(a1, v54, (const re::VertexFormatInfo *)v144, (const re::VertexFormatInfo *)v142[0], (const re::VertexFormatInfo *)v140[0], (const re::VertexFormatInfo *)v138[0], *v88 == 0, *v89, 1);
            if (*PerformSkinningPipeline)
            {
              *(void *)&v145[0] = PerformSkinningPipeline;
              *((void *)&v145[0] + 1) = v108;
              uint64_t v73 = v32 + 72 * v98;
              v145[1] = *(_OWORD *)(v73 + 24);
              v145[2] = *(_OWORD *)(v73 + 8);
              v145[3] = v133;
              v145[4] = v132;
              uint64_t v146 = *v93;
              uint64_t v147 = *(void *)(v94 + 16 * v95 + 8);
              uint64_t v148 = v102;
              unint64_t v149 = v92;
              uint64_t v150 = v84;
              uint64_t v151 = v83 | (v82 << 32);
              long long v152 = v131;
              long long v153 = v130;
              long long v154 = v129;
              long long v155 = v128;
              long long v156 = v127;
            }
          }
          if (v110)
          {
            __int16 v74 = re::SkinningDeformer::getPerformSkinningPipeline(a1, 0, (const re::VertexFormatInfo *)v136[0], 0, 0, 0, *(unsigned char *)(v32 + 72 * v98 + 3) == 0, *(unsigned __int8 *)(v32 + 72 * v98 + 1), 1);
            if (*v74)
            {
              *(void *)&v145[0] = v74;
              *((void *)&v145[0] + 1) = v100;
              uint64_t v75 = v32 + 72 * v98;
              v145[1] = *(_OWORD *)(v75 + 56);
              v145[2] = *(_OWORD *)(v75 + 40);
              v145[3] = v126;
              v145[4] = v125;
              uint64_t v146 = *v93;
              uint64_t v147 = *(void *)(v94 + 16 * v95 + 8);
              uint64_t v148 = v102;
              unint64_t v149 = v92;
              uint64_t v150 = v86;
              uint64_t v151 = v87 | (v85 << 32);
              long long v155 = 0u;
              long long v156 = 0u;
              long long v153 = 0u;
              long long v154 = 0u;
              long long v152 = 0u;
            }
          }
          unint64_t v4 = (unint64_t)v115;
        }
        else
        {
          unint64_t v4 = (unint64_t)v115;
          unint64_t v5 = (unint64_t)v99;
          if ((v113 & v22) != 0)
          {
            unint64_t v43 = v113 & v22;
            do
            {
              unint64_t v44 = __clz(__rbit64(v43));
              re::FrameContext::perFrameAlloc(v99, 4 * (v108 + 2 * v108), 0x10uLL, (uint64_t)v145);
              *(_WORD *)&v157[4] = 257;
              *(_DWORD *)unint64_t v157 = 65548;
              v157[12] = 30;
              *(_DWORD *)&v157[8] = 0;
              re::DeformationVertexBufferState::setOutputBuffer(v21, v44, 0, (uint64_t)v145, (uint64_t)v157);
              if (v44 == 63) {
                break;
              }
              unint64_t v43 = v113 & v22 & (-2 << v44);
            }
            while (v43);
          }
        }
      }
      unint64_t v9 = v111 + 1;
    }
    while (v111 + 1 != v107);
  }
  return v81;
}

uint64_t re::VertexFormatInfo::setVertexFormat(uint64_t this, const VertexBufferFormat *a2, unsigned __int8 a3)
{
  *(_WORD *)(this + 8) = (_WORD)a2;
  uint64_t v3 = re::unpackHalf3Data;
  if (a3 > 0x19u)
  {
    if (a3 == 26)
    {
      int v4 = 1;
      goto LABEL_10;
    }
    if (a3 == 30)
    {
      int v4 = 0;
      uint64_t v3 = re::unpackFloat3Data;
      goto LABEL_10;
    }
  }
  else
  {
    if (a3 == 8)
    {
      int v4 = 2;
      uint64_t v3 = re::unpackUChar3NormalizedData;
      goto LABEL_10;
    }
    if (a3 == 11)
    {
      int v4 = 3;
      uint64_t v3 = re::unpackChar3NormalizedData;
LABEL_10:
      *(void *)this = v3;
      *(_DWORD *)(this + 12) = v4;
      return this;
    }
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Unsupported format", "!\"Unreachable code\"", "setVertexFormat", 146);
  this = _os_crash();
  __break(1u);
  return this;
}

__n128 re::BucketArray<re::anonymous namespace'::GpuAllocationData::SkinTask,8ul>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 40);
  unint64_t v5 = *(void *)(a1 + 8);
  if (v4 + 1 > 8 * v5)
  {
    unint64_t v5 = *(void *)(a1 + 8);
  }
  if (v5 <= v4 >> 3)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v6 = a1 + 24;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 32);
  }
  uint64_t v7 = *(void *)(v6 + 8 * (v4 >> 3));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  uint64_t v8 = (_OWORD *)(v7 + 208 * (v4 & 7));
  long long v9 = *(_OWORD *)(a2 + 64);
  long long v11 = *(_OWORD *)(a2 + 16);
  long long v10 = *(_OWORD *)(a2 + 32);
  v8[3] = *(_OWORD *)(a2 + 48);
  void v8[4] = v9;
  v8[1] = v11;
  v8[2] = v10;
  long long v12 = *(_OWORD *)(a2 + 128);
  long long v14 = *(_OWORD *)(a2 + 80);
  long long v13 = *(_OWORD *)(a2 + 96);
  v8[7] = *(_OWORD *)(a2 + 112);
  v8[8] = v12;
  void v8[5] = v14;
  v8[6] = v13;
  long long v15 = *(_OWORD *)(a2 + 192);
  long long v17 = *(_OWORD *)(a2 + 144);
  long long v16 = *(_OWORD *)(a2 + 160);
  v8[11] = *(_OWORD *)(a2 + 176);
  v8[12] = v15;
  v8[9] = v17;
  v8[10] = v16;
  __n128 result = *(__n128 *)a2;
  *uint64_t v8 = *(_OWORD *)a2;
  return result;
}

uint64_t re::SkinningDeformer::deformGPU(int a1, uint64_t a2, void **this)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  re::mtl::ComputeCommandEncoder::pushDebugGroup(this, (re::ns *)"Linear Blend Skinning");
  uint64_t v8 = *(void *)(a2 + 40);
  if (v8)
  {
    unint64_t v9 = 0;
    int64x2_t v22 = vdupq_n_s64(1uLL);
    do
    {
      unint64_t v10 = *(void *)(a2 + 40);
      if (v10 <= v9)
      {
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, v9, v10);
        _os_crash();
        __break(1u);
LABEL_22:
        memset(v26, 0, sizeof(v26));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)uint64_t v23 = 136315906;
        *(void *)&v23[4] = "operator[]";
        *(_WORD *)&v23[12] = 1024;
        *(_DWORD *)&v23[14] = 866;
        *(_WORD *)&v23[18] = 2048;
        *(void *)&v23[20] = v3;
        __int16 v24 = 2048;
        unint64_t v25 = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      unint64_t v3 = v9 >> 3;
      unint64_t v4 = *(void *)(a2 + 8);
      if (v4 <= v9 >> 3) {
        goto LABEL_22;
      }
      uint64_t v11 = a2 + 24;
      if ((*(unsigned char *)(a2 + 16) & 1) == 0) {
        uint64_t v11 = *(void *)(a2 + 32);
      }
      unint64_t v3 = *(void *)(v11 + 8 * v3);
      unint64_t v4 = v9 & 7;
      long long v12 = (id **)(v3 + 208 * v4);
      [*this setComputePipelineState:**v12];
      if (*((_DWORD *)v12 + 19))
      {
        unint64_t v13 = v3 + 208 * v4;
        [*this setBuffer:*(void *)(v13 + 48) offset:*(unsigned int *)(v13 + 56) atIndex:0];
        [*this setBuffer:*(void *)(v13 + 64) offset:*(unsigned int *)(v13 + 72) atIndex:1];
      }
      unint64_t v14 = v3 + 208 * v4;
      [*this setBuffer:*(void *)(v14 + 80) offset:*(unsigned int *)(v14 + 88) atIndex:2];
      [*this setBuffer:*(void *)(v14 + 96) offset:*(unsigned int *)(v14 + 104) atIndex:3];
      [*this setBuffer:*(void *)(v14 + 112) offset:*(unsigned int *)(v14 + 120) atIndex:4];
      [*this setBuffer:*(void *)(v14 + 16) offset:*(unsigned int *)(v14 + 24) atIndex:5];
      if (*(_DWORD *)(v14 + 44)) {
        [*this setBuffer:*(void *)(v3 + 208 * v4 + 32) offset:*(unsigned int *)(v3 + 208 * v4 + 40) atIndex:6];
      }
      if (*(_DWORD *)(v3 + 208 * v4 + 156))
      {
        unint64_t v15 = v3 + 208 * v4;
        [*this setBuffer:*(void *)(v15 + 128) offset:*(unsigned int *)(v15 + 136) atIndex:7];
        [*this setBuffer:*(void *)(v15 + 144) offset:*(unsigned int *)(v15 + 152) atIndex:8];
      }
      if (*(_DWORD *)(v3 + 208 * v4 + 188))
      {
        unint64_t v16 = v3 + 208 * v4;
        [*this setBuffer:*(void *)(v16 + 160) offset:*(unsigned int *)(v16 + 168) atIndex:9];
        [*this setBuffer:*(void *)(v16 + 176) offset:*(unsigned int *)(v16 + 184) atIndex:10];
      }
      if (*(_DWORD *)(v3 + 208 * v4 + 204)) {
        [*this setBuffer:*(void *)(v3 + 208 * v4 + 192) offset:*(unsigned int *)(v3 + 208 * v4 + 200) atIndex:11];
      }
      uint64_t v17 = *(void *)(v3 + 208 * v4 + 8);
      unint64_t v18 = objc_msgSend(**v12, sel_threadExecutionWidth);
      uint64_t v19 = *this;
      *(void *)&v26[0] = ((v17 + v18 - 1) / v18);
      *(int64x2_t *)((char *)v26 + 8) = v22;
      *(void *)uint64_t v23 = v18;
      *(int64x2_t *)&v23[8] = v22;
      [v19 dispatchThreadgroups:v26 threadsPerThreadgroup:v23];
      ++v9;
    }
    while (v8 != v9);
  }
  uint64_t v20 = *this;
  return [v20 popDebugGroup];
}

uint64_t re::SkinningDeformer::deformCPU(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v122 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(*a3 + 48);
  if (v6)
  {
    uint64_t v7 = a3;
    uint64_t v8 = result;
    unint64_t v9 = 0;
    uint64_t v82 = *a3 + 8;
    uint64_t v70 = *(void *)(*a3 + 48);
    uint64_t v71 = result;
    while (1)
    {
      unint64_t v11 = *(void *)(re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v82, v9) + 8);
      unint64_t v12 = v7[6];
      if (v12 <= v11) {
        goto LABEL_69;
      }
      uint64_t v13 = v7[5];
      unint64_t v5 = re::BucketArray<re::ActiveDeformation,8ul>::operator[](v7[1], v11);
      __n128 result = re::DataArray<re::MeshModel>::get(*(void *)(*(void *)(v8 + 8) + 32) + 8, *(void *)(*(void *)(v5 + 368) + 16));
      unint64_t v3 = *(unsigned __int16 *)(v5 + 392);
      unint64_t v4 = *(void *)(result + 56);
      if (v4 <= v3)
      {
LABEL_70:
        *(void *)BOOL v110 = 0;
        long long v120 = 0u;
        long long v121 = 0u;
        long long v118 = 0u;
        long long v119 = 0u;
        long long v117 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)simd_float3x3 buf = 136315906;
        *(void *)unint64_t v114 = "operator[]";
        *(_WORD *)&v114[8] = 1024;
        *(_DWORD *)&v114[10] = 476;
        *(_WORD *)&v114[14] = 2048;
        *(void *)&v114[16] = v3;
        __int16 v115 = 2048;
        unint64_t v116 = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_71:
        *(void *)BOOL v110 = 0;
        long long v120 = 0u;
        long long v121 = 0u;
        long long v118 = 0u;
        long long v119 = 0u;
        long long v117 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)simd_float3x3 buf = 136315906;
        *(void *)unint64_t v114 = "operator[]";
        *(_WORD *)&v114[8] = 1024;
        *(_DWORD *)&v114[10] = 476;
        *(_WORD *)&v114[14] = 2048;
        *(void *)&v114[16] = v3;
        __int16 v115 = 2048;
        unint64_t v116 = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_72:
        *(void *)BOOL v110 = 0;
        long long v120 = 0u;
        long long v121 = 0u;
        long long v118 = 0u;
        long long v119 = 0u;
        long long v117 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)simd_float3x3 buf = 136315906;
        *(void *)unint64_t v114 = "operator[]";
        *(_WORD *)&v114[8] = 1024;
        *(_DWORD *)&v114[10] = 476;
        *(_WORD *)&v114[14] = 2048;
        *(void *)&v114[16] = v4;
        __int16 v115 = 2048;
        unint64_t v116 = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v14 = *(void *)(*(void *)(v5 + 352) + 40);
      if (v14) {
        break;
      }
LABEL_60:
      if (++v9 == v6) {
        return result;
      }
    }
    unint64_t v15 = *(void **)(*(void *)(v5 + 344) + 80);
    unint64_t v4 = v15[1];
    if (v4 <= v3) {
      goto LABEL_71;
    }
    unint64_t v84 = v9;
    uint64_t v16 = v15[2];
    uint64_t v83 = (unsigned __int8 *)(v16 + 72 * *(unsigned __int16 *)(v5 + 392));
    unint64_t v4 = *((unsigned int *)v83 + 1);
    unint64_t v5 = v15[4];
    if (v5 <= v4) {
      goto LABEL_72;
    }
    unint64_t v5 = *(void *)(result + 64);
    re::ReadOnlyCPUAccessibleBufferSliceContent::make((void *)(v15[5] + 16 * v4), (uint64_t)&v117);
    if (!(_BYTE)v117)
    {
      uint64_t v23 = *re::graphicsLogObjects(v17);
      unint64_t v9 = v84;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)simd_float3x3 buf = 0;
        _os_log_impl(&dword_233120000, v23, OS_LOG_TYPE_DEFAULT, "Failure: Read metal buffer", buf, 2u);
      }
      goto LABEL_59;
    }
    uint64_t v19 = *((void *)&v117 + 1);
    unint64_t v18 = v118;
    uint64_t v20 = v16 + 72 * v3;
    re::ReadOnlyCPUAccessibleBufferSliceContent::make((void *)(v20 + 8), (uint64_t)buf);
    int v22 = *(unsigned __int8 *)(v20 + 2);
    unint64_t v4 = v20 + 2;
    uint64_t v79 = (unsigned __int8 *)v4;
    if (v22)
    {
      unint64_t v77 = 0;
      uint64_t v78 = 0;
    }
    else
    {
      if (!buf[0])
      {
        __int16 v66 = *re::graphicsLogObjects(v21);
        uint64_t v6 = v70;
        uint64_t v8 = v71;
        unint64_t v9 = v84;
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)BOOL v110 = 0;
          _os_log_impl(&dword_233120000, v66, OS_LOG_TYPE_DEFAULT, "Failure: Read metal buffer", v110, 2u);
        }
LABEL_58:
        re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(buf);
LABEL_59:
        __n128 result = (uint64_t)re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(&v117);
        goto LABEL_60;
      }
      unint64_t v77 = *(void *)&v114[12] >> 2;
      uint64_t v78 = *(void *)&v114[4];
    }
    unint64_t v4 = 72;
    re::ReadOnlyCPUAccessibleBufferSliceContent::make((void *)(v16 + 72 * v3 + 24), (uint64_t)v110);
    if (v110[0])
    {
      uint64_t v72 = v111;
      unint64_t v4 = v16 + 72 * v3;
      re::ReadOnlyCPUAccessibleBufferSliceContent::make((void *)(v4 + 56), (uint64_t)v108);
      re::ReadOnlyCPUAccessibleBufferSliceContent::make((void *)(v4 + 40), (uint64_t)v105);
      re::ReadOnlyCPUAccessibleBufferSliceContent::make((void *)v14, (uint64_t)v103);
      if (v103[0])
      {
        unint64_t v26 = v13 + 312 * v11;
        unint64_t v27 = *(void *)(v26 + 16);
        uint64_t v73 = (void *)(v26 + 16);
        if (v27)
        {
          uint64_t v76 = v13 + 312 * v11;
          unint64_t v28 = v18 >> 6;
          unint64_t v4 = v104;
          unint64_t v29 = *(unsigned int *)(v14 + 12);
          unint64_t v30 = v5;
          unint64_t v5 = v29 >> 6;
          unint64_t v31 = __clz(__rbit64(v27));
          uint64_t v81 = (void *)(v76 + 120);
          uint64_t v80 = (void *)(v76 + 128);
          uint64_t v75 = (void *)(v76 + 56);
          __int16 v74 = (void *)(v76 + 64);
          uint64_t v32 = v16 + 72 * v3;
          uint64_t v67 = (unsigned __int8 *)(v32 + 3);
          unsigned int v68 = (unsigned __int8 *)(v32 + 1);
          uint64_t v86 = (float32x4_t *)(v30 + 560 * v3 + 368);
          while (1)
          {
            unint64_t v99 = v31;
            unsigned __int8 v112 = v31;
            unsigned __int8 v33 = v31;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized(v76, v31);
            uint64_t v34 = *v80
                + 20
                * re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v81, &v112);
            *(void *)unint64_t v100 = 0;
            __int16 v101 = 0;
            int v102 = 0;
            re::VertexFormatInfo::setVertexFormat((uint64_t)v100, (const VertexBufferFormat *)*(unsigned __int16 *)(v34 + 4), *(unsigned char *)(v34 + 16));
            unsigned __int8 v112 = v99;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized(v76, v33);
            uint64_t v35 = *v74
                + 32
                * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v75, &v112);
            uint64_t v95 = *(unsigned int *)(v35 + 16);
            uint64_t v97 = *(void *)(v35 + 8);
            unsigned __int8 v112 = v99;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized(v76, v33);
            uint64_t v36 = *(void *)(v76 + 192)
                + 32
                * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v76 + 184), &v112);
            uint64_t v89 = *(unsigned int *)(v36 + 16);
            uint64_t v91 = *(void *)(v36 + 8);
            unsigned int v93 = *(_DWORD *)(v36 + 20);
            unint64_t v3 = *v83;
            int v85 = *v79;
            unsigned __int8 v112 = v99;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized(v76, v33);
            unsigned int v37 = *(_DWORD *)(*v74
                            + 32
                            * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v75, &v112)+ 20);
            unsigned __int8 v112 = v99;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized(v76, v33);
            uint64_t v38 = re::HashBrown<re::VertexBufferID,re::VertexBufferFormat,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v81, &v112);
            unint64_t v40 = v99;
            unsigned int v41 = *(unsigned __int16 *)(*v80 + 20 * v38 + 4);
            if (v99 == 19)
            {
              if (!v108[0]) {
                goto LABEL_49;
              }
              unint64_t v3 = *v68;
              int v85 = *v67;
              uint64_t v87 = v109;
              if (v105[0])
              {
                uint64_t v88 = v106;
                unint64_t v11 = v107 >> 2;
              }
              else
              {
                unint64_t v11 = 0;
                uint64_t v88 = 0;
              }
            }
            else
            {
              unint64_t v11 = v77;
              uint64_t v87 = v72;
              uint64_t v88 = v78;
            }
            if (v37 >= v41)
            {
              unint64_t v42 = 0;
              int v43 = 0;
              uint64_t v98 = v97 + v95;
              uint64_t v92 = v91 + v89;
              LODWORD(v44) = v37 / v41;
              if (v44 <= 1) {
                uint64_t v44 = 1;
              }
              else {
                uint64_t v44 = v44;
              }
              uint64_t v90 = v44;
              uint64_t v94 = v93 / 0xC;
              __int16 v96 = *(uint64_t (**)(uint64_t, unint64_t))v100;
              while (1)
              {
                if (v11)
                {
                  if (v11 <= v42) {
                    goto LABEL_68;
                  }
                  int v45 = *(_DWORD *)(v88 + 4 * v42);
                }
                else
                {
                  int v45 = v43 + v85;
                }
                float32x2_t v46 = (float32x2_t)v96(v98, v42);
                float32x4_t v47 = 0uLL;
                int v48 = v45 - v43;
                if (v45 > v43) {
                  break;
                }
LABEL_43:
                unint64_t v40 = v99;
                if (v99 != 1 && v99 != 19)
                {
                  int8x16_t v60 = (int8x16_t)vmulq_f32(v47, v47);
                  *(float32x2_t *)v60.i8 = vadd_f32(*(float32x2_t *)v60.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL));
                  v60.i32[0] = vadd_f32(*(float32x2_t *)v60.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v60.i8, 1)).u32[0];
                  float32x2_t v61 = vrsqrte_f32((float32x2_t)v60.u32[0]);
                  float32x2_t v62 = vmul_f32(v61, vrsqrts_f32((float32x2_t)v60.u32[0], vmul_f32(v61, v61)));
                  float32x4_t v47 = vmulq_n_f32(v47, vmul_f32(v62, vrsqrts_f32((float32x2_t)v60.u32[0], vmul_f32(v62, v62))).f32[0]);
                }
                if (v42 == v94) {
                  goto LABEL_67;
                }
                uint64_t v63 = v92 + 12 * v42;
                *(void *)uint64_t v63 = v47.i64[0];
                *(_DWORD *)(v63 + 8) = v47.i32[2];
                ++v42;
                int v43 = v45;
                if (v42 == v90) {
                  goto LABEL_48;
                }
              }
              *(float32x2_t *)v49.f32 = v46;
              v49.i64[1] = v39;
              int32x4_t v50 = (int32x4_t)vaddq_f32(v86[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*v86, v46.f32[0]), v86[1], v46, 1), v86[2], v49, 2));
              float32x4_t v51 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.i8, 1);
              float32x4_t v52 = (float32x4_t)vdupq_laneq_s32(v50, 2);
              float32x4_t v53 = (float32x4_t)vdupq_laneq_s32(v50, 3);
              uint64_t v54 = (float *)(v87 + 4 + 8 * v43);
              uint64_t v55 = (_DWORD *)(v87 + 4 * v43);
              float32x4_t v47 = 0uLL;
              while (1)
              {
                if (v3)
                {
                  signed int v56 = *v55 >> 22;
                  float v57 = (float)(*v55 & 0x3FFFFF) * 0.00000023842;
                }
                else
                {
                  signed int v56 = *((_DWORD *)v54 - 1);
                  float v57 = *v54;
                }
                uint64_t v58 = v56;
                if (v28 <= v56) {
                  break;
                }
                float32x4_t v59 = vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(v19 + ((uint64_t)v56 << 6)), *(float *)v50.i32), v51, *(float32x4_t *)(v19 + ((uint64_t)v56 << 6) + 16)), v52, *(float32x4_t *)(v19 + ((uint64_t)v56 << 6) + 32)), v53, *(float32x4_t *)(v19 + ((uint64_t)v56 << 6) + 48));
                if (v29 >= 0x40)
                {
                  if (v5 <= v56) {
                    goto LABEL_66;
                  }
                  float32x4_t v59 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)(v4 + ((uint64_t)v56 << 6)), v59.f32[0]), *(float32x4_t *)(v4 + ((uint64_t)v56 << 6) + 16), *(float32x2_t *)v59.f32, 1), *(float32x4_t *)(v4 + ((uint64_t)v56 << 6) + 32), v59, 2), *(float32x4_t *)(v4 + ((uint64_t)v56 << 6) + 48), v59, 3);
                }
                float32x4_t v47 = vaddq_f32(v47, vmulq_n_f32(v59, v57));
                v54 += 2;
                ++v55;
                if (!--v48) {
                  goto LABEL_43;
                }
              }
              re::internal::assertLog((re::internal *)6, v39, *(double *)v47.i64, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v56, v28);
              _os_crash();
              __break(1u);
LABEL_66:
              re::internal::assertLog((re::internal *)6, v39, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v58, v29 >> 6);
              _os_crash();
              __break(1u);
LABEL_67:
              re::internal::assertLog((re::internal *)6, v39, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v94, v94);
              _os_crash();
              __break(1u);
LABEL_68:
              re::internal::assertLog((re::internal *)6, v39, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v42, v11);
              _os_crash();
              __break(1u);
LABEL_69:
              re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v11, v12);
              _os_crash();
              __break(1u);
              goto LABEL_70;
            }
LABEL_48:
            if (v40 == 63) {
              break;
            }
LABEL_49:
            if ((*v73 & (-2 << v40)) == 0) {
              break;
            }
            unint64_t v31 = __clz(__rbit64(*v73 & (-2 << v40)));
          }
        }
      }
      else
      {
        uint64_t v65 = *re::graphicsLogObjects(v25);
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)unint64_t v100 = 0;
          _os_log_impl(&dword_233120000, v65, OS_LOG_TYPE_DEFAULT, "Failure: Read metal buffer", v100, 2u);
        }
      }
      re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(v103);
      re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(v105);
      re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(v108);
      uint64_t v7 = a3;
    }
    else
    {
      char v64 = *re::graphicsLogObjects(v24);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v108 = 0;
        _os_log_impl(&dword_233120000, v64, OS_LOG_TYPE_DEFAULT, "Failure: Read metal buffer", v108, 2u);
      }
    }
    re::Result<re::ReadOnlyCPUAccessibleBufferSliceContent,re::DetailedError>::~Result(v110);
    uint64_t v6 = v70;
    uint64_t v8 = v71;
    unint64_t v9 = v84;
    goto LABEL_58;
  }
  return result;
}

void re::SkinningDeformer::~SkinningDeformer(re::SkinningDeformer *this)
{
  for (uint64_t i = 32784; i != 16; i -= 8)
  {
    unint64_t v3 = *(void **)((char *)this + i);
    if (v3)
    {

      *(void *)((char *)this + i) = 0;
    }
  }
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  uint64_t v2 = 32784;
  while (1)
  {
    unint64_t v3 = *(void **)((char *)this + v2);
    if (v3)
    {

      *(void *)((char *)this + v2) = 0;
    }
    v2 -= 8;
    if (v2 == 16)
    {
      JUMPOUT(0x237DBCBD0);
    }
  }
}

uint64_t re::BucketArray<re::SkinningModelBuilder::RawSkinnedMeshPartData,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<re::SkinningModelBuilder::RawSkinnedMeshPartData,4ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 88 * (v2 & 3);
}

uint64_t re::BucketArray<re::SkinningModelBuilder::PreparedSkinnedMeshPartData,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<re::SkinningModelBuilder::PreparedSkinnedMeshPartData,4ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 4) >> 2);
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(v4 + 8 * (v2 >> 2));
  ++*(void *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 152 * (v2 & 3);
}

void _ZNSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_16SkinningDeformerENS2_12_GLOBAL__N_113SkinningModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISG_EEFvSF_EED0Ev()
{
}

void *_ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_16SkinningDeformerENS2_12_GLOBAL__N_113SkinningModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISG_EEFvSF_EE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26E714100;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_16SkinningDeformerENS2_12_GLOBAL__N_113SkinningModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISG_EEFvSF_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E714100;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_16SkinningDeformerENS2_12_GLOBAL__N_113SkinningModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISG_EEFvSF_EEclEOSF_(uint64_t result, void **a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    re::FixedArray<re::BufferSlice>::deinit(v2 + 3);
    if (*v2)
    {
      uint64_t v4 = v2[1];
      if (v4)
      {
        uint64_t v5 = 72 * v4;
        uint64_t v6 = v2[2] + 40;
        do
        {
          uint64_t v7 = *(void **)(v6 + 16);
          if (v7)
          {

            *(void *)(v6 + 16) = 0;
          }
          if (*(void *)v6)
          {

            *(void *)uint64_t v6 = 0;
          }
          uint64_t v8 = *(void **)(v6 - 16);
          if (v8)
          {

            *(void *)(v6 - 16) = 0;
          }
          unint64_t v9 = *(void **)(v6 - 32);
          if (v9)
          {

            *(void *)(v6 - 32) = 0;
          }
          v6 += 72;
          v5 -= 72;
        }
        while (v5);
        (*(void (**)(void, void))(*(void *)*v2 + 40))(*v2, v2[2]);
        v2[1] = 0;
        v2[2] = 0;
      }
      void *v2 = 0;
    }
    uint64_t v10 = *(uint64_t (**)(uint64_t, void *))(*(void *)v3 + 40);
    return v10(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_16SkinningDeformerENS2_12_GLOBAL__N_113SkinningModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISG_EEFvSF_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re20DeformationModelData6createINS2_16SkinningDeformerENS2_12_GLOBAL__N_113SkinningModelEJEEEPT0_PNS2_9AllocatorEDpOT1_EUlPvE_NS_9allocatorISG_EEFvSF_EE11target_typeEv()
{
}

uint64_t re::HashTable<re::StringID,re::DeformationAttributeData,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, const StringID *a4, long long *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      int v12 = *(_DWORD *)(a1 + 28);
      signed int v13 = 2 * v12;
      uint64_t v14 = *(void *)a1;
      if (*(void *)a1)
      {
        if (v13) {
          BOOL v15 = v9 == v13;
        }
        else {
          BOOL v15 = 1;
        }
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v33, 0, 36);
          *(void *)&v33[36] = 0x7FFFFFFFLL;
          re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v33, v14, v13);
          long long v16 = *(_OWORD *)v33;
          *(_OWORD *)unsigned __int8 v33 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          uint64_t v17 = *(void *)&v33[16];
          uint64_t v18 = *(void *)(a1 + 16);
          *(void *)&v33[16] = v18;
          *(void *)(a1 + 16) = v17;
          long long v20 = *(_OWORD *)&v33[24];
          *(_OWORD *)&v33[24] = *(_OWORD *)(a1 + 24);
          unsigned int v19 = *(_DWORD *)&v33[32];
          *(_OWORD *)(a1 + 24) = v20;
          unint64_t v21 = v19;
          if (v19)
          {
            unint64_t v22 = 0;
            uint64_t v23 = v18 + 24;
            do
            {
              if ((*(_DWORD *)(v23 - 24) & 0x80000000) != 0)
              {
                unint64_t v24 = 0xBF58476D1CE4E5B9 * ((*(void *)(v23 - 16) >> 31) ^ (*(void *)(v23 - 16) >> 1));
                unint64_t v25 = (0x94D049BB133111EBLL * (v24 ^ (v24 >> 27))) ^ ((0x94D049BB133111EBLL * (v24 ^ (v24 >> 27))) >> 31);
                re::HashTable<re::StringID,re::DeformationAttributeData,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(a1, v25 % *(unsigned int *)(a1 + 24), v25, v23 - 16, v23);
              }
              ++v22;
              v23 += 48;
            }
            while (v22 < v21);
          }
          re::HashTable<re::StringID,re::DeformationAttributeData,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)v33);
        }
      }
      else
      {
        if (v13) {
          signed int v28 = 2 * v12;
        }
        else {
          signed int v28 = 3;
        }
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v26 = *(void *)(a1 + 16);
    int v27 = *(_DWORD *)(v26 + 48 * v9);
  }
  else
  {
    uint64_t v26 = *(void *)(a1 + 16);
    int v27 = *(_DWORD *)(v26 + 48 * v9);
    *(_DWORD *)(a1 + 36) = v27 & 0x7FFFFFFF;
  }
  uint64_t v29 = 48 * v9;
  *(_DWORD *)(v26 + v29) = v27 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v29) = *(_DWORD *)(*(void *)(a1 + 16) + 48 * v9) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(void *)(a1 + 16) + 48 * v9 + 8), a4);
  uint64_t v30 = *(void *)(a1 + 16) + 48 * v9;
  long long v31 = *a5;
  *(void *)(v30 + 40) = *((void *)a5 + 2);
  *(_OWORD *)(v30 + 24) = v31;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

uint64_t re::BucketArray<re::anonymous namespace'::GpuAllocationData::SkinTask,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((void *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(void *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void *re::BucketArray<re::anonymous namespace'::GpuAllocationData::SkinTask,8ul>::setBucketsCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      unint64_t v4 = result[1];
      if (v4 > a2)
      {
        int v5 = *((_DWORD *)result + 4);
        do
        {
          uint64_t v6 = v3 + 3;
          if ((v5 & 1) == 0) {
            uint64_t v6 = (void *)v3[4];
          }
          uint64_t result = (void *)(*(uint64_t (**)(void, void))(*(void *)*v3 + 40))(*v3, v6[v4 - 1]);
          int v7 = *((_DWORD *)v3 + 4);
          unint64_t v4 = v3[1] - 1;
          v3[1] = v4;
          int v5 = v7 + 2;
          *((_DWORD *)v3 + 4) = v5;
        }
        while (v4 > a2);
      }
      if (v4 < a2)
      {
        uint64_t v8 = v3 + 3;
        do
        {
          uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(*(void *)*v3 + 32))(*v3, 1664, 0);
          uint64_t v9 = result;
          if (*v3)
          {
            unint64_t v10 = v3[1];
            int v11 = *((_DWORD *)v3 + 4);
            if ((v11 & 1) == 0)
            {
              unint64_t v12 = *v8;
              BOOL v14 = v10 >= *v8;
              unint64_t v13 = v10 + 1;
              BOOL v14 = !v14 || v12 >= v13;
              if (v14) {
                goto LABEL_24;
              }
              unint64_t v15 = 2 * v12;
              goto LABEL_20;
            }
            unint64_t v13 = v10 + 1;
            if (v13 >= 3)
            {
              unint64_t v15 = 4;
LABEL_20:
              if (v15 <= v13) {
                unint64_t v17 = v13;
              }
              else {
                unint64_t v17 = v15;
              }
              uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v17);
              int v11 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            unint64_t v16 = v3[1] + 1;
            uint64_t result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v16);
            int v11 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v11;
          }
LABEL_24:
          uint64_t v18 = v3 + 3;
          if ((v11 & 1) == 0) {
            uint64_t v18 = (void *)v3[4];
          }
          unint64_t v19 = v3[1];
          v18[v19++] = v9;
          v3[1] = v19;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v19 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

float32x4_t re::ColorManager::computeWPCMatrix@<Q0>(float32x4_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v3 = a2;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF980A8, memory_order_acquire) & 1) == 0)
  {
    int v14 = __cxa_guard_acquire(&qword_26AF980A8);
    uint64_t v3 = a2;
    if (v14)
    {
      re::Defaults::floatValue((re::Defaults *)"iblWPCStrength", v15, (uint64_t)&_MergedGlobals_415);
      __cxa_atexit((void (*)(void *))re::Optional<float>::~Optional, &_MergedGlobals_415, &dword_233120000);
      __cxa_guard_release(&qword_26AF980A8);
      uint64_t v3 = a2;
    }
  }
  float v6 = *(float *)&dword_26AF980A4;
  if (!_MergedGlobals_415) {
    float v6 = 1.0;
  }
  float v18 = v6;
  if (v3)
  {
    v17[0] = 0xFEE1A01690D44944;
    v17[1] = "colorpipe:wpcStrength";
    re::DebugSettingsManager::getWithErrorCode<float>(v3, v17, &v18);
    re::StringID::destroyString((re::StringID *)v17);
    float v6 = v18;
  }
  float32x4_t v7 = vmulq_n_f32(*a1, v6);
  float32x4_t v8 = vmulq_n_f32(a1[1], v6);
  float32x4_t v9 = vmulq_n_f32(a1[2], v6);
  float v10 = 1.0 - v6;
  float32x4_t v11 = vaddq_f32(v7, vmulq_n_f32((float32x4_t)xmmword_23435FD50, v10));
  float32x4_t v12 = vaddq_f32(v8, vmulq_n_f32((float32x4_t)xmmword_23435FD60, v10));
  *(_DWORD *)(a3 + 8) = v11.i32[2];
  *(_DWORD *)(a3 + 24) = v12.i32[2];
  float32x4_t result = vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_23435FD80, v10), v9);
  *(void *)a3 = v11.i64[0];
  *(void *)(a3 + 16) = v12.i64[0];
  *(_DWORD *)(a3 + 40) = result.i32[2];
  *(void *)(a3 + 32) = result.i64[0];
  return result;
}

uint64_t re::ColorManager::deinit(re::ColorManager *this)
{
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    MEMORY[0x237DBCBA0](v2, 0x1000C8052888210);
    *((void *)this + 10) = 0;
  }
  uint64_t result = *((void *)this + 1559);
  if (result)
  {
    uint64_t result = MEMORY[0x237DBCBA0](result, 0x1000C8052888210);
    *((void *)this + 1559) = 0;
  }
  return result;
}

void *re::ColorManager::setTargetDisplayTonemapLUTDomain(void *a1, uint64_t *a2)
{
  unint64_t v4 = (void *)a1[10];
  if (v4)
  {
    uint64_t v5 = a1[9];
    if (v5 == *a2) {
      goto LABEL_7;
    }
    MEMORY[0x237DBCBA0]();
    a1[10] = 0;
  }
  uint64_t v5 = *a2;
  if (*a2) {
    operator new[]();
  }
  unint64_t v4 = 0;
LABEL_7:
  a1[9] = v5;
  uint64_t result = memcpy(v4, (const void *)a2[1], 4 * *a2);
  if (a1[1558] != *a2 && *a2 != 0)
  {
    uint64_t v8 = a1[1559];
    if (v8) {
      MEMORY[0x237DBCBA0](v8, 0x1000C8052888210);
    }
    operator new[]();
  }
  return result;
}

__n128 re::ColorManager::setTonemapUserParameters(re::ColorManager *this, const re::TonemapUserParameters *a2, const re::TonemapUserParameters *a3)
{
  uint64_t v5 = (re::ColorManager *)((char *)this + 88);
  *((unsigned char *)this + 173) |= !re::haveSamePreBlendLUT((re::ColorManager *)((char *)this + 88), a2, a3);
  *((unsigned char *)this + 174) |= !re::haveSameExposure(v5, a2, v6);
  __n128 result = *(__n128 *)a2;
  long long v8 = *((_OWORD *)a2 + 1);
  long long v9 = *((_OWORD *)a2 + 2);
  *(_OWORD *)((char *)this + 129) = *(_OWORD *)((char *)a2 + 41);
  *(_OWORD *)((char *)this + 120) = v9;
  *(_OWORD *)((char *)this + 104) = v8;
  *(__n128 *)((char *)this + 88) = result;
  return result;
}

void re::ColorManager::updateTonemapLUTs(uint64_t a1, float *a2)
{
  if (*(unsigned char *)(a1 + 174) || *(unsigned char *)(a1 + 173))
  {
    uint64_t v4 = *(void *)(a1 + 12464);
    if (v4)
    {
      uint64_t v5 = *(float **)(a1 + 80);
      float v6 = *(float **)(a1 + 12472);
      do
      {
        float v7 = *v5++;
        *v6++ = re::computeTonemapping(a2, v7 * *a2);
        --v4;
      }
      while (v4);
    }
    if (!*(unsigned char *)(a1 + 67) && *(unsigned char *)(a1 + 173))
    {
      for (unint64_t i = 0; i != 1024; ++i)
        *(float *)(a1 + 176 + 4 * i) = re::computeTonemapping(a2, a2[31] * (float)(*a2 * (float)((float)((float)i * 0.00097752) + 0.0)))* a2[32];
      for (unint64_t j = 0; j != 1024; ++j)
        *(float *)(a1 + 4272 + 4 * j) = (float)(re::computeTonemappingInverse(a2, (float)((float)j * 0.00097752) + 0.0)
                                              * a2[1])
                                      * a2[6];
    }
    *(_WORD *)(a1 + 173) = 0;
  }
}

void re::ColorManager::updateISPTonemapLUTAccelerated(uint64_t a1)
{
  double v4 = MEMORY[0x270FA5388](a1);
  uint64_t v22 = *MEMORY[0x263EF8340];
  unint64_t v5 = *(void *)(v2 + 8);
  if (v5)
  {
    float v6 = *(float *)&v4;
    float v7 = v3;
    uint64_t v8 = v2;
    long long v9 = v1;
    float __A = 0.0;
    float __B = (float)v5 * 0.00097656;
    vDSP_vramp(&__A, &__B, __C, 1, 0x400uLL);
    float __S2 = 0.0;
    float __S1 = 1.0;
    vDSP_vtabi(__C, 1, &__S1, &__S2, *(const float **)v8, *(void *)(v8 + 8), v9 + 2092, 1, 0x400uLL);
    re::computeTonemappingInverseAccelerated(v7, v9 + 2092, v9 + 2092, 0x400uLL);
    unint64_t v11 = *(void *)(v8 + 8);
    double v12 = (double)v11 * 0.1;
    if (v11 <= (unint64_t)v12)
    {
      re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, (unint64_t)v12, v11);
      _os_crash();
      __break(1u);
    }
    else
    {
      unint64_t v13 = *(const float **)v8;
      v9[3122] = re::computeTonemappingInverse(v7, v13[(unint64_t)v12]) / 0.1;
      unint64_t v15 = (unint64_t)(float)((float)(v9[3120] * (float)v11) / v6);
      if (v11 - 1 < v15) {
        unint64_t v15 = v11 - 1;
      }
      if (v11 > v15)
      {
        float v16 = v9[3121] + (float)(v13[v15] - v9[3121]) * 0.05;
        v9[3121] = v16;
        return;
      }
    }
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v11);
    _os_crash();
    __break(1u);
  }
}

void *re::allocInfo_ColorManager(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF980B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF980B0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF980B8, "ColorManager");
    __cxa_guard_release(&qword_26AF980B0);
  }
  return &unk_26AF980B8;
}

void re::initInfo_ColorManager(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x31DB7AC1852E8DD4;
  v5[1] = "ColorManager";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0x30D000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = &re::initInfo_ColorManager(re::IntrospectionBase *)::structureAttributes;
  *((void *)this + 9) = re::internal::defaultConstruct<re::ColorManager>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::ColorManager>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ColorManager>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ColorManager>;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

double re::internal::defaultConstruct<re::ColorManager>(int a1, int a2, re::ColorManager *this)
{
  return re::ColorManager::ColorManager(this);
}

uint64_t re::introspect_ColorManager(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ColorManager", (uint64_t (*)(re::internal *))re::allocInfo_ColorManager, (re::IntrospectionBase *(*)(void))re::initInfo_ColorManager, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ColorManager>, this);
}

float32x4_t *re::computeFrustumCorners@<X0>(float32x4_t *result@<X0>, uint64_t a2@<X1>, int a3@<W2>, float32x4_t *a4@<X8>, float32x4_t a5@<Q1>, float32x4_t a6@<Q2>, float32x4_t a7@<Q4>)
{
  a4[6] = 0u;
  a4[7] = 0u;
  a4[4] = 0u;
  a4[5] = 0u;
  a4[2] = 0u;
  a4[3] = 0u;
  *a4 = 0u;
  a4[1] = 0u;
  if (*(_DWORD *)a2)
  {
    if (!a3) {
      return result;
    }
    float32x4_t v8 = *result;
    float v9 = result[1].f32[0];
    float v10 = result[1].f32[1];
    float v11 = result[1].f32[2];
    float v12 = result[1].f32[3];
    float v13 = (float)(v9 + v9) * v11;
    float v14 = (float)(v10 + v10) * v12;
    a6.f32[0] = v13 + v14;
    float v15 = (float)(v10 + v10) * v11;
    float v16 = (float)(v9 + v9) * v12;
    float v17 = (float)(v9 + v9) * v9;
    float v18 = (float)(v10 + v10) * v10;
    a6.f32[1] = v15 - v16;
    a6.f32[2] = 1.0 - (float)(v17 + v18);
    float v19 = (float)(v9 + v9) * v10;
    float v20 = (float)(v11 + v11) * v12;
    v7.f32[0] = v19 - v20;
    a7.f32[0] = (float)(v11 + v11) * v11;
    v7.f32[1] = 1.0 - (float)(v17 + a7.f32[0]);
    v7.f32[2] = v16 + v15;
    a7.f32[0] = 1.0 - (float)(v18 + a7.f32[0]);
    a7.f32[1] = v19 + v20;
    a7.f32[2] = v13 - v14;
    float32x4_t v21 = vsubq_f32(*result, vmulq_n_f32(a6, COERCE_FLOAT(*(void *)(a2 + 4))));
    float32x4_t v22 = vmulq_n_f32(a7, COERCE_FLOAT(*(_OWORD *)(a2 + 16)));
    float32x4_t v23 = vaddq_f32(v22, v21);
    float32x4_t v24 = vmulq_n_f32(v7, COERCE_FLOAT(*(void *)(a2 + 20)));
    float32x4_t v25 = vaddq_f32(v24, v23);
    v25.i32[3] = 1.0;
    float32x4_t v26 = vmulq_n_f32(v7, COERCE_FLOAT(*(void *)(a2 + 24)));
    float32x4_t v27 = vaddq_f32(v26, v23);
    v27.i32[3] = 1.0;
    *a4 = v25;
    a4[1] = v27;
    float32x4_t v28 = vmulq_n_f32(a7, COERCE_FLOAT(*(void *)(a2 + 12)));
    float32x4_t v29 = vaddq_f32(v28, v21);
    float32x4_t v30 = vaddq_f32(v24, v29);
    v30.i32[3] = 1.0;
    float32x4_t v31 = vaddq_f32(v26, v29);
    v31.i32[3] = 1.0;
    a4[2] = v30;
    a4[3] = v31;
    float32x4_t v32 = vsubq_f32(v8, vmulq_n_f32(a6, COERCE_FLOAT(*(void *)(a2 + 8))));
    float32x4_t v33 = vaddq_f32(v22, v32);
    float32x4_t v34 = vaddq_f32(v24, v33);
    v34.i32[3] = 1.0;
    float32x4_t v35 = vaddq_f32(v26, v33);
    v35.i32[3] = 1.0;
    a4[4] = v34;
    a4[5] = v35;
    float32x4_t v36 = vaddq_f32(v28, v32);
    float32x4_t v37 = vaddq_f32(v24, v36);
    v37.i32[3] = 1.0;
    a4[6] = v37;
    float32x4_t v38 = vaddq_f32(v26, v36);
    v38.i32[3] = 1.0;
  }
  else
  {
    a5.i32[0] = result[1].i32[0];
    a6.i32[0] = result[1].i32[1];
    float v39 = result[1].f32[2];
    a7.i32[0] = result[1].i32[3];
    float32x4_t v40 = *result;
    float v41 = a6.f32[0] + a6.f32[0];
    float v42 = (float)(a5.f32[0] + a5.f32[0]) * a5.f32[0];
    float v43 = (float)(a6.f32[0] + a6.f32[0]) * a6.f32[0];
    float v44 = (float)(v39 + v39) * v39;
    a6.f32[0] = (float)(a5.f32[0] + a5.f32[0]) * a6.f32[0];
    float v45 = (float)(a5.f32[0] + a5.f32[0]) * v39;
    float v46 = v41 * v39;
    float v47 = (float)(a5.f32[0] + a5.f32[0]) * a7.f32[0];
    float v48 = v41 * a7.f32[0];
    a7.f32[0] = (float)(v39 + v39) * a7.f32[0];
    a5.f32[0] = 1.0 - (float)(v43 + v44);
    a5.f32[1] = a6.f32[0] + a7.f32[0];
    a5.f32[2] = v45 - v48;
    a6.f32[0] = a6.f32[0] - a7.f32[0];
    a6.f32[1] = 1.0 - (float)(v42 + v44);
    a6.f32[2] = v47 + v46;
    a7.f32[0] = v45 + v48;
    a7.f32[1] = v46 - v47;
    a7.f32[2] = 1.0 - (float)(v42 + v43);
    float v49 = *(float *)(a2 + 4);
    float32x4_t v50 = vaddq_f32(*result, vmulq_n_f32(a7, -v49));
    long long v51 = *(_OWORD *)(a2 + 16);
    float32x4_t v52 = vmulq_n_f32(a5, *(float *)&v51);
    float32x4_t v53 = vaddq_f32(v50, v52);
    uint64_t v54 = *(void *)(a2 + 12);
    float32x4_t v55 = vmulq_n_f32(a5, *(float *)&v54);
    float32x4_t v56 = vaddq_f32(v50, v55);
    uint64_t v57 = *(void *)(a2 + 20);
    float32x4_t v58 = vmulq_n_f32(a6, *(float *)&v57);
    float32x4_t v59 = vaddq_f32(v58, v53);
    uint64_t v60 = *(void *)(a2 + 24);
    float32x4_t v61 = vmulq_n_f32(a6, *(float *)&v60);
    float32x4_t v62 = vaddq_f32(v61, v53);
    float32x4_t v63 = vaddq_f32(v58, v56);
    float32x4_t v64 = vaddq_f32(v61, v56);
    v59.i32[3] = 1.0;
    v62.i32[3] = 1.0;
    *a4 = v59;
    a4[1] = v62;
    v63.i32[3] = 1.0;
    v64.i32[3] = 1.0;
    a4[2] = v63;
    a4[3] = v64;
    if (a3 && (float v65 = *(float *)(a2 + 8), v65 != INFINITY))
    {
      float32x4_t v69 = vaddq_f32(v40, vmulq_n_f32(a7, -v65));
      float v70 = 1.0 / v49;
      float32x4_t v71 = vmulq_n_f32(a5, v65);
      float32x4_t v72 = vmulq_n_f32(a6, v65);
      float32x4_t v73 = vaddq_f32(v69, vmulq_n_f32(vmulq_n_f32(v71, *(float *)&v51), v70));
      float32x4_t v74 = vaddq_f32(v69, vmulq_n_f32(vmulq_n_f32(vmulq_f32(a5, v71), *(float *)&v54), v70));
      float32x4_t v75 = vmulq_n_f32(vmulq_n_f32(v72, *(float *)&v57), v70);
      float32x4_t v76 = vaddq_f32(v75, v73);
      float32x4_t v77 = vmulq_n_f32(vmulq_n_f32(v72, *(float *)&v60), v70);
      float32x4_t v78 = vaddq_f32(v77, v73);
      float32x4_t v79 = vaddq_f32(v75, v74);
      float32x4_t v38 = vaddq_f32(v77, v74);
      v76.i32[3] = 1.0;
      v78.i32[3] = 1.0;
      a4[4] = v76;
      a4[5] = v78;
      v79.i32[3] = 1.0;
      a4[6] = v79;
      v38.i32[3] = 1.0;
    }
    else
    {
      float32x4_t v66 = vaddq_f32(v58, v52);
      float32x4_t v67 = vaddq_f32(v61, v52);
      float32x4_t v68 = vaddq_f32(v58, v55);
      float32x4_t v38 = vaddq_f32(v61, v55);
      v66.i32[3] = 0;
      v67.i32[3] = 0;
      a4[4] = v66;
      a4[5] = v67;
      v68.i32[3] = 0;
      a4[6] = v68;
      v38.i32[3] = 0;
    }
  }
  a4[7] = v38;
  return result;
}

unint64_t re::computeCullingPlanes@<X0>(float32x4_t *this@<X0>, const re::RenderCamera *a2@<X1>, const re::Projection *a3@<X2>, float32x4_t *a4@<X8>, float32x4_t a5@<Q1>, float32x4_t a6@<Q2>, float32x4_t a7@<Q3>, float32x4_t a8@<Q4>, float32x4_t a9@<Q6>)
{
  int v9 = (int)a3;
  a4->i64[0] = 0;
  a4->i32[2] = 0;
  if (*(_DWORD *)a2)
  {
    float32x4_t v107 = *this;
    float v12 = this[1].f32[0];
    float v13 = this[1].f32[1];
    a6.i32[0] = this[1].i32[2];
    float v14 = this[1].f32[3];
    a8.f32[0] = v12 + v12;
    float v15 = v13 + v13;
    float v16 = (float)(v12 + v12) * v12;
    float v17 = (float)(v13 + v13) * v13;
    float v18 = (float)(a6.f32[0] + a6.f32[0]) * a6.f32[0];
    float v19 = a8.f32[0] * v13;
    float v20 = a8.f32[0] * a6.f32[0];
    float v21 = v15 * a6.f32[0];
    float v22 = a8.f32[0] * v14;
    float v23 = v15 * v14;
    a6.f32[0] = (float)(a6.f32[0] + a6.f32[0]) * v14;
    a8.f32[0] = 1.0 - (float)(v17 + v18);
    a8.f32[1] = v19 + a6.f32[0];
    a8.f32[2] = v20 - (float)(v15 * v14);
    a6.f32[0] = v19 - a6.f32[0];
    a6.f32[1] = 1.0 - (float)(v16 + v18);
    a6.f32[2] = v22 + v21;
    float32x4_t v102 = a8;
    float32x4_t v104 = a6;
    long long v100 = *((_OWORD *)a2 + 1);
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(0, (uint64_t)a2);
    float32x4_t v24 = vmulq_f32(v102, vaddq_f32(v107, vmulq_n_f32(v102, *(float *)&v100)));
    float32x4_t v25 = v102;
    v25.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0];
    a4[1] = v25;
    LODWORD(v100) = *(void *)((char *)a2 + 12);
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(1uLL, v26);
    float32x4_t v27 = vnegq_f32(v102);
    float32x4_t v28 = vmulq_f32(vaddq_f32(v107, vmulq_n_f32(v102, *(float *)&v100)), v27);
    v27.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0];
    a4[2] = v27;
    v102.i32[0] = *(void *)((char *)a2 + 20);
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(2uLL, v29);
    float32x4_t v30 = vmulq_f32(v104, vaddq_f32(v107, vmulq_n_f32(v104, v102.f32[0])));
    float32x4_t v31 = v104;
    v31.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0];
    a4[3] = v31;
    v102.i32[0] = *((void *)a2 + 3);
    unint64_t result = re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(3uLL, v32);
    float32x4_t v35 = vnegq_f32(v104);
    float32x4_t v36 = vmulq_f32(vaddq_f32(v107, vmulq_n_f32(v104, v102.f32[0])), v35);
    float32x4_t v37 = vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1));
    v35.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), v37).f32[0];
    a4[4] = v35;
    a4->i64[0] = 4;
    a4->i32[2] = 4;
    if (v9)
    {
      v37.f32[0] = v20 + v23;
      v37.f32[1] = v21 - v22;
      v37.f32[2] = 1.0 - (float)(v16 + v17);
      float32x4_t v105 = v37;
      float v38 = *((float *)a2 + 2);
      re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(4uLL, v34);
      float32x4_t v39 = vnegq_f32(v105);
      float32x4_t v40 = vmulq_f32(vaddq_f32(v107, vmulq_n_f32(v105, -v38)), v39);
      v39.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).f32[0];
      a4[5] = v39;
      unint64_t v41 = 5;
      a4->i64[0] = 5;
      a4->i32[2] = 5;
      float v42 = *((float *)a2 + 1);
      unint64_t result = re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(5uLL, v43);
      float32x4_t v44 = v105;
      float32x4_t v45 = vaddq_f32(v107, vmulq_n_f32(v105, -v42));
      float32x4_t v46 = v105;
LABEL_4:
      float32x4_t v47 = vmulq_f32(v45, v44);
      v46.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0];
      a4[v41 + 1] = v46;
      ++a4->i64[0];
      ++a4->i32[2];
    }
  }
  else
  {
    float v48 = this[1].f32[0];
    a5.i32[0] = this[1].i32[1];
    float v49 = this[1].f32[2];
    a7.i32[0] = this[1].i32[3];
    float v50 = v48 + v48;
    float v51 = a5.f32[0] + a5.f32[0];
    a9.f32[0] = v49 + v49;
    float v52 = (float)(v48 + v48) * v48;
    float v53 = (float)(a5.f32[0] + a5.f32[0]) * a5.f32[0];
    float v54 = (float)(v49 + v49) * v49;
    a5.f32[0] = v50 * a5.f32[0];
    float v55 = v50 * v49;
    float v56 = v51 * v49;
    float v57 = v50 * a7.f32[0];
    float v58 = v51 * a7.f32[0];
    a7.f32[0] = a9.f32[0] * a7.f32[0];
    a9.f32[0] = 1.0 - (float)(v53 + v54);
    a9.f32[1] = a5.f32[0] + a7.f32[0];
    a9.f32[2] = v55 - v58;
    a5.f32[0] = a5.f32[0] - a7.f32[0];
    a5.f32[1] = 1.0 - (float)(v52 + v54);
    a5.f32[2] = v57 + v56;
    a7.f32[0] = v55 + v58;
    a7.f32[1] = v56 - v57;
    a7.f32[2] = 1.0 - (float)(v52 + v53);
    float32x4_t v96 = a7;
    float32x4_t v108 = *this;
    float32x4_t v97 = vaddq_f32(*this, vmulq_n_f32(a7, -*((float *)a2 + 1)));
    float32x4_t v98 = vsubq_f32(*this, v97);
    float32x4_t v59 = vaddq_f32(vmulq_n_f32(a9, COERCE_FLOAT(*((_OWORD *)a2 + 1))), v97);
    float32x4_t v60 = vaddq_f32(vmulq_n_f32(a9, COERCE_FLOAT(*(void *)((char *)a2 + 12))), v97);
    float32x4_t v61 = vmulq_n_f32(a5, COERCE_FLOAT(*(void *)((char *)a2 + 20)));
    float32x4_t v62 = vmulq_n_f32(a5, COERCE_FLOAT(*((void *)a2 + 3)));
    float32x4_t v99 = vaddq_f32(v61, v59);
    float32x4_t v101 = vaddq_f32(v61, v60);
    float32x4_t v103 = vaddq_f32(v62, v59);
    float32x4_t v106 = vaddq_f32(v62, v60);
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(0, (uint64_t)a2);
    float32x4_t v63 = vmulq_f32(v97, v98);
    float32x4_t v64 = v98;
    v64.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v63, 2), vaddq_f32(v63, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v63.f32, 1))).f32[0];
    float v65 = a4 + 1;
    a4[a4->i64[0] + 1] = v64;
    unint64_t v66 = a4->i64[0] + 1;
    a4->i64[0] = v66;
    ++a4->i32[2];
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(v66, v67);
    float32x4_t v68 = vsubq_f32(v103, v108);
    float32x4_t v69 = vsubq_f32(v99, v103);
    int8x16_t v70 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v69, (int32x4_t)v69), (int8x16_t)v69, 0xCuLL), vnegq_f32(v68)), v69, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v68, (int32x4_t)v68), (int8x16_t)v68, 0xCuLL));
    float32x4_t v71 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v70, (int32x4_t)v70), v70, 0xCuLL);
    float32x4_t v72 = vmulq_f32(v108, v71);
    v71.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 2), vaddq_f32(v72, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v72.f32, 1))).f32[0];
    v65[v66] = v71;
    unint64_t v73 = a4->i64[0] + 1;
    a4->i64[0] = v73;
    ++a4->i32[2];
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(v73, v74);
    float32x4_t v75 = vsubq_f32(v99, v108);
    float32x4_t v76 = vsubq_f32(v101, v99);
    int8x16_t v77 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v76, (int32x4_t)v76), (int8x16_t)v76, 0xCuLL), vnegq_f32(v75)), v76, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v75, (int32x4_t)v75), (int8x16_t)v75, 0xCuLL));
    float32x4_t v78 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v77, (int32x4_t)v77), v77, 0xCuLL);
    float32x4_t v79 = vmulq_f32(v108, v78);
    v78.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v79, 2), vaddq_f32(v79, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.f32, 1))).f32[0];
    v65[v73] = v78;
    unint64_t v80 = a4->i64[0] + 1;
    a4->i64[0] = v80;
    ++a4->i32[2];
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(v80, v81);
    float32x4_t v82 = vsubq_f32(v101, v108);
    float32x4_t v83 = vsubq_f32(v106, v101);
    int8x16_t v84 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v83, (int32x4_t)v83), (int8x16_t)v83, 0xCuLL), vnegq_f32(v82)), v83, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v82, (int32x4_t)v82), (int8x16_t)v82, 0xCuLL));
    float32x4_t v85 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v84, (int32x4_t)v84), v84, 0xCuLL);
    float32x4_t v86 = vmulq_f32(v108, v85);
    v85.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v86, 2), vaddq_f32(v86, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v86.f32, 1))).f32[0];
    v65[v80] = v85;
    unint64_t v87 = a4->i64[0] + 1;
    a4->i64[0] = v87;
    ++a4->i32[2];
    unint64_t result = re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(v87, v88);
    float32x4_t v90 = vsubq_f32(v106, v108);
    float32x4_t v91 = vsubq_f32(v103, v106);
    int8x16_t v92 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v91, (int32x4_t)v91), (int8x16_t)v91, 0xCuLL), vnegq_f32(v90)), v91, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v90, (int32x4_t)v90), (int8x16_t)v90, 0xCuLL));
    float32x4_t v93 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v92, (int32x4_t)v92), v92, 0xCuLL);
    float32x4_t v94 = vmulq_f32(v108, v93);
    v93.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 2), vaddq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v94.f32, 1))).f32[0];
    v65[v87] = v93;
    unint64_t v41 = a4->i64[0] + 1;
    a4->i64[0] = v41;
    ++a4->i32[2];
    if (v9)
    {
      float v95 = *((float *)a2 + 2);
      if (v95 != INFINITY)
      {
        unint64_t result = re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(v41, v89);
        float32x4_t v45 = vnegq_f32(v98);
        float32x4_t v44 = vaddq_f32(v108, vmulq_n_f32(v96, -v95));
        float32x4_t v46 = v45;
        goto LABEL_4;
      }
    }
  }
  return result;
}

unint64_t re::buildCullingPlanes@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, __n128 a4@<Q0>)
{
  unint64_t v6 = 0;
  uint64_t v7 = 0;
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t v8 = a1 + 16;
  uint64_t v9 = a1 + 32;
  uint64_t v10 = a1 + 48;
  uint64_t v11 = a3 + 16;
  char v12 = 1;
  do
  {
    char v13 = v12;
    char v14 = 1;
    do
    {
      char v15 = v14;
      float v16 = *(float *)(a1 + 4 * v7);
      if (v14)
      {
        float v16 = -v16;
        float v30 = (float)-*(float *)(v8 + 4 * v7) - *(float *)(a1 + 28);
        a4.n128_f32[0] = (float)-*(float *)(v9 + 4 * v7) - *(float *)(a1 + 44);
        __n128 v29 = a4;
        float v17 = -*(float *)(v10 + 4 * v7);
      }
      else
      {
        float v30 = *(float *)(v8 + 4 * v7) - *(float *)(a1 + 28);
        a4.n128_f32[0] = *(float *)(v9 + 4 * v7) - *(float *)(a1 + 44);
        __n128 v29 = a4;
        float v17 = *(float *)(v10 + 4 * v7);
      }
      float v18 = *(float *)(a1 + 12);
      float v19 = *(float *)(a1 + 60);
      unint64_t result = re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(v6, a2);
      char v14 = 0;
      a4.n128_f32[0] = v16 - v18;
      a4.n128_f32[1] = v30;
      __n128 v21 = v29;
      a4.n128_u32[2] = v29.n128_u32[0];
      a4.n128_f32[3] = v17 - v19;
      *(__n128 *)(v11 + 16 * v6) = a4;
      unint64_t v6 = *(void *)a3 + 1;
      *(void *)a3 = v6;
      ++*(_DWORD *)(a3 + 8);
    }
    while ((v15 & 1) != 0);
    char v12 = 0;
    uint64_t v7 = 1;
  }
  while ((v13 & 1) != 0);
  v21.n128_u32[0] = *(_DWORD *)(a1 + 8);
  float v22 = *(float *)(a1 + 24);
  float32x4_t v23 = (float32x4_t)v21;
  v23.f32[1] = v22;
  float v24 = *(float *)(a1 + 40);
  float32x4_t v25 = vnegq_f32(v23);
  v25.f32[2] = -v24;
  float32x4_t v26 = vmulq_f32(v25, v25);
  float32x4_t v27 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1)));
  if (sqrtf(v27.f32[0]) > 0.0)
  {
    v25.f32[3] = -*(float *)(a1 + 56);
    float32x4_t v31 = v25;
    unint64_t result = re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(v6, a2);
    *(float32x4_t *)(v11 + 16 * v6) = v31;
    unint64_t v6 = *(void *)a3 + 1;
    *(void *)a3 = v6;
    ++*(_DWORD *)(a3 + 8);
    v21.n128_u32[0] = *(_DWORD *)(a1 + 8);
    float v22 = *(float *)(a1 + 24);
    float v24 = *(float *)(a1 + 40);
  }
  v27.f32[0] = (float)-*(float *)(a1 + 12) - v21.n128_f32[0];
  v27.f32[1] = (float)-*(float *)(a1 + 28) - v22;
  v27.f32[2] = (float)-*(float *)(a1 + 44) - v24;
  float32x4_t v28 = vmulq_f32(v27, v27);
  if (sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0]) > 0.0)
  {
    v27.f32[3] = (float)-*(float *)(a1 + 60) - *(float *)(a1 + 56);
    float32x4_t v32 = v27;
    unint64_t result = re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(v6, a2);
    *(float32x4_t *)(v11 + 16 * v6) = v32;
    ++*(void *)a3;
    ++*(_DWORD *)(a3 + 8);
  }
  return result;
}

double re::buildCullingFrustum@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  unsigned int v4 = 0;
  char v5 = 0;
  uint64_t v6 = 0;
  v40[1] = *MEMORY[0x263EF8340];
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  v40[0] = 0x3F80000000000000;
  __n128 v7 = *(__n128 *)a2;
  float32x4_t v8 = *((float32x4_t *)a2 + 1);
  float32x4_t v9 = *((float32x4_t *)a2 + 2);
  float32x4_t v10 = *((float32x4_t *)a2 + 3);
  do
  {
    char v11 = 0;
    uint64_t v12 = 0;
    char v13 = v5;
    char v14 = (const float *)v40 + v6;
    float32x4_t v15 = vld1q_dup_f32(v14);
    uint64_t v39 = 0x3F800000BF800000;
    do
    {
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      char v18 = v11;
      float v19 = (const float *)&v40[-1] + v12;
      float32x4_t v20 = vld1q_dup_f32(v19);
      uint64_t v38 = 0x3F800000BF800000;
      uint64_t v21 = (int)v4;
      LODWORD(v22) = 8 - v4;
      if (v4 <= 8) {
        uint64_t v22 = v22;
      }
      else {
        uint64_t v22 = 0;
      }
      do
      {
        char v23 = v16;
        float32x4_t v24 = vaddq_f32(v10, vmlaq_f32(vmlaq_f32(vmulq_n_f32((float32x4_t)v7, *((float *)&v38 + v17)), v20, v8), v15, v9));
        if (v24.f32[3] != 0.0) {
          float32x4_t v24 = vdivq_f32(v24, (float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 3));
        }
        if (v17 == v22)
        {
          re::internal::assertLog((re::internal *)6, v17, v16, v7.n128_f64[0], *(double *)v8.i64, *(double *)v9.i64, *(double *)v10.i64, 0.00781250557, *(double *)v15.i64, *(double *)v20.i64, *(double *)v24.i64, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, v21, 8);
          _os_crash();
          __break(1u);
        }
        *(&v30 + v21++) = (__int128)v24;
        ++v4;
        uint64_t v16 = 1;
        uint64_t v17 = 1;
      }
      while ((v23 & 1) == 0);
      char v11 = 1;
      uint64_t v12 = 1;
    }
    while ((v18 & 1) == 0);
    char v5 = 1;
    uint64_t v6 = 1;
  }
  while ((v13 & 1) == 0);
  re::buildCullingPlanes(a1, 1, (uint64_t)a3, v7);
  long long v25 = v35;
  a3[11] = v34;
  a3[12] = v25;
  long long v26 = v37;
  a3[13] = v36;
  a3[14] = v26;
  long long v27 = v31;
  a3[7] = v30;
  a3[8] = v27;
  double result = *(double *)&v32;
  long long v29 = v33;
  a3[9] = v32;
  a3[10] = v29;
  return result;
}

uint64_t re::boundingBoxIntersectFrustums(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::transformedAABBVertices(a1, (float32x4_t *)a2, &v81);
  int8x16_t v5 = *(int8x16_t *)(a2 + 16);
  int8x16_t v6 = *(int8x16_t *)(a2 + 32);
  float32x4_t v7 = vmulq_f32(*(float32x4_t *)a2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v6, v6, 0xCuLL), v6, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v5, (int32x4_t)v5), v5, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), v6, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v5, v5, 0xCuLL), v5, 8uLL)));
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0] >= 0.0)
  {
    float32x4_t v38 = vsubq_f32(v81, v82);
    float32x4_t v39 = vsubq_f32(v84, v81);
    int8x16_t v40 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v39, (int32x4_t)v39), (int8x16_t)v39, 0xCuLL), vnegq_f32(v38)), v39, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v38, (int32x4_t)v38), (int8x16_t)v38, 0xCuLL));
    float32x4_t v41 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v40, (int32x4_t)v40), v40, 0xCuLL);
    float32x4_t v42 = vmulq_f32(v82, v41);
    v41.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0];
    float32x4_t v43 = vsubq_f32(v85, v81);
    float32x4_t v44 = vsubq_f32(v88, v85);
    int8x16_t v45 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL), vnegq_f32(v43)), v44, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v43, (int32x4_t)v43), (int8x16_t)v43, 0xCuLL));
    float32x4_t v46 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v45, (int32x4_t)v45), v45, 0xCuLL);
    float32x4_t v47 = vmulq_f32(v81, v46);
    v46.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0];
    float32x4_t v48 = vsubq_f32(v86, v85);
    float32x4_t v49 = vsubq_f32(v87, v86);
    int8x16_t v50 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v49, (int32x4_t)v49), (int8x16_t)v49, 0xCuLL), vnegq_f32(v48)), v49, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v48, (int32x4_t)v48), (int8x16_t)v48, 0xCuLL));
    float32x4_t v51 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v50, (int32x4_t)v50), v50, 0xCuLL);
    float32x4_t v52 = vmulq_f32(v85, v51);
    v51.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).f32[0];
    float32x4_t v53 = vsubq_f32(v82, v86);
    float32x4_t v54 = vsubq_f32(v83, v82);
    int8x16_t v55 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v54, (int32x4_t)v54), (int8x16_t)v54, 0xCuLL), vnegq_f32(v53)), v54, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL));
    float32x4_t v56 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v55, (int32x4_t)v55), v55, 0xCuLL);
    float32x4_t v57 = vmulq_f32(v86, v56);
    v56.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 2), vaddq_f32(v57, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 1))).f32[0];
    float32x4_t v75 = v41;
    float32x4_t v76 = v46;
    float32x4_t v77 = v51;
    float32x4_t v78 = v56;
    float32x4_t v58 = vsubq_f32(v84, v83);
    float32x4_t v59 = vsubq_f32(v88, v84);
    int8x16_t v60 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v59, (int32x4_t)v59), (int8x16_t)v59, 0xCuLL), vnegq_f32(v58)), v59, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v58, (int32x4_t)v58), (int8x16_t)v58, 0xCuLL));
    float32x4_t v32 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v60, (int32x4_t)v60), v60, 0xCuLL);
    float32x4_t v61 = vmulq_f32(v83, v32);
    v32.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 2), vaddq_f32(v61, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61.f32, 1))).f32[0];
    float32x4_t v62 = vsubq_f32(v85, v82);
    float32x4_t v63 = vsubq_f32(v81, v85);
    int8x16_t v64 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v63, (int32x4_t)v63), (int8x16_t)v63, 0xCuLL), vnegq_f32(v62)), v63, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v62, (int32x4_t)v62), (int8x16_t)v62, 0xCuLL));
    float32x4_t v36 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v64, (int32x4_t)v64), v64, 0xCuLL);
    float32x4_t v37 = vmulq_f32(v82, v36);
  }
  else
  {
    float32x4_t v8 = vsubq_f32(v81, v84);
    float32x4_t v9 = vsubq_f32(v82, v81);
    int8x16_t v10 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL), vnegq_f32(v8)), v9, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL));
    float32x4_t v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), v10, 0xCuLL);
    float32x4_t v12 = vmulq_f32(v84, v11);
    v11.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0];
    float32x4_t v13 = vsubq_f32(v85, v88);
    float32x4_t v14 = vsubq_f32(v81, v85);
    int8x16_t v15 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL), vnegq_f32(v13)), v14, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v13, (int32x4_t)v13), (int8x16_t)v13, 0xCuLL));
    float32x4_t v16 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), v15, 0xCuLL);
    float32x4_t v17 = vmulq_f32(v88, v16);
    v16.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0];
    float32x4_t v18 = vsubq_f32(v86, v87);
    float32x4_t v19 = vsubq_f32(v85, v86);
    int8x16_t v20 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL), vnegq_f32(v18)), v19, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL));
    float32x4_t v21 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), v20, 0xCuLL);
    float32x4_t v22 = vmulq_f32(v87, v21);
    v21.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0];
    float32x4_t v23 = vsubq_f32(v82, v83);
    float32x4_t v24 = vsubq_f32(v86, v82);
    int8x16_t v25 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), (int8x16_t)v24, 0xCuLL), vnegq_f32(v23)), v24, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL));
    float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), v25, 0xCuLL);
    float32x4_t v27 = vmulq_f32(v83, v26);
    v26.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0];
    float32x4_t v75 = v11;
    float32x4_t v76 = v16;
    float32x4_t v77 = v21;
    float32x4_t v78 = v26;
    float32x4_t v28 = vsubq_f32(v84, v88);
    float32x4_t v29 = vsubq_f32(v83, v84);
    int8x16_t v30 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), (int8x16_t)v29, 0xCuLL), vnegq_f32(v28)), v29, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), (int8x16_t)v28, 0xCuLL));
    float32x4_t v32 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), v30, 0xCuLL);
    float32x4_t v31 = vmulq_f32(v88, v32);
    v32.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1))).f32[0];
    float32x4_t v33 = vsubq_f32(v85, v81);
    float32x4_t v34 = vsubq_f32(v82, v85);
    int8x16_t v35 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34), (int8x16_t)v34, 0xCuLL), vnegq_f32(v33)), v34, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL));
    float32x4_t v36 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), v35, 0xCuLL);
    float32x4_t v37 = vmulq_f32(v81, v36);
  }
  v36.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).f32[0];
  float32x4_t v79 = v32;
  float32x4_t v80 = v36;
  uint64_t v73 = 6;
  int v74 = 6;
  uint64_t result = 1;
  if (*(void *)a3 == 1)
  {
    char v72 = 1;
    uint64_t result = re::boxVerticesIntersectPlanesForFrustumCulling((uint64_t)&v81, a3 + 32, *(void *)(a3 + 16), &v72, *(unsigned __int8 *)(a3 + 544));
    if (result && v72) {
      return re::frustumVerticesIntersectWithBox((unint64_t *)(a3 + 240), 0, &v75, 6);
    }
  }
  else if (*(void *)a3 == 2)
  {
    char v72 = 1;
    int v66 = *(unsigned __int8 *)(a3 + 544);
    int v67 = re::boxVerticesIntersectPlanesForFrustumCulling((uint64_t)&v81, a3 + 32, *(void *)(a3 + 16), &v72, v66);
    if (v67 && v72)
    {
      int v68 = re::frustumVerticesIntersectWithBox((unint64_t *)(a3 + 240), 0, &v75, 6);
      unint64_t v70 = *(void *)a3;
      char v72 = 1;
      if (v70 < 2)
      {
        re::internal::assertLog((re::internal *)6, v69, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 389, 1, v70);
        uint64_t result = _os_crash();
        __break(1u);
        return result;
      }
      int v67 = v68;
      int v66 = *(unsigned __int8 *)(a3 + 544);
    }
    else
    {
      char v72 = 1;
    }
    unsigned int v71 = re::boxVerticesIntersectPlanesForFrustumCulling((uint64_t)&v81, a3 + 144, *(void *)(a3 + 128), &v72, v66 != 0);
    if (v71)
    {
      if (v72) {
        unsigned int v71 = re::frustumVerticesIntersectWithBox((unint64_t *)(a3 + 240), 1, &v75, v73);
      }
    }
    return v67 | v71;
  }
  return result;
}

uint64_t re::transformedAABBVertices@<X0>(uint64_t a1@<X0>, float32x4_t *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  a3[6] = 0u;
  a3[7] = 0u;
  a3[4] = 0u;
  a3[5] = 0u;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  memset(v13, 0, sizeof(v13));
  uint64_t result = re::AABB::extractCorners(a1, v13, 8uLL, (__n128)0);
  uint64_t v6 = 0;
  float32x4_t v7 = *a2;
  float32x4_t v8 = a2[1];
  float32x4_t v9 = a2[2];
  float32x4_t v10 = a2[3];
  do
  {
    float32x4_t v11 = vaddq_f32(v10, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v7, COERCE_FLOAT(*(_OWORD *)&v13[v6])), v8, (float32x2_t)v13[v6].n128_u64[0], 1), v9, (float32x4_t)v13[v6], 2));
    float32x4_t v12 = vdivq_f32(v11, (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3));
    v12.i32[3] = 1.0;
    a3[v6++] = v12;
  }
  while (v6 != 8);
  return result;
}

uint64_t re::boxVerticesIntersectPlanesForFrustumCulling(uint64_t result, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  if ((int)a3 < 1)
  {
    uint64_t v13 = 0;
    uint64_t result = 1;
  }
  else
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    int v7 = 0;
    LOBYTE(result) = 1;
    do
    {
      uint64_t v8 = 0;
      int v9 = 0;
      if (v6 == 5) {
        int v10 = a5;
      }
      else {
        int v10 = 1;
      }
      do
      {
        int8x16_t v11 = (int8x16_t)vmulq_f32(*(float32x4_t *)(a2 + 16 * v6), *(float32x4_t *)(v5 + v8));
        if (vaddv_f32(vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL))) > 0.0) {
          int v12 = v10;
        }
        else {
          int v12 = 0;
        }
        v9 += v12;
        v8 += 16;
      }
      while (v8 != 128);
      uint64_t result = result & (v9 != 8);
      int v7 = v7 - v9 + 8;
      ++v6;
    }
    while (v6 != (int)a3);
    uint64_t v13 = v7;
  }
  if (*a4) {
    BOOL v14 = v13 == 8 * a3;
  }
  else {
    BOOL v14 = 1;
  }
  char v15 = !v14;
  *a4 = v15;
  return result;
}

uint64_t re::frustumVerticesIntersectWithBox(unint64_t *a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  unint64_t v4 = *a1;
  if (!*a1) {
    return 1;
  }
  if (v4 <= (int)a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 389, (int)a2, v4);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  unint64_t v5 = a1[18 * (int)a2 + 2];
  if (!v5 || !a4) {
    return 1;
  }
  uint64_t v6 = &a3[a4];
  uint64_t v7 = (uint64_t)&a1[18 * (int)a2 + 4];
  uint64_t result = 1;
  do
  {
    unint64_t v9 = v5;
    for (unint64_t i = (float32x4_t *)v7; ; ++i)
    {
      int8x16_t v11 = (int8x16_t)vmulq_f32(*a3, *i);
      if (vaddv_f32(vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL))) <= 0.0) {
        break;
      }
      if (!--v9) {
        return 0;
      }
    }
    ++a3;
  }
  while (a3 != v6);
  return result;
}

uint64_t re::buildCullingFrustum@<X0>(uint64_t result@<X0>, _DWORD *a2@<X1>, unsigned int a3@<W2>, unsigned char *a4@<X3>, uint64_t a5@<X8>, float32x4_t a6@<Q2>, float32x4_t a7@<Q4>)
{
  uint64_t v7 = a4;
  uint64_t v8 = a5;
  uint64_t v145 = *MEMORY[0x263EF8340];
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  *(void *)(a5 + 240) = 0;
  *(_DWORD *)(a5 + 248) = 0;
  *(unsigned char *)(a5 + 544) = 0;
  if (*a2)
  {
    if (a3)
    {
      uint64_t v9 = result + 16;
      int v10 = (float *)(a2 + 3);
      uint64_t v11 = a3;
      do
      {
        float32x4_t v126 = *(float32x4_t *)(v9 - 16);
        float v12 = *(float *)v9;
        float v13 = *(float *)(v9 + 4);
        a6.i32[0] = *(_DWORD *)(v9 + 8);
        float v14 = *(float *)(v9 + 12);
        a7.f32[0] = v12 + v12;
        float v15 = v13 + v13;
        float v16 = (float)(v12 + v12) * v12;
        float v17 = (float)(v13 + v13) * v13;
        float v18 = (float)(a6.f32[0] + a6.f32[0]) * a6.f32[0];
        float v19 = a7.f32[0] * v13;
        float v20 = a7.f32[0] * a6.f32[0];
        float v21 = v15 * a6.f32[0];
        float v22 = a7.f32[0] * v14;
        float v23 = v15 * v14;
        a6.f32[0] = (float)(a6.f32[0] + a6.f32[0]) * v14;
        a7.f32[0] = 1.0 - (float)(v17 + v18);
        a7.f32[1] = v19 + a6.f32[0];
        a7.f32[2] = v20 - (float)(v15 * v14);
        a6.f32[0] = v19 - a6.f32[0];
        a6.f32[1] = 1.0 - (float)(v16 + v18);
        a6.f32[2] = v22 + v21;
        simd_float4 v124 = (simd_float4)a7;
        simd_float4 v125 = (simd_float4)a6;
        float v120 = v10[1];
        re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(0, (uint64_t)a2);
        float32x4_t v24 = vmulq_f32((float32x4_t)v124, vaddq_f32(v126, vmulq_n_f32((float32x4_t)v124, v120)));
        simd_float4 v25 = v124;
        v25.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0];
        v127.columns[1] = v25;
        float v121 = *v10;
        re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(1uLL, v26);
        float32x4_t v27 = vnegq_f32((float32x4_t)v124);
        float32x4_t v28 = vmulq_f32(vaddq_f32(v126, vmulq_n_f32((float32x4_t)v124, v121)), v27);
        v27.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0];
        v127.columns[2] = (simd_float4)v27;
        v27.f32[0] = v10[2];
        simd_float4 v124 = (simd_float4)v27;
        re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(2uLL, v29);
        float32x4_t v30 = vmulq_f32((float32x4_t)v125, vaddq_f32(v126, vmulq_n_f32((float32x4_t)v125, v124.f32[0])));
        float32x4_t v31 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1)));
        simd_float4 v32 = v125;
        v32.f32[3] = -v31.f32[0];
        v127.columns[3] = v32;
        v31.f32[0] = v10[3];
        simd_float4 v124 = (simd_float4)v31;
        re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(3uLL, v33);
        float32x4_t v37 = vnegq_f32((float32x4_t)v125);
        float32x4_t v35 = vmulq_f32(vaddq_f32(v126, vmulq_n_f32((float32x4_t)v125, v124.f32[0])), v37);
        float32x4_t v36 = vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1));
        v37.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), v36).f32[0];
        float32x4_t v128 = v37;
        v127.columns[0].i64[0] = 4;
        v127.columns[0].i32[2] = 4;
        if (*v7)
        {
          v36.f32[0] = v20 + v23;
          v36.f32[1] = v21 - v22;
          v36.f32[2] = 1.0 - (float)(v16 + v17);
          v37.f32[0] = *(v10 - 1);
          simd_float4 v124 = (simd_float4)v37;
          simd_float4 v125 = (simd_float4)v36;
          re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(4uLL, v34);
          float32x4_t v38 = vmulq_f32((float32x4_t)v125, vaddq_f32(v126, vmulq_n_f32((float32x4_t)v125, v124.f32[0])));
          float32x4_t v39 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1)));
          float32x4_t v40 = (float32x4_t)v125;
          v40.f32[3] = -v39.f32[0];
          float32x4_t v129 = v40;
          v39.f32[0] = *(v10 - 2);
          simd_float4 v124 = (simd_float4)v39;
          re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(5uLL, v41);
          float32x4_t v42 = vnegq_f32((float32x4_t)v125);
          float32x4_t v43 = vmulq_f32(vaddq_f32(v126, vmulq_n_f32((float32x4_t)v125, v124.f32[0])), v42);
          v42.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v43, 2), vaddq_f32(v43, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 1))).f32[0];
          float32x4_t v130 = v42;
          v127.columns[0].i64[0] = 6;
          v127.columns[0].i32[2] = 6;
        }
        uint64_t result = re::DynamicInlineArray<re::DynamicInlineArray<re::PlaneF,6ul>,2ul>::add(v8, (uint64_t *)&v127);
        v9 += 32;
        v10 += 16;
        --v11;
      }
      while (v11);
    }
    goto LABEL_37;
  }
  if (!a3) {
    goto LABEL_37;
  }
  uint64_t v44 = 0;
  uint64_t v104 = a3;
  uint64_t v105 = a5 + 240;
  uint64_t v106 = result;
  float32x4_t v107 = a2;
  do
  {
    int8x16_t v45 = (long long *)&a2[16 * v44];
    long long v46 = v45[1];
    long long v132 = *v45;
    long long v133 = v46;
    long long v47 = v45[3];
    long long v134 = v45[2];
    long long v135 = v47;
    float v48 = *((float *)&v132 + 2);
    BYTE12(v133) = 0;
    float v49 = 1000.0;
    if (*((float *)&v132 + 2) != INFINITY) {
      float v49 = *((float *)&v132 + 2);
    }
    *((float *)&v132 + 2) = v49;
    uint64_t v110 = v44;
    int8x16_t v50 = (float32x4_t *)(result + 32 * v44);
    float32x4_t v113 = *v50;
    re::Projection::computeMatrix4x4F((re::Projection *)&v132, (uint64_t)v144);
    re::RenderCamera::computeInverseTransform(v50, (uint64_t)v143);
    unint64_t v51 = 0;
    float32x4_t v52 = (float32x4_t)v144[0];
    float32x4_t v53 = (float32x4_t)v144[1];
    float32x4_t v54 = (float32x4_t)v144[2];
    float32x4_t v55 = (float32x4_t)v144[3];
    long long v136 = v143[0];
    float32x4_t v137 = (float32x4_t)v143[1];
    float32x4_t v138 = (float32x4_t)v143[2];
    float32x4_t v139 = (float32x4_t)v143[3];
    do
    {
      v127.columns[v51 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v52, COERCE_FLOAT(*(long long *)((char *)&v136 + v51))), v53, *(float32x2_t *)((char *)&v136 + v51), 1), v54, *(float32x4_t *)((char *)&v136 + v51), 2), v55, *(float32x4_t *)((char *)&v136 + v51), 3);
      v51 += 16;
    }
    while (v51 != 64);
    simd_float4x4 v146 = __invert_f4(v127);
    float32x4_t v118 = (float32x4_t)v146.columns[1];
    float32x4_t v122 = (float32x4_t)v146.columns[0];
    float32x4_t v114 = (float32x4_t)v146.columns[3];
    float32x4_t v116 = (float32x4_t)v146.columns[2];
    unint64_t v57 = 0;
    LODWORD(v58) = 0;
    char v59 = 0;
    uint64_t v60 = 0;
    v127.columns[0].i64[0] = 0;
    v127.columns[0].i32[2] = 0;
    *(void *)&long long v136 = 1065353216;
    do
    {
      char v61 = 0;
      uint64_t v62 = 0;
      char v111 = v59;
      v146.columns[0].i32[0] = *((_DWORD *)&v136 + v60);
      *(void *)&v144[0] = 0x3F800000BF800000;
      BOOL v63 = v146.columns[0].f32[0] == 0.0 && v48 == INFINITY;
      simd_float4 v124 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)v146.columns[0].f32, 0);
      do
      {
        char v64 = 0;
        char v65 = v61;
        int v66 = (const float *)v144 + v62;
        v146.columns[0] = (simd_float4)vld1q_dup_f32(v66);
        simd_float4 v125 = v146.columns[0];
        *(void *)&v143[0] = 0x3F800000BF800000;
        int v67 = (float32x4_t *)(&v124 + (int)v58);
        uint64_t v58 = (int)v58;
        int v68 = (__int32 *)v143;
        uint64_t v69 = 1;
        do
        {
          char v70 = v64;
          if (v63)
          {
            if (v57 <= v58 - 4)
            {
              re::internal::assertLog((re::internal *)6, v56, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 381, v58 - 4, v57);
              _os_crash();
              __break(1u);
LABEL_39:
              re::internal::assertLog((re::internal *)6, v56, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 381, 0, 0);
              _os_crash();
              __break(1u);
LABEL_40:
              re::internal::assertLog((re::internal *)6, v56, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 381, 1, 1);
              _os_crash();
              __break(1u);
LABEL_41:
              re::internal::assertLog((re::internal *)6, v56, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 381, 3, v57);
              _os_crash();
              __break(1u);
              goto LABEL_42;
            }
            v146.columns[0].i64[0] = v67->i64[0];
            v146.columns[0].i32[2] = v67->i32[2];
            float32x4_t v126 = (float32x4_t)v146.columns[0];
            re::DynamicInlineArray<re::Vector4<float>,8ul>::ensureCapacity(v57, v56);
            v146.columns[0] = (simd_float4)vsubq_f32(v126, v113);
            v146.columns[0].i32[3] = 0;
          }
          else
          {
            v146.columns[0].i32[0] = *v68;
            float32x4_t v126 = (float32x4_t)v146.columns[0];
            re::DynamicInlineArray<re::Vector4<float>,8ul>::ensureCapacity(v57, v56);
            v146.columns[0] = (simd_float4)vaddq_f32(v114, vmlaq_f32(vmlaq_f32(vmulq_n_f32(v122, v126.f32[0]), (float32x4_t)v125, v118), (float32x4_t)v124, v116));
            v146.columns[0] = (simd_float4)vdivq_f32((float32x4_t)v146.columns[0], (float32x4_t)vdupq_laneq_s32((int32x4_t)v146.columns[0], 3));
            v146.columns[0].i32[3] = 1.0;
          }
          v127.columns[v57 + 1] = v146.columns[0];
          uint64_t v71 = v127.columns[0].i64[0];
          unint64_t v57 = ++v127.columns[0].i64[0];
          ++v127.columns[0].i32[2];
          ++v58;
          int v68 = (__int32 *)v143 + v69;
          ++v67;
          char v64 = 1;
          uint64_t v69 = 2;
        }
        while ((v70 & 1) == 0);
        char v61 = 1;
        uint64_t v62 = 1;
      }
      while ((v65 & 1) == 0);
      char v59 = 1;
      uint64_t v60 = 1;
    }
    while ((v111 & 1) == 0);
    if (!v57) {
      goto LABEL_39;
    }
    uint64_t v8 = a5;
    uint64_t v7 = a4;
    if (!v71) {
      goto LABEL_40;
    }
    if (v57 <= 3) {
      goto LABEL_41;
    }
    simd_float4 v124 = v127.columns[2];
    simd_float4 v125 = (simd_float4)v128;
    float32x4_t v126 = (float32x4_t)v127.columns[1];
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(0, v56);
    float32x4_t v72 = vsubq_f32((float32x4_t)v124, v126);
    float32x4_t v117 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v72, (int32x4_t)v72), (int8x16_t)v72, 0xCuLL);
    float32x4_t v119 = v72;
    float32x4_t v115 = vsubq_f32((float32x4_t)v125, (float32x4_t)v124);
    float32x4_t v112 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v115, (int32x4_t)v115), (int8x16_t)v115, 0xCuLL);
    int8x16_t v73 = (int8x16_t)vmlaq_f32(vmulq_f32(v112, vnegq_f32(v72)), v115, v117);
    float32x4_t v74 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v73, (int32x4_t)v73), v73, 0xCuLL);
    float32x4_t v75 = vmulq_f32(v126, v74);
    v74.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 2), vaddq_f32(v75, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v75.f32, 1))).f32[0];
    float32x4_t v137 = v74;
    float32x4_t v123 = (float32x4_t)v127.columns[3];
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(1uLL, v76);
    float32x4_t v77 = vsubq_f32(v123, v113);
    float32x4_t v78 = vsubq_f32(v126, v123);
    int8x16_t v79 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v78, (int32x4_t)v78), (int8x16_t)v78, 0xCuLL), vnegq_f32(v77)), v78, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v77, (int32x4_t)v77), (int8x16_t)v77, 0xCuLL));
    float32x4_t v80 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v79, (int32x4_t)v79), v79, 0xCuLL);
    float32x4_t v81 = vmulq_f32(v113, v80);
    v80.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 2), vaddq_f32(v81, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 1))).f32[0];
    float32x4_t v138 = v80;
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(2uLL, v82);
    float32x4_t v83 = vsubq_f32((float32x4_t)v124, v113);
    int8x16_t v84 = (int8x16_t)vmlaq_f32(vmulq_f32(v112, vnegq_f32(v83)), v115, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v83, (int32x4_t)v83), (int8x16_t)v83, 0xCuLL));
    float32x4_t v85 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v84, (int32x4_t)v84), v84, 0xCuLL);
    float32x4_t v86 = vmulq_f32(v113, v85);
    v85.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v86, 2), vaddq_f32(v86, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v86.f32, 1))).f32[0];
    float32x4_t v139 = v85;
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(3uLL, v87);
    float32x4_t v88 = vsubq_f32((float32x4_t)v125, v113);
    float32x4_t v89 = vsubq_f32(v123, (float32x4_t)v125);
    int8x16_t v90 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v89, (int32x4_t)v89), (int8x16_t)v89, 0xCuLL), vnegq_f32(v88)), v89, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v88, (int32x4_t)v88), (int8x16_t)v88, 0xCuLL));
    float32x4_t v91 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v90, (int32x4_t)v90), v90, 0xCuLL);
    float32x4_t v92 = vmulq_f32(v113, v91);
    v91.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 2), vaddq_f32(v92, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v92.f32, 1))).f32[0];
    float32x4_t v140 = v91;
    re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(4uLL, v93);
    float32x4_t v95 = vsubq_f32(v126, v113);
    int8x16_t v96 = (int8x16_t)vmlaq_f32(vmulq_f32(v117, vnegq_f32(v95)), v119, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v95, (int32x4_t)v95), (int8x16_t)v95, 0xCuLL));
    float32x4_t v97 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v96, (int32x4_t)v96), v96, 0xCuLL);
    float32x4_t v98 = vmulq_f32(v113, v97);
    v97.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 2), vaddq_f32(v98, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v98.f32, 1))).f32[0];
    float32x4_t v141 = v97;
    *(void *)&long long v136 = 5;
    DWORD2(v136) = 5;
    if (*a4 && v48 != INFINITY)
    {
      if (v57 > 7)
      {
        simd_float4 v124 = (simd_float4)v130;
        simd_float4 v125 = (simd_float4)v131;
        float32x4_t v126 = v129;
        re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(5uLL, v94);
        float32x4_t v99 = vsubq_f32((float32x4_t)v124, (float32x4_t)v125);
        float32x4_t v100 = vsubq_f32(v126, (float32x4_t)v124);
        int8x16_t v101 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v100, (int32x4_t)v100), (int8x16_t)v100, 0xCuLL), vnegq_f32(v99)), v100, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v99, (int32x4_t)v99), (int8x16_t)v99, 0xCuLL));
        float32x4_t v102 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v101, (int32x4_t)v101), v101, 0xCuLL);
        float32x4_t v103 = vmulq_f32((float32x4_t)v125, v102);
        v102.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v103, 2), vaddq_f32(v103, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v103.f32, 1))).f32[0];
        float32x4_t v142 = v102;
        *(void *)&long long v136 = 6;
        DWORD2(v136) = 6;
        goto LABEL_34;
      }
LABEL_42:
      re::internal::assertLog((re::internal *)6, v94, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 381, 7, v57);
      _os_crash();
      __break(1u);
    }
LABEL_34:
    re::DynamicInlineArray<re::DynamicInlineArray<re::PlaneF,6ul>,2ul>::add(a5, (uint64_t *)&v136);
    if (a4[1]) {
      re::DynamicInlineArray<re::DynamicInlineArray<re::Vector4<float>,8ul>,2ul>::add(v105, (uint64_t *)&v127);
    }
    uint64_t v44 = v110 + 1;
    uint64_t result = v106;
    a2 = v107;
  }
  while (v110 + 1 != v104);
LABEL_37:
  *(unsigned char *)(v8 + 544) = *v7;
  return result;
}

uint64_t re::DynamicInlineArray<re::DynamicInlineArray<re::PlaneF,6ul>,2ul>::add(uint64_t a1, uint64_t *a2)
{
  if (*(void *)a1 >= 2uLL)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Capacity limit reached. DynamicInlineArray<T,N> cannot be resized.", "false", "ensureCapacity", 277);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v3 = a1 + 112 * *(void *)a1;
    *(void *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 24) = 0;
    uint64_t v4 = *a2;
    uint64_t result = (uint64_t)memcpy((void *)(v3 + 32), a2 + 2, 16 * *a2);
    *(void *)(v3 + 16) = v4;
    ++*(void *)a1;
    ++*(_DWORD *)(a1 + 8);
  }
  return result;
}

uint64_t re::DynamicInlineArray<re::DynamicInlineArray<re::Vector4<float>,8ul>,2ul>::add(uint64_t a1, uint64_t *a2)
{
  if (*(void *)a1 >= 2uLL)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Capacity limit reached. DynamicInlineArray<T,N> cannot be resized.", "false", "ensureCapacity", 277);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v3 = a1 + 144 * *(void *)a1;
    *(void *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 24) = 0;
    uint64_t v4 = *a2;
    uint64_t result = (uint64_t)memcpy((void *)(v3 + 32), a2 + 2, 16 * *a2);
    *(void *)(v3 + 16) = v4;
    ++*(void *)a1;
    ++*(_DWORD *)(a1 + 8);
  }
  return result;
}

uint64_t re::isBoundingBoxInsidePlanes(uint64_t a1, uint64_t a2, float32x4_t *a3)
{
  if (*(void *)(a2 + 8))
  {
    re::transformedAABBVertices(a1, a3, v10);
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      unint64_t v5 = *(float32x4_t **)a2;
      uint64_t v6 = *(void *)a2 + 16 * v4;
      do
      {
        uint64_t v7 = 0;
        while (1)
        {
          int8x16_t v8 = (int8x16_t)vmulq_f32(*v5, (float32x4_t)v10[v7]);
          if (vaddv_f32(vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL))) <= 0.0) {
            break;
          }
          if (++v7 == 8) {
            return 0;
          }
        }
        ++v5;
      }
      while (v5 != (float32x4_t *)v6);
    }
  }
  return 1;
}

uint64_t re::isBoundingBoxInsidePlanesArray(uint64_t a1, float32x4_t *a2, float32x4_t *a3)
{
  if (a2->i64[0] == 1)
  {
    uint64_t v10 = a2[1].i64[0];
    *(void *)&v17[0] = a2 + 2;
    *((void *)&v17[0] + 1) = v10;
    return re::isBoundingBoxInsidePlanes(a1, (uint64_t)v17, a3);
  }
  if (a2->i64[0] != 2) {
    return 0;
  }
  if (!a2[1].i64[0] || !a2[8].i64[0]) {
    return 1;
  }
  re::transformedAABBVertices(a1, a3, v17);
  if (a2->i64[0])
  {
    uint64_t v5 = a2[1].i64[0];
    if (v5)
    {
      uint64_t v6 = a2 + 2;
      uint64_t v7 = (uint64_t)&a2[v5 + 2];
LABEL_8:
      for (uint64_t i = 0; i != 8; ++i)
      {
        int8x16_t v9 = (int8x16_t)vmulq_f32(*v6, (float32x4_t)v17[i]);
        if (vaddv_f32(vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL))) <= 0.0)
        {
          if (++v6 != (float32x4_t *)v7) {
            goto LABEL_8;
          }
          return 1;
        }
      }
      if (a2->i64[0] <= 1uLL) {
        goto LABEL_27;
      }
      uint64_t v12 = a2[8].i64[0];
      if (v12)
      {
        float v13 = a2 + 9;
        uint64_t v14 = (uint64_t)&a2[v12 + 9];
        uint64_t result = 1;
        do
        {
          uint64_t v15 = 0;
          while (1)
          {
            int8x16_t v16 = (int8x16_t)vmulq_f32(*v13, (float32x4_t)v17[v15]);
            if (vaddv_f32(vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL))) <= 0.0) {
              break;
            }
            if (++v15 == 8) {
              return 0;
            }
          }
          ++v13;
        }
        while (v13 != (float32x4_t *)v14);
        return result;
      }
    }
    return 1;
  }
  re::internal::assertLog((re::internal *)6, v4, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 389, 0, 0);
  _os_crash();
  __break(1u);
LABEL_27:
  re::internal::assertLog((re::internal *)6, v4, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 389, 1, 1);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::isBoundingSphereIntersectingFrustumPlanes(float32x4_t *a1, void *a2, double a3, double a4, float32x4_t a5)
{
  if (!*a2) {
    return 1;
  }
  uint64_t v5 = a2 + 2;
  float32x4_t v6 = *a1;
  LODWORD(v7) = HIDWORD(*(unsigned long long *)a1);
  do
  {
    a5.i64[0] = *v5;
    a5.i32[2] = *((_DWORD *)v5 + 2);
    float32x4_t v8 = vmulq_f32(a5, a5);
    float32x4_t v9 = vmulq_f32(v6, a5);
    a5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1)));
    a5.f32[0] = (float)(*((float *)v5 + 3) + a5.f32[0])
              / sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0]);
    BOOL result = a5.f32[0] <= v7;
    v5 += 2;
  }
  while (a5.f32[0] <= v7 && v5 != &a2[2 * *a2 + 2]);
  return result;
}

uint64_t re::approxFrustumIntersectFrustum(float32x4_t *a1, float32x4_t *a2)
{
  if (!a1->i64[0] || !a2->i64[0]) {
    return 1;
  }
  uint64_t v2 = a1 + 1;
  do
  {
    uint64_t v3 = 0;
    while (1)
    {
      int8x16_t v4 = (int8x16_t)vmulq_f32(*v2, a2[v3 + 7]);
      if (vaddv_f32(vadd_f32(*(float32x2_t *)v4.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v4, v4, 8uLL))) <= 0.0) {
        break;
      }
      if (++v3 == 8) {
        return 0;
      }
    }
    ++v2;
  }
  while (v2 != &a1[a1->i64[0] + 1]);
  uint64_t v5 = a1 + 7;
  float32x4_t v6 = a2 + 1;
  do
  {
    uint64_t v7 = 0;
    while (1)
    {
      int8x16_t v8 = (int8x16_t)vmulq_f32(*v6, v5[v7]);
      if (vaddv_f32(vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL))) <= 0.0) {
        break;
      }
      uint64_t result = 0;
      if (++v7 == 8) {
        return result;
      }
    }
    ++v6;
    uint64_t result = 1;
  }
  while (v6 != &a2[a2->i64[0] + 1]);
  return result;
}

_DWORD *re::setResolvedTechniqueStateOverride(_DWORD *result, re::MaterialParameterTableLayers *this)
{
  unsigned int v2 = result[36];
  if (v2 != -1)
  {
    uint64_t v3 = result;
    uint64_t result = (_DWORD *)re::MaterialParameterTableLayers::getTechniqueAtIndex(this, v2);
    if (result)
    {
      if (*(unsigned char *)(*(void *)result + 2846))
      {
        *((unsigned char *)v3 + 176) = 1;
        int v4 = v3[45];
        if ((v4 & 0x1000000) == 0) {
          *((unsigned char *)v3 + 177) |= 4u;
        }
        if ((v4 & 0x800000) == 0) {
          *((unsigned char *)v3 + 177) |= 1u;
        }
      }
    }
  }
  return result;
}

double re::bucketMeshPart(uint64_t a1, int8x16_t *a2, uint64_t a3, uint64_t a4, _WORD *a5)
{
  uint64_t v97 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a3 + 24);
  long long v76 = 0u;
  long long v77 = 0u;
  int v78 = 0;
  uint64_t v79 = 0x7FFFFFFFLL;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,false,false>::init((uint64_t)&v76, v8, 10);
  if (re::s_debugSettingsManager)
  {
    LOBYTE(v84) = 0;
    *(void *)&long long v92 = 0x38C0AA772CC1B274;
    *((void *)&v92 + 1) = "overrides:usepbrlite";
    int v9 = re::DebugSettingsManager::getWithErrorCode<BOOL>(re::s_debugSettingsManager, &v92, &v84);
    re::StringID::destroyString((re::StringID *)&v92);
    char v10 = v84;
    if (v9) {
      char v10 = 0;
    }
    char v73 = v10;
  }
  else
  {
    char v73 = 0;
  }
  uint64_t v11 = 0;
  int8x16_t v81 = vextq_s8(a2[3], a2[3], 8uLL);
  uint64_t v12 = a2[2].i64[1] + 224;
  uint64_t v82 = a2[4].i64[1];
  uint64_t v83 = v12;
  while (1)
  {
    uint64_t v13 = v81.i64[v11];
    if (v13)
    {
      *(void *)&long long v92 = a2[9].i64[0];
      if (re::HashTable<unsigned long,re::HashTable<unsigned long,unsigned long,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::tryGet(v13 + 1032, (uint64_t *)&v92))
      {
        break;
      }
    }
    if (++v11 == 4)
    {
      int v69 = 1;
      goto LABEL_12;
    }
  }
  int v69 = 0;
LABEL_12:
  uint64_t v14 = 0;
  do
  {
    uint64_t v71 = v14;
    uint64_t v15 = (re::MaterialParameterTable *)v81.i64[v14];
    if (v15)
    {
      int8x16_t v16 = (unsigned int *)re::MaterialParameterTable::passTechniqueHashTable(v15, a2[9].i64[0], v69);
      uint64_t v17 = v16[8];
      if (v17)
      {
        uint64_t v18 = 0;
        float v19 = (int *)*((void *)v16 + 2);
        while (1)
        {
          int v20 = *v19;
          v19 += 6;
          if (v20 < 0) {
            break;
          }
          if (v17 == ++v18)
          {
            LODWORD(v18) = v16[8];
            break;
          }
        }
      }
      else
      {
        LODWORD(v18) = 0;
      }
      if (v17 != v18)
      {
        uint64_t v21 = v18;
        uint64_t v22 = *((void *)v16 + 2);
        unsigned int v23 = v16[8];
        unsigned int v74 = v23;
        float32x4_t v75 = v16;
        while (1)
        {
          uint64_t v24 = v22 + 24 * v21;
          unint64_t v27 = *(void *)(v24 + 8);
          uint64_t v26 = (uint64_t *)(v24 + 8);
          unint64_t v25 = v27;
          if (DWORD2(v77))
          {
            uint64_t v28 = *(unsigned int *)(*((void *)&v76 + 1) + 4 * (v25 % DWORD2(v77)));
            if (v28 != 0x7FFFFFFF)
            {
              while (*(void *)(v77 + 16 * v28 + 8) != v25)
              {
                uint64_t v28 = *(_DWORD *)(v77 + 16 * v28) & 0x7FFFFFFF;
                if (v28 == 0x7FFFFFFF) {
                  goto LABEL_28;
                }
              }
              goto LABEL_49;
            }
          }
LABEL_28:
          uint64_t v29 = re::HashTable<unsigned long,re::MeshPassInfo,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a4, v26);
          if (!v29)
          {
            uint64_t v40 = *(void *)(a3 + 24);
            long long v92 = 0uLL;
            LODWORD(v93) = 1;
            long long v94 = 0uLL;
            *((void *)&v93 + 1) = 0;
            LODWORD(v95) = 0;
            re::BucketArray<re::MeshPartDrawContext,128ul>::init((uint64_t)&v92, v40, 1uLL);
            DWORD2(v95) = 0;
            uint64_t v29 = re::HashTable<unsigned long,re::MeshPassInfo,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add(a4, (unint64_t *)v26, (uint64_t)&v92);
            re::BucketArray<re::MeshPartDrawContext,128ul>::deinit((uint64_t)&v92);
            if ((void)v92)
            {
              if ((v93 & 1) == 0) {
                (*(void (**)(void, void))(*(void *)v92 + 40))(v92, v94);
              }
            }
          }
          *(_WORD *)(a1 + 148) = 0;
          *(unsigned char *)(a1 + 150) = 0;
          uint64_t v30 = re::HashTable<unsigned long,re::Pair<re::FixedArray<unsigned int>,signed char,true>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::tryGet(a2[2].i64[1] + 24, v26 + 1);
          if (!v30) {
            break;
          }
          uint64_t v31 = v30;
          int v32 = *(char *)(v30 + 24);
          if ((v32 & 0x80000000) == 0)
          {
            uint64_t v33 = a4;
            unsigned int v34 = *(_DWORD *)(a1 + 180);
            if ((v34 & 0x400) != 0) {
              char v35 = 0;
            }
            else {
              char v35 = -2;
            }
            if ((v34 & 0x100) != 0) {
              char v36 = ((v34 >> 9) | 0xFE) + v35;
            }
            else {
              char v36 = (v34 >> 9) & 3;
            }
            if ((*(_DWORD *)(a1 + 180) & 0x700) == 0x100) {
              char v36 = v73;
            }
            int v37 = (char)(v36 + v32);
            unint64_t v38 = *(void *)(v30 + 8);
            if (v37 >= (char)(v38 - 1)) {
              int v37 = (char)(v38 - 1);
            }
            unint64_t v39 = v37 & ~(v37 >> 31);
            if (v38 <= v39)
            {
              uint64_t v80 = 0;
              long long v95 = 0u;
              long long v96 = 0u;
              long long v93 = 0u;
              long long v94 = 0u;
              long long v92 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v84 = 136315906;
              float32x4_t v85 = "operator[]";
              __int16 v86 = 1024;
              int v87 = 476;
              __int16 v88 = 2048;
              unint64_t v89 = v39;
              __int16 v90 = 2048;
              unint64_t v91 = v38;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            *(_DWORD *)(a1 + 144) = *(_DWORD *)(*(void *)(v30 + 16) + 4 * v39);
            re::setResolvedTechniqueStateOverride((_DWORD *)a1, (re::MaterialParameterTableLayers *)a2);
            a4 = v33;
            goto LABEL_47;
          }
          unint64_t v54 = *(void *)(v30 + 8);
          if (v54 >= 2)
          {
            __int16 v55 = (*a5)++;
            *(_WORD *)(a1 + 148) = v55;
LABEL_61:
            unint64_t v56 = 0;
            do
            {
              *(_DWORD *)(a1 + 144) = *(_DWORD *)(*(void *)(v31 + 16) + 4 * v56);
              *(unsigned char *)(a1 + 150) = v56;
              re::setResolvedTechniqueStateOverride((_DWORD *)a1, (re::MaterialParameterTableLayers *)a2);
              unint64_t v57 = (_OWORD *)re::BucketArray<re::MeshPartDrawContext,128ul>::addUninitialized(v29);
              long long v58 = *(_OWORD *)(a1 + 16);
              *unint64_t v57 = *(_OWORD *)a1;
              v57[1] = v58;
              long long v59 = *(_OWORD *)(a1 + 80);
              long long v61 = *(_OWORD *)(a1 + 32);
              long long v60 = *(_OWORD *)(a1 + 48);
              void v57[4] = *(_OWORD *)(a1 + 64);
              v57[5] = v59;
              v57[2] = v61;
              v57[3] = v60;
              long long v62 = *(_OWORD *)(a1 + 144);
              long long v64 = *(_OWORD *)(a1 + 96);
              long long v63 = *(_OWORD *)(a1 + 112);
              v57[8] = *(_OWORD *)(a1 + 128);
              v57[9] = v62;
              v57[6] = v64;
              v57[7] = v63;
              long long v65 = *(_OWORD *)(a1 + 208);
              long long v67 = *(_OWORD *)(a1 + 160);
              long long v66 = *(_OWORD *)(a1 + 176);
              v57[12] = *(_OWORD *)(a1 + 192);
              v57[13] = v65;
              v57[10] = v67;
              v57[11] = v66;
              ++v56;
            }
            while (v56 < *(void *)(v31 + 8));
            goto LABEL_48;
          }
          if (v54) {
            goto LABEL_61;
          }
LABEL_48:
          re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add((uint64_t)&v76, (unint64_t *)v26);
          LODWORD(v17) = v74;
          unsigned int v23 = v75[8];
          uint64_t v22 = *((void *)v75 + 2);
LABEL_49:
          if (v23 <= (int)v18 + 1) {
            unsigned int v52 = v18 + 1;
          }
          else {
            unsigned int v52 = v23;
          }
          while (1)
          {
            uint64_t v21 = (v18 + 1);
            if (v52 - 1 == v18) {
              break;
            }
            LODWORD(v18) = v18 + 1;
            unsigned int v53 = v21;
            if ((*(_DWORD *)(v22 + 24 * v21) & 0x80000000) != 0) {
              goto LABEL_56;
            }
          }
          unsigned int v53 = v52;
LABEL_56:
          LODWORD(v18) = v53;
          if (v17 == v53) {
            goto LABEL_21;
          }
        }
        *(_DWORD *)(a1 + 144) = -1;
LABEL_47:
        uint64_t v41 = (_OWORD *)re::BucketArray<re::MeshPartDrawContext,128ul>::addUninitialized(v29);
        long long v42 = *(_OWORD *)(a1 + 16);
        *uint64_t v41 = *(_OWORD *)a1;
        v41[1] = v42;
        long long v43 = *(_OWORD *)(a1 + 80);
        long long v45 = *(_OWORD *)(a1 + 32);
        long long v44 = *(_OWORD *)(a1 + 48);
        v41[4] = *(_OWORD *)(a1 + 64);
        v41[5] = v43;
        void v41[2] = v45;
        v41[3] = v44;
        long long v46 = *(_OWORD *)(a1 + 144);
        long long v48 = *(_OWORD *)(a1 + 96);
        long long v47 = *(_OWORD *)(a1 + 112);
        v41[8] = *(_OWORD *)(a1 + 128);
        v41[9] = v46;
        v41[6] = v48;
        v41[7] = v47;
        long long v49 = *(_OWORD *)(a1 + 208);
        long long v51 = *(_OWORD *)(a1 + 160);
        long long v50 = *(_OWORD *)(a1 + 176);
        v41[12] = *(_OWORD *)(a1 + 192);
        v41[13] = v49;
        v41[10] = v51;
        v41[11] = v50;
        goto LABEL_48;
      }
    }
LABEL_21:
    uint64_t v14 = v71 + 1;
  }
  while (v71 != 3);
  return re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::PrecalculatedHash,re::EqualTo<unsigned long long>,false,false>::deinit((uint64_t *)&v76);
}

unint64_t re::DynamicInlineArray<re::PlaneF,6ul>::ensureCapacity(unint64_t result, uint64_t a2)
{
  if (result > 5)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Capacity limit reached. DynamicInlineArray<T,N> cannot be resized.", "false", "ensureCapacity", 277, v2, v3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

unint64_t re::DynamicInlineArray<re::Vector4<float>,8ul>::ensureCapacity(unint64_t result, uint64_t a2)
{
  if (result > 7)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Capacity limit reached. DynamicInlineArray<T,N> cannot be resized.", "false", "ensureCapacity", 277, v2, v3);
    uint64_t result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::DrawCallSortKey<3ul,unsigned long long>::appendUInt8(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x18)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 1, 24);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(unsigned char *)(result - v3 + 23) = a2;
    ++*a3;
  }
  return result;
}

uint64_t re::DrawCallSortKey<3ul,unsigned long long>::appendUInt16(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x17)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 2, 24);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_WORD *)(result - v3 + 22) = a2;
    *a3 += 2;
  }
  return result;
}

uint64_t re::DrawCallSortKey<3ul,unsigned long long>::appendUInt64(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x11)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 8, 24);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(void *)(result - v3 + 16) = a2;
    *a3 += 8;
  }
  return result;
}

uint64_t re::DrawCallSortKey<3ul,unsigned long long>::appendBytes(uint64_t a1, uint64_t a2, uint64_t a3, size_t __n, unsigned char *a5)
{
  uint64_t v9 = a2;
  uint64_t v5 = *a5;
  if (v5 + __n >= 0x19)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v5 + __n, 24);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    char v7 = __n;
    uint64_t result = (uint64_t)memcpy((void *)(a1 + (24 - __n - v5)), (char *)&v9 + a3, __n);
    *a5 += v7;
  }
  return result;
}

uint64_t re::DrawCallSortKey<4ul,unsigned long long>::appendFloat(uint64_t result, unsigned char *a2, float a3)
{
  uint64_t v3 = *a2;
  if (v3 >= 0x1D)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 4, 32);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_DWORD *)(result - v3 + 28) = ((SLODWORD(a3) >> 31) | 0x80000000) ^ LODWORD(a3);
    *a2 += 4;
  }
  return result;
}

uint64_t re::DrawCallSortKey<4ul,unsigned long long>::appendInt8(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x20)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 1, 32);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(unsigned char *)(result - v3 + 31) = a2 ^ 0x80;
    ++*a3;
  }
  return result;
}

uint64_t re::DrawCallSortKey<4ul,unsigned long long>::appendInt32(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x1D)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 4, 32);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_DWORD *)(result - v3 + 28) = a2 ^ 0x80000000;
    *a3 += 4;
  }
  return result;
}

uint64_t re::DrawCallSortKey<4ul,unsigned long long>::appendUInt8(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x20)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 1, 32);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(unsigned char *)(result - v3 + 31) = a2;
    ++*a3;
  }
  return result;
}

uint64_t re::DrawCallSortKey<4ul,unsigned long long>::appendUInt16(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x1F)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 2, 32);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_WORD *)(result - v3 + 30) = a2;
    *a3 += 2;
  }
  return result;
}

uint64_t re::DrawCallSortKey<4ul,unsigned long long>::appendUInt32(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x1D)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 4, 32);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_DWORD *)(result - v3 + 28) = a2;
    *a3 += 4;
  }
  return result;
}

uint64_t re::DrawCallSortKey<5ul,unsigned long long>::appendFloat(uint64_t result, unsigned char *a2, float a3)
{
  uint64_t v3 = *a2;
  if (v3 >= 0x25)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 4, 40);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_DWORD *)(result - v3 + 36) = ((SLODWORD(a3) >> 31) | 0x80000000) ^ LODWORD(a3);
    *a2 += 4;
  }
  return result;
}

uint64_t re::DrawCallSortKey<5ul,unsigned long long>::appendInt8(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x28)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 1, 40);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(unsigned char *)(result - v3 + 39) = a2 ^ 0x80;
    ++*a3;
  }
  return result;
}

uint64_t re::DrawCallSortKey<5ul,unsigned long long>::appendInt32(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x25)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 4, 40);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_DWORD *)(result - v3 + 36) = a2 ^ 0x80000000;
    *a3 += 4;
  }
  return result;
}

uint64_t re::DrawCallSortKey<5ul,unsigned long long>::appendUInt8(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x28)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 1, 40);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(unsigned char *)(result - v3 + 39) = a2;
    ++*a3;
  }
  return result;
}

uint64_t re::DrawCallSortKey<5ul,unsigned long long>::appendUInt16(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x27)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 2, 40);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_WORD *)(result - v3 + 38) = a2;
    *a3 += 2;
  }
  return result;
}

uint64_t re::DrawCallSortKey<5ul,unsigned long long>::appendUInt32(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a3;
  if (v3 >= 0x25)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) SortKey trying to use %zu bytes when it only has capacity for %zu.", "(size_t)inoutByteOffset + byteCount <= WordCount * sizeof(WordType)", "appendBytesToKey", 19, v3 + 4, 40);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_DWORD *)(result - v3 + 36) = a2;
    *a3 += 4;
  }
  return result;
}

uint64_t re::OpenSubdivViewIndependentComputeStep::init(uint64_t this, re::RenderManager *a2)
{
  if (!*(unsigned char *)(this + 8))
  {
    uint64_t v3 = this;
    *(unsigned char *)(this + 8) = 1;
    *(void *)(this + 16) = *((void *)a2 + 4);
    if (*((unsigned char *)a2 + 262))
    {
      v9[0] = 0;
      uint64_t v18 = 0;
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      uint64_t v14 = 0;
      int v17 = 0;
      char v19 = 0;
      char v20 = 0;
      uint64_t v21 = 0;
      char v22 = 0;
      ComputePipelineState = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)v9);
      NS::SharedPtr<MTL::Texture>::operator=((void **)(v3 + 24), ComputePipelineState);
      re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v14);
      uint64_t v5 = (_anonymous_namespace_ *)v12;
      if ((void)v12)
      {
        if (BYTE8(v12)) {
          uint64_t v5 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v12 + 40))();
        }
        long long v12 = 0u;
        long long v13 = 0u;
      }
      if (v9[0])
      {
        uint64_t v5 = (_anonymous_namespace_ *)v10;
        if (v10)
        {
          if (v11) {
            uint64_t v5 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
          }
        }
      }
      v9[0] = 0;
      uint64_t v18 = 0;
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      uint64_t v14 = 0;
      int v17 = 0;
      char v19 = 0;
      char v20 = 0;
      uint64_t v21 = 0;
      char v22 = 0;
      float32x4_t v6 = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)v9);
      char v7 = (uint64_t *)(v3 + 32);
      NS::SharedPtr<MTL::Texture>::operator=((void **)(v3 + 32), v6);
      re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)&v14);
      this = v12;
      if ((void)v12)
      {
        if (BYTE8(v12)) {
          this = (*(uint64_t (**)(void))(*(void *)v12 + 40))();
        }
        long long v12 = 0u;
        long long v13 = 0u;
      }
      if (v9[0])
      {
        this = v10;
        if (v10)
        {
          if (v11) {
            this = (*(uint64_t (**)(void))(*(void *)v10 + 40))();
          }
        }
      }
      uint64_t v8 = *v7;
      if (*v7) {
        LOBYTE(v8) = *(void *)(v3 + 24) != 0;
      }
      *(unsigned char *)(v3 + 9) = v8;
    }
  }
  return this;
}

double re::OpenSubdivViewIndependentComputeStep::addDeformationInstance@<D0>(re::OpenSubdivViewIndependentComputeStep *this@<X0>, uint64_t a2@<X8>)
{
  if (*((unsigned char *)this + 8))
  {
    if (*((unsigned char *)this + 9)) {
      char v3 = 1;
    }
    else {
      char v3 = 2;
    }
  }
  else
  {
    char v3 = 2;
  }
  *(void *)a2 = 0xFFFFFFFFLL;
  *(void *)&double result = 7682;
  *(_OWORD *)(a2 + 8) = xmmword_2344073E0;
  *(unsigned char *)(a2 + 24) = v3;
  *(void *)(a2 + 32) = -1;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

uint64_t re::OpenSubdivViewIndependentComputeStep::allocateBuffers(re *a1, re::FrameContext *a2, unsigned int a3, uint64_t *a4)
{
  float32x4_t v6 = a4;
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v8 = *a4;
  unint64_t v9 = *(void *)(*a4 + 48);
  re::globalAllocators(a1);
  uint64_t v10 = *((void *)a2 + 3);
  char v11 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
  uint64_t v12 = *((void *)a2 + 3);
  v11[1] = 0;
  void v11[2] = 0;
  *char v11 = 0;
  re::FixedArray<re::FrameContextBuffer>::init<>(v11, v12, v9);
  uint64_t v14 = re::globalAllocators(v13)[2];
  *(void *)&long long v45 = &unk_26E7141B0;
  *((void *)&v46 + 1) = v14;
  *(void *)&long long v47 = &v45;
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t *, long long *))(*(void *)v10 + 16))(v10, v11, &v45);
  re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)&v45);
  unint64_t v34 = v9;
  if (v9)
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    int v32 = v6;
    uint64_t v33 = v8 + 8;
    while (1)
    {
      unint64_t v18 = *(void *)(re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v33, v17) + 8);
      uint64_t v19 = re::BucketArray<re::ActiveDeformation,8ul>::operator[](v6[1], v18);
      unint64_t v21 = v6[6];
      if (v21 <= v18) {
        break;
      }
      uint64_t v22 = v19;
      uint64_t v23 = v6[5];
      uint64_t v24 = re::DataArray<re::MeshModel>::get(*((void *)a1 + 2) + 8, *(void *)(*(void *)(v19 + 368) + 16));
      unint64_t v4 = *(unsigned __int16 *)(v22 + 392);
      unint64_t v5 = *(void *)(v24 + 56);
      if (v5 <= v4) {
        goto LABEL_9;
      }
      unint64_t v5 = v23 + 312 * v18;
      uint64_t v25 = *(void *)(v24 + 64);
      LOBYTE(v45) = 9;
      re::DeformationVertexBufferState::ensureVertexBufferInitialized(v5, 9u);
      unint64_t v26 = (unint64_t)*(unsigned int *)(*(void *)(v5 + 64)
                                              + 32
                                              * re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find((void *)(v5 + 56), (unsigned __int8 *)&v45)+ 20) >> 2;
      uint64_t v27 = *(unsigned int *)(v25 + 560 * v4 + 528);
      re::FrameContext::perFrameAlloc(a2, 8uLL, 4uLL, (uint64_t)&v45);
      long long v28 = v45;
      uint64_t v29 = v46;
      *(void *)(v45 + DWORD2(v45)) = v27 | (v26 << 32);
      unint64_t v4 = *(void *)(v15 + 8);
      if (v4 <= v17) {
        goto LABEL_10;
      }
      uint64_t v30 = *(void *)(v15 + 16) + v16;
      *(_OWORD *)uint64_t v30 = v28;
      *(void *)(v30 + 16) = v29;
      re::FrameContext::perFrameAllocTail(a2, 12 * (v26 + v27), 0x10uLL, (uint64_t)&v45);
      LOWORD(v38) = 1025;
      int v37 = 65548;
      LOBYTE(v39) = 30;
      HIDWORD(v38) = 0;
      re::DeformationVertexBufferState::setOutputBuffer(v5, 0xDu, a3, (uint64_t)&v45, (uint64_t)&v37);
      ++v17;
      v16 += 24;
      float32x4_t v6 = v32;
      if (v34 == v17) {
        return v15;
      }
    }
    re::internal::assertLog((re::internal *)6, v20, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v18, v21);
    _os_crash();
    __break(1u);
LABEL_9:
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v37 = 136315906;
    unint64_t v38 = "operator[]";
    __int16 v39 = 1024;
    int v40 = 476;
    __int16 v41 = 2048;
    unint64_t v42 = v4;
    __int16 v43 = 2048;
    unint64_t v44 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_10:
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v37 = 136315906;
    unint64_t v38 = "operator[]";
    __int16 v39 = 1024;
    int v40 = 468;
    __int16 v41 = 2048;
    unint64_t v42 = v17;
    __int16 v43 = 2048;
    unint64_t v44 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return v15;
}

uint64_t re::OpenSubdivViewIndependentComputeStep::deformGPU(uint64_t a1, uint64_t a2, void **a3, uint64_t *a4)
{
  unint64_t v4 = a4;
  uint64_t v7 = a1;
  uint64_t v71 = *MEMORY[0x263EF8340];
  uint64_t v8 = *a4;
  unsigned int v9 = objc_msgSend(*(id *)(a1 + 24), sel_maxTotalThreadsPerThreadgroup);
  unint64_t v10 = *(void *)(v8 + 48);
  re::mtl::ComputeCommandEncoder::pushDebugGroup(a3, (re::ns *)"OpenSubdivViewIndependentComputeStep - copy positions");
  unint64_t v63 = v10;
  if (v10)
  {
    unsigned int v11 = v9;
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    uint64_t v61 = v7;
    uint64_t v62 = v8 + 8;
    unsigned int v57 = v11 - 1;
    unsigned int v58 = v11;
    long long v59 = v4;
    uint64_t v56 = v11;
    uint64_t v60 = a2;
    while (1)
    {
      uint64_t v14 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v62, v13);
      unint64_t v16 = *(void *)(a2 + 8);
      if (v16 <= v13) {
        break;
      }
      unint64_t v16 = *(void *)(v14 + 8);
      unint64_t v17 = v4[6];
      if (v17 <= v16) {
        goto LABEL_19;
      }
      uint64_t v18 = *(void *)(a2 + 16);
      uint64_t v19 = v4[5];
      uint64_t v20 = re::BucketArray<re::ActiveDeformation,8ul>::operator[](v4[1], v16);
      if (*(_DWORD *)(v18 + v12 + 12))
      {
        uint64_t v21 = v20;
        uint64_t v22 = re::DataArray<re::MeshModel>::get(*(void *)(v7 + 16) + 8, *(void *)(*(void *)(v20 + 368) + 16));
        unint64_t v4 = (uint64_t *)*(unsigned __int16 *)(v21 + 392);
        unint64_t v10 = *(void *)(v22 + 56);
        if (v10 <= (unint64_t)v4) {
          goto LABEL_22;
        }
        uint64_t v23 = *(void *)(v22 + 64);
        LOBYTE(v67[0]) = 1;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized(v19 + 312 * v16, 1u);
        uint64_t v24 = (void *)(v19 + 312 * v16);
        unint64_t v16 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v24 + 7, (unsigned __int8 *)v67);
        uint64_t v25 = v24[8];
        LOBYTE(v67[0]) = 13;
        re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v24, 0xDu);
        unint64_t v10 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v24 + 23, (unsigned __int8 *)v67);
        uint64_t v26 = v24[24];
        uint64_t v27 = (*(_DWORD *)(v23 + 560 * v4 + 528) + v57) / v58;
        [*a3 setComputePipelineState:*(void *)(v61 + 24)];
        [*a3 setBuffer:*(void *)(v18 + v12 + 16) offset:*(unsigned int *)(v18 + v12 + 8) atIndex:0];
        uint64_t v28 = v25 + 32 * v16;
        a2 = v60;
        [*a3 setBuffer:*(void *)(v28 + 24) offset:*(unsigned int *)(v28 + 16) atIndex:1];
        [*a3 setBuffer:*(void *)(v26 + 32 * v10 + 24) offset:*(unsigned int *)(v26 + 32 * v10 + 16) atIndex:2];
        uint64_t v29 = *a3;
        *(void *)&v67[0] = v27;
        uint64_t v7 = v61;
        *(int64x2_t *)((char *)v67 + 8) = vdupq_n_s64(1uLL);
        *(void *)long long v64 = v56;
        *(_OWORD *)&v64[8] = *(_OWORD *)((char *)v67 + 8);
        [v29 dispatchThreadgroups:v67 threadsPerThreadgroup:v64];
        unint64_t v4 = v59;
      }
      ++v13;
      v12 += 24;
      if (v63 == v13)
      {
        [*a3 popDebugGroup];
        re::mtl::ComputeCommandEncoder::pushDebugGroup(a3, (re::ns *)"OpenSubdivViewIndependentComputeStep - apply stencils");
        uint64_t v30 = 0;
        unint64_t v13 = 0;
        while (1)
        {
          uint64_t v31 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v62, v13);
          unint64_t v12 = *(void *)(a2 + 8);
          if (v12 <= v13) {
            break;
          }
          unint64_t v16 = *(void *)(v31 + 8);
          unint64_t v33 = v4[6];
          if (v33 <= v16) {
            goto LABEL_21;
          }
          uint64_t v34 = *(void *)(a2 + 16);
          uint64_t v35 = v4[5];
          re::BucketArray<re::ActiveDeformation,8ul>::operator[](v4[1], v16);
          uint64_t v36 = v34 + v30;
          if (*(_DWORD *)(v34 + v30 + 12))
          {
            int v37 = (void *)(v35 + 312 * v16);
            LOBYTE(v67[0]) = 1;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v37, 1u);
            uint64_t v38 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v37 + 7, (unsigned __int8 *)v67);
            uint64_t v52 = v37[8];
            uint64_t v53 = v38;
            LOBYTE(v67[0]) = 12;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v37, 0xCu);
            uint64_t v39 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v37 + 7, (unsigned __int8 *)v67);
            uint64_t v54 = v37[8];
            uint64_t v55 = v39;
            LOBYTE(v67[0]) = 9;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v37, 9u);
            uint64_t v40 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v37 + 7, (unsigned __int8 *)v67);
            uint64_t v41 = v37[8];
            LOBYTE(v67[0]) = 10;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v37, 0xAu);
            uint64_t v42 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v37 + 7, (unsigned __int8 *)v67);
            uint64_t v43 = v37[8];
            LOBYTE(v67[0]) = 11;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v37, 0xBu);
            uint64_t v44 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v37 + 7, (unsigned __int8 *)v67);
            uint64_t v50 = v37[8];
            uint64_t v51 = v44;
            LOBYTE(v67[0]) = 13;
            re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v37, 0xDu);
            unint64_t v10 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v37 + 23, (unsigned __int8 *)v67);
            unint64_t v16 = v37[24];
            uint64_t v45 = v41 + 32 * v40;
            uint64_t v46 = (v57 + (*(_DWORD *)(v45 + 20) >> 2)) / v58;
            [*a3 setComputePipelineState:*(void *)(v61 + 32)];
            [*a3 setBuffer:*(void *)(v36 + 16) offset:*(unsigned int *)(v36 + 8) atIndex:0];
            [*a3 setBuffer:*(void *)(v52 + 32 * v53 + 24) offset:*(unsigned int *)(v52 + 32 * v53 + 16) atIndex:1];
            [*a3 setBuffer:*(void *)(v45 + 24) offset:*(unsigned int *)(v45 + 16) atIndex:2];
            uint64_t v47 = v43 + 32 * v42;
            unint64_t v4 = v59;
            [*a3 setBuffer:*(void *)(v47 + 24) offset:*(unsigned int *)(v47 + 16) atIndex:3];
            [*a3 setBuffer:*(void *)(v54 + 32 * v55 + 24) offset:*(unsigned int *)(v54 + 32 * v55 + 16) atIndex:4];
            [*a3 setBuffer:*(void *)(v50 + 32 * v51 + 24) offset:*(unsigned int *)(v50 + 32 * v51 + 16) atIndex:5];
            [*a3 setBuffer:*(void *)(v16 + 32 * v10 + 24) offset:*(unsigned int *)(v16 + 32 * v10 + 16) atIndex:6];
            long long v48 = *a3;
            *(void *)&v67[0] = v46;
            *(int64x2_t *)((char *)v67 + 8) = vdupq_n_s64(1uLL);
            *(void *)long long v64 = v56;
            *(_OWORD *)&v64[8] = *(_OWORD *)((char *)v67 + 8);
            [v48 dispatchThreadgroups:v67 threadsPerThreadgroup:v64];
          }
          ++v13;
          v30 += 24;
          a2 = v60;
          if (v63 == v13) {
            return [*a3 popDebugGroup];
          }
        }
LABEL_20:
        long long v69 = 0u;
        long long v70 = 0u;
        long long v68 = 0u;
        memset(v67, 0, sizeof(v67));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)long long v64 = 136315906;
        *(void *)&v64[4] = "operator[]";
        *(_WORD *)&v64[12] = 1024;
        *(_DWORD *)&v64[14] = 468;
        *(_WORD *)&unsigned char v64[18] = 2048;
        *(void *)&v64[20] = v13;
        __int16 v65 = 2048;
        unint64_t v66 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_21:
        re::internal::assertLog((re::internal *)6, v32, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v16, v33);
        _os_crash();
        __break(1u);
LABEL_22:
        long long v69 = 0u;
        long long v70 = 0u;
        long long v68 = 0u;
        memset(v67, 0, sizeof(v67));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)long long v64 = 136315906;
        *(void *)&v64[4] = "operator[]";
        *(_WORD *)&v64[12] = 1024;
        *(_DWORD *)&v64[14] = 476;
        *(_WORD *)&unsigned char v64[18] = 2048;
        *(void *)&v64[20] = v4;
        __int16 v65 = 2048;
        unint64_t v66 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
    }
    long long v69 = 0u;
    long long v70 = 0u;
    long long v68 = 0u;
    memset(v67, 0, sizeof(v67));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v64 = 136315906;
    *(void *)&v64[4] = "operator[]";
    *(_WORD *)&v64[12] = 1024;
    *(_DWORD *)&v64[14] = 468;
    *(_WORD *)&unsigned char v64[18] = 2048;
    *(void *)&v64[20] = v13;
    __int16 v65 = 2048;
    unint64_t v66 = v16;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_19:
    re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v16, v17);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  [*a3 popDebugGroup];
  re::mtl::ComputeCommandEncoder::pushDebugGroup(a3, (re::ns *)"OpenSubdivViewIndependentComputeStep - apply stencils");
  return [*a3 popDebugGroup];
}

uint64_t re::OpenSubdivViewDependentComputeStep::init(uint64_t this, re::RenderManager *a2)
{
  if (!*(unsigned char *)(this + 8))
  {
    uint64_t v3 = this;
    *(unsigned char *)(this + 8) = 1;
    *(void *)(this + 16) = *((void *)a2 + 4);
    if (*((unsigned char *)a2 + 262))
    {
      v15[0] = 0;
      uint64_t v21 = 0;
      memset(v19, 0, sizeof(v19));
      int v20 = 0;
      char v22 = 0;
      char v23 = 0;
      uint64_t v24 = 0;
      char v25 = 0;
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      unint64_t v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v7, 0);
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      re::TechniqueFunctionConstant::setAs64Bits((re::TechniqueFunctionConstant *)&v7, 0);
      int v11 = 1048629;
      re::DynamicArray<re::TechniqueFunctionConstant>::add((_anonymous_namespace_ *)v19, (re::DynamicString *)&v7);
      ComputePipelineState = (void **)re::getOrCreateComputePipelineState((uint64_t)a2, (uint64_t)v15);
      NS::SharedPtr<MTL::Texture>::operator=((void **)(v3 + 24), ComputePipelineState);
      if (v12)
      {
        if (v13)
        {
          (*(void (**)(void))(*(void *)v12 + 40))();
          uint64_t v13 = 0;
          uint64_t v14 = 0;
        }
        uint64_t v12 = 0;
      }
      if (v7 && (v8 & 1) != 0) {
        (*(void (**)(void))(*v7 + 40))();
      }
      re::DynamicArray<re::TechniqueFunctionConstant>::deinit((uint64_t)v19);
      this = v18[0];
      if (v18[0])
      {
        if (v18[1]) {
          this = (*(uint64_t (**)(void))(*(void *)v18[0] + 40))();
        }
        memset(v18, 0, sizeof(v18));
      }
      if (v15[0])
      {
        this = v16;
        if (v16)
        {
          if (v17) {
            return (*(uint64_t (**)(void))(*(void *)v16 + 40))();
          }
        }
      }
    }
  }
  return this;
}

uint64_t re::OpenSubdivViewDependentComputeStep::addDeformationInstance@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0xFFFFFFFFLL;
  *(_OWORD *)(a2 + 8) = xmmword_2344073F0;
  if (*(void *)(this + 24)) {
    char v3 = 1;
  }
  else {
    char v3 = 2;
  }
  *(unsigned char *)(a2 + 24) = v3;
  *(void *)(a2 + 32) = -1;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return this;
}

uint64_t re::OpenSubdivViewDependentComputeStep::allocateBuffers(uint64_t a1, re::FrameContext *a2, unsigned int a3, uint64_t *a4)
{
  uint64_t v97 = *MEMORY[0x263EF8340];
  unint64_t v57 = *(void *)(*a4 + 48);
  if (v57)
  {
    unint64_t v5 = a4;
    uint64_t v6 = a4[4];
    if (v6)
    {
      uint64_t v54 = *a4 + 8;
      uint64_t v8 = (float32x4_t *)(a4[3] + 96 * (v6 - 1));
      re::RenderCamera::computeInverseTransform(v8, (uint64_t)&v86);
      re::Projection::computeMatrix4x4F((re::Projection *)&v8[2], (uint64_t)&v82);
      uint64_t v10 = 0;
      float32x4_t v11 = v82;
      float32x4_t v12 = v83;
      float32x4_t v13 = v84;
      float32x4_t v14 = v85;
      *(float32x4_t *)__int16 v90 = v86;
      *(float32x4_t *)&v90[16] = v87;
      *(float32x4_t *)&v90[32] = v88;
      float32x4_t v91 = v89;
      do
      {
        *(float32x4_t *)((char *)&v92 + v10) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v11, COERCE_FLOAT(*(_OWORD *)&v90[v10])), v12, *(float32x2_t *)&v90[v10], 1), v13, *(float32x4_t *)&v90[v10], 2), v14, *(float32x4_t *)&v90[v10], 3);
        v10 += 16;
      }
      while (v10 != 64);
      float32x4_t v52 = v93;
      float32x4_t v53 = v92;
      float32x4_t v50 = v95;
      float32x4_t v51 = v94;
      re::globalAllocators(v9);
      uint64_t v15 = *((void *)a2 + 3);
      unint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 32))(v15, 24, 8);
      uint64_t v17 = *((void *)a2 + 3);
      *(void *)(v16 + 8) = 0;
      *(void *)(v16 + 16) = 0;
      *(void *)unint64_t v16 = 0;
      re::FixedArray<re::FrameContextBuffer>::init<>((uint64_t *)v16, v17, v57);
      uint64_t v19 = re::globalAllocators(v18)[2];
      v92.i64[0] = (uint64_t)&unk_26E714208;
      v93.i64[1] = v19;
      v94.i64[0] = (uint64_t)&v92;
      uint64_t v20 = (*(uint64_t (**)(uint64_t, unint64_t, float32x4_t *))(*(void *)v15 + 16))(v15, v16, &v92);
      re::FunctionBase<24ul,void ()(void *)>::destroyCallable((uint64_t)&v92);
      uint64_t v21 = 0;
      long long v49 = v5;
      while (1)
      {
        unint64_t v22 = *(void *)(re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v54, (unint64_t)v21) + 8);
        uint64_t v23 = re::BucketArray<re::ActiveDeformation,8ul>::operator[](v5[1], v22);
        unint64_t v25 = v5[6];
        if (v25 <= v22) {
          break;
        }
        uint64_t v26 = v23;
        long long v70 = v21;
        uint64_t v21 = a2;
        uint64_t v27 = v20;
        uint64_t v28 = v5[5];
        uint64_t v29 = *(float32x4_t **)(*(void *)(v23 + 352) + 80);
        uint64_t v30 = re::DataArray<re::MeshModel>::get(*(void *)(a1 + 16) + 8, *(void *)(*(void *)(v23 + 368) + 16));
        unint64_t v4 = *(unsigned __int16 *)(v26 + 392);
        unint64_t v16 = *(void *)(v30 + 56);
        if (v16 <= v4) {
          goto LABEL_18;
        }
        uint64_t v31 = 0;
        int v32 = *(_DWORD *)(*(void *)(v30 + 64) + 560 * *(unsigned __int16 *)(v26 + 392) + 532);
        float32x4_t v33 = v86;
        float32x4_t v34 = v87;
        uint64_t v35 = v28 + 312 * v22;
        float32x4_t v36 = v88;
        float32x4_t v37 = v89;
        float32x4_t v38 = *v29;
        float32x4_t v39 = v29[1];
        float32x4_t v40 = v29[2];
        float32x4_t v41 = v29[3];
        *(float32x4_t *)__int16 v90 = *v29;
        *(float32x4_t *)&v90[16] = v39;
        *(float32x4_t *)&v90[32] = v40;
        float32x4_t v91 = v41;
        do
        {
          *(float32x4_t *)((char *)&v92 + v31) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, COERCE_FLOAT(*(_OWORD *)&v90[v31])), v34, *(float32x2_t *)&v90[v31], 1), v36, *(float32x4_t *)&v90[v31], 2), v37, *(float32x4_t *)&v90[v31], 3);
          v31 += 16;
        }
        while (v31 != 64);
        uint64_t v42 = 0;
        float32x4_t v68 = v93;
        float32x4_t v69 = v92;
        unint64_t v4 = (6 * v32);
        float32x4_t v66 = v95;
        float32x4_t v67 = v94;
        float32x4_t v64 = v83;
        float32x4_t v65 = v82;
        float32x4_t v62 = v85;
        float32x4_t v63 = v84;
        *(float32x4_t *)__int16 v90 = v38;
        *(float32x4_t *)&v90[16] = v39;
        *(float32x4_t *)&v90[32] = v40;
        float32x4_t v91 = v41;
        uint64_t v20 = v27;
        do
        {
          *(float32x4_t *)((char *)&v92 + v42) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v53, COERCE_FLOAT(*(_OWORD *)&v90[v42])), v52, *(float32x2_t *)&v90[v42], 1), v51, *(float32x4_t *)&v90[v42], 2), v50, *(float32x4_t *)&v90[v42], 3);
          v42 += 16;
        }
        while (v42 != 64);
        float32x4_t v60 = v93;
        float32x4_t v61 = v92;
        float32x4_t v58 = v95;
        float32x4_t v59 = v94;
        a2 = v21;
        re::FrameContext::perFrameAlloc(v21, 0xD0uLL, 0x10uLL, (uint64_t)&v92);
        float32x4_t v43 = v92;
        uint64_t v44 = v93.i64[0];
        uint64_t v45 = v92.i64[0] + v92.u32[2];
        *(float32x4_t *)uint64_t v45 = v69;
        *(float32x4_t *)(v45 + 16) = v68;
        *(float32x4_t *)(v45 + 32) = v67;
        *(float32x4_t *)(v45 + 48) = v66;
        *(float32x4_t *)(v45 + 64) = v65;
        *(float32x4_t *)(v45 + 80) = v64;
        *(float32x4_t *)(v45 + 96) = v63;
        *(float32x4_t *)(v45 + 112) = v62;
        *(float32x4_t *)(v45 + 128) = v61;
        *(float32x4_t *)(v45 + 144) = v60;
        *(float32x4_t *)(v45 + 160) = v59;
        *(float32x4_t *)(v45 + 176) = v58;
        *(_DWORD *)(v45 + 192) = 16 * v32;
        *(_DWORD *)(v45 + 196) = 2;
        unint64_t v16 = *(void *)(v20 + 8);
        uint64_t v21 = v70;
        if (v16 <= (unint64_t)v70) {
          goto LABEL_19;
        }
        uint64_t v46 = *(void *)(v20 + 16) + 24 * (void)v70;
        *(float32x4_t *)uint64_t v46 = v43;
        unint64_t v16 = (4 * v32);
        *(void *)(v46 + 16) = v44;
        WORD2(v79) = 1025;
        LODWORD(v79) = 65548;
        char v81 = 30;
        int v80 = 0;
        __int16 v76 = 769;
        int v75 = 65552;
        char v78 = 31;
        int v77 = 0;
        __int16 v72 = 769;
        int v71 = 65548;
        char v74 = 30;
        int v73 = 0;
        unint64_t v47 = 12 * (16 * v32);
        re::FrameContext::perFrameAllocTail(a2, v47, 4uLL, (uint64_t)&v92);
        *(float32x4_t *)__int16 v90 = v92;
        *(void *)&v90[16] = v93.i64[0];
        re::DeformationVertexBufferState::setOutputBuffer(v35, 0x10u, a3, (uint64_t)v90, (uint64_t)&v79);
        re::FrameContext::perFrameAllocTail(a2, v47, 4uLL, (uint64_t)&v92);
        *(float32x4_t *)__int16 v90 = v92;
        *(void *)&v90[16] = v93.i64[0];
        re::DeformationVertexBufferState::setOutputBuffer(v35, 0x11u, a3, (uint64_t)v90, (uint64_t)&v79);
        re::FrameContext::perFrameAllocTail(a2, v47, 4uLL, (uint64_t)&v92);
        *(float32x4_t *)__int16 v90 = v92;
        *(void *)&v90[16] = v93.i64[0];
        re::DeformationVertexBufferState::setOutputBuffer(v35, 0x12u, a3, (uint64_t)v90, (uint64_t)&v79);
        re::FrameContext::perFrameAllocTail(a2, 4 * v16, 4uLL, (uint64_t)&v92);
        *(float32x4_t *)__int16 v90 = v92;
        *(void *)&v90[16] = v93.i64[0];
        re::DeformationVertexBufferState::setOutputBuffer(v35, 0xEu, a3, (uint64_t)v90, (uint64_t)&v75);
        re::FrameContext::perFrameAllocTail(a2, 4 * v16, 4uLL, (uint64_t)&v92);
        *(float32x4_t *)__int16 v90 = v92;
        *(void *)&v90[16] = v93.i64[0];
        re::DeformationVertexBufferState::setOutputBuffer(v35, 0xFu, a3, (uint64_t)v90, (uint64_t)&v75);
        re::FrameContext::perFrameAllocTail(a2, 2 * v4, 2uLL, (uint64_t)&v92);
        *(float32x4_t *)__int16 v90 = v92;
        *(void *)&v90[16] = v93.i64[0];
        re::DeformationVertexBufferState::setOutputBuffer(v35, 7u, a3, (uint64_t)v90, (uint64_t)&v71);
        uint64_t v21 = (re::FrameContext *)((char *)v70 + 1);
        unint64_t v5 = v49;
        if ((re::FrameContext *)((char *)v70 + 1) == (re::FrameContext *)v57) {
          return v20;
        }
      }
      re::internal::assertLog((re::internal *)6, v24, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v22, v25);
      _os_crash();
      __break(1u);
LABEL_18:
      uint64_t v79 = 0;
      float32x4_t v95 = 0u;
      long long v96 = 0u;
      float32x4_t v93 = 0u;
      float32x4_t v94 = 0u;
      float32x4_t v92 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int16 v90 = 136315906;
      *(void *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 476;
      *(_WORD *)&v90[18] = 2048;
      *(void *)&v90[20] = v4;
      *(_WORD *)&v90[28] = 2048;
      *(void *)&v90[30] = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_19:
      uint64_t v79 = 0;
      float32x4_t v95 = 0u;
      long long v96 = 0u;
      float32x4_t v93 = 0u;
      float32x4_t v94 = 0u;
      float32x4_t v92 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int16 v90 = 136315906;
      *(void *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(void *)&v90[20] = v21;
      *(_WORD *)&v90[28] = 2048;
      *(void *)&v90[30] = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return 0;
}

uint64_t re::OpenSubdivViewDependentComputeStep::deformGPU(uint64_t result, uint64_t a2, void **a3, uint64_t *a4)
{
  uint64_t v51 = result;
  uint64_t v59 = *MEMORY[0x263EF8340];
  if (a4[4])
  {
    unint64_t v5 = a4;
    uint64_t v8 = *a4;
    uint64_t v9 = &selRef_stepFunction_0;
    if ((unint64_t)objc_msgSend(*(id *)(result + 24), sel_threadExecutionWidth) <= 0x40) {
      unsigned int v34 = objc_msgSend(*(id *)(v51 + 24), sel_threadExecutionWidth);
    }
    else {
      unsigned int v34 = 64;
    }
    re::mtl::ComputeCommandEncoder::pushDebugGroup(a3, (re::ns *)"OpenSubdivViewIndependentComputeStep - cull and calculate tessellation factors");
    uint64_t v36 = *(void *)(v8 + 48);
    if (v36)
    {
      uint64_t v10 = 0;
      unint64_t v11 = 0;
      uint64_t v35 = v8 + 8;
      int64x2_t v31 = vdupq_n_s64(1uLL);
      uint64_t v32 = a2;
      float32x4_t v33 = v5;
      do
      {
        uint64_t v12 = re::BucketArray<re::DeformationInstanceIndex,64ul>::operator[](v35, v11);
        unint64_t v14 = *(void *)(a2 + 8);
        if (v14 <= v11)
        {
          long long v57 = 0u;
          long long v58 = 0u;
          long long v56 = 0u;
          memset(v55, 0, sizeof(v55));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)float32x4_t v52 = 136315906;
          *(void *)&v52[4] = "operator[]";
          *(_WORD *)&v52[12] = 1024;
          *(_DWORD *)&v52[14] = 468;
          *(_WORD *)&v52[18] = 2048;
          *(void *)&v52[20] = v11;
          __int16 v53 = 2048;
          unint64_t v54 = v14;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_16:
          re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 666, v14, v15);
          _os_crash();
          __break(1u);
LABEL_17:
          long long v57 = 0u;
          long long v58 = 0u;
          long long v56 = 0u;
          memset(v55, 0, sizeof(v55));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)float32x4_t v52 = 136315906;
          *(void *)&v52[4] = "operator[]";
          *(_WORD *)&v52[12] = 1024;
          *(_DWORD *)&v52[14] = 476;
          *(_WORD *)&v52[18] = 2048;
          *(void *)&v52[20] = v9;
          __int16 v53 = 2048;
          unint64_t v54 = v4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        unint64_t v14 = *(void *)(v12 + 8);
        unint64_t v15 = v5[6];
        if (v15 <= v14) {
          goto LABEL_16;
        }
        uint64_t v16 = *(void *)(a2 + 16);
        uint64_t v17 = v5[5];
        uint64_t v18 = re::BucketArray<re::ActiveDeformation,8ul>::operator[](v5[1], v14);
        if (*(_DWORD *)(v16 + v10 + 12))
        {
          uint64_t v19 = v18;
          uint64_t v20 = re::DataArray<re::MeshModel>::get(*(void *)(v51 + 16) + 8, *(void *)(*(void *)(v18 + 368) + 16));
          uint64_t v9 = (char **)*(unsigned __int16 *)(v19 + 392);
          unint64_t v4 = *(void *)(v20 + 56);
          if (v4 <= (unint64_t)v9) {
            goto LABEL_17;
          }
          uint64_t v49 = v16;
          uint64_t v50 = (v34 - 1 + 16 * *(_DWORD *)(*(void *)(v20 + 64) + 560 * v9 + 532)) / v34;
          LOBYTE(v55[0]) = 13;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized(v17 + 312 * v14, 0xDu);
          uint64_t v21 = (void *)(v17 + 312 * v14);
          uint64_t v42 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v21 + 7, (unsigned __int8 *)v55);
          uint64_t v40 = v21[8];
          LOBYTE(v55[0]) = 6;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v21, 6u);
          uint64_t v41 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v21 + 7, (unsigned __int8 *)v55);
          uint64_t v39 = v21[8];
          LOBYTE(v55[0]) = 8;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v21, 8u);
          uint64_t v22 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v21 + 7, (unsigned __int8 *)v55);
          uint64_t v37 = v21[8];
          uint64_t v38 = v22;
          LOBYTE(v55[0]) = 16;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v21, 0x10u);
          uint64_t v23 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v21 + 23, (unsigned __int8 *)v55);
          uint64_t v47 = v21[24];
          uint64_t v48 = v23;
          LOBYTE(v55[0]) = 17;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v21, 0x11u);
          uint64_t v46 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v21 + 23, (unsigned __int8 *)v55);
          uint64_t v44 = v21[24];
          LOBYTE(v55[0]) = 18;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v21, 0x12u);
          uint64_t v45 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v21 + 23, (unsigned __int8 *)v55);
          uint64_t v43 = v21[24];
          LOBYTE(v55[0]) = 14;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v21, 0xEu);
          uint64_t v24 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v21 + 23, (unsigned __int8 *)v55);
          uint64_t v25 = v21[24];
          LOBYTE(v55[0]) = 15;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v21, 0xFu);
          uint64_t v26 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v21 + 23, (unsigned __int8 *)v55);
          uint64_t v9 = (char **)v21[24];
          LOBYTE(v55[0]) = 7;
          re::DeformationVertexBufferState::ensureVertexBufferInitialized((uint64_t)v21, 7u);
          unint64_t v4 = re::HashBrown<re::VertexBufferID,re::FrameContextBuffer,re::Hash<re::VertexBufferID>,re::EqualTo<re::VertexBufferID>,void,false>::find(v21 + 23, (unsigned __int8 *)v55);
          uint64_t v27 = v21[24];
          [*a3 setComputePipelineState:*(void *)(v51 + 24)];
          [*a3 setBuffer:*(void *)(v40 + 32 * v42 + 24) offset:*(unsigned int *)(v40 + 32 * v42 + 16) atIndex:0];
          [*a3 setBuffer:*(void *)(v39 + 32 * v41 + 24) offset:*(unsigned int *)(v39 + 32 * v41 + 16) atIndex:1];
          [*a3 setBuffer:*(void *)(v37 + 32 * v38 + 24) offset:*(unsigned int *)(v37 + 32 * v38 + 16) atIndex:2];
          uint64_t v28 = v25 + 32 * v24;
          unint64_t v5 = v33;
          [*a3 setBuffer:*(void *)(v28 + 24) offset:*(unsigned int *)(v28 + 16) atIndex:3];
          uint64_t v29 = &v9[4 * v26];
          a2 = v32;
          [*a3 setBuffer:v29[3] offset:*((unsigned int *)v29 + 4) atIndex:4];
          [*a3 setBuffer:*(void *)(v47 + 32 * v48 + 24) offset:*(unsigned int *)(v47 + 32 * v48 + 16) atIndex:5];
          [*a3 setBuffer:*(void *)(v44 + 32 * v46 + 24) offset:*(unsigned int *)(v44 + 32 * v46 + 16) atIndex:6];
          [*a3 setBuffer:*(void *)(v43 + 32 * v45 + 24) offset:*(unsigned int *)(v43 + 32 * v45 + 16) atIndex:7];
          [*a3 setBuffer:*(void *)(v49 + v10 + 16) offset:*(unsigned int *)(v49 + v10 + 8) atIndex:9];
          [*a3 setBuffer:*(void *)(v27 + 32 * v4 + 24) offset:*(unsigned int *)(v27 + 32 * v4 + 16) atIndex:10];
          uint64_t v30 = *a3;
          *(void *)&v55[0] = v50;
          *(int64x2_t *)((char *)v55 + 8) = v31;
          *(void *)float32x4_t v52 = v34;
          *(int64x2_t *)&v52[8] = v31;
          [v30 dispatchThreadgroups:v55 threadsPerThreadgroup:v52];
        }
        ++v11;
        v10 += 24;
      }
      while (v36 != v11);
    }
    return [*a3 popDebugGroup];
  }
  return result;
}

void re::OpenSubdivViewIndependentComputeStep::deformCPU(uint64_t a1, uint64_t a2)
{
}

void re::OpenSubdivViewDependentComputeStep::~OpenSubdivViewDependentComputeStep(re::OpenSubdivViewDependentComputeStep *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {

    *((void *)this + 3) = 0;
  }
}

{
  void *v2;
  uint64_t vars8;

  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {

    *((void *)this + 3) = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

void re::OpenSubdivViewDependentComputeStep::deformCPU(uint64_t a1, uint64_t a2)
{
}

void re::internal::Callable<re::OpenSubdivViewIndependentComputeStep::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::~Callable()
{
}

uint64_t re::internal::Callable<re::OpenSubdivViewIndependentComputeStep::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::operator()(uint64_t a1, uint64_t **a2)
{
  return re::FixedArray<CoreIKTransform>::deinit(*a2);
}

void *re::internal::Callable<re::OpenSubdivViewIndependentComputeStep::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::cloneInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E7141B0;
  return result;
}

void *re::internal::Callable<re::OpenSubdivViewIndependentComputeStep::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::moveInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E7141B0;
  return result;
}

uint64_t re::internal::Callable<re::OpenSubdivViewIndependentComputeStep::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::size()
{
  return 16;
}

void re::internal::Callable<re::OpenSubdivViewDependentComputeStep::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::~Callable()
{
}

uint64_t re::internal::Callable<re::OpenSubdivViewDependentComputeStep::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::operator()(uint64_t a1, uint64_t **a2)
{
  return re::FixedArray<CoreIKTransform>::deinit(*a2);
}

void *re::internal::Callable<re::OpenSubdivViewDependentComputeStep::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::cloneInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E714208;
  return result;
}

void *re::internal::Callable<re::OpenSubdivViewDependentComputeStep::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::moveInto(uint64_t a1, void *a2)
{
  double result = a2;
  *a2 = &unk_26E714208;
  return result;
}

uint64_t re::internal::Callable<re::OpenSubdivViewDependentComputeStep::allocateBuffers(re::FrameContext &,re::DeformationExecutionMode,re::DeformationParameters &,re::BufferInitializationOptions &,re::DynamicArray<re::PostDeformationBlit> &,re::DynamicArray<re::EventWait> &)::$_0,void ()(void *)>::size()
{
  return 16;
}

double re::RenderThread::RenderThread(re::RenderThread *this)
{
  uint64_t v1 = 0;
  *((_DWORD *)this + 6) = 0;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *(_DWORD *)((char *)this + 15) = 0;
  do
  {
    uint64_t v2 = (char *)this + v1;
    *((void *)v2 + 8) = 0;
    *((void *)v2 + 5) = 0;
    *((void *)v2 + 6) = 0;
    *((void *)v2 + 4) = 0;
    v1 += 40;
    *((_DWORD *)v2 + 14) = 0;
  }
  while (v1 != 80);
  *((_DWORD *)this + 28) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 26) = 850045863;
  double result = 0.0;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 1018212795;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 305) = 0u;
  *((void *)this + 41) = 850045863;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((void *)this + 48) = 0;
  *((void *)this + 49) = 1018212795;
  *((void *)this + 54) = 0;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  return result;
}

uint64_t re::RenderThread::init(uint64_t this, re::RenderManager *a2)
{
  v2[4] = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(this + 16))
  {
    *(void *)(this + 8) = a2;
    atomic_store(0, (unint64_t *)(this + 176));
    atomic_store(0, (unint64_t *)(this + 184));
    atomic_store(0, (unint64_t *)(this + 192));
    atomic_store(0, (unint64_t *)(this + 200));
    *(void *)(this + 160) = 0;
    *(void *)(this + 168) = 0;
    v2[3] = 0;
    std::function<void ()(re::EventQueue &)>::operator=((void *)(this + 128), (uint64_t)v2);
    std::__function::__value_func<void ()(re::EventQueue &)>::~__value_func[abi:nn180100](v2);
    operator new();
  }
  return this;
}

void re::RenderThread::threadFuncStatic(re::RenderThread *this, void *a2)
{
  v44[4] = *MEMORY[0x263EF8340];
  pthread_setname_np("Render");
  uint64_t v4 = *((void *)this + 1);
  if (!v4)
  {
LABEL_42:
    re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) NULL RenderManager in RenderThread. Cannot continue.", "m_renderManager", "threadFunc", 90);
    _os_crash();
    __break(1u);
  }
  uint64_t v5 = *(void *)(v4 + 224);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
  }
  uint64_t v6 = (re::RenderThread *)((char *)this + 320);
  uint64_t v7 = 40;
  do
  {
    do
    {
      re::internal::AutoResetEvent::waitOne(v6);
      re::EventQueue::processEvents((os_unfair_lock_s *)this + 6);
    }
    while (*((void *)this + 15) == *((void *)this + 5 * ((*((_DWORD *)this + 28) & 1) == 0) + 6));
    char v8 = 0;
    do
    {
      int v9 = re::EventQueue::peekEvent((re::RenderThread *)((char *)this + 24), 0);
      if (v9 == 1)
      {
        char v8 = 1;
        int __dst = 1;
        re::EventQueue::readEvent((re::RenderThread *)((char *)this + 24), &__dst, 4uLL);
      }
      else
      {
        if (v9) {
          continue;
        }
        int __dst = 0;
        uint64_t v36 = 0xFFFFFFFFFFFFFFFLL;
        uint64_t v10 = (re::ProfilerConfig *)re::EventQueue::readEvent((re::RenderThread *)((char *)this + 24), &__dst, 0x28uLL);
        uint64_t v12 = v36;
        uint64_t v13 = *(void *)(*((void *)this + 1) + 104) + 16 * (v36 & 7);
        *(void *)(v13 + 472) = v37;
        *(void *)(v13 + 480) = v12;
        uint64_t v14 = v39;
        if (!v39)
        {
          re::internal::assertLog((re::internal *)4, v11, "assertion failure: '%s' (%s:line %i) NULL workload passed to RenderThread::doRender", "workload", "doRender", 141);
          _os_crash();
          __break(1u);
          goto LABEL_42;
        }
        int v15 = v38;
        uint64_t v16 = v36;
        isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(v10);
        if (isStatisticCollectionEnabled)
        {
          uint64_t v18 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
          uint64_t v19 = *(void *)(*((void *)this + 1) + 104);
          if (v19) {
            uint64_t v20 = *(re::ProfilerManager **)(v19 + 1664);
          }
          else {
            uint64_t v20 = 0;
          }
          re::ProfilerThreadContext::begin(v18, v20, 0);
        }
        unsigned __int8 v43 = 1;
        uint64_t v21 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
        if (v21)
        {
          uint64_t v22 = re::profilerThreadContext(v21);
          if (*(void *)(v22 + 152)) {
            uint64_t v7 = mach_absolute_time();
          }
        }
        else
        {
          uint64_t v22 = 0;
        }
        double v41 = 0.0;
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = std::chrono::steady_clock::now().__d_.__rep_;
        char v42 = 1;
        uint64_t v23 = operator new(0x38uLL);
        *uint64_t v23 = &unk_26E714300;
        v23[1] = &v43;
        *((_DWORD *)v23 + 4) = v15;
        v23[3] = v14;
        v23[4] = v16;
        v23[5] = &rep;
        v23[6] = this;
        void v44[3] = v23;
        re::runInLocalAutoreleasePool((uint64_t)v44);
        std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v44);
        double v41 = v41 + (double)(std::chrono::steady_clock::now().__d_.__rep_ - rep) / 1000000000.0;
        char v42 = 0;
        uint64_t v24 = *((void *)this + 1);
        v25.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
        uint64_t v26 = *(void *)(v24 + 104);
        if (v26)
        {
          if (v42) {
            double v27 = 1.0;
          }
          else {
            double v27 = 0.0;
          }
          *(double *)(v26 + 880) = v41 + (double)(v25.__d_.__rep_ - rep) / 1000000000.0 * v27;
        }
        if (v22)
        {
          if (*(void *)(v22 + 152))
          {
            v25.__d_.__rep_ = mach_absolute_time();
            uint64_t v28 = *(int64x2_t **)(v22 + 152);
            if (v28)
            {
              uint64_t v29 = v28[36].u64[0];
              if (v29 >= v25.__d_.__rep_ - v7) {
                uint64_t v29 = v25.__d_.__rep_ - v7;
              }
              v28[36].i64[0] = v29;
              uint64_t v30 = v28[36].u64[1];
              if (v30 <= v25.__d_.__rep_ - v7) {
                uint64_t v30 = v25.__d_.__rep_ - v7;
              }
              v28[36].i64[1] = v30;
              int64x2_t v31 = vdupq_n_s64(1uLL);
              v31.i64[0] = v25.__d_.__rep_ - v7;
              v28[37] = vaddq_s64(v28[37], v31);
              *(unsigned char *)(v22 + 184) = 0;
            }
          }
        }
        uint64_t v32 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v25.__d_.__rep_);
        if (v32)
        {
          float32x4_t v33 = (re::ProfilerThreadContext *)re::profilerThreadContext(v32);
          re::ProfilerThreadContext::end(v33);
        }
        int v34 = v43;
        std::mutex::lock((std::mutex *)((char *)this + 208));
        atomic_fetch_add((atomic_ullong *volatile)this + 23, 1uLL);
        uint64_t v6 = (re::RenderThread *)((char *)this + 320);
        uint64_t v7 = 40;
        if (v34) {
          atomic_fetch_add((atomic_ullong *volatile)this + 25, 1uLL);
        }
        std::condition_variable::notify_one((std::condition_variable *)((char *)this + 272));
        std::mutex::unlock((std::mutex *)((char *)this + 208));
      }
    }
    while (*((void *)this + 15) != *((void *)this + 5 * ((*((_DWORD *)this + 28) & 1) == 0) + 6));
  }
  while ((v8 & 1) == 0);
}

void re::RenderThread::join(re::RenderThread *this)
{
  if (*((unsigned char *)this + 16))
  {
    if (!*((unsigned char *)this + 18))
    {
      *((unsigned char *)this + 18) = 1;
      int v2 = 1;
      re::EventQueue::postEvent((os_unfair_lock_s *)this + 6, &v2, 4uLL);
      re::internal::AutoResetEvent::set((re::RenderThread *)((char *)this + 320));
      std::thread::join((std::thread *)this);
    }
  }
}

void re::RenderThread::commitFrame(uint64_t a1, int a2, re::RenderFrameWorkload *a3)
{
  if (*(unsigned char *)(a1 + 16))
  {
    int v16 = 0;
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(re::FrameManager **)(v6 + 136);
    uint64_t v8 = *((void *)v7 + 3) & 0xFFFFFFFFFFFFFFFLL;
    unint64_t v17 = v8 | ((unint64_t)*((void *)v7 + 2) << 60);
    uint64_t v9 = *(void *)(v6 + 104);
    if (v9)
    {
      uint64_t v9 = re::RenderFrameBox::get(v9 + 344, 0xFFFFFFFFFFFFFFFuLL);
      uint64_t v7 = *(re::FrameManager **)(*(void *)(a1 + 8) + 136);
    }
    uint64_t v18 = v9;
    int v19 = a2;
    uint64_t v20 = a3;
    atomic_fetch_add((atomic_uint *volatile)(re::FrameManager::getFrameRefCount(v7, v8) + 128), 1u);
    re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v15, 1506, *(void *)(a1 + 8));
    re::internal::AutoResetEvent::set((re::internal::AutoResetEvent *)(a1 + 320));
    re::RenderThread::waitForIdleInternal((re::RenderThread *)a1);
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v15);
    re::EventQueue::postEvent((os_unfair_lock_s *)(a1 + 24), &v16, 0x28uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 176), 1uLL);
    if (*((unsigned char *)a3 + 184))
    {
      uint64_t v10 = *(void *)(a1 + 168);
      unint64_t v11 = atomic_load((unint64_t *)(a1 + 176));
      *(void *)(a1 + 160) = v10;
      *(void *)(a1 + 168) = v11;
    }
    re::internal::AutoResetEvent::set((re::internal::AutoResetEvent *)(a1 + 320));
    if (a2 == 2)
    {
      re::RenderThread::waitForIdleInternal((re::RenderThread *)a1);
      uint64_t v12 = *(void *)(*(void *)(a1 + 8) + 104);
      if (v12) {
        double v13 = *(float *)(v12 + 1760);
      }
      else {
        double v13 = 0.0;
      }
      re::RenderFrameWorkload::immediatePresentDrawables(a3, 1.0 / v13);
    }
    uint64_t v14 = *(void *)(*(void *)(a1 + 8) + 104);
    if (!v14 || !*(unsigned char *)(*(void *)(v14 + 256) + 267)) {
      re::RenderThread::waitForFramePacing((re::RenderThread *)a1);
    }
    if (a2 == 1 || *(unsigned char *)(a1 + 17)) {
      re::RenderThread::waitForIdleInternal((re::RenderThread *)a1);
    }
  }
}

void re::RenderThread::waitForIdleInternal(re::RenderThread *this)
{
  m = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 208);
  v3.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 208);
  v3.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 208));
  if (*((void *)this + 23) >= *((void *)this + 22)) {
    goto LABEL_5;
  }
  do
    std::condition_variable::wait((std::condition_variable *)((char *)this + 272), &v3);
  while (*((void *)this + 23) < *((void *)this + 22));
  if (v3.__owns_)
  {
    m = v3.__m_;
LABEL_5:
    std::mutex::unlock(m);
  }
}

void re::RenderThread::waitForFramePacing(re::RenderThread *this)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v28, 1508, *((void *)this + 1));
  uint64_t v2 = *(void *)(*((void *)this + 1) + 104);
  if (v2) {
    uint64_t v3 = *(void *)(v2 + 1648);
  }
  else {
    uint64_t v3 = 0;
  }
  *(void *)(v3 + 272) = 0;
  *(void *)(v3 + 280) = 0;
  *(unsigned char *)(v3 + 288) = 0;
  *(std::chrono::steady_clock::time_point *)(v3 + 272) = std::chrono::steady_clock::now();
  *(unsigned char *)(v3 + 288) = 1;
  uint64_t v4 = mach_absolute_time();
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 208);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 208));
  float v5 = 0.0;
  while (1)
  {
    unint64_t v6 = *((void *)this + 24);
    unint64_t v7 = *((void *)this + 20);
    if (v6 >= v7) {
      break;
    }
    std::chrono::steady_clock::now();
    v8.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    v9.__d_.__rep_ = 8000000;
    if (v8.__d_.__rep_)
    {
      if (v8.__d_.__rep_ < 1)
      {
        if ((unint64_t)v8.__d_.__rep_ >= 0xFFDF3B645A1CAC09) {
          v9.__d_.__rep_ = 1000 * v8.__d_.__rep_ + 8000000;
        }
        else {
          v9.__d_.__rep_ = 0x80000000007A1200;
        }
      }
      else if ((unint64_t)v8.__d_.__rep_ < 0x20C49BA5E334B8)
      {
        v9.__d_.__rep_ = 1000 * v8.__d_.__rep_ + 8000000;
      }
      else
      {
        v9.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    std::condition_variable::__do_timed_wait((std::condition_variable *)((char *)this + 272), &__lk, v9);
    std::chrono::steady_clock::now();
    uint64_t v10 = mach_absolute_time();
    double v11 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0) {
      goto LABEL_18;
    }
    if (!mach_timebase_info(&info))
    {
      LODWORD(v12) = info.numer;
      LODWORD(v13) = info.denom;
      double v11 = (double)v12 / (double)v13;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v11;
LABEL_18:
      double v14 = v11 * (double)(v10 - v4);
      goto LABEL_19;
    }
    double v14 = NAN;
LABEL_19:
    float v15 = v14 / 1000000.0;
    float v5 = v5 + v15;
    uint64_t v4 = v10;
    if (v5 > 100.0) {
      goto LABEL_22;
    }
  }
  uint64_t v10 = v4;
LABEL_22:
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
  if (v6 >= v7)
  {
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 208);
    __lk.__owns_ = 1;
    std::mutex::lock((std::mutex *)((char *)this + 208));
    while (1)
    {
      if (*((void *)this + 25) >= *((void *)this + 20))
      {
LABEL_41:
        if (__lk.__owns_) {
          std::mutex::unlock(__lk.__m_);
        }
        goto LABEL_43;
      }
      std::chrono::steady_clock::now();
      v16.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      v17.__d_.__rep_ = 8000000;
      if (v16.__d_.__rep_)
      {
        if (v16.__d_.__rep_ < 1)
        {
          if ((unint64_t)v16.__d_.__rep_ >= 0xFFDF3B645A1CAC09) {
            v17.__d_.__rep_ = 1000 * v16.__d_.__rep_ + 8000000;
          }
          else {
            v17.__d_.__rep_ = 0x80000000007A1200;
          }
        }
        else if ((unint64_t)v16.__d_.__rep_ < 0x20C49BA5E334B8)
        {
          v17.__d_.__rep_ = 1000 * v16.__d_.__rep_ + 8000000;
        }
        else
        {
          v17.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
        }
      }
      std::condition_variable::__do_timed_wait((std::condition_variable *)((char *)this + 272), &__lk, v17);
      std::chrono::steady_clock::now();
      uint64_t v18 = mach_absolute_time();
      double v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0) {
        goto LABEL_39;
      }
      if (!mach_timebase_info(&info)) {
        break;
      }
      double v22 = NAN;
LABEL_40:
      float v23 = v22 / 1000000.0;
      float v5 = v5 + v23;
      uint64_t v10 = v18;
      if (v5 > 100.0) {
        goto LABEL_41;
      }
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    double v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v19;
LABEL_39:
    double v22 = v19 * (double)(v18 - v10);
    goto LABEL_40;
  }
LABEL_43:
  v24.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  double v25 = 0.0;
  if (*(unsigned char *)(v3 + 288)) {
    double v25 = 1.0;
  }
  float v26 = (*(double *)(v3 + 280) + (double)(v24.__d_.__rep_ - *(void *)(v3 + 272)) / 1000000000.0 * v25) * 1000.0;
  *(float *)(v3 + 240) = v26;
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v28);
}

void re::RenderThread::workloadGPUCompleted(re::RenderThread *this)
{
  uint64_t v2 = (std::mutex *)((char *)this + 208);
  std::mutex::lock((std::mutex *)((char *)this + 208));
  atomic_fetch_add((atomic_ullong *volatile)this + 24, 1uLL);
  std::condition_variable::notify_one((std::condition_variable *)((char *)this + 272));
  std::mutex::unlock(v2);
}

void re::RenderThread::waitForCallbacksCompletion(re::RenderThread *this)
{
  v3.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 208);
  v3.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 208));
  unint64_t v2 = *((void *)this + 22);
  while (*((void *)this + 24) < v2 || *((void *)this + 25) < v2)
    std::condition_variable::wait((std::condition_variable *)((char *)this + 272), &v3);
  if (v3.__owns_) {
    std::mutex::unlock(v3.__m_);
  }
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (*)(void *),re::RenderThread *>>(uint64_t a1)
{
  float v5 = (uint64_t *)a1;
  unint64_t v2 = std::__thread_local_data();
  std::unique_lock<std::mutex> v3 = *(const void **)a1;
  *(void *)a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  (*(void (**)(void))(a1 + 8))(*(void *)(a1 + 16));
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (*)(void *),re::RenderThread *>>::reset[abi:nn180100](&v5);
  return 0;
}

uint64_t **std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (*)(void *),re::RenderThread *>>::reset[abi:nn180100](uint64_t **result)
{
  uint64_t v1 = *result;
  *double result = 0;
  if (v1)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](v1, 0);
    JUMPOUT(0x237DBCBD0);
  }
  return result;
}

uint64_t std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    MEMORY[0x237DBC830]();
    JUMPOUT(0x237DBCBD0);
  }
  return result;
}

void std::__function::__func<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0,std::allocator<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0,std::allocator<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)unint64_t v2 = &unk_26E714300;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 std::__function::__func<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0,std::allocator<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E714300;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void *std::__function::__func<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0,std::allocator<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = *(re::DrawingManager **)(*(void *)(v3 + 8) + 104);
  *(double *)(v2 + 8) = *(double *)(v2 + 8)
                      + (double)(std::chrono::steady_clock::now().__d_.__rep_ - *(void *)v2) / 1000000000.0;
  *(unsigned char *)(v2 + 16) = 0;
  re::DrawingManager::waitForGPUInternal(v4);
  uint64_t v5 = *(void *)(a1 + 40);
  *(std::chrono::steady_clock::time_point *)uint64_t v5 = std::chrono::steady_clock::now();
  *(unsigned char *)(v5 + 16) = 1;
  uint64_t v6 = re::RenderFrameBox::get((uint64_t)v4 + 344, *(void *)(a1 + 32));
  std::chrono::system_clock::time_point v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v7 = *(void *)(a1 + 40);
  *(double *)(v7 + 8) = *(double *)(v7 + 8)
                      + (double)(std::chrono::steady_clock::now().__d_.__rep_ - *(void *)v7) / 1000000000.0;
  *(unsigned char *)(v7 + 16) = 0;
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard(v25);
  re::RenderFrame::acquireDrawables(v6, &v16);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)11>::end((uint64_t)v25);
  uint64_t v8 = *(void *)(a1 + 40);
  *(std::chrono::steady_clock::time_point *)uint64_t v8 = std::chrono::steady_clock::now();
  *(unsigned char *)(v8 + 16) = 1;
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v15, 5004, *(void *)(v3 + 8));
  re::DrawingManager::executeFrameInternal(v4, *(re::RenderFrameWorkload **)(a1 + 24));
  uint64_t v9 = re::globalAllocators((re *)(id)(*(void *)(a1 + 24) + 8))[2];
  uint64_t v26 = v9;
  double v27 = v25;
  v25[0] = (uint64_t)&unk_26E714370;
  v25[1] = v3;
  uint64_t v10 = v17;
  if (v17)
  {
    double v11 = v18;
    while (!*v11)
    {
      ++v11;
      if (!--v10) {
        goto LABEL_7;
      }
    }
    uint64_t v23 = v9;
    uint64_t v24 = 0;
    re::FunctionBase<24ul,void ()(re::mtl::Drawable const&)>::operator=<24ul>((uint64_t)v22, (uint64_t)v25);
    re::mtl::Drawable::addPresentedHandler(v11, (uint64_t)v22);
    re::FunctionBase<24ul,void ()(re::mtl::Drawable const&)>::destroyCallable((uint64_t)v22);
    **(unsigned char **)(a1 + 8) = 0;
  }
LABEL_7:
  unint64_t v12 = *(void *)(a1 + 24);
  if (**(unsigned char **)(a1 + 8) && *(void *)(v12 + 208))
  {
    unint64_t v13 = *(void ***)(v12 + 224);
    uint64_t v20 = v26;
    uint64_t v21 = 0;
    re::FunctionBase<24ul,void ()(re::mtl::Drawable const&)>::operator=<24ul>((uint64_t)v19, (uint64_t)v25);
    re::mtl::Drawable::addPresentedHandler(v13, (uint64_t)v19);
    re::FunctionBase<24ul,void ()(re::mtl::Drawable const&)>::destroyCallable((uint64_t)v19);
    **(unsigned char **)(a1 + 8) = 0;
    unint64_t v12 = *(void *)(a1 + 24);
  }
  re::DrawingManager::presentDrawablesAndCommit(v4, &v16, *(unsigned int *)(a1 + 16), v12);

  if (*(_DWORD *)(a1 + 16) == 1) {
    re::RenderFrame::onFrameComplete(v6);
  }
  re::FunctionBase<24ul,void ()(re::mtl::Drawable const&)>::destroyCallable((uint64_t)v25);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v15);
  return re::FixedArray<re::mtl::Drawable>::deinit(&v16);
}

uint64_t std::__function::__func<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0,std::allocator<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0,std::allocator<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0>,void ()(void)>::target_type()
{
}

void re::internal::Callable<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0::operator() const(void)::{lambda(re::mtl::Drawable)#1},void ()(re::mtl::Drawable const&)>::~Callable()
{
}

void re::internal::Callable<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0::operator() const(void)::{lambda(re::mtl::Drawable)#1},void ()(re::mtl::Drawable const&)>::operator()(uint64_t a1, id *a2)
{
  id v4 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  std::mutex::lock((std::mutex *)(v3 + 208));
  atomic_fetch_add((atomic_ullong *volatile)(v3 + 200), 1uLL);
  std::condition_variable::notify_one((std::condition_variable *)(v3 + 272));
  std::mutex::unlock((std::mutex *)(v3 + 208));
}

void *re::internal::Callable<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0::operator() const(void)::{lambda(re::mtl::Drawable)#1},void ()(re::mtl::Drawable const&)>::cloneInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E714370;
  a2[1] = v2;
  return a2;
}

void *re::internal::Callable<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0::operator() const(void)::{lambda(re::mtl::Drawable)#1},void ()(re::mtl::Drawable const&)>::moveInto(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26E714370;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::RenderThread::doRender(re::WorkloadCommitMode,re::RenderFrameWorkload *,re::FrameCount)::$_0::operator() const(void)::{lambda(re::mtl::Drawable)#1},void ()(re::mtl::Drawable const&)>::size()
{
  return 16;
}

void re::APIFunctionCache::init(uint64_t a1, id *a2)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  uint64_t v4 = mach_absolute_time();
  for (uint64_t i = 0; i != 12; ++i)
  {
    uint64_t v6 = (re::ns *)realitykit_shader_api::textureFunctions[i];
    id v7 = *a2;
    uint64_t v45 = v7;
    re::APIFunctionCache::gatherFunctionConstantReflectionData(a1, v6, &v45);
  }
  for (uint64_t j = 0; j != 9; ++j)
  {
    uint64_t v9 = (re::ns *)realitykit_shader_api::materialFunctions[j];
    id v10 = *a2;
    uint64_t v44 = v10;
    re::APIFunctionCache::gatherFunctionConstantReflectionData(a1, v9, &v44);
  }
  for (uint64_t k = 0; k != 47; ++k)
  {
    unint64_t v12 = (re::ns *)realitykit_shader_api::geometry_modifierFunctions[k];
    id v13 = *a2;
    unsigned __int8 v43 = v13;
    re::APIFunctionCache::gatherFunctionConstantReflectionData(a1, v12, &v43);
  }
  for (uint64_t m = 0; m != 54; ++m)
  {
    float v15 = (re::ns *)realitykit_shader_api::surfaceFunctions[m];
    id v16 = *a2;
    char v42 = v16;
    re::APIFunctionCache::gatherFunctionConstantReflectionData(a1, v15, &v42);
  }
  for (uint64_t n = 0; n != 55; ++n)
  {
    uint64_t v18 = (re::ns *)realitykit_shader_api::geometry_modifier_privateFunctions[n];
    id v19 = *a2;
    double v41 = v19;
    re::APIFunctionCache::gatherFunctionConstantReflectionData(a1, v18, &v41);
  }
  for (iuint64_t i = 0; ii != 60; ++ii)
  {
    uint64_t v21 = (re::ns *)realitykit_shader_api::surface_privateFunctions[ii];
    id v22 = *a2;
    uint64_t v40 = v22;
    re::APIFunctionCache::gatherFunctionConstantReflectionData(a1, v21, &v40);
  }
  for (juint64_t j = 0; jj != 13; ++jj)
  {
    uint64_t v24 = (re::ns *)realitykit_shader_api::ui_geometry_modifier_privateFunctions[jj];
    id v25 = *a2;
    uint64_t v39 = v25;
    re::APIFunctionCache::gatherFunctionConstantReflectionData(a1, v24, &v39);
  }
  for (kuint64_t k = 0; kk != 22; ++kk)
  {
    double v27 = (re::ns *)realitykit_shader_api::uisurface_privateFunctions[kk];
    id v28 = *a2;
    int v38 = v28;
    re::APIFunctionCache::gatherFunctionConstantReflectionData(a1, v27, &v38);
  }
  id v29 = *a2;
  uint64_t v37 = v29;
  re::APIFunctionCache::gatherFunctionConstantReflectionData(a1, (re::ns *)"realitykit::texture_private::api::custom_at", &v37);

  uint64_t v30 = mach_absolute_time();
  uint64_t v31 = v30;
  double v32 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    uint64_t v30 = mach_timebase_info(&info);
    if (v30)
    {
      double v35 = NAN;
      goto LABEL_22;
    }
    LODWORD(v33) = info.numer;
    LODWORD(v34) = info.denom;
    double v32 = (double)v33 / (double)v34;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v32;
  }
  double v35 = v32 * (double)(v31 - v4);
LABEL_22:
  uint64_t v36 = *re::graphicsLogObjects((re *)v30);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    info.numer = 67109120;
    info.denouint64_t m = (int)(v35 / 1000000.0);
    _os_log_impl(&dword_233120000, v36, OS_LOG_TYPE_DEFAULT, "API function cache initialized in %d", (uint8_t *)&info, 8u);
  }
}

void re::APIFunctionCache::gatherFunctionConstantReflectionData(uint64_t a1, re::ns *a2, void **a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  re::mtl::Library::makeFunction(a3, a2, &v34);
  int v32 = 0;
  memset(v31, 0, sizeof(v31));
  uint64_t v33 = 0x7FFFFFFFLL;
  size_t v5 = strlen((const char *)a2);
  if (v5)
  {
    MurmurHash3_x64_128((uint64_t)a2, v5, 0, (unint64_t *)&v37);
    unint64_t v6 = (*((void *)&v37 + 1) + ((void)v37 << 6) + ((unint64_t)v37 >> 2) - 0x61C8864680B583E9) ^ v37;
  }
  else
  {
    unint64_t v6 = 0;
  }
  unint64_t v30 = v6;
  id v7 = v34;
  if (!objc_msgSend(objc_msgSend(v34, sel_functionConstantsDictionary), sel_count))
  {
    id v16 = re::globalAllocators(0);
    uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16[2] + 32))(v16[2], 16, 8);
    *(void *)uint64_t v17 = 0;
    *(void *)(v17 + 8) = 0;
    *(void *)&long long v37 = v17;
    NS::SharedPtr<MTL::Texture>::operator=((void **)(v17 + 8), &v34);
    atomic_store(2u, (unsigned __int8 *)v17);
    re::HashTable<unsigned long,re::CachedAPIFunction *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add<re::CachedAPIFunction *&>(a1, &v30, &v37);
    goto LABEL_30;
  }
  id v8 = objc_msgSend(v7, sel_functionConstantsDictionary);
  long long v37 = 0u;
  long long v38 = 0u;
  unsigned int v39 = 0;
  uint64_t v40 = 0x7FFFFFFFLL;
  id v9 = objc_msgSend(v8, sel_keyEnumerator);
  id v10 = objc_msgSend(v9, sel_nextObject);
  if (v10)
  {
    id v11 = v10;
    do
    {
      uint64_t v36 = (char *)objc_msgSend(v11, sel_UTF8String);
      id v35 = objc_msgSend(v8, sel_objectForKey_, v11);
      re::HashTable<char const*,NS::SharedPtr<MTL::FunctionConstant>,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::add((uint64_t)&v37, &v36, &v35);
      if (v35) {

      }
      id v11 = objc_msgSend(v9, sel_nextObject);
    }
    while (v11);
    unsigned int v12 = v39;
    if (v39)
    {
      uint64_t v13 = 0;
      double v14 = (int *)(v38 + 8);
      while (1)
      {
        int v15 = *v14;
        v14 += 8;
        if (v15 < 0) {
          goto LABEL_18;
        }
        if (v39 == ++v13)
        {
          LODWORD(v13) = v39;
          goto LABEL_18;
        }
      }
    }
  }
  else
  {
    unsigned int v12 = 0;
  }
  LODWORD(v13) = 0;
LABEL_18:
  if (v12 != v13)
  {
    uint64_t v18 = v13;
    uint64_t v19 = v38;
    do
    {
      LOWORD(v36) = (unsigned __int16)objc_msgSend(*(id *)(v19 + 32 * v18 + 24), sel_index);
      re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::addNew((uint64_t)v31, &v36);
      uint64_t v19 = v38;
      if (v39 <= (int)v13 + 1) {
        unsigned int v20 = v13 + 1;
      }
      else {
        unsigned int v20 = v39;
      }
      int v21 = v13;
      while (1)
      {
        uint64_t v18 = (v21 + 1);
        if (v20 - 1 == v21) {
          break;
        }
        ++v21;
        LODWORD(v13) = v18;
        if ((*(_DWORD *)(v38 + 32 * v18 + 8) & 0x80000000) != 0) {
          goto LABEL_28;
        }
      }
      LODWORD(v13) = v20;
LABEL_28:
      ;
    }
    while (v12 != v13);
  }
  re::HashTable<unsigned long long,NS::SharedPtr<MTL::SamplerState>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v37);
LABEL_30:
  if (*(void *)(a1 + 48))
  {
    unint64_t v22 = v6 % *(unsigned int *)(a1 + 72);
    uint64_t v23 = *(unsigned int *)(*(void *)(a1 + 56) + 4 * v22);
    if (v23 != 0x7FFFFFFF)
    {
      uint64_t v24 = *(void *)(a1 + 64);
      if (*(void *)(v24 + (v23 << 6) + 8) == v6) {
        goto LABEL_43;
      }
      while (1)
      {
        uint64_t v23 = *(_DWORD *)(v24 + (v23 << 6)) & 0x7FFFFFFF;
        if (v23 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v24 + (v23 << 6) + 8) == v6) {
          goto LABEL_43;
        }
      }
    }
  }
  else
  {
    LODWORD(v22) = 0;
  }
  uint64_t v25 = *(unsigned int *)(a1 + 84);
  if (v25 == 0x7FFFFFFF)
  {
    uint64_t v25 = *(unsigned int *)(a1 + 80);
    int v26 = v25;
    if (v25 == *(_DWORD *)(a1 + 72))
    {
      re::HashTable<unsigned long,re::HashSet<unsigned short,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(a1 + 48, 2 * *(_DWORD *)(a1 + 76));
      LODWORD(v22) = v6 % *(unsigned int *)(a1 + 72);
      int v26 = *(_DWORD *)(a1 + 80);
    }
    *(_DWORD *)(a1 + 80) = v26 + 1;
    uint64_t v27 = *(void *)(a1 + 64);
    int v28 = *(_DWORD *)(v27 + (v25 << 6));
  }
  else
  {
    uint64_t v27 = *(void *)(a1 + 64);
    int v28 = *(_DWORD *)(v27 + (v25 << 6));
    *(_DWORD *)(a1 + 84) = v28 & 0x7FFFFFFF;
  }
  uint64_t v29 = v25 << 6;
  *(_DWORD *)(v27 + v29) = v28 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 64) + v29) = *(_DWORD *)(*(void *)(a1 + 64) + (v25 << 6)) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 56) + 4 * v22);
  *(void *)(*(void *)(a1 + 64) + (v25 << 6) + 8) = v6;
  re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::HashSetBase(*(void *)(a1 + 64) + (v25 << 6) + 16, (uint64_t)v31);
  *(_DWORD *)(*(void *)(a1 + 56) + 4 * v22) = v25;
  ++*(_DWORD *)(a1 + 76);
  ++*(_DWORD *)(a1 + 88);
LABEL_43:
  re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit((uint64_t *)v31);
  if (v34) {
}
  }

re *re::APIFunctionCache::deinit(re *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((unsigned int *)this + 8);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (int *)*((void *)this + 2);
    while (1)
    {
      int v5 = *v4;
      v4 += 6;
      if (v5 < 0) {
        break;
      }
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 8);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (v2 != v3)
  {
    uint64_t v6 = v3;
    do
    {
      uint64_t v7 = *((void *)v1 + 2) + 24 * v6;
      *(void *)&long long v10 = *(void *)(v7 + 16);
      BYTE8(v10) = 1;
      HIDWORD(v10) = 5;
      uint64_t v11 = v10;
      long long v12 = v10;
      std::__libcpp_thread_poll_with_backoff[abi:nn180100]<std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<re::VertexFetchCompilationState,std::__cxx_atomic_base_impl<re::VertexFetchCompilationState>>,re::VertexFetchCompilationState> &,std::__libcpp_atomic_wait_backoff_impl<std::__cxx_atomic_impl<re::VertexFetchCompilationState,std::__cxx_atomic_base_impl<re::VertexFetchCompilationState>>,std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<re::VertexFetchCompilationState,std::__cxx_atomic_base_impl<re::VertexFetchCompilationState>>,re::VertexFetchCompilationState>> &>((uint64_t)&v10, (uint64_t)&v11, 0);
      this = re::internal::destroyPersistent<re::CachedAPIFunction>((re *)"deinit", 55, *(void *)(v7 + 16));
      if (*((_DWORD *)v1 + 8) <= (v3 + 1)) {
        int v8 = v3 + 1;
      }
      else {
        int v8 = *((_DWORD *)v1 + 8);
      }
      int v9 = v3;
      while (1)
      {
        uint64_t v6 = (v9 + 1);
        if (v8 - 1 == v9) {
          break;
        }
        ++v9;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((void *)v1 + 2) + 24 * v6) & 0x80000000) != 0) {
          goto LABEL_17;
        }
      }
      LODWORD(v3) = v8;
LABEL_17:
      ;
    }
    while (v2 != v3);
  }
  return this;
}

re *re::internal::destroyPersistent<re::CachedAPIFunction>(re *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    int v5 = *(void **)(a3 + 8);
    if (v5)
    {

      *(void *)(a3 + 8) = 0;
    }
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 40);
    return (re *)v6(v4, a3);
  }
  return result;
}

double re::APIFunctionCache::getOrCreateAPIFunction(uint64_t a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, dispatch_group_t *a7, int a8, uint64_t a9, uint64_t a10, unint64_t a11)
{
  uint64_t v75 = *MEMORY[0x263EF8340];
  size_t v18 = strlen(__s);
  if (v18)
  {
    MurmurHash3_x64_128((uint64_t)__s, v18, 0, (unint64_t *)&v70);
    unint64_t v19 = (*((void *)&v70 + 1) - 0x61C8864680B583E9 + ((void)v70 << 6) + ((unint64_t)v70 >> 2)) ^ v70;
  }
  else
  {
    unint64_t v19 = 0;
  }
  LODWORD(v20) = 0x7FFFFFFF;
  if (*(void *)(a1 + 48))
  {
    uint64_t v21 = *(unsigned int *)(*(void *)(a1 + 56) + 4 * (v19 % *(unsigned int *)(a1 + 72)));
    if (v21 != 0x7FFFFFFF)
    {
      uint64_t v22 = *(void *)(a1 + 64);
      LODWORD(v20) = *(_DWORD *)(*(void *)(a1 + 56) + 4 * (v19 % *(unsigned int *)(a1 + 72)));
      if (*(void *)(v22 + (v21 << 6) + 8) != v19)
      {
        uint64_t v20 = *(unsigned int *)(*(void *)(a1 + 56) + 4 * (v19 % *(unsigned int *)(a1 + 72)));
        while (1)
        {
          uint64_t v20 = *(_DWORD *)(v22 + (v20 << 6)) & 0x7FFFFFFF;
          if (v20 == 0x7FFFFFFF) {
            break;
          }
          if (*(void *)(v22 + (v20 << 6) + 8) == v19) {
            goto LABEL_12;
          }
        }
        LODWORD(v20) = 0x7FFFFFFF;
      }
    }
  }
LABEL_12:
  unint64_t As64Bits = re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::HashSetBase((uint64_t)v57, *(void *)(a1 + 64) + ((unint64_t)v20 << 6) + 16);
  if (!v58)
  {
    unsigned int v40 = 0x7FFFFFFF;
    if (*(void *)a1)
    {
      unsigned int v41 = *(_DWORD *)(*(void *)(a1 + 8) + 4 * (v19 % *(unsigned int *)(a1 + 24)));
      if (v41 != 0x7FFFFFFF)
      {
        uint64_t v42 = *(void *)(a1 + 16);
        unsigned int v40 = *(_DWORD *)(*(void *)(a1 + 8) + 4 * (v19 % *(unsigned int *)(a1 + 24)));
        if (*(void *)(v42 + 24 * v41 + 8) != v19)
        {
          while (1)
          {
            unsigned int v40 = *(_DWORD *)(v42
                            + 24 * *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v19 % *(unsigned int *)(a1 + 24)))) & 0x7FFFFFFF;
            if (v40 == 0x7FFFFFFF) {
              break;
            }
            if (*(void *)(v42 + 24 * v40 + 8) == v19) {
              goto LABEL_43;
            }
          }
          unsigned int v40 = 0x7FFFFFFF;
        }
      }
    }
LABEL_43:
    unint64_t v49 = *(void *)(a10 + 8);
    if (v49 > a11)
    {
      uint64_t v50 = (void **)(*(void *)(*(void *)(a1 + 16) + 24 * v40 + 16) + 8);
      uint64_t v51 = (void **)(*(void *)(a10 + 16) + 8 * a11);
      goto LABEL_45;
    }
    uint64_t v59 = 0;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v70 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)float32x4_t v63 = 136315906;
    *(void *)&v63[4] = "operator[]";
    __int16 v64 = 1024;
    int v65 = 468;
    __int16 v66 = 2048;
    unint64_t v67 = a11;
    __int16 v68 = 2048;
    unint64_t v69 = v49;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_48:
    uint64_t v59 = 0;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v70 = 0u;
    unint64_t v53 = v48;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)float32x4_t v63 = 136315906;
    *(void *)&v63[4] = "operator[]";
    __int16 v64 = 1024;
    int v65 = 468;
    __int16 v66 = 2048;
    unint64_t v67 = v53;
    __int16 v68 = 2048;
    unint64_t v69 = v49;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  int v54 = a8;
  uint64_t v24 = 0;
  if (a5)
  {
    uint64_t v25 = a5 << 6;
    int v26 = (unsigned __int16 *)(a4 + 34);
    do
    {
      unint64_t As64Bits = re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::contains((uint64_t)v57, v26);
      if (As64Bits)
      {
        unint64_t As64Bits = re::TechniqueFunctionConstant::getAs64Bits((re::TechniqueFunctionConstant *)(v26 - 17));
        unint64_t v27 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (As64Bits ^ (As64Bits >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                        * (As64Bits ^ (As64Bits >> 30))) >> 27));
        unint64_t v28 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * *v26) ^ ((0xBF58476D1CE4E5B9 * *v26) >> 27));
        v24 ^= v27 ^ (v27 >> 31) ^ ((v28 ^ (v28 >> 31))
                                  - 0x61C8864680B583E9
                                  + ((v27 ^ (v27 >> 31)) << 6)
                                  + ((v27 ^ (v27 >> 31)) >> 2));
      }
      v26 += 32;
      v25 -= 64;
    }
    while (v25);
  }
  unint64_t v29 = ((v19 << 6) - 0x61C8864680B583E9 + (v19 >> 2) + v24) ^ v19;
  unint64_t v56 = v29;
  if (*(void *)a1)
  {
    uint64_t v30 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v29 % *(unsigned int *)(a1 + 24)));
    if (v30 != 0x7FFFFFFF)
    {
      uint64_t v43 = *(void *)(a1 + 16);
      while (*(void *)(v43 + 24 * v30 + 8) != v29)
      {
        LODWORD(v30) = *(_DWORD *)(v43 + 24 * v30) & 0x7FFFFFFF;
        if (v30 == 0x7FFFFFFF) {
          goto LABEL_20;
        }
      }
      uint64_t v44 = v43 + 24 * v30;
      uint64_t v46 = *(unsigned __int8 **)(v44 + 16);
      uint64_t v45 = (uint64_t *)(v44 + 16);
      int v47 = atomic_load(v46);
      if (v47 != 2)
      {
        uint64_t v32 = *v45;
        char v33 = 1;
        goto LABEL_21;
      }
      unint64_t v48 = a11;
      unint64_t v49 = *(void *)(a10 + 8);
      if (v49 > a11)
      {
        uint64_t v50 = (void **)(*v45 + 8);
        uint64_t v51 = (void **)(*(void *)(a10 + 16) + 8 * a11);
LABEL_45:
        NS::SharedPtr<MTL::Texture>::operator=(v51, v50);
        return re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit(v57);
      }
      goto LABEL_48;
    }
  }
LABEL_20:
  uint64_t v31 = re::globalAllocators((re *)As64Bits);
  uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v31[2] + 32))(v31[2], 16, 8);
  *(void *)uint64_t v32 = 0;
  *(void *)(v32 + 8) = 0;
  *(void *)&long long v70 = v32;
  atomic_store(1u, (unsigned __int8 *)v32);
  re::HashTable<unsigned long,re::CachedAPIFunction *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add<re::CachedAPIFunction *&>(a1, &v56, &v70);
  char v33 = 0;
LABEL_21:
  uint64_t v34 = mach_absolute_time();
  *(void *)&long long v70 = *(id *)(a3 + 248);
  re::ShaderManager::makeFunctionDescriptor(a3, (uint64_t)__s, a6, &v70, *(void *)(a3 + 256), v63);
  dispatch_group_enter(*a7);
  id v35 = (id)v70;
  id v36 = *(id *)v63;
  long long v37 = *a7;
  uint64_t v38 = re::globalAllocators(v37)[2];
  uint64_t v61 = v38;
  if (v38) {
    uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v38 + 32))(v38, 104, 0);
  }
  else {
    uint64_t v39 = 0;
  }
  *(void *)uint64_t v39 = &unk_26E7143E8;
  *(void *)(v39 + 8) = v35;
  *(void *)(v39 + 16) = v36;
  *(void *)(v39 + 24) = a10;
  *(void *)(v39 + 32) = a11;
  *(void *)(v39 + 40) = v34;
  *(void *)(v39 + 48) = __s;
  *(void *)(v39 + 56) = a9;
  *(unsigned char *)(v39 + 64) = v54;
  *(void *)(v39 + 72) = v37;
  *(void *)(v39 + 80) = v32;
  *(unsigned char *)(v39 + 88) = v33;
  *(void *)(v39 + 96) = v24;
  uint64_t v62 = v39;
  re::ShaderManager::scheduleAsyncFuncOnCompilationQueue(a3, v54, a9, (uint64_t)v60);
  re::FunctionBase<24ul,void ()(void)>::destroyCallable((uint64_t)v60);
  if (v36) {

  }
  if (*(void *)v63) {
  return re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::deinit(v57);
  }
}

void re::HashTable<unsigned long,re::CachedAPIFunction *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::add<re::CachedAPIFunction *&>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)a1;
  if (*(void *)a1)
  {
    unint64_t v7 = v6 % *(unsigned int *)(a1 + 24);
    uint64_t v8 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v7);
    if (v8 != 0x7FFFFFFF)
    {
      uint64_t v13 = *(void *)(a1 + 16);
      if (*(void *)(v13 + 24 * v8 + 8) == v6) {
        return;
      }
      while (1)
      {
        LODWORD(v8) = *(_DWORD *)(v13 + 24 * v8) & 0x7FFFFFFF;
        if (v8 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v13 + 24 * v8 + 8) == v6) {
          return;
        }
      }
    }
  }
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long,re::CachedAPIFunction *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v7) = v6 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
      unint64_t v6 = *a2;
    }
    else
    {
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v9);
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v11 + 24 * v9);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  uint64_t v14 = 24 * v9;
  *(_DWORD *)(v11 + v14) = v12 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v14) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v9) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * v7);
  *(void *)(*(void *)(a1 + 16) + 24 * v9 + 8) = v6;
  *(void *)(*(void *)(a1 + 16) + 24 * v9 + 16) = *a3;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v7) = v9;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
}

uint64_t re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::HashSetBase(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 36) = 0x7FFFFFFFLL;
  uint64_t v4 = *(void *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u) {
      signed int v5 = 3;
    }
    else {
      signed int v5 = *(_DWORD *)(a2 + 28);
    }
    re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::init(a1, v4, v5);
    re::HashSetBase<unsigned short,unsigned short,re::internal::ValueAsKey<unsigned short>,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::internal::Callable<re::APIFunctionCache::getOrCreateAPIFunction(char const*,re::ShaderManager const*,re::Slice<re::TechniqueFunctionConstant>,NS::SharedPtr<MTL::FunctionConstantValues> const&,re::dispatch::Group,BOOL,unsigned long long,re::FixedArray<NS::SharedPtr<MTL::Function>> &,unsigned long)::$_0,void ()(void)>::~Callable(uint64_t a1)
{
  *(void *)a1 = &unk_26E7143E8;

  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {

    *(void *)(a1 + 16) = 0;
  }

  return a1;
}

void re::internal::Callable<re::APIFunctionCache::getOrCreateAPIFunction(char const*,re::ShaderManager const*,re::Slice<re::TechniqueFunctionConstant>,NS::SharedPtr<MTL::FunctionConstantValues> const&,re::dispatch::Group,BOOL,unsigned long long,re::FixedArray<NS::SharedPtr<MTL::Function>> &,unsigned long)::$_0,void ()(void)>::~Callable(uint64_t a1)
{
  *(void *)a1 = &unk_26E7143E8;

  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {

    *(void *)(a1 + 16) = 0;
  }

  JUMPOUT(0x237DBCBD0);
}

void re::internal::Callable<re::APIFunctionCache::getOrCreateAPIFunction(char const*,re::ShaderManager const*,re::Slice<re::TechniqueFunctionConstant>,NS::SharedPtr<MTL::FunctionConstantValues> const&,re::dispatch::Group,BOOL,unsigned long long,re::FixedArray<NS::SharedPtr<MTL::Function>> &,unsigned long)::$_0,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (re::internal::enableSignposts(0, 0)) {
    kdebug_trace();
  }
  uint64_t v2 = mach_absolute_time();
  if (*(unsigned char *)(a1 + 88))
  {
    *(void *)unint64_t v19 = *(void *)(a1 + 80);
    v19[8] = 1;
    *(_DWORD *)&v19[12] = 5;
    v24[0] = *(id *)v19;
    *(_OWORD *)&v24[1] = *(_OWORD *)v19;
    std::__libcpp_thread_poll_with_backoff[abi:nn180100]<std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<re::VertexFetchCompilationState,std::__cxx_atomic_base_impl<re::VertexFetchCompilationState>>,re::VertexFetchCompilationState> &,std::__libcpp_atomic_wait_backoff_impl<std::__cxx_atomic_impl<re::VertexFetchCompilationState,std::__cxx_atomic_base_impl<re::VertexFetchCompilationState>>,std::__cxx_atomic_wait_test_fn_impl<std::__cxx_atomic_impl<re::VertexFetchCompilationState,std::__cxx_atomic_base_impl<re::VertexFetchCompilationState>>,re::VertexFetchCompilationState>> &>((uint64_t)v19, (uint64_t)v24, 0);
  }
  else
  {
    re::mtl::Library::makeFunctionWithDescriptor((id *)(a1 + 8), *(void **)(a1 + 16), v24);
    NS::SharedPtr<MTL::Texture>::operator=((void **)(*(void *)(a1 + 80) + 8), v24);
    atomic_store(2u, *(unsigned __int8 **)(a1 + 80));
    MEMORY[0x237DBC9B0](*(void *)(a1 + 80));
    if (v24[0]) {
  }
    }
  uint64_t v3 = *(void *)(a1 + 24);
  unint64_t v4 = *(void *)(a1 + 32);
  unint64_t v5 = *(void *)(v3 + 8);
  if (v5 <= v4)
  {
    long long v25 = 0u;
    long long v26 = 0u;
    memset(v24, 0, sizeof(v24));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unint64_t v19 = 136315906;
    *(void *)&v19[4] = "operator[]";
    *(_WORD *)&v19[12] = 1024;
    *(_DWORD *)&v19[14] = 468;
    __int16 v20 = 2048;
    unint64_t v21 = v4;
    __int16 v22 = 2048;
    unint64_t v23 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  NS::SharedPtr<MTL::Texture>::operator=((void **)(*(void *)(v3 + 16) + 8 * v4), (void **)(*(void *)(a1 + 80) + 8));
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 72));
  uint64_t v6 = mach_absolute_time();
  uint64_t v7 = re::internal::enableSignposts(0, 0);
  if (v7) {
    uint64_t v7 = kdebug_trace();
  }
  double v8 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    uint64_t v7 = mach_timebase_info((mach_timebase_info_t)v24);
    if (v7)
    {
      double v8 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      double v11 = NAN;
      goto LABEL_15;
    }
    LODWORD(v10) = HIDWORD(v24[0]);
    LODWORD(v9) = v24[0];
    double v8 = (double)v9 / (double)v10;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v8;
  }
  double v11 = v8 * (double)(v6 - v2);
LABEL_15:
  uint64_t v12 = *(void *)(a1 + 40);
  if (v8 < 0.0)
  {
    uint64_t v7 = mach_timebase_info((mach_timebase_info_t)v24);
    if (v7)
    {
      double v15 = NAN;
      goto LABEL_20;
    }
    LODWORD(v14) = HIDWORD(v24[0]);
    LODWORD(v13) = v24[0];
    double v8 = (double)v13 / (double)v14;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(void *)&v8;
  }
  double v15 = v8 * (double)(v6 - v12);
LABEL_20:
  id v16 = *re::graphicsLogObjects((re *)v7);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = *(void **)(a1 + 48);
    size_t v18 = *(void **)(a1 + 96);
    LODWORD(v24[0]) = 136446978;
    *(id *)((char *)v24 + 4) = v17;
    WORD2(v24[1]) = 2048;
    *(id *)((char *)&v24[1] + 6) = v18;
    HIWORD(v24[2]) = 1024;
    LODWORD(v24[3]) = (int)(v11 / 1000000.0);
    WORD2(v24[3]) = 1024;
    *(_DWORD *)((char *)&v24[3] + 6) = (int)(v15 / 1000000.0);
    _os_log_impl(&dword_233120000, v16, OS_LOG_TYPE_DEFAULT, "API function compilation completed for %{public}s %zu in %d (elapsed %d)", (uint8_t *)v24, 0x22u);
  }
}

uint64_t re::internal::Callable<re::APIFunctionCache::getOrCreateAPIFunction(char const*,re::ShaderManager const*,re::Slice<re::TechniqueFunctionConstant>,NS::SharedPtr<MTL::FunctionConstantValues> const&,re::dispatch::Group,BOOL,unsigned long long,re::FixedArray<NS::SharedPtr<MTL::Function>> &,unsigned long)::$_0,void ()(void)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E7143E8;
  *(void *)(a2 + 8) = *(id *)(a1 + 8);
  *(void *)(a2 + 16) = *(id *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 40);
  long long v5 = *(_OWORD *)(a1 + 49);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 49) = v5;
  *(_OWORD *)(a2 + 40) = v4;
  *(void *)(a2 + 72) = *(id *)(a1 + 72);
  uint64_t v6 = *(void *)(a1 + 96);
  *(_OWORD *)(a2 + 80) = *(_OWORD *)(a1 + 80);
  *(void *)(a2 + 96) = v6;
  return a2;
}

uint64_t re::internal::Callable<re::APIFunctionCache::getOrCreateAPIFunction(char const*,re::ShaderManager const*,re::Slice<re::TechniqueFunctionConstant>,NS::SharedPtr<MTL::FunctionConstantValues> const&,re::dispatch::Group,BOOL,unsigned long long,re::FixedArray<NS::SharedPtr<MTL::Function>> &,unsigned long)::$_0,void ()(void)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 8);
  long long v4 = *(void **)(a1 + 16);
  *(void *)(a1 + 8) = 0;
  *(void *)a2 = &unk_26E7143E8;
  *(void *)(a2 + 8) = v5;
  *(void *)(a2 + 16) = v4;
  long long v6 = *(_OWORD *)(a1 + 49);
  long long v7 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = v7;
  *(_OWORD *)(a2 + 49) = v6;
  uint64_t v8 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  *(void *)(a2 + 72) = v8;
  uint64_t v9 = *(void *)(a1 + 96);
  *(_OWORD *)(a2 + 80) = *(_OWORD *)(a1 + 80);
  *(void *)(a2 + 96) = v9;
  return a2;
}

uint64_t re::internal::Callable<re::APIFunctionCache::getOrCreateAPIFunction(char const*,re::ShaderManager const*,re::Slice<re::TechniqueFunctionConstant>,NS::SharedPtr<MTL::FunctionConstantValues> const&,re::dispatch::Group,BOOL,unsigned long long,re::FixedArray<NS::SharedPtr<MTL::Function>> &,unsigned long)::$_0,void ()(void)>::size()
{
  return 104;
}

void re::HashTable<unsigned long,re::CachedAPIFunction *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v24, 0, 36);
      *(void *)&v24[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v24, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v24;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v24[8];
      *(_OWORD *)uint64_t v24 = v5;
      *(void *)&v24[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v24[24];
      *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v24[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        unint64_t v14 = (unint64_t *)(v6 + 8);
        do
        {
          if ((*(_DWORD *)(v14 - 1) & 0x80000000) != 0)
          {
            unint64_t v15 = *v14;
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = *v14 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<unsigned long,re::CachedAPIFunction *,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
                unint64_t v15 = *v14;
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 24 * v18);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 24 * v18);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            uint64_t v22 = 24 * v18;
            *(_DWORD *)(v20 + v22) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + v22) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v18) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 24 * v18 + 8) = v15;
            *(void *)(*(void *)(a1 + 16) + 24 * v18 + 16) = v14[1];
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 3;
        }
        while (v11 < v10);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v24);
    }
  }
  else
  {
    if (a2) {
      signed int v23 = a2;
    }
    else {
      signed int v23 = 3;
    }
  }
}

void re::HashTable<unsigned long,re::HashSet<unsigned short,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(void *)&v25[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v25, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v25;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v25[8];
      *(_OWORD *)long long v25 = v5;
      *(void *)&v25[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v25[24];
      *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        unint64_t v14 = (uint64_t *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v14 - 2) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 1);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<unsigned long,re::HashSet<unsigned short,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
                unint64_t v15 = *(v14 - 1);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + (v18 << 6));
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + (v18 << 6));
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            uint64_t v22 = v18 << 6;
            *(_DWORD *)(v20 + v22) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + v22) = *(_DWORD *)(*(void *)(a1 + 16) + (v18 << 6)) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + (v18 << 6) + 8) = v15;
            uint64_t v23 = *(void *)(a1 + 16) + (v18 << 6);
            *(_OWORD *)(v23 + 16) = 0u;
            v23 += 16;
            *(_DWORD *)(v23 + 32) = 0;
            *(_OWORD *)(v23 + 16) = 0u;
            *(void *)(v23 + 36) = 0x7FFFFFFFLL;
            re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v23, v14);
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 8;
        }
        while (v11 < v10);
      }
      re::HashTable<unsigned long,re::HashSet<unsigned short,re::Hash<unsigned short>,re::EqualTo<unsigned short>,true,false>,re::PrecalculatedHash,re::EqualTo<unsigned long>,false,false>::deinit((uint64_t *)v25);
    }
  }
  else
  {
    if (a2) {
      signed int v24 = a2;
    }
    else {
      signed int v24 = 3;
    }
  }
}

re::FileStreamReader *re::FileStreamReader::FileStreamReader(re::FileStreamReader *this, __sFILE *a2, char a3)
{
  *(void *)this = &unk_26E714440;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = 0;
  *((unsigned char *)this + 24) = a3;
  uint64_t v5 = MEMORY[0x237DBD630](a2);
  fseek(a2, 0, 2);
  *((void *)this + 2) = MEMORY[0x237DBD630](a2);
  fseek(a2, v5, 0);
  return this;
}

void re::FileStreamReader::~FileStreamReader(re::FileStreamReader *this)
{
  uint64_t v2 = (FILE *)*((void *)this + 1);
  if (v2)
  {
    if (*((unsigned char *)this + 24))
    {
      fclose(v2);
      *((void *)this + 1) = 0;
      *((unsigned char *)this + 24) = 0;
    }
  }
}

{
  FILE *v2;
  uint64_t vars8;

  uint64_t v2 = (FILE *)*((void *)this + 1);
  if (v2 && *((unsigned char *)this + 24))
  {
    fclose(v2);
    *((void *)this + 1) = 0;
    *((unsigned char *)this + 24) = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

__n128 re::FileStreamReader::open@<Q0>(re::FileStreamReader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = fopen((const char *)this, "rb");
  if (v5)
  {
    re::FileStreamReader::FileStreamReader((re::FileStreamReader *)&v14, v5, 1);
    char v7 = v16;
    unint64_t v8 = v14.n128_u64[1];
    uint64_t v9 = v15;
    *(unsigned char *)a2 = 1;
    *(void *)(a2 + 8) = &unk_26E714440;
    *(void *)(a2 + 16) = v8;
    *(unsigned char *)(a2 + 32) = v7;
    *(void *)(a2 + 24) = v9;
  }
  else
  {
    unint64_t v10 = __error();
    unint64_t v11 = strerror(*v10);
    re::DynamicString::format((re::DynamicString *)"Failed to open file \"%s\" for reading. Details: %s", (re::DynamicString *)&v14, this, v11);
    __n128 result = v14;
    uint64_t v12 = v15;
    uint64_t v13 = v16;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 300;
    *(void *)(a2 + 16) = re::FoundationErrorCategory(void)::instance;
    *(__n128 *)(a2 + 24) = result;
    *(void *)(a2 + 40) = v12;
    *(void *)(a2 + 48) = v13;
  }
  return result;
}

size_t re::FileStreamReader::readBytes(FILE **this, void *__ptr, size_t a3)
{
  return fread(__ptr, 1uLL, a3, this[1]);
}

fpos_t re::FileStreamReader::bytesRead(FILE **this)
{
  fpos_t v2 = 0;
  fgetpos(this[1], &v2);
  return v2;
}

uint64_t re::FileStreamReader::bytesRemaining(re::FileStreamReader *this)
{
  fpos_t v3 = 0;
  uint64_t v1 = *((void *)this + 2);
  fgetpos(*((FILE **)this + 1), &v3);
  return v1 - v3;
}

unint64_t re::FileStreamReader::skipBytes(re::FileStreamReader *this, unint64_t a2)
{
  fpos_t v6 = 0;
  uint64_t v4 = *((void *)this + 2);
  fgetpos(*((FILE **)this + 1), &v6);
  if (v4 - v6 < a2) {
    a2 = v4 - v6;
  }
  if (fseek(*((FILE **)this + 1), a2, 1)) {
    return 0;
  }
  else {
    return a2;
  }
}

BOOL re::FileStreamReader::seek(re::FileStreamReader *this, unint64_t a2)
{
  fpos_t v6 = 0;
  uint64_t v4 = *((void *)this + 2);
  fgetpos(*((FILE **)this + 1), &v6);
  return v4 - v6 >= a2 && fseek(*((FILE **)this + 1), a2, 0) == 0;
}

uint64_t re::StreamReader::seekAndRead(re::StreamReader *this, void *a2)
{
  return 0;
}

uint64_t re::ExternalMemorySeekableInputStream::ExternalMemorySeekableInputStream(uint64_t a1, re::FixedArrayInputStream *a2)
{
  *(void *)a1 = &unk_26E7144B8;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  uint64_t v4 = *((void *)a2 + 3);
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(void *)(a1 + 24) = v4;
  re::FixedArrayInputStream::FixedArrayInputStream((re::FixedArrayInputStream *)(a1 + 32), *((const char **)a2 + 2), *((_DWORD *)a2 + 6), -1);
  uint64_t v5 = (*(uint64_t (**)(re::FixedArrayInputStream *))(*(void *)a2 + 40))(a2);
  if (v5) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, v5);
  }
  re::ExternalMemorySeekableInputStream::postDetachCleanup(a2);
  return a1;
}

re::FixedArrayInputStream *re::ExternalMemorySeekableInputStream::postDetachCleanup(re::FixedArrayInputStream *this)
{
  if (!*((unsigned char *)this + 8))
  {
    uint64_t v1 = (re::FixedArrayInputStream *)((char *)this + 32);
    (**((void (***)(uint64_t))this + 4))((uint64_t)this + 32);
    this = re::FixedArrayInputStream::FixedArrayInputStream(v1, 0, 0, -1);
    *((unsigned char *)v1 - 24) = 1;
    *((void *)v1 - 2) = 0;
    *((void *)v1 - 1) = 0;
  }
  return this;
}

uint64_t re::ExternalMemorySeekableInputStream::operator=(uint64_t a1, re::FixedArrayInputStream *a2)
{
  uint64_t v5 = (re::FixedArrayInputStream *)(a1 + 32);
  uint64_t v4 = *(void (***)(uint64_t))(a1 + 32);
  uint64_t v6 = *((void *)a2 + 3);
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(void *)(a1 + 24) = v6;
  *(unsigned char *)(a1 + 8) = *((unsigned char *)a2 + 8);
  (*v4)(a1 + 32);
  re::FixedArrayInputStream::FixedArrayInputStream(v5, *((const char **)v5 - 2), *((_DWORD *)v5 - 2), -1);
  uint64_t v7 = (*(uint64_t (**)(re::FixedArrayInputStream *))(*(void *)a2 + 40))(a2);
  if (v7) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, v7);
  }
  re::ExternalMemorySeekableInputStream::postDetachCleanup(a2);
  return a1;
}

BOOL re::ExternalMemorySeekableInputStream::Seek(re::ExternalMemorySeekableInputStream *this, unint64_t a2)
{
  unint64_t v3 = *((void *)this + 3);
  if (v3 >= a2) {
    google::protobuf::io::ArrayInputStream::Seek((re::ExternalMemorySeekableInputStream *)((char *)this + 56), a2);
  }
  return v3 >= a2;
}

uint64_t re::ExternalMemorySeekableInputStream::CreateDetached(re::ExternalMemorySeekableInputStream *this)
{
  int __dst = 0;
  memset(v10, 0, sizeof(v10));
  uint64_t v9 = 0;
  int v11 = 0;
  re::DynamicArray<char>::resize((uint64_t)&v9, *((void *)this + 3));
  fpos_t v2 = (re *)memcpy(__dst, *((const void **)this + 2), *((void *)this + 3));
  unint64_t v3 = re::globalAllocators(v2);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[2] + 32))(v3[2], 136, 8);
  uint64_t v5 = (const char *)__dst;
  uint64_t v6 = *(void *)&v10[2];
  *(void *)uint64_t v4 = &unk_26E7144B8;
  *(unsigned char *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = v5;
  *(void *)(v4 + 24) = v6;
  re::FixedArrayInputStream::FixedArrayInputStream((re::FixedArrayInputStream *)(v4 + 32), v5, v6, -1);
  *(void *)uint64_t v4 = &unk_26E714668;
  *(void *)(v4 + 96) = v9;
  *(_OWORD *)(v4 + 104) = *(_OWORD *)v10;
  uint64_t v9 = 0;
  memset(v10, 0, sizeof(v10));
  *(void *)(v4 + 128) = __dst;
  int __dst = 0;
  ++v11;
  *(_DWORD *)(v4 + 120) = 1;
  uint64_t v7 = (*(uint64_t (**)(re::ExternalMemorySeekableInputStream *))(*(void *)this + 40))(this);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 56))(v4, v7);
  re::ExternalMemorySeekableInputStream::postDetachCleanup(this);
  if (v9 && __dst) {
    (*(void (**)(void))(*(void *)v9 + 40))();
  }
  return v4;
}

uint64_t re::DataSeekableInputStream::DataSeekableInputStream(uint64_t a1, id *a2, char a3, char a4)
{
  if (!*a2)
  {
    unint64_t v8 = 0;
    goto LABEL_5;
  }
  unint64_t v8 = (const char *)[*a2 bytes];
  if (!*a2)
  {
LABEL_5:
    uint64_t v9 = 0;
    goto LABEL_6;
  }
  uint64_t v9 = [*a2 length];
LABEL_6:
  *(void *)a1 = &unk_26E7144B8;
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 24) = v9;
  re::FixedArrayInputStream::FixedArrayInputStream((re::FixedArrayInputStream *)(a1 + 32), v8, v9, -1);
  *(void *)a1 = &unk_26E714530;
  *(void *)(a1 + 96) = *a2;
  *(unsigned char *)(a1 + 104) = a3;
  *(unsigned char *)(a1 + 105) = a4;
  return a1;
}

uint64_t re::DataSeekableInputStream::DataSeekableInputStream(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = re::ExternalMemorySeekableInputStream::ExternalMemorySeekableInputStream(a1, (re::FixedArrayInputStream *)a2);
  *(void *)uint64_t v4 = &unk_26E714530;
  uint64_t v5 = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = 0;
  *(void *)(v4 + 96) = v5;
  *(unsigned char *)(v4 + 104) = *(unsigned char *)(a2 + 104);
  *(unsigned char *)(v4 + 105) = *(unsigned char *)(a2 + 105);
  re::DataSeekableInputStream::postDetachCleanup((re::DataSeekableInputStream *)a2);
  return a1;
}

re::FixedArrayInputStream *re::DataSeekableInputStream::postDetachCleanup(re::DataSeekableInputStream *this)
{
  fpos_t v2 = (void *)*((void *)this + 12);
  *((void *)this + 12) = 0;

  *((_WORD *)this + 52) = 0;
  return re::ExternalMemorySeekableInputStream::postDetachCleanup(this);
}

uint64_t re::DataSeekableInputStream::operator=(uint64_t a1, uint64_t a2)
{
  re::ObjCObject::operator=((id *)(a1 + 96), (id *)(a2 + 96));
  *(_WORD *)(a1 + 104) = *(_WORD *)(a2 + 104);
  re::ExternalMemorySeekableInputStream::operator=(a1, (re::FixedArrayInputStream *)a2);
  re::DataSeekableInputStream::postDetachCleanup((re::DataSeekableInputStream *)a2);
  return a1;
}

uint64_t re::DataSeekableInputStream::CreateDetached(id *this)
{
  if (*((unsigned char *)this + 104))
  {
    fpos_t v2 = re::globalAllocators((re *)this);
    uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 112, 8);
    re::DataSeekableInputStream::DataSeekableInputStream(v3, (uint64_t)this);
  }
  else
  {
    uint64_t v4 = (*((uint64_t (**)(id *))*this + 5))(this);
    re::Data::makeDataWithBytes((re::Data *)[this[12] bytes], (const void *)objc_msgSend(this[12], "length"), &v10);
    uint64_t v5 = re::DataSeekableInputStream::postDetachCleanup((re::DataSeekableInputStream *)this);
    uint64_t v6 = re::globalAllocators(v5);
    uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6[2] + 32))(v6[2], 112, 8);
    id v7 = v10;
    id v9 = v7;
    re::DataSeekableInputStream::DataSeekableInputStream(v3, &v9, 1, 0);

    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 56))(v3, v4);
  }
  return v3;
}

re::CFDataSeekableInputStream *re::CFDataSeekableInputStream::CFDataSeekableInputStream(re::CFDataSeekableInputStream *this, CFDataRef theData, char a3, char a4)
{
  if (theData)
  {
    BytePtr = (const char *)CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
  }
  else
  {
    BytePtr = 0;
    CFIndex Length = 0;
  }
  *(void *)this = &unk_26E7144B8;
  *((unsigned char *)this + 8) = 0;
  *((void *)this + 2) = BytePtr;
  *((void *)this + 3) = Length;
  re::FixedArrayInputStream::FixedArrayInputStream((re::CFDataSeekableInputStream *)((char *)this + 32), BytePtr, Length, -1);
  *(void *)this = &unk_26E7145A8;
  *((void *)this + 12) = theData;
  *((unsigned char *)this + 104) = a3;
  *((unsigned char *)this + 105) = a4;
  CFRetain(theData);
  return this;
}

uint64_t re::CFDataSeekableInputStream::CFDataSeekableInputStream(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = re::ExternalMemorySeekableInputStream::ExternalMemorySeekableInputStream(a1, (re::FixedArrayInputStream *)a2);
  *(void *)uint64_t v4 = &unk_26E7145A8;
  *(void *)(v4 + 96) = *(void *)(a2 + 96);
  *(_WORD *)(v4 + 104) = *(_WORD *)(a2 + 104);
  *(void *)(a2 + 96) = 0;
  re::CFDataSeekableInputStream::postDetachCleanup((re::CFDataSeekableInputStream *)a2);
  return a1;
}

re::FixedArrayInputStream *re::CFDataSeekableInputStream::postDetachCleanup(re::CFDataSeekableInputStream *this)
{
  fpos_t v2 = (const void *)*((void *)this + 12);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 12) = 0;
  }
  *((_WORD *)this + 52) = 0;
  return re::ExternalMemorySeekableInputStream::postDetachCleanup(this);
}

void re::CFDataSeekableInputStream::~CFDataSeekableInputStream(re::CFDataSeekableInputStream *this)
{
  *(void *)this = &unk_26E7145A8;
  re::CFDataSeekableInputStream::postDetachCleanup(this);
  *(void *)this = &unk_26E7144B8;
  re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)this + 32);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7145A8;
  re::CFDataSeekableInputStream::postDetachCleanup(this);
  *(void *)this = &unk_26E7144B8;
  re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)this + 32);
  JUMPOUT(0x237DBCBD0);
}

re::CFDataSeekableInputStream *re::CFDataSeekableInputStream::CreateDetached(const __CFData **this)
{
  if (!*((unsigned char *)this + 104))
  {
    uint64_t v4 = (*((uint64_t (**)(const __CFData **))*this + 5))(this);
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFDataRef v6 = this[12];
    if (v6)
    {
      BytePtr = CFDataGetBytePtr(v6);
      CFDataRef v8 = this[12];
      if (v8)
      {
        CFIndex Length = CFDataGetLength(v8);
LABEL_8:
        CFDataRef v10 = CFDataCreate(v5, BytePtr, Length);
        int v11 = re::CFDataSeekableInputStream::postDetachCleanup((re::CFDataSeekableInputStream *)this);
        uint64_t v12 = re::globalAllocators(v11);
        uint64_t v3 = (re::CFDataSeekableInputStream *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12[2] + 32))(v12[2], 112, 8);
        re::CFDataSeekableInputStream::CFDataSeekableInputStream(v3, v10, 1, 0);
        CFRelease(v10);
        (*(void (**)(re::CFDataSeekableInputStream *, uint64_t))(*(void *)v3 + 56))(v3, v4);
        return v3;
      }
    }
    else
    {
      BytePtr = 0;
    }
    CFIndex Length = 0;
    goto LABEL_8;
  }
  fpos_t v2 = re::globalAllocators((re *)this);
  uint64_t v3 = (re::CFDataSeekableInputStream *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 112, 8);
  re::CFDataSeekableInputStream::CFDataSeekableInputStream((uint64_t)v3, (uint64_t)this);
  return v3;
}

void re::ExternalMemorySeekableInputStream::~ExternalMemorySeekableInputStream(re::ExternalMemorySeekableInputStream *this)
{
  *(void *)this = &unk_26E7144B8;
  re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)this + 32);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26E7144B8;
  re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)this + 32);
  JUMPOUT(0x237DBCBD0);
}

BOOL re::ExternalMemorySeekableInputStream::Next(re::ExternalMemorySeekableInputStream *this, const void **a2, int *a3)
{
  uint64_t v3 = *((int *)this + 20);
  int v4 = *((_DWORD *)this + 18);
  if ((int)v3 >= v4)
  {
    *((_DWORD *)this + 21) = 0;
  }
  else
  {
    int v5 = v4 - v3;
    if (v4 - (int)v3 >= *((_DWORD *)this + 19)) {
      int v5 = *((_DWORD *)this + 19);
    }
    *((_DWORD *)this + 21) = v5;
    *a2 = (const void *)(*((void *)this + 8) + v3);
    *a3 = v5;
    *((_DWORD *)this + 20) += *((_DWORD *)this + 21);
  }
  return (int)v3 < v4;
}

void re::ExternalMemorySeekableInputStream::BackUp(re::ExternalMemorySeekableInputStream *this, int a2)
{
}

BOOL re::ExternalMemorySeekableInputStream::Skip(re::ExternalMemorySeekableInputStream *this, int a2)
{
  return google::protobuf::io::ArrayInputStream::Skip((re::ExternalMemorySeekableInputStream *)((char *)this + 56), a2);
}

uint64_t re::ExternalMemorySeekableInputStream::ByteCount(re::ExternalMemorySeekableInputStream *this)
{
  return *((int *)this + 20);
}

uint64_t re::ExternalMemorySeekableInputStream::CanSeek(re::ExternalMemorySeekableInputStream *this)
{
  return 1;
}

uint64_t re::ExternalMemorySeekableInputStream::Length(re::ExternalMemorySeekableInputStream *this)
{
  return *((void *)this + 3);
}

uint64_t re::ExternalMemorySeekableInputStream::AllInMemory(re::ExternalMemorySeekableInputStream *this)
{
  return 1;
}

uint64_t re::ExternalMemorySeekableInputStream::OwnsMemory(re::ExternalMemorySeekableInputStream *this)
{
  return 0;
}

void re::SeekableInputStream::FilePathAndOffset(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

BOOL re::DataSeekableInputStream::AllInMemory(re::DataSeekableInputStream *this)
{
  return *((unsigned char *)this + 105) == 0;
}

uint64_t re::DataSeekableInputStream::OwnsMemory(re::DataSeekableInputStream *this)
{
  return *((unsigned __int8 *)this + 104);
}

BOOL re::CFDataSeekableInputStream::AllInMemory(re::CFDataSeekableInputStream *this)
{
  return *((unsigned char *)this + 105) == 0;
}

uint64_t re::CFDataSeekableInputStream::OwnsMemory(re::CFDataSeekableInputStream *this)
{
  return *((unsigned __int8 *)this + 104);
}

void *re::internal::OwnedMemorySeekableInputStream<re::DynamicArray<char>>::~OwnedMemorySeekableInputStream(void *a1)
{
  *a1 = &unk_26E714668;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 12));
  *a1 = &unk_26E7144B8;
  re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)(a1 + 4));
  return a1;
}

void re::internal::OwnedMemorySeekableInputStream<re::DynamicArray<char>>::~OwnedMemorySeekableInputStream(void *a1)
{
  *a1 = &unk_26E714668;
  re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 12));
  *a1 = &unk_26E7144B8;
  re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)(a1 + 4));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::OwnedMemorySeekableInputStream<re::DynamicArray<char>>::CreateDetached(uint64_t a1)
{
  fpos_t v2 = re::globalAllocators((re *)a1);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 136, 8);
  uint64_t v4 = re::ExternalMemorySeekableInputStream::ExternalMemorySeekableInputStream(v3, (re::FixedArrayInputStream *)a1);
  *(void *)uint64_t v4 = &unk_26E714668;
  *(void *)(v4 + 128) = 0;
  *(_DWORD *)(v4 + 120) = 0;
  *(void *)(v4 + 104) = 0;
  *(void *)(v4 + 112) = 0;
  *(void *)(v4 + 96) = 0;
  uint64_t v5 = *(void *)(a1 + 104);
  *(void *)(v4 + 96) = *(void *)(a1 + 96);
  *(void *)(v4 + 104) = v5;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  uint64_t v6 = *(void *)(v4 + 112);
  *(void *)(v4 + 112) = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = v6;
  uint64_t v7 = *(void *)(v4 + 128);
  *(void *)(v4 + 128) = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = v7;
  ++*(_DWORD *)(a1 + 120);
  ++*(_DWORD *)(v4 + 120);
  re::ExternalMemorySeekableInputStream::postDetachCleanup((re::FixedArrayInputStream *)a1);
  return v3;
}

re::FileSeekableInputStream *re::FileSeekableInputStream::FileSeekableInputStream(re::FileSeekableInputStream *this, const char *a2, uint64_t a3, uint64_t a4)
{
  *(void *)this = &unk_26E714710;
  CFDataRef v8 = (re::FileSeekableInputStream *)((char *)this + 8);
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  re::DynamicString::setCapacity((void *)this + 5, 0);
  CFDataRef v10 = (_anonymous_namespace_ *)open(a2, 0);
  *((_DWORD *)this + 18) = v10;
  *((void *)this + 10) = a3;
  *((void *)this + 11) = a4;
  *((unsigned char *)this + 96) = 0;
  *((void *)this + 13) = &unk_26E6BE630;
  *((void *)this + 14) = &unk_26E6BE670;
  *((_DWORD *)this + 30) = v10;
  *((_WORD *)this + 62) = 0;
  *((_DWORD *)this + 32) = 0;
  *((unsigned char *)this + 132) = 0;
  *((void *)this + 17) = &unk_26E6BE818;
  *((void *)this + 18) = (char *)this + 112;
  *((_WORD *)this + 76) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0x2000;
  *((_DWORD *)this + 46) = 0;
  *((void *)this + 24) = (char *)this + 200;
  *((void *)this + 25) = &unk_26E7147A0;
  int v11 = *((_DWORD *)this + 18);
  if (v11 == -1)
  {
    uint64_t v13 = __error();
    __n128 v14 = strerror(*v13);
    re::DynamicString::operator=((re::FileSeekableInputStream *)((char *)this + 40), (re::DynamicString *)&v19);
    if (v19 && (v20 & 1) != 0) {
      (*(void (**)(void))(*(void *)v19 + 40))();
    }
    *((void *)this + 11) = 0;
  }
  else
  {
    if (a4 != -1)
    {
      unint64_t v12 = *((void *)this + 10);
      if (!v12) {
        return this;
      }
      goto LABEL_16;
    }
    *((void *)this + 11) = lseek(v11, 0, 2);
    lseek(*((_DWORD *)this + 18), 0, 0);
    unint64_t v12 = *((void *)this + 10);
    unint64_t v15 = *((void *)this + 11);
    BOOL v16 = v15 >= v12;
    unint64_t v17 = v15 - v12;
    if (v16)
    {
      *((void *)this + 11) = v17;
      if (!v12) {
        return this;
      }
      goto LABEL_16;
    }
    re::DynamicString::operator=((re::FileSeekableInputStream *)((char *)this + 40), (re::DynamicString *)&v19);
    if (v19 && (v20 & 1) != 0) {
      (*(void (**)(void))(*(void *)v19 + 40))();
    }
    unint64_t v12 = *((void *)this + 11);
    *((void *)this + 10) = v12;
    *((void *)this + 11) = 0;
    if (v12)
    {
LABEL_16:
      if (!google::protobuf::io::CopyingInputStreamAdaptor::Skip((re::FileSeekableInputStream *)((char *)this + 136), v12))
      {
        re::DynamicString::operator=((re::FileSeekableInputStream *)((char *)this + 40), (re::DynamicString *)&v19);
        if (v19)
        {
          if (v20) {
            (*(void (**)(void))(*(void *)v19 + 40))();
          }
        }
      }
    }
  }
  return this;
}

uint64_t re::FileSeekableInputStream::FileSeekableInputStream(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26E714710;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v5 = *(void *)(a2 + 24);
  *(void *)(a2 + 32) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = v5;
  *(void *)(a2 + 16) = v7;
  *(void *)(a2 + 24) = v6;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  CFDataRef v8 = (void *)(a1 + 40);
  re::DynamicString::setCapacity(v8, 0);
  int v9 = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 72) = v9;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(unsigned char *)(a1 + 96) = *(unsigned char *)(a2 + 96);
  *(void *)(a1 + 104) = &unk_26E6BE630;
  *(void *)(a1 + 112) = &unk_26E6BE670;
  *(_DWORD *)(a1 + 120) = v9;
  *(_WORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 132) = 0;
  *(void *)(a1 + 136) = &unk_26E6BE818;
  *(void *)(a1 + 144) = a1 + 112;
  *(_WORD *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0x2000;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = a1 + 200;
  CFDataRef v10 = (void *)(a2 + 160);
  uint64_t v11 = *(void *)(a2 + 160);
  uint64_t v12 = *(void *)(a2 + 208);
  *(void *)(a1 + 200) = &unk_26E7147A0;
  *(void *)(a1 + 208) = v12;
  uint64_t v13 = *(int *)(a2 + 184);
  if (v11 != v13)
  {
    lseek(v9, 0, 0);
    google::protobuf::io::CopyingInputStreamAdaptor::Skip((google::protobuf::io::CopyingInputStreamAdaptor *)(a1 + 136), v11 - v13);
  }
  unint64_t v15 = *(void (***)(uint64_t))(a2 + 104);
  uint64_t v14 = a2 + 104;
  *(_DWORD *)(v14 - 32) = -1;
  *(unsigned char *)(v14 - 8) = 1;
  (*v15)(v14);
  int v16 = *(_DWORD *)(v14 - 32);
  *(void *)uint64_t v14 = &unk_26E6BE630;
  *(void *)(v14 + 8) = &unk_26E6BE670;
  *(_DWORD *)(v14 + 16) = v16;
  *(_WORD *)(v14 + 20) = 0;
  *(_DWORD *)(v14 + 24) = 0;
  *(unsigned char *)(v14 + 28) = 0;
  *(void *)(v14 + 32) = &unk_26E6BE818;
  *(void *)(v14 + 40) = v14 + 8;
  *(_WORD *)(v14 + 48) = 0;
  *CFDataRef v10 = 0;
  v10[1] = 0;
  *(void *)(v14 + 72) = 0x2000;
  *(_DWORD *)(v14 + 80) = 0;
  *(void *)(v14 + 88) = 0;
  return a1;
}

void re::FileSeekableInputStream::~FileSeekableInputStream(re::FileSeekableInputStream *this)
{
  int v2 = *((_DWORD *)this + 18);
  if (v2 != -1) {
    close(v2);
  }
  *((void *)this + 13) = &unk_26E6BE630;
  google::protobuf::io::CopyingInputStreamAdaptor::~CopyingInputStreamAdaptor((re::FileSeekableInputStream *)((char *)this + 136));
  google::protobuf::io::FileInputStream::CopyingFileInputStream::~CopyingFileInputStream((re::FileSeekableInputStream *)((char *)this + 112));
  re::DynamicString::deinit((re::FileSeekableInputStream *)((char *)this + 40));
  re::DynamicString::deinit((re::FileSeekableInputStream *)((char *)this + 8));
}

{
  uint64_t vars8;

  re::FileSeekableInputStream::~FileSeekableInputStream(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::FileSeekableInputStream::Next(re::FileSeekableInputStream *this, const void **a2, int *a3)
{
  unint64_t v4 = *((void *)this + 20) - *((int *)this + 46);
  uint64_t v5 = *((void *)this + 10);
  unint64_t v6 = *((void *)this + 11);
  unint64_t v7 = v6 + v5;
  unint64_t v8 = v4 - v5;
  if (v4 >= v7) {
    unint64_t v9 = *((void *)this + 11);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= v6)
  {
    int v13 = 0;
    uint64_t result = 0;
    goto LABEL_9;
  }
  uint64_t result = google::protobuf::io::CopyingInputStreamAdaptor::Next((re::FileSeekableInputStream *)((char *)this + 136), a2, a3);
  uint64_t v12 = *((void *)this + 11);
  if (v12 != -1 && *a3 + (int)v9 > (int)v12)
  {
    int v13 = v12 - v9;
LABEL_9:
    *a3 = v13;
  }
  return result;
}

uint64_t re::FileSeekableInputStream::ByteCount(re::FileSeekableInputStream *this)
{
  unint64_t v1 = *((void *)this + 20) - *((int *)this + 46);
  uint64_t v2 = *((void *)this + 10);
  unint64_t v3 = *((void *)this + 11) + v2;
  uint64_t v4 = v1 - v2;
  if (v1 >= v3) {
    return *((void *)this + 11);
  }
  else {
    return v4;
  }
}

void re::FileSeekableInputStream::BackUp(re::FileSeekableInputStream *this, int a2)
{
  unint64_t v2 = *((void *)this + 20) - *((int *)this + 46);
  uint64_t v3 = *((void *)this + 10);
  unint64_t v4 = *((void *)this + 11) + v3;
  if (v2 <= v4) {
    int v5 = 0;
  }
  else {
    int v5 = v2 - v4;
  }
  int v6 = v5 + a2;
  int v7 = v2 - v6;
  int v8 = v2 - v3;
  if (v7 >= (int)v3) {
    int v9 = v6;
  }
  else {
    int v9 = v8;
  }
  google::protobuf::io::CopyingInputStreamAdaptor::BackUp((re::FileSeekableInputStream *)((char *)this + 136), v9);
}

BOOL re::FileSeekableInputStream::Seek(re::FileSeekableInputStream *this, unint64_t a2)
{
  if (*((_DWORD *)this + 18) == -1) {
    return 0;
  }
  unint64_t v4 = (void *)((char *)this + 160);
  unint64_t v5 = *((void *)this + 20) - *((int *)this + 46);
  uint64_t v6 = *((void *)this + 10);
  unint64_t v7 = *((void *)this + 11) + v6;
  unint64_t v8 = v5 - v6;
  if (v5 >= v7) {
    unint64_t v9 = *((void *)this + 11);
  }
  else {
    unint64_t v9 = v8;
  }
  BOOL v10 = a2 >= v9;
  unint64_t v11 = a2 - v9;
  if (!v10)
  {
    uint64_t v12 = (void *)((char *)this + 104);
    (**((void (***)(char *, uint64_t))this + 13))((char *)this + 104, v11);
    lseek(*((_DWORD *)this + 18), 0, 0);
    int v13 = *((_DWORD *)this + 18);
    *uint64_t v12 = &unk_26E6BE630;
    *((void *)this + 14) = &unk_26E6BE670;
    *((_DWORD *)this + 30) = v13;
    *((_WORD *)this + 62) = 0;
    *((_DWORD *)this + 32) = 0;
    *((unsigned char *)this + 132) = 0;
    *((void *)this + 17) = &unk_26E6BE818;
    *((void *)this + 18) = (char *)this + 112;
    *((_WORD *)this + 76) = 0;
    *unint64_t v4 = 0;
    v4[1] = 0;
    *((void *)this + 22) = 0x2000;
    *((_DWORD *)this + 46) = 0;
    *((void *)this + 24) = (char *)this + 200;
    unint64_t v11 = *((void *)this + 10) + a2;
  }
  return google::protobuf::io::CopyingInputStreamAdaptor::Skip((re::FileSeekableInputStream *)((char *)this + 136), v11);
}

BOOL re::FileSeekableInputStream::Skip(re::FileSeekableInputStream *this, int a2)
{
  return google::protobuf::io::CopyingInputStreamAdaptor::Skip((re::FileSeekableInputStream *)((char *)this + 136), a2);
}

uint64_t re::FileSeekableInputStream::CreateDetached(re::FileSeekableInputStream *this)
{
  unint64_t v2 = re::globalAllocators(this);
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[2] + 32))(v2[2], 216, 8);
  return re::FileSeekableInputStream::FileSeekableInputStream(v3, (uint64_t)this);
}

uint64_t re::FileSeekableInputStream::FilePathAndOffset@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  if (*(unsigned char *)(this + 16)) {
    uint64_t v2 = *(void *)(this + 24);
  }
  else {
    uint64_t v2 = this + 17;
  }
  uint64_t v3 = *(void *)(this + 80);
  *(unsigned char *)a2 = 1;
  *(void *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = v3;
  return this;
}

uint64_t re::FileSeekableInputStream::CanSeek(re::FileSeekableInputStream *this)
{
  return 1;
}

uint64_t re::FileSeekableInputStream::Length(re::FileSeekableInputStream *this)
{
  return *((void *)this + 11);
}

uint64_t re::FileSeekableInputStream::AllInMemory(re::FileSeekableInputStream *this)
{
  return 0;
}

uint64_t re::FileSeekableInputStream::OwnsMemory(re::FileSeekableInputStream *this)
{
  return 0;
}

uint64_t re::IOAlloc::alloc(re::IOAlloc *this, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**((void **)this + 1) + 32))(*((void *)this + 1), a2, 0);
}

uint64_t re::IOAlloc::free(re::IOAlloc *this, void *a2)
{
  return (*(uint64_t (**)(void, void *))(**((void **)this + 1) + 40))(*((void *)this + 1), a2);
}

size_t re::DynamicArrayStreamWriter::writeBytes(re::DynamicArrayStreamWriter *this, char *__src, size_t __len)
{
  return __len;
}

void re::DynamicArrayStreamWriter::~DynamicArrayStreamWriter(re::DynamicArrayStreamWriter *this)
{
}

uint64_t re::NullStreamWriter::writeBytes(re::NullStreamWriter *this, const void *a2, uint64_t a3)
{
  *((_DWORD *)this + 2) += a3;
  return a3;
}

void re::NullStreamWriter::~NullStreamWriter(re::NullStreamWriter *this)
{
}

uint64_t *re::foundationIOLogObjects(re *this)
{
  {
    re::foundationIOLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.IO");
  }
  return &re::foundationIOLogObjects(void)::logObjects;
}

uint64_t re::DynamicArrayBufferedOutputStream::DynamicArrayBufferedOutputStream(uint64_t result, uint64_t a2, int a3)
{
  *(_WORD *)(result + 8) = 0;
  *(void *)uint64_t result = &unk_26E714878;
  *(void *)(result + 16) = a2;
  *(void *)(result + 24) = &unk_26E7148D0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = &unk_26E6BE858;
  *(void *)(result + 48) = result + 24;
  *(_WORD *)(result + 56) = 0;
  if (a3 <= 0) {
    int v3 = 0x2000;
  }
  else {
    int v3 = a3;
  }
  *(void *)(result + 64) = 0;
  *(void *)(result + 72) = 0;
  *(_DWORD *)(result + 80) = v3;
  *(_DWORD *)(result + 84) = 0;
  *(void *)(result + 88) = 0;
  return result;
}

void re::DynamicArrayBufferedOutputStream::~DynamicArrayBufferedOutputStream(re::DynamicArrayBufferedOutputStream *this)
{
  *(void *)this = &unk_26E714878;
  *((void *)this + 3) = &unk_26E7148D0;
  if (*((unsigned char *)this + 8))
  {
    *((unsigned char *)this + 8) = 0;
    google::protobuf::io::CopyingOutputStreamAdaptor::Flush((re::DynamicArrayBufferedOutputStream *)((char *)this + 40));
  }
  *((void *)this + 4) = 0;
  google::protobuf::io::CopyingOutputStreamAdaptor::~CopyingOutputStreamAdaptor((re::DynamicArrayBufferedOutputStream *)((char *)this + 40));
  re::internal::MemoryOutputStream<re::DynamicArray<char>>::~MemoryOutputStream((uint64_t)this);
}

{
  uint64_t vars8;

  re::DynamicArrayBufferedOutputStream::~DynamicArrayBufferedOutputStream(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::MemoryOutputStream<re::DynamicArray<char>>::~MemoryOutputStream(uint64_t a1)
{
  *(void *)a1 = &unk_26E714BE0;
  if (*(unsigned char *)(a1 + 9))
  {
    if (*(void *)(a1 + 16))
    {
      re::DynamicArray<unsigned long>::deinit(*(void *)(a1 + 16));
    }
    *(void *)(a1 + 16) = 0;
    *(unsigned char *)(a1 + 9) = 0;
  }
  return a1;
}

void non-virtual thunk to're::DynamicArrayBufferedOutputStream::~DynamicArrayBufferedOutputStream(re::DynamicArrayBufferedOutputStream *this)
{
}

{
  uint64_t vars8;

  re::DynamicArrayBufferedOutputStream::~DynamicArrayBufferedOutputStream((re::DynamicArrayBufferedOutputStream *)((char *)this - 24));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::DynamicArrayBufferedOutputStream::Next(re::DynamicArrayBufferedOutputStream *this, void **a2, int *a3)
{
  *((unsigned char *)this + 8) = 1;
  return google::protobuf::io::CopyingOutputStreamAdaptor::Next((re::DynamicArrayBufferedOutputStream *)((char *)this + 40), a2, a3);
}

void re::DynamicArrayBufferedOutputStream::BackUp(re::DynamicArrayBufferedOutputStream *this, int a2)
{
}

uint64_t re::DynamicArrayBufferedOutputStream::ByteCount(re::DynamicArrayBufferedOutputStream *this)
{
  return *((void *)this + 8) + *((int *)this + 21);
}

void re::DynamicArrayBufferedOutputStream::WriteAliasedRaw(re::DynamicArrayBufferedOutputStream *this, uint64_t a2)
{
}

uint64_t re::DynamicArrayBufferedOutputStream::Write(re::DynamicArrayBufferedOutputStream *this, const void *a2, int a3)
{
  unint64_t v5 = (void *)*((void *)this + 2);
  size_t v6 = a3;
  uint64_t v7 = v5[2];
  unint64_t v8 = v7 + a3;
  unint64_t v9 = (v8 - 1) | ((v8 - 1) >> 1) | (((v8 - 1) | ((v8 - 1) >> 1)) >> 2);
  unint64_t v10 = v9 | (v9 >> 4) | ((v9 | (v9 >> 4)) >> 8);
  unint64_t v11 = (v10 | (v10 >> 16) | ((v10 | (v10 >> 16)) >> 32)) + 1;
  if (v5[1] < v11)
  {
    re::DynamicArray<char>::setCapacity(v5, v11);
    unint64_t v5 = (void *)*((void *)this + 2);
  }
  re::DynamicArray<char>::resizeUninitialized(v5, v8);
  memcpy((void *)(*(void *)(*((void *)this + 2) + 32) + v7), a2, v6);
  *((void *)this + 4) += v6;
  return 1;
}

void *re::DynamicArray<char>::resizeUninitialized(void *result, unint64_t a2)
{
  int v3 = result;
  unint64_t v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return result;
    }
  }
  else if (result[1] < a2)
  {
    uint64_t result = re::DynamicArray<char>::setCapacity(result, a2);
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t non-virtual thunk to're::DynamicArrayBufferedOutputStream::Write(re::DynamicArrayBufferedOutputStream *this, const void *a2, int a3)
{
  return 1;
}

re::CFDataBufferedOutputStream *re::CFDataBufferedOutputStream::CFDataBufferedOutputStream(re::CFDataBufferedOutputStream *this, int a2)
{
  *unint64_t v4 = 0;
  *((_WORD *)this + 4) = 256;
  *(void *)this = &unk_26E7148F8;
  *((void *)this + 2) = v4;
  *((void *)this + 3) = &unk_26E714950;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = &unk_26E6BE858;
  *((void *)this + 6) = (char *)this + 24;
  *((_WORD *)this + 28) = 0;
  if (a2 <= 0) {
    int v5 = 0x2000;
  }
  else {
    int v5 = a2;
  }
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((_DWORD *)this + 20) = v5;
  *((_DWORD *)this + 21) = 0;
  *((void *)this + 11) = 0;
  **((void **)this + 2) = CFDataCreateMutable(0, 0);
  return this;
}

re::CFDataBufferedOutputStream *re::CFDataBufferedOutputStream::CFDataBufferedOutputStream(re::CFDataBufferedOutputStream *this, CFTypeRef *a2, int a3)
{
  *((_WORD *)this + 4) = 0;
  *(void *)this = &unk_26E7148F8;
  *((void *)this + 2) = a2;
  *((void *)this + 3) = &unk_26E714950;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = &unk_26E6BE858;
  *((void *)this + 6) = (char *)this + 24;
  *((_WORD *)this + 28) = 0;
  if (a3 <= 0) {
    int v4 = 0x2000;
  }
  else {
    int v4 = a3;
  }
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((_DWORD *)this + 20) = v4;
  *((_DWORD *)this + 21) = 0;
  *((void *)this + 11) = 0;
  CFRetain(*a2);
  return this;
}

void re::CFDataBufferedOutputStream::~CFDataBufferedOutputStream(re::CFDataBufferedOutputStream *this)
{
  *(void *)this = &unk_26E7148F8;
  *((void *)this + 3) = &unk_26E714950;
  if (*((unsigned char *)this + 8))
  {
    *((unsigned char *)this + 8) = 0;
    google::protobuf::io::CopyingOutputStreamAdaptor::Flush((re::CFDataBufferedOutputStream *)((char *)this + 40));
  }
  *((void *)this + 4) = 0;
  CFRelease(**((CFTypeRef **)this + 2));
  google::protobuf::io::CopyingOutputStreamAdaptor::~CopyingOutputStreamAdaptor((re::CFDataBufferedOutputStream *)((char *)this + 40));
  re::internal::MemoryOutputStream<__CFData *>::~MemoryOutputStream((uint64_t)this);
}

{
  uint64_t vars8;

  re::CFDataBufferedOutputStream::~CFDataBufferedOutputStream(this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::internal::MemoryOutputStream<__CFData *>::~MemoryOutputStream(uint64_t a1)
{
  *(void *)a1 = &unk_26E714C30;
  if (*(unsigned char *)(a1 + 9))
  {
    if (*(void *)(a1 + 16)) {
    *(void *)(a1 + 16) = 0;
    }
    *(unsigned char *)(a1 + 9) = 0;
  }
  return a1;
}

void non-virtual thunk to're::CFDataBufferedOutputStream::~CFDataBufferedOutputStream(re::CFDataBufferedOutputStream *this)
{
}

{
  uint64_t vars8;

  re::CFDataBufferedOutputStream::~CFDataBufferedOutputStream((re::CFDataBufferedOutputStream *)((char *)this - 24));
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::CFDataBufferedOutputStream::Next(re::CFDataBufferedOutputStream *this, void **a2, int *a3)
{
  *((unsigned char *)this + 8) = 1;
  return google::protobuf::io::CopyingOutputStreamAdaptor::Next((re::CFDataBufferedOutputStream *)((char *)this + 40), a2, a3);
}

void re::CFDataBufferedOutputStream::BackUp(re::CFDataBufferedOutputStream *this, int a2)
{
}

uint64_t re::CFDataBufferedOutputStream::ByteCount(re::CFDataBufferedOutputStream *this)
{
  return *((void *)this + 8) + *((int *)this + 21);
}

void re::CFDataBufferedOutputStream::WriteAliasedRaw(re::CFDataBufferedOutputStream *this, uint64_t a2)
{
}

uint64_t re::CFDataBufferedOutputStream::Write(CFMutableDataRef **this, const UInt8 *a2, int a3)
{
  this[4] = (CFMutableDataRef *)((char *)this[4] + a3);
  return 1;
}

uint64_t non-virtual thunk to're::CFDataBufferedOutputStream::Write(CFMutableDataRef **this, const UInt8 *a2, int a3)
{
  this[1] = (CFMutableDataRef *)((char *)this[1] + a3);
  return 1;
}

void re::CFDataOutputStream::~CFDataOutputStream(re::CFDataOutputStream *this)
{
  re::internal::MemoryOutputStream<__CFData *>::~MemoryOutputStream((uint64_t)this);
  JUMPOUT(0x237DBCBD0);
}

BOOL re::CFDataOutputStream::Next(re::CFDataOutputStream *this, void **a2, int *a3)
{
  uint64_t v3 = *((int *)this + 12);
  int v4 = *((_DWORD *)this + 10);
  if ((int)v3 >= v4)
  {
    *((_DWORD *)this + 13) = 0;
  }
  else
  {
    int v5 = v4 - v3;
    if (v4 - (int)v3 >= *((_DWORD *)this + 11)) {
      int v5 = *((_DWORD *)this + 11);
    }
    *((_DWORD *)this + 13) = v5;
    *a2 = (void *)(*((void *)this + 4) + v3);
    *a3 = v5;
    *((_DWORD *)this + 12) += *((_DWORD *)this + 13);
  }
  return (int)v3 < v4;
}

void re::CFDataOutputStream::BackUp(re::CFDataOutputStream *this, int a2)
{
}

uint64_t re::CFDataOutputStream::ByteCount(re::CFDataOutputStream *this)
{
  return *((int *)this + 12);
}

void re::CFDataOutputStream::WriteAliasedRaw(re::CFDataOutputStream *this, uint64_t a2)
{
}

uint64_t re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream(uint64_t a1)
{
  *(void *)a1 = &unk_26E714C80;
  if (*(unsigned char *)(a1 + 9))
  {
    if (*(void *)(a1 + 16))
    {
      re::FixedArray<CoreIKTransform>::deinit(*(uint64_t **)(a1 + 16));
    }
    *(void *)(a1 + 16) = 0;
    *(unsigned char *)(a1 + 9) = 0;
  }
  return a1;
}

re::FixedArrayInputStream *re::FixedArrayInputStream::FixedArrayInputStream(re::FixedArrayInputStream *this, const char *a2, int a3, int a4)
{
  v8[1] = 0;
  v8[2] = 0;
  *unint64_t v8 = 0;
  *((_WORD *)this + 4) = 256;
  *(void *)this = &unk_26E7149C8;
  *((void *)this + 2) = v8;
  *((void *)this + 3) = &unk_26E6BE790;
  *((void *)this + 4) = a2;
  if (a4 <= 0) {
    int v9 = a3;
  }
  else {
    int v9 = a4;
  }
  *((_DWORD *)this + 10) = a3;
  *((_DWORD *)this + 11) = v9;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = a3;
  return this;
}

void re::FixedArrayInputStream::~FixedArrayInputStream(re::FixedArrayInputStream *this)
{
  re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)this);
  JUMPOUT(0x237DBCBD0);
}

BOOL re::FixedArrayInputStream::Next(re::FixedArrayInputStream *this, const void **a2, int *a3)
{
  uint64_t v3 = *((int *)this + 12);
  int v4 = *((_DWORD *)this + 10);
  if ((int)v3 >= v4)
  {
    *((_DWORD *)this + 13) = 0;
  }
  else
  {
    int v5 = v4 - v3;
    if (v4 - (int)v3 >= *((_DWORD *)this + 11)) {
      int v5 = *((_DWORD *)this + 11);
    }
    *((_DWORD *)this + 13) = v5;
    *a2 = (const void *)(*((void *)this + 4) + v3);
    *a3 = v5;
    *((_DWORD *)this + 12) += *((_DWORD *)this + 13);
  }
  return (int)v3 < v4;
}

void re::FixedArrayInputStream::BackUp(re::FixedArrayInputStream *this, int a2)
{
}

uint64_t re::FixedArrayInputStream::ByteCount(re::FixedArrayInputStream *this)
{
  return *((int *)this + 12);
}

BOOL re::FixedArrayInputStream::Skip(re::FixedArrayInputStream *this, int a2)
{
  return google::protobuf::io::ArrayInputStream::Skip((re::FixedArrayInputStream *)((char *)this + 24), a2);
}

uint64_t re::FixedArrayInputStream::Seek(re::FixedArrayInputStream *this, uint64_t a2)
{
  return 1;
}

uint64_t re::FixedArrayInputStream::Length(re::FixedArrayInputStream *this)
{
  return *((void *)this + 7);
}

uint64_t re::internal::MemoryInputStream<__CFData const*>::~MemoryInputStream(uint64_t a1)
{
  *(void *)a1 = &unk_26E714D00;
  if (*(unsigned char *)(a1 + 9))
  {
    if (*(void *)(a1 + 16)) {
    *(void *)(a1 + 16) = 0;
    }
    *(unsigned char *)(a1 + 9) = 0;
  }
  return a1;
}

void re::CFDataInputStream::~CFDataInputStream(re::CFDataInputStream *this)
{
  re::internal::MemoryInputStream<__CFData const*>::~MemoryInputStream((uint64_t)this);
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::CFDataInputStream::Seek(re::CFDataInputStream *this, uint64_t a2)
{
  return 1;
}

CFIndex re::CFDataInputStream::Length(CFDataRef **this)
{
  return CFDataGetLength(*this[2]);
}

BOOL re::CFDataInputStream::Next(re::CFDataInputStream *this, const void **a2, int *a3)
{
  uint64_t v3 = *((int *)this + 12);
  int v4 = *((_DWORD *)this + 10);
  if ((int)v3 >= v4)
  {
    *((_DWORD *)this + 13) = 0;
  }
  else
  {
    int v5 = v4 - v3;
    if (v4 - (int)v3 >= *((_DWORD *)this + 11)) {
      int v5 = *((_DWORD *)this + 11);
    }
    *((_DWORD *)this + 13) = v5;
    *a2 = (const void *)(*((void *)this + 4) + v3);
    *a3 = v5;
    *((_DWORD *)this + 12) += *((_DWORD *)this + 13);
  }
  return (int)v3 < v4;
}

void re::CFDataInputStream::BackUp(re::CFDataInputStream *this, int a2)
{
}

uint64_t re::CFDataInputStream::ByteCount(re::CFDataInputStream *this)
{
  return *((int *)this + 12);
}

BOOL re::CFDataInputStream::Skip(re::CFDataInputStream *this, int a2)
{
  return google::protobuf::io::ArrayInputStream::Skip((re::CFDataInputStream *)((char *)this + 24), a2);
}

uint64_t re::DynamicArrayBufferedOutputStream::AllowsAliasing(re::DynamicArrayBufferedOutputStream *this)
{
  return 0;
}

uint64_t re::DynamicArrayBufferedOutputStream::Flush(re::DynamicArrayBufferedOutputStream *this)
{
  *((unsigned char *)this + 8) = 0;
  return google::protobuf::io::CopyingOutputStreamAdaptor::Flush((re::DynamicArrayBufferedOutputStream *)((char *)this + 40));
}

uint64_t re::CFDataBufferedOutputStream::AllowsAliasing(re::CFDataBufferedOutputStream *this)
{
  return 0;
}

uint64_t re::CFDataBufferedOutputStream::Flush(re::CFDataBufferedOutputStream *this)
{
  *((unsigned char *)this + 8) = 0;
  return google::protobuf::io::CopyingOutputStreamAdaptor::Flush((re::CFDataBufferedOutputStream *)((char *)this + 40));
}

uint64_t re::CFDataOutputStream::AllowsAliasing(re::CFDataOutputStream *this)
{
  return 1;
}

uint64_t re::internal::MemoryOutputStream<__CFData *>::Flush(uint64_t a1)
{
  *(unsigned char *)(a1 + 8) = 0;
  return 1;
}

uint64_t re::internal::MemoryInputStream<re::FixedArray<char>>::Flush(uint64_t a1)
{
  *(unsigned char *)(a1 + 8) = 0;
  return 1;
}

uint64_t re::FixedArrayInputStream::CanSeek(re::FixedArrayInputStream *this)
{
  return 1;
}

void re::FixedArrayInputStream::CreateDetached(re::FixedArrayInputStream *this, uint64_t a2)
{
}

uint64_t re::FixedArrayInputStream::AllInMemory(re::FixedArrayInputStream *this)
{
  return 1;
}

uint64_t re::FixedArrayInputStream::OwnsMemory(re::FixedArrayInputStream *this)
{
  return 1;
}

uint64_t re::CFDataInputStream::CanSeek(re::CFDataInputStream *this)
{
  return 1;
}

void re::CFDataInputStream::CreateDetached(re::CFDataInputStream *this, uint64_t a2)
{
}

uint64_t re::CFDataInputStream::AllInMemory(re::CFDataInputStream *this)
{
  return 1;
}

uint64_t re::CFDataInputStream::OwnsMemory(re::CFDataInputStream *this)
{
  return 1;
}

uint64_t re::internal::MemoryInputStream<__CFData const*>::Flush(uint64_t a1)
{
  *(unsigned char *)(a1 + 8) = 0;
  return 1;
}

uint64_t re::internal::MemoryOutputStream<re::DynamicArray<char>>::Flush(uint64_t a1)
{
  *(unsigned char *)(a1 + 8) = 0;
  return 1;
}

uint64_t re::path::ext(re::path *this, const char *a2)
{
  size_t v3 = strlen((const char *)this);
  if (v3 < 2) {
    return (uint64_t)this + v3;
  }
  size_t v4 = v3 - 1;
  BOOL v5 = 1;
  unint64_t v6 = 2;
  while (1)
  {
    int v7 = *((unsigned __int8 *)this + v4);
    if (v7 == 46) {
      break;
    }
    if (v7 != 47)
    {
      BOOL v5 = v6++ < v3;
      if (--v4) {
        continue;
      }
    }
    return (uint64_t)this + v3;
  }
  if (v5) {
    return (uint64_t)this + v4;
  }
  else {
    return (uint64_t)this + v3;
  }
}

void *re::path::dirname(re::path *this, re::PathBuffer *__s, const char *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  size_t v5 = strlen((const char *)__s);
  if (v5 < 2) {
    return (void *)*((void *)this + 1);
  }
  uint64_t v6 = 0x100000000 - (v5 << 32);
  size_t v7 = v5 - 1;
  while (*((unsigned char *)__s + v7) != 47)
  {
    v6 += 0x100000000;
    if (!--v7) {
      return (void *)*((void *)this + 1);
    }
  }
  if (!v6) {
    return (void *)*((void *)this + 1);
  }
  uint64_t v8 = -v6 >> 32;
  uint64_t v9 = re::PathBuffer::reserve((const char **)this, v8);
  if (v9)
  {
    unint64_t v10 = (void *)*((void *)this + 1);
    memcpy(v10, __s, v8);
    *((unsigned char *)v10 + v8) = 0;
  }
  else
  {
    uint64_t v12 = *re::foundationIOLogObjects((re *)v9);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v13 = 134218242;
      uint64_t v14 = v8;
      __int16 v15 = 2080;
      int v16 = __s;
      _os_log_error_impl(&dword_233120000, v12, OS_LOG_TYPE_ERROR, "Failed to allocated %lu bytes for calculating dirname(\"%s\")", (uint8_t *)&v13, 0x16u);
    }
    return &unk_234407C5D;
  }
  return v10;
}

uint64_t re::PathBuffer::reserve(const char **this, uint64_t a2)
{
  uint64_t v2 = (const char *)(a2 + 1);
  if ((unint64_t)(a2 + 1) >= 0x1E9 && v2 > this[2])
  {
    uint64_t result = (*(uint64_t (**)(const char *, uint64_t, void))(*(void *)*this + 32))(*this, a2 + 1, 0);
    if (!result) {
      return result;
    }
    uint64_t v6 = result;
    strcpy((char *)result, this[1]);
    if (this[1] != (const char *)(this + 3)) {
      (*(void (**)(void))(*(void *)*this + 40))();
    }
    this[1] = (const char *)v6;
    this[2] = v2;
  }
  return 1;
}

uint64_t re::path::join(const char **this, re::PathBuffer *__s, const char *a3, const char *a4)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  size_t v7 = strlen((const char *)__s);
  size_t v8 = strlen(a3);
  size_t v9 = v8;
  if (v7)
  {
    if (*((unsigned char *)__s + v7 - 1) == 47) {
      --v7;
    }
    BOOL v10 = v7 != 0;
    if (v7) {
      BOOL v11 = v8 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      BOOL v10 = 1;
      if (*a3 == 47)
      {
        ++a3;
        size_t v9 = v8 - 1;
      }
    }
  }
  else
  {
    BOOL v10 = 0;
  }
  uint64_t v12 = re::PathBuffer::reserve(this, v9 + 1 + v7);
  if (v12)
  {
    uint64_t v14 = (char *)this[1];
    int v13 = (char *)(this + 1);
    memcpy(v14, __s, v7);
    __int16 v15 = &v14[v7];
    char v16 = !v10;
    if (!v9) {
      char v16 = 1;
    }
    if ((v16 & 1) == 0) {
      *v15++ = 47;
    }
    memcpy(v15, a3, v9 + 1);
  }
  else
  {
    uint64_t v17 = *re::foundationIOLogObjects((re *)v12);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      int v19 = 134218498;
      size_t v20 = v9 + 1 + v7;
      __int16 v21 = 2080;
      uint64_t v22 = __s;
      __int16 v23 = 2080;
      signed int v24 = a3;
      _os_log_error_impl(&dword_233120000, v17, OS_LOG_TYPE_ERROR, "Failed to allocated %lu bytes for calculating join(\"%s\", \"%s\")", (uint8_t *)&v19, 0x20u);
    }
    int v13 = (char *)&re::path::kErrorOutOfMemory;
  }
  return *(void *)v13;
}

size_t re::MemoryStreamWriter::writeBytes(re::MemoryStreamWriter *this, const void *a2, size_t a3)
{
  uint64_t v4 = *((void *)this + 3);
  if (*((void *)this + 2) - v4 >= a3) {
    size_t v5 = a3;
  }
  else {
    size_t v5 = *((void *)this + 2) - v4;
  }
  memcpy((void *)(*((void *)this + 1) + v4), a2, v5);
  *((void *)this + 3) += v5;
  return v5;
}

void re::MemoryStreamWriter::~MemoryStreamWriter(re::MemoryStreamWriter *this)
{
}

unint64_t re::CopyRead(re *this, re::SeekableInputStream *a2, uint64_t a3, void *a4)
{
  if (!a2) {
    return 0;
  }
  unint64_t v7 = 0;
  do
  {
    LODWORD(__n) = 0;
    __src = 0;
    char v8 = (*(uint64_t (**)(re *, void **, size_t *, void *))(*(void *)this + 16))(this, &__src, &__n, a4);
    uint64_t v9 = (int)__n;
    unint64_t v10 = v7 + (int)__n;
    if (v10 <= (unint64_t)a2)
    {
      memcpy((void *)(a3 + v7), __src, (int)__n);
    }
    else
    {
      uint64_t v11 = (v10 - a2);
      LODWORD(__n) = __n - v11;
      uint64_t v9 = (int)v9 - (int)v11;
      memcpy((void *)(a3 + v7), __src, (int)__n);
      if (v11)
      {
        (*(void (**)(re *, uint64_t))(*(void *)this + 24))(this, v11);
        uint64_t v9 = (int)__n;
      }
    }
    v7 += v9;
    if (v7 < (unint64_t)a2) {
      char v12 = v8;
    }
    else {
      char v12 = 0;
    }
  }
  while ((v12 & 1) != 0);
  return v7;
}

BOOL re::SeekableInputStreamBufferedReader::readNext(re::SeekableInputStreamBufferedReader *this, unint64_t a2)
{
  if (!*(void *)this) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4)
  {
    *((void *)this + 1) += v4;
    *((void *)this + 2) = 0;
    *((void *)this + 6) = 0;
    ++*((_DWORD *)this + 14);
  }
  uint64_t v5 = 0;
  uint64_t v6 = (_DWORD *)((char *)this + 24);
  while (1)
  {
    if (*v6)
    {
      BOOL v7 = 1;
    }
    else if ((*(unsigned int (**)(void, char *, char *))(**(void **)this + 16))(*(void *)this, (char *)this + 8, (char *)this + 24))
    {
      uint64_t v8 = (*(uint64_t (**)(void))(**(void **)this + 40))();
      BOOL v7 = v8 != (*(uint64_t (**)(void))(**(void **)this + 64))();
    }
    else
    {
      BOOL v7 = 0;
    }
    unint64_t v9 = *((int *)this + 6);
    int v10 = v9 - a2;
    BOOL v11 = v9 >= a2;
    if (v9 >= a2) {
      unint64_t v9 = a2;
    }
    unint64_t v12 = v9 + *((void *)this + 2);
    if (v11) {
      int v13 = v10;
    }
    else {
      int v13 = 0;
    }
    *((void *)this + 2) = v12;
    *((_DWORD *)this + 6) = v13;
    BOOL v14 = v12 < a2 && v7;
    if (v5 || v14)
    {
      if (!*((void *)this + 6))
      {
        unint64_t v15 = a2;
        if (a2 != -1
          || (uint64_t v16 = (*(uint64_t (**)(void))(**(void **)this + 64))(), v16 != -1)
          && (unint64_t v15 = v16 - (*(uint64_t (**)(void))(**(void **)this + 40))() + *((int *)this + 6), v15 != -1))
        {
          if (*((void *)this + 5) < v15) {
            re::DynamicArray<BOOL>::setCapacity((void *)this + 4, v15);
          }
        }
      }
      re::DynamicArray<BOOL>::resize((uint64_t)this + 32, *((void *)this + 2));
      memcpy((void *)(*((void *)this + 8) + v5), *((const void **)this + 1), *((void *)this + 2) - v5);
    }
    if (!v14) {
      break;
    }
    uint64_t v5 = *((void *)this + 2);
  }
  if (*((void *)this + 6))
  {
    if (*v6)
    {
      (*(void (**)(void))(**(void **)this + 24))();
      *((_DWORD *)this + 6) = 0;
    }
    *((void *)this + 1) = *((void *)this + 8);
  }
  return *((void *)this + 2) != 0;
}

uint64_t re::SeekableInputStreamReaderAdaptor::readBytes(re::SeekableInputStreamReaderAdaptor *this, char *__dst, size_t __n)
{
  if (*((unsigned char *)this + 48))
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v8 = (_DWORD *)((char *)this + 24);
    int v7 = *((_DWORD *)this + 6);
    unint64_t v9 = (const void **)((char *)this + 16);
    while (1)
    {
      if (!v7)
      {
        *((unsigned char *)this + 48) = (*(uint64_t (**)(void, char *, char *))(**((void **)this + 1) + 16))(*((void *)this + 1), (char *)this + 16, (char *)this + 24) ^ 1;
        int v7 = *((_DWORD *)this + 6);
      }
      int v10 = *v9;
      if (__n <= v7) {
        break;
      }
      memcpy(__dst, v10, v7);
      int v7 = 0;
      uint64_t v11 = *((int *)this + 6);
      v4 += v11;
      __n -= v11;
      __dst += v11;
      *((_DWORD *)this + 6) = 0;
      if (*((unsigned char *)this + 48)) {
        goto LABEL_10;
      }
    }
    memcpy(__dst, v10, __n);
    *v8 -= __n;
    *unint64_t v9 = (char *)*v9 + __n;
    v4 += __n;
  }
LABEL_10:
  *((void *)this + 4) += v4;
  return v4;
}

uint64_t re::SeekableInputStreamReaderAdaptor::skipBytes(re::SeekableInputStreamReaderAdaptor *this, unint64_t a2)
{
  if (*((unsigned char *)this + 48))
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v6 = (_DWORD *)((char *)this + 24);
    int v5 = *((_DWORD *)this + 6);
    int v7 = (void *)((char *)this + 16);
    while (1)
    {
      if (v5)
      {
        int v8 = 0;
      }
      else
      {
        int v9 = (*(uint64_t (**)(void, char *, char *))(**((void **)this + 1) + 16))(*((void *)this + 1), (char *)this + 16, (char *)this + 24);
        int v8 = v9 ^ 1;
        *((unsigned char *)this + 48) = v9 ^ 1;
        int v5 = *((_DWORD *)this + 6);
      }
      uint64_t v10 = v5;
      if (a2 <= v5) {
        break;
      }
      int v5 = 0;
      v3 += v10;
      a2 -= v10;
      _DWORD *v6 = 0;
      if (v8) {
        goto LABEL_11;
      }
    }
    _DWORD *v6 = v5 - a2;
    *v7 += a2;
    v3 += a2;
  }
LABEL_11:
  *((void *)this + 4) += v3;
  return v3;
}

uint64_t re::SeekableInputStreamReaderAdaptor::seek(re::SeekableInputStreamReaderAdaptor *this, unint64_t a2)
{
  if ((*(uint64_t (**)(void))(**((void **)this + 1) + 64))(*((void *)this + 1)) < a2) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(void, unint64_t))(**((void **)this + 1) + 56))(*((void *)this + 1), *((void *)this + 5) + a2);
  if (result)
  {
    *((void *)this + 2) = 0;
    *((_DWORD *)this + 6) = 0;
    uint64_t result = 1;
    *((void *)this + 4) = a2;
  }
  return result;
}

void re::SeekableInputStreamReaderAdaptor::~SeekableInputStreamReaderAdaptor(re::SeekableInputStreamReaderAdaptor *this)
{
  if (*((_DWORD *)this + 6))
  {
    (*(void (**)(void))(**((void **)this + 1) + 24))(*((void *)this + 1));
    *((_DWORD *)this + 6) = 0;
    *((void *)this + 2) = 0;
  }
}

{
  uint64_t vars8;

  if (*((_DWORD *)this + 6))
  {
    (*(void (**)(void))(**((void **)this + 1) + 24))(*((void *)this + 1));
    *((_DWORD *)this + 6) = 0;
    *((void *)this + 2) = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

uint64_t re::SeekableInputStreamReaderAdaptor::bytesRead(re::SeekableInputStreamReaderAdaptor *this)
{
  return *((void *)this + 4);
}

uint64_t re::SeekableInputStreamReaderAdaptor::bytesRemaining(re::SeekableInputStreamReaderAdaptor *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 64))(*((void *)this + 1))
       - *((void *)this + 4);
}

re::SeekableInputStreamSlice *re::SeekableInputStreamSlice::SeekableInputStreamSlice(re::SeekableInputStreamSlice *this, re::SeekableInputStream *a2, uint64_t a3)
{
  *(void *)this = &unk_26E714E28;
  *((void *)this + 1) = a2;
  *((unsigned char *)this + 16) = 0;
  *((void *)this + 3) = (*(uint64_t (**)(re::SeekableInputStream *))(*(void *)a2 + 40))(a2);
  *((void *)this + 4) = a3;
  if (a3 == -1)
  {
    uint64_t v6 = (*(uint64_t (**)(re::SeekableInputStream *))(*(void *)a2 + 64))(a2);
    if (v6 != -1) {
      *((void *)this + 4) = v6 - *((void *)this + 3);
    }
  }
  return this;
}

re *re::SeekableInputStreamSlice::detach(re::SeekableInputStreamSlice *this)
{
  uint64_t result = (re *)*((void *)this + 1);
  if (result)
  {
    unint64_t v3 = *((void *)this + 4) + *((void *)this + 3);
    uint64_t result = (re *)(*(uint64_t (**)(re *))(*(void *)result + 40))(result);
    if ((unint64_t)result > v3)
    {
      uint64_t v4 = *((void *)this + 1);
      int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
      uint64_t result = (re *)(*(uint64_t (**)(uint64_t, void))(*(void *)v4 + 24))(v4, (v5 - v3));
    }
    if (*((unsigned char *)this + 16))
    {
      uint64_t result = re::internal::destroyPersistent<re::SeekableInputStream>((re *)"detach", 37, *((void (****)(void))this + 1));
      *((unsigned char *)this + 16) = 0;
    }
    *((void *)this + 1) = 0;
  }
  return result;
}

void re::SeekableInputStreamSlice::~SeekableInputStreamSlice(re::SeekableInputStreamSlice *this)
{
}

{
  uint64_t vars8;

  re::SeekableInputStreamSlice::detach(this);
  JUMPOUT(0x237DBCBD0);
}

re *re::internal::destroyPersistent<re::SeekableInputStream>(re *result, uint64_t a2, void (***a3)(void))
{
  if (a3)
  {
    uint64_t v4 = re::globalAllocators(result)[2];
    (**a3)(a3);
    int v5 = *(uint64_t (**)(uint64_t, void (***)(void)))(*(void *)v4 + 40);
    return (re *)v5(v4, a3);
  }
  return result;
}

uint64_t re::SeekableInputStreamSlice::BackUp(re::SeekableInputStreamSlice *this)
{
  (*(uint64_t (**)(void))(**((void **)this + 1) + 40))(*((void *)this + 1));
  uint64_t v2 = *(uint64_t (**)(void))(**((void **)this + 1) + 24);
  return v2();
}

uint64_t re::SeekableInputStreamSlice::ByteCount(re::SeekableInputStreamSlice *this)
{
  unint64_t v2 = (*(uint64_t (**)(void))(**((void **)this + 1) + 40))(*((void *)this + 1));
  uint64_t v3 = *((void *)this + 3);
  unint64_t v4 = *((void *)this + 4) + v3;
  uint64_t v5 = v2 - v3;
  if (v2 >= v4) {
    return *((void *)this + 4);
  }
  else {
    return v5;
  }
}

uint64_t re::SeekableInputStreamSlice::Next(re::SeekableInputStreamSlice *this, const void **a2, int *a3)
{
  unint64_t v6 = (*(uint64_t (**)(void))(**((void **)this + 1) + 40))(*((void *)this + 1));
  uint64_t v7 = *((void *)this + 3);
  unint64_t v8 = *((void *)this + 4);
  unint64_t v9 = v8 + v7;
  unint64_t v10 = v6 - v7;
  if (v6 >= v9) {
    unint64_t v11 = *((void *)this + 4);
  }
  else {
    unint64_t v11 = v10;
  }
  if (v11 >= v8) {
    return 0;
  }
  *a3 = 0;
  uint64_t result = (*(uint64_t (**)(void, const void **, int *))(**((void **)this + 1) + 16))(*((void *)this + 1), a2, a3);
  uint64_t v13 = *((void *)this + 4);
  if (*a3 + (int)v11 > (int)v13) {
    *a3 = v13 - v11;
  }
  return result;
}

uint64_t re::SeekableInputStreamSlice::Skip(re::SeekableInputStreamSlice *this, int a2)
{
  unint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 1) + 40))(*((void *)this + 1));
  uint64_t v5 = *((void *)this + 3);
  unint64_t v6 = *((void *)this + 4);
  unint64_t v7 = v6 + v5;
  unint64_t v8 = v4 - v5;
  if (v4 >= v7) {
    unint64_t v8 = *((void *)this + 4);
  }
  if (v8 + a2 <= v6)
  {
    unint64_t v15 = *(uint64_t (**)(void))(**((void **)this + 1) + 32);
    return v15();
  }
  else
  {
    if (v8 < v6)
    {
      uint64_t v9 = *((void *)this + 1);
      unint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9);
      uint64_t v11 = *((void *)this + 3);
      unint64_t v12 = *((void *)this + 4) + v11;
      int v13 = v10 - v11;
      if (v10 >= v12) {
        int v13 = *((void *)this + 4);
      }
      (*(void (**)(uint64_t, void))(*(void *)v9 + 32))(v9, (v6 - v13));
    }
    return 0;
  }
}

BOOL re::SeekableInputStreamSlice::Seek(re::SeekableInputStreamSlice *this, unint64_t a2)
{
  unint64_t v3 = *((void *)this + 4);
  if (v3 >= a2) {
    (*(void (**)(void, unint64_t))(**((void **)this + 1) + 56))(*((void *)this + 1), *((void *)this + 3) + a2);
  }
  return v3 >= a2;
}

re::SeekableInputStreamSlice *re::SeekableInputStreamSlice::CreateDetached(re::SeekableInputStreamSlice *this)
{
  unint64_t v2 = (*(uint64_t (**)(void))(**((void **)this + 1) + 40))(*((void *)this + 1));
  uint64_t v3 = *((void *)this + 3);
  unint64_t v4 = *((void *)this + 4) + v3;
  unint64_t v5 = v2 - v3;
  if (v2 >= v4) {
    unint64_t v6 = *((void *)this + 4);
  }
  else {
    unint64_t v6 = v5;
  }
  uint64_t v7 = (*(uint64_t (**)(void))(**((void **)this + 1) + 72))(*((void *)this + 1));
  if (!v7) {
    return 0;
  }
  unint64_t v8 = (re::SeekableInputStream *)v7;
  uint64_t v9 = (re *)(*(uint64_t (**)(uint64_t, void))(*(void *)v7 + 56))(v7, *((void *)this + 3));
  unint64_t v10 = re::globalAllocators(v9);
  uint64_t v11 = (re::SeekableInputStreamSlice *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10[2] + 32))(v10[2], 40, 8);
  unint64_t v12 = re::SeekableInputStreamSlice::SeekableInputStreamSlice(v11, v8, *((void *)this + 4));
  uint64_t v13 = *((void *)this + 3);
  *((void *)v12 + 3) = v13;
  *((unsigned char *)v12 + 16) = 1;
  *((void *)this + 1) = 0;
  *((unsigned char *)this + 16) = 0;
  if (*((void *)v12 + 4) >= v6) {
    (*(void (**)(void *, unint64_t))(**((void **)v11 + 1) + 56))(*((void **)v11 + 1), v13 + v6);
  }
  return v11;
}

void *re::SeekableInputStreamSlice::FilePathAndOffset@<X0>(re::SeekableInputStreamSlice *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = (*(void *(**)(void *__return_ptr))(**((void **)this + 1) + 96))(v7);
  char v5 = v7[0];
  if (LOBYTE(v7[0]))
  {
    uint64_t v6 = *((void *)this + 3) + v7[2];
    *(void *)(a2 + 8) = v7[1];
    *(void *)(a2 + 16) = v6;
    char v5 = 1;
  }
  *(unsigned char *)a2 = v5;
  return result;
}

uint64_t re::SeekableInputStreamSlice::CanSeek(re::SeekableInputStreamSlice *this)
{
  return 1;
}

uint64_t re::SeekableInputStreamSlice::Length(re::SeekableInputStreamSlice *this)
{
  return *((void *)this + 4);
}

uint64_t re::SeekableInputStreamSlice::AllInMemory(re::SeekableInputStreamSlice *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 80))();
}

uint64_t re::SeekableInputStreamSlice::OwnsMemory(re::SeekableInputStreamSlice *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 88))();
}

double re::StreamWriterCopyingOutputStream::StreamWriterCopyingOutputStream(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 96) = 0;
  *(_WORD *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a1 + 96;
  *(void *)(a1 + 24) = &unk_26E714F10;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = &unk_26E6BE858;
  *(void *)(a1 + 48) = a1 + 24;
  *(_WORD *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)&double result = 0x2000;
  *(void *)(a1 + 80) = 0x2000;
  *(void *)(a1 + 88) = 0;
  *(void *)a1 = &unk_26E714EB8;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = a2;
  return result;
}

BOOL re::StreamWriterCopyingOutputStream::Flush(re::StreamWriterCopyingOutputStream *this)
{
  if (!*((unsigned char *)this + 8)) {
    return 1;
  }
  *((unsigned char *)this + 8) = 0;
  google::protobuf::io::CopyingOutputStreamAdaptor::Flush((re::StreamWriterCopyingOutputStream *)((char *)this + 40));
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 17) + 16))(*((void *)this + 17), *((void *)this + 16), *((void *)this + 14)) == *((void *)this + 14);
}

void re::StreamWriterCopyingOutputStream::~StreamWriterCopyingOutputStream(re::StreamWriterCopyingOutputStream *this)
{
  re::StreamWriterCopyingOutputStream::Flush(this);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 96);
  re::DynamicArrayBufferedOutputStream::~DynamicArrayBufferedOutputStream(this);
}

{
  uint64_t vars8;

  re::StreamWriterCopyingOutputStream::Flush(this);
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 96);
  re::DynamicArrayBufferedOutputStream::~DynamicArrayBufferedOutputStream(this);
  JUMPOUT(0x237DBCBD0);
}

void non-virtual thunk to're::StreamWriterCopyingOutputStream::~StreamWriterCopyingOutputStream(re::StreamWriterCopyingOutputStream *this)
{
  unint64_t v2 = (re::StreamWriterCopyingOutputStream *)((char *)this - 24);
  re::StreamWriterCopyingOutputStream::Flush((re::StreamWriterCopyingOutputStream *)((char *)this - 24));
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 72);
  re::DynamicArrayBufferedOutputStream::~DynamicArrayBufferedOutputStream(v2);
}

{
  re::StreamWriterCopyingOutputStream::~StreamWriterCopyingOutputStream((re::StreamWriterCopyingOutputStream *)((char *)this - 24));
}

void re::Bundle::application(void *a1@<X8>)
{
  id v3 = [MEMORY[0x263F086E0] mainBundle];
  *a1 = v3;
}

void re::Bundle::searchForAppOrAppExtension(re::Bundle *this@<X0>, void *a2@<X8>)
{
  id v13 = [NSString stringWithUTF8String:this];
  unint64_t v4 = [MEMORY[0x263F086E0] mainBundle];
  char v5 = [v4 bundleIdentifier];
  int v6 = [v5 isEqualToString:v13];

  if (!v6 || (id v7 = v4) == 0)
  {
    unint64_t v8 = [MEMORY[0x263F01890] bundleRecordWithBundleIdentifier:v13 allowPlaceholder:1 error:0];
    uint64_t v9 = v8;
    if (v8)
    {
      unint64_t v10 = (void *)MEMORY[0x263F086E0];
      uint64_t v11 = [v8 URL];
      id v7 = [v10 bundleWithURL:v11];
    }
    else
    {
      id v7 = 0;
    }
  }
  id v12 = v7;
  *a2 = v12;
}

void re::Bundle::findWithBundleID(re::Bundle *this@<X0>, void *a2@<X8>)
{
  unint64_t v4 = (void *)MEMORY[0x263F086E0];
  char v5 = [NSString stringWithUTF8String:this];
  int v6 = [v4 bundleWithIdentifier:v5];

  id v7 = v6;
  *a2 = v7;
}

void re::Bundle::findWithFilePath(re::Bundle *this@<X0>, void *a2@<X8>)
{
  unint64_t v4 = (void *)MEMORY[0x263F086E0];
  char v5 = [NSString stringWithUTF8String:this];
  int v6 = [v4 bundleWithPath:v5];

  id v7 = v6;
  *a2 = v7;
}

void re::Bundle::ID(id *this@<X0>, re::DynamicString *a2@<X8>)
{
  id v3 = [*this bundleIdentifier];
  id v5 = v3;
  if (v3)
  {
    unint64_t v4 = (_anonymous_namespace_ *)[v3 cStringUsingEncoding:4];
  }
  else
  {
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    re::DynamicString::setCapacity(a2, 0);
  }
}

void re::Bundle::bundlePath(id *this@<X0>, re::DynamicString *a2@<X8>)
{
  id v3 = [*this bundlePath];
  id v5 = v3;
  if (v3)
  {
    unint64_t v4 = (_anonymous_namespace_ *)[v3 cStringUsingEncoding:4];
  }
  else
  {
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    re::DynamicString::setCapacity(a2, 0);
  }
}

void re::Bundle::versionString(id *this@<X0>, re::DynamicString *a2@<X8>)
{
  id v3 = [*this infoDictionary];
  id v5 = [v3 valueForKey:@"CFBundleVersion"];

  if (v5)
  {
    unint64_t v4 = (_anonymous_namespace_ *)[v5 cStringUsingEncoding:4];
  }
  else
  {
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    re::DynamicString::setCapacity(a2, 0);
  }
}

BOOL re::Bundle::pathForResource(id *this, const char *a2, re::DynamicString *a3)
{
  id v5 = NSString;
  id v6 = *this;
  id v7 = [v5 stringWithUTF8String:a2];
  unint64_t v8 = [v6 pathForResource:v7 ofType:0];

  if (v8)
  {
    uint64_t v9 = (_anonymous_namespace_ *)[v8 cStringUsingEncoding:4];
    re::DynamicString::operator=(a3, (re::DynamicString *)&v11);
    if (v11)
    {
      if (v12) {
        (*(void (**)(void))(*(void *)v11 + 40))();
      }
    }
  }

  return v8 != 0;
}

void re::Bundle::testData(re::Bundle *this@<X0>, void *a2@<X8>)
{
  id v3 = (void *)MEMORY[0x237DBDCF0](this);
  re::Bundle::reResourcesFramework((uint64_t)v15);
  int v4 = v15[0];
  id v5 = v16;
  if (v15[0]) {
    id v6 = v16;
  }
  else {
    id v6 = 0;
  }
  id v7 = v6;
  if (v4) {

  }
  if (!v7)
  {
    re::Bundle::realityKitFramework((uint64_t)v15);
    int v8 = v15[0];
    id v5 = v16;
    if (v15[0]) {
      uint64_t v9 = v16;
    }
    else {
      uint64_t v9 = 0;
    }
    id v10 = v9;
    if (v8) {

    }
    if (!v10)
    {
      re::Bundle::reTestsDataFramework((uint64_t)v15);
      int v11 = v15[0];
      char v12 = v16;
      id v13 = v15[0] ? v16 : 0;
      id v5 = v13;
      if (v11) {
    }
      }
  }
  id v14 = v5;
  *a2 = v14;
}

void re::Bundle::reResourcesFramework(uint64_t a1@<X8>)
{
  if (qword_26AF98150 != -1) {
    dispatch_once(&qword_26AF98150, &__block_literal_global_14_1);
  }
  char v3 = qword_26AF98158;
  if (qword_26AF98158)
  {
    *(void *)(a1 + 8) = (id)qword_26AF98158;
    char v3 = 1;
  }
  *(unsigned char *)a1 = v3;
}

void re::Bundle::realityKitFramework(uint64_t a1@<X8>)
{
  if (qword_26AF98140 != -1) {
    dispatch_once(&qword_26AF98140, &__block_literal_global_36);
  }
  char v3 = qword_26AF98148;
  if (qword_26AF98148)
  {
    *(void *)(a1 + 8) = (id)qword_26AF98148;
    char v3 = 1;
  }
  *(unsigned char *)a1 = v3;
}

void re::Bundle::reTestsDataFramework(uint64_t a1@<X8>)
{
  if (qword_26AF98160 != -1) {
    dispatch_once(&qword_26AF98160, &__block_literal_global_24_0);
  }
  char v3 = qword_26AF98168;
  if (qword_26AF98168)
  {
    *(void *)(a1 + 8) = (id)qword_26AF98168;
    char v3 = 1;
  }
  *(unsigned char *)a1 = v3;
}

uint64_t re::Bundle::findFile@<X0>(re::Bundle *this@<X0>, const char *a2@<X1>, re::DynamicString *a3@<X8>)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  id v6 = (re *)re::DynamicString::rfind((uint64_t)&v27, 46, v25);
  if (v25[0])
  {
    unint64_t v7 = v26;
    re::DynamicString::substr((re::DynamicString *)&v27, 0, v26, (re::DynamicString *)buf);
    if (v28) {
      size_t v8 = v28 >> 1;
    }
    else {
      size_t v8 = v28 >> 1;
    }
    re::DynamicString::substr((re::DynamicString *)&v27, v7 + 1, v8, (re::DynamicString *)&v22);
    if (buf[8]) {
      uint64_t v9 = v30;
    }
    else {
      uint64_t v9 = &buf[9];
    }
    if (v23) {
      id v10 = *(unsigned char **)&v24[7];
    }
    else {
      id v10 = v24;
    }
    int v11 = [NSString stringWithUTF8String:v9];
    char v12 = [NSString stringWithUTF8String:v10];
    id v13 = *(id *)this;
    id v14 = [v13 pathForResource:v11 ofType:v12];
    unint64_t v15 = v14;
    if (v14)
    {
      uint64_t v16 = (_anonymous_namespace_ *)[v14 cStringUsingEncoding:4];
    }
    else
    {
      int v19 = *re::foundationIOLogObjects(0);
      BOOL v20 = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
      if (v20)
      {
        *(_DWORD *)uint64_t v31 = 136315394;
        uint64_t v32 = v9;
        __int16 v33 = 2080;
        uint64_t v34 = v10;
        _os_log_error_impl(&dword_233120000, v19, OS_LOG_TYPE_ERROR, "Could not locate file '%s.%s' in bundle.", v31, 0x16u);
      }
      *((void *)a3 + 1) = 0;
      *((void *)a3 + 2) = 0;
      *((void *)a3 + 3) = 0;
      re::DynamicString::setCapacity(a3, 0);
    }

    if (v22 && (v23 & 1) != 0) {
      (*(void (**)(void))(*(void *)v22 + 40))();
    }
    if (*(void *)buf && (buf[8] & 1) != 0) {
      (*(void (**)(void))(**(void **)buf + 40))();
    }
  }
  else
  {
    uint64_t v17 = *re::foundationIOLogObjects(v6);
    BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    if (v18)
    {
      *(_DWORD *)simd_float3x3 buf = 136315138;
      *(void *)&uint8_t buf[4] = a2;
      _os_log_error_impl(&dword_233120000, v17, OS_LOG_TYPE_ERROR, "Could not locate file '%s' in bundle; extension missing.",
        buf,
        0xCu);
    }
  }
  uint64_t result = v27;
  if (v27)
  {
    if (v28) {
      return (*(uint64_t (**)(void))(*(void *)v27 + 40))();
    }
  }
  return result;
}

id re::Bundle::coreREFramework@<X0>(void *a1@<X8>)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98138, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98138))
  {
    _MergedGlobals_416 = [MEMORY[0x263F086E0] bundleForClass:objc_opt_class()];
    __cxa_guard_release(&qword_26AF98138);
  }
  id result = (id)_MergedGlobals_416;
  *a1 = result;
  return result;
}

void ___ZN2re6Bundle19realityKitFrameworkEv_block_invoke()
{
  Class v0 = NSClassFromString(&cfstr_RealitykitArvi.isa);
  if (v0 || (Class v0 = NSClassFromString(&cfstr_RealitykitEnti.isa)) != 0)
  {
    uint64_t v1 = [MEMORY[0x263F086E0] bundleForClass:v0];
    unint64_t v2 = (void *)qword_26AF98148;
    qword_26AF98148 = v1;
  }
}

void ___ZN2re6Bundle20reResourcesFrameworkEv_block_invoke()
{
  Class v0 = NSClassFromString(&cfstr_Reresourcesobj.isa);
  if (v0)
  {
    uint64_t v1 = [MEMORY[0x263F086E0] bundleForClass:v0];
    unint64_t v2 = (void *)qword_26AF98158;
    qword_26AF98158 = v1;
  }
  re::Bundle::coreREFramework(&obj);
  if (!qword_26AF98158)
  {
    re::Bundle::ID(&obj, (re::DynamicString *)&v9);
    uint64_t v3 = v10[0] & 1;
    if (v10[0]) {
      int v4 = (const char *)v10[1];
    }
    else {
      int v4 = (char *)v10 + 1;
    }
    int v5 = strcmp(v4, "com.apple.CoreRE");
    if (v9 && v3) {
      (*(void (**)(void))(*(void *)v9 + 40))();
    }
    if (!v5) {
      objc_storeStrong((id *)&qword_26AF98158, obj);
    }
    if (!qword_26AF98158)
    {
      re::Bundle::realityKitFramework((uint64_t)&v9);
      int v6 = v9;
      unint64_t v7 = (void *)v10[0];
      if ((_BYTE)v9) {
        size_t v8 = (void *)v10[0];
      }
      else {
        size_t v8 = 0;
      }
      objc_storeStrong((id *)&qword_26AF98158, v8);
      if (v6) {
    }
      }
  }
}

void ___ZN2re6Bundle20reTestsDataFrameworkEv_block_invoke()
{
  if (!qword_26AF98168)
  {
    Class v0 = NSClassFromString(&cfstr_Retestsdataobj.isa);
    if (v0)
    {
      uint64_t v1 = [MEMORY[0x263F086E0] bundleForClass:v0];
      unint64_t v2 = (void *)qword_26AF98168;
      qword_26AF98168 = v1;
    }
  }
}

const char *re::bundleFrameworkIdentifier(re *this)
{
  uint64_t v1 = (void *)MEMORY[0x237DBDCF0](this);
  re::Bundle::reResourcesFramework((uint64_t)v14);
  int v2 = v14[0];
  uint64_t v3 = v15;
  if (v14[0]) {
    int v4 = v15;
  }
  else {
    int v4 = 0;
  }
  id v5 = v4;
  if (v2) {

  }
  if (!v5) {
    goto LABEL_9;
  }
  int v6 = [v5 bundleIdentifier];
  unint64_t v7 = "com.apple.CoreRE";
  size_t v8 = [NSString stringWithUTF8String:"com.apple.CoreRE"];
  char v9 = [v6 isEqualToString:v8];

  if ((v9 & 1) == 0)
  {
    id v10 = [v5 bundleIdentifier];
    unint64_t v7 = "com.apple.REResources";
    int v11 = [NSString stringWithUTF8String:"com.apple.REResources"];
    char v12 = [v10 isEqualToString:v11];

    if ((v12 & 1) == 0) {
LABEL_9:
    }
      unint64_t v7 = "com.apple.RealityKit";
  }

  return v7;
}

unsigned char *re::stringToLowerCase@<X0>(re *this@<X0>, re::DynamicString *a2@<X8>)
{
  unint64_t v6 = *((void *)a2 + 1);
  if (v6) {
    unint64_t v7 = v6 >> 1;
  }
  else {
    unint64_t v7 = v6 >> 1;
  }
  if (v7)
  {
    for (unint64_t i = 0; i < v12; ++i)
    {
      char v9 = (char *)re::DynamicString::operator[]((uint64_t)a2, i);
      char v10 = __tolower(*v9);
      id result = (unsigned char *)re::DynamicString::operator[]((uint64_t)a2, i);
      *id result = v10;
      unint64_t v11 = *((void *)a2 + 1);
      if (v11) {
        unint64_t v12 = v11 >> 1;
      }
      else {
        unint64_t v12 = v11 >> 1;
      }
    }
  }
  return result;
}

BOOL re::ensureFolderExists(re *this, const char *a2)
{
  if (!stat((const char *)this, &v11) && (v11.st_mode & 0x4000) != 0) {
    return 1;
  }
  std::string::basic_string[abi:nn180100]<0>(&v11, (char *)this);
  std::string::size_type v4 = std::string::rfind((const std::string *)&v11, 47, 0xFFFFFFFFFFFFFFFFLL);
  if (v4 == -1)
  {
    BOOL v3 = 0;
    goto LABEL_17;
  }
  std::string::basic_string(&__p, (const std::string *)&v11, 0, v4, (std::allocator<char> *)&v12);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = (re *)&__p;
  }
  else {
    p_p = (re *)__p.__r_.__value_.__r.__words[0];
  }
  uint64_t v7 = re::ensureFolderExists(p_p, v5);
  BOOL v3 = v7;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (!v3) {
      goto LABEL_17;
    }
LABEL_13:
    if ((v11.st_gid & 0x80000000) == 0) {
      size_t v8 = &v11;
    }
    else {
      size_t v8 = *(stat **)&v11.st_dev;
    }
    BOOL v3 = mkdir((const char *)v8, 0x1EDu) == 0;
    goto LABEL_17;
  }
  if (v7) {
    goto LABEL_13;
  }
LABEL_17:
  if (SHIBYTE(v11.st_gid) < 0) {
    operator delete(*(void **)&v11.st_dev);
  }
  return v3;
}

BOOL re::ensureFolderExistsForFile(re *this, const char *a2)
{
  std::string::basic_string[abi:nn180100]<0>(&__str, (char *)this);
  std::string::size_type v2 = std::string::rfind(&__str, 47, 0xFFFFFFFFFFFFFFFFLL);
  if (v2 == -1)
  {
    BOOL v5 = 0;
  }
  else
  {
    std::string::basic_string(&v7, &__str, 0, v2, (std::allocator<char> *)&v9);
    if ((v7.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v4 = &v7;
    }
    else {
      std::string::size_type v4 = (std::string *)v7.__r_.__value_.__r.__words[0];
    }
    BOOL v5 = re::ensureFolderExists((re *)v4, v3);
    if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v7.__r_.__value_.__l.__data_);
    }
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return v5;
}

void re::fileURLWithPath(re *this@<X0>, re::DynamicString *a2@<X8>)
{
  std::string::size_type v4 = NSURL;
  BOOL v5 = [NSString stringWithUTF8String:this];
  id v8 = [v4 fileURLWithPath:v5 isDirectory:0];

  id v6 = [v8 absoluteString];
  std::string v7 = (_anonymous_namespace_ *)[v6 UTF8String];
}

void re::filePathWithURL(re *this@<X0>, re::DynamicString *a2@<X8>)
{
  id v7 = [NSString stringWithUTF8String:this];
  std::string::size_type v4 = [NSURL URLWithString:v7];
  id v5 = [v4 path];
  id v6 = (_anonymous_namespace_ *)[v5 UTF8String];
}

void re::filePathURLConverted(re *this@<X0>, re::DynamicString *a2@<X8>)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  BOOL v3 = [NSString stringWithUTF8String:this];
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  std::string::size_type v4 = [v3 pathComponents];
  uint64_t v5 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v17;
    id v8 = &stru_26E738380;
    do
    {
      uint64_t v9 = 0;
      char v10 = v8;
      do
      {
        if (*(void *)v17 != v7) {
          objc_enumerationMutation(v4);
        }
        stat v11 = [NSURL fileURLWithPath:*(void *)(*((void *)&v16 + 1) + 8 * v9) isDirectory:0];
        char v12 = [v11 lastPathComponent];
        id v8 = [(__CFString *)v10 stringByAppendingPathComponent:v12];

        ++v9;
        char v10 = v8;
      }
      while (v6 != v9);
      uint64_t v6 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v6);
  }
  else
  {
    id v8 = &stru_26E738380;
  }

  id v13 = v8;
  id v14 = (_anonymous_namespace_ *)[(__CFString *)v13 UTF8String];
}

void re::pathsToFilesInDirectory(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  uint64_t v5 = [NSString stringWithUTF8String:a1];
  uint64_t v6 = [MEMORY[0x263F08850] defaultManager];
  id v41 = 0;
  uint64_t v7 = [v6 contentsOfDirectoryAtPath:v5 error:&v41];
  id v8 = v41;

  if (v7)
  {
    id v27 = v8;
    uint64_t v28 = a3;
    uint64_t v40 = 0;
    uint64_t v38 = 0;
    long long v37 = 0uLL;
    LODWORD(v39) = 0;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    unint64_t v26 = v7;
    id v9 = v7;
    uint64_t v10 = [v9 countByEnumeratingWithState:&v33 objects:v42 count:16];
    if (v10)
    {
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)v34;
      do
      {
        for (uint64_t i = 0; i != v11; ++i)
        {
          if (*(void *)v34 != v12) {
            objc_enumerationMutation(v9);
          }
          id v14 = *(void **)(*((void *)&v33 + 1) + 8 * i);
          id v15 = [v14 pathExtension];
          uint64_t v16 = [v15 UTF8String];
          uint64_t v17 = *(void *)(a2 + 24);
          uint64_t v29 = v16;
          if (!v17) {
            std::__throw_bad_function_call[abi:nn180100]();
          }
          int v18 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v17 + 48))(v17, &v29);

          if (v18)
          {
            re::DynamicString::format((re::DynamicString *)"%s/%s", (re::DynamicString *)&v29, [v5 UTF8String], objc_msgSend(objc_retainAutorelease(v14), "UTF8String"));
            double v19 = re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)&v37, &v29);
            if (v29)
            {
              if (v30) {
                (*(void (**)(double))(*(void *)v29 + 40))(v19);
              }
            }
          }
        }
        uint64_t v11 = [v9 countByEnumeratingWithState:&v33 objects:v42 count:16];
      }
      while (v11);
    }

    re::DynamicArray<re::DynamicString>::DynamicArray((uint64_t)&v29, (uint64_t *)&v37);
    uint64_t v20 = v29;
    *(unsigned char *)uint64_t v28 = 1;
    *(void *)(v28 + 8) = v20;
    *(_OWORD *)(v28 + 16) = v30;
    uint64_t v29 = 0;
    long long v30 = 0uLL;
    *(void *)(v28 + 40) = v32;
    uint64_t v32 = 0;
    ++v31;
    *(_DWORD *)(v28 + 32) = 1;
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v29);
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v37);
    uint64_t v7 = v26;
    id v8 = v27;
  }
  else
  {
    id v21 = [v8 localizedDescription];
    uint64_t v22 = (_anonymous_namespace_ *)[v21 UTF8String];
    long long v23 = v37;
    long long v37 = 0uLL;
    uint64_t v24 = v38;
    uint64_t v25 = v39;
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    *(unsigned char *)a3 = 0;
    *(_OWORD *)(a3 + 8) = v23;
    *(void *)(a3 + 24) = v24;
    *(void *)(a3 + 32) = v25;
  }
}

void std::__function::__func<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0,std::allocator<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0>,BOOL ()(char const*)>::~__func()
{
}

void *std::__function::__func<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0,std::allocator<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0>,BOOL ()(char const*)>::__clone(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *id result = &unk_26E714FB0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0,std::allocator<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0>,BOOL ()(char const*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E714FB0;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0,std::allocator<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0>,BOOL ()(char const*)>::operator()(uint64_t a1, const char **a2)
{
  return strcmp(*a2, *(const char **)(a1 + 8)) == 0;
}

uint64_t std::__function::__func<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0,std::allocator<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0>,BOOL ()(char const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0,std::allocator<re::pathsToFilesWithPathExtensionInDirectory(char const*,char const*)::$_0>,BOOL ()(char const*)>::target_type()
{
}

void re::FileStreamWriter::~FileStreamWriter(re::FileStreamWriter *this)
{
  uint64_t v2 = (FILE *)*((void *)this + 1);
  if (v2)
  {
    if (*((unsigned char *)this + 16))
    {
      fclose(v2);
      *((void *)this + 1) = 0;
      *((unsigned char *)this + 16) = 0;
    }
  }
}

{
  FILE *v2;
  uint64_t vars8;

  uint64_t v2 = (FILE *)*((void *)this + 1);
  if (v2 && *((unsigned char *)this + 16))
  {
    fclose(v2);
    *((void *)this + 1) = 0;
    *((unsigned char *)this + 16) = 0;
  }
  JUMPOUT(0x237DBCBD0);
}

FILE *re::FileStreamWriter::open@<X0>(re::FileStreamWriter *this@<X0>, uint64_t a2@<X8>)
{
  id result = fopen((const char *)this, "wb");
  if (result)
  {
    *(unsigned char *)a2 = 1;
    *(void *)(a2 + 8) = &unk_26E715030;
    *(unsigned char *)(a2 + 24) = 1;
  }
  else
  {
    uint64_t v6 = __error();
    uint64_t v7 = strerror(*v6);
    re::DynamicString::format((re::DynamicString *)"Failed to open file \"%s\" for writing. Details: %s", (re::DynamicString *)&v11, this, v7);
    long long v8 = v11;
    uint64_t v9 = v12;
    uint64_t v10 = v13;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 300;
    *(_OWORD *)(a2 + 24) = v8;
    *(void *)(a2 + 40) = v9;
    *(void *)(a2 + 48) = v10;
    id result = (FILE *)re::FoundationErrorCategory(void)::instance;
  }
  *(void *)(a2 + 16) = result;
  return result;
}

size_t re::FileStreamWriter::writeBytes(FILE **this, const void *__ptr, size_t a3)
{
  return fwrite(__ptr, 1uLL, a3, this[1]);
}

size_t re::StringStreamWriter::writeBytes(re::DynamicString **this, const char *a2, size_t a3)
{
  return a3;
}

void re::StringStreamWriter::~StringStreamWriter(re::StringStreamWriter *this)
{
}

size_t re::MemoryStreamReader::readBytes(re::MemoryStreamReader *this, void *__dst, size_t a3)
{
  uint64_t v3 = *((void *)this + 1);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = *((void *)this + 3);
  if (*((void *)this + 2) - v5 >= a3) {
    size_t v6 = a3;
  }
  else {
    size_t v6 = *((void *)this + 2) - v5;
  }
  memcpy(__dst, (const void *)(v3 + v5), v6);
  *((void *)this + 3) += v6;
  return v6;
}

uint64_t re::MemoryStreamReader::bytesRemaining(re::MemoryStreamReader *this)
{
  return *((void *)this + 2) - *((void *)this + 3);
}

size_t re::MemoryStreamReader::seekAndRead(re::MemoryStreamReader *this, void *__dst, unint64_t a3, size_t a4)
{
  uint64_t v4 = *((void *)this + 1);
  if (!v4) {
    return 0;
  }
  unint64_t v5 = *((void *)this + 2);
  if (v5 >= a3) {
    unint64_t v6 = a3;
  }
  else {
    unint64_t v6 = *((void *)this + 2);
  }
  size_t v7 = v5 - v6;
  if (v7 >= a4) {
    size_t v8 = a4;
  }
  else {
    size_t v8 = v7;
  }
  memcpy(__dst, (const void *)(v4 + v6), v8);
  return v8;
}

void re::MemoryStreamReader::~MemoryStreamReader(re::MemoryStreamReader *this)
{
}

uint64_t re::MemoryStreamReader::bytesRead(re::MemoryStreamReader *this)
{
  return *((void *)this + 3);
}

unint64_t re::MemoryStreamReader::skipBytes(re::MemoryStreamReader *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 3);
  unint64_t v3 = *((void *)this + 2) - v2;
  if (v3 >= a2) {
    unint64_t v3 = a2;
  }
  *((void *)this + 3) = v3 + v2;
  return v3;
}

BOOL re::MemoryStreamReader::seek(re::MemoryStreamReader *this, unint64_t a2)
{
  unint64_t v2 = *((void *)this + 2);
  if (v2 >= a2) {
    *((void *)this + 3) = a2;
  }
  return v2 >= a2;
}

uint64_t re::internal::canAppendGeomMeshToGeomMesh(re::internal *this, const re::GeomMesh *a2, const re::GeomMesh *a3)
{
  uint64_t v4 = (re::internal *)((char *)this + 64);
  int v5 = *((_DWORD *)this + 160);
  if (v5)
  {
    for (unsigned int i = 0; v5 != i; ++i)
    {
      uint64_t v7 = re::internal::GeomAttributeManager::attributeByIndex(v4, i);
      uint64_t v8 = re::internal::GeomAttributeManager::attributeByName((const re::GeomMesh *)((char *)a2 + 64), *(const char **)(v7 + 8));
      if (v8)
      {
        if (*(unsigned __int8 *)(v7 + 17) != *(unsigned __int8 *)(v8 + 17)) {
          return 0;
        }
        int v9 = *(unsigned __int8 *)(v7 + 16);
        int v10 = *(unsigned __int8 *)(v8 + 16);
        if (v10 == v9)
        {
          if (!*(unsigned char *)(v7 + 16))
          {
            uint64_t result = re::GeomAttribute::operator==(v7, v8);
            if (!result) {
              return result;
            }
          }
        }
        else
        {
          unsigned int v12 = v10 & 0xFFFFFFFD;
          if ((v9 & 0xFFFFFFFD) != 1 || v12 != 1) {
            return 0;
          }
        }
      }
    }
  }
  uint64_t v14 = re::internal::GeomAttributeManager::attributeByName((const re::GeomMesh *)((char *)a2 + 64), "skinnedAnimationGeometryBindTransform");
  uint64_t v15 = re::internal::GeomAttributeManager::attributeByName(v4, "skinnedAnimationGeometryBindTransform");
  if (!v14) {
    return 1;
  }
  if (!v15) {
    return 1;
  }
  uint64_t result = re::GeomAttribute::operator==(v15, v15);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t re::internal::appendGeomMeshToGeomMesh(_DWORD *a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t v4 = (re::internal::GeomAttributeManager *)(a2 + 64);
  uint64_t v5 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a2 + 64), "skinnedAnimationInfluenceEndIndices");
  uint64_t v6 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a1 + 16), "skinnedAnimationInfluenceEndIndices");
  if (!(v5 | v6)) {
    goto LABEL_21;
  }
  uint64_t v8 = v6;
  uint64_t v9 = a1[4];
  if (v5)
  {
    int v10 = *(_DWORD *)(a2 + 16);
    if (v10)
    {
      uint64_t v11 = re::internal::GeomAttributeManager::attributeByName(v4, "skinnedAnimationInfluenceEndIndices");
      if (!(*(unsigned int (**)(uint64_t))(*(void *)v11 + 16))(v11))
      {
        unsigned int v28 = 0;
        unsigned int v14 = v10 - 1;
        goto LABEL_38;
      }
      uint64_t v12 = re::internal::GeomTypedAttribute<float>::operator[](v11, 0);
      unsigned int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
      unsigned int v14 = v10 - 1;
      if (v13 <= v14)
      {
        while (1)
        {
          unsigned int v28 = v13;
LABEL_38:
          long long v32 = 0u;
          long long v33 = 0u;
          long long v30 = 0u;
          long long v31 = 0u;
          *(_OWORD *)uint64_t v29 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v34 = 136315906;
          long long v35 = "operator[]";
          __int16 v36 = 1024;
          int v37 = 609;
          __int16 v38 = 2048;
          uint64_t v39 = v14;
          __int16 v40 = 2048;
          uint64_t v41 = v28;
          _os_log_send_and_compose_impl();
          unsigned int v13 = _os_crash_msg();
          __break(1u);
        }
      }
      int v10 = *(_DWORD *)(v12 + 4 * v14);
    }
    if (v8)
    {
LABEL_8:
      if (!v9) {
        goto LABEL_18;
      }
LABEL_12:
      uint64_t v15 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a1 + 16), "skinnedAnimationInfluenceEndIndices");
      if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 16))(v15))
      {
        uint64_t v16 = re::internal::GeomTypedAttribute<float>::operator[](v15, 0);
        uint64_t v17 = (*(unsigned int (**)(uint64_t))(*(void *)v15 + 16))(v15);
      }
      else
      {
        uint64_t v17 = 0;
        uint64_t v16 = 0;
      }
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (v17 == i)
        {
          long long v32 = 0u;
          long long v33 = 0u;
          long long v30 = 0u;
          long long v31 = 0u;
          *(_OWORD *)uint64_t v29 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v34 = 136315906;
          long long v35 = "operator[]";
          __int16 v36 = 1024;
          int v37 = 609;
          __int16 v38 = 2048;
          uint64_t v39 = v17;
          __int16 v40 = 2048;
          uint64_t v41 = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        *(_DWORD *)(v16 + 4 * i) += v10;
      }
      goto LABEL_18;
    }
  }
  else
  {
    int v10 = 0;
    if (v8) {
      goto LABEL_8;
    }
  }
  if (v9) {
    goto LABEL_12;
  }
LABEL_18:
  if (v5 && v8) {
    re::internal::GeomAttributeManager::deleteAttribute((re::internal::GeomAttributeManager *)(a1 + 16), "skinnedAnimationGeometryBindTransform");
  }
LABEL_21:
  if (re::meshHasSubdivCreases((re *)a1, v7))
  {
    double v19 = (const char *)*(unsigned int *)(a2 + 16);
  }
  int v20 = a1[160];
  if (v20)
  {
    for (unsigned int j = 0; j != v20; ++j)
    {
      uint64_t v22 = re::internal::GeomAttributeManager::attributeByIndex((re::internal::GeomAttributeManager *)(a1 + 16), j);
      uint64_t v23 = re::internal::GeomAttributeManager::attributeByName(v4, *(const char **)(v22 + 8));
      if (v23)
      {
        int v24 = *(unsigned __int8 *)(v22 + 16);
        int v25 = *(unsigned __int8 *)(v23 + 16);
        if (v25 != v24)
        {
          if (v25 == 1) {
            re::internal::GeomBaseMesh::replaceVertexAttributeWithFaceVaryingAttribute((re::internal::GeomBaseMesh *)(a2 + 16), *(char **)(v23 + 8));
          }
          if (v24 == 1) {
            re::internal::GeomBaseMesh::replaceVertexAttributeWithFaceVaryingAttribute((re::internal::GeomBaseMesh *)(a1 + 4), *(char **)(v22 + 8));
          }
        }
      }
    }
  }
  re::GeomMeshBuilder::GeomMeshBuilder((re *)v29, a2);
  re::GeomMeshBuilder::appendMesh((re::GeomMeshBuilder *)v29, (const re::GeomMesh *)a1);
  unint64_t v26 = (re *)re::GeomMesh::operator=(a2, &v29[1]);
  re::GeomMesh::setName(v26, v29[0]);
  re::GeomMesh::freeName((re *)v29);
  re::GeomMesh::clear((re::GeomMesh *)a1);
  re::GeomMesh::freeName((re *)v29);
  re::internal::GeomAttributeManager::~GeomAttributeManager((re::internal::GeomAttributeManager *)((char *)&v32 + 8));
  uint64_t result = v30;
  if ((void)v30)
  {
    if ((void)v32) {
      return (*(uint64_t (**)(void))(*(void *)v30 + 40))();
    }
  }
  return result;
}

uint64_t re::internal::anonymous namespace'::addSkinningInfluenceIndicesEndToMesh(re::internal::_anonymous_namespace_ *this, re::GeomMesh *a2)
{
  uint64_t result = re::internal::GeomAttributeManager::attributeByName((re::internal::_anonymous_namespace_ *)((char *)this + 64), "skinnedAnimationInfluenceEndIndices");
  if (!result)
  {
    uint64_t v4 = *((unsigned int *)this + 4);
    uint64_t v5 = re::GeomMesh::addAttribute((uint64_t)this, "skinnedAnimationInfluenceEndIndices", 4, 2);
    if (!v5) {
      goto LABEL_12;
    }
    uint64_t v7 = (uint64_t)v5;
    (*(void (**)(re::GeomAttribute *, uint64_t))(*(void *)v5 + 24))(v5, v4);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
    if (result)
    {
      uint64_t v8 = re::internal::GeomTypedAttribute<float>::operator[](v7, 0);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
      uint64_t v9 = result;
      if (!v4) {
        return result;
      }
      goto LABEL_7;
    }
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    if (v4)
    {
LABEL_7:
      uint64_t v10 = 0;
      while (v9 != v10)
      {
        *(_DWORD *)(v8 + 4 * v10++) = 0;
        if (v4 == v10) {
          return result;
        }
      }
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_12:
      re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "influencesEndOffsetAttr != nullptr", "addSkinningInfluenceIndicesEndToMesh", 30);
      _os_crash();
      __break(1u);
    }
  }
  return result;
}

unsigned char *re::internal::anonymous namespace'::addOffsetToAllValuesForAttribute(re::internal::_anonymous_namespace_ *this, re::GeomMesh *a2, const char *a3)
{
  int v3 = (int)a3;
  uint64_t result = (unsigned char *)re::internal::GeomAttributeManager::attributeByName((re::internal::_anonymous_namespace_ *)((char *)this + 64), (const char *)a2);
  if (result)
  {
    uint64_t v5 = (uint64_t)result;
    if (result[17] == 3)
    {
      if ((*(unsigned int (**)(unsigned char *))(*(void *)result + 16))(result))
      {
        uint64_t v6 = re::internal::GeomTypedAttribute<float>::operator[](v5, 0);
        uint64_t v7 = (*(unsigned int (**)(uint64_t))(*(void *)v5 + 16))(v5);
      }
      else
      {
        uint64_t v7 = 0;
        uint64_t v6 = 0;
      }
      uint64_t result = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
      if (result)
      {
        uint64_t v8 = 0;
        do
        {
          if (v7 == v8)
          {
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          *(_DWORD *)(v6 + 4 * v8++) += v3;
        }
        while (result != v8);
      }
    }
  }
  return result;
}

void re::ktxMipInfo(id *a1@<X0>, uint64_t a2@<X8>)
{
  id v3 = *a1;
  MTLPixelFormatGetInfoForDevice();
  if ((v7 & 1) == 0)
  {

    id v3 = 0;
  }
  *(void *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  MTLGetTextureLevelInfoForDeviceWithOptions();
  unint64_t v4 = (*(void *)(a2 + 80) + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v5 = *(void *)(a2 + 40);
  unint64_t v6 = *(void *)(a2 + 32) * v4;
  *(void *)(a2 + 80) = v4;
  *(void *)(a2 + 88) = v6;
  *(void *)(a2 + 96) = v5 * v6;
}

uint64_t re::canLoadPixelFormat(void *a1, id *a2)
{
  if (!*a1) {
    return 1;
  }
  if (re::isASTCPixelFormat((int)objc_msgSend(*a2, sel_pixelFormat))) {
    return 1;
  }
  objc_msgSend(*a2, sel_textureType);
  uint64_t result = re::isSupportedPixelFormat();
  if (result) {
    return 1;
  }
  return result;
}

CFComparisonResult re::useImageIOForTextureImport(uint64_t a1, id *a2, uint64_t a3)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (objc_msgSend(*a2, sel_textureType) != (id)2) {
    return 0;
  }
  uint64_t canLoadPixelFormat = re::canLoadPixelFormat((void *)a1, a2);
  if ((canLoadPixelFormat & 1) == 0)
  {
    uint64_t v17 = *re::pipelineLogObjects((re *)canLoadPixelFormat);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      id v18 = *a2;
      unsigned int v13 = v17;
      *(_DWORD *)simd_float3x3 buf = 134217984;
      *(void *)&uint8_t buf[4] = objc_msgSend(v18, sel_pixelFormat);
      unsigned int v14 = "KTX Texture Import: Pixel format %lu is not supported on current platform, using ImageIO to perform conversi"
            "on to supported pixel format.";
      uint64_t v15 = v13;
      uint32_t v16 = 12;
      goto LABEL_12;
    }
    return 1;
  }
  if (!*(unsigned char *)(a1 + 16)
    || objc_msgSend(*a2, sel_textureType) != (id)2
    || (*(_DWORD *)(a3 + 56) - 3) > 1)
  {
    return 0;
  }
  CFComparisonResult result = (CFComparisonResult)*(id *)(a3 + 64);
  if (result == kCFCompareEqualTo) {
    return result;
  }
  CFStringRef v8 = (const __CFString *)result;
  objc_msgSend(*a2, sel_pixelFormat);
  uint64_t v38 = 0;
  long long v37 = 0u;
  memset(buf, 0, sizeof(buf));
  MTLPixelFormatGetInfoForDevice();
  BOOL HasSRGBTransfer = re::colorSpaceNameHasSRGBTransfer(v8, v9);
  if (HasSRGBTransfer)
  {
    uint64_t v11 = *re::pipelineLogObjects((re *)HasSRGBTransfer);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = *a2;
      unsigned int v13 = v11;
      *(_DWORD *)simd_float3x3 buf = 134218754;
      *(void *)&uint8_t buf[4] = objc_msgSend(v12, sel_pixelFormat);
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "is";
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = CFStringGetCStringPtr(v8, 0x8000100u);
      LOWORD(v37) = 2080;
      *(void *)((char *)&v37 + 2) = "does not use";
      unsigned int v14 = "Pixel format %lu %s linear while colorspace %s %s a linear transfer function. Using ImageIO to facilitate th"
            "e gamma transfer function conversion.";
      uint64_t v15 = v13;
      uint32_t v16 = 42;
LABEL_12:
      _os_log_impl(&dword_233120000, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);

      return 1;
    }
    return 1;
  }
  double v19 = CGColorSpaceCreateWithName(v8);
  if (!v19)
  {
    long long v30 = *re::pipelineLogObjects(0);
    BOOL v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
    CFComparisonResult result = kCFCompareEqualTo;
    if (!v31) {
      return result;
    }
    long long v32 = v30;
    *(_DWORD *)simd_float3x3 buf = 136315138;
    *(void *)&uint8_t buf[4] = CFStringGetCStringPtr(v8, 0x8000100u);
    _os_log_impl(&dword_233120000, v32, OS_LOG_TYPE_DEFAULT, "Invalid colorSpaceNameOverride: %s", buf, 0xCu);

    return 0;
  }
  int v20 = v19;
  size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(v19);
  BOOL IsExtendedOrHDR = re::internal::colorSpaceIsExtendedOrHDR(v20, v22);
  CGColorSpaceRelease(v20);
  objc_msgSend(*a2, sel_pixelFormat);
  uint64_t v38 = 0;
  long long v37 = 0u;
  memset(buf, 0, sizeof(buf));
  MTLPixelFormatGetInfoForDevice();
  CFStringRef v24 = (const __CFString *)re::computeWorkingColorSpaceName((unsigned char *)a1, NumberOfComponents, 0, IsExtendedOrHDR);
  if (!v24)
  {
    long long v33 = *re::pipelineLogObjects(0);
    BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
    CFComparisonResult result = kCFCompareEqualTo;
    if (!v34) {
      return result;
    }
    *(_WORD *)simd_float3x3 buf = 0;
    _os_log_impl(&dword_233120000, v33, OS_LOG_TYPE_DEFAULT, "KTX Texture Import: Working colorspace was nullptr, skipping ImageIO.", buf, 2u);
    return 0;
  }
  CFComparisonResult result = CFStringCompare(v8, v24, 0);
  if (result)
  {
    uint64_t ColorGamutFromCGColorSpaceName = re::ColorHelpers::getColorGamutFromCGColorSpaceName(v8, &v35);
    int v26 = ColorGamutFromCGColorSpaceName;
    if ((ColorGamutFromCGColorSpaceName & 1) == 0)
    {
      id v27 = *re::pipelineLogObjects((re *)ColorGamutFromCGColorSpaceName);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v28 = v27;
        if (*(unsigned char *)(a1 + 19)) {
          unsigned __int8 v29 = *(unsigned char *)(a1 + 20);
        }
        else {
          unsigned __int8 v29 = 0;
        }
        *(_DWORD *)simd_float3x3 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v29;
        _os_log_impl(&dword_233120000, v28, OS_LOG_TYPE_DEFAULT, "KTX Texture Import: Using ImageIO to convert from source color gamut to destination color gamut: %d", buf, 8u);
      }
    }
    return (unint64_t)(v26 ^ 1u);
  }
  return result;
}

void re::createTextureWithKTXData(uint64_t a1@<X0>, __n128 *a2@<X1>, unint64_t a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, int a8@<W7>, uint64_t a9@<X8>, uint64_t a10)
{
  uint64_t v120 = *MEMORY[0x263EF8340];
  unsigned int v103 = a4;
  if (!v113[0])
  {
    CFStringRef v24 = *re::pipelineLogObjects(v17);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      if (v115) {
        int v26 = *(unsigned char **)&v116[7];
      }
      else {
        int v26 = v116;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v26;
      _os_log_error_impl(&dword_233120000, v24, OS_LOG_TYPE_ERROR, "Failed to create texture from KTX: %s", (uint8_t *)&buf, 0xCu);
    }
    *(unsigned char *)a9 &= 0x80u;
    *(void *)(a9 + 8) = 0;
    *(_DWORD *)(a9 + 88) = 0;
    *(void *)(a9 + 96) = 0;
    goto LABEL_151;
  }
  id v102 = v117;
  int v101 = 0;
  {
    *(unsigned char *)a9 &= 0x80u;
    *(void *)(a9 + 8) = 0;
    *(_DWORD *)(a9 + 88) = 0;
    *(void *)(a9 + 96) = 0;
LABEL_149:
    if (v102) {

    }
LABEL_151:
    return;
  }
  uint64_t v90 = a5;
  BOOL v18 = 0;
  uint64_t v19 = v101;
  LOBYTE(v96) = 0;
  v97[0] = 0;
  unsigned int v99 = 0;
  id v100 = 0;
  if (*(unsigned char *)(a1 + 16) && (*(_DWORD *)(a6 + 56) - 3) <= 1)
  {
    uint64_t v20 = v101;
    id v21 = (re::ColorHelpers *)*(id *)(a6 + 64);
    if (v21 && (uint64_t v23 = v21, !re::ColorHelpers::isGrayScaleCGColorSpaceName(v21, v22)))
    {
      LOBYTE(buf) = 0;
      if (re::ColorHelpers::getColorGamutFromCGColorSpaceName(v23, (char *)&buf))
      {
        objc_msgSend(v102, sel_pixelFormat);
        if (re::getComponentCount() == 1)
        {
          BOOL v25 = 0;
        }
        else
        {
          if (*(unsigned char *)(a1 + 19)) {
            unsigned __int8 v27 = *(unsigned char *)(a1 + 20);
          }
          else {
            unsigned __int8 v27 = 0;
          }
          BOOL v25 = buf != v27;
        }
      }
      else
      {
        BOOL v25 = 1;
      }
      uint64_t v19 = v20;
      BOOL v18 = v25;
    }
    else
    {
      uint64_t v19 = v20;
      BOOL v18 = 0;
    }
  }
  if (!re::useImageIOForTextureImport(a1, &v102, a6))
  {
    uint64_t canLoadPixelFormat = (re *)re::canLoadPixelFormat((void *)a1, &v102);
    if (!canLoadPixelFormat)
    {
      __int16 v40 = *re::pipelineLogObjects(canLoadPixelFormat);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        id v41 = v102;
        uint64_t v42 = v40;
        LODWORD(v41) = objc_msgSend(v41, sel_pixelFormat);
        unsigned int v43 = objc_msgSend(v102, sel_textureType);
        LODWORD(buf) = 67109376;
        DWORD1(buf) = v41;
        WORD4(buf) = 1024;
        *(_DWORD *)((char *)&buf + 10) = v43;
        _os_log_error_impl(&dword_233120000, v42, OS_LOG_TYPE_ERROR, "Unsupported pixel format %d for texture type %d", (uint8_t *)&buf, 0xEu);
      }
      goto LABEL_50;
    }
    int v89 = v19;
    if (v19)
    {
      objc_msgSend(v102, sel_setPixelFormat_, v19);
      if (!*(void *)a1)
      {
        char v39 = 0;
        goto LABEL_57;
      }
    }
    else if (!*(void *)a1)
    {
      char v49 = 0;
      *(void *)uint64_t v104 = 0;
      goto LABEL_63;
    }
    objc_msgSend(v102, sel_pixelFormat);
    objc_msgSend(v102, sel_textureType);
    char isSupportedPixelFormat = re::isSupportedPixelFormat();
    char v46 = isSupportedPixelFormat;
    id v47 = *(id *)a1;
    if (!v89 || v47)
    {
      *(void *)uint64_t v104 = v47;
      if (v46)
      {
LABEL_59:
        char v49 = 0;
LABEL_63:
        unint64_t v94 = 0;
        uint64_t v50 = *(void *)(a1 + 24);
        id v51 = *(id *)v104;
        float32x4_t v52 = v51;
        if (a3 > 0x500000 && v50)
        {
          id v53 = v93;
          unint64_t v88 = v94;
          id v54 = v93;
          uint64_t v55 = (os_unfair_lock_s *)(*(void *)(a1 + 24) + 128);
          os_unfair_lock_lock(v55);
          id v56 = v52;
          *(void *)&long long buf = v56;
          *(void *)&long long v112 = v54;
          char v57 = re::processKtxMips((id *)&buf, (re *)a1, a6, v90, (uint64_t)&v114, &v114, &v102, v88, (id *)&v112, v49, a10, (uint64_t)&v96);
          if ((void)v112)
          {

            *(void *)&long long v112 = 0;
          }

          os_unfair_lock_unlock(v55);
          if (v54) {

          }
          if ((v57 & 1) == 0)
          {
LABEL_70:
            *(unsigned char *)a9 &= 0x80u;
            *(void *)(a9 + 8) = 0;
            *(_DWORD *)(a9 + 88) = 0;
            *(void *)(a9 + 96) = 0;
            if (v53) {

            }
            goto LABEL_147;
          }
        }
        else
        {
          id v92 = v51;
          id v53 = v93;
          unint64_t v58 = v94;
          id v91 = v93;
          int v59 = re::processKtxMips(&v92, (re *)a1, a6, v90, (uint64_t)&v114, &v114, &v102, v58, &v91, v49, a10, (uint64_t)&v96);
          if (v91)
          {

            id v91 = 0;
          }

          if (!v59) {
            goto LABEL_70;
          }
        }
        if (v53) {

        }
        LOBYTE(v96) = v96 & 0xDF | (32 * v118);
        uint64_t v36 = v90;
        if (v18)
        {
          v104[0] = 0;
          if (re::ColorHelpers::getColorGamutFromCGColorSpaceName(*(id *)(a6 + 64), v104))
          {
            unsigned __int8 v60 = *(unsigned char *)(a1 + 19) ? *(unsigned char *)(a1 + 20) : 0;
            if (v104[0] != v60)
            {
              if (!v100) {
                re::TextureData::setColorSpace(&v96, (__CFString *)*(id *)(a6 + 64));
              }
              objc_msgSend(v102, sel_pixelFormat);
              uint64_t v108 = 0;
              long long v106 = 0u;
              long long v107 = 0u;
              long long buf = 0u;
              InfoForDevice = (re *)MTLPixelFormatGetInfoForDevice();
              if ((WORD4(buf) & 0x400) != 0)
              {
                uint64_t v62 = *re::pipelineLogObjects(InfoForDevice);
                if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(buf) = 136315138;
                  *(void *)((char *)&buf + 4) = v90;
                  _os_log_impl(&dword_233120000, v62, OS_LOG_TYPE_DEFAULT, "Applying gamut conversion for '%s' will decompress the texture, increasing memory usage.", (uint8_t *)&buf, 0xCu);
                }
              }
              if (*(unsigned char *)(a1 + 19)) {
                unsigned __int8 v63 = *(unsigned char *)(a1 + 20);
              }
              else {
                unsigned __int8 v63 = 0;
              }
              re::convertTextureColorSpace(v63, (uint64_t)&v96, (uint64_t)&buf);
              if (v109)
              {
                if (v109 != 1) {
                  goto LABEL_152;
                }
                if (!(void)v107) {
                  goto LABEL_97;
                }
              }
              if (*((void *)&buf + 1))
              {
                re::TextureData::operator=((uint64_t)&v96, (uint64_t)&buf);
              }
              else
              {
LABEL_97:
                int v65 = *re::pipelineLogObjects(v64);
                if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                {
                  LODWORD(v112) = 136315138;
                  *(void *)((char *)&v112 + 4) = v90;
                  _os_log_error_impl(&dword_233120000, v65, OS_LOG_TYPE_ERROR, "Failed to convert KTX texture colorspace for '%s'", (uint8_t *)&v112, 0xCu);
                }
              }
              re::TextureData::~TextureData((id *)&buf);
            }
          }
        }
        goto LABEL_100;
      }
LABEL_61:
      re::ObjCObject::operator=((void **)v104, 0);
      char v49 = 1;
      goto LABEL_63;
    }
    char v39 = isSupportedPixelFormat ^ 1;
LABEL_57:
    char isASTCPixelFormat = re::isASTCPixelFormat(v89);
    *(void *)uint64_t v104 = 0;
    if ((isASTCPixelFormat & 1) == 0 && (v39 & 1) == 0) {
      goto LABEL_59;
    }
    goto LABEL_61;
  }
  uint64_t v108 = 0;
  long long v106 = 0u;
  long long v107 = 0u;
  long long buf = 0u;
  int v89 = v19;
  unsigned int v28 = (re *)MTLPixelFormatGetInfoForDevice();
  if ((WORD4(buf) & 0x400) != 0)
  {
    unsigned __int8 v29 = *re::pipelineLogObjects(v28);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v90;
      _os_log_impl(&dword_233120000, v29, OS_LOG_TYPE_DEFAULT, "Using ImageIO to import KTX '%s' will decompress the texture, increasing memory usage.", (uint8_t *)&buf, 0xCu);
    }
  }
  objc_msgSend(v102, sel_pixelFormat);
  uint64_t v108 = 0;
  long long v106 = 0u;
  long long v107 = 0u;
  long long buf = 0u;
  MTLPixelFormatGetInfoForDevice();
  if ((WORD4(buf) & 0x800) != 0) {
    *(_DWORD *)(a6 + 48) = 2;
  }
  id v30 = v102;
  id v95 = v30;
  long long v32 = v31;
  if (v30)
  {

    id v95 = 0;
  }
  if (!v32)
  {
    uint64_t v44 = *re::pipelineLogObjects(v31);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v90;
      _os_log_error_impl(&dword_233120000, v44, OS_LOG_TYPE_ERROR, "Failed to create image source from KTX: %s", (uint8_t *)&buf, 0xCu);
    }
LABEL_50:
    *(unsigned char *)a9 &= 0x80u;
    *(void *)(a9 + 8) = 0;
    *(_DWORD *)(a9 + 88) = 0;
    *(void *)(a9 + 96) = 0;
    goto LABEL_147;
  }
  re::loadMetalTextureWithReleasedCGImageSource((re::internal *)a6, v32, (id *)a1, &v102, v90, a7, a10, (uint64_t)&buf);
  LOBYTE(v96) = buf;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)v97, (uint64_t)&buf + 8);
  id v33 = v110;
  id v110 = 0;
  id v34 = v100;
  id v100 = v33;

  if (v109 != -1) {
    char v35 = (re *)((uint64_t (*)(long long *, char *))*(&__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2NS9SharedPtrIN3MTL7TextureEEEN2re10CPUTextureEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSF_EEEDcOSG_DpOT0____fmatrix_1
  }
                                                             + v109))(&v112, (char *)&buf + 8);
  if (v99)
  {
    uint64_t v36 = v90;
    if (v99 != 1) {
      goto LABEL_152;
    }
    if (!v98 || !v97[0]) {
      goto LABEL_39;
    }
  }
  else
  {
    uint64_t v36 = v90;
    if (!v97[0])
    {
LABEL_39:
      long long v37 = *re::pipelineLogObjects(v35);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v36;
        _os_log_fault_impl(&dword_233120000, v37, OS_LOG_TYPE_FAULT, "Failed to create texture '%s' from KTX", (uint8_t *)&buf, 0xCu);
      }
      *(unsigned char *)a9 &= 0x80u;
      *(void *)(a9 + 8) = 0;
      *(_DWORD *)(a9 + 88) = 0;
      *(void *)(a9 + 96) = 0;
      goto LABEL_147;
    }
  }
  LOBYTE(v96) = v96 & 0xDF | (32 * v118);
LABEL_100:
  if (v99)
  {
    if (v99 != 1) {
      goto LABEL_152;
    }
    if (!v98) {
      goto LABEL_128;
    }
  }
  if (v97[0] && (*(_DWORD *)(a6 + 56) - 3) <= 1 && !v100)
  {
    int v66 = objc_msgSend(v102, sel_pixelFormat);
    if (*(unsigned char *)(a1 + 19)) {
      unsigned __int8 v67 = *(unsigned char *)(a1 + 20);
    }
    else {
      unsigned __int8 v67 = 0;
    }
    CGColorSpaceNameForPixelFormat = (__CFString *)re::ColorHelpers::getCGColorSpaceNameForPixelFormat(v66, v67);
    re::TextureData::setColorSpace(&v96, CGColorSpaceNameForPixelFormat);
  }
  if (v99)
  {
    if (v99 != 1) {
      goto LABEL_152;
    }
    if (!v98) {
      goto LABEL_128;
    }
  }
  if (!v97[0] || !*(void *)a1) {
    goto LABEL_128;
  }
  char v69 = [*(id *)a1 supportsTextureSwizzle];
  unint64_t v70 = v103;
  if (v103 == 84148994) {
    char v71 = 1;
  }
  else {
    char v71 = v69;
  }
  if (v89 && !re::MTLToASTCPixelFormat((int)objc_msgSend(v102, sel_pixelFormat)))
  {
    objc_msgSend(v102, sel_pixelFormat);
    uint64_t v108 = 0;
    long long v106 = 0u;
    long long v107 = 0u;
    long long buf = 0u;
    long long v72 = (re *)MTLPixelFormatGetInfoForDevice();
    if ((WORD4(buf) & 0x400) != 0)
    {
      long long v73 = *re::pipelineLogObjects(v72);
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        id v74 = v102;
        uint64_t v75 = v73;
        uint64_t v36 = v90;
        unsigned int v76 = objc_msgSend(v74, sel_pixelFormat);
        LODWORD(buf) = 67109120;
        DWORD1(buf) = v76;
        _os_log_impl(&dword_233120000, v75, OS_LOG_TYPE_DEFAULT, "Source compressed pixel format '%d' does not match compression options: will decompress and recompress", (uint8_t *)&buf, 8u);
      }
    }
    goto LABEL_125;
  }
  if ((v71 & 1) == 0)
  {
LABEL_125:
    if (v99) {
      goto LABEL_152;
    }
    re::internal::createRepackedTexture((id *)a1, v97, v70, &v112);
    LOBYTE(buf) = 0;
    *((void *)&buf + 1) = (id)v112;
    unsigned int v109 = 0;
    id v110 = 0;
    re::TextureData::operator=((uint64_t)&v96, (uint64_t)&buf);
    re::TextureData::~TextureData((id *)&buf);
    if ((void)v112) {
  }
    }
LABEL_128:
  objc_msgSend(v102, sel_pixelFormat);
  uint64_t v108 = 0;
  long long v106 = 0u;
  long long v107 = 0u;
  long long buf = 0u;
  MTLPixelFormatGetInfoForDevice();
  if ((WORD4(buf) & 0x400) != 0)
  {
    if (v99 >= 2) {
      goto LABEL_152;
    }
    objc_msgSend(v97[0], sel_pixelFormat);
    uint64_t v108 = 0;
    long long v106 = 0u;
    long long v107 = 0u;
    long long buf = 0u;
    MTLPixelFormatGetInfoForDevice();
    if ((WORD4(buf) & 0x400) == 0) {
      LOBYTE(v96) = v96 | 4;
    }
  }
  if (!v89)
  {
LABEL_146:
    *(unsigned char *)a9 = (_BYTE)v96;
    *(unsigned char *)(a9 + 8) = 0;
    *(_DWORD *)(a9 + 88) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(a9 + 8, (uint64_t)v97);
    id v82 = v100;
    id v100 = 0;
    *(void *)(a9 + 96) = v82;
LABEL_147:

    if (v99 != -1) {
      ((void (*)(long long *, id *))*(&__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2NS9SharedPtrIN3MTL7TextureEEEN2re10CPUTextureEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSF_EEEDcOSG_DpOT0____fmatrix_1
    }
                                              + v99))(&buf, v97);
    goto LABEL_149;
  }
  if (v99 < 2)
  {
    int v77 = (re *)re::MTLToASTCPixelFormat((int)objc_msgSend(v97[0], sel_pixelFormat));
    if (v77)
    {
      long long v112 = *(_OWORD *)(a6 + 28);
      if (*(_DWORD *)(a6 + 24) == 3) {
        LODWORD(v112) = 1;
      }
      re::logTextureCompressionInfo((re *)"createTextureWithKTXData", (uint64_t)&v96, (int *)&v112);
      re::createCompressedTextureData((uint64_t)&v96, *(_DWORD *)(a6 + 56), &v112, (id *)a1, 0, 0, (uint64_t)&buf);
      if ((_BYTE)buf)
      {
        LOBYTE(v96) = BYTE8(buf);
        std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>((uint64_t)v97, (uint64_t)&v106);
        re::ObjCObject::operator=(&v100, &v111);
      }
      else
      {
        char v81 = *re::pipelineLogObjects(v78);
        if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v104 = 136315138;
          *(void *)&v104[4] = v36;
          _os_log_error_impl(&dword_233120000, v81, OS_LOG_TYPE_ERROR, "ASTC compression failed for '%s'", v104, 0xCu);
        }
      }
      re::Result<re::TextureData,re::DynamicString>::~Result((uint64_t)&buf);
      goto LABEL_146;
    }
    uint64_t v79 = (id)*re::pipelineLogObjects(v77);
    if (!os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_142;
    }
    if (v99 < 2)
    {
      unsigned int v80 = objc_msgSend(v97[0], sel_pixelFormat);
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v80;
      _os_log_impl(&dword_233120000, v79, OS_LOG_TYPE_DEFAULT, "Ignoring ASTC compression options: not supported for source pixel format '%d'", (uint8_t *)&buf, 8u);
LABEL_142:

      goto LABEL_146;
    }
  }
LABEL_152:
  uint64_t v83 = std::__throw_bad_variant_access[abi:nn180100]();
}

void re::anonymous namespace'::parseKTX(uint64_t ASTCHDRFormatForPixelFormat, id *a2, __n128 *a3, unint64_t a4, int a5)
{
  uint64_t v5 = ASTCHDRFormatForPixelFormat;
  uint64_t v108 = *MEMORY[0x263EF8340];
  if (a4 <= 0x3F)
  {
    __n128 v6 = v96;
    uint64_t v8 = v97.n128_i64[1];
    unint64_t v7 = v97.n128_u64[0];
LABEL_15:
    *(unsigned char *)uint64_t v5 = 0;
    *(__n128 *)(v5 + 8) = v6;
    *(void *)(v5 + 24) = v7;
    *(void *)(v5 + 32) = v8;
    return;
  }
  __n128 v9 = a3[1];
  __n128 v96 = *a3;
  __n128 v97 = v9;
  __n128 v10 = a3[2];
  __n128 v11 = a3[3];
  __n128 v98 = v10;
  __n128 v99 = v11;
  if (v96.n128_u64[0] != 0xBB31312058544BABLL || v96.n128_u32[2] != 169478669)
  {
    unsigned int v13 = "Tried to load a non-KTX file as KTX (header identifier mismatch)";
LABEL_13:
    goto LABEL_14;
  }
  if (v96.n128_u32[3] != 67305985)
  {
    unsigned int v13 = "Tried to load a KTX file with unsupported endianness";
    goto LABEL_13;
  }
  unint64_t v16 = a4 - 64;
  uint64_t v17 = v99.n128_u32[3];
  if (v99.n128_u32[3])
  {
    BOOL v22 = v16 >= v99.n128_u32[3];
    v16 -= v99.n128_u32[3];
    if (!v22)
    {
      re::DynamicString::format((re::DynamicString *)"KTX data is not large enough to contain %u bytes of key-value data", (re::DynamicString *)v106, v99.n128_u32[3]);
LABEL_14:
      __n128 v6 = *(__n128 *)v106;
      uint64_t v8 = *((void *)&v107 + 1);
      unint64_t v7 = v107;
      goto LABEL_15;
    }
    uint64_t v87 = (uint64_t)&a3[4] + v99.n128_u32[3];
    *(void *)long long v106 = &unk_26E7150B0;
    *(void *)&v106[8] = a3 + 4;
    id v93 = a3 + 4;
    *(void *)&long long v107 = v99.n128_u32[3];
    if (v99.n128_u32[3] >= 5)
    {
      uint64_t v21 = 0;
      int v18 = 0;
      BOOL v88 = 0;
      size_t v90 = 0;
      id v91 = 0;
      size_t v19 = 0;
      __s1 = 0;
      v10.n128_u64[0] = 134218498;
      while (1)
      {
        if (*(void *)&v106[8]) {
          BOOL v22 = (unint64_t)(v17 - v21) >= 4;
        }
        else {
          BOOL v22 = 0;
        }
        if (!v22) {
          goto LABEL_56;
        }
        uint64_t v23 = v21 + 4;
        *((void *)&v107 + 1) = v21 + 4;
        size_t v24 = *(unsigned int *)(*(void *)&v106[8] + v21);
        size_t v25 = v17 - (v21 + 4);
        if (v25 < v24)
        {
          int v66 = *re::pipelineLogObjects((re *)ASTCHDRFormatForPixelFormat);
          ASTCHDRFormatForPixelFormat = os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT);
          if (ASTCHDRFormatForPixelFormat)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_233120000, v66, OS_LOG_TYPE_DEFAULT, "Failed to parse KTX metadata: Key value pair overflowed available data", buf, 2u);
          }
          goto LABEL_56;
        }
        if (v24)
        {
          unint64_t v26 = (v24 + 3) & 0x1FFFFFFFCLL;
          if (v25 >= v26)
          {
            unsigned __int8 v27 = (const char *)(*(void *)&v106[8] + v23);
            *((void *)&v107 + 1) = v26 + v23;
          }
          else
          {
            unsigned __int8 v27 = 0;
          }
          unsigned int v28 = (re *)strnlen(v27, v24);
          if (v28 == (re *)v24)
          {
            unsigned __int8 v29 = *re::pipelineLogObjects(v28);
            ASTCHDRFormatForPixelFormat = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
            if (ASTCHDRFormatForPixelFormat)
            {
              *(_DWORD *)long long buf = 136315138;
              int v101 = v27;
              id v30 = v29;
              BOOL v31 = "Failed to parse KTX metadata: Missing value for key %s";
              uint32_t v32 = 12;
              goto LABEL_45;
            }
          }
          else
          {
            size_t v33 = (size_t)v28 + 1;
            size_t v34 = v24 - ((void)v28 + 1);
            ASTCHDRFormatForPixelFormat = strncmp("KTXmetalPixelFormat", v27, (size_t)v28 + 1);
            if (ASTCHDRFormatForPixelFormat)
            {
              ASTCHDRFormatForPixelFormat = strncmp("MTLPixelFormat", v27, v33);
              if (ASTCHDRFormatForPixelFormat)
              {
                ASTCHDRFormatForPixelFormat = strncmp("com.apple.image.premultipliedAlpha", v27, v33);
                if (ASTCHDRFormatForPixelFormat)
                {
                  ASTCHDRFormatForPixelFormat = strncmp("com.apple.image.colorGamut", v27, v33);
                  if (ASTCHDRFormatForPixelFormat)
                  {
                    ASTCHDRFormatForPixelFormat = strncmp("com.apple.image.colorTransfer", v27, v33);
                    if (!ASTCHDRFormatForPixelFormat)
                    {
                      size_t v35 = v34 - 1;
                      __s1 = (char *)&v27[v33];
                      if (v27[v33 - 1 + v34]) {
                        size_t v35 = v34;
                      }
                      size_t v90 = v35;
                    }
                  }
                  else
                  {
                    id v91 = &v27[v33];
                    if (v27[v33 - 1 + v34]) {
                      size_t v19 = v34;
                    }
                    else {
                      size_t v19 = v34 - 1;
                    }
                  }
                  goto LABEL_46;
                }
                if (v34 == 4)
                {
                  BOOL v88 = *(_DWORD *)&v27[v33] != 0;
                  goto LABEL_46;
                }
                uint64_t v36 = *re::pipelineLogObjects((re *)ASTCHDRFormatForPixelFormat);
                ASTCHDRFormatForPixelFormat = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
                if (!ASTCHDRFormatForPixelFormat) {
                  goto LABEL_46;
                }
LABEL_44:
                *(_DWORD *)long long buf = 134218498;
                int v101 = (const char *)v34;
                __int16 v102 = 2048;
                uint64_t v103 = 4;
                __int16 v104 = 2080;
                uint64_t v105 = v27;
                id v30 = v36;
                BOOL v31 = "Unexpected size (%lu != %lu) for key %s";
                uint32_t v32 = 32;
LABEL_45:
                _os_log_impl(&dword_233120000, v30, OS_LOG_TYPE_DEFAULT, v31, buf, v32);
                goto LABEL_46;
              }
            }
            if (v34 == 4)
            {
              int v18 = *(_DWORD *)&v27[v33];
            }
            else
            {
              uint64_t v36 = *re::pipelineLogObjects((re *)ASTCHDRFormatForPixelFormat);
              ASTCHDRFormatForPixelFormat = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
              if (ASTCHDRFormatForPixelFormat) {
                goto LABEL_44;
              }
            }
          }
        }
LABEL_46:
        uint64_t v21 = *((void *)&v107 + 1);
        uint64_t v17 = v107;
        if ((void)v107 - *((void *)&v107 + 1) <= 4uLL) {
          goto LABEL_56;
        }
      }
    }
    int v18 = 0;
    BOOL v88 = 0;
    size_t v90 = 0;
    id v91 = 0;
    size_t v19 = 0;
    __s1 = 0;
LABEL_56:
    uint64_t v20 = v93;
  }
  else
  {
    int v18 = 0;
    BOOL v88 = 0;
    size_t v90 = 0;
    id v91 = 0;
    size_t v19 = 0;
    __s1 = 0;
    uint64_t v87 = (uint64_t)&a3[4];
    uint64_t v20 = 0;
  }
  uint64_t v92 = v98.n128_u32[1];
  if (v98.n128_u32[1]) {
    BOOL v37 = v98.n128_u32[2] == 0;
  }
  else {
    BOOL v37 = 1;
  }
  int v38 = !v37;
  BOOL v39 = v38 != 1 || v98.n128_u32[3] == 0;
  unint64_t v94 = v20;
  if (v39)
  {
    if (v99.n128_u32[0]) {
      char v40 = v38;
    }
    else {
      char v40 = 0;
    }
    if (v40)
    {
      unsigned int v86 = 3;
      int v41 = 1;
    }
    else
    {
      if ((v38 & (v99.n128_u32[1] == 6)) != 0) {
        int v42 = 5;
      }
      else {
        int v42 = 2;
      }
      if (v38) {
        unsigned int v43 = v42;
      }
      else {
        unsigned int v43 = 0;
      }
      unsigned int v86 = v43;
      if (!v98.n128_u32[1])
      {
        re::DynamicString::format((re::DynamicString *)"Bad dimensions in KTX: (%u, %u, %u)", (re::DynamicString *)v106, 0, v98.n128_u32[2], v98.n128_u32[3]);
        goto LABEL_14;
      }
      int v41 = 0;
    }
  }
  else
  {
    int v41 = 0;
    unsigned int v86 = 7;
  }
  *(_DWORD *)long long buf = v18;
  unint64_t v44 = 0xFFFFFFFFFFFFDF10;
  uint64_t v89 = v98.n128_u32[3];
  int v83 = v41;
  while (1)
  {
    {
        break;
    }
    v44 += 68;
    if (!v44)
    {
      uint64_t v46 = 0;
      BOOL v84 = 1;
      goto LABEL_87;
    }
  }
  unint64_t v82 = v16;
  uint64_t v46 = *((unsigned int *)v45 + 2108);
  unsigned __int32 v52 = v98.n128_u32[0];
  BOOL v84 = v98.n128_u32[0] == 6408;
  int v53 = *((_DWORD *)v45 + 2114);
  if (v97.n128_u32[1] != v53)
  {
    log = *re::pipelineLogObjects((re *)ASTCHDRFormatForPixelFormat);
    ASTCHDRFormatForPixelFormat = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
    unsigned __int32 v52 = v98.n128_u32[0];
    if (ASTCHDRFormatForPixelFormat)
    {
      *(_DWORD *)long long v106 = 67110144;
      *(_DWORD *)&v106[4] = v97.n128_u32[0];
      *(_WORD *)&v106[8] = 1024;
      *(_DWORD *)&v106[10] = v97.n128_u32[2];
      *(_WORD *)&v106[14] = 1024;
      LODWORD(v107) = v97.n128_u32[3];
      WORD2(v107) = 1024;
      *(_DWORD *)((char *)&v107 + 6) = v53;
      WORD5(v107) = 1024;
      HIDWORD(v107) = v97.n128_u32[1];
      _os_log_impl(&dword_233120000, log, OS_LOG_TYPE_DEFAULT, "KTX with type 0x%x, format 0x%x, internal format 0x%x has unexpected type size (expected: %u, actual: %u)", v106, 0x20u);
      unsigned __int32 v52 = v98.n128_u32[0];
    }
  }
  if (v88)
  {
    unint64_t v16 = v82;
    if (v52 != 6408)
    {
      id v54 = *re::pipelineLogObjects((re *)ASTCHDRFormatForPixelFormat);
      ASTCHDRFormatForPixelFormat = os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT);
      if (ASTCHDRFormatForPixelFormat)
      {
        *(_WORD *)long long v106 = 0;
        _os_log_impl(&dword_233120000, v54, OS_LOG_TYPE_DEFAULT, "Metadata mismatch: Pre-multiplied alpha specified when format has no alpha channel", v106, 2u);
      }
      BOOL v88 = 0;
      BOOL v84 = 0;
    }
  }
  else
  {
    unint64_t v16 = v82;
  }
LABEL_87:
  int v47 = *(_DWORD *)buf;
  if (*(_DWORD *)buf)
  {
    if (*(_DWORD *)buf == v46)
    {
      char v48 = 0;
LABEL_94:
      size_t v49 = v90;
      uint64_t v50 = v91;
LABEL_95:
      uint64_t v51 = v98.n128_u32[2];
      goto LABEL_114;
    }
    if ((v46 - 204) <= 0xE && v46 != 209)
    {
      if (v47 == ASTCHDRFormatForPixelFormat)
      {
        char v48 = 0;
        LODWORD(v46) = v47;
        goto LABEL_94;
      }
    }
    uint64_t v55 = *re::pipelineLogObjects((re *)ASTCHDRFormatForPixelFormat);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long v106 = 67109376;
      *(_DWORD *)&v106[4] = *(_DWORD *)buf;
      *(_WORD *)&v106[8] = 1024;
      *(_DWORD *)&v106[10] = v46;
      _os_log_impl(&dword_233120000, v55, OS_LOG_TYPE_DEFAULT, "Metadata mismatch: Pixel format mismatch metadata (%u) != inferred (%u), using inferred format", v106, 0xEu);
    }
  }
  *(_DWORD *)long long buf = v46;
  if ((v46 - 204) > 0xE || v46 == 209)
  {
    uint64_t v50 = v91;
    if (!v46)
    {
      re::DynamicString::format((re::DynamicString *)"Unsupported KTX pixel format: type 0x%x, type size %u, format 0x%x, internal format 0x%x", (re::DynamicString *)v106, v97.n128_u32[0], v97.n128_u32[1], v97.n128_u32[2], v97.n128_u32[3]);
      goto LABEL_14;
    }
    char v48 = 0;
    size_t v49 = v90;
    goto LABEL_95;
  }
  size_t v49 = v90;
  uint64_t v51 = v98.n128_u32[2];
  if (a5)
  {
    if (a5 == 1)
    {
      char v48 = 0;
      *(_DWORD *)long long buf = v46;
    }
    else
    {
      char v48 = 0;
    }
  }
  else
  {
    char v95 = 0;
    *(_DWORD *)long long v106 = v86;
    *(void *)&v106[8] = &v95;
    *(void *)&long long v107 = buf;
    char v48 = 1;
    LODWORD(v46) = *(_DWORD *)buf;
  }
  uint64_t v50 = v91;
LABEL_114:
  int isHDR = re::isHDR(v46);
  {
    if (!v49)
    {
      char v57 = (_anonymous_namespace_ *)strncmp(v50, "BT709", v19);
      uint64_t v58 = v89;
      {
        __int16 v64 = (uint64_t *)MEMORY[0x263F00230];
        if (!isHDR) {
          __int16 v64 = (uint64_t *)MEMORY[0x263F002D8];
        }
      }
      else
      {
        __int16 v64 = (uint64_t *)MEMORY[0x263F00298];
      }
      uint64_t v59 = *v64;
      goto LABEL_183;
    }
    char v57 = (_anonymous_namespace_ *)strncmp(__s1, "linear", v49);
    {
      unint64_t v70 = (uint64_t *)MEMORY[0x263F00230];
      if (!isHDR) {
        unint64_t v70 = (uint64_t *)MEMORY[0x263F002C8];
      }
      uint64_t v59 = *v70;
      goto LABEL_176;
    }
    char v57 = (_anonymous_namespace_ *)strncmp(__s1, "sRGB", v49);
    uint64_t v60 = v92;
    {
      char v57 = (_anonymous_namespace_ *)strncmp(__s1, "ITU", v49);
      if (v57)
      {
        uint64_t v59 = 0;
      }
      {
        uint64_t v59 = 0;
      }
      else
      {
        uint64_t v59 = *MEMORY[0x263F00298];
      }
      goto LABEL_207;
    }
    __int16 v68 = (uint64_t *)MEMORY[0x263F00238];
    char v69 = (uint64_t *)MEMORY[0x263F002D8];
    goto LABEL_204;
  }
  char v57 = (_anonymous_namespace_ *)strncmp(v50, "DisplayP3", v19);
  {
    uint64_t v60 = v92;
    if (v49)
    {
      char v57 = (_anonymous_namespace_ *)strncmp(__s1, "linear", v49);
      {
        __int16 v68 = (uint64_t *)MEMORY[0x263F00218];
        char v69 = (uint64_t *)MEMORY[0x263F002B0];
        goto LABEL_204;
      }
      char v57 = (_anonymous_namespace_ *)strncmp(__s1, "sRGB", v49);
      {
        char v57 = (_anonymous_namespace_ *)strncmp(__s1, "PQ", v49);
        {
          char v57 = (_anonymous_namespace_ *)strncmp(__s1, "HLG", v49);
          uint64_t v58 = v89;
          if (!v57)
          {
            uint64_t v62 = (uint64_t *)MEMORY[0x263F001F0];
LABEL_159:
            uint64_t v63 = *v62;
            if (v61) {
              uint64_t v59 = 0;
            }
            else {
              uint64_t v59 = v63;
            }
            goto LABEL_208;
          }
LABEL_190:
          uint64_t v59 = 0;
          goto LABEL_208;
        }
        __int16 v68 = (uint64_t *)MEMORY[0x263F001F8];
        goto LABEL_206;
      }
      __int16 v68 = (uint64_t *)MEMORY[0x263F00200];
    }
    else
    {
      __int16 v68 = (uint64_t *)MEMORY[0x263F00218];
    }
    char v69 = (uint64_t *)MEMORY[0x263F001E8];
    goto LABEL_204;
  }
  char v57 = (_anonymous_namespace_ *)strncmp(v50, "DCIP3", v19);
  {
    int v65 = (uint64_t *)MEMORY[0x263F001E0];
    goto LABEL_173;
  }
  char v57 = (_anonymous_namespace_ *)strncmp(v50, "BT2020", v19);
    || (char v57 = (_anonymous_namespace_ *)strncmp(v50, "BT2100", v19), !v57)
  {
    uint64_t v60 = v92;
    if (v49)
    {
      char v57 = (_anonymous_namespace_ *)strncmp(__s1, "ITU", v49);
      {
        char v57 = (_anonymous_namespace_ *)strncmp(__s1, "linear", v49);
        {
          char v57 = (_anonymous_namespace_ *)strncmp(__s1, "PQ", v49);
          {
            char v57 = (_anonymous_namespace_ *)strncmp(__s1, "HLG", v49);
            uint64_t v58 = v89;
            if (!v57)
            {
              uint64_t v62 = (uint64_t *)MEMORY[0x263F00288];
              goto LABEL_159;
            }
            goto LABEL_190;
          }
          __int16 v68 = (uint64_t *)MEMORY[0x263F00290];
          goto LABEL_206;
        }
        __int16 v68 = (uint64_t *)MEMORY[0x263F00228];
        char v69 = (uint64_t *)MEMORY[0x263F002C0];
LABEL_204:
        if (!isHDR) {
          __int16 v68 = v69;
        }
LABEL_206:
        uint64_t v59 = *v68;
LABEL_207:
        uint64_t v58 = v89;
        goto LABEL_208;
      }
      __int16 v68 = (uint64_t *)MEMORY[0x263F00210];
    }
    else
    {
      __int16 v68 = (uint64_t *)MEMORY[0x263F00228];
    }
    char v69 = (uint64_t *)MEMORY[0x263F00278];
    goto LABEL_204;
  }
  char v57 = (_anonymous_namespace_ *)strncmp(v50, "Adobe-RGB-1998", v19);
  {
    int v65 = (uint64_t *)MEMORY[0x263F001D8];
LABEL_173:
    uint64_t v67 = *v65;
    if (v49) {
      uint64_t v59 = 0;
    }
    else {
      uint64_t v59 = v67;
    }
LABEL_176:
    uint64_t v58 = v89;
    goto LABEL_183;
  }
  char v57 = (_anonymous_namespace_ *)strncmp(v50, "CIE-1931-XYZ", v19);
  uint64_t v58 = v89;
  {
    if (v49) {
      uint64_t v59 = 0;
    }
    else {
      uint64_t v59 = *MEMORY[0x263F00270];
    }
    goto LABEL_183;
  }
  char v57 = (_anonymous_namespace_ *)strncmp(v50, "ACEScg", v19);
  {
    uint64_t v59 = 0;
LABEL_183:
    uint64_t v60 = v92;
    goto LABEL_208;
  }
  uint64_t v60 = v92;
  if (v49)
  {
    char v57 = (_anonymous_namespace_ *)strncmp(__s1, "linear", v49);
      goto LABEL_190;
  }
  uint64_t v59 = *MEMORY[0x263F001D0];
LABEL_208:
  uint64_t v71 = v99.n128_u32[2];
  if (!v99.n128_u32[2])
  {
    unsigned int v13 = "Unsupported number of mipmaps (0) in KTX";
    goto LABEL_13;
  }
  if (v60 <= v51) {
    unsigned int v72 = v51;
  }
  else {
    unsigned int v72 = v60;
  }
  if (v72 <= v58) {
    unsigned int v72 = v58;
  }
  double v73 = log2((double)v72);
  if (v71 > v73 + 1)
  {
    re::DynamicString::format((re::DynamicString *)"Bad MipmapLevelCount (%u) in KTX header - dimensions (%u, %u, %u) can only support a max of %u levels", (re::DynamicString *)v106, v71, v60, v51, v58, v73 + 1);
    goto LABEL_14;
  }
  id v74 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  objc_msgSend(v74, sel_setTextureType_, v86);
  if (v60 <= 1) {
    uint64_t v75 = 1;
  }
  else {
    uint64_t v75 = v60;
  }
  objc_msgSend(v74, sel_setWidth_, v75);
  if (v51 <= 1) {
    uint64_t v76 = 1;
  }
  else {
    uint64_t v76 = v51;
  }
  objc_msgSend(v74, sel_setHeight_, v76);
  if (v58 <= 1) {
    uint64_t v77 = 1;
  }
  else {
    uint64_t v77 = v58;
  }
  objc_msgSend(v74, sel_setDepth_, v77);
  if (v83) {
    objc_msgSend(v74, sel_setArrayLength_, v99.n128_u32[0]);
  }
  objc_msgSend(v74, sel_setMipmapLevelCount_, v71);
  objc_msgSend(v74, sel_setPixelFormat_, *(int *)buf);
  objc_msgSend(v74, sel_setResourceOptions_, 32);
  id v78 = v74;
  __n128 v79 = v97;
  *(__n128 *)(v5 + 8) = v96;
  *(__n128 *)(v5 + 24) = v79;
  __n128 v80 = v99;
  *(__n128 *)(v5 + 40) = v98;
  *(unsigned char *)uint64_t v5 = 1;
  *(__n128 *)(v5 + 56) = v80;
  *(void *)(v5 + 72) = v78;
  *(void *)(v5 + 80) = v94;
  *(void *)(v5 + 88) = v87;
  *(void *)(v5 + 96) = v16;
  *(unsigned char *)(v5 + 104) = v84;
  *(unsigned char *)(v5 + 105) = v88;
  *(unsigned char *)(v5 + 106) = v48;
  *(void *)(v5 + 112) = v59;
  if (v74) {
}
  }

uint64_t re::anonymous namespace'::updateTextureDescriptorAndOptions(re *a1, __CFString *a2, id *a3, unsigned __int8 *a4, uint8_t *this, unsigned int *a6)
{
  *a6 = 0;
  if (*(_DWORD *)this == 1)
  {
    id v12 = *re::pipelineLogObjects(a1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Ignoring explicit pixel format option for KTX", buf, 2u);
    }
    *(_DWORD *)this = 0;
  }
  re::internal::applySemanticToOptions((re::internal *)this, (uint64_t)buf);
  long long v13 = v36;
  *(_OWORD *)this = *(_OWORD *)buf;
  *((_OWORD *)this + 1) = v13;
  *((_OWORD *)this + 2) = *(_OWORD *)v37;
  *(_OWORD *)(this + 44) = *(_OWORD *)&v37[12];
  if (buf != this)
  {
    id v14 = v38;
    id v38 = 0;
    uint64_t v15 = (void *)*((void *)this + 8);
    *((void *)this + 8) = v14;
  }
  *(_OWORD *)(this + 72) = v39;

  id v17 = *((id *)this + 8);
  if (a2 && !*((void *)this + 8)) {
    re::TextureFromImageOptions::setColorSpace((re::TextureFromImageOptions *)this, a2);
  }
  if (*((_DWORD *)this + 19)) {
    objc_msgSend(*a3, sel_setHeight_);
  }
  if (*((_DWORD *)this + 18)) {
    objc_msgSend(*a3, sel_setWidth_);
  }
  if (*((_DWORD *)this + 20)) {
    objc_msgSend(*a3, sel_setDepth_);
  }
  if (*((_DWORD *)this + 21)) {
    objc_msgSend(*a3, sel_setMipmapLevelCount_);
  }
  int v18 = *((_DWORD *)this + 1);
  if (v18 != 1)
  {
    if (v18 == 2)
    {
      objc_msgSend(*a3, sel_pixelFormat);
      if (re::getComponentCount() == 1) {
        *(_DWORD *)a4 = re::internal::broadcastRToRGB(a4);
      }
      else {
        *(_DWORD *)a4 = 84148994;
      }
      goto LABEL_29;
    }
    if (v18 != 3) {
      goto LABEL_29;
    }
    re::internal::assertLog((re::internal *)4, v16, "assertion failure: '%s' (%s:line %i) Semantics should have been applied at this point", "!\"Unreachable code\"", "updateTextureDescriptorAndOptions", 901);
    _os_crash();
    __break(1u);
  }
  objc_msgSend(*a3, sel_pixelFormat);
  ComponentCount = (re *)re::getComponentCount();
  if (ComponentCount != (re *)1)
  {
    uint64_t v20 = *re::pipelineLogObjects(ComponentCount);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_233120000, v20, OS_LOG_TYPE_ERROR, "TextureChannelsMode::kSingleChannel is not supported for ktx images with multiple channels", buf, 2u);
    }
    uint64_t v21 = 0;
    goto LABEL_65;
  }
LABEL_29:
  int isHDR = (CGColorSpace *)re::isHDR((int)objc_msgSend(*a3, sel_pixelFormat));
  int DestinationTransferFunctionFromOptions = re::internal::getDestinationTransferFunctionFromOptions((re::internal *)this, 0, isHDR);
  if (!DestinationTransferFunctionFromOptions)
  {
    if (dyld_program_sdk_at_least())
    {
      objc_msgSend(*a3, sel_pixelFormat);
      long long v36 = 0u;
      memset(v37, 0, 24);
      *(_OWORD *)long long buf = 0u;
      MTLPixelFormatGetInfoForDevice();
      if ((*(_WORD *)&buf[8] & 0x800) != 0) {
        int DestinationTransferFunctionFromOptions = 2;
      }
      else {
        int DestinationTransferFunctionFromOptions = 1;
      }
    }
    else if ((*((_DWORD *)this + 14) - 3) >= 2)
    {
      int DestinationTransferFunctionFromOptions = 1;
    }
    else
    {
      int DestinationTransferFunctionFromOptions = 2;
    }
  }
  CFStringRef v24 = (const __CFString *)*((id *)this + 8);
  if (v24)
  {
    CFStringRef v26 = v24;
    if ((DestinationTransferFunctionFromOptions == 2) != re::colorSpaceNameHasSRGBTransfer(v24, v25))
    {
      unsigned int v28 = (__CFString *)(DestinationTransferFunctionFromOptions == 2
                         ? re::getLinearColorSpaceNameFromSRGB(v26, v27)
                         : re::getSRGBColorSpaceNameFromLinear(v26, v27));
      if (v28) {
        re::TextureFromImageOptions::setColorSpace((re::TextureFromImageOptions *)this, v28);
      }
    }
  }
  objc_msgSend(*a3, sel_pixelFormat);
  long long v36 = 0u;
  memset(v37, 0, 24);
  *(_OWORD *)long long buf = 0u;
  MTLPixelFormatGetInfoForDevice();
  if ((*(_WORD *)&buf[8] & 0x800) == 0 || DestinationTransferFunctionFromOptions == 2)
  {
    if ((*(_WORD *)&buf[8] & 0x800) != 0 || DestinationTransferFunctionFromOptions != 2) {
      goto LABEL_53;
    }
    int v29 = re::translateLinearPixelFormatToSRGB((uint64_t)objc_msgSend(*a3, sel_pixelFormat));
  }
  else
  {
    int v29 = re::translateSRGBPixelFormatToLinear((uint64_t)objc_msgSend(*a3, sel_pixelFormat));
  }
  int v30 = v29;
  if (v29 != objc_msgSend(*a3, sel_pixelFormat) && v30)
  {
    objc_msgSend(*a3, sel_setPixelFormat_, v30);
    objc_msgSend(*a3, sel_pixelFormat);
    long long v36 = 0u;
    memset(v37, 0, 24);
    *(_OWORD *)long long buf = 0u;
    MTLPixelFormatGetInfoForDevice();
  }
LABEL_53:
  if (*(void *)a1)
  {
    int v31 = [*(id *)a1 supportsTextureSwizzle];
    id v32 = *a3;
    if (!v31)
    {
      objc_msgSend(v32, sel_pixelFormat);
      long long v36 = 0u;
      memset(v37, 0, 24);
      *(_OWORD *)long long buf = 0u;
      MTLPixelFormatGetInfoForDevice();
      if ((*(_WORD *)&buf[8] & 0x800) != 0 && *(_DWORD *)a4 != 84148994) {
        objc_msgSend(*a3, sel_setUsage_, (unint64_t)objc_msgSend(*a3, sel_usage) | 0x10);
      }
      goto LABEL_60;
    }
  }
  else
  {
    id v32 = *a3;
  }
  objc_msgSend(v32, sel_setSwizzle_, *(unsigned int *)a4);
LABEL_60:
  objc_msgSend(*a3, sel_pixelFormat);
  if (re::internal::textureMightNeedPixelFormatViewUsage()) {
    objc_msgSend(*a3, sel_setUsage_, (unint64_t)objc_msgSend(*a3, sel_usage) | 0x10);
  }
  unsigned int v33 = objc_msgSend(*a3, sel_pixelFormat);
  uint64_t v21 = 1;
  if (re::internal::applyCompressionOptionsToTextureDescriptor((id *)a1, this, 0, 1, a3)
    && re::isASTCPixelFormat((int)objc_msgSend(*a3, sel_pixelFormat)))
  {
    *a6 = v33;
  }
LABEL_65:

  return v21;
}

re *re::anonymous namespace'::createImageSourceAndUpdatedOptionsFromDescriptor(uint64_t a1, uint64_t a2, id *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  CFDataRef v8 = [MEMORY[0x263EFF8F8] dataWithBytesNoCopy:a1 length:a2 freeWhenDone:0];
  objc_msgSend(*a3, sel_pixelFormat);
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  *(_OWORD *)long long buf = 0u;
  MTLPixelFormatGetInfoForDevice();
  if ((unint64_t)objc_msgSend(*a3, sel_mipmapLevelCount) <= 1) {
    *(_DWORD *)(a5 + 20) = 2;
  }
  uint64_t v13 = *MEMORY[0x263F0F600];
  uint64_t v14 = MEMORY[0x263EFFA80];
  CFDictionaryRef v9 = [NSDictionary dictionaryWithObjects:&v14 forKeys:&v13 count:1];
  __n128 v10 = CGImageSourceCreateWithData(v8, v9);
  __n128 v11 = *re::pipelineLogObjects(v10);
  if (v10)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = a4;
      _os_log_debug_impl(&dword_233120000, v11, OS_LOG_TYPE_DEBUG, "Creating texture '%s' from KTX data using Image I/O fallback for non-native pixel format", buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = a4;
    _os_log_error_impl(&dword_233120000, v11, OS_LOG_TYPE_ERROR, "Failed to create image source for texture '%s'", buf, 0xCu);
  }

  return v10;
}

uint64_t re::TextureData::operator=(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(a1 + 8, a2 + 8);
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)(a2 + 96);
    *(void *)(a2 + 96) = 0;
    uint64_t v5 = *(void **)(a1 + 96);
    *(void *)(a1 + 96) = v4;
  }
  return a1;
}

id re::anonymous namespace'::createDownsampledDescriptor(void *a1, id *a2, id *a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a4 + 8) == 1) {
    int v9 = *(_DWORD *)(a4 + 16);
  }
  else {
    int v9 = 1;
  }
  unint64_t v10 = re::internal::downsampleFactorToFitDeviceLimits(a3, (int)objc_msgSend(*a2, sel_textureType), (unint64_t)objc_msgSend(*a2, sel_width), (unint64_t)objc_msgSend(*a2, sel_height), (unint64_t)objc_msgSend(*a2, sel_depth));
  if (v10 <= v9)
  {
    unint64_t v11 = v9;
  }
  else
  {
    unint64_t v11 = v10;
    id v12 = *re::pipelineLogObjects((re *)v10);
    unint64_t v10 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (v10)
    {
      unsigned int v13 = __clz(v11);
      unsigned int v14 = (0x80000000 >> v13) - 1;
      unsigned int v15 = 32 - v13;
      unsigned int v16 = 31 - v13;
      if (!v11)
      {
        unsigned int v14 = 0;
        unsigned int v16 = 0;
      }
      if ((v14 & v11) != 0) {
        uint64_t v17 = v15;
      }
      else {
        uint64_t v17 = v16;
      }
      id v18 = *a2;
      uint64_t v19 = v12;
      id v20 = objc_msgSend(v18, sel_width);
      id v21 = objc_msgSend(*a2, sel_height);
      LODWORD(v39[0]) = 134218496;
      *(void *)((char *)v39 + 4) = v17;
      WORD6(v39[0]) = 2048;
      *(void *)((char *)v39 + 14) = v20;
      WORD3(v39[1]) = 2048;
      *((void *)&v39[1] + 1) = v21;
      _os_log_impl(&dword_233120000, v19, OS_LOG_TYPE_DEFAULT, "Loading mip #%zu from imported %zux%zu KTX to match device limits", (uint8_t *)v39, 0x20u);
    }
  }
  unsigned int v22 = __clz(v11);
  unsigned int v23 = (0x80000000 >> v22) - 1;
  unsigned int v24 = 32 - v22;
  LODWORD(v25) = 31 - v22;
  if (!v11)
  {
    unsigned int v23 = 0;
    LODWORD(v25) = 0;
  }
  if ((v23 & v11) != 0) {
    unint64_t v25 = v24;
  }
  else {
    unint64_t v25 = v25;
  }
  *a5 = v25;
  if (v11 != 1 << v25)
  {
    CFStringRef v26 = *re::pipelineLogObjects((re *)v10);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v27 = *a5;
      int v28 = 1 << *a5;
      LODWORD(v39[0]) = 134218496;
      *(void *)((char *)v39 + 4) = v11;
      WORD6(v39[0]) = 2048;
      *(void *)((char *)v39 + 14) = v27;
      WORD3(v39[1]) = 1024;
      DWORD2(v39[1]) = v28;
      _os_log_impl(&dword_233120000, v26, OS_LOG_TYPE_DEFAULT, "Passed a downsampleFactor %zu which is not a power of two; falling back to the previous mipmap %lu (with a downs"
        "ampling factor of %i).",
        (uint8_t *)v39,
        0x1Cu);
    }
  }
  id v29 = *a2;
  id v30 = objc_msgSend(*a2, sel_copy);
  *a1 = v30;
  unint64_t v31 = *a5;
  id v32 = (re *)objc_msgSend(v29, sel_mipmapLevelCount);
  if (v31 >= (unint64_t)v32)
  {
    unsigned int v33 = *re::pipelineLogObjects(v32);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      size_t v34 = v33;
      id v35 = objc_msgSend(v29, sel_mipmapLevelCount);
      unint64_t v36 = *a5;
      LODWORD(v39[0]) = 134218240;
      *(void *)((char *)v39 + 4) = v35;
      WORD6(v39[0]) = 2048;
      *(void *)((char *)v39 + 14) = v36;
      _os_log_impl(&dword_233120000, v34, OS_LOG_TYPE_DEFAULT, "Downsampling a texture with %lu mipmaps by %lu", (uint8_t *)v39, 0x16u);
    }
    *a5 = (unint64_t)objc_msgSend(v29, sel_mipmapLevelCount) - 1;
  }
  uint64_t v40 = 0;
  memset(v39, 0, sizeof(v39));
  id v37 = *a3;
  objc_msgSend(v29, sel_pixelFormat);
  objc_msgSend(v29, sel_width);
  objc_msgSend(v29, sel_height);
  objc_msgSend(v29, sel_depth);
  objc_msgSend(v29, sel_sampleCount);
  MTLGetTextureLevelInfoForDevice();

  objc_msgSend(v30, sel_setWidth_, *(void *)&v39[0]);
  objc_msgSend(v30, sel_setHeight_, *((void *)&v39[0] + 1));
  objc_msgSend(v30, sel_setDepth_, *(void *)&v39[1]);
  return objc_msgSend(v30, sel_setMipmapLevelCount_, (char *)objc_msgSend(v29, sel_mipmapLevelCount) - *a5);
}

uint64_t re::processKtxMips(id *a1, re *a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, id *a7, unint64_t a8, id *a9, char a10, uint64_t a11, uint64_t a12)
{
  uint64_t v120 = *MEMORY[0x263EF8340];
  context = (void *)MEMORY[0x237DBDCF0]();
  unsigned int v17 = a6[10];
  unsigned int v85 = a6[9];
  unsigned int v18 = a6[11];
  id v19 = objc_msgSend(*a7, sel_width);
  id v20 = objc_msgSend(*a7, sel_height);
  id v21 = objc_msgSend(*a7, sel_depth);
  int v83 = a2;
  *(void *)__n128 v98 = a2;
  int v22 = 1;
  *(_DWORD *)&v98[8] = 1;
  uint64_t v101 = 0;
  memset(v99, 0, sizeof(v99));
  int v100 = 0;
  char v102 = 0;
  v103[0] = 0;
  unsigned int v106 = 0;
  id v107 = 0;
  char v108 = 0;
  memset(v109, 0, sizeof(v109));
  int v110 = 0;
  id v112 = 0;
  uint64_t v111 = 0;
  uint64_t v81 = a3;
  uint64_t v82 = a4;
  if (re::TextureBuilderKTX::init((uint64_t)v98, a9, *(unsigned char *)(a3 + 52), a4))
  {
    if (v19 <= v20) {
      unint64_t v23 = (unint64_t)v20;
    }
    else {
      unint64_t v23 = (unint64_t)v19;
    }
    if (v23 <= (unint64_t)v21) {
      unint64_t v23 = (unint64_t)v21;
    }
    int v24 = __clz(v23);
    unsigned int v25 = 64 - v24;
    unsigned int v26 = 63 - v24;
    BOOL v27 = v24 == 64;
    if (v24 == 64) {
      uint64_t v28 = 0;
    }
    else {
      uint64_t v28 = ~(-1 << (63 - v24));
    }
    if (v27) {
      unsigned int v26 = 0;
    }
    if ((v28 & v23) != 0) {
      uint64_t v29 = v25;
    }
    else {
      uint64_t v29 = v26;
    }
    LODWORD(v30) = v85;
    if (v85 <= v17) {
      LODWORD(v30) = v17;
    }
    if (v30 <= v18) {
      uint64_t v30 = v18;
    }
    else {
      uint64_t v30 = v30;
    }
    unsigned int v31 = 32 - __clz(v30);
    unsigned int v32 = v31 - 1;
    uint64_t v33 = ~(-1 << (v31 - 1));
    if (!v30)
    {
      uint64_t v33 = 0;
      unsigned int v32 = 0;
    }
    if ((v33 & v30) != 0) {
      uint64_t v34 = v31;
    }
    else {
      uint64_t v34 = v32;
    }
    id v35 = a1;
    id v36 = *a1;
    uint64_t v37 = *(void *)(a5 + 80);
    uint64_t v38 = *(void *)(a5 + 88);
    unsigned int v39 = objc_msgSend(*a7, sel_textureType);
    objc_msgSend(*a7, sel_pixelFormat);
    unsigned int v40 = objc_msgSend(*a7, sel_arrayLength);
    uint64_t v41 = (re *)objc_msgSend(*a7, sel_sampleCount);
    unint64_t v94 = &unk_26E7150B0;
    uint64_t v95 = v37;
    uint64_t v96 = v38;
    size_t v97 = 0;
    if (v39 == 5)
    {
      uint64_t v84 = 6;
      unint64_t v42 = a8;
    }
    else
    {
      unint64_t v42 = a8;
      if (v39 == 3) {
        uint64_t v43 = v40;
      }
      else {
        uint64_t v43 = 1;
      }
      uint64_t v84 = v43;
    }
    uint64_t v44 = a5;
    if (*(_DWORD *)(a5 + 56))
    {
      unint64_t v45 = 0;
      uint64_t v79 = v29 - v34;
      int v78 = -(int)v42;
      while (1)
      {
        unsigned int __dst = 0;
        if (!v95
          || ((size_t v46 = v97, v47 = v96 - v97, v96 - v97 >= 4) ? (v48 = 4) : (v48 = v96 - v97),
              uint64_t v41 = (re *)memcpy(&__dst, (const void *)(v95 + v97), v48),
              size_t v97 = v48 + v46,
              v47 <= 3))
        {
          int v65 = *re::pipelineLogObjects(v41);
          if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
            goto LABEL_84;
          }
          *(_WORD *)long long buf = 0;
          int v66 = "Unexpected end of file when reading image size from KTX";
          goto LABEL_81;
        }
          goto LABEL_84;
        unint64_t v92 = 0;
        long long v91 = 0u;
        memset(v90, 0, sizeof(v90));
        re::ktxMipInfo(v35, (uint64_t)v90);
        unsigned int v50 = v91;
        if (DWORD1(v91))
        {
          int v65 = *re::pipelineLogObjects(v41);
          if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
            goto LABEL_84;
          }
          *(_WORD *)long long buf = 0;
          int v66 = "Overflow when computing row block bytes during KTX load";
          goto LABEL_81;
        }
        unsigned int v51 = DWORD2(v91);
        if (HIDWORD(*((void *)&v91 + 1)))
        {
          int v65 = *re::pipelineLogObjects(v41);
          if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
            goto LABEL_84;
          }
          *(_WORD *)long long buf = 0;
          int v66 = "Overflow when computing image block bytes during KTX load";
          goto LABEL_81;
        }
        int v52 = v92;
        if (HIDWORD(v92))
        {
          int v65 = *re::pipelineLogObjects(v41);
          if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
            goto LABEL_84;
          }
          *(_WORD *)long long buf = 0;
          int v66 = "Overflow when computing image block bytes during KTX load";
          goto LABEL_81;
        }
        unsigned int v53 = __dst;
        if (*(_DWORD *)(v44 + 52) != 6 || *(_DWORD *)(v44 + 48))
        {
          unint64_t v54 = v92;
        }
        else
        {
          if (*((void *)&v91 + 1) == ((__dst + 3) & 0x1FFFFFFFCLL))
          {
            unint64_t v54 = v92;
          }
          else
          {
            uint64_t v55 = *re::pipelineLogObjects(v41);
            uint64_t v41 = (re *)os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT);
            if (v41)
            {
              *(_DWORD *)long long buf = 67109376;
              *(_DWORD *)&uint8_t buf[4] = v51;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v53;
              _os_log_impl(&dword_233120000, v55, OS_LOG_TYPE_DEFAULT, "KTX image size field for non-array cubemap is unexpected (expected: %u, got: %u)", buf, 0xEu);
            }
            unsigned int v51 = (v53 + 3) & 0xFFFFFFFC;
            unint64_t v54 = v92;
          }
          v53 *= 6;
        }
        unsigned int v56 = v54 * v84;
        if ((v54 * v84) >> 32) {
          break;
        }
        if (v53 < v56)
        {
          char v69 = *re::pipelineLogObjects(v41);
          if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
          {
LABEL_84:
            int v22 = 1;
            goto LABEL_85;
          }
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v56;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v53;
          int v66 = "KTX image size field is too small for given pixel format and dimensions (expected: %u, got: %u)";
          uint64_t v67 = v69;
          uint32_t v68 = 14;
LABEL_82:
          _os_log_error_impl(&dword_233120000, v67, OS_LOG_TYPE_ERROR, v66, buf, v68);
          goto LABEL_84;
        }
        if (v53 > v56)
        {
          char v57 = *re::pipelineLogObjects(v41);
          uint64_t v41 = (re *)os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT);
          if (v41)
          {
            *(_DWORD *)long long buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v56;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v53;
            _os_log_impl(&dword_233120000, v57, OS_LOG_TYPE_DEFAULT, "KTX image size field is larger than expected given pixel format and dimensions (expected: %u, got: %u)", buf, 0xEu);
          }
        }
        if (!v95 || (size_t v58 = v97, v96 - v97 < v53))
        {
          int v65 = *re::pipelineLogObjects(v41);
          if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
            goto LABEL_84;
          }
          *(_WORD *)long long buf = 0;
          int v66 = "Unexpected end of file when reading image from KTX";
          goto LABEL_81;
        }
        v97 += v53;
        if (v45 >= v42)
        {
          uint64_t v80 = v95 + v58;
          id v119 = 0;
          long long v117 = 0u;
          long long v118 = 0u;
          long long v115 = 0u;
          long long v116 = 0u;
          *(_OWORD *)long long buf = 0u;
          long long v114 = 0u;
          id v59 = *a9;
          id v60 = v36;
          objc_msgSend(v59, sel_pixelFormat);
          objc_msgSend(*a9, sel_sampleCount);
          id v35 = a1;
          MTLGetTextureLevelInfoForDevice();

          char v61 = v60;
          unint64_t v42 = a8;
          uint64_t v41 = (re *)re::TextureBuilderKTX::setMip((uint64_t)v98, v61, v78 + v45, v80, v53, v50, v51, v52, (uint64_t *)buf, v79);
          if ((v41 & 1) == 0) {
            goto LABEL_84;
          }
        }
        ++v45;
        uint64_t v44 = a5;
        if (v45 >= *(unsigned int *)(a5 + 56)) {
          goto LABEL_61;
        }
      }
      int v65 = *re::pipelineLogObjects(v41);
      if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
        goto LABEL_84;
      }
      *(_WORD *)long long buf = 0;
      int v66 = "Overflow when computing image size during KTX load";
LABEL_81:
      uint64_t v67 = v65;
      uint32_t v68 = 2;
      goto LABEL_82;
    }
LABEL_61:
    if (a11)
    {
      uint64_t v62 = *(void *)(a11 + 24);
      if (!v62)
      {
        uint64_t v77 = std::__throw_bad_function_call[abi:nn180100]();
      }
      (*(void (**)(uint64_t))(*(void *)v62 + 48))(v62);
    }
    re::TextureBuilderKTX::finish((uint64_t)buf, (uint64_t)v98, (uint64_t)*v35, *a9);
    *(unsigned char *)a12 = buf[0];
    std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(a12 + 8, (uint64_t)&buf[8]);
    if (buf != (uint8_t *)a12)
    {
      id v63 = v119;
      id v119 = 0;
      __int16 v64 = *(void **)(a12 + 96);
      *(void *)(a12 + 96) = v63;
    }
    if (DWORD2(v118) != -1) {
      ((void (*)(_OWORD *, uint8_t *))*(&__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2NS9SharedPtrIN3MTL7TextureEEEN2re10CPUTextureEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSF_EEEDcOSG_DpOT0____fmatrix_1
    }
                                                 + DWORD2(v118)))(v90, &buf[8]);
    int v22 = 0;
LABEL_85:
  }
  re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::deinit((uint64_t)v109);

  if (v106 != -1) {
    ((void (*)(uint8_t *, uint64_t *))*(&__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2NS9SharedPtrIN3MTL7TextureEEEN2re10CPUTextureEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSF_EEEDcOSG_DpOT0____fmatrix_1
  }
                                                + v106))(buf, v103);
  unsigned int v106 = -1;
  re::DynamicArray<re::DynamicArray<unsigned char>>::deinit((uint64_t)v99);
  if (v22) {
    return 0;
  }
  if (!a10) {
    return 1;
  }
  unsigned int v72 = *re::pipelineLogObjects(v70);
  if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__n128 v98 = 136315138;
    *(void *)&v98[4] = v82;
    _os_log_impl(&dword_233120000, v72, OS_LOG_TYPE_DEFAULT, "ASTC compressed textures are not supported by this device, decompressing '%s'.", v98, 0xCu);
  }
  re::decompressCPUTexture((re *)a12, (uint64_t)v98);
  *(unsigned char *)a12 = v98[0];
  std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(a12 + 8, (uint64_t)&v98[8]);
  if (v98 != (unsigned char *)a12)
  {
    id v73 = v105;
    id v105 = 0;
    id v74 = *(void **)(a12 + 96);
    *(void *)(a12 + 96) = v73;
  }
  if (v104 != -1) {
    ((void (*)(uint8_t *, unsigned char *))*(&__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2NS9SharedPtrIN3MTL7TextureEEEN2re10CPUTextureEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSF_EEEDcOSG_DpOT0____fmatrix_1
  }
                                              + v104))(buf, &v98[8]);
  uint64_t result = re::TextureData::isValid((re::TextureData *)a12);
  if (result)
  {
    if (!*(void *)v83) {
      return 1;
    }
    re::loadCPUTextureInMetal(v83, (const re::ImportGraphicsContext *)a12, (const re::TextureData *)*(unsigned __int8 *)(v81 + 52), (uint64_t)v98);
    *(unsigned char *)a12 = v98[0];
    std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(a12 + 8, (uint64_t)&v98[8]);
    if (v98 != (unsigned char *)a12)
    {
      id v75 = v105;
      id v105 = 0;
      uint64_t v76 = *(void **)(a12 + 96);
      *(void *)(a12 + 96) = v75;
    }
    if (v104 != -1) {
      ((void (*)(uint8_t *, unsigned char *))*(&__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2NS9SharedPtrIN3MTL7TextureEEEN2re10CPUTextureEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSF_EEEDcOSG_DpOT0____fmatrix_1
    }
                                                + v104))(buf, &v98[8]);
    uint64_t result = re::TextureData::isValid((re::TextureData *)a12);
    if (result) {
      return 1;
    }
  }
  return result;
}

uint64_t re::Result<re::anonymous namespace'::KTXData,re::DynamicString>::~Result(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    unint64_t v2 = *(void **)(a1 + 72);
    if (v2)
    {

      *(void *)(a1 + 72) = 0;
    }
  }
  else
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 8));
  }
  return a1;
}

uint64_t re::createTextureDescriptorForKTXData@<X0>(id *a1@<X0>, __n128 *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, unsigned char *a8@<X7>, id *a9@<X8>, unsigned __int8 a10)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  int v30 = a4;
  if (v36[0])
  {
    if (a7)
    {
      *(void *)&long long v19 = v38;
      *((void *)&v19 + 1) = v39;
      *(_OWORD *)a7 = v19;
      *(void *)(a7 + 16) = v40;
      *a8 = v42;
    }
    id v29 = v41;
    long long v20 = *(_OWORD *)(a6 + 16);
    *(_OWORD *)long long buf = *(_OWORD *)a6;
    long long v32 = v20;
    v33[0] = *(_OWORD *)(a6 + 32);
    *(_OWORD *)((char *)v33 + 12) = *(_OWORD *)(a6 + 44);
    id v34 = *(id *)(a6 + 64);
    long long v35 = *(_OWORD *)(a6 + 72);
    {
      if (re::useImageIOForTextureImport((uint64_t)a1, &v29, a6))
      {
        id v21 = v29;
        id v27 = v21;
        if (v21) {

        }
        if (v22)
        {
          re::createTextureDescriptorForCGImageSource(v22, a1, &v29, buf, 0, 0, 0, a9);
          CFRelease(v22);
        }
        else
        {
          *a9 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
        }
      }
      else
      {
        unint64_t v26 = 0;
      }
    }
    else
    {
      *a9 = 0;
    }

    if (v29) {
  }
    }
  else
  {
    unint64_t v23 = *re::pipelineLogObjects(v18);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      if (v36[16]) {
        unsigned int v25 = *(unsigned char **)&v37[7];
      }
      else {
        unsigned int v25 = v37;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v25;
      _os_log_error_impl(&dword_233120000, v23, OS_LOG_TYPE_ERROR, "Failed to create texture from KTX: %s", buf, 0xCu);
    }
    *a9 = 0;
  }
}

uint64_t re::loadDescriptor@<X0>(__n128 *a1@<X0>, unint64_t a2@<X1>, id *a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (v14[0])
  {
    id v7 = v17;
    objc_msgSend(v7, sel_pixelFormat);
    objc_msgSend(v7, sel_textureType);
    if ((re::isSupportedPixelFormat() & 1) == 0) {
      objc_msgSend(v7, sel_setPixelFormat_, 70);
    }
    id v8 = v7;
    *(unsigned char *)a5 = 1;
    *(void *)(a5 + 8) = v8;
    if (v7) {
  }
    }
  else
  {
    int v9 = *re::pipelineLogObjects(v6);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (v15[8]) {
        unint64_t v11 = *(unsigned char **)&v16[7];
      }
      else {
        unint64_t v11 = v16;
      }
      *(_DWORD *)id v12 = 136315138;
      *(void *)&void v12[4] = v11;
      _os_log_error_impl(&dword_233120000, v9, OS_LOG_TYPE_ERROR, "Failed to parse KTX: %s", v12, 0xCu);
    }
    re::DynamicString::DynamicString((re::DynamicString *)v12, (const re::DynamicString *)v15);
    *(unsigned char *)a5 = 0;
    *(void *)(a5 + 8) = *(void *)v12;
    *(void *)(a5 + 32) = v13;
    *(_OWORD *)(a5 + 16) = *(_OWORD *)&v12[8];
  }
}

uint64_t re::readMetadataFromKTXData@<X0>(__n128 *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _anonymous_namespace_ *a5@<X4>, _anonymous_namespace_ *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  id v41 = 0;
  if (v47[0])
  {
    long long v13 = v51;
    long long v14 = v49;
    *(_OWORD *)a4 = v48;
    *(_OWORD *)(a4 + 16) = v14;
    *(_OWORD *)(a4 + 32) = v50;
    *(_OWORD *)(a4 + 48) = v13;
    uint64_t v15 = *(unsigned int *)(a4 + 60);
    if (!v15)
    {
      *(unsigned char *)a7 = 1;
      *(_DWORD *)(a7 + 8) = 0;
    }
    *(void *)long long buf = &unk_26E7150B0;
    *(void *)&uint8_t buf[8] = v52;
    *(void *)&uint8_t buf[16] = v15;
    uint64_t v46 = 0;
    if (v15 < 5)
    {
LABEL_28:
      *(unsigned char *)a7 = 1;
      *(_DWORD *)(a7 + 8) = v15;
    }
    uint64_t v16 = 0;
    while (1)
    {
      int __dst = 0;
      unint64_t v17 = v15 - v16;
      if (*(void *)&buf[8])
      {
        size_t v18 = v17 >= 4 ? 4 : v15 - v16;
        memcpy(&__dst, (const void *)(*(void *)&buf[8] + v16), v18);
        v16 += v18;
        uint64_t v46 = v16;
        size_t v19 = __dst;
        unint64_t v17 = v15 - v16;
        if (__dst >= 1 && v17 >= __dst)
        {
          size_t v21 = (__dst + 3) & 0xFFFFFFFC;
          int v22 = (char *)(*(uint64_t (**)(uint64_t, size_t, void))(*(void *)a3 + 32))(a3, v21, 0);
          unint64_t v23 = v22;
          if (*(void *)&buf[8])
          {
            if (*(void *)&buf[16] - v46 < v21) {
              size_t v21 = *(void *)&buf[16] - v46;
            }
            memcpy(v22, (const void *)(*(void *)&buf[8] + v46), v21);
            v46 += v21;
          }
          int v24 = (re *)strnlen(v23, v19);
          if (v24 == (re *)v19)
          {
            uint64_t v33 = *re::pipelineLogObjects(v24);
            BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
            if (v34)
            {
              if (BYTE8(v48)) {
                unsigned int v39 = (char *)v49;
              }
              else {
                unsigned int v39 = (char *)&v48 + 9;
              }
              *(_DWORD *)char v42 = 136315138;
              *(void *)&v42[4] = v39;
              _os_log_error_impl(&dword_233120000, v33, OS_LOG_TYPE_ERROR, "Failed to parse KTX: %s", v42, 0xCu);
            }
            long long v35 = *(_OWORD *)v42;
            uint64_t v36 = v43;
            uint64_t v37 = v44;
            *(unsigned char *)a7 = 0;
            *(_OWORD *)(a7 + 8) = v35;
            *(void *)(a7 + 24) = v36;
            *(void *)(a7 + 32) = v37;
          }
          size_t v25 = (size_t)v24;
          double v26 = re::DynamicArray<re::DynamicString>::add(a5, v42);
          if (*(void *)v42 && (v42[8] & 1) != 0) {
            (*(void (**)(double))(**(void **)v42 + 40))(v26);
          }
          size_t v27 = v19 - (v25 + 1);
          unsigned int v28 = &v23[v25 + 1];
          id v29 = (_anonymous_namespace_ *)strnlen(v28, v27);
          v30.n128_f64[0] = re::DynamicArray<re::DynamicString>::add(a6, v42);
          if (*(void *)v42 && (v42[8] & 1) != 0) {
            (*(void (**)(double))(**(void **)v42 + 40))(v30.n128_f64[0]);
          }
          (*(void (**)(uint64_t, const char *, __n128))(*(void *)a3 + 40))(a3, v23, v30);
          uint64_t v15 = *(void *)&buf[16];
          uint64_t v16 = v46;
          unint64_t v17 = *(void *)&buf[16] - v46;
        }
      }
      if (v17 <= 4)
      {
        LODWORD(v15) = *(_DWORD *)(a4 + 60);
        goto LABEL_28;
      }
    }
  }
  unsigned int v31 = *re::pipelineLogObjects(v12);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    if (BYTE8(v48)) {
      unsigned int v38 = (char *)v49;
    }
    else {
      unsigned int v38 = (char *)&v48 + 9;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v38;
    _os_log_error_impl(&dword_233120000, v31, OS_LOG_TYPE_ERROR, "Failed to parse KTX: %s", buf, 0xCu);
  }
  re::DynamicString::DynamicString((re::DynamicString *)buf, (const re::DynamicString *)&v48);
  *(unsigned char *)a7 = 0;
  *(void *)(a7 + 8) = *(void *)buf;
  *(void *)(a7 + 32) = v46;
  *(_OWORD *)(a7 + 16) = *(_OWORD *)&buf[8];
}

void re::makeLoadedTextureView(id *a1@<X0>, _WORD *a2@<X1>, id *a3@<X8>)
{
  unint64_t v5 = (unsigned __int16)*a2;
  if (*a2)
  {
    unint64_t v6 = __clz(__rbit64(v5));
    if (v6 >= 0x10) {
      uint64_t v7 = -1;
    }
    else {
      uint64_t v7 = v6;
    }
    if ((unint64_t)(v7 + 1) > 0xF)
    {
      uint64_t v9 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v9 = 16 - v7;
      while (((v5 >> (v7 + v8 + 1)) & 1) != 0)
      {
        ++v8;
        if (v7 + v8 == 15) {
          goto LABEL_15;
        }
      }
      uint64_t v9 = v8 + 1;
    }
LABEL_15:
    id v11 = *a1;
    uint64_t v12 = (uint64_t)objc_msgSend(*a1, sel_arrayLength);
    if ((char *)objc_msgSend(v11, sel_textureType) - 5 >= (char *)2) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 6 * v12;
    }
    *a3 = objc_msgSend(*a1, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, objc_msgSend(*a1, sel_pixelFormat), objc_msgSend(*a1, sel_textureType), v7, v9, 0, v13);
  }
  else
  {
    unint64_t v10 = *re::pipelineLogObjects((re *)a1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long v14 = 0;
      _os_log_error_impl(&dword_233120000, v10, OS_LOG_TYPE_ERROR, "updateTextureView called with no mipsLoaded", v14, 2u);
    }
    *a3 = *a1;
    *a1 = 0;
  }
}

void re::copyTextureMips(uint64_t a1, id *a2, id *a3, unsigned __int16 *a4)
{
  uint64_t v7 = *a4;
  id v8 = objc_msgSend(*a2, sel_width);
  id v9 = objc_msgSend(*a2, sel_height);
  id v10 = objc_msgSend(*a2, sel_depth);
  id v11 = objc_msgSend(*a3, sel_width);
  id v12 = objc_msgSend(*a3, sel_height);
  id v13 = objc_msgSend(*a3, sel_depth);
  if (v8 <= v9) {
    unint64_t v14 = (unint64_t)v9;
  }
  else {
    unint64_t v14 = (unint64_t)v8;
  }
  if (v14 <= (unint64_t)v10) {
    unint64_t v14 = (unint64_t)v10;
  }
  if (v11 <= v12) {
    unint64_t v15 = (unint64_t)v12;
  }
  else {
    unint64_t v15 = (unint64_t)v11;
  }
  if (v15 <= (unint64_t)v13) {
    unint64_t v15 = (unint64_t)v13;
  }
  int v16 = __clz(v14);
  unsigned int v17 = 64 - v16;
  unsigned int v18 = 63 - v16;
  BOOL v19 = v16 == 64;
  if (v16 == 64) {
    uint64_t v20 = 0;
  }
  else {
    uint64_t v20 = ~(-1 << (63 - v16));
  }
  if (v19) {
    unsigned int v18 = 0;
  }
  if ((v20 & v14) != 0) {
    uint64_t v21 = v17;
  }
  else {
    uint64_t v21 = v18;
  }
  int v22 = __clz(v15);
  unsigned int v23 = 64 - v22;
  unsigned int v24 = 63 - v22;
  BOOL v25 = v22 == 64;
  if (v22 == 64) {
    uint64_t v26 = 0;
  }
  else {
    uint64_t v26 = ~(-1 << (63 - v22));
  }
  if (v25) {
    unsigned int v24 = 0;
  }
  if ((v26 & v15) != 0) {
    uint64_t v27 = v23;
  }
  else {
    uint64_t v27 = v24;
  }
  id v28 = *a2;
  uint64_t v29 = (uint64_t)objc_msgSend(*a2, sel_arrayLength);
  if ((char *)objc_msgSend(v28, sel_textureType) - 5 >= (char *)2) {
    uint64_t v30 = v29;
  }
  else {
    uint64_t v30 = 6 * v29;
  }
  objc_msgSend(*a2, sel_sampleCount);
  unsigned int v31 = (re *)objc_msgSend(*a2, sel_mipmapLevelCount);
  uint64_t v32 = v27 - v21;
  if (v27 - v21 < 0)
  {
    unsigned int v40 = *re::pipelineLogObjects(v31);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_233120000, v40, OS_LOG_TYPE_ERROR, "Failed copyTextureMips: unexpected mipmapOffset", buf, 2u);
    }
  }
  else
  {
    uint64_t v33 = v31;
    id v41 = a4;
    id v44 = objc_msgSend(*a2, sel_device);
    *(void *)long long buf = 0x3676813F7E71551;
    *(void *)&uint8_t buf[8] = "CopyKTXTextureMipsQueue";
    re::ImportGraphicsContext::getOrCreateCommandQueue(a1, (uint64_t)buf, (const char *)1, &v55);
    re::mtl::CommandQueue::makeCommandBuffer(&v55, &v54);
    re::mtl::CommandBuffer::makeBlitCommandEncoder(&v54, &v53);
    objc_msgSend(*a2, sel_pixelFormat);
    if (v33)
    {
      BOOL v34 = 0;
      uint64_t v42 = v32;
      uint64_t v43 = v33;
      do
      {
        uint64_t v35 = (uint64_t)v34 + v32;
        uint64_t v36 = 1 << (v34 + v32);
        if ((v36 & v7) == 0)
        {
          uint64_t v52 = 0;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          *(_OWORD *)long long buf = 0u;
          long long v47 = 0u;
          MTLGetTextureLevelInfoForDeviceWithOptions();
          MTLGetTextureLevelInfoForDeviceWithOptions();
          if (v30)
          {
            for (uint64_t i = 0; i != v30; ++i)
            {
              id v38 = *a2;
              id v39 = *a3;
              memset(v59, 0, 24);
              long long v57 = *(_OWORD *)buf;
              uint64_t v58 = v47;
              memset(v56, 0, sizeof(v56));
              [v53 copyFromTexture:v38 sourceSlice:i sourceLevel:v34 sourceOrigin:v59 sourceSize:&v57 toTexture:v39 destinationSlice:i destinationLevel:v35 destinationOrigin:v56];
            }
          }
          v7 |= (unsigned __int16)v36;
          uint64_t v32 = v42;
          uint64_t v33 = v43;
        }
        BOOL v34 = (re *)((char *)v34 + 1);
      }
      while (v34 != v33);
    }
    [v53 endEncoding];
    [v54 commit];
    [v54 waitUntilCompleted];
    *id v41 = v7;
  }
}

size_t re::makeStandardKtxMetadata(int a1, CFTypeRef cf1, int a3, uint64_t a4, void *a5)
{
  if (!cf1)
  {
    id v13 = 0;
    id v39 = 0;
    unint64_t v14 = 0;
    goto LABEL_5;
  }
  id v9 = (const void *)*MEMORY[0x263F002C8];
  int v10 = CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F002C8]);
  id v11 = (CFTypeRef *)MEMORY[0x263F00238];
  if (v10)
  {
    CFTypeRef v12 = (CFTypeRef)*MEMORY[0x263F00238];
LABEL_9:
    BOOL v19 = "sRGB";
    goto LABEL_10;
  }
  int v18 = CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00230]);
  CFTypeRef v12 = *v11;
  if (v18 || CFEqual(cf1, *v11) || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F002D8])) {
    goto LABEL_9;
  }
  if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F001E8])
    || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F002B0])
    || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00200])
    || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00218])
    || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F001F8])
    || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F001F0]))
  {
    BOOL v19 = "DisplayP3";
  }
  else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F001D0]))
  {
    BOOL v19 = "ACEScg";
  }
  else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00298]))
  {
    BOOL v19 = "BT709";
  }
  else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00278]) {
         || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00210])
  }
         || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00228]))
  {
    BOOL v19 = "BT2020";
  }
  else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F001E0]))
  {
    BOOL v19 = "DCIP3";
  }
  else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00290]) || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00288]))
  {
    BOOL v19 = "BT2100";
  }
  else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F001D8]))
  {
    BOOL v19 = "Adobe-RGB-1998";
  }
  else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00270]))
  {
    BOOL v19 = "CIE-1931-XYZ";
  }
  else
  {
    BOOL v19 = 0;
  }
LABEL_10:
  if (CFEqual(cf1, v12)
    || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F002D8])
    || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F001E8])
    || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00200]))
  {
    unint64_t v14 = "sRGB";
  }
  else if (CFEqual(cf1, v9) {
         || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00230])
  }
         || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F002B0])
         || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00218])
         || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F001D0])
         || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00228]))
  {
    unint64_t v14 = "linear";
  }
  else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00298]) {
         || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00278])
  }
         || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00210]))
  {
    unint64_t v14 = "ITU";
  }
  else if (CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00290]) || CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F001F8]))
  {
    unint64_t v14 = "PQ";
  }
  else
  {
    unint64_t v14 = "HLG";
    if (!CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F00288]) && !CFEqual(cf1, (CFTypeRef)*MEMORY[0x263F001F0])) {
      unint64_t v14 = 0;
    }
  }
  BOOL v17 = v19 == 0;
  if (!v19)
  {
    id v13 = 0;
    if (v14) {
      goto LABEL_19;
    }
    id v39 = 0;
LABEL_5:
    id v38 = 0;
    unsigned int v15 = 28;
    char v16 = 1;
    BOOL v17 = 1;
    goto LABEL_22;
  }
  id v13 = (char *)(strlen(v19) + 1);
  if (!v14)
  {
    id v38 = 0;
    id v39 = v19;
    BOOL v17 = 0;
    unsigned int v15 = ((v13 + 34) & 0xFFFFFFFC) + 28;
    char v16 = 1;
    goto LABEL_22;
  }
LABEL_19:
  size_t v20 = strlen(v14);
  char v16 = 0;
  id v38 = (char *)(v20 + 1);
  id v39 = v19;
  int v21 = ((v13 + 34) & 0xFFFFFFFC) + 28;
  if (!v19) {
    int v21 = 28;
  }
  unsigned int v15 = v21 + ((v20 + 38) & 0xFFFFFFFC);
LABEL_22:
  if (a3) {
    unint64_t v22 = v15 + 44;
  }
  else {
    unint64_t v22 = v15;
  }
  unsigned int v23 = (char *)(*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)a4 + 32))(a4, v22, 0);
  unsigned int v24 = v23;
  uint64_t v43 = &unk_26E714D80;
  id v44 = v23;
  unint64_t v45 = v22;
  int v42 = a1;
  int __src = 24;
  if (v22 >= 4) {
    size_t v25 = 4;
  }
  else {
    size_t v25 = v22;
  }
  memcpy(v23, &__src, v25);
  if (v22 - v25 >= 0x14) {
    size_t v26 = 20;
  }
  else {
    size_t v26 = v22 - v25;
  }
  memcpy(&v24[v25], "KTXmetalPixelFormat", v26);
  size_t v27 = v25 + v26;
  if (v22 - v27 >= 4) {
    size_t v28 = 4;
  }
  else {
    size_t v28 = v22 - v27;
  }
  memcpy(&v24[v27], &v42, v28);
  size_t v30 = v27 + v28;
  size_t v46 = v30;
  if (!v17) {
  if ((v16 & 1) == 0)
  }
  if (a3)
  {
    int v41 = 1;
    int __src = 24;
    if (v45 - v46 >= 4) {
      size_t v31 = 4;
    }
    else {
      size_t v31 = v45 - v46;
    }
    memcpy(&v44[v46], &__src, v31);
    size_t v32 = v46 + v31;
    size_t v46 = v32;
    if (v45 - v32 >= 0x14) {
      size_t v33 = 20;
    }
    else {
      size_t v33 = v45 - v32;
    }
    memcpy(&v44[v32], "KTXmetalPixelFormat", v33);
    size_t v34 = v46 + v33;
    int v35 = v33 + v31;
    if (v45 - v34 >= 4) {
      size_t v36 = 4;
    }
    else {
      size_t v36 = v45 - v34;
    }
    memcpy(&v44[v34], &v41, v36);
    size_t v30 = (v30 + v35 + v36);
  }
  *a5 = v24;
  return v30;
}

char *re::anonymous namespace'::writeKeyValueMetadataPair(re::_anonymous_namespace_ *this, char *a2, const void *a3, char *a4, void *a5, re::MemoryStreamWriter *a6)
{
  uint64_t v7 = a4;
  id v9 = a2;
  uint64_t v11 = a5[3];
  uint64_t v12 = a5[1];
  if ((unint64_t)(a5[2] - v11) >= 4) {
    size_t v13 = 4;
  }
  else {
    size_t v13 = a5[2] - v11;
  }
  int v14 = a4 + a2;
  int __src = a4 + a2;
  memcpy((void *)(v12 + v11), &__src, v13);
  uint64_t v15 = a5[2];
  size_t v16 = a5[3] + v13;
  a5[3] = v16;
  BOOL v17 = (char *)(v15 - v16);
  if (v17 < v9) {
    id v9 = v17;
  }
  memcpy((void *)(a5[1] + v16), this, (size_t)v9);
  uint64_t v18 = a5[2];
  BOOL v19 = &v9[a5[3]];
  a5[3] = v19;
  size_t v20 = &v9[v13];
  int v21 = (char *)(v18 - (void)v19);
  if (v21 < v7) {
    uint64_t v7 = v21;
  }
  memcpy(&v19[a5[1]], a3, (size_t)v7);
  unint64_t v22 = &v7[a5[3]];
  a5[3] = v22;
  unsigned int v23 = &v7[(void)v20];
  if ((-v14 & 3) != 0)
  {
    int v26 = 0;
    if (a5[2] - (void)v22 >= (unint64_t)(-v14 & 3)) {
      size_t v24 = -v14 & 3;
    }
    else {
      size_t v24 = a5[2] - (void)v22;
    }
    memcpy(&v22[a5[1]], &v26, v24);
    a5[3] += v24;
    v23 += v24;
  }
  return v23;
}

uint64_t re::loadCPUTextureInMetal@<X0>(re *this@<X0>, const re::ImportGraphicsContext *a2@<X1>, const re::TextureData *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v5 = (uint64_t *)this;
  int v6 = 1;
  uint64_t v9 = 0;
  memset(v7, 0, sizeof(v7));
  int v8 = 0;
  char v10 = 0;
  v11[0] = 0;
  unsigned int v12 = 0;
  id v13 = 0;
  char v14 = 0;
  memset(v15, 0, sizeof(v15));
  int v16 = 0;
  uint64_t v17 = 0;
  id v18 = 0;
  re::TextureBuilderKTX::loadCPUTextureInMetal(&v5, a2, (char)a3, a4);

  re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::deinit((uint64_t)v15);
  if (v12 != -1) {
    ((void (*)(char *, void *))*(&__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2NS9SharedPtrIN3MTL7TextureEEEN2re10CPUTextureEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSF_EEEDcOSG_DpOT0____fmatrix_1
  }
                                            + v12))(&v19, v11);
  unsigned int v12 = -1;
  return re::DynamicArray<re::DynamicArray<unsigned char>>::deinit((uint64_t)v7);
}

void re::TextureBuilderKTX::loadCPUTextureInMetal(uint64_t **this@<X0>, const re::TextureData *a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (*((_DWORD *)a2 + 22) != 1) {
LABEL_27:
  }
    std::__throw_bad_variant_access[abi:nn180100]();
  uint64_t v7 = (id *)((char *)a2 + 8);
  int v8 = (char *)a2 + 65;
  if (*((void *)a2 + 8)) {
    uint64_t v9 = (char *)*((void *)a2 + 9);
  }
  else {
    uint64_t v9 = (char *)a2 + 65;
  }
  if (!re::TextureBuilderKTX::init((uint64_t)this, (id *)a2 + 1, a3, (uint64_t)v9))
  {
    *(unsigned char *)a4 &= 0x80u;
    *(void *)(a4 + 8) = 0;
    *(_DWORD *)(a4 + 88) = 0;
    *(void *)(a4 + 96) = 0;
    return;
  }
  int v21 = v8;
  if (!re::TextureData::mipmapLevelCount(a2))
  {
LABEL_16:
    re::TextureBuilderKTX::finish(a4, (uint64_t)this, **this, *v7);
    return;
  }
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  while (1)
  {
    uint64_t v24 = 0;
    *(_OWORD *)unsigned int v23 = 0u;
    memset(v22, 0, sizeof(v22));
    id v12 = (id)**this;
    if (*((_DWORD *)a2 + 22) >= 2u) {
      goto LABEL_27;
    }
    id v13 = v12;
    objc_msgSend(*((id *)a2 + 1), sel_pixelFormat);
    if (*((_DWORD *)a2 + 22) >= 2u) {
      goto LABEL_27;
    }
    objc_msgSend(*((id *)a2 + 1), sel_width);
    if (*((_DWORD *)a2 + 22) >= 2u) {
      goto LABEL_27;
    }
    objc_msgSend(*((id *)a2 + 1), sel_height);
    if (*((_DWORD *)a2 + 22) >= 2u) {
      goto LABEL_27;
    }
    objc_msgSend(*((id *)a2 + 1), sel_depth);
    MTLGetTextureLevelInfoForDeviceWithOptions();

    unint64_t v14 = *((void *)a2 + 4);
    if (v14 <= v11)
    {
      uint64_t v25 = 0;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      *(_OWORD *)long long buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v26 = 136315906;
      size_t v27 = "operator[]";
      __int16 v28 = 1024;
      int v29 = 797;
      __int16 v30 = 2048;
      unint64_t v31 = v11;
      __int16 v32 = 2048;
      unint64_t v33 = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_27;
    }
    uint64_t v15 = *((void *)a2 + 6) + v10;
    unsigned int v16 = *(_DWORD *)(v15 + 16);
    if (v16)
    {
      BOOL v17 = re::TextureBuilderKTX::setMip((uint64_t)this, (id)**this, v11, *(void *)(v15 + 32), v16, v23[0], v23[2], v16, (uint64_t *)v22, 0);
      if (!v17) {
        break;
      }
    }
    ++v11;
    v10 += 40;
    if (v11 >= (unint64_t)re::TextureData::mipmapLevelCount(a2)) {
      goto LABEL_16;
    }
  }
  id v18 = *re::pipelineLogObjects((re *)v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    char v19 = (const char *)*((void *)a2 + 9);
    if (!v19) {
      char v19 = "<no label>";
    }
    size_t v20 = v21;
    if (*((void *)a2 + 8)) {
      size_t v20 = v19;
    }
    *(_DWORD *)long long buf = 136315138;
    *(void *)&uint8_t buf[4] = v20;
    _os_log_error_impl(&dword_233120000, v18, OS_LOG_TYPE_ERROR, "Failed to load texture mip for '%s'", buf, 0xCu);
  }
  *(unsigned char *)a4 &= 0x80u;
  *(void *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 88) = 0;
  *(void *)(a4 + 96) = 0;
}

uint64_t re::anonymous namespace'::getASTCHDRFormatForPixelFormat(int a1)
{
  if ((a1 - 204) > 0x20) {
    return 0;
  }
  else {
    return dword_234407F24[a1 - 204];
  }
}

void re::anonymous namespace'::iterateKtxMips<re::anonymous namespace'::parseKTX(re::mtl::Device const&,void const*,unsigned long,re::KTXHDRHint)::$_0>(_DWORD *a1, uint64_t a2, uint64_t a3, id *a4, int a5, __n128 a6, uint64_t a7, unsigned int a8, uint64_t a9)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  long long v49 = &unk_26E7150B0;
  uint64_t v50 = a2;
  uint64_t v51 = a3;
  size_t v52 = 0;
  uint64_t v9 = 6;
  uint64_t v10 = a8;
  if (a5 != 3) {
    uint64_t v10 = 1;
  }
  if (a5 != 5) {
    uint64_t v9 = v10;
  }
  uint64_t v42 = v9;
  if (a1[14])
  {
    unint64_t v11 = a1;
    uint64_t v12 = 0;
    a6.n128_u64[0] = 67109376;
    __n128 v41 = a6;
    while (1)
    {
      unsigned int __dst = 0;
      if (!v50
        || ((size_t v13 = v52, v14 = v51 - v52, v51 - v52 >= 4) ? (v15 = 4) : (v15 = v51 - v52),
            a1 = memcpy(&__dst, (const void *)(v50 + v52), v15),
            size_t v52 = v15 + v13,
            v14 <= 3))
      {
        long long v35 = *re::pipelineLogObjects((re *)a1);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          return;
        }
        LOWORD(v45[0]) = 0;
        long long v36 = "Unexpected end of file when reading image size from KTX";
        long long v37 = (uint8_t *)v45;
        goto LABEL_60;
      }
        return;
      unint64_t v47 = 0;
      long long v46 = 0u;
      memset(v45, 0, sizeof(v45));
      re::ktxMipInfo(a4, (uint64_t)v45);
      if (DWORD1(v46))
      {
        long long v35 = *re::pipelineLogObjects((re *)a1);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          return;
        }
        *(_WORD *)long long buf = 0;
        long long v36 = "Overflow when computing row block bytes during KTX load";
        goto LABEL_59;
      }
      unsigned int v17 = DWORD2(v46);
      if (HIDWORD(*((void *)&v46 + 1)))
      {
        long long v35 = *re::pipelineLogObjects((re *)a1);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          return;
        }
        *(_WORD *)long long buf = 0;
        long long v36 = "Overflow when computing image block bytes during KTX load";
        goto LABEL_59;
      }
      unsigned int v18 = v47;
      if (HIDWORD(v47))
      {
        long long v35 = *re::pipelineLogObjects((re *)a1);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          return;
        }
        *(_WORD *)long long buf = 0;
        long long v36 = "Overflow when computing image block bytes during KTX load";
        goto LABEL_59;
      }
      unsigned int v19 = __dst;
      if (v11[13] != 6 || v11[12])
      {
        unint64_t v20 = v47;
      }
      else
      {
        if (*((void *)&v46 + 1) == ((__dst + 3) & 0x1FFFFFFFCLL))
        {
          unint64_t v20 = v47;
        }
        else
        {
          int v21 = *re::pipelineLogObjects((re *)a1);
          a1 = (_DWORD *)os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
          if (a1)
          {
            *(_DWORD *)long long buf = v41.n128_u32[0];
            unsigned int v54 = v17;
            __int16 v55 = 1024;
            unsigned int v56 = v19;
            _os_log_impl(&dword_233120000, v21, OS_LOG_TYPE_DEFAULT, "KTX image size field for non-array cubemap is unexpected (expected: %u, got: %u)", buf, 0xEu);
          }
          unsigned int v17 = (v19 + 3) & 0xFFFFFFFC;
          unint64_t v20 = v47;
        }
        v19 *= 6;
      }
      unsigned int v22 = v20 * v42;
      if ((v20 * v42) >> 32) {
        break;
      }
      if (v19 < v22)
      {
        unsigned int v40 = *re::pipelineLogObjects((re *)a1);
        if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
          return;
        }
        *(_DWORD *)long long buf = v41.n128_u32[0];
        unsigned int v54 = v22;
        __int16 v55 = 1024;
        unsigned int v56 = v19;
        long long v36 = "KTX image size field is too small for given pixel format and dimensions (expected: %u, got: %u)";
        long long v37 = buf;
        long long v38 = v40;
        uint32_t v39 = 14;
LABEL_61:
        _os_log_error_impl(&dword_233120000, v38, OS_LOG_TYPE_ERROR, v36, v37, v39);
        return;
      }
      if (v19 > v22)
      {
        unsigned int v23 = *re::pipelineLogObjects((re *)a1);
        a1 = (_DWORD *)os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
        if (a1)
        {
          *(_DWORD *)long long buf = v41.n128_u32[0];
          unsigned int v54 = v22;
          __int16 v55 = 1024;
          unsigned int v56 = v19;
          _os_log_impl(&dword_233120000, v23, OS_LOG_TYPE_DEFAULT, "KTX image size field is larger than expected given pixel format and dimensions (expected: %u, got: %u)", buf, 0xEu);
        }
      }
      if (!v50 || (size_t v24 = v52, v51 - v52 < v19))
      {
        long long v35 = *re::pipelineLogObjects((re *)a1);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
          return;
        }
        *(_WORD *)long long buf = 0;
        long long v36 = "Unexpected end of file when reading image from KTX";
        goto LABEL_59;
      }
      v52 += v19;
      if (*(_DWORD *)a9 == 7) {
        unsigned int v25 = v18;
      }
      else {
        unsigned int v25 = v19;
      }
      if (v25 >= v17)
      {
        BOOL v26 = 0;
        uint64_t v27 = 0;
        uint64_t v28 = v50 + v24;
        unint64_t v29 = v25 / v17;
        uint64_t v30 = v17;
        uint64_t v31 = v29 <= 1 ? 1 : v25 / v17;
        while (1)
        {
          __int16 v32 = objc_msgSend(MEMORY[0x263EFF8F8], "dataWithBytesNoCopy:length:freeWhenDone:", v28, v30, 0, *(_OWORD *)&v41);
          int64_t v33 = +[RETextureLoaderASTCHelper isASTCHDRData:v32 textureType:2 error:0];
          if (v33 == -1) {
            break;
          }
          if (v33 == 1)
          {
            **(unsigned char **)(a9 + 8) = 1;
            size_t v34 = *(int **)(a9 + 16);
            break;
          }

          BOOL v26 = ++v27 >= v29;
          v28 += v30;
          if (v31 == v27) {
            goto LABEL_45;
          }
        }

        if (!v26) {
          return;
        }
      }
LABEL_45:
      if (++v12 >= (unint64_t)v11[14]) {
        return;
      }
    }
    long long v35 = *re::pipelineLogObjects((re *)a1);
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)long long buf = 0;
    long long v36 = "Overflow when computing image size during KTX load";
LABEL_59:
    long long v37 = buf;
LABEL_60:
    long long v38 = v35;
    uint32_t v39 = 2;
    goto LABEL_61;
  }
}

BOOL re::anonymous namespace'::checkAlignment(re::_anonymous_namespace_ *this, unsigned int *a2)
{
  uint64_t v2 = *(unsigned int *)this;
  unint64_t v3 = (v2 + 3) & 0x1FFFFFFFCLL;
  if (v3 == v2) {
    return 1;
  }
  unint64_t v5 = *re::pipelineLogObjects(this);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_233120000, v5, OS_LOG_TYPE_DEFAULT, "KTX image size field was not a multiple of 4, which should not be possible", buf, 2u);
  }
  *(_DWORD *)this = v3;
  if (!HIDWORD(v3)) {
    return 1;
  }
  uint64_t v7 = *re::pipelineLogObjects((re *)v6);
  BOOL result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)uint64_t v9 = 0;
    _os_log_error_impl(&dword_233120000, v7, OS_LOG_TYPE_ERROR, "Overflow when computing aligned image size during KTX load", v9, 2u);
    return 0;
  }
  return result;
}

uint64_t re::TextureBuilderKTX::init(uint64_t a1, id *a2, char a3, uint64_t a4)
{
  *(_DWORD *)(a1 + 8) = re::internal::getFaceOrArrayLength(a2);
  if (**(void **)a1)
  {
    *(unsigned char *)(a1 + 160) = objc_msgSend(*a2, sel_storageMode) == (id)2;
    v16[0] = MEMORY[0x263EF8330];
    v16[1] = 3221225472;
    _OWORD v16[2] = ___ZN2re17TextureBuilderKTX4initERKN2NS9SharedPtrIN3MTL17TextureDescriptorEEEbPKc_block_invoke;
    v16[3] = &__block_descriptor_57_e5_B8__0l;
    char v17 = a3;
    v16[4] = a1;
    v16[5] = a2;
    v16[6] = a4;
    int v8 = _Block_copy(v16);
    uint64_t v9 = v8;
    if (!*(unsigned char *)(a1 + 160))
    {
      uint64_t v14 = (*((uint64_t (**)(void *))v8 + 2))(v8);

      return v14;
    }
    id v10 = objc_msgSend(*a2, sel_mipmapLevelCount);
    if (*(void *)(a1 + 176) < (unint64_t)v10) {
      re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity((void *)(a1 + 168), (unint64_t)v10);
    }
    unint64_t v11 = _Block_copy(v9);
    uint64_t v12 = *(void **)(a1 + 208);
    *(void *)(a1 + 208) = v11;
  }
  else
  {
    id v13 = objc_msgSend(*a2, sel_mipmapLevelCount);
    if (*(void *)(a1 + 24) < (unint64_t)v13) {
      re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity((void *)(a1 + 16), (unint64_t)v13);
    }
  }
  return 1;
}

void re::TextureBuilderKTX::finish(uint64_t a1, uint64_t a2, uint64_t a3, id a4)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    *(void *)&long long buf = a4;
    unsigned int v19 = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicArray<unsigned char>>::DynamicArray((uint64_t)&buf + 8, (uint64_t *)(a2 + 16));
    memset(v34, 0, sizeof(v34));
    re::DynamicString::setCapacity(v34, 0);
    *(unsigned char *)a1 &= 0x80u;
    std::__variant_detail::__alt<1ul,re::CPUTexture>::__alt[abi:nn180100]<re::CPUTexture const&>((void *)(a1 + 8), (uint64_t)&buf);
    *(_DWORD *)(a1 + 88) = 1;
    *(void *)(a1 + 96) = 0;
    re::CPUTexture::~CPUTexture((id *)&buf);
    return;
  }
  if (!*(unsigned char *)(a2 + 160)) {
    goto LABEL_26;
  }
  if (((*(uint64_t (**)(void))(*(void *)(a2 + 208) + 16))() & 1) == 0)
  {
    *(unsigned char *)a1 &= 0x80u;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
    return;
  }
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v6 = *(void *)a2;
  uint64_t v7 = (void *)MEMORY[0x237DBDCF0]();
  re::ImportGraphicsContext::getOrCreateCommandQueue(v6, (uint64_t)&re::internal::KTXTextureUploadQueueName(void)::queueName, (const char *)1, (id *)&buf);
  int v8 = (void *)buf;
  *(void *)&long long buf = 0;
  id v29 = v8;

  re::mtl::CommandQueue::makeCommandBuffer(&v29, &buf);
  uint64_t v9 = (void *)buf;
  *(void *)&long long buf = 0;
  uint64_t v30 = v9;

  if (*(void *)(a2 + 184))
  {
    uint64_t v25 = a1;
    id v10 = 0;
    unint64_t v11 = 0;
    do
    {
      uint64_t v12 = *(void *)(a2 + 200);
      context = (void *)MEMORY[0x237DBDCF0]();
      if (*(_DWORD *)(a2 + 8))
      {
        unint64_t v13 = 0;
        uint64_t v14 = v12 + 56 * v11;
        do
        {
          uint64_t v15 = *(unsigned int *)(v14 + 36);
          *(void *)&long long buf = (v15 * v13);
          *((void *)&buf + 1) = *(unsigned int *)(v14 + 32);
          uint64_t v33 = v15;
          if (!v10)
          {
            re::mtl::CommandBuffer::makeBlitCommandEncoder(&v30, &v27);
            id v10 = (void *)v27;
            *(void *)&long long v27 = 0;
            uint64_t v31 = v10;
          }
          if (*(_DWORD *)(a2 + 144)) {
            std::__throw_bad_variant_access[abi:nn180100]();
          }
          uint64_t v16 = *(void *)(a2 + 64);
          uint64_t v17 = *(void *)(v14 + 48) + v11;
          long long v27 = 0uLL;
          v28[0] = 0;
          re::mtl::BlitCommandEncoder::copyFromBufferToTexture(&v31, (void **)v14, (uint64_t *)&buf, (long long *)(v14 + 8), v16, v13++, v17, &v27);
        }
        while (v13 < *(unsigned int *)(a2 + 8));
      }
      ++v11;
    }
    while (v11 < *(void *)(a2 + 184));
    LOBYTE(v27) = 1;
    a1 = v25;
    if (v10)
    {
      unsigned int v18 = (void *)MEMORY[0x237DBDCF0]();
      [v31 endEncoding];
      re::ObjCObject::operator=(&v31, 0);
      [v30 commit];
      [v30 waitUntilCompleted];
      re::internal::getCommandBufferError(&v30, (uint64_t)&buf);
      re::Result<re::Unit,re::DynamicString>::operator=((uint64_t)&v27, (uint64_t)&buf);
      if (!(_BYTE)buf && *((void *)&buf + 1) && (v33 & 1) != 0) {
        (*(void (**)(void))(**((void **)&buf + 1) + 40))();
      }
    }
  }
  else
  {
    LOBYTE(v27) = 1;
  }
  unint64_t v20 = re::ObjCObject::operator=(&v30, 0);
  int v21 = v27;
  if (!(_BYTE)v27)
  {
    unsigned int v22 = *re::pipelineLogObjects((re *)v20);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      if (v28[0]) {
        size_t v24 = (char *)v28[1];
      }
      else {
        size_t v24 = (char *)v28 + 1;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v24;
    }
    *(unsigned char *)a1 &= 0x80u;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
    if (!(_BYTE)v27 && *((void *)&v27 + 1) && (v28[0] & 1) != 0) {
      (*(void (**)(void))(**((void **)&v27 + 1) + 40))();
    }
  }
  if (v31)
  {
    [v31 endEncoding];
    unsigned int v23 = v31;
  }
  else
  {
    unsigned int v23 = 0;
  }

  if (v21)
  {
LABEL_26:
    *(unsigned char *)a1 = *(unsigned char *)(a2 + 56);
    *(unsigned char *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 88) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>(a1 + 8, a2 + 64);
    *(void *)(a1 + 96) = *(id *)(a2 + 152);
  }
}

re *___ZN2re17TextureBuilderKTX4initERKN2NS9SharedPtrIN3MTL17TextureDescriptorEEEbPKc_block_invoke(uint64_t a1)
{
  v17[1] = *(id *)MEMORY[0x263EF8340];
  uint64_t v2 = *(id ***)(a1 + 32);
  unint64_t v3 = (id *)(v2 + 19);
  if (*(unsigned char *)(a1 + 56)) {
    re::mtl::Device::makeSharedTexture(**(id **)(a1 + 40), *v2, &v12);
  }
  else {
    re::mtl::Device::makeTexture(**(id **)(a1 + 40), *v2, &v12);
  }
  buf[0] = 0;
  *(void *)&v15[4] = v12;
  unsigned int v16 = 0;
  v17[0] = 0;
  *((unsigned char *)v2 + 56) = 0;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)(v2 + 8), (uint64_t)&v15[4]);
  if (v3 != v17)
  {
    id v4 = v17[0];
    v17[0] = 0;
    id v5 = *v3;
    *unint64_t v3 = v4;
  }
  if (v16 != -1) {
    ((void (*)(char *, unsigned char *))*(&__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8nn180100IZNS0_6__dtorINS0_8__traitsIJN2NS9SharedPtrIN3MTL7TextureEEEN2re10CPUTextureEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRSF_EEEDcOSG_DpOT0____fmatrix_1
  }
                                           + v16))(&v13, &v15[4]);
  unsigned int v16 = -1;
  if (v12) {

  }
  isValid = (re *)re::TextureData::isValid((re::TextureData *)(v2 + 7));
  uint64_t v7 = isValid;
  if (isValid)
  {
    int v8 = *(const char **)(a1 + 48);
    if (v8 && *v8) {
      re::TextureData::setLabel((re::TextureData *)(v2 + 7), v8);
    }
  }
  else
  {
    uint64_t v9 = *re::pipelineLogObjects(isValid);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
    {
      uint64_t v11 = *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 136315138;
      *(void *)uint64_t v15 = v11;
      _os_log_fault_impl(&dword_233120000, v9, OS_LOG_TYPE_FAULT, "Failed to create texture '%s' from KTX", buf, 0xCu);
    }
  }
  return v7;
}

id re::TextureData::setLabel(re::TextureData *this, const char *a2)
{
  int v2 = *((_DWORD *)this + 22);
  if (v2 == 1)
  {
    uint64_t v7 = (re::TextureData *)((char *)this + 8);
    return (id)re::CPUTexture::setLabel(v7, a2);
  }
  if (v2)
  {
    uint64_t v7 = (re::CPUTexture *)std::__throw_bad_variant_access[abi:nn180100]();
    return (id)re::CPUTexture::setLabel(v7, a2);
  }
  unint64_t v3 = (void *)*((void *)this + 1);
  if (a2) {
    id v4 = a2;
  }
  else {
    id v4 = "";
  }
  id v5 = objc_msgSend(NSString, sel_stringWithCString_encoding_, v4, 4);
  return objc_msgSend(v3, sel_setLabel_, v5);
}

uint64_t re::CPUTexture::setLabel(re::CPUTexture *this, const char *a2)
{
  re::DynamicString::operator=((re::CPUTexture *)((char *)this + 48), (re::DynamicString *)&v5);
  uint64_t result = v5;
  if (v5)
  {
    if (v6) {
      return (*(uint64_t (**)(void))(*(void *)v5 + 40))();
    }
  }
  return result;
}

void *re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    uint64_t v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        uint64_t result = (void *)re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x38uLL))
        {
          uint64_t v2 = 56 * a2;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 56 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 56, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = 56 * v9;
        uint64_t v11 = v7;
        do
        {
          *uint64_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          long long v12 = *(_OWORD *)(v8 + 8);
          long long v13 = *(_OWORD *)(v8 + 24);
          *(_OWORD *)(v11 + 5) = *(_OWORD *)(v8 + 40);
          *(_OWORD *)(v11 + 3) = v13;
          *(_OWORD *)(v11 + 1) = v12;
          if (*(void *)v8)
          {

            *(void *)uint64_t v8 = 0;
          }
          v8 += 56;
          v11 += 7;
          v10 -= 56;
        }
        while (v10);
        uint64_t v8 = v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

BOOL re::TextureBuilderKTX::setMip(uint64_t a1, id a2, int a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, int a8, uint64_t *a9, uint64_t a10)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  uint64_t v12 = (a10 + a3);
  if (!a2)
  {
    unint64_t v29 = (v12 + 1);
    if (*(void *)(a1 + 32) < v29) {
      re::DynamicArray<re::DynamicArray<re::Matrix4x4<float>>>::resize((void *)(a1 + 16), v29);
    }
    v43[0] = a4;
    v43[1] = a5;
    re::DynamicArray<unsigned char>::DynamicArray((uint64_t)v44, (uint64_t)v43);
    unint64_t v30 = *(void *)(a1 + 32);
    if (v30 > v12)
    {
      re::DynamicArray<re::internal::DeferredUnregister *>::operator=(*(void *)(a1 + 48) + 40 * v12, (uint64_t)v44);
      if (v44[0] && v44[4]) {
        (*(void (**)(void))(*(void *)v44[0] + 40))();
      }
      return 1;
    }
    v44[5] = 0;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v45 = 136315906;
    long long v46 = "operator[]";
    __int16 v47 = 1024;
    int v48 = 789;
    __int16 v49 = 2048;
    uint64_t v50 = v12;
    __int16 v51 = 2048;
    unint64_t v52 = v30;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_34;
  }
  if (!*(unsigned char *)(a1 + 160))
  {
    if (!*(_DWORD *)(a1 + 8)) {
      return 1;
    }
    unsigned int v31 = 0;
    unint64_t v32 = 0;
    uint64_t v34 = *a9;
    uint64_t v33 = a9[1];
    uint64_t v36 = a9[2];
    while (!*(_DWORD *)(a1 + 144))
    {
      id v37 = *(id *)(a1 + 64);
      memset(buf, 0, sizeof(buf));
      *(void *)&long long v54 = 0;
      *((void *)&v54 + 1) = v34;
      *(void *)&long long v55 = v33;
      *((void *)&v55 + 1) = v36;
      objc_msgSend(v37, sel_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage_, buf, v12, v32, a4 + v31, a6, a7);
      if (v37) {

      }
      ++v32;
      v31 += a7;
      if (v32 >= *(unsigned int *)(a1 + 8)) {
        return 1;
      }
    }
LABEL_34:
    std::__throw_bad_variant_access[abi:nn180100]();
  }
  id v15 = objc_msgSend(a2, sel_newBufferWithBytes_length_options_, a4, a5, 0);
  if (v15)
  {
    unsigned int v16 = v15;
    objc_msgSend(v15, sel_setLabel_, @"createTextureWithKTXData staging buffer");
    uint64_t v17 = *a9;
    uint64_t v18 = a9[1];
    uint64_t v19 = a9[2];
    id v20 = v16;
    unint64_t v21 = *(void *)(a1 + 176);
    unint64_t v22 = *(void *)(a1 + 184);
    if (v22 >= v21)
    {
      unint64_t v23 = v22 + 1;
      if (v21 < v22 + 1)
      {
        size_t v24 = (_anonymous_namespace_ *)(a1 + 168);
        if (*(void *)(a1 + 168))
        {
          uint64_t v25 = 2 * v21;
          BOOL v26 = v21 == 0;
          unint64_t v27 = 8;
          if (!v26) {
            unint64_t v27 = v25;
          }
          if (v27 <= v23) {
            unint64_t v28 = v23;
          }
          else {
            unint64_t v28 = v27;
          }
          re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity(v24, v28);
        }
        else
        {
          re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity((void *)(a1 + 168), v23);
          ++*(_DWORD *)(a1 + 192);
        }
      }
      unint64_t v22 = *(void *)(a1 + 184);
    }
    uint64_t v40 = *(void *)(a1 + 200) + 56 * v22;
    *(void *)uint64_t v40 = v20;
    *(void *)(v40 + 8) = v17;
    *(void *)(v40 + 16) = v18;
    *(void *)(v40 + 24) = v19;
    *(_DWORD *)(v40 + 32) = a6;
    *(_DWORD *)(v40 + 36) = a7;
    *(_DWORD *)(v40 + 40) = a8;
    *(void *)(v40 + 48) = a10;
    ++*(void *)(a1 + 184);
    ++*(_DWORD *)(a1 + 192);

    return 1;
  }
  long long v38 = *re::pipelineLogObjects(0);
  BOOL result = os_log_type_enabled(v38, OS_LOG_TYPE_FAULT);
  if (result)
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_233120000, v38, OS_LOG_TYPE_FAULT, "Failed to create staging buffer for KTX data", buf, 2u);
    return 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    uint64_t v3 = *(id **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 56 * v4;
        do
        {
          if (*v3)
          {

            *uint64_t v3 = 0;
          }
          v3 += 7;
          v5 -= 56;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        uint64_t v3 = *(id **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, id *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::internal::TextureProviderProperties::~TextureProviderProperties(re::internal::TextureProviderProperties *this)
{
  uint64_t v2 = *(const void **)this;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 1);
  if (v4)
  {

    *((void *)this + 1) = 0;
  }
}

re::internal::TextureProviderProperties *re::internal::TextureProviderProperties::TextureProviderProperties(re::internal::TextureProviderProperties *this, const re::internal::TextureProviderProperties *a2)
{
  uint64_t v4 = (void *)*((void *)a2 + 1);
  *(void *)this = *(void *)a2;
  id v5 = v4;
  uint64_t v6 = (const void *)*((void *)a2 + 2);
  *((void *)this + 1) = v5;
  *((void *)this + 2) = v6;
  if (*(void *)this)
  {
    CFRetain(*(CFTypeRef *)this);
    uint64_t v6 = (const void *)*((void *)this + 2);
  }
  if (v6) {
    CFRetain(v6);
  }
  return this;
}

uint64_t re::internal::TextureProviderProperties::operator=(uint64_t a1, void **a2)
{
  if ((void **)a1 != a2)
  {
    NS::SharedPtr<MTL::Texture>::operator=((void **)(a1 + 8), a2 + 1);
    uint64_t v4 = a2[2];
    *(void *)(a1 + 16) = v4;
    id v5 = *a2;
    if (*(void **)a1 != *a2)
    {
      if (*(void *)a1)
      {
        CFRelease(*(CFTypeRef *)a1);
        id v5 = *a2;
      }
      *(void *)a1 = v5;
      *a2 = 0;
      uint64_t v4 = *(const void **)(a1 + 16);
    }
    uint64_t v6 = a2[2];
    if (v4 != v6)
    {
      if (v4)
      {
        CFRelease(v4);
        uint64_t v6 = a2[2];
      }
      *(void *)(a1 + 16) = v6;
      a2[2] = 0;
    }
  }
  return a1;
}

uint64_t re::TextureProvider::TextureProvider(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26E6E09A0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v4 = (void *)(a1 + 8);
  re::DynamicString::setCapacity(v4, 0);
  *(void *)(a1 + 40) = *(id *)(a2 + 40);
  long long v6 = *(_OWORD *)(a2 + 64);
  long long v5 = *(_OWORD *)(a2 + 80);
  long long v7 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 92) = *(_OWORD *)(a2 + 92);
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 48) = v7;
  *(void *)(a1 + 112) = *(id *)(a2 + 112);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(void *)(a1 + 136) = _Block_copy(*(const void **)(a2 + 136));
  *(void *)(a1 + 144) = *(id *)(a2 + 144);
  *(void *)(a1 + 152) = *(id *)(a2 + 152);
  __int16 v8 = *(_WORD *)(a2 + 160);
  *(unsigned char *)(a1 + 162) = *(unsigned char *)(a2 + 162);
  *(_WORD *)(a1 + 160) = v8;
  int v9 = *(unsigned __int8 *)(a2 + 163);
  *(unsigned char *)(a1 + 163) = v9;
  if (v9) {
    *(unsigned char *)(a1 + 164) = *(unsigned char *)(a2 + 164);
  }
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  long long v11 = *(_OWORD *)(a2 + 176);
  uint64_t v10 = a2 + 176;
  *(_OWORD *)(a1 + 176) = v11;
  *(void *)(a1 + 192) = *(void *)(v10 + 16);
  *(void *)uint64_t v10 = 0;
  *(void *)(v10 + 8) = 0;
  *(void *)(v10 + 16) = 0;
  *(unsigned char *)(a1 + 200) = *(unsigned char *)(v10 + 24);

  *(void *)(v10 - 136) = 0;
  uint64_t v12 = *(void **)(v10 - 40);
  *(void *)(v10 - 40) = 0;

  v14[0] = 0;
  v14[1] = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  _OWORD v14[2] = 0;
  re::internal::TextureProviderProperties::operator=(v10, v14);
  re::internal::TextureProviderProperties::~TextureProviderProperties((re::internal::TextureProviderProperties *)v14);
  *(unsigned char *)(v10 + 24) = 0;
  return a1;
}

re::TextureProvider *re::TextureProvider::TextureProvider(re::TextureProvider *this, const re::TextureProvider *a2)
{
  *(void *)this = &unk_26E6E09A0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  uint64_t v4 = (void *)((char *)this + 8);
  re::DynamicString::setCapacity(v4, 0);
  *((void *)this + 5) = *((id *)a2 + 5);
  long long v6 = *((_OWORD *)a2 + 4);
  long long v5 = *((_OWORD *)a2 + 5);
  long long v7 = *((_OWORD *)a2 + 3);
  *(_OWORD *)((char *)this + 92) = *(_OWORD *)((char *)a2 + 92);
  *((_OWORD *)this + 4) = v6;
  *((_OWORD *)this + 5) = v5;
  *((_OWORD *)this + 3) = v7;
  *((void *)this + 14) = *((id *)a2 + 14);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)a2 + 120);
  *((void *)this + 17) = 0;
  *((void *)this + 18) = *((id *)a2 + 18);
  *((void *)this + 19) = *((id *)a2 + 19);
  __int16 v8 = *((_WORD *)a2 + 80);
  *((unsigned char *)this + 162) = *((unsigned char *)a2 + 162);
  *((_WORD *)this + 80) = v8;
  int v9 = *((unsigned __int8 *)a2 + 163);
  *((unsigned char *)this + 163) = v9;
  if (v9) {
    *((unsigned char *)this + 164) = *((unsigned char *)a2 + 164);
  }
  *((void *)this + 21) = *((void *)a2 + 21);
  re::internal::TextureProviderProperties::TextureProviderProperties((re::TextureProvider *)((char *)this + 176), (const re::TextureProvider *)((char *)a2 + 176));
  *((unsigned char *)this + 200) = *((unsigned char *)a2 + 200);
  return this;
}

re::TextureProvider *re::TextureProvider::TextureProvider(re::TextureProvider *this, id *a2, int a3)
{
  *(void *)this = &unk_26E6E09A0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  long long v6 = (void *)((char *)this + 8);
  re::DynamicString::setCapacity(v6, 0);
  id v7 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = v7;
  *((_DWORD *)this + 16) = 1;
  *((_DWORD *)this + 22) = 0;
  *((unsigned char *)this + 92) = 0;
  *((_DWORD *)this + 24) = 0;
  *((unsigned char *)this + 100) = 0;
  *(void *)((char *)this + 76) = 0;
  *(void *)((char *)this + 68) = 0;
  *((unsigned char *)this + 84) = 0;
  *((_DWORD *)this + 26) = 6;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((void *)this + 18) = *a2;
  *((void *)this + 19) = a2[1];
  __int16 v8 = *((_WORD *)a2 + 8);
  *((unsigned char *)this + 162) = *((unsigned char *)a2 + 18);
  *((_WORD *)this + 80) = v8;
  int v9 = *((unsigned __int8 *)a2 + 19);
  *((unsigned char *)this + 163) = v9;
  if (v9) {
    *((unsigned char *)this + 164) = *((unsigned char *)a2 + 20);
  }
  *((void *)this + 21) = a2[3];
  *((void *)this + 22) = 0;
  *((void *)this + 23) = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  *((void *)this + 24) = 0;
  *((unsigned char *)this + 200) = 1;
  objc_msgSend(*((id *)this + 5), sel_setResourceOptions_, 32);
  *((unsigned char *)this + 100) = a3;
  uint64_t v10 = (void *)*((void *)this + 18);
  if (v10)
  {
    if (a3) {
      char v11 = [v10 supportsSharedTextureHandles];
    }
    else {
      char v11 = 0;
    }
    *((unsigned char *)this + 100) = v11;
  }
  return this;
}

uint64_t re::TextureProvider::canHaveAlpha(re::TextureProvider *this, const re::TextureProvider *a2)
{
  re::TextureProvider::lazyFetchProperties((id *)this, a2);
  uint64_t v3 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 22), (const void *)*MEMORY[0x263F0F458]);
  uint64_t v4 = [v3 BOOLValue];

  return v4;
}

void re::TextureProvider::lazyFetchProperties(id *this, const re::TextureProvider *a2)
{
  if (*((unsigned char *)this + 200))
  {
    re::internal::createTextureProviderProperties(this, a2, (uint64_t)v3);
    re::internal::TextureProviderProperties::operator=((uint64_t)(this + 22), v3);
    re::internal::TextureProviderProperties::~TextureProviderProperties((re::internal::TextureProviderProperties *)v3);
    *((unsigned char *)this + 200) = 0;
  }
}

void re::TextureProvider::setOptions(uint64_t a1, long long *a2)
{
  long long v4 = a2[1];
  long long v6 = *a2;
  long long v7 = v4;
  *(_OWORD *)__int16 v8 = a2[2];
  *(_OWORD *)&v8[12] = *(long long *)((char *)a2 + 44);
  id v9 = *((id *)a2 + 8);
  long long v10 = *(long long *)((char *)a2 + 72);
  v8[20] = *(unsigned char *)(a1 + 100);
  if (!re::TextureFromImageOptions::operator==(a1 + 48, (uint64_t)&v6))
  {
    long long v5 = v7;
    *(_OWORD *)(a1 + 48) = v6;
    *(_OWORD *)(a1 + 64) = v5;
    *(_OWORD *)(a1 + 80) = *(_OWORD *)v8;
    *(_OWORD *)(a1 + 92) = *(_OWORD *)&v8[12];
    re::ObjCObject::operator=((id *)(a1 + 112), &v9);
    *(_OWORD *)(a1 + 120) = v10;
    *(unsigned char *)(a1 + 200) = 1;
  }
}

void **re::TextureProvider::setTemplateDescriptor(uint64_t a1, void **a2)
{
  long long v4 = *(void **)(a1 + 40);
  uint64_t result = (void **)(a1 + 40);
  if (v4 != *a2)
  {
    NS::SharedPtr<MTL::Texture>::operator=(result, a2);
    uint64_t result = (void **)objc_msgSend(*(id *)(a1 + 40), sel_setResourceOptions_, 32);
    *(unsigned char *)(a1 + 200) = 1;
  }
  return result;
}

void re::CGImageSourceTextureProvider::~CGImageSourceTextureProvider(re::CGImageSourceTextureProvider *this)
{
  *(void *)this = &unk_26E715128;
  uint64_t v2 = (const void *)*((void *)this + 26);
  if (v2) {
    CFRelease(v2);
  }
  re::TextureProvider::~TextureProvider((id *)this);
}

{
  uint64_t vars8;

  re::CGImageSourceTextureProvider::~CGImageSourceTextureProvider(this);
  JUMPOUT(0x237DBCBD0);
}

const void *re::CGImageSourceTextureProvider::tryCreateImageSource(re::CGImageSourceTextureProvider *this, const __CFDictionary *a2)
{
  uint64_t result = (const void *)*((void *)this + 26);
  if (result)
  {
    CFRetain(result);
    return (const void *)*((void *)this + 26);
  }
  return result;
}

uint64_t re::CGImageSourceTextureProvider::tryCreateOrDetachImageSource(re::CGImageSourceTextureProvider *this, const __CFDictionary *a2)
{
  uint64_t v2 = *((void *)this + 26);
  *((void *)this + 26) = 0;
  return v2;
}

void re::CGImageTextureProvider::~CGImageTextureProvider(CGImageRef *this)
{
  *this = (CGImageRef)&unk_26E715190;
  CGImageRelease(this[26]);
  re::TextureProvider::~TextureProvider((id *)this);
}

{
  uint64_t vars8;

  *this = (CGImageRef)&unk_26E715190;
  CGImageRelease(this[26]);
  re::TextureProvider::~TextureProvider((id *)this);
  JUMPOUT(0x237DBCBD0);
}

re::TextureProvider *re::CGImageArrayTextureProvider::CGImageArrayTextureProvider(re::TextureProvider *a1, id *a2, int a3, uint64_t *a4, int a5)
{
  __int16 v8 = re::TextureProvider::TextureProvider(a1, a2, a3);
  *(void *)__int16 v8 = &unk_26E7151F8;
  *((_DWORD *)v8 + 51) = a5;
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v8 + 208, a4);
  uint64_t v9 = *((void *)a1 + 28);
  if (v9)
  {
    long long v10 = (CGImage **)*((void *)a1 + 30);
    uint64_t v11 = 8 * v9;
    do
    {
      uint64_t v12 = *v10++;
      CGImageRetain(v12);
      v11 -= 8;
    }
    while (v11);
  }
  return a1;
}

void re::CGImageArrayTextureProvider::~CGImageArrayTextureProvider(re::CGImageArrayTextureProvider *this)
{
  *(void *)this = &unk_26E7151F8;
  uint64_t v2 = *((void *)this + 28);
  if (v2)
  {
    uint64_t v3 = (CGImage **)*((void *)this + 30);
    uint64_t v4 = 8 * v2;
    do
    {
      long long v5 = *v3++;
      CGImageRelease(v5);
      v4 -= 8;
    }
    while (v4);
  }
  uint64_t v6 = *((void *)this + 26);
  if (v6)
  {
    if (*((void *)this + 30)) {
      (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
    }
    *((void *)this + 30) = 0;
    *((void *)this + 27) = 0;
    *((void *)this + 28) = 0;
    *((void *)this + 26) = 0;
    ++*((_DWORD *)this + 58);
  }
  re::TextureProvider::~TextureProvider((id *)this);
}

{
  uint64_t vars8;

  re::CGImageArrayTextureProvider::~CGImageArrayTextureProvider(this);
  JUMPOUT(0x237DBCBD0);
}

re::TextureProvider *re::ResourceTextureProvider::ResourceTextureProvider(re::TextureProvider *a1, id *a2, int a3, const re::DynamicString *a4)
{
  uint64_t v6 = re::TextureProvider::TextureProvider(a1, a2, a3);
  *(void *)uint64_t v6 = &unk_26E6E0A08;
  long long v7 = (re::TextureProvider *)((char *)v6 + 8);
  re::DynamicString::DynamicString((re::TextureProvider *)((char *)v6 + 208), a4);
  re::DynamicString::operator=(v7, a4);
  return a1;
}

re::TextureProvider *re::USKTextureProvider::USKTextureProvider(re::TextureProvider *a1, id *a2, int a3, const re::DynamicString *a4)
{
  re::DynamicString::DynamicString((re::DynamicString *)&v8, a4);
  re::ResourceTextureProvider::ResourceTextureProvider(a1, a2, a3, (const re::DynamicString *)&v8);
  if (v8 && (v9 & 1) != 0) {
    (*(void (**)(void))(*(void *)v8 + 40))();
  }
  *(void *)a1 = &unk_26E715260;
  return a1;
}

id re::USKTextureProvider::tryCreateRawImageData(re::USKTextureProvider *this)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 216)) {
    uint64_t v2 = (re::usdkit::Resource *)*((void *)this + 28);
  }
  else {
    uint64_t v2 = (re::USKTextureProvider *)((char *)this + 217);
  }
  re::usdkit::Resource::makeWithPath(v2, &v9);
  re::usdkit::Resource::makeMappedData(&v9, &v8);
  id v4 = v8;
  if (v8)
  {
    CFRetain(v8);
  }
  else
  {
    long long v5 = *re::pipelineLogObjects(v3);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      if (*((unsigned char *)this + 216)) {
        long long v7 = (char *)*((void *)this + 28);
      }
      else {
        long long v7 = (char *)this + 217;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v11 = v7;
      _os_log_error_impl(&dword_233120000, v5, OS_LOG_TYPE_ERROR, "Failed to open texture resource '%s'", buf, 0xCu);
    }
  }

  return v4;
}

CGImageSourceRef re::USKTextureProvider::tryCreateImageSource(re::USKTextureProvider *this, const __CFDictionary *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  CFDataRef v4 = (const __CFData *)(*(uint64_t (**)(re::USKTextureProvider *))(*(void *)this + 40))(this);
  CFDataRef v12 = v4;
  if (!v4) {
    return 0;
  }
  CFDataRef v6 = v4;
  if (re::internal::isBasisTextureData(&v12, v5))
  {
    CFRelease(v6);
    return 0;
  }
  CGImageSourceRef v7 = CGImageSourceCreateWithData(v6, a2);
  CFRelease(v6);
  if (!v7)
  {
    id v9 = *re::pipelineLogObjects(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (*((unsigned char *)this + 216)) {
        uint64_t v11 = (char *)*((void *)this + 28);
      }
      else {
        uint64_t v11 = (char *)this + 217;
      }
      *(_DWORD *)long long buf = 136315138;
      uint64_t v14 = v11;
      _os_log_error_impl(&dword_233120000, v9, OS_LOG_TYPE_ERROR, "Failed to create CGImageSource for texture resource '%s'", buf, 0xCu);
    }
    return 0;
  }
  return v7;
}

void *re::USKTextureProvider::tryReadHeaderBytes@<X0>(re::USKTextureProvider *this@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void v12[4] = *MEMORY[0x263EF8340];
  uint64_t v11 = 0;
  id v8 = operator new(0x28uLL);
  *id v8 = &unk_26E715428;
  v8[1] = this;
  v8[2] = &v11;
  v8[3] = a2;
  void v8[4] = a3;
  v12[3] = v8;
  re::runInLocalAutoreleasePool((uint64_t)v12);
  uint64_t result = std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v12);
  uint64_t v10 = v11;
  *(unsigned char *)a4 = 1;
  *(void *)(a4 + 8) = v10;
  return result;
}

re::FileTextureProvider *re::FileTextureProvider::FileTextureProvider(re::FileTextureProvider *this, id *a2, int a3, const char *a4)
{
  re::ResourceTextureProvider::ResourceTextureProvider(this, a2, a3, (const re::DynamicString *)&v9);
  if (v9 && (v10 & 1) != 0) {
    (*(void (**)(void))(*(void *)v9 + 40))();
  }
  *(void *)this = &unk_26E7152C8;
  return this;
}

void *re::FileTextureProvider::tryCreateRawImageData(re::FileTextureProvider *this)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 216)) {
    uint64_t v2 = (char *)*((void *)this + 28);
  }
  else {
    uint64_t v2 = (char *)this + 217;
  }
  uint64_t v3 = [NSURL fileURLWithFileSystemRepresentation:v2 isDirectory:0 relativeToURL:0];
  id v10 = 0;
  CFDataRef v4 = [MEMORY[0x263EFF8F8] dataWithContentsOfURL:v3 options:1 error:&v10];
  long long v5 = (re *)v10;
  CFDataRef v6 = v5;
  if (v4)
  {
    CFRetain(v4);
  }
  else
  {
    CGImageSourceRef v7 = *re::pipelineLogObjects(v5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      if (*((unsigned char *)this + 216)) {
        uint64_t v9 = (char *)*((void *)this + 28);
      }
      else {
        uint64_t v9 = (char *)this + 217;
      }
      *(_DWORD *)long long buf = 136315394;
      CFDataRef v12 = v9;
      __int16 v13 = 2112;
      uint64_t v14 = v6;
      _os_log_error_impl(&dword_233120000, v7, OS_LOG_TYPE_ERROR, "Failed to create texture from path: %s: %@", buf, 0x16u);
    }
  }

  return v4;
}

uint64_t re::FileTextureProvider::tryCreateImageSource(re::FileTextureProvider *this, const __CFDictionary *a2)
{
  v7[4] = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  CFDataRef v4 = operator new(0x20uLL);
  *CFDataRef v4 = &unk_26E7154A8;
  v4[1] = this;
  v4[2] = a2;
  v4[3] = &v6;
  void v7[3] = v4;
  re::runInLocalAutoreleasePool((uint64_t)v7);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v7);
  return v6;
}

uint64_t re::FileTextureProvider::tryReadHeaderBytes@<X0>(re::FileTextureProvider *this@<X0>, void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  if (*((unsigned char *)this + 216)) {
    CGImageSourceRef v7 = (re::FileStreamReader *)*((void *)this + 28);
  }
  else {
    CGImageSourceRef v7 = (re::FileTextureProvider *)((char *)this + 217);
  }
  re::FileStreamReader::open(v7, (uint64_t)v17);
  if (v17[0])
  {
    size_t v8 = fread(a2, 1uLL, a3, __stream);
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = v8;
  }
  else
  {
    if (v19) {
      uint64_t v9 = *(unsigned char **)&v20[7];
    }
    else {
      uint64_t v9 = v20;
    }
    re::DynamicString::format((re::DynamicString *)"Failed to open image file: %s", (re::DynamicString *)&v14, v9);
    long long v10 = v14;
    uint64_t v11 = v15;
    uint64_t v12 = v16;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v10;
    *(void *)(a4 + 24) = v11;
    *(void *)(a4 + 32) = v12;
  }
  return re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v17);
}

uint64_t re::DataTextureProvider::DataTextureProvider(uint64_t a1, uint64_t a2)
{
  *(void *)re::TextureProvider::TextureProvider(a1, a2) = &unk_26E715330;
  CFDataRef v4 = *(const void **)(a2 + 216);
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  *(void *)(a1 + 216) = _Block_copy(v4);
  long long v5 = *(void **)(a2 + 216);
  *(void *)(a2 + 208) = 0;
  *(void *)(a2 + 216) = 0;

  return a1;
}

uint64_t re::DataTextureProvider::DataTextureProvider(uint64_t a1, id *a2, int a3, void *a4, void *a5)
{
  id v9 = a5;
  re::TextureProvider::TextureProvider((re::TextureProvider *)a1, a2, a3);
  *(void *)a1 = &unk_26E715330;
  *(void *)(a1 + 208) = *a4;
  long long v10 = _Block_copy(v9);

  *(void *)(a1 + 216) = v10;
  CFRetain(*(CFTypeRef *)(a1 + 208));
  return a1;
}

void re::DataTextureProvider::~DataTextureProvider(re::DataTextureProvider *this)
{
  *(void *)this = &unk_26E715330;
  uint64_t v2 = (const void *)*((void *)this + 26);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 26) = 0;
  }

  re::TextureProvider::~TextureProvider((id *)this);
}

{
  uint64_t vars8;

  re::DataTextureProvider::~DataTextureProvider(this);
  JUMPOUT(0x237DBCBD0);
}

const void *re::DataTextureProvider::tryCreateRawImageData(re::DataTextureProvider *this)
{
  uint64_t result = (const void *)*((void *)this + 26);
  if (result)
  {
    CFRetain(result);
    return (const void *)*((void *)this + 26);
  }
  return result;
}

uint64_t re::DataTextureProvider::tryCreateOrDetachRawImageData(re::DataTextureProvider *this)
{
  uint64_t v1 = *((void *)this + 26);
  *((void *)this + 26) = 0;
  return v1;
}

const __CFData *re::DataTextureProvider::tryCreateImageSource(re::DataTextureProvider *this, const __CFDictionary *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  CFDataRef result = (const __CFData *)*((void *)this + 26);
  if (result)
  {
    CFDataRef result = CGImageSourceCreateWithData(result, a2);
    if (!result)
    {
      CFDataRef v4 = *re::pipelineLogObjects(0);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if (*((unsigned char *)this + 16)) {
          long long v5 = (char *)*((void *)this + 3);
        }
        else {
          long long v5 = (char *)this + 17;
        }
        int v6 = 136315138;
        CGImageSourceRef v7 = v5;
        _os_log_error_impl(&dword_233120000, v4, OS_LOG_TYPE_ERROR, "Failed to create CGImageSource for texture data '%s'", (uint8_t *)&v6, 0xCu);
      }
      return 0;
    }
  }
  return result;
}

uint64_t re::DataTextureProvider::tryCreateOrDetachImageSource(re::DataTextureProvider *this, const __CFDictionary *a2)
{
  uint64_t v3 = (*(uint64_t (**)(re::DataTextureProvider *, const __CFDictionary *))(*(void *)this + 24))(this, a2);
  CFDataRef v4 = (const void *)*((void *)this + 26);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 26) = 0;
  }
  return v3;
}

void *re::DataTextureProvider::tryReadHeaderBytes@<X0>(re::DataTextureProvider *this@<X0>, void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  CFDataRef v7 = (const __CFData *)*((void *)this + 26);
  if (!v7)
  {
    uint64_t v9 = v17;
    char v10 = v18;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v11 = v19;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v12 = v10 & 1;
    if (v9) {
      BOOL v13 = v12 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (!v13)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 40))(v9, v11);
      if (v17)
      {
        if (v18) {
          (*(void (**)(void))(*(void *)v17 + 40))();
        }
      }
    }
    CFDataRef v7 = (const __CFData *)*((void *)this + 26);
  }
  unint64_t Length = CFDataGetLength(v7);
  if (Length < a3) {
    a3 = Length;
  }
  BytePtr = CFDataGetBytePtr(v7);
  CFDataRef result = memcpy(a2, BytePtr, a3);
  *(unsigned char *)a4 = 1;
  *(void *)(a4 + 8) = a3;
  return result;
}

uint64_t re::CGImageTextureProvider::tryGetImage(re::CGImageTextureProvider *this)
{
  return *((void *)this + 26);
}

uint64_t re::CGImageTextureProvider::tryCreateOrDetachImage(re::CGImageTextureProvider *this)
{
  uint64_t v1 = *((void *)this + 26);
  *((void *)this + 26) = 0;
  return v1;
}

uint64_t re::CGImageArrayTextureProvider::tryGetImageArray@<X0>(re::CGImageArrayTextureProvider *this@<X0>, unsigned char *a2@<X8>)
{
  *a2 = 1;
  return re::DynamicArray<char const*>::DynamicArray((uint64_t)(a2 + 8), (uint64_t *)this + 26);
}

uint64_t re::CGImageArrayTextureProvider::tryGetTextureTypeForImageArray@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 204);
  return this;
}

void re::USKTextureProvider::~USKTextureProvider(id *this)
{
  *this = &unk_26E6E0A08;
  re::DynamicString::deinit((re::DynamicString *)(this + 26));
  re::TextureProvider::~TextureProvider(this);
}

{
  uint64_t vars8;

  *this = &unk_26E6E0A08;
  re::DynamicString::deinit((re::DynamicString *)(this + 26));
  re::TextureProvider::~TextureProvider(this);
  JUMPOUT(0x237DBCBD0);
}

void re::FileTextureProvider::~FileTextureProvider(id *this)
{
  *this = &unk_26E6E0A08;
  re::DynamicString::deinit((re::DynamicString *)(this + 26));
  re::TextureProvider::~TextureProvider(this);
}

{
  uint64_t vars8;

  *this = &unk_26E6E0A08;
  re::DynamicString::deinit((re::DynamicString *)(this + 26));
  re::TextureProvider::~TextureProvider(this);
  JUMPOUT(0x237DBCBD0);
}

void std::__function::__func<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0,std::allocator<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0,std::allocator<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_26E715428;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0,std::allocator<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E715428;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0,std::allocator<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  CFDataRef v2 = (const __CFData *)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  if (v2)
  {
    CFDataRef v3 = v2;
    CFDataRef v4 = *(void **)(a1 + 24);
    size_t v5 = *(void *)(a1 + 32);
    unint64_t Length = CFDataGetLength(v2);
    if (Length < v5) {
      size_t v5 = Length;
    }
    BytePtr = CFDataGetBytePtr(v3);
    memcpy(v4, BytePtr, v5);
    **(void **)(a1 + 16) = v5;
    CFRelease(v3);
  }
}

uint64_t std::__function::__func<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0,std::allocator<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0,std::allocator<re::USKTextureProvider::tryReadHeaderBytes(void *,unsigned long)::$_0>,void ()(void)>::target_type()
{
}

void std::__function::__func<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0,std::allocator<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0,std::allocator<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  CFDataRef v2 = (char *)operator new(0x20uLL);
  *(void *)CFDataRef v2 = &unk_26E7154A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0,std::allocator<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E7154A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0,std::allocator<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v2 + 216)) {
    uint64_t v3 = *(void *)(v2 + 224);
  }
  else {
    uint64_t v3 = v2 + 217;
  }
  CFURLRef v4 = [NSURL fileURLWithFileSystemRepresentation:v3 isDirectory:0 relativeToURL:0];
  size_t v5 = CGImageSourceCreateWithURL(v4, *(CFDictionaryRef *)(a1 + 16));
  **(void **)(a1 + 24) = v5;
  if (!**(void **)(a1 + 24))
  {
    int v6 = *re::pipelineLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      if (*(unsigned char *)(v2 + 216)) {
        uint64_t v7 = *(void *)(v2 + 224);
      }
      else {
        uint64_t v7 = v2 + 217;
      }
      int v8 = 136315138;
      uint64_t v9 = v7;
      _os_log_error_impl(&dword_233120000, v6, OS_LOG_TYPE_ERROR, "Failed to create CGImageSource for texture resource '%s'", (uint8_t *)&v8, 0xCu);
    }
  }
}

uint64_t std::__function::__func<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0,std::allocator<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0,std::allocator<re::FileTextureProvider::tryCreateImageSource(__CFDictionary const*)::$_0>,void ()(void)>::target_type()
{
}

double re::internal::createGeomMeshFromUSKNode@<D0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, uint64_t a6@<X8>)
{
  int v19 = 0;
  memset(v18, 0, sizeof(v18));
  uint64_t v20 = 0x7FFFFFFFLL;
  *(_OWORD *)uint64_t v12 = 0uLL;
  re::makeGeomModelDescriptorFromUSKNode(a1, a2, (uint64_t)v18, a3, a4, a5, (uint64_t)v12, 0, (uint64_t)v15);
  if (v15[0])
  {
    re::makeGeomMeshFromModelDescriptor((re *)&v16, (unint64_t)v12);
    if (v12[0])
    {
      re::GeomMesh::GeomMesh((uint64_t)&v8, (uint64_t)&v12[8]);
      *(unsigned char *)a6 = 1;
      re::GeomMesh::GeomMesh(a6 + 8, (uint64_t)&v8);
      re::GeomMesh::~GeomMesh((re::GeomMesh *)&v8);
    }
    else
    {
      long long v8 = *(_OWORD *)&v12[8];
      re::DynamicString::DynamicString((re::DynamicString *)&v9, (const re::DynamicString *)&v13);
      *(unsigned char *)a6 = 0;
      *(_OWORD *)(a6 + 8) = v8;
      *(void *)(a6 + 24) = v9;
      *(void *)(a6 + 48) = v11;
      *(_OWORD *)(a6 + 32) = v10;
    }
    re::Result<re::GeomMeshWithNGons,re::DetailedError>::~Result((uint64_t)v12);
  }
  else
  {
    *(_OWORD *)uint64_t v12 = v16;
    re::DynamicString::DynamicString((re::DynamicString *)&v12[16], (const re::DynamicString *)&v17);
    *(unsigned char *)a6 = 0;
    *(_OWORD *)(a6 + 8) = *(_OWORD *)v12;
    *(void *)(a6 + 24) = *(void *)&v12[16];
    *(void *)(a6 + 48) = v14;
    *(_OWORD *)(a6 + 32) = v13;
  }
  re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)v15);
  return re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)v18);
}

uint64_t re::Result<re::GeomMeshWithNGons,re::DetailedError>::~Result(uint64_t a1)
{
  if (!*(unsigned char *)a1)
  {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
    return a1;
  }
  double v3 = re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::deinit(a1 + 832);
  int v4 = *(unsigned __int8 *)(a1 + 764);
  if (v4 == 2)
  {
    re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(a1 + 768);
    goto LABEL_9;
  }
  if (v4 == 1)
  {
    re::DynamicArray<unsigned long>::deinit(a1 + 768);
    goto LABEL_9;
  }
  if (!*(unsigned char *)(a1 + 764))
  {
    *(_DWORD *)(a1 + 768) = 0;
LABEL_9:
    re::GeomMesh::~GeomMesh((re::GeomMesh *)(a1 + 8));
    return a1;
  }
  re::internal::assertLog((re::internal *)4, v2, v3, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

double re::HashBrown<unsigned int,re::GeomMeshWithNGons::NGonToTriangleInfo,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::deinit(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 16);
      if (v3)
      {
        uint64_t v4 = 96 * v3;
        size_t v5 = (uint64_t *)(v2 + 32);
        do
        {
          re::DynamicArray<unsigned long>::deinit((uint64_t)(v5 + 3));
          re::FixedArray<CoreIKTransform>::deinit(v5);
          re::FixedArray<CoreIKTransform>::deinit(v5 - 3);
          v5 += 12;
          v4 -= 96;
        }
        while (v4);
      }
      *(void *)(a1 + 8) = 0;
    }
    if (*(void *)a1)
    {
      (*(void (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56));
      *(void *)a1 = 0;
    }
    double result = 0.0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

unsigned char *re::Result<re::GeomModel,re::DetailedError>::~Result(unsigned char *a1)
{
  if (*a1)
  {
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)(a1 + 216));
    if (a1[168]) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)(a1 + 176));
    }
    uint64_t v2 = (re::DynamicString *)(a1 + 8);
    if (a1[120]) {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)(a1 + 128));
    }
    re::DynamicArray<unsigned long>::deinit((uint64_t)(a1 + 80));
    re::DynamicArray<re::GeomMesh>::deinit((uint64_t)(a1 + 40));
  }
  else
  {
    uint64_t v2 = (re::DynamicString *)(a1 + 24);
  }
  re::DynamicString::deinit(v2);
  return a1;
}

uint64_t re::types::Ok<re::GeomModel>::Ok(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v5 = *(void *)(a2 + 16);
  *(void *)(a2 + 24) = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(void *)(a2 + 8) = v7;
  *(void *)(a2 + 16) = v6;
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  uint64_t v8 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v8;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v9;
  uint64_t v10 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v10;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(a1 + 56);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  uint64_t v11 = *(void *)(a2 + 80);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a1 + 80) = v11;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  uint64_t v12 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v12;
  uint64_t v13 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v13;
  ++*(_DWORD *)(a2 + 96);
  ++*(_DWORD *)(a1 + 96);
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(a1 + 112, (unsigned __int8 *)(a2 + 112));
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(a1 + 160, (unsigned __int8 *)(a2 + 160));
  *(void *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 208) = 0;
  uint64_t v14 = *(void *)(a2 + 216);
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  *(void *)(a1 + 216) = v14;
  *(void *)(a2 + 208) = 0;
  *(void *)(a2 + 216) = 0;
  uint64_t v15 = *(void *)(a1 + 224);
  *(void *)(a1 + 224) = *(void *)(a2 + 224);
  *(void *)(a2 + 224) = v15;
  uint64_t v16 = *(void *)(a1 + 240);
  *(void *)(a1 + 240) = *(void *)(a2 + 240);
  *(void *)(a2 + 240) = v16;
  ++*(_DWORD *)(a2 + 232);
  ++*(_DWORD *)(a1 + 232);
  return a1;
}

uint64_t re::Result<re::GeomModel,re::DetailedError>::Result(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 1;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 32) = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)(a1 + 8) = *(void *)a2;
  *(void *)a2 = 0;
  uint64_t v5 = *(void *)(a2 + 16);
  *(void *)(a2 + 24) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = v5;
  *(void *)(a2 + 8) = v7;
  *(void *)(a2 + 16) = v6;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v8 = *(void *)(a2 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 32);
  *(void *)(a1 + 48) = v8;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v9 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v9;
  uint64_t v10 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v10;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(a1 + 64);
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  uint64_t v11 = *(void *)(a2 + 80);
  *(void *)(a1 + 80) = *(void *)(a2 + 72);
  *(void *)(a1 + 88) = v11;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  uint64_t v12 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v12;
  uint64_t v13 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v13;
  ++*(_DWORD *)(a2 + 96);
  ++*(_DWORD *)(a1 + 104);
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(a1 + 120, (unsigned __int8 *)(a2 + 112));
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::Optional(a1 + 168, (unsigned __int8 *)(a2 + 160));
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 240) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 216) = 0;
  uint64_t v14 = *(void *)(a2 + 216);
  *(void *)(a1 + 216) = *(void *)(a2 + 208);
  *(void *)(a1 + 224) = v14;
  *(void *)(a2 + 208) = 0;
  *(void *)(a2 + 216) = 0;
  uint64_t v15 = *(void *)(a1 + 232);
  *(void *)(a1 + 232) = *(void *)(a2 + 224);
  *(void *)(a2 + 224) = v15;
  uint64_t v16 = *(void *)(a1 + 248);
  *(void *)(a1 + 248) = *(void *)(a2 + 240);
  *(void *)(a2 + 240) = v16;
  ++*(_DWORD *)(a2 + 232);
  ++*(_DWORD *)(a1 + 240);
  return a1;
}

void re::importVertexCacheAnimationFromUSKNode(void *a1@<X0>, float *a2@<X1>, unint64_t a3@<X8>, double a4@<D0>)
{
  uint64_t v116 = *MEMORY[0x263EF8340];
  id v8 = a1;
  uint64_t v9 = [v8 property:@"points"];
  uint64_t v10 = [v8 property:@"faceVertexIndices"];
  uint64_t v11 = (void *)v10;
  if (!v9 || !v10 || ([v9 isAnimated] & 1) == 0)
  {
    *(unsigned char *)a3 = 1;
    goto LABEL_113;
  }
  uint64_t v12 = [v9 timeSamples];
  unint64_t v13 = (unint64_t)v12;
  if (!v12)
  {
    long long v34 = v111;
    long long v35 = v112;
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 1024;
    *(void *)(a3 + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a3 + 24) = v34;
    *(_OWORD *)(a3 + 40) = v35;
    goto LABEL_112;
  }
  unint64_t v14 = [v12 dataNoCopy];
  unint64_t v15 = [(id)v14 bytes];
  unint64_t v16 = [(id)v13 arraySize];

  if (!v16)
  {
LABEL_118:
    re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) Array is empty.", "!isEmpty()", "first", 225);
    _os_crash();
    __break(1u);
LABEL_119:
    re::internal::assertLog((re::internal *)6, v18, "assertion failure: '%s' (%s:line %i) Index out of range. fromInclusive = %zu, size = %zu", "fromInclusive <= size()", "range", 241, v15, v16);
    _os_crash();
    __break(1u);
LABEL_120:
    re::internal::assertLog((re::internal *)4, v18, "assertion failure: '%s' (%s:line %i) Array is empty.", "!isEmpty()", "last", 233);
    _os_crash();
    __break(1u);
    goto LABEL_121;
  }
  unint64_t v4 = [v9 arraySizeAtTime:*(double *)v15];
  long long v111 = 0uLL;
  *(void *)&long long v112 = 0;
  memset(v108, 0, 24);
  __n128 v98 = (double *)v15;
  unint64_t v14 = 1;
  if (v16 != 1)
  {
    while (v4 == [v9 float3Array:*(void *)&v108[16] maxCount:v4 atTime:*(double *)(v15 + 8 * v14)]
         && *((void *)&v111 + 1) == *(void *)&v108[8])
    {
      if (*((void *)&v111 + 1))
      {
        unint64_t v30 = (float32x4_t *)v112;
        unsigned int v31 = *(float32x4_t **)&v108[16];
        uint64_t v32 = 16 * *((void *)&v111 + 1);
        do
        {
          uint32x4_t v33 = (uint32x4_t)vceqq_f32(*v30, *v31);
          v33.i32[3] = v33.i32[2];
          if ((vminvq_u32(v33) & 0x80000000) == 0) {
            goto LABEL_7;
          }
          ++v30;
          ++v31;
          v32 -= 16;
        }
        while (v32);
      }
      if (++v14 == v16)
      {
        unint64_t v14 = v16;
        break;
      }
    }
  }
LABEL_7:
  unint64_t v15 = v14 - 1;
  if (v16 < v14 - 1) {
    goto LABEL_119;
  }
  if (*(void *)v108 && *(void *)&v108[8]) {
    (*(void (**)(void))(**(void **)v108 + 40))();
  }
  int v19 = (_anonymous_namespace_ *)v111;
  if ((void)v111 && *((void *)&v111 + 1)) {
    int v19 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v111 + 40))();
  }
  unint64_t v95 = v13;
  unint64_t v96 = a3;
  if (v16 == v15) {
    goto LABEL_120;
  }
  unint64_t v13 = (unint64_t)&v98[v15];
  unint64_t v94 = v16;
  unint64_t v16 = (unint64_t)(*(double *)(v13 + 8 * (v16 - v14)) - *(double *)v13 + 1.5);
  uint64_t v102 = 0;
  unint64_t v103 = 0;
  unsigned int v104 = 0;
  if (!v16)
  {
    *((void *)a2 + 2) = 0;
    goto LABEL_36;
  }
  unint64_t v21 = 0;
  unint64_t v15 = v103;
  unint64_t v22 = v104;
  do
  {
    if (v15 == v21)
    {
      *(void *)&long long v106 = 0;
      long long v114 = 0u;
      long long v115 = 0u;
      long long v112 = 0u;
      long long v113 = 0u;
      long long v111 = 0u;
      id v8 = (id)&_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)char v108 = 136315906;
      *(void *)&v108[4] = "operator[]";
      *(_WORD *)&v108[12] = 1024;
      *(_DWORD *)&v108[14] = 468;
      *(_WORD *)&v108[18] = 2048;
      *(void *)&v108[20] = v15;
      __int16 v109 = 2048;
      unint64_t v110 = v15;
      _os_log_send_and_compose_impl();
      uint64_t v72 = _os_crash_msg();
      __break(1u);
LABEL_95:
      re::DynamicString::format((re::DynamicString *)"Sampled index count does not matched for frame %zu: %zu != %zu", (re::DynamicString *)&v111, v4, v72, v13);
LABEL_97:
      long long v88 = v111;
      uint64_t v90 = *((void *)&v112 + 1);
      uint64_t v89 = v112;
      unint64_t v91 = v96;
      *(unsigned char *)unint64_t v96 = 0;
      uint64_t v92 = 1025;
      goto LABEL_99;
    }
    v22[v21] = *(double *)v13 + (double)v21;
    ++v21;
  }
  while (v16 != v21);
  *((void *)a2 + 2) = v16;
  if (v16 >> 58) {
    goto LABEL_122;
  }
  *((void *)a2 + 3) = v24;
  if (!v24) {
    goto LABEL_123;
  }
  unint64_t v26 = v16 - 1;
  if (v16 != 1)
  {
    int32x4_t v27 = vdupq_n_s32(0x7F800000u);
    *(void *)&long long v28 = 0x7F0000007FLL;
    *((void *)&v28 + 1) = 0x7F0000007FLL;
    do
    {
      *(int32x4_t *)uint64_t v24 = v27;
      *(_OWORD *)(v24 + 16) = v28;
      *(void *)(v24 + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 32) = 0;
      v24 += 64;
      --v26;
    }
    while (v26);
  }
  *(void *)&long long v29 = 0x7F0000007FLL;
  *((void *)&v29 + 1) = 0x7F0000007FLL;
  *(int32x4_t *)uint64_t v24 = vdupq_n_s32(0x7F800000u);
  *(_OWORD *)(v24 + 16) = v29;
  *(void *)(v24 + 40) = 0;
  *(void *)(v24 + 48) = 0;
  *(void *)(v24 + 32) = 0;
LABEL_36:
  size_t v97 = v11;
  unint64_t v36 = v103;
  if (!v103)
  {
LABEL_121:
    re::internal::assertLog((re::internal *)4, v25, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "first", 440);
    _os_crash();
    __break(1u);
LABEL_122:
    re::internal::assertLog((re::internal *)6, v23, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 64, v16);
    _os_crash();
    __break(1u);
LABEL_123:
    re::internal::assertLog((re::internal *)4, v25, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
LABEL_124:
    uint64_t v99 = 0;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v111 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)char v108 = 136315906;
    *(void *)&v108[4] = "operator[]";
    *(_WORD *)&v108[12] = 1024;
    *(_DWORD *)&v108[14] = 468;
    *(_WORD *)&v108[18] = 2048;
    *(void *)&v108[20] = v14;
    __int16 v109 = 2048;
    unint64_t v110 = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_125:
    uint64_t v99 = 0;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v111 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)char v108 = 136315906;
    *(void *)&v108[4] = "operator[]";
    *(_WORD *)&v108[12] = 1024;
    *(_DWORD *)&v108[14] = 468;
    *(_WORD *)&v108[18] = 2048;
    *(void *)&v108[20] = v14;
    __int16 v109 = 2048;
    unint64_t v110 = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_126:
    uint64_t v105 = 0;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v111 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)char v108 = 136315906;
    *(void *)&v108[4] = "operator[]";
    *(_WORD *)&v108[12] = 1024;
    *(_DWORD *)&v108[14] = 468;
    *(_WORD *)&v108[18] = 2048;
    *(void *)&v108[20] = v4;
    __int16 v109 = 2048;
    unint64_t v110 = v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_127:
    uint64_t v105 = 0;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v111 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)char v108 = 136315906;
    *(void *)&v108[4] = "operator[]";
    *(_WORD *)&v108[12] = 1024;
    *(_DWORD *)&v108[14] = 468;
    *(_WORD *)&v108[18] = 2048;
    *(void *)&v108[20] = v4;
    __int16 v109 = 2048;
    unint64_t v110 = v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_128:
    re::internal::assertLog((re::internal *)4, v68, "assertion failure: '%s' (%s:line %i) Array is empty.", "!isEmpty()", "first", 225);
    _os_crash();
    __break(1u);
    goto LABEL_129;
  }
  id v37 = v104;
  float v38 = *v104 * a4;
  *a2 = v38;
  float v39 = v37[v36 - 1] * a4;
  a2[1] = v39;
  if (!v16)
  {
LABEL_45:
    uint64_t v43 = [v8 property:@"extent"];
    unint64_t v4 = (unint64_t)v43;
    if (v43 && [v43 isAnimated])
    {
      id v44 = (void *)v4;
      int v45 = [(id)v4 timeSamples];
      id v46 = [v45 dataNoCopy];
      __int16 v47 = (double *)[v46 bytes];
      uint64_t v48 = [v45 arraySize];

      if (!v48)
      {
LABEL_129:
        re::internal::assertLog((re::internal *)4, v49, "assertion failure: '%s' (%s:line %i) Array is empty.", "!isEmpty()", "first", 225);
        _os_crash();
        __break(1u);
        goto LABEL_130;
      }
      if ((*v98 == *v47 || vabdd_f64(*v98, *v47) < (fabs(*v98) + fabs(*v47) + 1.0) * 1.0e-12)
        && ((double v50 = v98[v94 - 1], v51 = v47[v48 - 1], v50 == v51)
         || vabdd_f64(v50, v51) < (fabs(v50) + fabs(v51) + 1.0) * 1.0e-12))
      {
        unint64_t v52 = v45;
        id v53 = v104;
        re::FixedArray<double>::operator[](v103);
        unint64_t v4 = (unint64_t)v44;
        uint64_t v11 = v97;
        if ([v44 arraySizeAtTime:*v53] == 2)
        {
          if (v16)
          {
            unint64_t v15 = 0;
            unint64_t v14 = 0;
            while (1)
            {
              unint64_t v13 = v103;
              if (v103 <= v14) {
                goto LABEL_124;
              }
              uint64_t v54 = [(id)v4 float3Array:&v106 maxCount:2 atTime:v104[v14]];
              if (v54 != 2) {
                break;
              }
              unint64_t v13 = *((void *)a2 + 2);
              if (v13 <= v14) {
                goto LABEL_125;
              }
              long long v55 = *(_OWORD *)__s1;
              long long v56 = (_OWORD *)(*((void *)a2 + 3) + v15);
              *long long v56 = v106;
              v56[1] = v55;
              ++v14;
              v15 += 64;
              if (v16 == v14) {
                goto LABEL_59;
              }
            }
            re::DynamicString::format((re::DynamicString *)"Expected exactly 2 float3 values for extent frame %zu, received: %zu", (re::DynamicString *)&v111, v14, v54);
            long long v86 = v111;
            long long v87 = v112;
            *(unsigned char *)unint64_t v96 = 0;
            *(void *)(v96 + 8) = 1025;
            *(void *)(v96 + 16) = &re::AnimationErrorCategory(void)::instance;
            *(_OWORD *)(v96 + 24) = v86;
            *(_OWORD *)(v96 + 40) = v87;

            goto LABEL_108;
          }
LABEL_59:

LABEL_67:
          if (![v11 isAnimated])
          {
LABEL_107:
            *(unsigned char *)unint64_t v96 = 1;
            goto LABEL_108;
          }
          unint64_t v93 = v4;
          a2 = [v11 timeSamples];
          id v65 = [a2 dataNoCopy];
          int v66 = (double *)[v65 bytes];
          uint64_t v67 = [a2 arraySize];

          if (v67)
          {
            if (*v98 == *v66 || vabdd_f64(*v98, *v66) < (fabs(*v98) + fabs(*v66) + 1.0) * 1.0e-12)
            {
              double v69 = v98[v94 - 1];
              double v70 = v66[v67 - 1];
              if (v69 == v70 || vabdd_f64(v69, v70) < (fabs(v69) + fabs(v70) + 1.0) * 1.0e-12)
              {
                uint64_t v11 = v97;
                if (v103)
                {
                  unint64_t v13 = [v97 arraySizeAtTime:*v104];
                  long long v106 = 0uLL;
                  __s1[0] = 0;
                  if (v103)
                  {
                    uint64_t v71 = (_anonymous_namespace_ *)[v97 intArray:__s1[0] maxCount:v13 atTime:*v104];
                    if (v71 != (_anonymous_namespace_ *)v13)
                    {
                      re::DynamicString::format((re::DynamicString *)"Read indices does not match expected count: %zu != %zu", (re::DynamicString *)&v111, v71, v13);
                      long long v79 = v111;
                      long long v80 = v112;
                      *(unsigned char *)unint64_t v96 = 0;
                      *(void *)(v96 + 8) = 1025;
                      *(void *)(v96 + 16) = &re::AnimationErrorCategory(void)::instance;
                      *(_OWORD *)(v96 + 24) = v79;
                      *(_OWORD *)(v96 + 40) = v80;
                      int v74 = 1;
                      unint64_t v4 = v93;
                      goto LABEL_103;
                    }
                    uint64_t v99 = 0;
                    uint64_t v100 = 0;
                    __s2 = 0;
                    if (v16 < 2)
                    {
LABEL_84:
                      int v74 = 0;
LABEL_100:
                      unint64_t v4 = v93;
                      if (v99 && v100) {
                        (*(void (**)(void))(*(void *)v99 + 40))();
                      }
LABEL_103:
                      if ((void)v106 && *((void *)&v106 + 1)) {
                        (*(void (**)(void))(*(void *)v106 + 40))();
                      }

                      if (v74) {
                        goto LABEL_108;
                      }
                      goto LABEL_107;
                    }
                    unint64_t v4 = 1;
                    while (1)
                    {
                      unint64_t v15 = v103;
                      if (v103 <= v4) {
                        goto LABEL_126;
                      }
                      uint64_t v72 = [v97 arraySizeAtTime:v104[v4]];
                      if (v72 != v13) {
                        goto LABEL_95;
                      }
                      unint64_t v15 = v103;
                      if (v103 <= v4) {
                        goto LABEL_127;
                      }
                      uint64_t v73 = [v97 intArray:__s2 maxCount:v13 atTime:v104[v4]];
                      if (v73 != v13)
                      {
                        re::DynamicString::format((re::DynamicString *)"Read indices does not match expected count for frame %zu: %zu != %zu", (re::DynamicString *)&v111, v4, v73, v13);
                        goto LABEL_97;
                      }
                      if (memcmp(__s1[0], __s2, 4 * v13)) {
                        break;
                      }
                      if (v16 == ++v4) {
                        goto LABEL_84;
                      }
                    }
                    re::DynamicString::format((re::DynamicString *)"Invalid topological change, index buffer does not match for frame %zu", (re::DynamicString *)&v111, v4);
                    long long v88 = v111;
                    uint64_t v90 = *((void *)&v112 + 1);
                    uint64_t v89 = v112;
                    unint64_t v91 = v96;
                    *(unsigned char *)unint64_t v96 = 0;
                    uint64_t v92 = 1033;
LABEL_99:
                    *(void *)(v91 + 8) = v92;
                    *(void *)(v91 + 16) = &re::AnimationErrorCategory(void)::instance;
                    *(_OWORD *)(v91 + 24) = v88;
                    *(void *)(v91 + 40) = v89;
                    *(void *)(v91 + 48) = v90;
                    int v74 = 1;
                    goto LABEL_100;
                  }
LABEL_131:
                  uint64_t v99 = 0;
                  long long v114 = 0u;
                  long long v115 = 0u;
                  long long v112 = 0u;
                  long long v113 = 0u;
                  long long v111 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)char v108 = 136315906;
                  *(void *)&v108[4] = "operator[]";
                  *(_WORD *)&v108[12] = 1024;
                  *(_DWORD *)&v108[14] = 468;
                  *(_WORD *)&v108[18] = 2048;
                  *(void *)&v108[20] = 0;
                  __int16 v109 = 2048;
                  unint64_t v110 = 0;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                }
LABEL_130:
                *(void *)&long long v106 = 0;
                long long v114 = 0u;
                long long v115 = 0u;
                long long v112 = 0u;
                long long v113 = 0u;
                long long v111 = 0u;
                os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                *(_DWORD *)char v108 = 136315906;
                *(void *)&v108[4] = "operator[]";
                *(_WORD *)&v108[12] = 1024;
                *(_DWORD *)&v108[14] = 468;
                *(_WORD *)&v108[18] = 2048;
                *(void *)&v108[20] = 0;
                __int16 v109 = 2048;
                unint64_t v110 = 0;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_131;
              }
            }
            re::DynamicString::format((re::DynamicString *)"Point and Index sample sizes do not match: %zu != %zu", (re::DynamicString *)&v111, v94, v67);
            long long v77 = v111;
            long long v78 = v112;
            *(unsigned char *)unint64_t v96 = 0;
            *(void *)(v96 + 8) = 1025;
            *(void *)(v96 + 16) = &re::AnimationErrorCategory(void)::instance;
            *(_OWORD *)(v96 + 24) = v77;
            *(_OWORD *)(v96 + 40) = v78;

            uint64_t v11 = v97;
            unint64_t v4 = v93;
LABEL_108:

            goto LABEL_109;
          }
          goto LABEL_128;
        }
        int v83 = v104;
        re::FixedArray<double>::operator[](v103);
        re::DynamicString::format((re::DynamicString *)"Expected exactly 2 float3 values for extent property, received: %zu", (re::DynamicString *)&v111, [v44 arraySizeAtTime:*v83]);
        long long v84 = v111;
        long long v85 = v112;
        *(unsigned char *)unint64_t v96 = 0;
        *(void *)(v96 + 8) = 1025;
        *(void *)(v96 + 16) = &re::AnimationErrorCategory(void)::instance;
        *(_OWORD *)(v96 + 24) = v84;
        *(_OWORD *)(v96 + 40) = v85;
        int v45 = v52;
      }
      else
      {
        re::DynamicString::format((re::DynamicString *)"Point and Extent sample sizes do not match: %zu != %zu", (re::DynamicString *)&v111, v94, v48);
        long long v81 = v111;
        long long v82 = v112;
        uint64_t v11 = v97;
        *(unsigned char *)unint64_t v96 = 0;
        *(void *)(v96 + 8) = 1025;
        *(void *)(v96 + 16) = &re::AnimationErrorCategory(void)::instance;
        *(_OWORD *)(v96 + 24) = v81;
        *(_OWORD *)(v96 + 40) = v82;
        unint64_t v4 = (unint64_t)v44;
      }

      goto LABEL_108;
    }
    uint64_t v11 = v97;
    if (!v16) {
      goto LABEL_67;
    }
    unint64_t v14 = 0;
    while (1)
    {
      unint64_t v15 = *((void *)a2 + 2);
      if (v15 <= v14) {
        break;
      }
      long long v57 = (float32x4_t *)(*((void *)a2 + 3) + (v14 << 6));
      uint64_t v58 = v57[2].i64[1];
      if (v58)
      {
        id v59 = (float32x4_t *)v57[3].i64[0];
        uint64_t v60 = 16 * v58;
        float32x4_t v61 = *v57;
        float32x4_t v62 = v57[1];
        do
        {
          float32x4_t v63 = *v59++;
          float32x4_t v64 = v63;
          v61.i32[3] = 0;
          v64.i32[3] = 0;
          float32x4_t v61 = vminnmq_f32(v61, v64);
          v62.i32[3] = 0;
          float32x4_t v62 = vmaxnmq_f32(v62, v64);
          *long long v57 = v61;
          v57[1] = v62;
          v60 -= 16;
        }
        while (v60);
      }
      if (++v14 == v16) {
        goto LABEL_67;
      }
    }
    *(void *)&long long v106 = 0;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v111 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)char v108 = 136315906;
    *(void *)&v108[4] = "operator[]";
    *(_WORD *)&v108[12] = 1024;
    *(_DWORD *)&v108[14] = 468;
    *(_WORD *)&v108[18] = 2048;
    *(void *)&v108[20] = v14;
    __int16 v109 = 2048;
    unint64_t v110 = v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_115:
    *(void *)&long long v106 = 0;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v111 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)char v108 = 136315906;
    *(void *)&v108[4] = "operator[]";
    *(_WORD *)&v108[12] = 1024;
    *(_DWORD *)&v108[14] = 468;
    *(_WORD *)&v108[18] = 2048;
    *(void *)&v108[20] = v13;
    __int16 v109 = 2048;
    unint64_t v110 = a3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_116:
    *(void *)&long long v106 = 0;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v111 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)char v108 = 136315906;
    *(void *)&v108[4] = "operator[]";
    *(_WORD *)&v108[12] = 1024;
    *(_DWORD *)&v108[14] = 468;
    *(_WORD *)&v108[18] = 2048;
    *(void *)&v108[20] = v13;
    __int16 v109 = 2048;
    unint64_t v110 = a3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_117:
    *(void *)&long long v106 = 0;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v111 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)char v108 = 136315906;
    *(void *)&v108[4] = "operator[]";
    *(_WORD *)&v108[12] = 1024;
    *(_DWORD *)&v108[14] = 468;
    *(_WORD *)&v108[18] = 2048;
    *(void *)&v108[20] = v13;
    __int16 v109 = 2048;
    unint64_t v110 = a3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_118;
  }
  unint64_t v13 = 0;
  unint64_t v15 = 48;
  while (1)
  {
    a3 = v103;
    if (v103 <= v13) {
      goto LABEL_115;
    }
    uint64_t v40 = (_anonymous_namespace_ *)[v9 arraySizeAtTime:v104[v13]];
    if (v40 != (_anonymous_namespace_ *)v4)
    {
      re::DynamicString::format((re::DynamicString *)"Sampled vertex count does not matched for frame %zu: %zu != %zu", (re::DynamicString *)&v111, v13, v40, v4);
      goto LABEL_87;
    }
    a3 = *((void *)a2 + 2);
    if (a3 <= v13) {
      goto LABEL_116;
    }
    uint64_t v41 = *((void *)a2 + 3);
    a3 = v103;
    if (v103 <= v13) {
      goto LABEL_117;
    }
    uint64_t v42 = [v9 float3Array:*(void *)(v41 + v15) maxCount:v4 atTime:v104[v13]];
    if (v42 != v4) {
      break;
    }
    ++v13;
    v15 += 64;
    if (v16 == v13) {
      goto LABEL_45;
    }
  }
  re::DynamicString::format((re::DynamicString *)"Read vertices does not match expected count for frame %zu: %zu != %zu", (re::DynamicString *)&v111, v13, v42, v4);
LABEL_87:
  long long v75 = v111;
  long long v76 = v112;
  uint64_t v11 = v97;
  *(unsigned char *)unint64_t v96 = 0;
  *(void *)(v96 + 8) = 1025;
  *(void *)(v96 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(v96 + 24) = v75;
  *(_OWORD *)(v96 + 40) = v76;
LABEL_109:
  unint64_t v13 = v95;
  if (v102 && v103) {
    (*(void (**)(void))(*(void *)v102 + 40))();
  }
LABEL_112:

LABEL_113:
}

uint64_t re::FixedArray<double>::operator[](uint64_t result)
{
  if (!result)
  {
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

uint64_t re::isCatmullClarkSurface(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 type];
  uint64_t v3 = (void *)*MEMORY[0x263F83FF8];

  if (v2 == v3)
  {
    uint64_t v5 = [v1 property:@"subdivisionScheme"];
    uint64_t v6 = v5;
    if (v5)
    {
      uint64_t v7 = [v5 tokenValue];
      id v8 = [v7 stringValue];
      int v9 = [v8 isEqualToString:@"catmullClark"];

      int v4 = v9 << 31 >> 31;
    }
    else
    {
      LOBYTE(v4) = 1;
    }
  }
  else
  {
    LOBYTE(v4) = 0;
  }

  return v4 & 1;
}

BOOL re::convertMDLAssetToGeomScene(const char *a1, uint64_t a2, unsigned char *a3)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v22, 4504, 0);
  uint64_t v6 = [NSString stringWithCString:a1 encoding:4];
  uint64_t v7 = [NSURL fileURLWithPath:v6];
  int v8 = a3[1];
  id v9 = objc_alloc(MEMORY[0x263F135E8]);
  if (v8)
  {
    uint64_t v20 = 0;
    uint64_t v10 = (id *)&v20;
    uint64_t v11 = [v9 initWithURL:v7 bufferAllocator:0 preserveIndexing:1 error:&v20];
  }
  else
  {
    uint64_t v21 = 0;
    uint64_t v10 = (id *)&v21;
    uint64_t v11 = [v9 initWithURL:v7 vertexDescriptor:0 bufferAllocator:0 preserveTopology:0 error:&v21];
  }
  uint64_t v12 = (void *)v11;
  id v13 = *v10;
  unint64_t v14 = v13;
  if (v13)
  {
    id v15 = [v13 localizedDescription];
    NSLog(&cfstr_Modelconverter.isa, [v15 UTF8String]);
  }
  else
  {
    id v18 = v12;
    id v19 = v18;
    uint64_t v56 = 0;
    uint64_t v53 = 0;
    memset(v54, 0, sizeof(v54));
    int v55 = 0;
    uint64_t v50 = 0;
    memset(v51, 0, sizeof(v51));
    int v52 = 0;
    memset(v48, 0, sizeof(v48));
    int v49 = 0;
    memset(v26, 0, sizeof(v26));
    int v27 = 0;
    long long v28 = 0u;
    long long v29 = 0u;
    memset(v31, 0, sizeof(v31));
    int v30 = 0;
    int v32 = 0;
    memset(v33, 0, sizeof(v33));
    int v34 = 0;
    memset(v35, 0, sizeof(v35));
    uint64_t v36 = 0x7FFFFFFFLL;
    memset(v37, 0, sizeof(v37));
    int v38 = 0;
    uint64_t v39 = 0x7FFFFFFFLL;
    int v41 = 0;
    memset(v40, 0, sizeof(v40));
    uint64_t v42 = 0x7FFFFFFFLL;
    uint64_t v47 = 0;
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    int v46 = 0;
    uint64_t v45 = 0;
    int v24 = 0;
    memset(v23, 0, sizeof(v23));
    uint64_t v25 = 0x7FFFFFFFLL;
    re::convertMDLAssetToGeomSceneAndImportAnimation(&v19, a1, a2, (uint64_t)v23, (uint64_t)v54, (uint64_t)v51, v48, (re::AnimationMetaData *)v26, a3, 0);
    double v16 = re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)v23);
    if (v43)
    {
      if (v47) {
        (*(void (**)(double))(*(void *)v43 + 40))(v16);
      }
      uint64_t v47 = 0;
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      uint64_t v43 = 0;
      ++v46;
    }
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v40);
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v37);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v35[8]);
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)v33 + 8);
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v31[1]);
    if (*((void *)&v28 + 1))
    {
      if (v31[0]) {
        (*(void (**)(void))(**((void **)&v28 + 1) + 40))();
      }
      v31[0] = 0;
      long long v29 = 0uLL;
      *((void *)&v28 + 1) = 0;
      ++v30;
    }
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)v26);
    re::DynamicArray<re::SkeletalPoseSampledAnimation>::deinit((uint64_t)v48);
    re::DynamicArray<re::ModelIOSkinningData>::deinit((uint64_t)v51);
    re::DynamicArray<re::ModelIOSkeleton>::deinit((uint64_t)v54);
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v22);
  return v14 == 0;
}

uint64_t re::convertMDLAssetToGeomSceneAndImportAnimation(id *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, re::AnimationMetaData *a8, unsigned char *a9, CFErrorRef *a10)
{
  uint64_t v275 = *MEMORY[0x263EF8340];
  uint64_t v16 = *(void *)(a3 + 16);
  *(void *)(a3 + 16) = 0;
  if (v16)
  {
    uint64_t v17 = *(re::DynamicString **)(a3 + 32);
    uint64_t v18 = 152 * v16;
    do
    {
      re::DynamicArray<unsigned long>::deinit((uint64_t)v17 + 112);
      re::DynamicArray<unsigned long>::deinit((uint64_t)v17 + 72);
      re::DynamicArray<re::GeomModel>::deinit((uint64_t)v17 + 32);
      re::DynamicString::deinit(v17);
      uint64_t v17 = (re::DynamicString *)((char *)v17 + 152);
      v18 -= 152;
    }
    while (v18);
  }
  ++*(_DWORD *)(a3 + 24);
  *(void *)(a3 + 56) = 0;
  ++*(_DWORD *)(a3 + 64);
  uint64_t v19 = *(void *)(a3 + 96);
  *(void *)(a3 + 96) = 0;
  if (v19)
  {
    uint64_t v20 = 0;
    uint64_t v21 = *(void *)(a3 + 112);
    uint64_t v22 = 160 * v19;
    do
    {
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(v21 + v20 + 112));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v21 + v20 + 88));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v21 + v20 + 64));
      re::FixedArray<CoreIKTransform>::deinit((uint64_t *)(v21 + v20 + 40));
      re::FixedArray<re::StringID>::deinit((void *)(v21 + v20 + 16));
      re::StringID::destroyString((re::StringID *)(v21 + v20));
      v20 += 160;
    }
    while (v22 != v20);
  }
  ++*(_DWORD *)(a3 + 104);
  uint64_t v23 = (_anonymous_namespace_ *)*a1;
  uint64_t v203 = 0;
  memset(v201, 0, sizeof(v201));
  int v202 = 0;
  v192[0] = 1;
  re::importSkinningAndSkeletalAnimations(v23, a5, a6, a7, a8, (unsigned __int8 *)&v247);
  uint64_t v25 = (re *)re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)v192, (uint64_t)&v247);
  if (!(_BYTE)v247)
  {
    uint64_t v25 = (re *)*((void *)&v248 + 1);
    if (*((void *)&v248 + 1))
    {
      if (v249) {
        uint64_t v25 = (re *)(*(uint64_t (**)(void))(**((void **)&v248 + 1) + 40))();
      }
    }
  }
  if (!v192[0])
  {
    unint64_t v26 = (id)*re::pipelineLogObjects(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      std::error_code::message((std::string *)&v247, &v193);
      int v27 = (SBYTE7(v248) & 0x80u) == 0 ? (float32x4_t *)&v247 : (float32x4_t *)v247;
      long long v28 = (v195 & 1) != 0 ? *(unsigned char **)&v196[7] : v196;
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v27;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v28;
      _os_log_impl(&dword_233120000, v26, OS_LOG_TYPE_DEFAULT, "Error: %s\nDetails:\n%s", buf, 0x16u);
      if (SBYTE7(v248) < 0) {
        operator delete((void *)v247);
      }
    }

    if (a10) {
      *a10 = CFErrorCreate(0, @"REPipelineErrorDomain", 3, 0);
    }
  }
  unsigned int v190 = 0;
  long long v188 = 0u;
  long long v189 = 0u;
  uint64_t v191 = 0x7FFFFFFFLL;
  unsigned int v186 = 0;
  long long v184 = 0u;
  long long v185 = 0u;
  uint64_t v187 = 0x7FFFFFFFLL;
  *(_DWORD *)float32x4_t v232 = 0;
  memset(buf, 0, sizeof(buf));
  *(void *)&v232[4] = 0x7FFFFFFFLL;
  long long v180 = 0u;
  long long v181 = 0u;
  long long v182 = 0u;
  long long v183 = 0u;
  long long v29 = v23;
  uint64_t v30 = [(_anonymous_namespace_ *)v29 countByEnumeratingWithState:&v180 objects:v261 count:16];
  if (v30)
  {
    uint64_t v31 = v30;
    uint64_t v32 = *(void *)v181;
    do
    {
      for (uint64_t i = 0; i != v31; ++i)
      {
        if (*(void *)v181 != v32) {
          objc_enumerationMutation(v29);
        }
        int v34 = *(void **)(*((void *)&v180 + 1) + 8 * i);
        long long v247 = xmmword_23435FD50;
        long long v248 = xmmword_23435FD60;
        long long v249 = xmmword_23435FD80;
        long long v250 = xmmword_23435FBB0;
      }
      uint64_t v31 = [(_anonymous_namespace_ *)v29 countByEnumeratingWithState:&v180 objects:v261 count:16];
    }
    while (v31);
  }

  if (!*(_DWORD *)&buf[28]) {
    goto LABEL_73;
  }
  int v35 = *(_DWORD *)v232;
  if (*(_DWORD *)v232)
  {
    uint64_t v36 = 0;
    id v37 = (int *)(*(void *)&buf[16] + 8);
    while (1)
    {
      int v38 = *v37;
      v37 += 16;
      if (v38 < 0) {
        break;
      }
      if (*(unsigned int *)v232 == ++v36)
      {
        LODWORD(v36) = *(_DWORD *)v232;
        break;
      }
    }
  }
  else
  {
    LODWORD(v36) = 0;
  }
  int v39 = *(_DWORD *)v232;
  if (*(_DWORD *)v232 != v36)
  {
    uint64_t v40 = v36;
    uint64_t v41 = *(void *)&buf[16];
    do
    {
      id v42 = *(id *)(v41 + (v40 << 6) + 16);
      *(void *)&long long v247 = v42;
      re::collectMeshMaterialsFromMDLMesh((id *)&v247, a4, a9[4]);

      int v39 = *(_DWORD *)v232;
      uint64_t v41 = *(void *)&buf[16];
      if (*(_DWORD *)v232 <= (v36 + 1)) {
        int v43 = v36 + 1;
      }
      else {
        int v43 = *(_DWORD *)v232;
      }
      int v44 = v36;
      while (1)
      {
        uint64_t v40 = (v44 + 1);
        if (v43 - 1 == v44) {
          break;
        }
        ++v44;
        LODWORD(v36) = v40;
        if ((*(_DWORD *)(*(void *)&buf[16] + (v40 << 6) + 8) & 0x80000000) != 0) {
          goto LABEL_47;
        }
      }
      LODWORD(v36) = v43;
LABEL_47:
      ;
    }
    while (v35 != v36);
  }
  uint64_t v160 = a2;
  if (!*a9) {
    goto LABEL_55;
  }
  uint64_t v45 = 0;
  if (v39)
  {
    int v46 = (int *)(*(void *)&buf[16] + 8);
    while (1)
    {
      int v47 = *v46;
      v46 += 16;
      if (v47 < 0) {
        break;
      }
      if (v39 == ++v45)
      {
        LODWORD(v45) = v39;
        break;
      }
    }
  }
  if (v39 != v45)
  {
    uint64_t v49 = v45;
    uint64_t v50 = *(void *)&buf[16];
    do
    {
      id v51 = *(id *)(v50 + (v49 << 6) + 16);
      int v52 = [v51 vertexAttributeDataForAttributeNamed:@"textureCoordinate"];

      if (v52) {
        [v51 addTangentBasisForTextureCoordinateAttributeNamed:@"textureCoordinate" tangentAttributeNamed:@"tangent" bitangentAttributeNamed:@"bitangent"];
      }

      int v48 = *(_DWORD *)v232;
      uint64_t v50 = *(void *)&buf[16];
      if (*(_DWORD *)v232 <= (v45 + 1)) {
        int v53 = v45 + 1;
      }
      else {
        int v53 = *(_DWORD *)v232;
      }
      while (1)
      {
        uint64_t v49 = (v45 + 1);
        if (v53 - 1 == v45) {
          break;
        }
        LODWORD(v45) = v45 + 1;
        int v54 = v49;
        if ((*(_DWORD *)(*(void *)&buf[16] + (v49 << 6) + 8) & 0x80000000) != 0) {
          goto LABEL_66;
        }
      }
      int v54 = v53;
LABEL_66:
      LODWORD(v45) = v54;
    }
    while (v39 != v54);
  }
  else
  {
LABEL_55:
    int v48 = v39;
  }
  unsigned int v176 = (void *)a3;
  uint64_t v55 = 0;
  if (v48)
  {
    uint64_t v56 = (int *)(*(void *)&buf[16] + 8);
    while (1)
    {
      int v57 = *v56;
      v56 += 16;
      if (v57 < 0) {
        break;
      }
      if (v48 == ++v55)
      {
        LODWORD(v55) = v48;
        break;
      }
    }
  }
  if (v48 == v55)
  {
LABEL_73:
    goto LABEL_74;
  }
  uint64_t v175 = a4;
  unint64_t v59 = 0;
  unint64_t v177 = 0;
  unint64_t v179 = (_anonymous_namespace_ *)(v176 + 5);
  uint64_t v60 = v55;
  uint64_t v61 = *(void *)&buf[16];
  do
  {
    uint64_t v62 = v61 + (v60 << 6);
    float32x4_t v63 = (re *)*(id *)(v62 + 16);
    id v65 = v63;
    *(void *)&long long v247 = v63;
    if (a9[2]
      || (uint64_t v66 = *(void *)(v62 + 40),
          int isSkinnedMesh = re::isSkinnedMesh(v63, v64),
          uint64_t v61 = *(void *)&buf[16],
          isSkinnedMesh))
    {
      ++v59;
      uint64_t v68 = &v184;
    }
    else
    {
      v177 += v66;
      v59 += v66;
      uint64_t v68 = &v188;
    }
    unint64_t v69 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * ((unint64_t)v65 ^ ((unint64_t)v65 >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                                              * ((unint64_t)v65 ^ ((unint64_t)v65 >> 30))) >> 27));
    unint64_t v70 = v69 ^ (v69 >> 31);
    if (!*(void *)v68)
    {
      LODWORD(v71) = 0;
LABEL_96:
      ++*((_DWORD *)v68 + 10);
      goto LABEL_97;
    }
    unint64_t v71 = v70 % *((unsigned int *)v68 + 6);
    uint64_t v72 = *(unsigned int *)(*((void *)v68 + 1) + 4 * v71);
    if (v72 == 0x7FFFFFFF) {
      goto LABEL_96;
    }
    uint64_t v73 = *((void *)v68 + 2);
    while (*(re **)(v73 + (v72 << 6) + 16) != v65)
    {
      uint64_t v72 = *(_DWORD *)(v73 + (v72 << 6) + 8) & 0x7FFFFFFF;
      if (v72 == 0x7FFFFFFF) {
        goto LABEL_96;
      }
    }
LABEL_97:

    uint64_t v61 = *(void *)&buf[16];
    if (*(_DWORD *)v232 <= (v55 + 1)) {
      int v74 = v55 + 1;
    }
    else {
      int v74 = *(_DWORD *)v232;
    }
    while (1)
    {
      uint64_t v60 = (v55 + 1);
      if (v74 - 1 == v55) {
        break;
      }
      LODWORD(v55) = v55 + 1;
      int v75 = v60;
      if ((*(_DWORD *)(*(void *)&buf[16] + (v60 << 6) + 8) & 0x80000000) != 0) {
        goto LABEL_104;
      }
    }
    int v75 = v74;
LABEL_104:
    LODWORD(v55) = v75;
  }
  while (v48 != v75);
  uint64_t v76 = v175;
  long long v77 = (_anonymous_namespace_ *)v176;
  if (v59)
  {
    if (v176[1] < v59) {
      re::DynamicArray<re::GeomModelWithLods>::setCapacity(v176, v59);
    }
    if (v177 <= 1) {
      unint64_t v78 = 1;
    }
    else {
      unint64_t v78 = v177;
    }
    if (v176[6] < v78) {
      re::DynamicArray<re::RigSplineIKJoint>::setCapacity(v179, v78);
    }
    uint64_t v79 = *(void *)(a5 + 16);
    *(void *)&long long v247 = *(void *)(a5 + 32);
    *((void *)&v247 + 1) = v79;
    re::GeomScene::setSkeletons((uint64_t)v176, (uint64_t)&v247);
    if (v186)
    {
      uint64_t v80 = 0;
      long long v81 = (int *)(v185 + 8);
      while (1)
      {
        int v82 = *v81;
        v81 += 16;
        if (v82 < 0) {
          break;
        }
        if (v186 == ++v80)
        {
          LODWORD(v80) = v186;
          break;
        }
      }
    }
    else
    {
      LODWORD(v80) = 0;
    }
    if (v186 != v80)
    {
      uint64_t v83 = v80;
      v166.i64[0] = (uint64_t)v260;
      unint64_t v84 = v185;
      v164.i64[0] = (uint64_t)&v249;
      unsigned int v170 = v186;
      v168.i64[0] = (uint64_t)v232;
      do
      {
        unint64_t v85 = v84 + (v83 << 6);
        id v86 = *(id *)(v85 + 16);
        long long v87 = (unsigned char *)*((unsigned int *)v77 + 4);
        id v88 = v86;
        *(void *)long long buf = v88;
        unint64_t v178 = v88;

        re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)buf);
        re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)v232, (uint64_t)&v247);
        v89.n128_f64[0] = re::DynamicArray<re::GeomModelWithLods>::add(v77, (uint64_t)buf);
        uint64_t v90 = (re::internal::GeomAttributeContainer *)(v85 + 40);
        unint64_t v91 = *(long long **)(v85 + 40);
        if (v91)
        {
          uint64_t v92 = 0;
          unint64_t v93 = (void *)(v85 + 56);
          uint64_t v94 = 80;
          do
          {
            uint64_t v95 = *(void *)v90;
            if (*(void *)v90 <= (unint64_t)v92) {
              goto LABEL_312;
            }
            unint64_t v96 = (long long *)(*v93 + v94);
            long long v97 = *v96;
            long long v98 = v96[1];
            long long v99 = v96[3];
            long long v219 = v96[2];
            long long v220 = v99;
            long long v217 = v97;
            long long v218 = v98;
            LODWORD(v221) = v87;
            if ((*((float *)&v97 + 3) == 0.0
               || vabds_f32(0.0, *((float *)&v217 + 3)) < (float)((float)(fabsf(*((float *)&v217 + 3)) + 1.0) * 0.00001))
              && (*((float *)&v218 + 3) == 0.0
               || vabds_f32(0.0, *((float *)&v218 + 3)) < (float)((float)(fabsf(*((float *)&v218 + 3)) + 1.0) * 0.00001))
              && (*((float *)&v219 + 3) == 0.0
               || vabds_f32(0.0, *((float *)&v219 + 3)) < (float)((float)(fabsf(*((float *)&v219 + 3)) + 1.0) * 0.00001))
              && (*((float *)&v99 + 3) == 1.0
               || vabds_f32(1.0, *((float *)&v99 + 3)) < (float)((float)((float)(fabsf(*((float *)&v99 + 3)) + 1.0) + 1.0)
                                                               * 0.00001)))
            {
              HIDWORD(v217) = 0;
              HIDWORD(v218) = 0;
              HIDWORD(v219) = 0;
              HIDWORD(v220) = 1065353216;
            }
            __n128 v89 = re::DynamicArray<re::GeomInstance>::add(v179, (uint64_t)&v217);
            uint64_t v92 = (long long *)((char *)v92 + 1);
            v94 += 144;
          }
          while (v91 != v92);
        }
        long long v77 = (_anonymous_namespace_ *)v176;
        if (v239)
        {
          if (v243) {
            (*(void (**)(__n128))(*(void *)v239 + 40))(v89);
          }
          uint64_t v243 = 0;
          uint64_t v240 = 0;
          uint64_t v241 = 0;
          uint64_t v239 = 0;
          ++v242;
        }
        if (v234)
        {
          if (v238) {
            (*(void (**)(__n128))(*(void *)v234 + 40))(v89);
          }
          uint64_t v238 = 0;
          uint64_t v235 = 0;
          uint64_t v236 = 0;
          uint64_t v234 = 0;
          ++v237;
        }
        re::DynamicArray<re::GeomModel>::deinit((uint64_t)v232);
        if (*(void *)buf && (buf[8] & 1) != 0) {
          (*(void (**)(void))(**(void **)buf + 40))();
        }
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v260);
        uint64_t v76 = v175;
        if (v258) {
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v259);
        }
        if (v256) {
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v257);
        }
        if (*((void *)&v251 + 1))
        {
          if (v255) {
            (*(void (**)(void))(**((void **)&v251 + 1) + 40))();
          }
          uint64_t v255 = 0;
          uint64_t v252 = 0;
          uint64_t v253 = 0;
          *((void *)&v251 + 1) = 0;
          ++v254;
        }
        re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v249);
        if (void)v247 && (BYTE8(v247)) {
          (*(void (**)(void))(*(void *)v247 + 40))();
        }

        if (v170 <= (int)v80 + 1) {
          unsigned int v100 = v80 + 1;
        }
        else {
          unsigned int v100 = v170;
        }
        while (1)
        {
          uint64_t v83 = (v80 + 1);
          if (v100 - 1 == v80) {
            break;
          }
          LODWORD(v80) = v80 + 1;
          unsigned int v101 = v83;
          if ((*(_DWORD *)(v84 + (v83 << 6) + 8) & 0x80000000) != 0) {
            goto LABEL_165;
          }
        }
        unsigned int v101 = v100;
LABEL_165:
        LODWORD(v80) = v101;
      }
      while (v170 != v101);
    }
    if (HIDWORD(v189))
    {
      re::GeomModel::GeomModel((re::GeomModel *)&v247);
      if (v190)
      {
        uint64_t v102 = 0;
        unint64_t v103 = (int *)(v189 + 8);
        while (1)
        {
          int v104 = *v103;
          v103 += 16;
          if (v104 < 0) {
            break;
          }
          if (v190 == ++v102)
          {
            LODWORD(v102) = v190;
            break;
          }
        }
      }
      else
      {
        LODWORD(v102) = 0;
      }
      if (v190 == v102)
      {
LABEL_174:
        if (v160) {
          uint64_t v105 = v160;
        }
        else {
          uint64_t v105 = "";
        }
        size_t v106 = strlen(v105);
        *(void *)long long buf = v105;
        *(void *)&uint8_t buf[8] = v106;
        re::DynamicString::operator=((re::DynamicString *)&v247, (uint64_t)buf);
        long long v217 = xmmword_23435FD50;
        long long v218 = xmmword_23435FD60;
        long long v219 = xmmword_23435FD80;
        long long v220 = xmmword_23435FBB0;
        LODWORD(v221) = *((void *)v77 + 2);
        re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)buf);
        re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)v232, (uint64_t)&v247);
        re::DynamicArray<re::GeomModelWithLods>::add(v77, (uint64_t)buf);
        __n128 v107 = re::DynamicArray<re::GeomInstance>::add(v179, (uint64_t)&v217);
        if (v239)
        {
          if (v243) {
            (*(void (**)(__n128))(*(void *)v239 + 40))(v107);
          }
          uint64_t v243 = 0;
          uint64_t v240 = 0;
          uint64_t v241 = 0;
          uint64_t v239 = 0;
          ++v242;
        }
        if (v234)
        {
          if (v238) {
            (*(void (**)(__n128))(*(void *)v234 + 40))(v107);
          }
          uint64_t v238 = 0;
          uint64_t v235 = 0;
          uint64_t v236 = 0;
          uint64_t v234 = 0;
          ++v237;
        }
        re::DynamicArray<re::GeomModel>::deinit((uint64_t)v232);
        if (*(void *)buf && (buf[8] & 1) != 0) {
          (*(void (**)(void))(**(void **)buf + 40))();
        }
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v260);
        if (v258) {
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v259);
        }
        if (v256) {
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v257);
        }
        if (*((void *)&v251 + 1))
        {
          if (v255) {
            (*(void (**)(void))(**((void **)&v251 + 1) + 40))();
          }
          uint64_t v255 = 0;
          uint64_t v252 = 0;
          uint64_t v253 = 0;
          *((void *)&v251 + 1) = 0;
          ++v254;
        }
        re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v249);
        if (void)v247 && (BYTE8(v247)) {
          (*(void (**)(void))(*(void *)v247 + 40))();
        }
        goto LABEL_199;
      }
      uint64_t v113 = v102;
      long long v114 = &v249;
      long long v87 = v230;
      uint64_t v115 = v189;
      unsigned int v153 = v190;
      uint64_t v156 = v189;
      while (1)
      {
        int v155 = v102;
        uint64_t v116 = v115 + (v113 << 6);
        id v117 = *(id *)(v116 + 16);
        *(void *)&long long v217 = v117;
        long long v154 = v117;

        unint64_t v118 = *(void *)(v116 + 40);
        uint64_t v159 = (unint64_t *)(v116 + 40);
        if ((unint64_t)v250 + v118 * v233 <= 1) {
          unint64_t v119 = 1;
        }
        else {
          unint64_t v119 = v250 + v118 * v233;
        }
        if (*((void *)&v249 + 1) < v119)
        {
          re::DynamicArray<re::GeomMesh>::setCapacity(v114, v119);
          unint64_t v118 = *v159;
        }
        if (v118) {
          break;
        }
        simd_float3 v147 = v166;
        simd_float3 v146 = v168;
        simd_float3 v148 = v164;
LABEL_291:
        simd_float3 v164 = v148;
        simd_float3 v166 = v147;
        simd_float3 v168 = v146;
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v246);
        if (v244) {
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v245);
        }
        if ((_BYTE)v239) {
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v240);
        }
        if (v234)
        {
          if (v238) {
            (*(void (**)(void))(*(void *)v234 + 40))();
          }
          uint64_t v238 = 0;
          uint64_t v235 = 0;
          uint64_t v236 = 0;
          uint64_t v234 = 0;
          ++v237;
        }
        re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v232);
        if (*(void *)buf && (buf[8] & 1) != 0) {
          (*(void (**)(void))(**(void **)buf + 40))();
        }

        int v149 = v155;
        uint64_t v115 = v156;
        if (v153 <= v155 + 1) {
          unsigned int v150 = v155 + 1;
        }
        else {
          unsigned int v150 = v153;
        }
        while (1)
        {
          uint64_t v113 = (v149 + 1);
          if (v150 - 1 == v149) {
            break;
          }
          ++v149;
          unsigned int v151 = v113;
          if ((*(_DWORD *)(v156 + (v113 << 6) + 8) & 0x80000000) != 0) {
            goto LABEL_309;
          }
        }
        unsigned int v151 = v150;
LABEL_309:
        LODWORD(v102) = v151;
        if (v153 == v151) {
          goto LABEL_174;
        }
      }
      unint64_t v120 = 0;
      unint64_t v158 = (void *)(v156 + (v113 << 6) + 56);
      __int32 v121 = v164.i32[3];
      __int32 v122 = v166.i32[3];
      __int32 v123 = v168.i32[3];
      unint64_t v157 = v118;
      while (2)
      {
        __int32 v161 = v123;
        __int32 v162 = v122;
        __int32 v163 = v121;
        unint64_t v171 = v120;
        re::DynamicString::DynamicString((re::DynamicString *)&v217, (const re::DynamicString *)buf);
        re::DynamicArray<re::GeomMesh>::DynamicArray((uint64_t)&v219, (uint64_t *)v232);
        re::DynamicArray<float>::DynamicArray((uint64_t)&v221 + 8, &v234);
        char v226 = v239;
        if ((_BYTE)v239) {
          re::DynamicArray<re::GeomIndexMap>::DynamicArray((uint64_t)v227, &v240);
        }
        char v228 = v244;
        if (v244) {
          re::DynamicArray<re::GeomIndexMap>::DynamicArray((uint64_t)v229, v245);
        }
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::DynamicArray((uint64_t)v230, v246);
        long long v124 = 0uLL;
        long long v213 = 0u;
        int32x4_t v214 = 0u;
        long long v211 = 0u;
        long long v212 = 0u;
        float32x4_t v209 = 0u;
        float32x4_t v210 = 0u;
        memset(&v208[2], 0, 32);
        long long v215 = xmmword_23435FBB0;
        float32x4_t v216 = 0u;
        unint64_t v84 = *v159;
        unint64_t v125 = v171;
        if (*v159 <= v171) {
          goto LABEL_323;
        }
        uint64_t v126 = *v158 + 144 * v171;
        v276.columns[0] = *(simd_float3 *)(v126 + 80);
        v276.columns[1] = *(simd_float3 *)(v126 + 96);
        float32x4_t v127 = *(float32x4_t *)(v126 + 128);
        float32x4_t v209 = *(float32x4_t *)(v126 + 112);
        float32x4_t v210 = v127;
        *(simd_float3 *)&v208[2] = v276.columns[0];
        *(simd_float3 *)&v208[18] = v276.columns[1];
        v276.columns[2] = (simd_float3)v209;
        simd_float3x3 v277 = __invert_f3(v276);
        simd_float3 v167 = v277.columns[1];
        simd_float3 v169 = v277.columns[0];
        DWORD2(v211) = v277.columns[2].i32[0];
        *(void *)&long long v211 = vzip1q_s32((int32x4_t)v277.columns[0], (int32x4_t)v277.columns[1]).u64[0];
        DWORD2(v212) = v277.columns[2].i32[1];
        simd_float3 v165 = v277.columns[2];
        DWORD2(v213) = v277.columns[2].i32[2];
        *(void *)&long long v212 = vtrn2q_s32((int32x4_t)v277.columns[0], (int32x4_t)v277.columns[1]).u64[0];
        *(void *)&long long v213 = vzip1q_s32(vdupq_laneq_s32((int32x4_t)v277.columns[0], 2), vdupq_laneq_s32((int32x4_t)v277.columns[1], 2)).u64[0];
        re::decomposeScaleRotationTranslation<float>((uint64_t)&v208[2], &v214, &v215, &v216);
        int v205 = 0;
        long long v270 = xmmword_23435FD50;
        long long v271 = xmmword_23435FD60;
        long long v272 = xmmword_23435FD80;
        long long v273 = xmmword_23435FBB0;
        if (re::areAlmostEqual<float>((float *)&v208[2], (float *)&v270))
        {
LABEL_272:
          uint64_t v145 = v220;
          if ((void)v220)
          {
            uint64_t v90 = 0;
            long long v87 = 0;
            unint64_t v84 = 0;
            do
            {
              uint64_t v94 = v220;
              if ((unint64_t)v220 <= v84) {
                goto LABEL_313;
              }
              re::DynamicArray<re::GeomMesh>::add((uint64_t)v114, (uint64_t)v90 + v221);
              uint64_t v94 = v223;
              if (v223 <= v84) {
                goto LABEL_314;
              }
              re::DynamicArray<int>::add((void *)&v251 + 1, &v87[v225]);
              ++v84;
              v87 += 4;
              uint64_t v90 = (re::internal::GeomAttributeContainer *)((char *)v90 + 736);
            }
            while (v145 != v84);
          }
        }
        else
        {
          float32x4_t v128 = vmulq_f32(v216, v216);
          if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v128, 2), vaddq_f32(v128, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v128.f32, 1))).f32[0]) >= 1.0e-10)v205 |= 1u; {
          if (*(float *)v214.i32 != 1.0
          }
            && fabsf(*(float *)v214.i32 + -1.0) >= (float)((float)((float)(fabsf(*(float *)v214.i32) + 1.0) + 1.0)
                                                         * 0.00001)
            || *(float *)&v214.i32[1] != 1.0
            && fabsf(*(float *)&v214.i32[1] + -1.0) >= (float)((float)((float)(fabsf(*(float *)&v214.i32[1]) + 1.0) + 1.0)
                                                             * 0.00001)
            || *(float *)&v214.i32[2] != 1.0
            && fabsf(*(float *)&v214.i32[2] + -1.0) >= (float)((float)((float)(fabsf(*(float *)&v214.i32[2]) + 1.0) + 1.0)
                                                             * 0.00001))
          {
            v205 |= 2u;
          }
          if ((*(float *)&v215 == 0.0 || (float v129 = fabsf(*(float *)&v215), v129 < (float)((float)(v129 + 1.0) * 0.00001)))
            && (*((float *)&v215 + 1) == 0.0
             || (float v130 = fabsf(*((float *)&v215 + 1)), v130 < (float)((float)(v130 + 1.0) * 0.00001)))
            && (*((float *)&v215 + 2) == 0.0
             || (float v131 = fabsf(*((float *)&v215 + 2)), v131 < (float)((float)(v131 + 1.0) * 0.00001)))
            && (*((float *)&v215 + 3) == 1.0
             || fabsf(*((float *)&v215 + 3) + -1.0) < (float)((float)((float)(fabsf(*((float *)&v215 + 3)) + 1.0) + 1.0)
                                                            * 0.00001)))
          {
            if (!v205) {
              goto LABEL_272;
            }
          }
          else
          {
            v205 |= 4u;
          }
          uint64_t v174 = v220;
          if ((void)v220)
          {
            unint64_t v84 = 0;
            while (1)
            {
              uint64_t v90 = (re::internal::GeomAttributeContainer *)v220;
              if ((unint64_t)v220 <= v84) {
                goto LABEL_315;
              }
              re::transform((re::GeomMesh *)(v221 + 736 * v84), (float32x4_t *)&v208[2]);
              uint64_t v90 = (re::internal::GeomAttributeContainer *)v220;
              if ((unint64_t)v220 <= v84) {
                break;
              }
              uint64_t v92 = v114;
              uint64_t v132 = v221 + 736 * v84;
              uint64_t v95 = *(unsigned int *)(v132 + 200);
              if (v95)
              {
                unsigned int v133 = 0;
                uint64_t v90 = (re::internal::GeomAttributeContainer *)(v132 + 176);
                long long v87 = (unsigned char *)*(unsigned int *)(v221 + 736 * v84 + 16);
                do
                {
                  uint64_t v134 = re::internal::GeomAttributeContainer::attributeByIndex(v90, v133);
                  if (*(unsigned char *)(v134 + 17) == 7)
                  {
                    uint64_t v135 = v134;
                    long long v136 = *(const char **)(v134 + 8);
                    size_t v137 = strlen(v136);
                    if (v137 >= 0x15)
                    {
                      BOOL v138 = *(void *)&v136[v137 - 21] == 0x6154646E656C627CLL
                          && *(void *)&v136[v137 - 13] == 0x44736F5074656772;
                      if (v138 && *(void *)&v136[v137 - 8] == 0x7361746C6544736FLL)
                      {
                        unsigned int v140 = (*(uint64_t (**)(uint64_t))(*(void *)v135 + 16))(v135);
                        if (v140)
                        {
                          float32x4_t v141 = (float32x2_t *)re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[](v135, 0);
                          unsigned int v140 = (*(uint64_t (**)(uint64_t))(*(void *)v135 + 16))(v135);
                          if (v87) {
                            goto LABEL_267;
                          }
                        }
                        else
                        {
                          float32x4_t v141 = 0;
                          if (v87)
                          {
LABEL_267:
                            uint64_t v94 = v140;
                            uint64_t v142 = v140;
                            __int16 v143 = v87;
                            while (v142)
                            {
                              float32x4_t v144 = vaddq_f32(v210, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)&v208[2], COERCE_FLOAT(*(_OWORD *)v141->f32)), *(float32x4_t *)&v208[18], *v141, 1), v209, *(float32x4_t *)v141->f32, 2));
                              *(float32x4_t *)v141->f32 = vdivq_f32(v144, (float32x4_t)vdupq_laneq_s32((int32x4_t)v144, 3));
                              v141 += 2;
                              --v142;
                              if (!--v143) {
                                goto LABEL_270;
                              }
                            }
                            uint64_t v204 = 0;
                            long long v273 = 0u;
                            long long v274 = 0u;
                            long long v271 = 0u;
                            long long v272 = 0u;
                            long long v270 = 0u;
                            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                            int v262 = 136315906;
                            float32x4_t v263 = "operator[]";
                            __int16 v264 = 1024;
                            int v265 = 609;
                            __int16 v266 = 2048;
                            unint64_t v267 = v94;
                            __int16 v268 = 2048;
                            unint64_t v269 = v94;
                            _os_log_send_and_compose_impl();
                            _os_crash_msg();
                            __break(1u);
LABEL_312:
                            *(void *)&long long v270 = 0;
                            long long v220 = 0u;
                            long long v221 = 0u;
                            long long v218 = 0u;
                            long long v219 = 0u;
                            long long v217 = 0u;
                            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                            int v205 = 136315906;
                            float32x4_t v206 = "operator[]";
                            __int16 v207 = 1024;
                            *(_DWORD *)float32x4_t v208 = 797;
                            *(_WORD *)&v208[4] = 2048;
                            *(void *)&v208[6] = v92;
                            *(_WORD *)&v208[14] = 2048;
                            *(void *)&v208[16] = v95;
                            _os_log_send_and_compose_impl();
                            _os_crash_msg();
                            __break(1u);
LABEL_313:
                            uint64_t v204 = 0;
                            long long v273 = 0u;
                            long long v274 = 0u;
                            long long v271 = 0u;
                            long long v272 = 0u;
                            long long v270 = 0u;
                            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                            int v262 = 136315906;
                            float32x4_t v263 = "operator[]";
                            __int16 v264 = 1024;
                            int v265 = 789;
                            __int16 v266 = 2048;
                            unint64_t v267 = v84;
                            __int16 v268 = 2048;
                            unint64_t v269 = v94;
                            _os_log_send_and_compose_impl();
                            _os_crash_msg();
                            __break(1u);
LABEL_314:
                            uint64_t v204 = 0;
                            long long v273 = 0u;
                            long long v274 = 0u;
                            long long v271 = 0u;
                            long long v272 = 0u;
                            long long v270 = 0u;
                            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                            int v262 = 136315906;
                            float32x4_t v263 = "operator[]";
                            __int16 v264 = 1024;
                            int v265 = 789;
                            __int16 v266 = 2048;
                            unint64_t v267 = v84;
                            __int16 v268 = 2048;
                            unint64_t v269 = v94;
                            _os_log_send_and_compose_impl();
                            _os_crash_msg();
                            __break(1u);
LABEL_315:
                            uint64_t v204 = 0;
                            long long v273 = 0u;
                            long long v274 = 0u;
                            long long v271 = 0u;
                            long long v272 = 0u;
                            long long v270 = 0u;
                            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                            int v262 = 136315906;
                            float32x4_t v263 = "operator[]";
                            __int16 v264 = 1024;
                            int v265 = 789;
                            __int16 v266 = 2048;
                            unint64_t v267 = v84;
                            __int16 v268 = 2048;
                            unint64_t v269 = (unint64_t)v90;
                            _os_log_send_and_compose_impl();
                            _os_crash_msg();
                            __break(1u);
                            goto LABEL_316;
                          }
                        }
                      }
                    }
                  }
LABEL_270:
                  ++v133;
                }
                while (v133 != v95);
              }
              ++v84;
              uint64_t v76 = v175;
              long long v77 = (_anonymous_namespace_ *)v176;
              long long v114 = v92;
              if (v84 == v174) {
                goto LABEL_272;
              }
            }
LABEL_316:
            uint64_t v204 = 0;
            long long v273 = 0u;
            long long v274 = 0u;
            long long v271 = 0u;
            long long v272 = 0u;
            long long v270 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v262 = 136315906;
            float32x4_t v263 = "operator[]";
            __int16 v264 = 1024;
            int v265 = 789;
            __int16 v266 = 2048;
            unint64_t v267 = v84;
            __int16 v268 = 2048;
            unint64_t v269 = (unint64_t)v90;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_317;
          }
        }
        long long v87 = v230;
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v230);
        if (v228) {
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v229);
        }
        if (v226) {
          re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v227);
        }
        if (*((void *)&v221 + 1))
        {
          if (v225) {
            (*(void (**)(void))(**((void **)&v221 + 1) + 40))();
          }
          uint64_t v225 = 0;
          uint64_t v222 = 0;
          unint64_t v223 = 0;
          *((void *)&v221 + 1) = 0;
          ++v224;
        }
        re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v219);
        if (void)v217 && (BYTE8(v217)) {
          (*(void (**)(void))(*(void *)v217 + 40))();
        }
        simd_float3 v146 = v169;
        v146.i32[3] = v161;
        simd_float3 v147 = v167;
        v147.i32[3] = v162;
        unint64_t v120 = v171 + 1;
        simd_float3 v148 = v165;
        v148.i32[3] = v163;
        __int32 v121 = v163;
        __int32 v122 = v162;
        __int32 v123 = v161;
        if (v171 + 1 == v157) {
          goto LABEL_291;
        }
        continue;
      }
    }
LABEL_199:
    if (a9[3])
    {
      uint64_t v108 = *((void *)v77 + 2);
      if (v108)
      {
        uint64_t v109 = 0;
        unint64_t v84 = 0;
        while (1)
        {
          *(void *)float32x4_t v232 = 0;
          memset(buf, 0, 28);
          *(void *)&long long v219 = 0;
          *(void *)&long long v218 = 0;
          long long v217 = 0uLL;
          DWORD2(v218) = 0;
          long long v87 = (unsigned char *)*((void *)v77 + 2);
          if ((unint64_t)v87 <= v84) {
            break;
          }
          uint64_t v110 = *((void *)v77 + 4) + v109;
          if (!*(void *)(v110 + 48)) {
            goto LABEL_318;
          }
          long long v87 = (unsigned char *)*((void *)v77 + 2);
          if ((unint64_t)v87 <= v84) {
            goto LABEL_319;
          }
          uint64_t v111 = *((void *)v77 + 4) + v109;
          if (!*(void *)(v111 + 48)) {
            goto LABEL_320;
          }
          re::DynamicArray<re::GeomMesh>::operator=(*(void *)(v111 + 64) + 32, (uint64_t)buf);
          long long v87 = (unsigned char *)*((void *)v77 + 2);
          if ((unint64_t)v87 <= v84) {
            goto LABEL_321;
          }
          uint64_t v112 = *((void *)v77 + 4) + v109;
          if (!*(void *)(v112 + 48)) {
            goto LABEL_322;
          }
          re::DynamicArray<re::RigComponentConstraint>::operator=(*(void *)(v112 + 64) + 72, (uint64_t)&v217);
          if ((void)v217 && (void)v219) {
            (*(void (**)(void))(*(void *)v217 + 40))();
          }
          re::DynamicArray<re::GeomMesh>::deinit((uint64_t)buf);
          ++v84;
          v109 += 152;
          if (v108 == v84) {
            goto LABEL_74;
          }
        }
LABEL_317:
        *(void *)&long long v270 = 0;
        long long v251 = 0u;
        long long v250 = 0u;
        long long v249 = 0u;
        long long v248 = 0u;
        long long v247 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v205 = 136315906;
        float32x4_t v206 = "operator[]";
        __int16 v207 = 1024;
        *(_DWORD *)float32x4_t v208 = 789;
        *(_WORD *)&v208[4] = 2048;
        *(void *)&v208[6] = v84;
        *(_WORD *)&v208[14] = 2048;
        *(void *)&v208[16] = v87;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_318:
        *(void *)&long long v270 = 0;
        long long v251 = 0u;
        long long v250 = 0u;
        long long v249 = 0u;
        long long v248 = 0u;
        long long v247 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v205 = 136315906;
        float32x4_t v206 = "operator[]";
        __int16 v207 = 1024;
        *(_DWORD *)float32x4_t v208 = 789;
        *(_WORD *)&v208[4] = 2048;
        *(void *)&v208[6] = 0;
        *(_WORD *)&v208[14] = 2048;
        *(void *)&v208[16] = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_319:
        *(void *)&long long v270 = 0;
        long long v251 = 0u;
        long long v250 = 0u;
        long long v249 = 0u;
        long long v248 = 0u;
        long long v247 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v205 = 136315906;
        float32x4_t v206 = "operator[]";
        __int16 v207 = 1024;
        *(_DWORD *)float32x4_t v208 = 789;
        *(_WORD *)&v208[4] = 2048;
        *(void *)&v208[6] = v84;
        *(_WORD *)&v208[14] = 2048;
        *(void *)&v208[16] = v87;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_320:
        *(void *)&long long v270 = 0;
        long long v251 = 0u;
        long long v250 = 0u;
        long long v249 = 0u;
        long long v248 = 0u;
        long long v247 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v205 = 136315906;
        float32x4_t v206 = "operator[]";
        __int16 v207 = 1024;
        *(_DWORD *)float32x4_t v208 = 789;
        *(_WORD *)&v208[4] = 2048;
        *(void *)&v208[6] = 0;
        *(_WORD *)&v208[14] = 2048;
        *(void *)&v208[16] = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_321:
        *(void *)&long long v270 = 0;
        long long v251 = 0u;
        long long v250 = 0u;
        long long v249 = 0u;
        long long v248 = 0u;
        long long v247 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v205 = 136315906;
        float32x4_t v206 = "operator[]";
        __int16 v207 = 1024;
        *(_DWORD *)float32x4_t v208 = 789;
        *(_WORD *)&v208[4] = 2048;
        *(void *)&v208[6] = v84;
        *(_WORD *)&v208[14] = 2048;
        *(void *)&v208[16] = v87;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_322:
        *(void *)&long long v270 = 0;
        long long v251 = 0u;
        long long v250 = 0u;
        long long v249 = 0u;
        long long v248 = 0u;
        long long v247 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v205 = 136315906;
        float32x4_t v206 = "operator[]";
        __int16 v207 = 1024;
        *(_DWORD *)float32x4_t v208 = 789;
        *(_WORD *)&v208[4] = 2048;
        *(void *)&v208[6] = 0;
        *(_WORD *)&v208[14] = 2048;
        *(void *)&v208[16] = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_323:
        uint64_t v204 = 0;
        long long v273 = v124;
        long long v274 = v124;
        long long v271 = v124;
        long long v272 = v124;
        long long v270 = v124;
        unint64_t v152 = v125;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v262 = 136315906;
        float32x4_t v263 = "operator[]";
        __int16 v264 = 1024;
        int v265 = 797;
        __int16 v266 = 2048;
        unint64_t v267 = v152;
        __int16 v268 = 2048;
        unint64_t v269 = v84;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
    }
  }
LABEL_74:
  if (!v192[0] && v194 && (v195 & 1) != 0) {
    (*(void (**)(void))(*(void *)v194 + 40))();
  }
  if (v197 && (v198 & 1) != 0) {
    (*(void (**)(void))(*(void *)v197 + 40))();
  }
  if (v199 && (v200 & 1) != 0) {
    (*(void (**)(void))(*(void *)v199 + 40))();
  }
  re::DynamicArray<re::ObjCObject>::deinit((uint64_t)v201);

  return 1;
}

void re::anonymous namespace'::traverseTransformHierarchy(void *a1, uint64_t a2, uint64_t *a3, float32x4_t *a4, uint64_t a5, re::DynamicString *a6, int a7)
{
  uint64_t v162 = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  uint64_t v153 = 0;
  uint64_t v154 = 0;
  uint64_t v155 = 0;
  re::DynamicString::setCapacity(&v152, 0);
  id v13 = [(_anonymous_namespace_ *)v12 name];
  uint64_t v14 = [v13 UTF8String];

  if (v14)
  {
    id v15 = [(_anonymous_namespace_ *)v12 name];
    v138.i64[0] = [v15 UTF8String];
    v138.i64[1] = strlen((const char *)v138.i64[0]);
    re::DynamicString::operator=((re::DynamicString *)&v152, (uint64_t)&v138);
  }
  else
  {
    id v15 = [MEMORY[0x263F08C38] UUID];
    id v16 = [v15 UUIDString];
    re::DynamicString::assignf((re::DynamicString *)&v152, "Untitled MDLObject %s", (const char *)[v16 UTF8String]);
  }
  uint64_t v17 = (_anonymous_namespace_ *)re::DynamicArray<MDLObject * {__strong}>::DynamicArray((uint64_t)&v147, a3);
  unint64_t v18 = v149;
  if (v149 >= v148)
  {
    if (v148 < v149 + 1)
    {
      if (v147)
      {
        unint64_t v19 = 8;
        if (v148) {
          unint64_t v19 = 2 * v148;
        }
        if (v19 <= v149 + 1) {
          unint64_t v20 = v149 + 1;
        }
        else {
          unint64_t v20 = v19;
        }
        re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity(&v147, v20);
      }
      else
      {
        re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity(&v147, v18 + 1);
        ++v150;
      }
    }
    unint64_t v18 = v149;
  }
  uint64_t v21 = v151;
  uint64_t v22 = v12;
  *(void *)(v21 + 8 * v18) = v22;
  ++v149;
  ++v150;
  uint64_t v23 = [(_anonymous_namespace_ *)v22 transform];
  int v24 = v23;
  if (v23)
  {
    [v23 matrix];
    unint64_t v25 = 0;
    float32x4_t v26 = *a4;
    float32x4_t v27 = a4[1];
    float32x4_t v28 = a4[2];
    float32x4_t v29 = a4[3];
    float32x4_t v156 = v30;
    float32x4_t v157 = v31;
    float32x4_t v158 = v32;
    float32x4_t v159 = v33;
    do
    {
      *(float32x4_t *)((char *)&v138 + v25) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v26, COERCE_FLOAT(*(_OWORD *)((char *)&v156 + v25))), v27, *(float32x2_t *)&v156.f32[v25 / 4], 1), v28, *(float32x4_t *)((char *)&v156 + v25), 2), v29, *(float32x4_t *)((char *)&v156 + v25), 3);
      v25 += 16;
    }
    while (v25 != 64);
    float32x4_t v156 = v138;
    float32x4_t v157 = (float32x4_t)v139;
    float32x4_t v158 = *(float32x4_t *)v140;
    float32x4_t v159 = v141;
  }
  else
  {
    float32x4_t v34 = a4[1];
    float32x4_t v156 = *a4;
    float32x4_t v157 = v34;
    float32x4_t v35 = a4[3];
    float32x4_t v158 = a4[2];
    float32x4_t v159 = v35;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v37 = v22;
    int v38 = v37;
    unint64_t v39 = *(void *)a2;
    unint64_t v40 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * ((unint64_t)v37 ^ ((unint64_t)v37 >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                                              * ((unint64_t)v37 ^ ((unint64_t)v37 >> 30))) >> 27));
    unint64_t v41 = v40 ^ (v40 >> 31);
    int v126 = a7;
    float32x4_t v127 = v24;
    unint64_t v125 = v37;
    if (*(void *)a2)
    {
      unint64_t v39 = v41 % *(unsigned int *)(a2 + 24);
      uint64_t v42 = *(void *)(a2 + 8);
      uint64_t v43 = *(unsigned int *)(v42 + 4 * v39);
      if (v43 != 0x7FFFFFFF)
      {
        uint64_t v68 = *(void *)(a2 + 16);
        if (*(uint64_t **)(v68 + (v43 << 6) + 16) == v37)
        {
LABEL_47:
          uint64_t v46 = v68 + (v43 << 6) + 24;
LABEL_58:
          float32x4_t v138 = 0u;
          long long v139 = 0u;
          re::DynamicString::setCapacity(&v138, 0);
          uint64_t v142 = 0;
          v140[1] = 0;
          v141.i64[0] = 0;
          v140[0] = 0;
          v141.i32[2] = 0;
          float32x4_t v143 = 0u;
          float32x4_t v144 = 0u;
          float32x4_t v145 = 0u;
          float32x4_t v146 = 0u;
          re::DynamicArray<objc_object  {objcproto8DRBuffer}* {__strong}>::operator=((uint64_t)v140, (uint64_t *)&v147);
          re::DynamicString::operator=((re::DynamicString *)&v138, a6);
          float32x4_t v143 = v156;
          float32x4_t v144 = v157;
          float32x4_t v145 = v158;
          float32x4_t v146 = v159;
          unint64_t v82 = *(void *)(a5 + 8);
          uint64_t v83 = *(const char **)(a5 + 16);
          uint64_t v84 = v82 & 1;
          if (v82) {
            unint64_t v85 = *(const char **)(a5 + 16);
          }
          else {
            unint64_t v85 = (const char *)(a5 + 9);
          }
          id v86 = (_anonymous_namespace_ *)strncmp(v85, "mdl__", 5uLL);
          if (v86
            || ((v138.i8[8] & 1) != 0
              ? (unint64_t v90 = (unint64_t)v138.i64[1] >> 1)
              : (unint64_t v90 = v138.i8[8] >> 1),
                !v90))
          {
            if (v138.i8[8]) {
              unint64_t v87 = (unint64_t)v138.i64[1] >> 1;
            }
            else {
              unint64_t v87 = v138.i8[8] >> 1;
            }
            if (v87)
            {
              re::DynamicString::append((re::DynamicString *)&v138, ":", 1uLL);
              unint64_t v82 = *(void *)(a5 + 8);
              uint64_t v83 = *(const char **)(a5 + 16);
              uint64_t v84 = v82 & 1;
            }
            if (v84) {
              id v88 = v83;
            }
            else {
              id v88 = (const char *)(a5 + 9);
            }
            if (v84) {
              size_t v89 = v82 >> 1;
            }
            else {
              size_t v89 = v82 >> 1;
            }
            id v86 = (_anonymous_namespace_ *)re::DynamicString::append((re::DynamicString *)&v138, v88, v89);
          }
          unint64_t v91 = *(void *)(v46 + 8);
          unint64_t v92 = *(void *)(v46 + 16);
          unint64_t v93 = v92 + 1;
          if (v92 >= v91 && v91 < v93)
          {
            if (*(void *)v46)
            {
              uint64_t v118 = 2 * v91;
              BOOL v119 = v91 == 0;
              unint64_t v120 = 8;
              if (!v119) {
                unint64_t v120 = v118;
              }
              if (v120 <= v93) {
                unint64_t v121 = v93;
              }
              else {
                unint64_t v121 = v120;
              }
            }
            else
            {
              ++*(_DWORD *)(v46 + 24);
            }
          }
          uint64_t v95 = (re::DynamicString *)(*(void *)(v46 + 32) + 144 * *(void *)(v46 + 16));
          re::DynamicString::DynamicString(v95, (const re::DynamicString *)&v138);
          re::DynamicArray<MDLObject * {__strong}>::DynamicArray((uint64_t)v95 + 32, (uint64_t *)v140);
          float32x4_t v96 = v143;
          float32x4_t v97 = v144;
          float32x4_t v98 = v146;
          *((float32x4_t *)v95 + 7) = v145;
          *((float32x4_t *)v95 + 8) = v98;
          *((float32x4_t *)v95 + 5) = v96;
          *((float32x4_t *)v95 + 6) = v97;
          ++*(void *)(v46 + 16);
          ++*(_DWORD *)(v46 + 24);
          re::DynamicArray<re::ObjCObject>::deinit((uint64_t)v140);
          if (v138.i64[0] && (v138.i8[8] & 1) != 0) {
            (*(void (**)(void))(*(void *)v138.i64[0] + 40))();
          }

          a7 = v126;
          int v24 = v127;
          goto LABEL_87;
        }
        while (1)
        {
          uint64_t v43 = *(_DWORD *)(v68 + (v43 << 6) + 8) & 0x7FFFFFFF;
          if (v43 == 0x7FFFFFFF) {
            break;
          }
          if (*(uint64_t **)(v68 + (v43 << 6) + 16) == v37) {
            goto LABEL_47;
          }
        }
      }
      v140[0] = 0;
      *(void *)&long long v139 = 0;
      float32x4_t v138 = 0uLL;
      DWORD2(v139) = 0;
      uint64_t v44 = *(unsigned int *)(v42 + 4 * v39);
      if (v44 != 0x7FFFFFFF)
      {
        uint64_t v45 = *(void *)(a2 + 16);
        if (*(uint64_t **)(v45 + (v44 << 6) + 16) == v37)
        {
LABEL_27:
          uint64_t v46 = v45 + (v44 << 6) + 24;
LABEL_57:
          goto LABEL_58;
        }
        while (1)
        {
          uint64_t v44 = *(_DWORD *)(v45 + (v44 << 6) + 8) & 0x7FFFFFFF;
          if (v44 == 0x7FFFFFFF) {
            break;
          }
          if (*(uint64_t **)(v45 + (v44 << 6) + 16) == v37) {
            goto LABEL_27;
          }
        }
      }
    }
    else
    {
      v140[0] = 0;
      *(void *)&long long v139 = 0;
      float32x4_t v138 = 0uLL;
      DWORD2(v139) = 0;
    }
    uint64_t v47 = *(unsigned int *)(a2 + 36);
    if (v47 == 0x7FFFFFFF)
    {
      uint64_t v47 = *(unsigned int *)(a2 + 32);
      int v48 = v47;
      if (v47 == *(_DWORD *)(a2 + 24))
      {
        LODWORD(v39) = v41 % *(unsigned int *)(a2 + 24);
        int v48 = *(_DWORD *)(a2 + 32);
      }
      *(_DWORD *)(a2 + 32) = v48 + 1;
      uint64_t v49 = *(void *)(a2 + 16);
      int v50 = *(_DWORD *)(v49 + (v47 << 6) + 8);
    }
    else
    {
      uint64_t v49 = *(void *)(a2 + 16);
      int v50 = *(_DWORD *)(v49 + (v47 << 6) + 8);
      *(_DWORD *)(a2 + 36) = v50 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v49 + (v47 << 6) + 8) = v50 | 0x80000000;
    uint64_t v51 = v39;
    *(_DWORD *)(*(void *)(a2 + 16) + (v47 << 6) + 8) = *(_DWORD *)(*(void *)(a2 + 16) + (v47 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a2 + 8) + 4 * v39);
    *(void *)(*(void *)(a2 + 16) + (v47 << 6)) = v41;
    uint64_t v52 = *(void *)(a2 + 16) + (v47 << 6);
    *(void *)(v52 + 16) = v38;
    uint64_t v53 = *(void *)(a2 + 16) + (v47 << 6);
    *(void *)(v53 + 24) = 0;
    int v54 = (void *)(v53 + 24);
    *(void *)(v53 + 40) = 0;
    uint64_t v55 = (uint64_t *)(v53 + 40);
    *(void *)(v53 + 56) = 0;
    uint64_t v56 = (re::DynamicString **)(v53 + 56);
    *(void *)(v53 + 32) = 0;
    *(_DWORD *)(v53 + 48) = 0;
    if (v138.i64[0])
    {
      unint64_t v57 = v139;
      *int v54 = v138.i64[0];
      ++*(_DWORD *)(v53 + 48);
      uint64_t v58 = v139;
      uint64_t v59 = *v55;
      uint64_t v123 = v51;
      uint64_t v124 = v139;
      __int32 v122 = v54 + 2;
      if ((unint64_t)v139 >= *v55)
      {
        unint64_t v69 = v140[0];
        uint64_t v70 = *v55;
        unint64_t v71 = *v56;
        if (*v55)
        {
          uint64_t v72 = 144 * v70;
          do
          {
            re::DynamicString::operator=(v71, v69);
            re::DynamicArray<objc_object  {objcproto8DRBuffer}* {__strong}>::operator=((uint64_t)v71 + 32, (uint64_t *)v69 + 4);
            long long v73 = *((_OWORD *)v69 + 5);
            long long v74 = *((_OWORD *)v69 + 6);
            long long v75 = *((_OWORD *)v69 + 8);
            *((_OWORD *)v71 + 7) = *((_OWORD *)v69 + 7);
            *((_OWORD *)v71 + 8) = v75;
            *((_OWORD *)v71 + 5) = v73;
            *((_OWORD *)v71 + 6) = v74;
            unint64_t v69 = (re::DynamicString *)((char *)v69 + 144);
            unint64_t v71 = (re::DynamicString *)((char *)v71 + 144);
            v72 -= 144;
          }
          while (v72);
          unint64_t v71 = *v56;
          uint64_t v70 = *v55;
          unint64_t v69 = v140[0];
          uint64_t v58 = v124;
        }
        if (v70 != v58)
        {
          uint64_t v76 = 144 * v70;
          uint64_t v77 = 144 * v124;
          do
          {
            unint64_t v78 = (_OWORD *)((char *)v71 + v76);
            re::DynamicString::DynamicString((re::DynamicString *)((char *)v71 + v76), (re::DynamicString *)((char *)v69 + v76));
            re::DynamicArray<MDLObject * {__strong}>::DynamicArray((uint64_t)v71 + v76 + 32, (uint64_t *)((char *)v69 + v76 + 32));
            long long v79 = *(_OWORD *)((char *)v69 + v76 + 80);
            long long v80 = *(_OWORD *)((char *)v69 + v76 + 96);
            long long v81 = *(_OWORD *)((char *)v69 + v76 + 128);
            v78[7] = *(_OWORD *)((char *)v69 + v76 + 112);
            v78[8] = v81;
            v78[5] = v79;
            v78[6] = v80;
            unint64_t v69 = (re::DynamicString *)((char *)v69 + 144);
            v77 -= 144;
            unint64_t v71 = (re::DynamicString *)((char *)v71 + 144);
          }
          while (v76 != v77);
        }
      }
      else
      {
        uint64_t v60 = *v56;
        if ((void)v139)
        {
          uint64_t v61 = v140[0];
          uint64_t v62 = 144 * v139;
          do
          {
            re::DynamicString::operator=(v60, v61);
            re::DynamicArray<objc_object  {objcproto8DRBuffer}* {__strong}>::operator=((uint64_t)v60 + 32, (uint64_t *)v61 + 4);
            long long v63 = *((_OWORD *)v61 + 5);
            long long v64 = *((_OWORD *)v61 + 6);
            long long v65 = *((_OWORD *)v61 + 8);
            *((_OWORD *)v60 + 7) = *((_OWORD *)v61 + 7);
            *((_OWORD *)v60 + 8) = v65;
            *((_OWORD *)v60 + 5) = v63;
            *((_OWORD *)v60 + 6) = v64;
            uint64_t v61 = (re::DynamicString *)((char *)v61 + 144);
            uint64_t v60 = (re::DynamicString *)((char *)v60 + 144);
            v62 -= 144;
          }
          while (v62);
          uint64_t v60 = *v56;
          uint64_t v59 = *v55;
          uint64_t v58 = v124;
        }
        if (v58 != v59)
        {
          uint64_t v66 = (re::DynamicString *)((char *)v60 + 144 * v124);
          uint64_t v67 = 144 * v59 - 144 * v124;
          do
          {
            re::DynamicArray<re::ObjCObject>::deinit((uint64_t)v66 + 32);
            re::DynamicString::deinit(v66);
            uint64_t v66 = (re::DynamicString *)((char *)v66 + 144);
            v67 -= 144;
          }
          while (v67);
        }
      }
      uint64_t v51 = v123;
      void *v122 = v124;
    }
    *(_DWORD *)(*(void *)(a2 + 8) + 4 * v51) = v47;
    ++*(_DWORD *)(a2 + 28);
    ++*(_DWORD *)(a2 + 40);
    uint64_t v46 = *(void *)(a2 + 16) + ((unint64_t)v47 << 6) + 24;
    goto LABEL_57;
  }
LABEL_87:
  if (!re::objectIsBlendShapeRoot(v22, v36))
  {
    long long v99 = [(_anonymous_namespace_ *)v22 instance];
    if (v99)
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v138, a6);
      if (v138.i8[8]) {
        unint64_t v100 = (unint64_t)v138.i64[1] >> 1;
      }
      else {
        unint64_t v100 = v138.i8[8] >> 1;
      }
      if (v100) {
        re::DynamicString::append((re::DynamicString *)&v138, ":", 1uLL);
      }
      unint64_t v101 = *(void *)(a5 + 8);
      if (v101) {
        uint64_t v102 = *(const char **)(a5 + 16);
      }
      else {
        uint64_t v102 = (const char *)(a5 + 9);
      }
      size_t v103 = v101 >> 1;
      size_t v104 = v101 >> 1;
      if (*(void *)(a5 + 8)) {
        size_t v105 = v103;
      }
      else {
        size_t v105 = v104;
      }
      re::DynamicString::append((re::DynamicString *)&v138, v102, v105);
      if (v138.i64[0] && (v138.i8[8] & 1) != 0) {
        (*(void (**)(void))(*(void *)v138.i64[0] + 40))();
      }
    }
    else
    {
      float32x4_t v128 = v24;
      size_t v106 = [(_anonymous_namespace_ *)v22 componentConformingToProtocol:&unk_26E75F868];
      __n128 v107 = v106;
      if (v106)
      {
        long long v136 = 0u;
        long long v137 = 0u;
        long long v134 = 0u;
        long long v135 = 0u;
        uint64_t v108 = [v106 countByEnumeratingWithState:&v134 objects:v161 count:16];
        if (v108)
        {
          uint64_t v109 = v108;
          uint64_t v110 = *(void *)v135;
          do
          {
            for (uint64_t i = 0; i != v109; ++i)
            {
              if (*(void *)v135 != v110) {
                objc_enumerationMutation(v107);
              }
            }
            uint64_t v109 = [v107 countByEnumeratingWithState:&v134 objects:v161 count:16];
          }
          while (v109);
        }
      }
      long long v132 = 0u;
      long long v133 = 0u;
      long long v130 = 0u;
      long long v131 = 0u;
      uint64_t v112 = [(_anonymous_namespace_ *)v22 children];
      uint64_t v113 = [v112 countByEnumeratingWithState:&v130 objects:v160 count:16];
      if (v113)
      {
        uint64_t v114 = v113;
        uint64_t v115 = *(void *)v131;
        uint64_t v116 = (a7 + 1);
        do
        {
          for (uint64_t j = 0; j != v114; ++j)
          {
            if (*(void *)v131 != v115) {
              objc_enumerationMutation(v112);
            }
          }
          uint64_t v114 = [v112 countByEnumeratingWithState:&v130 objects:v160 count:16];
        }
        while (v114);
      }

      int v24 = v128;
    }
  }
  re::DynamicArray<re::ObjCObject>::deinit((uint64_t)&v147);
  if (v152 && (v153 & 1) != 0) {
    (*(void (**)(void))(*v152 + 40))();
  }
}

void re::collectMeshMaterialsFromMDLMesh(id *a1, uint64_t a2, int a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (a3) {
    BOOL v5 = [*a1 subdivisionScheme] == 1;
  }
  else {
    BOOL v5 = 0;
  }
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v6 = [*a1 submeshes];
  uint64_t v7 = [v6 countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v25;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v25 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = [*(id *)(*((void *)&v24 + 1) + 8 * i) material];
        uint64_t v12 = v11;
        if (v11)
        {
          id v13 = [v11 name];

          if (v13)
          {
            id v14 = [v12 name];
            id v15 = (const char *)[v14 UTF8String];
          }
          else
          {
            id v15 = "missingMaterial.rematerialdefinition";
          }
          uint64_t v21 = 0;
          BOOL v23 = 0;
          id v16 = re::ObjCObject::operator=(&v21, v12);
          int v22 = *(_DWORD *)(a2 + 28);
          BOOL v23 = v5;
          v19[0] = v5;
          re::DynamicString::DynamicString((re::DynamicString *)v20, (const re::DynamicString *)&v17);
          re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfo&>(a2, v19, (uint64_t)&v21);
          if (v20[0])
          {
            if (v20[1]) {
              (*(void (**)(void))(*(void *)v20[0] + 40))();
            }
            memset(v20, 0, sizeof(v20));
          }
          if (v17 && (v18 & 1) != 0) {
            (*(void (**)(void))(*(void *)v17 + 40))();
          }
        }
      }
      uint64_t v8 = [v6 countByEnumeratingWithState:&v24 objects:v28 count:16];
    }
    while (v8);
  }
}

uint64_t *re::HashTable<MDLMesh * {__strong},re::DynamicArray<re::anonymous namespace'::Instance>,re::Hash<MDLMesh * {__strong}>,re::EqualTo<MDLMesh * {__strong}>,true,false>::~HashTable(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2] + v4;
        int v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;

          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 64;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return a1;
}

uint64_t re::GeomScene::setSkeletons(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = (_anonymous_namespace_ *)(result + 80);
  unint64_t v5 = *(void *)(a2 + 8);
  if (*(void *)(result + 88) < v5)
  {
    double result = (uint64_t)re::DynamicArray<re::GeomSkeleton>::setCapacity((void *)(result + 80), v5);
    unint64_t v5 = *(void *)(a2 + 8);
  }
  if (v5)
  {
    uint64_t v6 = *(StringID **)a2;
    uint64_t v7 = 168 * v5;
    do
    {
      re::GeomSkeleton::fromSkeleton(v6, v9);
      re::DynamicArray<re::GeomSkeleton>::add(v4, v9);
      v8.n128_f64[0] = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v20);
      if (v17)
      {
        if (v18)
        {
          (*(void (**)(double))(*(void *)v17 + 40))(v8.n128_f64[0]);
          uint64_t v18 = 0;
          uint64_t v19 = 0;
        }
        uint64_t v17 = 0;
      }
      if (v14)
      {
        if (v15)
        {
          (*(void (**)(__n128))(*(void *)v14 + 40))(v8);
          uint64_t v15 = 0;
          uint64_t v16 = 0;
        }
        uint64_t v14 = 0;
      }
      if (v11)
      {
        if (v12)
        {
          (*(void (**)(__n128))(*(void *)v11 + 40))(v8);
          uint64_t v12 = 0;
          uint64_t v13 = 0;
        }
        uint64_t v11 = 0;
      }
      re::FixedArray<re::StringID>::deinit(v10);
      re::StringID::destroyString((re::StringID *)v9);
      LODWORD(v9[0]) = *(_DWORD *)(v3 + 96) - 1;
      double result = re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<unsigned int &>(v3 + 120, v6, v9);
      uint64_t v6 = (StringID *)((char *)v6 + 168);
      v7 -= 168;
    }
    while (v7);
  }
  return result;
}

void re::anonymous namespace'::convertMdlMeshToGeomModel(uint64_t a1, id *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v111 = *MEMORY[0x263EF8340];
  re::GeomModel::GeomModel((re::GeomModel *)a1);
  id v11 = *a2;
  uint64_t v12 = [v11 name];

  id v89 = v11;
  if (!v12) {
    goto LABEL_16;
  }
  id v13 = [v11 name];
  uint64_t v14 = (_anonymous_namespace_ *)[v13 UTF8String];
  re::DynamicString::rfind((uint64_t)buf, "_blendShape", &v100);
  if (*(void *)buf)
  {
    if (buf[8]) {
      (*(void (**)(void))(**(void **)buf + 40))();
    }
    *(_OWORD *)long long buf = 0u;
    long long v107 = 0u;
  }

  if (!(_BYTE)v100)
  {
LABEL_16:
    float32x4_t v96 = 0;
    goto LABEL_31;
  }
  uint64_t v90 = a5;
  unint64_t v92 = a2;
  int v94 = a6;
  uint64_t v15 = [v11 children];
  uint64_t v16 = [v15 count];

  if (v16)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = [v11 children];
      uint64_t v19 = [v18 objectAtIndexedSubscript:v17];
      id v20 = [v19 name];
      uint64_t v21 = (_anonymous_namespace_ *)[v20 UTF8String];

      re::DynamicString::rfind((uint64_t)buf, "_blendTargets", &v100);
      if ((_BYTE)v100) {
        break;
      }
      if (*(void *)buf && (buf[8] & 1) != 0) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
      if (v16 == ++v17)
      {
        id v22 = 0;
LABEL_15:
        id v11 = v89;
        goto LABEL_29;
      }
    }
    BOOL v23 = [v11 children];
    id v22 = [v23 objectAtIndexedSubscript:v17];

    if (*(void *)buf && (buf[8] & 1) != 0) {
      (*(void (**)(void))(**(void **)buf + 40))();
    }
    if (v22)
    {
      uint64_t v97 = [v11 vertexCount];
      long long v24 = [v11 submeshes];
      uint64_t v25 = [v24 count];

      long long v26 = [v22 children];
      uint64_t v27 = [v26 count];

      if (!v27) {
        goto LABEL_15;
      }
      uint64_t v28 = 0;
      while (1)
      {
        uint64_t v29 = [v22 children];
        float32x4_t v30 = [v29 objectAtIndexedSubscript:v28];
        objc_opt_class();
        char isKindOfClass = objc_opt_isKindOfClass();

        if ((isKindOfClass & 1) == 0) {
          break;
        }
        float32x4_t v33 = [v22 children];
        float32x4_t v34 = [v33 objectAtIndexedSubscript:v28];

        float32x4_t v35 = [v34 submeshes];
        uint64_t v36 = [v35 count];

        if (v36 != v25)
        {
          long long v80 = *re::pipelineLogObjects(v37);
          if (!os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
          {
LABEL_111:

            float32x4_t v96 = 0;
            id v11 = v89;
            goto LABEL_30;
          }
          *(_WORD *)long long buf = 0;
          long long v81 = "Invalid blend shape definition: Submesh count does not match between target and base.";
LABEL_113:
          _os_log_error_impl(&dword_233120000, v80, OS_LOG_TYPE_ERROR, v81, buf, 2u);
          goto LABEL_111;
        }
        int v38 = (re *)[v34 vertexCount];
        if (v38 != (re *)v97)
        {
          long long v80 = *re::pipelineLogObjects(v38);
          if (!os_log_type_enabled(v80, OS_LOG_TYPE_ERROR)) {
            goto LABEL_111;
          }
          *(_WORD *)long long buf = 0;
          long long v81 = "Invalid blend shape definition: Vertex count does not match between target and base.";
          goto LABEL_113;
        }

        if (v27 == ++v28) {
          goto LABEL_15;
        }
      }
      long long v79 = *re::pipelineLogObjects(v32);
      id v11 = v89;
      if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl(&dword_233120000, v79, OS_LOG_TYPE_ERROR, "Blend shape targets must be meshes.", buf, 2u);
      }
      float32x4_t v96 = 0;
      goto LABEL_30;
    }
  }
  else
  {
    id v22 = 0;
  }
LABEL_29:
  id v22 = v22;
  float32x4_t v96 = v22;
LABEL_30:
  a5 = v90;

  a6 = v94;
  a2 = v92;
LABEL_31:

  unint64_t v39 = [v11 name];
  if (v39)
  {
    id v40 = [v11 name];
    unint64_t v41 = (const char *)[v40 UTF8String];
    size_t v42 = strlen(v41);
    *(void *)long long buf = v41;
    *(void *)&uint8_t buf[8] = v42;
    re::DynamicString::operator=((re::DynamicString *)a1, (uint64_t)buf);
  }
  else
  {
    *(void *)long long buf = "";
    *(void *)&uint8_t buf[8] = 0;
    re::DynamicString::operator=((re::DynamicString *)a1, (uint64_t)buf);
  }

  uint64_t v43 = [v11 submeshes];
  unsigned int v44 = [v43 count];

  id v88 = (void *)(a1 + 32);
  if (v44 <= 1) {
    unint64_t v45 = 1;
  }
  else {
    unint64_t v45 = v44;
  }
  if (*(void *)(a1 + 40) < v45) {
    re::DynamicArray<re::GeomMesh>::setCapacity(v88, v45);
  }
  if (a4)
  {
    if (a5) {
      BOOL v46 = *(void *)(a4 + 16) == 0;
    }
    else {
      BOOL v46 = 1;
    }
    int v47 = !v46;
    if (a6)
    {
LABEL_47:
      BOOL v95 = [*a2 subdivisionScheme] == 1;
      if (!v47) {
        goto LABEL_60;
      }
      goto LABEL_51;
    }
  }
  else
  {
    int v47 = 0;
    if (a6) {
      goto LABEL_47;
    }
  }
  BOOL v95 = 0;
  if (!v47)
  {
LABEL_60:
    uint64_t v91 = 0;
    uint64_t v83 = 0xFFFFFFFFLL;
    uint64_t v84 = 0;
    goto LABEL_61;
  }
LABEL_51:
  unint64_t v48 = *(void *)(a5 + 16);
  if (!v48) {
    goto LABEL_60;
  }
  unint64_t v49 = 0;
  uint64_t v50 = *(void *)(a5 + 32);
  if (*(unsigned char *)(a1 + 8)) {
    uint64_t v51 = *(const char **)(a1 + 16);
  }
  else {
    uint64_t v51 = (const char *)(a1 + 9);
  }
  while (1)
  {
    uint64_t v52 = (*(void *)(v50 + 80) & 1) != 0 ? *(const char **)(v50 + 88) : (const char *)(v50 + 81);
    if (!strcmp(v52, v51)) {
      break;
    }
    ++v49;
    v50 += 224;
    if (v48 == v49) {
      goto LABEL_60;
    }
  }
  if (v48 <= v49)
  {
    uint64_t v98 = 0;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v100 = 136315906;
    *(void *)unint64_t v101 = "operator[]";
    *(_WORD *)&v101[8] = 1024;
    *(_DWORD *)&v101[10] = 789;
    __int16 v102 = 2048;
    unint64_t v103 = v49;
    __int16 v104 = 2048;
    unint64_t v105 = v48;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_115:
    uint64_t v98 = 0;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v100 = 136315906;
    *(void *)unint64_t v101 = "operator[]";
    *(_WORD *)&v101[8] = 1024;
    *(_DWORD *)&v101[10] = 789;
    __int16 v102 = 2048;
    unint64_t v103 = v49;
    __int16 v104 = 2048;
    unint64_t v105 = v48;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  unint64_t v49 = *(unsigned int *)(v50 + 64);
  unint64_t v48 = *(void *)(a4 + 16);
  if (v48 <= v49) {
    goto LABEL_115;
  }
  uint64_t v83 = *(unsigned int *)(v50 + 64);
  uint64_t v84 = v50;
  uint64_t v91 = *(void *)(a4 + 32) + 168 * v49;
LABEL_61:
  unint64_t v82 = [v11 submeshes];
  uint64_t v86 = [v82 count];
  if (v86)
  {
    uint64_t v53 = 0;
    unint64_t v85 = (_anonymous_namespace_ *)(a1 + 72);
    do
    {
      int v54 = [v11 submeshes];
      uint64_t v55 = [v54 objectAtIndexedSubscript:v53];

      uint64_t v56 = [v55 name];
      if (v56)
      {
        id v57 = [v55 name];
        uint64_t v58 = (const char *)[v57 UTF8String];
      }
      else
      {
        uint64_t v58 = "";
      }

      uint64_t v59 = [v55 material];
      uint64_t v60 = [v59 name];
      unint64_t v93 = v59;
      if (v60)
      {
        id v61 = [v59 name];
        uint64_t v62 = (const char *)[v61 UTF8String];
      }
      else
      {
        uint64_t v62 = "missingMaterial.rematerialdefinition";
      }

      id v63 = v11;
      long long v64 = v96;
      long long v65 = [v63 submeshes];
      uint64_t v66 = [v65 objectAtIndexedSubscript:v53];

      re::internal::createGeomMeshFromMDLSubmesh((re::internal *)v63, v66, (re::GeomMesh *)buf);
      if (v91) {
        re::internal::attachSkinningDataToMesh(v63, v66, v91, v83, v84, (uint64_t)buf);
      }
      if (v96) {
        re::internal::attachNewBlendShapeDataIfItExistsToGeomMesh((re::internal *)v63, v64, v53, (uint64_t)buf, v68);
      }
      else {
        re::internal::attachBlendShapeDataIfItExistsToGeomMesh((re::internal *)v63, (const MDLMesh *)buf, v67);
      }
      if (v95) {
        re::internal::attachOpenSubdivDataToMesh((re::internal *)v63, v66, (MDLSubmesh *)buf, v69);
      }

      LOBYTE(v100) = v95;
      re::DynamicString::DynamicString((re::DynamicString *)&v101[4], (const re::DynamicString *)&v98);
      if (v98 && (v99 & 1) != 0) {
        (*(void (**)(void))(*(void *)v98 + 40))();
      }
      re::GeomMesh::setName((re *)buf, v58);
      unint64_t v71 = re::Hash<re::ImportMaterialSignature>::operator()((uint64_t)&v98, (char *)&v100);
      id v11 = v89;
      if (!*(void *)a3
        || (uint64_t v72 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (v71 % *(unsigned int *)(a3 + 24))),
            v72 == 0x7FFFFFFF))
      {
LABEL_85:
        LODWORD(v98) = 0;
        re::DynamicArray<int>::add(v85, &v98);
        goto LABEL_86;
      }
      uint64_t v73 = *(void *)(a3 + 16);
      int v74 = v100;
      while (*(unsigned __int8 *)(v73 + 72 * v72 + 16) != v74
           || !re::DynamicString::operator==(v73 + 72 * v72 + 24, (uint64_t)&v101[4]))
      {
        uint64_t v72 = *(_DWORD *)(v73 + 72 * v72 + 8) & 0x7FFFFFFF;
        if (v72 == 0x7FFFFFFF) {
          goto LABEL_85;
        }
      }
      unint64_t v75 = re::Hash<re::ImportMaterialSignature>::operator()((uint64_t)&v98, (char *)&v100);
      if (*(void *)a3)
      {
        uint64_t v76 = *(void *)(a3 + 16);
        uint64_t v77 = *(unsigned int *)(*(void *)(a3 + 8) + 4 * (v75 % *(unsigned int *)(a3 + 24)));
        if (v77 != 0x7FFFFFFF)
        {
          int v78 = v100;
          while (*(unsigned __int8 *)(v76 + 72 * v77 + 16) != v78
               || !re::DynamicString::operator==(v76 + 72 * v77 + 24, (uint64_t)&v101[4]))
          {
            uint64_t v77 = *(_DWORD *)(v76 + 72 * v77 + 8) & 0x7FFFFFFF;
            if (v77 == 0x7FFFFFFF) {
              goto LABEL_99;
            }
          }
          goto LABEL_100;
        }
      }
      else
      {
        uint64_t v76 = *(void *)(a3 + 16);
      }
LABEL_99:
      uint64_t v77 = 0x7FFFFFFFLL;
LABEL_100:
      re::DynamicArray<int>::add(v85, (_DWORD *)(v76 + 72 * v77 + 64));
LABEL_86:
      re::DynamicArray<re::GeomMesh>::add((uint64_t)v88, (uint64_t)buf);
      if (*(void *)&v101[4] && (v101[12] & 1) != 0) {
        (*(void (**)(void))(**(void **)&v101[4] + 40))();
      }
      re::GeomMesh::~GeomMesh((re::GeomMesh *)buf);

      uint64_t v53 = (const MDLObject *)((char *)v53 + 1);
    }
    while (v53 != (const MDLObject *)v86);
  }
}

uint64_t re::anonymous namespace'::consolidateMeshPartsWithSameMaterial<re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(unsigned int *)(a3 + 28);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v61 = 0;
  v58[1] = 0;
  unint64_t v59 = 0;
  uint64_t v57 = 0;
  v58[0] = 0;
  int v60 = 0;
  memset(v55, 0, sizeof(v55));
  int v56 = 0;
  if (!v10 || !v11)
  {
    re::DynamicArray<re::GeomMesh>::operator=((uint64_t)v58, a1);
    re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)v55, a2);
    goto LABEL_54;
  }
  int v53 = 0;
  memset(v52, 0, sizeof(v52));
  uint64_t v54 = 0x7FFFFFFFLL;
  id v13 = (_anonymous_namespace_ *)re::DynamicArray<re::GeomMesh>::setCapacity(v58, v11);
  uint64_t v14 = v10;
  if (!v15)
  {
LABEL_63:
    re::internal::assertLog((re::internal *)4, v16, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
  uint64_t v17 = v15;
  if (v10 != 1)
  {
    unint64_t v5 = v15;
    bzero(v15, v14 * 8 - 8);
    uint64_t v15 = v5;
    uint64_t v17 = &v5[v14 - 1];
  }
  *uint64_t v17 = 0;
  uint64_t v18 = *(unsigned int *)(a3 + 32);
  unint64_t v49 = v15;
  uint64_t v19 = 0;
  if (v18)
  {
    id v20 = (int *)(*(void *)(a3 + 16) + 8);
    while (1)
    {
      int v21 = *v20;
      v20 += 18;
      if (v21 < 0) {
        break;
      }
      if (v18 == ++v19)
      {
        LODWORD(v19) = *(_DWORD *)(a3 + 32);
        break;
      }
    }
  }
  if (v18 != v19)
  {
    uint64_t v22 = v19;
    uint64_t v23 = *(void *)(a3 + 16);
    do
    {
      uint64_t v24 = *(unsigned int *)(v23 + 72 * v22 + 64);
      if (v24 >= v10) {
        goto LABEL_60;
      }
      if (*(unsigned char *)(v23 + 72 * v22 + 32)) {
        uint64_t v25 = *(void *)(v23 + 72 * v22 + 40);
      }
      else {
        uint64_t v25 = v23 + 72 * v22 + 33;
      }
      v15[v24] = v25;
      uint64_t v23 = *(void *)(a3 + 16);
      if (v18 <= (int)v19 + 1) {
        int v26 = v19 + 1;
      }
      else {
        int v26 = v18;
      }
      while (1)
      {
        uint64_t v22 = (v19 + 1);
        if (v26 - 1 == v19) {
          break;
        }
        LODWORD(v19) = v19 + 1;
        int v27 = v22;
        if ((*(_DWORD *)(v23 + 72 * v22 + 8) & 0x80000000) != 0) {
          goto LABEL_24;
        }
      }
      int v27 = v26;
LABEL_24:
      LODWORD(v19) = v27;
    }
    while (v18 != v27);
  }
  uint64_t v46 = a5;
  int v47 = (void *)v10;
  uint64_t v45 = a4;
  unint64_t v28 = 0;
  if (v11 <= 1) {
    uint64_t v29 = 1;
  }
  else {
    uint64_t v29 = v11;
  }
  uint64_t v50 = v29;
  uint64_t v30 = a1;
  do
  {
    unint64_t v5 = *(void **)(v30 + 16);
    if ((unint64_t)v5 <= v28)
    {
      uint64_t v62 = 0;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v71 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      long long v64 = "operator[]";
      __int16 v65 = 1024;
      int v66 = 789;
      __int16 v67 = 2048;
      uint64_t v68 = (void *)v28;
      __int16 v69 = 2048;
      uint64_t v70 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_59:
      uint64_t v62 = 0;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v71 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      long long v64 = "operator[]";
      __int16 v65 = 1024;
      int v66 = 789;
      __int16 v67 = 2048;
      uint64_t v68 = (void *)v28;
      __int16 v69 = 2048;
      uint64_t v70 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_60:
      re::internal::assertLog((re::internal *)4, v16, "assertion failure: '%s' (%s:line %i) ", "(*it).value.index < materialCount", "consolidateMeshPartsWithSameMaterial", 437);
      _os_crash();
      __break(1u);
LABEL_61:
      uint64_t v62 = 0;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v71 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      long long v64 = "operator[]";
      __int16 v65 = 1024;
      int v66 = 789;
      __int16 v67 = 2048;
      uint64_t v68 = v5;
      __int16 v69 = 2048;
      uint64_t v70 = (void *)v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_62:
      uint64_t v62 = 0;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v71 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v63 = 136315906;
      long long v64 = "operator[]";
      __int16 v65 = 1024;
      int v66 = 468;
      __int16 v67 = 2048;
      uint64_t v68 = v5;
      __int16 v69 = 2048;
      uint64_t v70 = v47;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_63;
    }
    uint64_t v31 = *(void *)(v30 + 32);
    unsigned int v51 = 0;
    unint64_t v5 = *(void **)(a2 + 16);
    if ((unint64_t)v5 <= v28) {
      goto LABEL_59;
    }
    float32x4_t v32 = (_DWORD *)(v31 + 736 * v28);
    unsigned int v51 = *(_DWORD *)(*(void *)(a2 + 32) + 4 * v28);
    float32x4_t v34 = (unsigned int *)re::HashTable<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet((uint64_t)v52, &v51);
    unint64_t v6 = v32[50];
    if (!v6) {
      goto LABEL_44;
    }
    unsigned int v35 = 0;
    BOOL v36 = 1;
    do
    {
      uint64_t v37 = re::internal::GeomAttributeContainer::attributeByIndex((re::internal::GeomAttributeContainer *)(v32 + 44), v35);
      if (*(unsigned char *)(v37 + 17) == 7)
      {
        int v38 = *(const char **)(v37 + 8);
        size_t v39 = strlen(v38);
        if (v39 >= 0x15)
        {
          BOOL v40 = *(void *)&v38[v39 - 21] == 0x6154646E656C627CLL && *(void *)&v38[v39 - 13] == 0x44736F5074656772;
          if (v40 && *(void *)&v38[v39 - 8] == 0x7361746C6544736FLL) {
            break;
          }
        }
      }
      BOOL v36 = ++v35 < v6;
    }
    while (v6 != v35);
    uint64_t v30 = a1;
    if (!v36)
    {
LABEL_44:
      if (v34)
      {
        unint64_t v5 = (void *)*v34;
        unint64_t v6 = v59;
        if (v59 <= (unint64_t)v5) {
          goto LABEL_61;
        }
        size_t v42 = (const re::GeomMesh *)(v61 + 736 * v5);
        if (re::internal::canAppendGeomMeshToGeomMesh((re::internal *)v32, v42, v33))
        {
          re::internal::appendGeomMeshToGeomMesh(v32, (uint64_t)v42);
          goto LABEL_51;
        }
      }
      else
      {
        unint64_t v5 = (void *)v51;
        if (v10 <= v51) {
          goto LABEL_62;
        }
        re::GeomMesh::setName((re *)v32, (const char *)v49[v51]);
        LODWORD(v71) = v59;
        re::HashTable<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add((uint64_t)v52, &v51, &v71);
      }
    }
    re::DynamicArray<re::GeomMesh>::add((uint64_t)v58, (uint64_t)v32);
    re::DynamicArray<int>::add(v55, &v51);
LABEL_51:
    ++v28;
  }
  while (v28 != v50);
  double v43 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v52);
  a4 = v45;
  a5 = v46;
LABEL_54:
  re::DynamicArray<re::GeomMesh>::operator=(a4, (uint64_t)v58);
  re::DynamicArray<re::RigComponentConstraint>::operator=(a5, (uint64_t)v55);
  if (v55[0] && v57) {
    (*(void (**)(void))(*(void *)v55[0] + 40))();
  }
  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v58);
}

uint64_t re::convertMDLMeshToGeomModel(id *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  int v30 = 0;
  memset(v29, 0, sizeof(v29));
  uint64_t v31 = 0x7FFFFFFFLL;
  re::collectMeshMaterialsFromMDLMesh(a1, (uint64_t)v29, a5[4]);
  uint64_t v10 = [*a1 vertexAttributeDataForAttributeNamed:@"textureCoordinate"];

  if (v10) {
    BOOL v11 = *a5 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11) {
    [*a1 addTangentBasisForTextureCoordinateAttributeNamed:@"textureCoordinate" tangentAttributeNamed:@"tangent" bitangentAttributeNamed:@"bitangent"];
  }
  re::DynamicString::operator=((re::DynamicString *)a2, (re::DynamicString *)&v16);
  re::DynamicArray<re::GeomMesh>::operator=((uint64_t)(a2 + 32), (uint64_t)v20);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a2 + 72), (uint64_t)v21);
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=(a2 + 112, v24);
  re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=(a2 + 160, v26);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)(a2 + 208), (uint64_t)v28);
  re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v28);
  if (v26[0]) {
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v27);
  }
  if (v24[0]) {
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v25);
  }
  if (v21[0])
  {
    if (v23) {
      (*(void (**)(void))(*(void *)v21[0] + 40))();
    }
    uint64_t v23 = 0;
    memset(v21, 0, sizeof(v21));
    ++v22;
  }
  re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v20);
  if (v16 && (v17 & 1) != 0) {
    (*(void (**)(void))(*(void *)v16 + 40))();
  }
  if (a5[3])
  {
    v20[0] = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    int v19 = 0;
    memset(v13, 0, sizeof(v13));
    int v14 = 0;
    re::DynamicArray<re::GeomMesh>::operator=((uint64_t)(a2 + 32), (uint64_t)&v16);
    re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a2 + 72), (uint64_t)v13);
    if (v13[0] && v15) {
      (*(void (**)(void))(*(void *)v13[0] + 40))();
    }
    re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v16);
  }
  re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)v29);
  return 1;
}

uint64_t re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfo&>(uint64_t a1, char *a2, uint64_t a3)
{
  unint64_t v6 = re::Hash<re::ImportMaterialSignature>::operator()((uint64_t)&v15, a2);
  unint64_t v7 = v6;
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_9;
  }
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_9:
    unsigned int v12 = re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::addEmplace<re::MaterialInfo&>(a1, v8, v7, (re::DynamicString *)a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v13 = *(void *)(a1 + 16) + 72 * v12;
    return v13 + 56;
  }
  int v10 = *a2;
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(unsigned __int8 *)(v11 + 72 * v9 + 16) != v10
       || !re::DynamicString::operator==(v11 + 72 * v9 + 24, (uint64_t)(a2 + 8)))
  {
    uint64_t v9 = *(_DWORD *)(v11 + 72 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_9;
    }
  }
  uint64_t v13 = v11 + 72 * v9;
  return v13 + 56;
}

uint64_t *re::DynamicArray<re::anonymous namespace'::Instance>::~DynamicArray(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    uint64_t v3 = (re::DynamicString *)a1[4];
    if (v3)
    {
      uint64_t v4 = a1[2];
      if (v4)
      {
        uint64_t v5 = 144 * v4;
        do
        {
          re::DynamicArray<re::ObjCObject>::deinit((uint64_t)v3 + 32);
          re::DynamicString::deinit(v3);
          uint64_t v3 = (re::DynamicString *)((char *)v3 + 144);
          v5 -= 144;
        }
        while (v5);
        uint64_t v2 = *a1;
        uint64_t v3 = (re::DynamicString *)a1[4];
      }
      (*(void (**)(uint64_t, re::DynamicString *))(*(void *)v2 + 40))(v2, v3);
    }
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    ++*((_DWORD *)a1 + 6);
  }
  return a1;
}

uint64_t re::DynamicArray<MDLObject * {__strong}>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  if (*a2)
  {
    unint64_t v5 = a2[2];
    *(void *)a1 = v3;
    re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity((void *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<objc_object  {objcproto8DRBuffer}* {__strong}>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

void *re::DynamicArray<re::anonymous namespace'::Instance>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unint64_t v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x90uLL))
        {
          uint64_t v2 = 144 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 144 * a2, 16);
          if (result)
          {
            unint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 144, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      unint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 144 * v9;
        uint64_t v11 = v7;
        do
        {
          *(_OWORD *)uint64_t v11 = 0u;
          *((_OWORD *)v11 + 1) = 0u;
          v11[3] = *(void *)(v8 + 24);
          uint64_t v12 = *(void *)(v8 + 8);
          *uint64_t v11 = *(void *)v8;
          *(void *)uint64_t v8 = 0;
          uint64_t v13 = *(void *)(v8 + 16);
          *(void *)(v8 + 24) = 0;
          uint64_t v15 = v11[1];
          uint64_t v14 = v11[2];
          v11[1] = v12;
          void v11[2] = v13;
          *(void *)(v8 + 8) = v15;
          *(void *)(v8 + 16) = v14;
          unsigned __int8 v11[8] = 0;
          *((_DWORD *)v11 + 14) = 0;
          v11[5] = 0;
          v11[6] = 0;
          v11[4] = 0;
          uint64_t v16 = *(void *)(v8 + 40);
          v11[4] = *(void *)(v8 + 32);
          *(void *)(v8 + 32) = 0;
          v11[5] = v16;
          *(void *)(v8 + 40) = 0;
          uint64_t v17 = v11[6];
          v11[6] = *(void *)(v8 + 48);
          *(void *)(v8 + 48) = v17;
          uint64_t v18 = v11[8];
          unsigned __int8 v11[8] = *(void *)(v8 + 64);
          *(void *)(v8 + 64) = v18;
          ++*(_DWORD *)(v8 + 56);
          ++*((_DWORD *)v11 + 14);
          long long v19 = *(_OWORD *)(v8 + 80);
          long long v20 = *(_OWORD *)(v8 + 96);
          long long v21 = *(_OWORD *)(v8 + 128);
          *((_OWORD *)v11 + 7) = *(_OWORD *)(v8 + 112);
          *((_OWORD *)v11 + 8) = v21;
          *((_OWORD *)v11 + 5) = v19;
          *((_OWORD *)v11 + 6) = v20;
          re::DynamicArray<re::ObjCObject>::deinit(v8 + 32);
          re::DynamicString::deinit((re::DynamicString *)v8);
          v8 += 144;
          v11 += 18;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::HashTable<MDLMesh * {__strong},re::DynamicArray<re::anonymous namespace'::Instance>,re::Hash<MDLMesh * {__strong}>,re::EqualTo<MDLMesh * {__strong}>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(void *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      long long v5 = *(_OWORD *)v13;
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      uint64_t v6 = *(void *)&v13[16];
      uint64_t v7 = *(void *)(a1 + 16);
      *(void *)&v13[16] = v7;
      *(void *)(a1 + 16) = v6;
      long long v9 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v9;
      uint64_t v10 = v8;
      if (v8)
      {
        uint64_t v11 = (id *)(v7 + 16);
        do
        {
          if ((*(_DWORD *)(v11 - 1) & 0x80000000) != 0) {
          v11 += 8;
          }
          --v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    if (a2) {
      signed int v12 = a2;
    }
    else {
      signed int v12 = 3;
    }
  }
}

id re::HashTable<MDLMesh * {__strong},re::DynamicArray<re::anonymous namespace'::Instance>,re::Hash<MDLMesh * {__strong}>,re::EqualTo<MDLMesh * {__strong}>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, id *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + (v10 << 6) + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 8) = *(_DWORD *)(*(void *)(a1 + 16) + (v10 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + (v10 << 6)) = a3;
  uint64_t v14 = *(void *)(a1 + 16) + (v10 << 6);
  id result = *a4;
  *(void *)(v14 + 16) = result;
  uint64_t v16 = *(void *)(a1 + 16) + (v10 << 6);
  *(void *)(v16 + 56) = 0;
  *(_DWORD *)(v16 + 48) = 0;
  *(void *)(v16 + 32) = 0;
  *(void *)(v16 + 40) = 0;
  *(void *)(v16 + 24) = 0;
  uint64_t v17 = *(void *)(a5 + 8);
  *(void *)(v16 + 24) = *(void *)a5;
  *(void *)(v16 + 32) = v17;
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  uint64_t v18 = *(void *)(v16 + 40);
  *(void *)(v16 + 40) = *(void *)(a5 + 16);
  *(void *)(a5 + 16) = v18;
  uint64_t v19 = *(void *)(v16 + 56);
  *(void *)(v16 + 56) = *(void *)(a5 + 32);
  *(void *)(a5 + 32) = v19;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(v16 + 48);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

uint64_t *re::DynamicArray<re::GeomSkeleton>::add(_anonymous_namespace_ *this, uint64_t *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::GeomSkeleton>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t v5 = *((void *)this + 4) + 160 * v4;
  uint64_t v6 = *a2;
  *(void *)uint64_t v5 = *(void *)v5 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(void *)uint64_t v5 = *a2 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(void *)(v5 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)"";
  *(void *)(v5 + 16) = 0;
  *(void *)(v5 + 24) = 0;
  *(void *)(v5 + 32) = 0;
  uint64_t v7 = a2[3];
  *(void *)(v5 + 16) = a2[2];
  *(void *)(v5 + 24) = v7;
  a2[2] = 0;
  a2[3] = 0;
  uint64_t v8 = *(void *)(v5 + 32);
  *(void *)(v5 + 32) = a2[4];
  a2[4] = v8;
  *(void *)(v5 + 40) = 0;
  *(void *)(v5 + 48) = 0;
  *(void *)(v5 + 56) = 0;
  uint64_t v9 = a2[6];
  *(void *)(v5 + 40) = a2[5];
  *(void *)(v5 + 48) = v9;
  a2[5] = 0;
  a2[6] = 0;
  uint64_t v10 = *(void *)(v5 + 56);
  *(void *)(v5 + 56) = a2[7];
  a2[7] = v10;
  *(void *)(v5 + 64) = 0;
  *(void *)(v5 + 72) = 0;
  *(void *)(v5 + 80) = 0;
  uint64_t v11 = a2[9];
  *(void *)(v5 + 64) = a2[8];
  *(void *)(v5 + 72) = v11;
  a2[8] = 0;
  a2[9] = 0;
  uint64_t v12 = *(void *)(v5 + 80);
  *(void *)(v5 + 80) = a2[10];
  a2[10] = v12;
  *(void *)(v5 + 88) = 0;
  *(void *)(v5 + 96) = 0;
  *(void *)(v5 + 104) = 0;
  uint64_t v13 = a2[12];
  *(void *)(v5 + 88) = a2[11];
  *(void *)(v5 + 96) = v13;
  a2[11] = 0;
  a2[12] = 0;
  uint64_t v14 = *(void *)(v5 + 104);
  *(void *)(v5 + 104) = a2[13];
  a2[13] = v14;
  *(_OWORD *)(v5 + 112) = 0u;
  v5 += 112;
  *(_DWORD *)(v5 + 32) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(void *)(v5 + 36) = 0x7FFFFFFFLL;
  id result = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v5, a2 + 14);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::GeomSkeleton::fromSkeleton@<X0>(StringID *a1@<X0>, void *a2@<X8>)
{
  re::StringID::StringID((re::StringID *)a2, a1);
  re::FixedArray<re::StringID>::FixedArray(a2 + 2, (uint64_t)&a1[4].var1);
  re::FixedArray<unsigned int>::FixedArray(a2 + 5, (uint64_t)&a1[6]);
  re::FixedArray<re::GenericSRT<float>>::FixedArray(a2 + 8, (uint64_t)&a1[3]);
  re::FixedArray<re::Matrix4x4<float>>::FixedArray(a2 + 11, (uint64_t)&a1[1].var1);
  return re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable((uint64_t)(a2 + 14), (uint64_t)&a1[7].var1);
}

void *re::DynamicArray<re::GeomSkeleton>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    unint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::GeomSkeleton>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::GeomSkeleton>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

unsigned __int8 *re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3 = *a1;
  int v4 = *a2;
  if (*a1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    BOOL v6 = a1 + 8;
    if (v3) {
      BOOL v7 = v4 == 0;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v6);
      *a1 = 0;
    }
    else
    {
      if (v3) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = v4 == 0;
      }
      if (v8)
      {
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v6, (uint64_t)(a2 + 8));
      }
      else
      {
        *a1 = 1;
        *((void *)a1 + 5) = 0;
        *((void *)a1 + 2) = 0;
        *((void *)a1 + 3) = 0;
        void *v6 = 0;
        *((_DWORD *)a1 + 8) = 0;
        uint64_t v9 = *((void *)a2 + 2);
        *((void *)a1 + 1) = *((void *)a2 + 1);
        *((void *)a1 + 2) = v9;
        *((void *)a2 + 1) = 0;
        *((void *)a2 + 2) = 0;
        uint64_t v10 = *((void *)a1 + 3);
        *((void *)a1 + 3) = *((void *)a2 + 3);
        *((void *)a2 + 3) = v10;
        uint64_t v11 = *((void *)a1 + 5);
        *((void *)a1 + 5) = *((void *)a2 + 5);
        *((void *)a2 + 5) = v11;
        ++*((_DWORD *)a2 + 8);
        ++*((_DWORD *)a1 + 8);
      }
    }
  }
  return a1;
}

uint64_t re::HashTable<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(uint64_t a1, unsigned int *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  unint64_t v2 = *a2;
  unint64_t v3 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * ((v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v6 + 24 * v4 + 12) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 24 * v4 + 8) & 0x7FFFFFFF;
      if (v4 == 0x7FFFFFFF) {
        break;
      }
      if (*(_DWORD *)(v6 + 24 * v4 + 12) == v2) {
        return v6 + 24 * v4 + 16;
      }
    }
    return 0;
  }
  return v6 + 24 * v4 + 16;
}

uint64_t re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::addEmplace<re::MaterialInfo&>(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t a5)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    int v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 72 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + 72 * v10 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 72 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 72 * v10) = a3;
  uint64_t v14 = *(void *)(a1 + 16) + 72 * v10;
  *(unsigned char *)(v14 + 16) = *(unsigned char *)a4;
  re::DynamicString::DynamicString((re::DynamicString *)(v14 + 24), (re::DynamicString *)((char *)a4 + 8));
  uint64_t v15 = *(void *)(a1 + 16) + 72 * v10;
  *(void *)(v15 + 56) = *(id *)a5;
  int v16 = *(_DWORD *)(a5 + 8);
  *(unsigned char *)(v15 + 68) = *(unsigned char *)(a5 + 12);
  *(_DWORD *)(v15 + 64) = v16;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v26, 0, 36);
      *(void *)&v26[36] = 0x7FFFFFFFLL;
      re::HashTable<char const*,re::AssetLoadRequest::LoadStatistics::AssetTypeStats,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init((uint64_t)v26, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v26;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v26[8];
      *(_OWORD *)int v26 = v5;
      *(void *)&v26[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v26[24];
      *(_OWORD *)&v26[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v26[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        uint64_t v14 = (uint64_t *)(v6 + 56);
        do
        {
          if ((*(_DWORD *)(v14 - 6) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 7);
            unint64_t v16 = *(unsigned int *)(a1 + 24);
            unint64_t v17 = v15 % v16;
            uint64_t v18 = *(unsigned int *)(a1 + 36);
            if (v18 == 0x7FFFFFFF)
            {
              uint64_t v18 = *(unsigned int *)(a1 + 32);
              int v19 = v18;
              if (v18 == v16)
              {
                re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::setCapacity(a1, (2 * v12));
                unint64_t v17 = v15 % *(unsigned int *)(a1 + 24);
                int v19 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 72 * v18 + 8);
            }
            else
            {
              uint64_t v20 = *(void *)(a1 + 16);
              int v21 = *(_DWORD *)(v20 + 72 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 72 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 72 * v18 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 72 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(void *)(*(void *)(a1 + 16) + 72 * v18) = v15;
            uint64_t v22 = *(void *)(a1 + 16) + 72 * v18;
            *(unsigned char *)(v22 + 16) = *((unsigned char *)v14 - 40);
            re::DynamicString::DynamicString((re::DynamicString *)(v22 + 24), (const re::DynamicString *)(v14 - 4));
            uint64_t v23 = *(void *)(a1 + 16) + 72 * v18;
            uint64_t v24 = *v14;
            *uint64_t v14 = 0;
            *(void *)(v23 + 56) = v24;
            LODWORD(v24) = *((_DWORD *)v14 + 2);
            *(unsigned char *)(v23 + 68) = *((unsigned char *)v14 + 12);
            *(_DWORD *)(v23 + 64) = v24;
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 9;
        }
        while (v11 < v10);
      }
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)v26);
    }
  }
  else
  {
    if (a2) {
      signed int v25 = a2;
    }
    else {
      signed int v25 = 3;
    }
  }
}

void re::importPhysicsMaterial(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3 = a1;
  uint64_t v4 = [v3 property:@"preliminary:physics:material:restitution"];
  long long v5 = v4;
  if (v4
    && ([(_anonymous_namespace_ *)v4 data], uint64_t v6 = objc_claimAutoreleasedReturnValue(),
                                                   v6,
                                                   v6))
  {
    long long v7 = [v3 property:@"preliminary:physics:material:friction:static"];
    unsigned int v8 = v7;
    if (v7
      && ([(_anonymous_namespace_ *)v7 data],
          long long v9 = objc_claimAutoreleasedReturnValue(),
          v9,
          v9))
    {
      unint64_t v10 = [v3 property:@"preliminary:physics:material:friction:dynamic"];
      unint64_t v11 = v10;
      if (v10
        && ([(_anonymous_namespace_ *)v10 data],
            int v12 = objc_claimAutoreleasedReturnValue(),
            v12,
            v12))
      {
        uint64_t v13 = re::PhysicsFactory::m_defaultFactory;
        uint64_t v14 = re::PhysicsFactory::m_defaultAllocator;
        [(_anonymous_namespace_ *)v5 doubleValue];
        float v16 = v15;
        [(_anonymous_namespace_ *)v8 doubleValue];
        float v18 = v17;
        [(_anonymous_namespace_ *)v11 doubleValue];
        float v20 = v19;
        uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, float, float, float))(*(void *)v13 + 16))(v13, v14, v16, v18, v20);
        *(unsigned char *)a2 = 1;
        *(void *)(a2 + 8) = v21;
      }
      else
      {
        long long v28 = v31;
        uint64_t v29 = v32;
        uint64_t v30 = v33;
        *(unsigned char *)a2 = 0;
        *(void *)(a2 + 8) = 1003;
        *(void *)(a2 + 16) = &re::PhysicsErrorCategory(void)::instance;
        *(_OWORD *)(a2 + 24) = v28;
        *(void *)(a2 + 40) = v29;
        *(void *)(a2 + 48) = v30;
      }
    }
    else
    {
      long long v25 = v31;
      uint64_t v26 = v32;
      uint64_t v27 = v33;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 1002;
      *(void *)(a2 + 16) = &re::PhysicsErrorCategory(void)::instance;
      *(_OWORD *)(a2 + 24) = v25;
      *(void *)(a2 + 40) = v26;
      *(void *)(a2 + 48) = v27;
    }
  }
  else
  {
    long long v22 = v31;
    uint64_t v23 = v32;
    uint64_t v24 = v33;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 1001;
    *(void *)(a2 + 16) = &re::PhysicsErrorCategory(void)::instance;
    *(_OWORD *)(a2 + 24) = v22;
    *(void *)(a2 + 40) = v23;
    *(void *)(a2 + 48) = v24;
  }
}

void re::importPhysicsCollider(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3 = [a1 property:@"preliminary:physics:collider:convexShape"];
  uint64_t v4 = v3;
  if (v3)
  {
    long long v5 = [v3 data];

    if (v5)
    {
      uint64_t v6 = [v4 targetObject];
      if (v6)
      {
        if (!v21.i8[0])
        {
          long long v15 = v18;
          uint64_t v16 = v19;
          uint64_t v17 = v20;
          *(unsigned char *)a2 = 0;
          *(void *)(a2 + 16) = 3004;
          *(void *)(a2 + 24) = &re::PhysicsErrorCategory(void)::instance;
          *(_OWORD *)(a2 + 32) = v15;
          *(void *)(a2 + 48) = v16;
          *(void *)(a2 + 56) = v17;
          if (void)v23 && (BYTE8(v23)) {
            (*(void (**)(void))(*(void *)v23 + 40))();
          }
          goto LABEL_9;
        }
        long long v8 = v22;
        long long v9 = v23;
        uint64_t v10 = v24;
        uint64_t v11 = v25;
        *(unsigned char *)a2 = 1;
        *(_OWORD *)(a2 + 16) = v8;
        *(_OWORD *)(a2 + 32) = v9;
      }
      else
      {
        float32x4_t v14 = v21;
        uint64_t v11 = *((void *)&v22 + 1);
        uint64_t v10 = v22;
        *(unsigned char *)a2 = 0;
        *(void *)(a2 + 16) = 3000;
        *(void *)(a2 + 24) = &re::PhysicsErrorCategory(void)::instance;
        *(float32x4_t *)(a2 + 32) = v14;
      }
      *(void *)(a2 + 48) = v10;
      *(void *)(a2 + 56) = v11;
LABEL_9:

      goto LABEL_10;
    }
  }
  float32x4_t v12 = v21;
  long long v13 = v22;
  *(unsigned char *)a2 = 0;
  *(void *)(a2 + 16) = 3001;
  *(void *)(a2 + 24) = &re::PhysicsErrorCategory(void)::instance;
  *(float32x4_t *)(a2 + 32) = v12;
  *(_OWORD *)(a2 + 48) = v13;
LABEL_10:
}

void re::anonymous namespace'::createCollisionShapeFromNode(float32x4_t *a1, void *a2)
{
  id v3 = a2;
  [MEMORY[0x263F83F10] localTransformWithNode:v3 time:0.0];
  float32x4_t v113 = v4;
  long long v114 = v5;
  long long v115 = v6;
  long long v116 = v7;
  v106.i64[0] = 0x3F8000003F800000;
  v106.i64[1] = 1065353216;
  v107.i64[0] = 0;
  v107.i64[1] = 0x3F80000000000000;
  float32x4_t v108 = 0uLL;
  re::decomposeScaleRotationTranslation<float>((uint64_t)&v113, (int32x4_t *)&v106, &v107, &v108);
  float32x4_t v104 = v107;
  float32x4_t v105 = v108;
  long long v8 = [v3 type];
  long long v9 = (void *)*MEMORY[0x263F83FD0];

  if (v8 == v9)
  {
    uint64_t v34 = [v3 property:@"height"];
    if (!v34)
    {
      float32x4_t v57 = v113;
      uint64_t v59 = *((void *)&v114 + 1);
      uint64_t v58 = v114;
      a1->i8[0] = 0;
      uint64_t v60 = 3005;
      goto LABEL_30;
    }
    unsigned int v35 = (void *)v34;
    BOOL v36 = [v3 property:@"radius"];
    uint64_t v37 = [v3 property:@"axis"];
    int v38 = v37;
    if (v37)
    {
      size_t v39 = [v37 stringValue];
      int v40 = [v39 isEqualToString:@"X"];

      if (v40)
      {
        _Q5 = v104;
        float32x4_t v42 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q5, (int32x4_t)_Q5), (int8x16_t)v104, 0xCuLL);
        v43.i64[0] = 0x8000000080000000;
        v43.i64[1] = 0x8000000080000000;
        float32x4_t v44 = vmlaq_f32(vmulq_f32(v104, v43), (float32x4_t)0, v42);
        int8x16_t v45 = (int8x16_t)vaddq_f32(v44, v44);
        float32x4_t v46 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v45, (int32x4_t)v45), v45, 0xCuLL);
        int8x16_t v47 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v46, (int32x4_t)v46), (int8x16_t)v46, 0xCuLL), vnegq_f32(v104)), v46, v42);
        float32x4_t v105 = vaddq_f32(v105, vaddq_f32(vaddq_f32(vmulq_laneq_f32(v46, v104, 3), (float32x4_t)0), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v47, (int32x4_t)v47), v47, 0xCuLL)));
        float32x4_t v48 = vmulq_f32(v104, (float32x4_t)xmmword_2343853F0);
        float32x4_t v49 = (float32x4_t)xmmword_234385400;
LABEL_25:
        _Q1 = (int8x16_t)vmlaq_f32(v48, v49, v42);
        float32x4_t v71 = vmlaq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), _Q1, 0xCuLL), v49, _Q5, 3), (float32x4_t)vdupq_n_s32(0x3F3504F3u), _Q5);
        _S2 = 1060439283;
        __asm { FMLA            S1, S2, V5.S[3] }
        v71.i32[3] = _Q1.i32[0];
        float32x4_t v104 = v71;
        goto LABEL_26;
      }
      int v63 = [v38 stringValue];
      int v64 = [v63 isEqualToString:@"Z"];

      if (!v64)
      {
LABEL_26:
        uint64_t v77 = re::globalAllocators((re *)v37);
        uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v77[2] + 32))(v77[2], 24, 8);
        *(_DWORD *)(v52 + 8) = 4;
        *(void *)uint64_t v52 = &unk_26E6D8BE0;
        [v36 doubleValue];
        *(float *)&double v78 = v78;
        *(_DWORD *)(v52 + 16) = LODWORD(v78);
        [v35 doubleValue];
        *(float *)&double v79 = v79 + (float)(*(float *)(v52 + 16) + *(float *)(v52 + 16));
        *(_DWORD *)(v52 + 12) = LODWORD(v79);

        goto LABEL_27;
      }
    }
    _Q5 = v104;
    float32x4_t v42 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q5, (int32x4_t)_Q5), (int8x16_t)v104, 0xCuLL);
    v65.i64[0] = 0x8000000080000000;
    v65.i64[1] = 0x8000000080000000;
    float32x4_t v66 = vmlaq_f32(vmulq_f32(v104, v65), (float32x4_t)0, v42);
    int8x16_t v67 = (int8x16_t)vaddq_f32(v66, v66);
    float32x4_t v68 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v67, (int32x4_t)v67), v67, 0xCuLL);
    int8x16_t v69 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v68, (int32x4_t)v68), (int8x16_t)v68, 0xCuLL), vnegq_f32(v104)), v68, v42);
    float32x4_t v105 = vaddq_f32(v105, vaddq_f32(vaddq_f32(vmulq_laneq_f32(v68, v104, 3), (float32x4_t)0), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v69, (int32x4_t)v69), v69, 0xCuLL)));
    float32x4_t v48 = vmulq_f32(v104, (float32x4_t)xmmword_2343853D0);
    float32x4_t v49 = (float32x4_t)xmmword_2343853E0;
    goto LABEL_25;
  }
  uint64_t v10 = [v3 type];
  uint64_t v11 = (void *)*MEMORY[0x263F84020];

  if (v10 == v11)
  {
    uint64_t v50 = [v3 property:@"radius"];
    if (v50)
    {
      unsigned int v35 = v50;
      unsigned int v51 = re::globalAllocators(v50);
      uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v51[2] + 32))(v51[2], 16, 8);
      *(_DWORD *)(v52 + 8) = 2;
      *(void *)uint64_t v52 = &unk_26E6D8DA0;
      [v35 doubleValue];
      *(float *)&double v53 = v53;
      *(_DWORD *)(v52 + 12) = LODWORD(v53);
LABEL_27:

LABEL_28:
      a1->i8[0] = 1;
      a1[1].i64[0] = v52;
      a1[2] = v105;
      a1[3] = v104;
LABEL_31:

      return;
    }
    float32x4_t v57 = v113;
    uint64_t v59 = *((void *)&v114 + 1);
    uint64_t v58 = v114;
    a1->i8[0] = 0;
    uint64_t v60 = 3007;
LABEL_30:
    a1[1].i64[0] = v60;
    a1[1].i64[1] = (uint64_t)&re::PhysicsErrorCategory(void)::instance;
    a1[2] = v57;
    a1[3].i64[0] = v58;
    a1[3].i64[1] = v59;
    goto LABEL_31;
  }
  float32x4_t v12 = [v3 type];
  long long v13 = (void *)*MEMORY[0x263F83FE0];

  if (v12 == v13)
  {
    uint64_t v54 = [v3 property:@"size"];
    if (v54)
    {
      unsigned int v35 = v54;
      uint64_t v55 = re::globalAllocators(v54);
      uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v55[2] + 32))(v55[2], 32, 16);
      *(_DWORD *)(v52 + 8) = 3;
      *(void *)uint64_t v52 = &unk_26E6D8B78;
      *(_OWORD *)(v52 + 16) = 0u;
      [v35 doubleValue];
      *(float *)&double v56 = v56;
      *(float32x4_t *)(v52 + 16) = vmulq_n_f32(v106, *(float *)&v56);
      goto LABEL_27;
    }
    float32x4_t v57 = v113;
    uint64_t v59 = *((void *)&v114 + 1);
    uint64_t v58 = v114;
    a1->i8[0] = 0;
    uint64_t v60 = 3009;
    goto LABEL_30;
  }
  float32x4_t v14 = [v3 typeName];
  long long v15 = [v14 stringValue];
  if ([v15 isEqualToString:@"Preliminary_InfiniteColliderPlane"])
  {

LABEL_6:
    id v16 = v3;
    [MEMORY[0x263F83F10] localTransformWithNode:v16 time:0.0];
    float32x4_t v113 = v17;
    long long v114 = v18;
    long long v115 = v19;
    long long v116 = v20;
    v109.i64[0] = 0x3F8000003F800000;
    v109.i64[1] = 1065353216;
    unint64_t v110 = 0;
    uint64_t v111 = 0x3F80000000000000;
    float32x4_t __src = 0uLL;
    float32x4_t v21 = (re *)re::decomposeScaleRotationTranslation<float>((uint64_t)&v113, &v109, &v110, &__src);
    float32x4_t v22 = __src;
    unint64_t v24 = v110;
    uint64_t v23 = v111;
    uint64_t v25 = re::globalAllocators(v21);
    uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v25[2] + 32))(v25[2], 48, 16);
    *(_DWORD *)(v26 + 8) = 6;
    *(void *)uint64_t v26 = &unk_26E6D8D30;
    *(_OWORD *)(v26 + 16) = 0u;
    uint64_t v27 = [v16 property:@"position"];
    long long v28 = v27;
    if (v27)
    {
      [v27 float3Value];
      float32x4_t v30 = vmulq_f32(v29, v29);
      *(float *)(v26 + 32) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]);
    }
    long long v31 = [v16 property:@"normal"];
    uint64_t v32 = v31;
    if (v31)
    {
      [v31 float3Value];
      *(_OWORD *)(v26 + 16) = v33;
    }
    a1->i8[0] = 1;
    a1[1].i64[0] = v26;
    a1[2] = v22;
    a1[3].i64[0] = v24;
    a1[3].i64[1] = v23;

    goto LABEL_31;
  }
  uint64_t v61 = [v3 type];
  uint64_t v62 = v61;
  if (v61 == (void *)*MEMORY[0x263F83FF8])
  {
    int IsSceneGroundPlane = re::importPhysicsIsSceneGroundPlane(v3);

    if (IsSceneGroundPlane) {
      goto LABEL_6;
    }
  }
  else
  {
  }
  long long v81 = [v3 type];
  unint64_t v82 = (void *)*MEMORY[0x263F84028];

  uint64_t v84 = *(uint64_t (**)(void))(*(void *)re::globalAllocators(v83)[2] + 32);
  if (v81 != v82)
  {
    uint64_t v52 = v84();
    *(_DWORD *)(v52 + 8) = 1;
    *(void *)uint64_t v52 = &unk_26E6D8CF8;
    goto LABEL_28;
  }
  uint64_t v52 = v84();
  *(_DWORD *)(v52 + 8) = 7;
  *(void *)uint64_t v52 = &unk_26E715528;
  *(void *)(v52 + 16) = 0;
  *(void *)(v52 + 24) = 0;
  *(void *)(v52 + 32) = 0;
  __src.i64[0] = 0;
  v109.i64[1] = 0;
  unint64_t v110 = 0;
  LODWORD(v111) = 0;
  re::DynamicArray<re::Pair<re::AABB,unsigned int,true>>::setCapacity(&v109, 1uLL);
  int v85 = v111 + 1;
  LODWORD(v111) = v111 + 1;
  uint64_t v86 = [v3 loadedChildIterator];
  unint64_t v87 = [v86 nextObject];
  if (v87)
  {
    id v89 = v87;
    do
    {
      if (v113.i8[0])
      {
        unint64_t v91 = v110;
        if (v110 >= v109.i64[1])
        {
          unint64_t v92 = v110 + 1;
          if (v109.i64[1] < v110 + 1)
          {
            if (v109.i64[0])
            {
              unint64_t v93 = 2 * v109.i64[1];
              if (!v109.i64[1]) {
                unint64_t v93 = 8;
              }
              if (v93 <= v92) {
                unint64_t v94 = v110 + 1;
              }
              else {
                unint64_t v94 = v93;
              }
              re::DynamicArray<re::Pair<re::AABB,unsigned int,true>>::setCapacity(&v109, v94);
              int v85 = v111;
            }
            else
            {
              re::DynamicArray<re::Pair<re::AABB,unsigned int,true>>::setCapacity(&v109, v92);
              int v85 = v111 + 1;
            }
          }
          unint64_t v91 = v110;
        }
        BOOL v95 = (_OWORD *)(__src.i64[0] + 48 * v91);
        *BOOL v95 = v114;
        v95[1] = v115;
        v95[2] = v116;
        unint64_t v110 = v91 + 1;
        LODWORD(v111) = ++v85;
      }
      else if (void)v115 && (BYTE8(v115))
      {
        (*(void (**)(void, void))(*(void *)v115 + 40))(v115, v116);
      }
      uint64_t v96 = [v86 nextObject];

      id v89 = (void *)v96;
    }
    while (v96);
  }
  uint64_t v97 = (const void *)__src.i64[0];
  unint64_t v98 = v110;
  if (*(void *)(v52 + 16)) {
    goto LABEL_61;
  }
  if (!v110) {
    goto LABEL_64;
  }
  *(void *)(v52 + 24) = v98;
  if (v98 >= 0x555555555555556)
  {
LABEL_69:
    re::internal::assertLog((re::internal *)6, v99, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 48, v98);
    _os_crash();
    __break(1u);
    goto LABEL_70;
  }
  *(void *)(v52 + 32) = v100;
  if (v100)
  {
    unint64_t v101 = v98 - 1;
    if (v98 != 1)
    {
      do
      {
        *int v100 = 0;
        v100[2] = 0;
        v100[3] = 0;
        v100[4] = 0;
        v100[5] = 0x3F80000000000000;
        v100 += 6;
        --v101;
      }
      while (v101);
    }
    *int v100 = 0;
    v100[2] = 0;
    v100[3] = 0;
    v100[4] = 0;
    v100[5] = 0x3F80000000000000;
LABEL_61:
    if (*(void *)(v52 + 24) == v98)
    {
      if (v98)
      {
        memmove(*(void **)(v52 + 32), v97, 48 * v98);
LABEL_65:

        if (v109.i64[0] && __src.i64[0]) {
          (*(void (**)(void))(*(void *)v109.i64[0] + 40))();
        }
        goto LABEL_28;
      }
LABEL_64:
      __int16 v102 = re::internal::destroyPersistent<re::CompoundShapeDataWorkaround>((re *)v52);
      unint64_t v103 = re::globalAllocators(v102);
      uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v103[2] + 32))(v103[2], 16, 8);
      *(_DWORD *)(v52 + 8) = 1;
      *(void *)uint64_t v52 = &unk_26E6D8CF8;
      goto LABEL_65;
    }
    re::internal::assertLog((re::internal *)4, v88, "assertion failure: '%s' (%s:line %i) Cannot copy from a Slice of a different size", "m_size == other.size()", "copy", 378);
    _os_crash();
    __break(1u);
    goto LABEL_69;
  }
LABEL_70:
  re::internal::assertLog((re::internal *)4, v88, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
  _os_crash();
  __break(1u);
}

void re::importPhysicsRigidBody(void *a1@<X0>, int32x4_t *a2@<X8>)
{
  id v3 = [a1 property:@"preliminary:physics:rigidBody:mass"];
  float32x4_t v4 = v3;
  if (v3
    && ([(_anonymous_namespace_ *)v3 data], long long v5 = objc_claimAutoreleasedReturnValue(),
                                                   v5,
                                                   v5))
  {
    [(_anonymous_namespace_ *)v4 floatValue];
    a2[1].i64[0] = 0;
    a2[1].i64[1] = 0;
    a2[2].i64[0] = 0;
    a2[2].i64[1] = 0x3F80000000000000;
    a2[3] = vdupq_n_s32(0x3DCCCCCDu);
    a2[4].i32[0] = v6;
    a2->i8[0] = 1;
  }
  else
  {
    int32x4_t v7 = v10;
    uint64_t v8 = v11;
    uint64_t v9 = v12;
    a2->i8[0] = 0;
    a2[1].i64[0] = 4001;
    a2[1].i64[1] = (uint64_t)&re::PhysicsErrorCategory(void)::instance;
    a2[2] = v7;
    a2[3].i64[0] = v8;
    a2[3].i64[1] = v9;
  }
}

uint64_t re::importPhysicsIsSceneGroundPlane(void *a1)
{
  id v1 = a1;
  unint64_t v2 = [v1 metadataWithKey:@"preliminary_isSceneGroundPlane"];
  if (v2
    || ([v1 customMetadataWithKey:@"preliminary_isSceneGroundPlane"],
        (unint64_t v2 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    uint64_t v3 = [v2 BOOLValue];
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

uint64_t re::importPhysicsCollidesWithEnvironment(void *a1)
{
  id v1 = a1;
  unint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1;
    while (1)
    {
      float32x4_t v4 = [v2 metadataWithKey:@"kind"];
      long long v5 = [v4 stringValue];
      char v6 = [v5 isEqual:@"sceneLibrary"];

      if (v6)
      {
LABEL_7:
        uint64_t v11 = 0;
        goto LABEL_11;
      }
      int32x4_t v7 = [v3 metadataWithKey:@"preliminary_collidesWithEnvironment"];
      if ([v7 BOOLValue]) {
        break;
      }
      uint64_t v8 = [v3 customMetadataWithKey:@"preliminary_collidesWithEnvironment"];
      char v9 = [v8 BOOLValue];

      if (v9) {
        goto LABEL_10;
      }
      uint64_t v10 = [v3 parent];

      uint64_t v3 = (void *)v10;
      if (!v10) {
        goto LABEL_7;
      }
    }

LABEL_10:
    uint64_t v11 = 1;
LABEL_11:
  }
  else
  {
    uint64_t v11 = 0;
  }

  return v11;
}

re *re::internal::destroyPersistent<re::CompoundShapeDataWorkaround>(re *result)
{
  if (result)
  {
    id v1 = result;
    uint64_t v2 = re::globalAllocators(result)[2];
    re::CompoundShapeDataWorkaround::~CompoundShapeDataWorkaround(v1);
    uint64_t v3 = *(uint64_t (**)(uint64_t, re::CompoundShapeDataWorkaround *))(*(void *)v2 + 40);
    return (re *)v3(v2, v1);
  }
  return result;
}

void re::CompoundShapeDataWorkaround::~CompoundShapeDataWorkaround(re::CompoundShapeDataWorkaround *this)
{
  re::CompoundShapeDataWorkaround::~CompoundShapeDataWorkaround(this);
  JUMPOUT(0x237DBCBD0);
}

{
  uint64_t v2;
  void *v3;
  void (****v4)(void);
  uint64_t v5;
  void (***v6)(void);
  uint64_t v7;

  uint64_t v3 = (void *)((char *)this + 24);
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    float32x4_t v4 = (void (****)(void))*((void *)this + 4);
    long long v5 = 48 * v2;
    do
    {
      char v6 = *v4;
      v4 += 6;
      re::internal::destroyPersistent<re::CollisionShapeData>((re *)"~CompoundShapeDataWorkaround", 47, v6);
      v5 -= 48;
    }
    while (v5);
  }
  int32x4_t v7 = *((void *)this + 2);
  if (v7)
  {
    if (*v3)
    {
      (*(void (**)(uint64_t, void))(*(void *)v7 + 40))(v7, *((void *)this + 4));
      *uint64_t v3 = 0;
      v3[1] = 0;
    }
    *((void *)this + 2) = 0;
  }
}

uint64_t re::internal::loadUSKMeshNodes(void *a1, uint64_t a2)
{
  id v3 = a1;
  if (![MEMORY[0x263F83F10] isSceneGraphNode:v3]) {
    goto LABEL_9;
  }
  if (![MEMORY[0x263F83F10] isTransformNode:v3]) {
    goto LABEL_9;
  }
  float32x4_t v4 = [v3 type];
  long long v5 = (void *)*MEMORY[0x263F83FF8];

  if (v4 != v5) {
    goto LABEL_9;
  }
  double GeomMeshFromUSKNode = re::internal::createGeomMeshFromUSKNode(v3, (uint64_t)&v16, 0, 0, 1, (uint64_t)v17);
  if (v16.__r_.__value_.__r.__words[0] && (v16.__r_.__value_.__s.__data_[8] & 1) != 0) {
    (*(void (**)(double))(*(void *)v16.__r_.__value_.__l.__data_ + 40))(GeomMeshFromUSKNode);
  }
  if (v17[0])
  {
    re::DynamicArray<re::GeomMesh>::add(a2, (uint64_t)&v18);
    re::Result<re::GeomMesh,re::DetailedError>::~Result(v17);
LABEL_9:
    uint64_t v8 = [v3 childIterator];
    uint64_t v9 = [v8 nextObject];
    if (v9)
    {
      uint64_t v10 = (void *)v9;
      do
      {
        uint64_t USKMeshNodes = re::internal::loadUSKMeshNodes(v10, a2);
        if (!USKMeshNodes) {
          break;
        }
        uint64_t v12 = [v8 nextObject];

        uint64_t v10 = (void *)v12;
      }
      while (v12);
    }
    else
    {
      uint64_t USKMeshNodes = 1;
    }

    goto LABEL_16;
  }
  std::error_code::message(&v16, &v18);
  if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    float32x4_t v14 = &v16;
  }
  else {
    float32x4_t v14 = (std::string *)v16.__r_.__value_.__r.__words[0];
  }
  if (v19) {
    long long v15 = *(const char **)&v20[7];
  }
  else {
    long long v15 = v20;
  }
  printf("Error: %s\nDetails:\n%s", (const char *)v14, v15);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  re::Result<re::GeomMesh,re::DetailedError>::~Result(v17);
  uint64_t USKMeshNodes = 0;
LABEL_16:

  return USKMeshNodes;
}

uint64_t re::internal::importGeomMeshesFromFile@<X0>(re::internal *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = 0;
  long long v22 = 0uLL;
  uint64_t v21 = 0;
  int v23 = 0;
  float32x4_t v4 = [NSString stringWithUTF8String:this];
  long long v5 = [NSURL fileURLWithPath:v4];
  char v6 = (void *)[objc_alloc(MEMORY[0x263F83F00]) initSceneFromURL:v5];
  int32x4_t v7 = v6;
  if (v6
    && ([v6 rootNode],
        uint64_t v8 = objc_claimAutoreleasedReturnValue(),
        int USKMeshNodes = re::internal::loadUSKMeshNodes(v8, (uint64_t)&v21),
        v8,
        USKMeshNodes))
  {
    uint64_t v10 = v21;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v11 = v24;
    uint64_t v24 = 0;
    ++v23;
    *(unsigned char *)a2 = 1;
    *(void *)(a2 + 8) = v10;
    *(void *)std::error_code v18 = 0;
    long long v12 = v22;
    long long v22 = 0u;
    *(_OWORD *)(a2 + 16) = v12;
    *(_OWORD *)&v18[8] = 0u;
    *(void *)(a2 + 40) = v11;
    LODWORD(v19) = 2;
    *(_DWORD *)(a2 + 32) = 1;
    re::DynamicArray<re::GeomMesh>::deinit((uint64_t)v18);
  }
  else
  {
    long long v13 = (_anonymous_namespace_ *)std::system_category();
    long long v14 = *(_OWORD *)v18;
    uint64_t v15 = *(void *)&v18[16];
    uint64_t v16 = v19;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = v13;
    *(_OWORD *)(a2 + 24) = v14;
    *(void *)(a2 + 40) = v15;
    *(void *)(a2 + 48) = v16;
  }

  return re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v21);
}

void re::internal::anonymous namespace'::addPropertyToUSKMeshNodeFromGeomAttributeHelper(unint64_t a1, const char *a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  uint64_t v148 = *MEMORY[0x263EF8340];
  id v10 = a4;
  id v11 = a6;
  if (!a2) {
    goto LABEL_121;
  }
  if (!a5) {
    goto LABEL_121;
  }
  long long v12 = (unsigned __int8 *)re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a1 + 64), a2);
  if (!v12) {
    goto LABEL_121;
  }
  long long v14 = v12;
  int v15 = v12[16];
  int v16 = v15;
  if (v15 == 3)
  {
    if (*(_DWORD *)(re::internal::accessFaceVaryingAttributeSubmesh((re::internal *)v12, v13) + 24) != *(_DWORD *)(a1 + 40)) {
      goto LABEL_121;
    }
    int v16 = v14[16];
  }
  if (!v16)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)v13, "assertion failure: '%s' (%s:line %i) Currently don't support mesh rate attributes", "!\"Unreachable code\"", "addPropertyToUSKMeshNodeFromGeomAttributeHelper", 314);
    _os_crash();
    __break(1u);
LABEL_187:
    re::internal::assertLog((re::internal *)4, v108, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    _os_crash();
    __break(1u);
LABEL_188:
    re::internal::assertLog((re::internal *)4, (uint64_t)v13, "assertion failure: '%s' (%s:line %i) Unhandled type", "!\"Unreachable code\"", "addPropertyToUSKMeshNodeFromGeomAttributeHelper", 310);
    _os_crash();
    __break(1u);
    JUMPOUT(0x233D07CD8);
  }
  id v129 = v11;
  switch(v14[17])
  {
    case 0u:
      float32x4_t v17 = [NSString stringWithUTF8String:a5];
      uint64_t v18 = [v10 newPropertyWithName:v17 type:*MEMORY[0x263F83F80] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      uint64_t v20 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      a1 = v18;
      if (v20)
      {
        uint64_t v21 = re::internal::GeomTypedAttribute<short>::operator[]((uint64_t)v14, 0);
        uint64_t v20 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v22 = v20;
      }
      else
      {
        unsigned int v22 = 0;
        uint64_t v21 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_108;
      }
      uint64_t v73 = 0;
      uint64_t v75 = (uint64_t)v132;
      uint64_t v74 = v133;
      unint64_t v76 = v22;
      while (v22 != v73)
      {
        if (v75 == v73) {
          goto LABEL_174;
        }
        *(_DWORD *)(v74 + 4 * v73) = *(__int16 *)(v21 + 2 * v73);
        if (v19 == ++v73) {
          goto LABEL_108;
        }
      }
      goto LABEL_163;
    case 1u:
      int v23 = [NSString stringWithUTF8String:a5];
      uint64_t v24 = [v10 newPropertyWithName:v23 type:*MEMORY[0x263F83F80] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      uint64_t v25 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      a1 = v24;
      if (v25)
      {
        uint64_t v26 = re::internal::GeomTypedAttribute<short>::operator[]((uint64_t)v14, 0);
        uint64_t v25 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v27 = v25;
      }
      else
      {
        unsigned int v27 = 0;
        uint64_t v26 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_108;
      }
      uint64_t v77 = 0;
      uint64_t v75 = (uint64_t)v132;
      uint64_t v78 = v133;
      unint64_t v76 = v27;
      while (v27 != v77)
      {
        if (v75 == v77) {
          goto LABEL_175;
        }
        *(_DWORD *)(v78 + 4 * v77) = *(unsigned __int16 *)(v26 + 2 * v77);
        if (v19 == ++v77) {
          goto LABEL_108;
        }
      }
      goto LABEL_164;
    case 2u:
      long long v28 = [NSString stringWithUTF8String:a5];
      uint64_t v29 = [v10 newPropertyWithName:v28 type:*MEMORY[0x263F83F80] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      float32x4_t v30 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      a1 = v29;
      if (v30)
      {
        uint64_t v31 = re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)v14, 0);
        float32x4_t v30 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v32 = v30;
      }
      else
      {
        unsigned int v32 = 0;
        uint64_t v31 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_108;
      }
      uint64_t v79 = 0;
      uint64_t v75 = (uint64_t)v132;
      uint64_t v80 = v133;
      unint64_t v76 = v32;
      while (v32 != v79)
      {
        if (v75 == v79) {
          goto LABEL_176;
        }
        *(_DWORD *)(v80 + 4 * v79) = *(_DWORD *)(v31 + 4 * v79);
        if (v19 == ++v79) {
          goto LABEL_108;
        }
      }
      goto LABEL_165;
    case 3u:
      long long v33 = [NSString stringWithUTF8String:a5];
      uint64_t v34 = [v10 newPropertyWithName:v33 type:*MEMORY[0x263F83F80] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      unsigned int v35 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      a1 = v34;
      if (v35)
      {
        uint64_t v36 = re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)v14, 0);
        unsigned int v35 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v37 = v35;
      }
      else
      {
        unsigned int v37 = 0;
        uint64_t v36 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_108;
      }
      uint64_t v81 = 0;
      uint64_t v75 = (uint64_t)v132;
      uint64_t v82 = v133;
      unint64_t v76 = v37;
      while (v37 != v81)
      {
        if (v75 == v81) {
          goto LABEL_177;
        }
        *(_DWORD *)(v82 + 4 * v81) = *(_DWORD *)(v36 + 4 * v81);
        if (v19 == ++v81) {
          goto LABEL_108;
        }
      }
      goto LABEL_166;
    case 4u:
      int v38 = [NSString stringWithUTF8String:a5];
      uint64_t v39 = [v10 newPropertyWithName:v38 type:*MEMORY[0x263F83F70] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      int v40 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      a1 = v39;
      if (v40)
      {
        uint64_t v41 = re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)v14, 0);
        int v40 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v42 = v40;
      }
      else
      {
        unsigned int v42 = 0;
        uint64_t v41 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_65;
      }
      uint64_t v83 = 0;
      uint64_t v75 = (uint64_t)v132;
      uint64_t v84 = v133;
      unint64_t v76 = v42;
      do
      {
        if (v42 == v83) {
          goto LABEL_167;
        }
        if (v75 == v83) {
          goto LABEL_178;
        }
        *(_DWORD *)(v84 + 4 * v83) = *(_DWORD *)(v41 + 4 * v83);
        ++v83;
      }
      while (v19 != v83);
LABEL_65:
      id v85 = objc_alloc(MEMORY[0x263F83ED8]);
      uint64_t v86 = [v85 initWithFloatArray:v133 count:v19];
      goto LABEL_109;
    case 5u:
      float32x4_t v43 = [NSString stringWithUTF8String:a5];
      uint64_t v44 = [v10 newPropertyWithName:v43 type:*MEMORY[0x263F83F38] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      int8x16_t v45 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      a1 = v44;
      if (v45)
      {
        uint64_t v46 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)v14, 0);
        int8x16_t v45 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v47 = v45;
      }
      else
      {
        unsigned int v47 = 0;
        uint64_t v46 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_72;
      }
      uint64_t v87 = 0;
      uint64_t v75 = (uint64_t)v132;
      uint64_t v88 = v133;
      unint64_t v76 = v47;
      do
      {
        if (v47 == v87) {
          goto LABEL_168;
        }
        if (v75 == v87) {
          goto LABEL_179;
        }
        *(void *)(v88 + 8 * v87) = *(void *)(v46 + 8 * v87);
        ++v87;
      }
      while (v19 != v87);
LABEL_72:
      id v89 = objc_alloc(MEMORY[0x263F83ED8]);
      uint64_t v86 = [v89 initWithDoubleArray:v133 count:v19];
      goto LABEL_109;
    case 6u:
      float32x4_t v48 = [NSString stringWithUTF8String:a5];
      uint64_t v49 = [v10 newPropertyWithName:v48 type:*MEMORY[0x263F83F48] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      uint64_t v50 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      float32x4_t v128 = (void *)v49;
      if (v50)
      {
        uint64_t v51 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)v14, 0);
        uint64_t v50 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v52 = v50;
      }
      else
      {
        unsigned int v52 = 0;
        uint64_t v51 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_79;
      }
      unint64_t v76 = 0;
      uint64_t v75 = v52;
      do
      {
        if (v52 == v76) {
          goto LABEL_169;
        }
        a1 = (unint64_t)v132;
        if ((unint64_t)v132 <= v76) {
          goto LABEL_180;
        }
        *(void *)(v133 + 8 * v76) = *(void *)(v51 + 8 * v76);
        ++v76;
      }
      while (v19 != v76);
LABEL_79:
      id v90 = objc_alloc(MEMORY[0x263F83ED8]);
      uint64_t v91 = [v90 initWithFloat2Array:v133 count:v19];
      goto LABEL_94;
    case 7u:
      double v53 = [NSString stringWithUTF8String:a5];
      uint64_t v54 = [v10 newPropertyWithName:v53 type:*MEMORY[0x263F83F58] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      uint64_t v55 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      float32x4_t v128 = (void *)v54;
      if (v55)
      {
        uint64_t v56 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)v14, 0);
        uint64_t v55 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v57 = v55;
      }
      else
      {
        unsigned int v57 = 0;
        uint64_t v56 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_86;
      }
      unint64_t v76 = 0;
      uint64_t v75 = v57;
      do
      {
        if (v57 == v76) {
          goto LABEL_170;
        }
        a1 = (unint64_t)v132;
        if ((unint64_t)v132 <= v76) {
          goto LABEL_181;
        }
        *(_OWORD *)(v133 + 16 * v76) = *(_OWORD *)(v56 + 16 * v76);
        ++v76;
      }
      while (v19 != v76);
LABEL_86:
      id v92 = objc_alloc(MEMORY[0x263F83ED8]);
      uint64_t v91 = [v92 initWithFloat3Array:v133 count:v19];
      goto LABEL_94;
    case 8u:
      uint64_t v58 = [NSString stringWithUTF8String:a5];
      uint64_t v59 = [v10 newPropertyWithName:v58 type:*MEMORY[0x263F83F60] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      uint64_t v60 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      float32x4_t v128 = (void *)v59;
      if (v60)
      {
        uint64_t v61 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)v14, 0);
        uint64_t v60 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v62 = v60;
      }
      else
      {
        unsigned int v62 = 0;
        uint64_t v61 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_93;
      }
      unint64_t v76 = 0;
      uint64_t v75 = v62;
      do
      {
        if (v62 == v76) {
          goto LABEL_171;
        }
        a1 = (unint64_t)v132;
        if ((unint64_t)v132 <= v76) {
          goto LABEL_182;
        }
        *(_OWORD *)(v133 + 16 * v76) = *(_OWORD *)(v61 + 16 * v76);
        ++v76;
      }
      while (v19 != v76);
LABEL_93:
      id v93 = objc_alloc(MEMORY[0x263F83ED8]);
      uint64_t v91 = [v93 initWithFloat4Array:v133 count:v19];
LABEL_94:
      unint64_t v94 = v91;
      BOOL v95 = v128;
      uint64_t v96 = v128;
      goto LABEL_110;
    case 9u:
      int v63 = [NSString stringWithUTF8String:a5];
      uint64_t v64 = [v10 newPropertyWithName:v63 type:*MEMORY[0x263F83F80] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      float32x4_t v65 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      a1 = v64;
      if (v65)
      {
        uint64_t v66 = re::internal::GeomTypedAttribute<signed char>::operator[]((uint64_t)v14, 0);
        float32x4_t v65 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v67 = v65;
      }
      else
      {
        unsigned int v67 = 0;
        uint64_t v66 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_108;
      }
      uint64_t v97 = 0;
      uint64_t v75 = (uint64_t)v132;
      uint64_t v98 = v133;
      unint64_t v76 = v67;
      while (v67 != v97)
      {
        if (v75 == v97) {
          goto LABEL_183;
        }
        *(_DWORD *)(v98 + 4 * v97) = *(unsigned __int8 *)(v66 + v97);
        if (v19 == ++v97) {
          goto LABEL_108;
        }
      }
      goto LABEL_172;
    case 0xAu:
      float32x4_t v68 = [NSString stringWithUTF8String:a5];
      uint64_t v69 = [v10 newPropertyWithName:v68 type:*MEMORY[0x263F83F80] role:v11];

      unint64_t v19 = (*(unsigned int (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      uint64_t v70 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
      a1 = v69;
      if (v70)
      {
        uint64_t v71 = re::internal::GeomTypedAttribute<signed char>::operator[]((uint64_t)v14, 0);
        uint64_t v70 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v14 + 16))(v14);
        unsigned int v72 = v70;
      }
      else
      {
        unsigned int v72 = 0;
        uint64_t v71 = 0;
      }
      uint64_t v131 = 0;
      long long v132 = 0;
      uint64_t v133 = 0;
      if (!v19) {
        goto LABEL_108;
      }
      uint64_t v99 = 0;
      uint64_t v75 = (uint64_t)v132;
      uint64_t v100 = v133;
      unint64_t v76 = v72;
      break;
    default:
      goto LABEL_188;
  }
  do
  {
    if (v72 == v99) {
      goto LABEL_173;
    }
    if (v75 == v99) {
      goto LABEL_184;
    }
    *(_DWORD *)(v100 + 4 * v99) = *(char *)(v71 + v99);
    ++v99;
  }
  while (v19 != v99);
LABEL_108:
  id v101 = objc_alloc(MEMORY[0x263F83ED8]);
  uint64_t v86 = [v101 initWithIntArray:v133 count:v19];
LABEL_109:
  unint64_t v94 = v86;
  BOOL v95 = (void *)a1;
  uint64_t v96 = (void *)a1;
LABEL_110:
  [v96 setData:v94];

  if (v131 && v132) {
    (*(void (**)(void))(*(void *)v131 + 40))();
  }
  id v11 = v129;
  if (!v95) {
    goto LABEL_120;
  }
  if (v15 == 2)
  {
    id v102 = objc_alloc(MEMORY[0x263F83ED8]);
    unint64_t v103 = @"uniform";
    goto LABEL_118;
  }
  if (v15 == 1)
  {
    id v102 = objc_alloc(MEMORY[0x263F83ED8]);
    unint64_t v103 = @"vertex";
LABEL_118:
    a1 = [v102 initWithString:v103];
    [v95 setMetadataWithKey:@"interpolation" value:a1];
    goto LABEL_119;
  }
  if (v15 != 3)
  {
    if (v15) {
      goto LABEL_120;
    }
    objc_msgSend(v95, "setMetadataWithKey:value:", @"interpolation", objc_msgSend(objc_alloc(MEMORY[0x263F83ED8]), "initWithString:", @"constant"));
    re::internal::assertLog((re::internal *)4, v123, "assertion failure: '%s' (%s:line %i) Mesh rate attributes are currently not handled", "!\"Unreachable code\"", "addPropertyToUSKMeshNodeFromGeomAttributeHelper", 345);
    _os_crash();
    __break(1u);
LABEL_153:
    uint64_t v109 = 0;
    uint64_t v110 = v133;
    BOOL v122 = v132 == 0;
    goto LABEL_154;
  }
  unint64_t v94 = 0x263F83000uLL;
  a1 = [objc_alloc(MEMORY[0x263F83ED8]) initWithString:@"faceVarying"];
  float32x4_t v128 = v95;
  [v95 setMetadataWithKey:@"interpolation" value:a1];
  float32x4_t v104 = objc_msgSend(NSString, "stringWithFormat:", @"%s:indices", a5);
  id v127 = v10;
  a5 = (void *)[v10 newPropertyWithName:v104 type:*MEMORY[0x263F83F80] role:*MEMORY[0x263F84040]];

  uint64_t v106 = re::internal::accessFaceVaryingAttributeSubmesh((re::internal *)v14, v105);
  uint64_t v107 = *(void *)(a3 + 16);
  uint64_t v131 = 0;
  long long v132 = 0;
  uint64_t v133 = 0;
  unint64_t v76 = v107;
  if (!v107) {
    goto LABEL_153;
  }
  unint64_t v125 = a5;
  unint64_t v126 = a1;
  a1 = 0;
  LODWORD(v109) = 0;
  a5 = v132;
  uint64_t v110 = v133;
  uint64_t v75 = 3;
  uint64_t v111 = a3;
  do
  {
    LODWORD(v143) = a1;
    int v112 = *(unsigned __int8 *)(v106 + 140);
    if (v112 == 2)
    {
      uint64_t v114 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v106 + 144), (unsigned int *)&v143);
      if (v114 == -1) {
        unsigned int v113 = -1;
      }
      else {
        unsigned int v113 = *(_DWORD *)(*(void *)(v106 + 152) + 8 * v114 + 4);
      }
      uint64_t v111 = a3;
    }
    else if (v112 == 1)
    {
      if (*(void *)(v106 + 160) <= a1) {
        unsigned int v113 = -1;
      }
      else {
        unsigned int v113 = *(_DWORD *)(*(void *)(v106 + 176) + 4 * a1);
      }
    }
    else
    {
      if (*(unsigned char *)(v106 + 140)) {
        goto LABEL_187;
      }
      if (a1 >= *(unsigned int *)(v106 + 144)) {
        unsigned int v113 = -1;
      }
      else {
        unsigned int v113 = a1;
      }
    }
    unint64_t v19 = v113;
    unint64_t v115 = *(void *)(v106 + 24);
    if (v115 <= v113)
    {
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 797;
      __int16 v139 = 2048;
      unint64_t v140 = v19;
      __int16 v141 = 2048;
      unint64_t v142 = v115;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_159:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 797;
      __int16 v139 = 2048;
      unint64_t v140 = a1;
      __int16 v141 = 2048;
      unint64_t v142 = v115;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_160:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      uint64_t v75 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v115;
      __int16 v141 = 2048;
      unint64_t v142 = (unint64_t)a5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_161:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v19;
      __int16 v141 = 2048;
      unint64_t v142 = (unint64_t)a5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_162:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v19;
      __int16 v141 = 2048;
      unint64_t v142 = (unint64_t)a5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_163:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = v76;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_164:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = v76;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_165:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = v76;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_166:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = v76;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_167:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = v76;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_168:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = v76;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_169:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_170:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_171:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_172:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = v76;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_173:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 601;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = v76;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_174:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_175:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_176:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_177:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_178:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_179:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_180:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = a1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_181:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = a1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_182:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v76;
      __int16 v141 = 2048;
      unint64_t v142 = a1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_183:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_184:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v75;
      __int16 v141 = 2048;
      unint64_t v142 = v75;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_185:
      uint64_t v134 = 0;
      long long v146 = 0u;
      long long v147 = 0u;
      long long v144 = 0u;
      long long v145 = 0u;
      long long v143 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v135 = 136315906;
      long long v136 = "operator[]";
      __int16 v137 = 1024;
      int v138 = 468;
      __int16 v139 = 2048;
      unint64_t v140 = v19;
      __int16 v141 = 2048;
      unint64_t v142 = (unint64_t)a5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    unint64_t v115 = *(void *)(v111 + 16);
    if (v115 <= a1) {
      goto LABEL_159;
    }
    unint64_t v115 = *(unsigned __int8 *)(*(void *)(v111 + 32) + 4 * a1);
    if ((unint64_t)a5 <= v115) {
      goto LABEL_160;
    }
    long long v116 = (int *)(*(void *)(v106 + 40) + 16 * v113);
    int v118 = *v116;
    int v117 = v116[1];
    int v120 = v116[2];
    int v119 = v116[3];
    *(_DWORD *)(v110 + 4 * v115) = v118;
    unint64_t v19 = (v115 + 1);
    if ((unint64_t)a5 <= v19) {
      goto LABEL_161;
    }
    *(_DWORD *)(v110 + 4 * v19) = v117;
    unint64_t v19 = (v115 + 2);
    if ((unint64_t)a5 <= v19) {
      goto LABEL_162;
    }
    *(_DWORD *)(v110 + 4 * v19) = v120;
    if (v119 == -1) {
      int v121 = 3;
    }
    else {
      int v121 = 4;
    }
    if (v119 != -1)
    {
      unint64_t v19 = (v115 + 3);
      if ((unint64_t)a5 <= v19) {
        goto LABEL_185;
      }
      *(_DWORD *)(v110 + 4 * v19) = v119;
    }
    uint64_t v109 = (v121 + v109);
    ++a1;
  }
  while (v76 != a1);
  BOOL v122 = 0;
  id v11 = v129;
  a5 = v125;
  a1 = v126;
  unint64_t v94 = 0x263F83000;
LABEL_154:
  uint64_t v124 = (void *)[objc_alloc(*(Class *)(v94 + 3800)) initWithIntArray:v110 count:v109];
  if (v131 && !v122) {
    (*(void (**)(void))(*(void *)v131 + 40))();
  }
  [a5 setData:v124];

  id v10 = v127;
  BOOL v95 = v128;
LABEL_119:

LABEL_120:
LABEL_121:
}

void re::internal::exportGeomMeshesToUSDFile(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v157 = *MEMORY[0x263EF8340];
  id v101 = [MEMORY[0x263F08850] defaultManager];
  uint64_t v5 = NSTemporaryDirectory();
  uint64_t v98 = a1;
  char v6 = [NSString stringWithUTF8String:a1];
  int32x4_t v7 = [v6 pathExtension];

  float32x4_t v104 = v7;
  if (([(__CFString *)v7 isEqualToString:@"usd"] & 1) == 0
    && ([(__CFString *)v7 isEqualToString:@"usda"] & 1) == 0
    && ([(__CFString *)v7 isEqualToString:@"usdc"] & 1) == 0
    && ([(__CFString *)v7 isEqualToString:@"usdz"] & 1) == 0)
  {

    float32x4_t v104 = @"usda";
  }
  uint64_t v8 = [MEMORY[0x263F08C38] UUID];
  uint64_t v9 = NSString;
  uint64_t v99 = v8;
  id v10 = [v8 UUIDString];
  id v102 = (void *)v5;
  uint64_t v11 = [v9 stringWithFormat:@"%@/%@.%@", v5, v10, v104];

  context = (void *)MEMORY[0x237DBDCF0]();
  long long v12 = (void *)MEMORY[0x263F83F00];
  unint64_t v103 = (void *)v11;
  long long v13 = [NSURL fileURLWithPath:v11];
  int v112 = (void *)[v12 newSceneWithURL:v13];

  int v130 = 0;
  long long v128 = 0u;
  long long v129 = 0u;
  uint64_t v131 = 0x7FFFFFFFLL;
  unint64_t v111 = a2[1];
  if (!v111) {
    goto LABEL_87;
  }
  unint64_t v16 = 0;
  uint64_t v110 = *MEMORY[0x263F83FF8];
  uint64_t v109 = *MEMORY[0x263F83FB0];
  float32x4_t v17 = (void *)*MEMORY[0x263F84040];
  uint64_t v107 = (void *)*MEMORY[0x263F84050];
  uint64_t v108 = *MEMORY[0x263F83F80];
  float32x4_t v105 = (void *)*MEMORY[0x263F84048];
  uint64_t v106 = (void *)*MEMORY[0x263F84058];
  int v118 = (void *)*MEMORY[0x263F84040];
  do
  {
    unint64_t v18 = a2[1];
    if (v18 <= v16)
    {
      re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v16, v18);
      _os_crash();
      __break(1u);
LABEL_110:
      re::internal::assertLog((re::internal *)6, v33, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v16, v34);
      _os_crash();
      __break(1u);
    }
    if (*(void *)(*a2 + 736 * v16)) {
      unint64_t v19 = *(const char **)(*a2 + 736 * v16);
    }
    else {
      unint64_t v19 = "unnamed";
    }
    uint64_t v20 = (_DWORD *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&v128, (uint64_t)&v124);
    if (!v20)
    {
      LODWORD(v152) = 0;
      unint64_t v24 = re::Hash<re::DynamicString>::operator()((uint64_t)&v132, (uint64_t)&v124);
      unint64_t v25 = v24;
      if ((void)v128)
      {
        unint64_t v26 = v24 % DWORD2(v129);
        uint64_t v27 = *(unsigned int *)(*((void *)&v128 + 1) + 4 * v26);
        if (v27 != 0x7FFFFFFF)
        {
          uint64_t v28 = v129;
          do
          {
            uint64_t v23 = re::DynamicString::operator==(v28 + 56 * v27 + 16, (uint64_t)&v124);
            if (v23) {
              goto LABEL_27;
            }
            uint64_t v27 = *(_DWORD *)(v28 + 56 * v27 + 8) & 0x7FFFFFFF;
          }
          while (v27 != 0x7FFFFFFF);
        }
      }
      else
      {
        LODWORD(v26) = 0;
      }
      uint64_t v23 = re::HashTable<re::DynamicString,unsigned int,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove((uint64_t)&v128, v26, v25, (re::DynamicString *)&v124, &v152);
      ++HIDWORD(v131);
LABEL_27:
      float32x4_t v17 = v118;
      goto LABEL_28;
    }
    uint64_t v21 = (*v20 + 1);
    *uint64_t v20 = v21;
    if (v125) {
      unsigned int v22 = v127;
    }
    else {
      unsigned int v22 = v126;
    }
    re::DynamicString::format((re::DynamicString *)"%s_%d", (re::DynamicString *)&v152, v22, v21);
    re::DynamicString::operator=((re::DynamicString *)&v124, (re::DynamicString *)&v152);
    uint64_t v23 = v152;
    if (void)v152 && (BYTE8(v152)) {
      uint64_t v23 = (*(uint64_t (**)(void, void))(*(void *)v152 + 40))(v152, v153);
    }
LABEL_28:
    re::DynamicString::operator+((re::DynamicString *)&v132, (uint64_t)&v124, (re::DynamicString *)&v152);
    re::DynamicString::operator=((re::DynamicString *)&v124, (re::DynamicString *)&v152);
    if ((void)v152)
    {
      if (BYTE8(v152)) {
        (*(void (**)(void, void))(*(void *)v152 + 40))(v152, v153);
      }
      long long v152 = 0u;
      long long v153 = 0u;
    }
    if (v132 && (v133 & 1) != 0) {
      (*(void (**)(void))(*(void *)v132 + 40))();
    }
    id v29 = objc_alloc(MEMORY[0x263F83EE8]);
    if (v125) {
      float32x4_t v30 = v127;
    }
    else {
      float32x4_t v30 = v126;
    }
    uint64_t v31 = [NSString stringWithUTF8String:v30];
    unsigned int v32 = (void *)[v29 initWithString:v31];

    unint64_t v34 = a2[1];
    if (v34 <= v16) {
      goto LABEL_110;
    }
    unint64_t v35 = *a2;
    id v36 = v112;
    id v37 = v32;
    uint64_t v136 = 0;
    uint64_t v133 = 0;
    uint64_t v134 = 0;
    uint64_t v132 = 0;
    int v135 = 0;
    int v38 = (void *)[v36 newNodeAtPath:v37 type:v110];
    uint64_t v39 = v38;
    if (!v38) {
      goto LABEL_80;
    }
    id v116 = v36;
    id v117 = v37;
    int v40 = (void *)[v38 newPropertyWithName:@"subdivisionScheme" type:v109 role:v17];
    unsigned int v113 = (void *)[objc_alloc(MEMORY[0x263F83F08]) initWithString:@"none"];
    uint64_t v114 = v40;
    [v40 setTokenValue:v113];
    unint64_t v115 = v39;
    uint64_t v41 = v39;
    unint64_t v42 = v35 + 736 * v16;
    uint64_t v44 = *(void *)(v42 + 40);
    float32x4_t v43 = (void **)(v42 + 40);
    uint64_t v140 = 0;
    __int16 v141 = 0;
    uint64_t v142 = 0;
    uint64_t v137 = 0;
    int v138 = 0;
    uint64_t v139 = 0;
    unint64_t v46 = v44;
    LODWORD(v152) = 0;
    uint64_t v134 = 0;
    ++v135;
    LODWORD(v152) = 0;
    re::DynamicArray<unsigned int>::resize(&v132, v44, &v152);
    unint64_t v119 = v35;
    if (!v44)
    {
      uint64_t v49 = 0;
      uint64_t v55 = v142;
      goto LABEL_55;
    }
    unsigned int v47 = a2;
    float32x4_t v48 = 0;
    LODWORD(v49) = 0;
    uint64_t v50 = *v43;
    uint64_t v51 = v134;
    uint64_t v52 = v136;
    uint64_t v54 = v138;
    uint64_t v53 = v139;
    uint64_t v56 = v141;
    uint64_t v55 = v142;
    unsigned int v57 = (int *)(*(void *)(v35 + 736 * v16 + 56) + 8);
    do
    {
      if (v50 == v48)
      {
        uint64_t v143 = 0;
        long long v155 = 0u;
        long long v156 = 0u;
        long long v153 = 0u;
        long long v154 = 0u;
        long long v152 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v144 = 136315906;
        long long v145 = "operator[]";
        __int16 v146 = 1024;
        int v147 = 797;
        __int16 v148 = 2048;
        unint64_t v149 = (unint64_t)v50;
        __int16 v150 = 2048;
        uint64_t v151 = v50;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_98:
        uint64_t v143 = 0;
        long long v155 = 0u;
        long long v156 = 0u;
        long long v153 = 0u;
        long long v154 = 0u;
        long long v152 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v144 = 136315906;
        long long v145 = "operator[]";
        __int16 v146 = 1024;
        int v147 = 789;
        __int16 v148 = 2048;
        unint64_t v149 = (unint64_t)v51;
        __int16 v150 = 2048;
        uint64_t v151 = v51;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_99:
        uint64_t v143 = 0;
        long long v155 = 0u;
        long long v156 = 0u;
        long long v153 = 0u;
        long long v154 = 0u;
        long long v152 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v144 = 136315906;
        long long v145 = "operator[]";
        __int16 v146 = 1024;
        int v147 = 468;
        __int16 v148 = 2048;
        unint64_t v149 = (unint64_t)v54;
        __int16 v150 = 2048;
        uint64_t v151 = v54;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_100:
        uint64_t v143 = 0;
        long long v155 = 0u;
        long long v156 = 0u;
        long long v153 = 0u;
        long long v154 = 0u;
        long long v152 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v144 = 136315906;
        long long v145 = "operator[]";
        __int16 v146 = 1024;
        int v147 = 468;
        __int16 v148 = 2048;
        unint64_t v149 = v35;
        __int16 v150 = 2048;
        uint64_t v151 = v56;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_101:
        uint64_t v143 = 0;
        long long v155 = 0u;
        long long v156 = 0u;
        long long v153 = 0u;
        long long v154 = 0u;
        long long v152 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v144 = 136315906;
        long long v145 = "operator[]";
        __int16 v146 = 1024;
        int v147 = 468;
        __int16 v148 = 2048;
        unint64_t v149 = v35;
        __int16 v150 = 2048;
        uint64_t v151 = v56;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_102:
        uint64_t v143 = 0;
        long long v155 = 0u;
        long long v156 = 0u;
        long long v153 = 0u;
        long long v154 = 0u;
        long long v152 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v144 = 136315906;
        long long v145 = "operator[]";
        __int16 v146 = 1024;
        int v147 = 468;
        __int16 v148 = 2048;
        unint64_t v149 = v35;
        __int16 v150 = 2048;
        uint64_t v151 = v56;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_103:
        uint64_t v143 = 0;
        long long v155 = 0u;
        long long v156 = 0u;
        long long v153 = 0u;
        long long v154 = 0u;
        long long v152 = 0u;
        uint64_t v77 = (void *)&_os_log_internal;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v144 = 136315906;
        long long v145 = "operator[]";
        __int16 v146 = 1024;
        int v147 = 468;
        __int16 v148 = 2048;
        unint64_t v149 = v35;
        __int16 v150 = 2048;
        uint64_t v151 = v56;
        LODWORD(v96) = 38;
        BOOL v95 = &v144;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_104;
      }
      if (v51 == v48) {
        goto LABEL_98;
      }
      int v59 = *(v57 - 2);
      int v58 = *(v57 - 1);
      int v61 = *v57;
      int v60 = v57[1];
      *(_DWORD *)(v52 + 4 * (void)v48) = v49;
      if (v60 == -1) {
        int v62 = 3;
      }
      else {
        int v62 = 4;
      }
      if (v54 == v48) {
        goto LABEL_99;
      }
      *(_DWORD *)(v53 + 4 * (void)v48) = v62;
      unint64_t v35 = v49;
      if ((unint64_t)v56 <= v49) {
        goto LABEL_100;
      }
      *(_DWORD *)(v55 + 4 * v49) = v59;
      unint64_t v35 = (v49 + 1);
      if ((unint64_t)v56 <= v35) {
        goto LABEL_101;
      }
      *(_DWORD *)(v55 + 4 * v35) = v58;
      unint64_t v35 = (v49 + 2);
      if ((unint64_t)v56 <= v35) {
        goto LABEL_102;
      }
      *(_DWORD *)(v55 + 4 * v35) = v61;
      unint64_t v35 = (v49 + 3);
      if ((unint64_t)v56 <= v35) {
        goto LABEL_103;
      }
      *(_DWORD *)(v55 + 4 * v35) = v60;
      uint64_t v49 = (v62 + v49);
      float32x4_t v48 = (char *)v48 + 1;
      v57 += 4;
    }
    while ((void *)v46 != v48);
    a2 = v47;
    float32x4_t v17 = v118;
LABEL_55:
    int v63 = (void *)[(_anonymous_namespace_ *)v41 newPropertyWithName:@"faceVertexIndices" type:v108 role:v17];
    uint64_t v64 = (void *)[(_anonymous_namespace_ *)v41 newPropertyWithName:@"faceVertexCounts" type:v108 role:v17];
    float32x4_t v65 = (void *)[objc_alloc(MEMORY[0x263F83ED8]) initWithIntArray:v55 count:v49];
    [v63 setData:v65];

    id v66 = objc_alloc(MEMORY[0x263F83ED8]);
    unsigned int v67 = (void *)[v66 initWithIntArray:v139 count:v46];
    [v64 setData:v67];

    if (v137 && v138) {
      (*(void (**)(void))(*(void *)v137 + 40))();
    }
    if (v140 && v141) {
      (*(void (**)(void))(*(void *)v140 + 40))();
    }
    unint64_t v68 = v119 + 736 * v16;

    uint64_t v69 = (re::internal::GeomAttributeManager *)(v68 + 64);
    float32x4_t v17 = v118;
    if (re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(v68 + 64), "vertexUV"))
    {
    }
    if (re::internal::GeomAttributeManager::attributeByName(v69, "vertexNormal")) {
    if (re::internal::GeomAttributeManager::attributeByName(v69, "vertexTangent"))
    }
    if (re::internal::GeomAttributeManager::attributeByName(v69, "vertexBitangent")) {
    int v70 = *(_DWORD *)(v119 + 736 * v16 + 640);
    }
    if (v70)
    {
      for (unsigned int i = 0; i != v70; ++i)
      {
        uint64_t v72 = re::internal::GeomAttributeManager::attributeByIndex(v69, i);
        if (*(unsigned char *)(v72 + 16))
        {
          uint64_t v73 = *(char **)(v72 + 8);
          if (strcmp(v73, "vertexPosition"))
          {
            if (strcmp(v73, "vertexUV")
              && strcmp(v73, "vertexNormal")
              && strcmp(v73, "vertexTangent")
              && strcmp(v73, "vertexBitangent"))
            {
            }
          }
        }
      }
    }
    uint64_t v74 = v41;

    id v36 = v116;
    id v37 = v117;
    uint64_t v39 = v115;
LABEL_80:

    if (v132 && v136) {
      (*(void (**)(void))(*(void *)v132 + 40))();
    }

    long long v14 = v124;
    if (v124)
    {
      if (v125) {
        long long v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v124 + 40))();
      }
    }
    ++v16;
  }
  while (v16 != v111);
LABEL_87:
  [v112 save];
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v128);

  uint64_t v75 = [NSString stringWithUTF8String:v98];
  unint64_t v76 = [v75 stringByDeletingPathExtension];

  uint64_t v77 = [v76 stringByAppendingPathExtension:v104];

  uint64_t v56 = v101;
  if (([v101 fileExistsAtPath:v77] & 1) == 0)
  {
    id v120 = 0;
    char v84 = [v101 moveItemAtPath:v103 toPath:v77 error:&v120];
    uint64_t v41 = (_anonymous_namespace_ *)v120;
    if ((v84 & 1) == 0)
    {
      id v85 = (_anonymous_namespace_ *)std::system_category();
      long long v86 = v152;
      long long v87 = v153;
      *(unsigned char *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = v85;
      *(_OWORD *)(a3 + 24) = v86;
      *(_OWORD *)(a3 + 40) = v87;
      goto LABEL_107;
    }
    goto LABEL_95;
  }
  if (![v101 isDeletableFileAtPath:v77])
  {
    uint64_t v41 = 0;
LABEL_95:
    uint64_t v88 = v104;
    *(unsigned char *)a3 = 1;
    *(unsigned char *)(a3 + 8) = 1;
    goto LABEL_108;
  }
  uint64_t v78 = NSString;
  uint64_t v79 = [MEMORY[0x263F08C38] UUID];
  uint64_t v80 = [v79 UUIDString];
  uint64_t v51 = [v78 stringWithFormat:@"%@/%@.%@", v102, v80, v104];

  id v123 = 0;
  LOBYTE(v80) = [v101 moveItemAtPath:v77 toPath:v51 error:&v123];
  uint64_t v81 = (_anonymous_namespace_ *)v123;
  uint64_t v82 = v81;
  if ((v80 & 1) == 0)
  {
    id v89 = (_anonymous_namespace_ *)std::system_category();
    id v90 = "Could not backup original file";
    goto LABEL_106;
  }
  BOOL v122 = v81;
  char v83 = [v101 moveItemAtPath:v103 toPath:v77 error:&v122];
  uint64_t v41 = v122;

  if (v83)
  {

    goto LABEL_95;
  }
LABEL_104:
  int v121 = v41;
  char v91 = objc_msgSend(v56, "moveItemAtPath:toPath:error:", v51, v77, &v121, v95, v96);
  uint64_t v82 = v121;

  if (v91)
  {
    id v89 = (_anonymous_namespace_ *)std::system_category();
    id v90 = "Failed to write file.";
LABEL_106:
    long long v93 = v152;
    long long v94 = v153;
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = v89;
    *(_OWORD *)(a3 + 24) = v93;
    *(_OWORD *)(a3 + 40) = v94;

    uint64_t v41 = v82;
    uint64_t v56 = v101;
LABEL_107:
    uint64_t v88 = v104;
LABEL_108:
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v92, "assertion failure: '%s' (%s:line %i) We failed to attempting to replace a file", "!\"Unreachable code\"", "exportGeomMeshesToUSDFile", 497);
    _os_crash();
    __break(1u);
  }
}

void *re::FixedArray<int>::init<unsigned int const&>(void *result, uint64_t a2, uint64_t a3)
{
  *id result = a2;
  result[1] = a3;
  if (a3)
  {
    float32x4_t v4 = result;
    uint64_t v5 = 4 * a3;
    id result = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 4 * a3, 4);
    v4[2] = result;
    if (result)
    {
      int32x4_t v7 = result;
      if (a3 != 1)
      {
        id result = memset(result, 255, v5 - 4);
        int32x4_t v7 = (_DWORD *)((char *)v7 + v5 - 4);
      }
      *int32x4_t v7 = -1;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      id result = (void *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

unsigned char *re::Result<re::GeomMesh,re::DetailedError>::~Result(unsigned char *a1)
{
  if (*a1) {
    re::GeomMesh::~GeomMesh((re::GeomMesh *)(a1 + 8));
  }
  else {
    re::DynamicString::deinit((re::DynamicString *)(a1 + 24));
  }
  return a1;
}

uint64_t re::ImportGraphicsContext::ImportGraphicsContext(uint64_t a1, id *a2, id *a3, int a4, unsigned __int8 *a5)
{
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = *a3;
  *(unsigned char *)(a1 + 18) = BYTE2(a4);
  *(_WORD *)(a1 + 16) = a4;
  int v9 = *a5;
  *(unsigned char *)(a1 + 19) = v9;
  if (v9) {
    *(unsigned char *)(a1 + 20) = a5[1];
  }
  *(void *)(a1 + 24) = 0;
  return a1;
}

re::ImportGraphicsContext *re::ImportGraphicsContext::ImportGraphicsContext(re::ImportGraphicsContext *this, id *a2)
{
  *(void *)this = *a2;
  *((void *)this + 1) = a2[1];
  __int16 v4 = *((_WORD *)a2 + 8);
  *((unsigned char *)this + 18) = *((unsigned char *)a2 + 18);
  *((_WORD *)this + 8) = v4;
  uint64_t v5 = a2[3];
  if (v5) {
    LOBYTE(v5) = *v5;
  }
  *((unsigned char *)this + 19) = 1;
  *((unsigned char *)this + 20) = (_BYTE)v5;
  *((void *)this + 3) = a2;
  return this;
}

void re::ImportGraphicsContext::getOrCreateCommandQueue(uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, id *a4@<X8>)
{
  if (*(void *)(a1 + 24)) {
    re::ImportGraphicsResources::getOrCreateCommandQueue(*(void *)(a1 + 24), a2, a3, a4);
  }
  else {
    re::ImportGraphicsResources::createCommandQueue((id *)a1, *(const re::mtl::Device **)(a2 + 8), a3, a4);
  }
}

re::ImportGraphicsContext *re::ImportGraphicsContext::createFromRenderManager@<X0>(re::ImportGraphicsContext *this@<X0>, re::ImportGraphicsContext *a2@<X8>)
{
  uint64_t v5 = (id *)*((void *)this + 12);
  if (v5)
  {
    return re::ImportGraphicsContext::ImportGraphicsContext(a2, v5);
  }
  else
  {
    int32x4_t v7 = (unsigned __int8 *)*((void *)this + 19);
    uint64_t v8 = (id *)((char *)this + 184);
    int v9 = (id *)(*((void *)this + 7) + 248);
    int v10 = *((unsigned __int16 *)this + 140) | (*((unsigned __int8 *)this + 282) << 16);
    if (v7) {
      unsigned __int8 v11 = *v7;
    }
    else {
      unsigned __int8 v11 = 0;
    }
    v12[0] = 1;
    v12[1] = v11;
    return (re::ImportGraphicsContext *)re::ImportGraphicsContext::ImportGraphicsContext((uint64_t)a2, v8, v9, v10 & 0xFFFFFF, v12);
  }
}

void re::ImportGraphicsContext::createFromAvailableManagers(re::ImportGraphicsContext *this@<X0>, const re::RenderManager *a2@<X1>, re::ImportGraphicsContext *a3@<X8>)
{
  if (this)
  {
    re::ImportGraphicsContext::createFromRenderManager(this, a3);
  }
  else
  {
    id v7 = 0;
    id v8 = 0;
    if (a2) {
      unsigned __int8 v5 = *(unsigned char *)a2;
    }
    else {
      unsigned __int8 v5 = 0;
    }
    v6[0] = 1;
    v6[1] = v5;
    re::ImportGraphicsContext::ImportGraphicsContext((uint64_t)a3, &v8, &v7, 65793, v6);
  }
}

uint64_t re::internal::getFaceOrArrayLength(id *a1)
{
  if (objc_msgSend(*a1, sel_textureType) == (id)5) {
    return 6;
  }
  id v3 = objc_msgSend(*a1, sel_textureType);
  id v4 = *a1;
  if (v3 == (id)6) {
    return 6 * objc_msgSend(v4, sel_arrayLength);
  }
  if (objc_msgSend(v4, sel_textureType) == (id)3) {
    return (uint64_t)objc_msgSend(*a1, sel_arrayLength);
  }
  return 1;
}

{
  unsigned int v3;
  id v4;

  if (objc_msgSend(*a1, sel_textureType) == 5) {
    return 6;
  }
  id v3 = objc_msgSend(*a1, sel_textureType);
  id v4 = *a1;
  if (v3 == 6) {
    return 6 * objc_msgSend(v4, sel_arrayLength);
  }
  if (objc_msgSend(v4, sel_textureType) == 3) {
    return (uint64_t)objc_msgSend(*a1, sel_arrayLength);
  }
  return 1;
}

uint64_t re::internal::getFaceOrArrayLength(id *this, const re::TextureData *a2)
{
  if (*((_DWORD *)this + 22) < 2u)
  {
    if (objc_msgSend(this[1], sel_textureType) == 5) {
      return 6;
    }
    if (*((_DWORD *)this + 22) < 2u)
    {
      unsigned int v4 = objc_msgSend(this[1], sel_textureType);
      unsigned int v5 = *((_DWORD *)this + 22);
      if (v4 == 6)
      {
        if (v5 < 2) {
          return 6 * objc_msgSend(this[1], sel_arrayLength);
        }
      }
      else if (v5 < 2)
      {
        if (objc_msgSend(this[1], sel_textureType) != 3) {
          return 1;
        }
        if (*((_DWORD *)this + 22) < 2u) {
          return (uint64_t)objc_msgSend(this[1], sel_arrayLength);
        }
      }
    }
  }
  uint64_t v6 = (id *)std::__throw_bad_variant_access[abi:nn180100]();
  return re::internal::getFaceOrArrayLength(v6);
}

void re::internal::synchronizeTextureMipmaps(id *this, const re::TextureData *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (!*((_DWORD *)this + 22))
  {
    id v3 = this[1];
    if (objc_msgSend(v3, sel_storageMode) == (id)1)
    {
      re::TextureData::mipmapLevelCount((re::TextureData *)this);
      re::internal::getFaceOrArrayLength(this, v4);
      id v8 = objc_msgSend(v3, sel_device);
      re::ImportGraphicsResources::createCommandQueue(&v8, (const re::mtl::Device *)"blitMipmapsQueue", (const char *)1, &v13);

      re::mtl::CommandQueue::makeCommandBuffer(&v13, &v12);
      re::mtl::CommandBuffer::makeBlitCommandEncoder(&v12, &v11);
      [v11 endEncoding];
      [v12 commit];
      [v12 waitUntilCompleted];
      re::internal::getCommandBufferError(&v12, (uint64_t)&v8);
      if (!(_BYTE)v8)
      {
        uint64_t v6 = *re::pipelineLogObjects(v5);
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)
          || ((BYTE8(v9) & 1) != 0 ? (id v7 = (char *)v10) : (id v7 = (char *)&v9 + 9),
              *(_DWORD *)long long buf = 136315138,
              uint64_t v15 = v7,
        {
          if ((void)v9)
          {
            if (BYTE8(v9)) {
              (*(void (**)(void))(*(void *)v9 + 40))();
            }
            long long v9 = 0u;
            long long v10 = 0u;
          }
        }
      }
    }
    if (v3) {
  }
    }
}

void re::internal::getCommandBufferError(id *this@<X0>, uint64_t a2@<X8>)
{
  id v5 = *this;
  if (v5 && [v5 status] == 5)
  {
    re::mtl::CommandBuffer::error(this, v16);
    id v6 = v16[0];

    if (v6)
    {
      id v8 = [v6 localizedDescription];
      long long v9 = (_anonymous_namespace_ *)[v8 UTF8String];
      long long v10 = *(_OWORD *)v16;
      v16[0] = 0;
      v16[1] = 0;
      uint64_t v11 = v17;
      uint64_t v12 = v18;
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      *(unsigned char *)a2 = 0;
      *(_OWORD *)(a2 + 8) = v10;
      *(void *)(a2 + 24) = v11;
      *(void *)(a2 + 32) = v12;
    }
    else
    {
      long long v13 = *(_OWORD *)v16;
      uint64_t v14 = v17;
      uint64_t v15 = v18;
      *(unsigned char *)a2 = 0;
      *(_OWORD *)(a2 + 8) = v13;
      *(void *)(a2 + 24) = v14;
      *(void *)(a2 + 32) = v15;
    }
  }
  else
  {
    *(unsigned char *)a2 = 1;
  }
}

_anonymous_namespace_ *re::internal::ensureImageArrayConsistency@<X0>(_anonymous_namespace_ *result@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (!a2)
  {
    id v5 = "Image array is empty";
    goto LABEL_9;
  }
  if (a2 != 1 && a3 == 2)
  {
    id v5 = "Texture2D must have an image array of size 1";
LABEL_9:
    long long v6 = v21;
    uint64_t v7 = v22;
    uint64_t v8 = v23;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v6;
    *(void *)(a4 + 24) = v7;
    *(void *)(a4 + 32) = v8;
    return result;
  }
  if (a2 != 6 && a3 == 5)
  {
    id v5 = "TextureCube must have an image array of size 6";
    goto LABEL_9;
  }
  uint64_t v9 = a2 - 1;
  if (a2 != 1)
  {
    for (unsigned int i = (CGImage **)((char *)result + 8); ; ++i)
    {
      uint64_t v12 = *(i - 1);
      uint64_t v11 = *i;
      CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(v12);
      uint64_t v14 = (_anonymous_namespace_ *)CGImageGetBitmapInfo(v11);
      if (BitmapInfo != v14)
      {
        id v5 = "Inconsistent image CGBitmapInfo";
        goto LABEL_9;
      }
      CGImageGetColorSpace(v12);
      CGImageGetColorSpace(v11);
      uint64_t v15 = CGColorSpaceEqualToColorSpace();
      if ((v15 & 1) == 0) {
        break;
      }
      size_t BitsPerPixel = CGImageGetBitsPerPixel(v12);
      uint64_t v17 = (_anonymous_namespace_ *)CGImageGetBitsPerPixel(v11);
      if ((_anonymous_namespace_ *)BitsPerPixel != v17
        || (size_t BitsPerComponent = CGImageGetBitsPerComponent(v12),
            uint64_t v17 = (_anonymous_namespace_ *)CGImageGetBitsPerComponent(v11),
            (_anonymous_namespace_ *)BitsPerComponent != v17))
      {
        id v5 = "Inconsistent image pixel format";
        goto LABEL_9;
      }
      size_t Width = CGImageGetWidth(v12);
      id result = (_anonymous_namespace_ *)CGImageGetWidth(v11);
      if ((_anonymous_namespace_ *)Width != result
        || (size_t Height = CGImageGetHeight(v12),
            id result = (_anonymous_namespace_ *)CGImageGetHeight(v11),
            (_anonymous_namespace_ *)Height != result))
      {
        id v5 = "Inconsistent image size";
        goto LABEL_9;
      }
      *(unsigned char *)a4 = 1;
      if (!--v9) {
        return result;
      }
    }
    id v5 = "Inconsistent image CGColorSpace";
    goto LABEL_9;
  }
  *(unsigned char *)a4 = 1;
  return result;
}

uint64_t re::internal::getDestinationTransferFunctionFromOptions(re::internal *this, const re::TextureFromImageOptions *a2, CGColorSpace *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  unsigned int v3 = *((_DWORD *)this + 12);
  if (v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 1;
  }
  if (v3 || (a3 & 1) != 0) {
    return v4;
  }
  if ((*((_DWORD *)this + 14) - 3) > 1) {
    return 0;
  }
  CFStringRef v6 = (const __CFString *)*((id *)this + 8);
  if (!v6)
  {
LABEL_11:
    if (a2)
    {
      long long v10 = 0;
      uint64_t v9 = a2;
      goto LABEL_13;
    }
    return 0;
  }
  CFStringRef v8 = v6;
  uint64_t v9 = CGColorSpaceCreateWithName(v6);
  long long v10 = v9;
  if (!v9)
  {
    uint64_t v11 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = v11;
      int v16 = 136315138;
      CStringPtr = CFStringGetCStringPtr(v8, 0x8000100u);
      _os_log_impl(&dword_233120000, v12, OS_LOG_TYPE_DEFAULT, "Invalid colorSpaceNameOverride: %s", (uint8_t *)&v16, 0xCu);
    }
    goto LABEL_11;
  }
LABEL_13:
  ColorSpaceTransferFunctiouint64_t n = re::getColorSpaceTransferFunction(v9, v7);
  if (re::internal::colorSpaceIsExtendedOrHDR(v9, v14)) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = ColorSpaceTransferFunction;
  }
  if (v10) {
    CGColorSpaceRelease(v10);
  }
  return v4;
}

uint64_t re::internal::broadcastRToRGB(unsigned __int8 *a1)
{
  int v1 = *a1;
  if ((v1 - 2) < 3) {
    int v1 = 2;
  }
  int v2 = a1[1];
  if ((v2 - 2) < 3) {
    int v2 = 2;
  }
  int v3 = a1[2];
  if ((v3 - 2) < 3) {
    int v3 = 2;
  }
  if (a1[3] - 2 >= 3) {
    int v4 = a1[3];
  }
  else {
    int v4 = 2;
  }
  return (v3 << 16) | (v4 << 24) | (v2 << 8) | v1;
}

uint64_t re::internal::downsampleFactorToFitDeviceLimits(id *a1, int a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  id v6 = *a1;
  if (!v6) {
    return 1;
  }
  if (a3 <= a4) {
    unint64_t v7 = a4;
  }
  else {
    unint64_t v7 = a3;
  }
  if (v7 <= a5) {
    unsigned int v8 = a5;
  }
  else {
    unsigned int v8 = v7;
  }
  if (a2 == 7)
  {
    unsigned int v9 = 2048;
  }
  else
  {
    unsigned int v9 = 0x4000;
    if (([v6 supportsFamily:1003] & 1) == 0)
    {
      if ([*a1 supportsFamily:2002]) {
        unsigned int v9 = 0x4000;
      }
      else {
        unsigned int v9 = 0x2000;
      }
    }
  }
  uint64_t result = 1;
  if (v9 < v8)
  {
    char v11 = __clz(v8);
    unsigned int v12 = (0x80000000 >> v11) - 1;
    char v13 = 32 - v11;
    char v14 = v11 ^ 0x1F;
    if ((v12 & v8) != 0) {
      char v14 = v13;
    }
    char v15 = __clz(v9);
    unsigned int v16 = (0x80000000 >> v15) - 1;
    char v17 = v15 | 0xE0;
    char v18 = v15 - 31;
    if ((v16 & v9) != 0) {
      char v19 = v17;
    }
    else {
      char v19 = v18;
    }
    return (1 << (v19 + v14));
  }
  return result;
}

void re::TextureFromImageOptions::setColorSpace(re::TextureFromImageOptions *this, __CFString *a2)
{
  if (a2) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  id v5 = v4;
  id v6 = (void *)*((void *)this + 8);
  *((void *)this + 8) = a2;
}

id re::internal::applySemanticToOptions@<X0>(re::internal *this@<X0>, uint64_t a2@<X8>)
{
  long long v5 = *((_OWORD *)this + 1);
  *(_OWORD *)a2 = *(_OWORD *)this;
  *(_OWORD *)(a2 + 16) = v5;
  *(_OWORD *)(a2 + 32) = *((_OWORD *)this + 2);
  *(_OWORD *)(a2 + 44) = *(_OWORD *)((char *)this + 44);
  id result = *((id *)this + 8);
  *(void *)(a2 + 64) = result;
  *(_OWORD *)(a2 + 72) = *(_OWORD *)((char *)this + 72);
  if (*(_DWORD *)a2 == 2) {
    *(_DWORD *)a2 = 0;
  }
  if (*(_DWORD *)(a2 + 4) == 3)
  {
    int v7 = *(_DWORD *)(a2 + 56);
    if (v7)
    {
      if (v7 == 2) {
        int v8 = 1;
      }
      else {
        int v8 = 2 * ((v7 - 3) < 2);
      }
    }
    else
    {
      int v8 = 2;
    }
    *(_DWORD *)(a2 + 4) = v8;
  }
  return result;
}

BOOL re::internal::isBasisTextureData(CFDataRef *this, const __CFData *const *a2)
{
  BytePtr = CFDataGetBytePtr(*this);
  return (unint64_t)CFDataGetLength(*this) >= 2 && *BytePtr == 115 && BytePtr[1] == 66;
}

uint64_t re::internal::textureMightNeedPixelFormatViewUsage()
{
  return 0;
}

void re::internal::createRepackedTexture(id *a1@<X0>, id *a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  int v8 = (re *)objc_msgSend(*a2, sel_textureType);
  if ((unint64_t)v8 > 7 || ((1 << (char)v8) & 0xAC) == 0)
  {
    unint64_t v26 = *re::pipelineLogObjects(v8);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      id v31 = *a2;
      unsigned int v32 = v26;
      *(_DWORD *)id v37 = 67109120;
      *(_DWORD *)&uint64_t v37[4] = objc_msgSend(v31, sel_textureType);
      _os_log_error_impl(&dword_233120000, v32, OS_LOG_TYPE_ERROR, "Unable to repack texture type %d", v37, 8u);
    }
    *a4 = 0;
  }
  else
  {
    int v10 = objc_msgSend(*a2, sel_pixelFormat);
    uint64_t v40 = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    *(_OWORD *)id v37 = 0u;
    MTLPixelFormatGetInfoForDevice();
    uint64_t isHDR = re::isHDR(v10);
    unint64_t v12 = 0 / 0uLL;
    int v13 = 10;
    if (0 / 0uLL <= 0x1F) {
      int v14 = 25;
    }
    else {
      int v14 = 55;
    }
    if (isHDR) {
      int v13 = v14;
    }
    if (v12 <= 0x1F) {
      int v15 = 115;
    }
    else {
      int v15 = 125;
    }
    if (!isHDR) {
      int v15 = 70;
    }
    if (v39 == 1) {
      unsigned int v16 = v13;
    }
    else {
      unsigned int v16 = v15;
    }
    uint64_t v17 = 8;
    if (isHDR) {
      uint64_t v17 = 16;
    }
    if (v12 <= 0x1F) {
      unint64_t v18 = v17;
    }
    else {
      unint64_t v18 = 32;
    }
    if (v12 > v18)
    {
      char v19 = *re::pipelineLogObjects((re *)isHDR);
      uint64_t isHDR = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
      if (isHDR)
      {
        *(_DWORD *)long long buf = 134218240;
        *(void *)&uint8_t buf[4] = 8 * *((void *)&v38 + 1) / (unint64_t)v39;
        __int16 v35 = 2048;
        unint64_t v36 = v18;
        _os_log_impl(&dword_233120000, v19, OS_LOG_TYPE_DEFAULT, "Texture repack lost precision (before: %zu bpc, after: %zu bpc)", buf, 0x16u);
      }
    }
    uint64_t v20 = *re::pipelineLogObjects((re *)isHDR);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      if (a3 > 5u) {
        int v27 = 63;
      }
      else {
        int v27 = *(_DWORD *)&a0_3[4 * (char)a3];
      }
      if (BYTE1(a3) > 5u) {
        int v28 = 63;
      }
      else {
        int v28 = *(_DWORD *)&a0_3[(uint64_t)(a3 >> 8 << 56) >> 54];
      }
      if (BYTE2(a3) > 5u) {
        int v29 = 63;
      }
      else {
        int v29 = *(_DWORD *)&a0_3[(uint64_t)(a3 >> 16 << 56) >> 54];
      }
      if (BYTE3(a3) > 5u) {
        int v30 = 63;
      }
      else {
        int v30 = *(_DWORD *)&a0_3[(uint64_t)(a3 >> 24 << 56) >> 54];
      }
      *(_DWORD *)id v37 = 67110144;
      *(_DWORD *)&uint64_t v37[4] = v16;
      *(_WORD *)&v37[8] = 1024;
      *(_DWORD *)&unsigned char v37[10] = v27;
      *(_WORD *)&v37[14] = 1024;
      LODWORD(v38) = v28;
      WORD2(v38) = 1024;
      *(_DWORD *)((char *)&v38 + 6) = v29;
      WORD5(v38) = 1024;
      HIDWORD(v38) = v30;
      _os_log_debug_impl(&dword_233120000, v20, OS_LOG_TYPE_DEBUG, "Repacking texture to pixel format %d to bake in texture swizzle '%c%c%c%c'", v37, 0x20u);
    }
    *(void *)id v37 = *a1;
    uint64_t v21 = objc_msgSend(*a2, sel_usage) | 2;
    id v22 = objc_msgSend(*a2, sel_storageMode);
    id v23 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
    objc_msgSend(v23, sel_setStorageMode_, v22);
    objc_msgSend(v23, sel_setTextureType_, objc_msgSend(*a2, sel_textureType));
    objc_msgSend(v23, sel_setWidth_, objc_msgSend(*a2, sel_width));
    objc_msgSend(v23, sel_setHeight_, objc_msgSend(*a2, sel_height));
    objc_msgSend(v23, sel_setDepth_, objc_msgSend(*a2, sel_depth));
    objc_msgSend(v23, sel_setArrayLength_, objc_msgSend(*a2, sel_arrayLength));
    objc_msgSend(v23, sel_setPixelFormat_, v16);
    objc_msgSend(v23, sel_setMipmapLevelCount_, objc_msgSend(*a2, sel_mipmapLevelCount));
    objc_msgSend(v23, sel_setSampleCount_, objc_msgSend(*a2, sel_sampleCount));
    objc_msgSend(v23, sel_setUsage_, v21);
    objc_msgSend(v23, sel_setCpuCacheMode_, objc_msgSend(*a2, sel_cpuCacheMode));
    *(void *)long long buf = 0;
    if (objc_msgSend(*a2, sel_isShareable)) {
      re::mtl::Device::makeSharedTexture(v23, (id *)v37, v33);
    }
    else {
      re::mtl::Device::makeTexture(v23, (id *)v37, v33);
    }
    NS::SharedPtr<MTL::Texture>::operator=((void **)buf, v33);
    unint64_t v24 = (re *)v33[0];
    if (v33[0]) {

    }
    if (*(void *)buf)
    {
      re::copyTexture(a1, a2, (id *)buf, a3, 0);
      *a4 = *(void *)buf;
    }
    else
    {
      unint64_t v25 = *re::pipelineLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
      {
        LOWORD(v33[0]) = 0;
        _os_log_fault_impl(&dword_233120000, v25, OS_LOG_TYPE_FAULT, "Failed to create repacked texture", (uint8_t *)v33, 2u);
      }
      *a4 = 0;
      if (*(void *)buf) {
    }
      }
    if (v23) {
  }
    }
}

void re::copyTexture(id *a1, id *a2, id *a3, unint64_t a4, int a5)
{
  int v6 = a4;
  unint64_t v10 = a4 >> 8;
  uint64_t v57 = *MEMORY[0x263EF8340];
  unint64_t v11 = a4 >> 16;
  unint64_t v12 = a4 >> 24;
  int v13 = *re::pipelineLogObjects((re *)a1);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    id v41 = *a2;
    int v28 = v13;
    unsigned int v29 = objc_msgSend(v41, sel_pixelFormat);
    unsigned int v30 = objc_msgSend(*a3, sel_pixelFormat);
    if (v6 > 5u) {
      int v31 = 63;
    }
    else {
      int v31 = *(_DWORD *)&a0_3[4 * (char)v6];
    }
    if (BYTE1(v6) > 5u) {
      int v32 = 63;
    }
    else {
      int v32 = *(_DWORD *)&a0_3[4 * (char)v10];
    }
    if (BYTE2(v6) > 5u) {
      int v33 = 63;
    }
    else {
      int v33 = *(_DWORD *)&a0_3[4 * (char)v11];
    }
    if (HIBYTE(v6) > 5u) {
      int v34 = 63;
    }
    else {
      int v34 = *(_DWORD *)&a0_3[4 * (char)v12];
    }
    *(_DWORD *)long long buf = 67110400;
    *(_DWORD *)&uint8_t buf[4] = v29;
    *(_WORD *)&uint8_t buf[8] = 1024;
    *(_DWORD *)&buf[10] = v30;
    *(_WORD *)&buf[14] = 1024;
    LODWORD(v54) = v31;
    WORD2(v54) = 1024;
    *(_DWORD *)((char *)&v54 + 6) = v32;
    WORD5(v54) = 1024;
    HIDWORD(v54) = v33;
    LOWORD(v55) = 1024;
    *(_DWORD *)((char *)&v55 + 2) = v34;
    _os_log_debug_impl(&dword_233120000, v28, OS_LOG_TYPE_DEBUG, "Copying texture from pixel format %d to pixel format %d to bake in texture swizzle '%c%c%c%c'", buf, 0x26u);
  }
  v48[0] = v6;
  v48[1] = v10;
  v48[2] = v11;
  void v48[3] = v12;
  int v14 = (char *)objc_msgSend(*a2, sel_textureType);
  if ((unint64_t)(v14 - 2) >= 2)
  {
    if (v14 == (char *)7)
    {
      char v39 = a5;
      if (a5) {
        int v15 = "repack3DTextureWithSRGBToLinear";
      }
      else {
        int v15 = "repack3DTexture";
      }
      uint64_t v16 = 7;
      goto LABEL_13;
    }
    if (v14 != (char *)5) {
      return;
    }
  }
  char v39 = a5;
  if (a5) {
    int v15 = "repack2DTextureWithSRGBToLinear";
  }
  else {
    int v15 = "repack2DTexture";
  }
  uint64_t v16 = 2;
LABEL_13:
  id v40 = (id)v16;
  id v17 = objc_msgSend(objc_msgSend(MEMORY[0x263F128B8], sel_alloc), sel_init);
  objc_msgSend(v17, sel_setName_, objc_msgSend(NSString, sel_stringWithCString_encoding_, v15, 4));
  re::mtl::Library::makeFunctionWithDescriptor(a1 + 1, v17, &v47);
  id v18 = objc_msgSend(objc_msgSend(MEMORY[0x263F12850], sel_alloc), sel_init);
  id v46 = v18;
  char v19 = v47;
  objc_msgSend(v18, sel_setComputeFunction_, v47);
  re::mtl::Device::makeComputePipelineState(a1, &v46, &v45);
  re::ImportGraphicsContext::getOrCreateCommandQueue((uint64_t)a1, (uint64_t)&re::internal::copyTextureQueueName(void)::queueName, (const char *)1, &v44);
  re::mtl::CommandQueue::makeCommandBuffer(&v44, &v43);
  re::mtl::CommandBuffer::makeComputeCommandEncoder(&v43, &v42);
  id v20 = v45;
  [v42 setComputePipelineState:v45];
  [v42 setBytes:v48 length:4 atIndex:0];
  uint64_t v21 = (uint64_t)objc_msgSend(*a2, sel_pixelFormat);
  uint64_t v22 = (uint64_t)objc_msgSend(*a3, sel_pixelFormat);
  objc_msgSend(*a3, sel_pixelFormat);
  uint64_t v56 = 0;
  long long v54 = 0u;
  long long v55 = 0u;
  *(_OWORD *)long long buf = 0u;
  MTLPixelFormatGetInfoForDevice();
  if ((*(_WORD *)&buf[8] & 0x800) != 0)
  {
    if ((v39 & 1) == 0)
    {
      uint64_t v56 = 0;
      long long v54 = 0u;
      long long v55 = 0u;
      *(_OWORD *)long long buf = 0u;
      InfoForDevice = (re *)MTLPixelFormatGetInfoForDevice();
      if ((*(_WORD *)&buf[8] & 0x800) != 0)
      {
        uint64_t v21 = (int)re::translateSRGBPixelFormatToLinear(v21);
      }
      else
      {
        unint64_t v25 = *re::pipelineLogObjects(InfoForDevice);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_error_impl(&dword_233120000, v25, OS_LOG_TYPE_ERROR, "Copying from a linear to an sRGB texture will result if wrong gamma values.", buf, 2u);
        }
      }
    }
    uint64_t v23 = (uint64_t)v40;
    uint64_t v22 = (int)re::translateSRGBPixelFormatToLinear(v22);
  }
  else
  {
    uint64_t v23 = (uint64_t)v40;
  }
  re::encodeProcessTextureCommands(a1, &v45, &v42, a2, a3, v21, v22, v23);
  [v42 endEncoding];
  [v43 commit];
  [v43 waitUntilCompleted];
  re::internal::getCommandBufferError(&v43, (uint64_t)buf);
  if (!buf[0])
  {
    int v27 = *re::pipelineLogObjects(v26);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      goto LABEL_33;
    }
    id v35 = *a2;
    unint64_t v36 = v27;
    id v37 = objc_msgSend(objc_msgSend(v35, sel_label), sel_UTF8String);
    long long v38 = (v54 & 1) != 0 ? (long long *)*((void *)&v54 + 1) : (long long *)((char *)&v54 + 1);
    *(_DWORD *)uint64_t v49 = 136315394;
    id v50 = v37;
    __int16 v51 = 2080;
    uint64_t v52 = v38;

    if (!buf[0])
    {
LABEL_33:
      if (*(void *)&buf[8] && (v54 & 1) != 0) {
        (*(void (**)(void))(**(void **)&buf[8] + 40))();
      }
    }
  }

  if (v20) {
  if (v18)
  }

  if (v19) {
  if (v17)
  }
}

BOOL re::TextureFromImageOptions::operator==(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)(a1 + 64);
  id v5 = *(id *)(a2 + 64);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    BOOL v7 = v4 == v5;
  }
  else {
    BOOL v7 = CFEqual(v4, v5) != 0;
  }
  if (*(_DWORD *)a1 != *(_DWORD *)a2
    || *(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4)
    || *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16)
    || *(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20)
    || *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)
    || *(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a2 + 44)
    || *(_DWORD *)(a1 + 48) != *(_DWORD *)(a2 + 48)
    || *(unsigned __int8 *)(a1 + 52) != *(unsigned __int8 *)(a2 + 52)
    || *(_DWORD *)(a1 + 72) != *(_DWORD *)(a2 + 72)
    || *(_DWORD *)(a1 + 76) != *(_DWORD *)(a2 + 76)
    || *(_DWORD *)(a1 + 80) != *(_DWORD *)(a2 + 80)
    || *(_DWORD *)(a1 + 28) != *(_DWORD *)(a2 + 28)
    || *(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 32)
    || *(unsigned __int8 *)(a1 + 36) != *(unsigned __int8 *)(a2 + 36)
    || *(float *)(a1 + 40) != *(float *)(a2 + 40)
    || *(_DWORD *)(a1 + 84) != *(_DWORD *)(a2 + 84))
  {
    return 0;
  }
  if (*(_DWORD *)(a1 + 56) == *(_DWORD *)(a2 + 56)) {
    return v7;
  }
  return 0;
}

BOOL re::canLoadTextureFileWithExtension(re *this, const char *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  char v2 = *(unsigned char *)this;
  int v3 = __s1;
  if (*(unsigned char *)this)
  {
    uint64_t v4 = 0;
    do
    {
      if ((v2 - 65) < 0x1Au) {
        v2 += 32;
      }
      __s1[v4] = v2;
      uint64_t v5 = v4 + 1;
      char v2 = *((unsigned char *)this + v4 + 1);
      if (v2) {
        BOOL v6 = v4 == 30;
      }
      else {
        BOOL v6 = 1;
      }
      ++v4;
    }
    while (!v6);
    int v3 = &__s1[v5];
  }
  uint64_t v7 = 0;
  *int v3 = 0;
  do
  {
    int v8 = strcmp(__s1, re::canLoadTextureFileWithExtension(char const*)::supported[v7]);
    if (!v8) {
      break;
    }
    BOOL v6 = v7++ == 15;
  }
  while (!v6);
  return v8 == 0;
}

void re::loadMetalTextureWithReleasedCGImageSource(re::internal *this@<X4>, CGImageSource *a2@<X0>, id *a3@<X1>, id *a4@<X2>, uint64_t a5@<X3>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  void v54[3] = *MEMORY[0x263EF8340];
  *(unsigned char *)a8 &= 0x80u;
  *(void *)(a8 + 8) = 0;
  uint64_t v24 = a8 + 8;
  *(_DWORD *)(a8 + 88) = 0;
  *(void *)(a8 + 96) = 0;
  locatiouint64_t n = (id *)(a8 + 96);
  uint64_t v53 = 0;
  unsigned int v52 = 84148994;
  re::internal::applySemanticToOptions(this, (uint64_t)v50);
  size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(0);
  CGColorSpaceModel Model = CGColorSpaceGetModel(0);
  int v14 = (void *)MEMORY[0x237DBDCF0]();
  re::createCGImagePtrFromCGImageSource(a3, a2, (uint64_t)v50, (uint64_t)&image);
  long long v15 = v36;
  long long v36 = 0u;
  long long v43 = v15;
  long long v16 = v37;
  long long v37 = 0u;
  long long v44 = v16;
  long long v17 = v38;
  size_t v18 = v39;
  long long v38 = 0u;
  CGImageRef v42 = image;
  uint64_t v45 = v17;
  CGColorSpaceModel v19 = v40;
  CGImageRef image = 0;
  size_t v39 = NumberOfComponents;
  CGColorSpaceModel v40 = Model;
  CGColorSpaceRelease(0);
  CGColorSpaceRef v46 = (CGColorSpaceRef)*((void *)&v17 + 1);
  size_t v47 = v18;
  CGColorSpaceModel v48 = v19;
  CGColorSpaceRelease(0);
  CGColorSpaceRelease(0);
  int v20 = v41;
  int v41 = 0;
  int v49 = v20;
  CGImageRelease(image);
  CGImageRef image = 0;
  CGColorSpaceRelease(*((CGColorSpaceRef *)&v38 + 1));
  *((void *)&v38 + 1) = 0;
  CFRelease(a2);
  re::createTextureDescriptorForCGImagePtr((uint64_t)&v42, a3, a4, (re::internal *)v50, 0, v54, &v53, &v52, &v34);
  CGColorSpaceRef DestinationColorSpace = re::getDestinationColorSpace((uint64_t)&v42, a3, &v34, (uint64_t)this, (uint64_t)v33);
  uint64_t v22 = (void *)MEMORY[0x237DBDCF0](DestinationColorSpace);
  re::createTextureFromCGImagePtr((uint64_t)&v42, (uint64_t)a3, &v34, a5, (uint64_t)this, a6, (uint64_t)v33, (uint64_t)v54, v53, (uint64_t)&v52, a7);
  if (v30[0])
  {
    *(unsigned char *)a8 = v30[8];
    std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>(v24, (uint64_t)&v31);
    re::ObjCObject::operator=(location, &v32);
  }
  if (re::TextureData::isValid((re::TextureData *)a8)
    && (*((_DWORD *)this + 14) - 3) <= 1
    && v33[0])
  {
    Name = (__CFString *)CGColorSpaceGetName(v33[0]);
    re::TextureData::setColorSpace((id *)a8, Name);
  }
  re::Result<re::TextureData,re::DynamicString>::~Result((uint64_t)v30);
  CGColorSpaceRelease(v33[0]);
  if (v34) {

  }
  CGImageRelease(v42);
  CGImageRef v42 = 0;
  CGColorSpaceRelease(v46);
}

void re::loadMetalTextureWithReleasedCGImage(re::internal *this@<X4>, const re::ImportGraphicsContext *a2@<X0>, re *a3@<X1>, id *a4@<X2>, uint64_t a5@<X3>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  v31[3] = *MEMORY[0x263EF8340];
  *(unsigned char *)a8 &= 0x80u;
  *(void *)(a8 + 8) = 0;
  uint64_t v16 = a8 + 8;
  *(_DWORD *)(a8 + 88) = 0;
  *(void *)(a8 + 96) = 0;
  long long v17 = (id *)(a8 + 96);
  uint64_t v30 = 0;
  unsigned int v29 = 84148994;
  re::internal::applySemanticToOptions(this, (uint64_t)v28);
  CGImageRefWithColorSpace = re::createCGImageRefWithColorSpace(a3, a2, v28, (const re::TextureFromImageOptions *)1);
  CGImagePtr::CGImagePtr((CGImagePtr *)image, CGImageRefWithColorSpace);
  re::createTextureDescriptorForCGImagePtr((uint64_t)image, (id *)a3, a4, (re::internal *)v28, 0, v31, &v30, &v29, &v26);
  CGColorSpaceRef DestinationColorSpace = re::getDestinationColorSpace((uint64_t)image, a3, &v26, (uint64_t)v28, (uint64_t)space);
  int v20 = (void *)MEMORY[0x237DBDCF0](DestinationColorSpace);
  re::createTextureFromCGImagePtr((uint64_t)image, (uint64_t)a3, &v26, a5, (uint64_t)v28, a6, (uint64_t)space, (uint64_t)v31, v30, (uint64_t)&v29, a7);
  if (v22[0])
  {
    *(unsigned char *)a8 = v22[8];
    std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>(v16, (uint64_t)&v23);
    re::ObjCObject::operator=(v17, &v24);
  }
  if (re::TextureData::isValid((re::TextureData *)a8)
    && (*((_DWORD *)this + 14) - 3) <= 1
    && space[0])
  {
    Name = (__CFString *)CGColorSpaceGetName(space[0]);
    re::TextureData::setColorSpace((id *)a8, Name);
  }
  re::Result<re::TextureData,re::DynamicString>::~Result((uint64_t)v22);
  CGColorSpaceRelease(space[0]);
  if (v26) {

  }
  CGImageRelease(image[0]);
  image[0] = 0;
  CGColorSpaceRelease(image[6]);
}

void re::loadTextureWithContentsOfFile(uint64_t a1@<X0>, id *a2@<X1>, id *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  int v14 = [NSURL fileURLWithFileSystemRepresentation:a1 isDirectory:0 relativeToURL:0];
  long long v15 = [v14 pathExtension];
  int v16 = [v15 isEqual:@"ktx"];

  if (v16)
  {
    id v33 = 0;
    long long v17 = [MEMORY[0x263EFF8F8] dataWithContentsOfURL:v14 options:1 error:&v33];
    size_t v18 = (re *)v33;
    CFDictionaryRef v19 = v18;
    if (v17)
    {
      id v20 = v17;
      uint64_t v28 = a6;
      uint64_t v21 = (__n128 *)[v20 bytes];
      unint64_t v22 = [v20 length];
      unsigned int v23 = objc_msgSend(*a3, sel_swizzle);
      long long v24 = *(_OWORD *)(a5 + 16);
      v29[0] = *(_OWORD *)a5;
      v29[1] = v24;
      v30[0] = *(_OWORD *)(a5 + 32);
      *(_OWORD *)((char *)v30 + 12) = *(_OWORD *)(a5 + 44);
      id v31 = *(id *)(a5 + 64);
      long long v32 = *(_OWORD *)(a5 + 72);
      re::createTextureWithKTXData((uint64_t)a2, v21, v22, v23, a4, (uint64_t)v29, v28, 0, a7, 0);
    }
    else
    {
      id v26 = *re::pipelineLogObjects(v18);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315394;
        uint64_t v37 = a1;
        __int16 v38 = 2112;
        CFDictionaryRef v39 = v19;
        _os_log_error_impl(&dword_233120000, v26, OS_LOG_TYPE_ERROR, "Failed to create texture from path: %s: %@", buf, 0x16u);
      }
      *(unsigned char *)a7 &= 0x80u;
      *(void *)(a7 + 8) = 0;
      *(_DWORD *)(a7 + 88) = 0;
      *(void *)(a7 + 96) = 0;
    }
  }
  else
  {
    v34[0] = *MEMORY[0x263F0F600];
    v34[1] = @"kCGImageSourceCreateUnpremultipliedPNG";
    v35[0] = MEMORY[0x263EFFA80];
    v35[1] = MEMORY[0x263EFFA88];
    CFDictionaryRef v19 = [NSDictionary dictionaryWithObjects:v35 forKeys:v34 count:2];
    unint64_t v25 = CGImageSourceCreateWithURL((CFURLRef)v14, v19);
    if (v25)
    {
      re::loadMetalTextureWithReleasedCGImageSource((re::internal *)a5, v25, a2, a3, a4, a6, 0, a7);
    }
    else
    {
      int v27 = *re::pipelineLogObjects(0);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315138;
        uint64_t v37 = a1;
        _os_log_error_impl(&dword_233120000, v27, OS_LOG_TYPE_ERROR, "Failed to create texture from path: %s", buf, 0xCu);
      }
      *(unsigned char *)a7 &= 0x80u;
      *(void *)(a7 + 8) = 0;
      *(_DWORD *)(a7 + 88) = 0;
      *(void *)(a7 + 96) = 0;
    }
  }
}

void re::loadTextureWithData(id *a1@<X0>, id *a2@<X1>, id *a3@<X2>, const char *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, re::TextureData *a7@<X8>)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  int v14 = (unsigned __int8 *)[*a1 bytes];
  if ((unint64_t)[*a1 length] >= 0xC && *v14 == 171)
  {
    uint64_t v15 = 1u;
    while (v15 != 12)
    {
      int v16 = v14[v15];
      if (v16 != v17)
      {
        if ((unint64_t)(v15 - 2) < 0xB) {
          goto LABEL_8;
        }
        break;
      }
    }
    size_t v18 = (__n128 *)[*a1 bytes];
    unint64_t v19 = [*a1 length];
    unsigned int v20 = objc_msgSend(*a3, sel_swizzle);
    long long v21 = *(_OWORD *)(a5 + 16);
    v25[0] = *(_OWORD *)a5;
    v25[1] = v21;
    v26[0] = *(_OWORD *)(a5 + 32);
    *(_OWORD *)((char *)v26 + 12) = *(_OWORD *)(a5 + 44);
    id v27 = *(id *)(a5 + 64);
    long long v28 = *(_OWORD *)(a5 + 72);
    re::createTextureWithKTXData((uint64_t)a2, v18, v19, v20, (uint64_t)a4, (uint64_t)v25, a6, 0, (uint64_t)a7, 0);
  }
  else
  {
LABEL_8:
    unint64_t v22 = CGImageSourceCreateWithData((CFDataRef)*a1, 0);
    re::loadMetalTextureWithReleasedCGImageSource((re::internal *)a5, v22, a2, a3, (uint64_t)a4, a6, 0, (uint64_t)a7);
    isValid = (re *)re::TextureData::isValid(a7);
    if (isValid)
    {
      re::TextureData::setLabel(a7, a4);
    }
    else
    {
      long long v24 = *re::pipelineLogObjects(isValid);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136315138;
        uint64_t v30 = a4;
        _os_log_error_impl(&dword_233120000, v24, OS_LOG_TYPE_ERROR, "Failed to create texture from data labeled '%s'", buf, 0xCu);
      }
    }
  }
}

void re::loadTextureDataWithProvider(re *this@<X0>, re::TextureProvider *a2@<X1>, re::Allocator *a3@<X2>, uint64_t a4@<X8>)
{
  v106[3] = *(CFDataRef *)MEMORY[0x263EF8340];
  uint64_t v7 = (id *)((char *)this + 40);
  if (*((void *)this + 2)) {
    int v8 = (char *)*((void *)this + 3);
  }
  else {
    int v8 = (char *)this + 17;
  }
  unsigned int v9 = (const re::ImportGraphicsContext *)(*(uint64_t (**)(re *, re::TextureProvider *, re::Allocator *))(*(void *)this + 64))(this, a2, a3);
  char v84 = v9;
  if (!v9) {
    goto LABEL_18;
  }
  CGImageRef v97 = (CGImageRef)&unk_26E715570;
  unint64_t v98 = (unint64_t)&v84;
  uint64_t v99 = this;
  uint64_t v100 = &v97;
  re::loadMetalTextureWithReleasedCGImage((re *)((char *)this + 48), v9, (re *)((char *)this + 144), v7, (uint64_t)v8, (uint64_t)a2, (uint64_t)&v97, (uint64_t)buf);
  if (!v100) {
    goto LABEL_116;
  }
  (*((void (**)(CGImageRef *))*v100 + 6))(v100);
  if (v95)
  {
    if (v95 != 1) {
      goto LABEL_117;
    }
    if (!v92) {
      goto LABEL_15;
    }
  }
  if (!*(void *)&buf[8])
  {
LABEL_15:

    if (v95 != -1) {
      ((void (*)(unsigned char *, uint8_t *))*(&off_26E715550 + v95))(image, &buf[8]);
    }
    std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](&v97);
LABEL_18:
    (*(void (**)(uint8_t *__return_ptr, re *))(*(void *)this + 72))(buf, this);
    if (buf[0])
    {
      if (*(void *)&buf[8] && v93) {
        (*(void (**)(void))(**(void **)&buf[8] + 40))();
      }
      (*(void (**)(uint8_t *__return_ptr, re *))(*(void *)this + 80))(buf, this);
      uint64_t v11 = (re *)((char *)this + 144);
      (*(void (**)(const re::ImportGraphicsContext **__return_ptr, re *))(*(void *)this + 72))(&v84, this);
      unint64_t v12 = (id *)((char *)this + 48);
      int v13 = (_anonymous_namespace_ *)(*(void *(**)(uint64_t *__return_ptr, re *))(*(void *)this + 80))(&v72, this);
      if (!v87)
      {
        long long v28 = *(_OWORD *)buf;
        uint64_t v29 = v90;
        uint64_t v30 = v91;
        *(unsigned char *)a4 = 0;
        *(_OWORD *)(a4 + 8) = v28;
        *(void *)(a4 + 24) = v29;
        *(void *)(a4 + 32) = v30;
        goto LABEL_93;
      }
      uint64_t v14 = HIDWORD(v72);
      uint64_t v15 = CGImageRetain(*v88);
      CGImageRefWithColorSpace = re::createCGImageRefWithColorSpace(v11, v15, v12, 0);
      CGImagePtr::CGImagePtr((CGImagePtr *)image, CGImageRefWithColorSpace);
      uint64_t v81 = 0;
      unsigned int v80 = 84148994;
      re::internal::applySemanticToOptions((re::internal *)v12, (uint64_t)buf);
      re::createTextureDescriptorForCGImagePtr((uint64_t)image, (id *)v11, v7, (re::internal *)buf, 0, (unint64_t *)v106, &v81, &v80, &v79);
      re::getDestinationColorSpace((uint64_t)image, v11, &v79, (uint64_t)v12, (uint64_t)space);
      switch(v14)
      {
        case 3:
          int v41 = &selRef_setArrayLength_;
          break;
        case 7:
          int v41 = &selRef_setDepth_;
          break;
        case 5:
          if (v87 != 6)
          {
            re::DynamicString::format((re::DynamicString *)"Image array size is expected to be 6 for a cube, but is %d", (re::DynamicString *)&v97, v87);
LABEL_78:
            re::DynamicString::DynamicString((re::DynamicString *)&v102, (const re::DynamicString *)&v97);
            *(unsigned char *)a4 = 0;
            uint64_t v54 = v104;
            *(void *)(a4 + 8) = v102;
            *(void *)(a4 + 32) = v54;
            *(_OWORD *)(a4 + 16) = v103;
            if (v97 && (v98 & 1) != 0) {
              (*(void (**)(CGImageRef, re *, uint64_t, uint64_t))(*(void *)v97 + 40))(v97, v99, v52, v53);
            }
LABEL_90:
            CGColorSpaceRelease(space[0]);
            if (v79) {

            }
            CGImageRelease(*(CGImageRef *)image);
            *(void *)CGImageRef image = 0;
            CGColorSpaceRelease(v75);
LABEL_93:
            if (!(_BYTE)v84) {
              return;
            }
            unint64_t v60 = (unint64_t)v85;
            if (!v85 || !v88) {
              return;
            }
            goto LABEL_109;
          }
LABEL_61:
          CGImageRef v42 = objc_msgSend(v79, sel_setTextureType_, v14);
          uint64_t v105 = 0;
          long long v103 = 0uLL;
          id v102 = 0;
          LODWORD(v104) = 0;
          if (v87)
          {
            CGImageRef v42 = re::DynamicArray<CGImagePtr>::setCapacity(&v102, v87);
            if (v87)
            {
              long long v43 = (CFTypeRef *)v88;
              unint64_t v44 = *((void *)&v103 + 1);
              unint64_t v45 = 8 * v87;
              do
              {
                CGColorSpaceRef v46 = (CGImage *)*v43;
                CFRetain(*v43);
                CGImagePtr::CGImagePtr((CGImagePtr *)&v97, v46);
                if (v44 >= (unint64_t)v103)
                {
                  unint64_t v48 = v44 + 1;
                  if ((unint64_t)v103 < v48)
                  {
                    if (v102)
                    {
                      unint64_t v49 = 8;
                      if ((void)v103) {
                        unint64_t v49 = 2 * v103;
                      }
                      if (v49 <= v48) {
                        unint64_t v50 = v48;
                      }
                      else {
                        unint64_t v50 = v49;
                      }
                      re::DynamicArray<CGImagePtr>::setCapacity(&v102, v50);
                    }
                    else
                    {
                      re::DynamicArray<CGImagePtr>::setCapacity(&v102, v48);
                      LODWORD(v104) = v104 + 1;
                    }
                  }
                  unint64_t v44 = *((void *)&v103 + 1);
                }
                uint64_t v51 = v105;
                CGImagePtr::CGImagePtr(v105 + 80 * v44++, (uint64_t *)&v97);
                *((void *)&v103 + 1) = v44;
                LODWORD(v104) = v104 + 1;
                CGImageRelease(v97);
                CGImageRef v97 = 0;
                CGColorSpaceRelease(v101);
                ++v43;
                v45 -= 8;
              }
              while (v45);
            }
            else
            {
              uint64_t v51 = v105;
              unint64_t v44 = *((void *)&v103 + 1);
            }
            long long v55 = v102;
          }
          else
          {
            long long v55 = 0;
            unint64_t v44 = 0;
            uint64_t v51 = 0;
          }
          uint64_t v56 = (void *)MEMORY[0x237DBDCF0](v42);
          re::createTextureFromCGImagePtrs(v51, v44, (uint64_t)v11, &v79, (uint64_t)v8, (uint64_t)v12);
          if (v55 && v51)
          {
            if (v44)
            {
              int v59 = (CGImageRef *)v51;
              do
              {
                CGImageRelease(*v59);
                *int v59 = 0;
                CGColorSpaceRelease(v59[6]);
                v59[6] = 0;
                v59 += 10;
              }
              while (v59 != (CGImageRef *)(v51 + 80 * v44));
            }
            (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(*v55 + 40))(v55, v51, v57, v58);
          }
          goto LABEL_90;
        default:
          re::DynamicString::format((re::DynamicString *)"Unsupported texture type for image array import: %d", (re::DynamicString *)&v97, v14);
          goto LABEL_78;
      }
      objc_msgSend(v79, *v41, v87);
      goto LABEL_61;
    }
    int v17 = (re *)(*(void *(**)(CGImageRef *__return_ptr, re *, uint64_t **, uint64_t))(*(void *)this + 16))(&v97, this, &v102, 12);
    if ((_BYTE)v97)
    {
      if (v98 < 0xC || v102 != 171) {
        goto LABEL_45;
      }
      uint64_t v18 = 1u;
      while (v18 != 12)
      {
        int v19 = *((unsigned __int8 *)&v102 + v18);
        if (v19 != v20)
        {
          if ((unint64_t)(v18 - 2) < 0xB) {
            goto LABEL_45;
          }
          break;
        }
      }
      CFDataRef v21 = (const __CFData *)(*(uint64_t (**)(re *))(*(void *)this + 48))(this);
      v106[0] = v21;
      if (v21)
      {
        char v84 = (const re::ImportGraphicsContext *)&unk_26E7155F0;
        id v85 = v106;
        long long v86 = this;
        unint64_t v87 = (unint64_t)&v84;
        BytePtr = (__n128 *)CFDataGetBytePtr(v21);
        CFIndex Length = CFDataGetLength(v106[0]);
        unsigned int v24 = objc_msgSend(*((id *)this + 5), sel_swizzle);
        long long v25 = *((_OWORD *)this + 4);
        v68[0] = *((_OWORD *)this + 3);
        v68[1] = v25;
        v69[0] = *((_OWORD *)this + 5);
        *(_OWORD *)((char *)v69 + 12) = *(_OWORD *)((char *)this + 92);
        id v70 = *((id *)this + 14);
        long long v71 = *(_OWORD *)((char *)this + 120);
        re::createTextureWithKTXData((uint64_t)this + 144, BytePtr, Length, v24, (uint64_t)v8, (uint64_t)v68, (uint64_t)a2, 0, (uint64_t)buf, (uint64_t)&v84);

        if (!v95)
        {
LABEL_39:
          if (*(void *)&buf[8])
          {
            if (v87)
            {
              (*(void (**)(unint64_t))(*(void *)v87 + 48))(v87);
              image[0] = buf[0];
              image[8] = 0;
              unsigned int v76 = -1;
              std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>((uint64_t)&image[8], (uint64_t)&buf[8]);
              id v77 = v96;
              *(unsigned char *)a4 = 1;
              *(unsigned char *)(a4 + 8) = image[0];
              *(unsigned char *)(a4 + 16) = 0;
              *(_DWORD *)(a4 + 96) = -1;
              std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(a4 + 16, (uint64_t)&image[8]);
              id v27 = v77;
              id v77 = 0;
              *(void *)(a4 + 104) = v27;
              if (v76 != -1) {
                ((void (*)(CGColorSpaceRef *, unsigned char *))*(&off_26E715550 + v76))(space, &image[8]);
              }
              goto LABEL_103;
            }
            goto LABEL_116;
          }
LABEL_102:
          long long v62 = *(_OWORD *)image;
          uint64_t v63 = *(void *)&image[16];
          uint64_t v64 = v74;
          *(unsigned char *)a4 = 0;
          *(_OWORD *)(a4 + 8) = v62;
          *(void *)(a4 + 24) = v63;
          *(void *)(a4 + 32) = v64;
LABEL_103:

          if (v95 != -1) {
            ((void (*)(unsigned char *, uint8_t *))*(&off_26E715550 + v95))(image, &buf[8]);
          }
          std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](&v84);
          goto LABEL_106;
        }
        if (v95 == 1)
        {
          if (!v92) {
            goto LABEL_102;
          }
          goto LABEL_39;
        }
LABEL_117:
        id v66 = (re::internal *)std::__throw_bad_variant_access[abi:nn180100]();
        re::internal::createTextureProviderProperties(v66, v67);
        return;
      }
      uint64_t v31 = *re::pipelineLogObjects(0);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        goto LABEL_45;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      int v61 = "Failed to get texture ktx data for data labeled '%s'";
    }
    else
    {
      uint64_t v31 = *re::pipelineLogObjects(v17);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
LABEL_45:
        buf[0] = 0;
        *(void *)&uint8_t buf[8] = 0;
        unsigned int v95 = 0;
        id v96 = 0;
        long long v32 = (void *)MEMORY[0x237DBDCF0]();
        uint64_t v82 = *MEMORY[0x263F0F600];
        uint64_t v83 = MEMORY[0x263EFFA80];
        id v33 = [NSDictionary dictionaryWithObjects:&v83 forKeys:&v82 count:1];
        CFDataRef v34 = (const __CFData *)(*(uint64_t (**)(re *, void *))(*(void *)this + 32))(this, v33);
        v106[0] = v34;
        if (!v34) {
          goto LABEL_50;
        }
        char v84 = (const re::ImportGraphicsContext *)&unk_26E715670;
        id v85 = v106;
        long long v86 = this;
        unint64_t v87 = (unint64_t)&v84;
        re::loadMetalTextureWithReleasedCGImageSource((re *)((char *)this + 48), v34, (id *)this + 18, v7, (uint64_t)v8, (uint64_t)a2, (uint64_t)&v84, (uint64_t)image);
        buf[0] = image[0];
        std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)&buf[8], (uint64_t)&image[8]);
        id v35 = v77;
        id v77 = 0;
        id v36 = v96;
        id v96 = v35;

        if (v76 != -1) {
          ((void (*)(CGColorSpaceRef *, unsigned char *))*(&off_26E715550 + v76))(space, &image[8]);
        }
        if (v87)
        {
          (*(void (**)(unint64_t))(*(void *)v87 + 48))(v87);
          std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](&v84);
LABEL_50:

          if (v95)
          {
            if (v95 != 1) {
              goto LABEL_117;
            }
            if (!v92) {
              goto LABEL_56;
            }
          }
          if (*(void *)&buf[8])
          {
            image[0] = buf[0];
            image[8] = 0;
            unsigned int v76 = -1;
            std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>((uint64_t)&image[8], (uint64_t)&buf[8]);
            id v77 = v96;
            *(unsigned char *)a4 = 1;
            *(unsigned char *)(a4 + 8) = image[0];
            *(unsigned char *)(a4 + 16) = 0;
            *(_DWORD *)(a4 + 96) = -1;
            std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(a4 + 16, (uint64_t)&image[8]);
            id v37 = v77;
            id v77 = 0;
            *(void *)(a4 + 104) = v37;
            if (v76 != -1) {
              ((void (*)(const re::ImportGraphicsContext **, unsigned char *))*(&off_26E715550 + v76))(&v84, &image[8]);
            }
          }
          else
          {
LABEL_56:
            if ((_BYTE)v97)
            {
              re::DynamicString::format((re::DynamicString *)"Failed to create texture data from data labeled '%s'", (re::DynamicString *)image, v8);
              long long v38 = *(_OWORD *)image;
              uint64_t v39 = *(void *)&image[16];
              uint64_t v40 = v74;
              *(unsigned char *)a4 = 0;
              *(_OWORD *)(a4 + 8) = v38;
              *(void *)(a4 + 24) = v39;
              *(void *)(a4 + 32) = v40;
            }
            else
            {
              re::DynamicString::DynamicString((re::DynamicString *)image, (const re::DynamicString *)&v98);
              *(unsigned char *)a4 = 0;
              *(void *)(a4 + 8) = *(void *)image;
              *(void *)(a4 + 32) = v74;
              *(_OWORD *)(a4 + 16) = *(_OWORD *)&image[8];
            }
          }

          if (v95 != -1) {
            ((void (*)(unsigned char *, uint8_t *))*(&off_26E715550 + v95))(image, &buf[8]);
          }
LABEL_106:
          if ((_BYTE)v97) {
            return;
          }
          unint64_t v60 = v98;
          if (!v98 || (v99 & 1) == 0) {
            return;
          }
LABEL_109:
          (*(void (**)(unint64_t))(*(void *)v60 + 40))(v60);
          return;
        }
LABEL_116:
        std::__throw_bad_function_call[abi:nn180100]();
        goto LABEL_117;
      }
      if (v99) {
        float32x4_t v65 = v100;
      }
      else {
        float32x4_t v65 = (re **)((char *)&v99 + 1);
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v65;
      int v61 = "%s";
    }
    _os_log_error_impl(&dword_233120000, v31, OS_LOG_TYPE_ERROR, v61, buf, 0xCu);
    goto LABEL_45;
  }
  image[0] = buf[0];
  image[8] = 0;
  unsigned int v76 = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>((uint64_t)&image[8], (uint64_t)&buf[8]);
  id v77 = v96;
  *(unsigned char *)a4 = 1;
  *(unsigned char *)(a4 + 8) = image[0];
  *(unsigned char *)(a4 + 16) = 0;
  *(_DWORD *)(a4 + 96) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(a4 + 16, (uint64_t)&image[8]);
  id v10 = v77;
  id v77 = 0;
  *(void *)(a4 + 104) = v10;
  if (v76 != -1) {
    ((void (*)(uint64_t **, unsigned char *))*(&off_26E715550 + v76))(&v102, &image[8]);
  }

  if (v95 != -1) {
    ((void (*)(unsigned char *, uint8_t *))*(&off_26E715550 + v95))(image, &buf[8]);
  }
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](&v97);
}

void re::internal::createTextureProviderProperties(id *this@<X0>, const re::TextureProvider *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  uint64_t v5 = this + 5;
  uint64_t v6 = (*((uint64_t (**)(id *, const re::TextureProvider *))*this + 7))(this, a2);
  if (v6)
  {
    uint64_t v7 = (CGImage *)v6;
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
    *(void *)(a3 + 16) = 0;
    int v8 = (re *)(this + 18);
    unsigned int v9 = CGImageRetain(v7);
    id v10 = this + 6;
    CGImageRefWithColorSpace = re::createCGImageRefWithColorSpace(v8, v9, v10, 0);
    CGImagePtr::CGImagePtr((CGImagePtr *)&v33[1], CGImageRefWithColorSpace);
    re::internal::applySemanticToOptions((re::internal *)v10, (uint64_t)buf);
    re::createTextureDescriptorForCGImagePtr((uint64_t)&v33[1], (id *)v8, v5, (re::internal *)buf, 1, 0, 0, 0, v41);
    NS::SharedPtr<MTL::Texture>::operator=((void **)(a3 + 8), v41);
    if (v41[0])
    {

      v41[0] = 0;
    }

    size_t Width = (re::_anonymous_namespace_ *)CGImageGetWidth(v7);
    CGImageGetHeight(v7);
    CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(v7);
    CGImageRelease(*(CGImageRef *)&v33[1]);
    *(void *)&v33[1] = 0;
    CGColorSpaceRelease(space);
    return;
  }
  (*((void (**)(uint8_t *__return_ptr, id *))*this + 9))(buf, this);
  if (buf[0] && *(void *)&buf[8] && v43) {
    (*(void (**)(void))(**(void **)&buf[8] + 40))(*(void *)&buf[8]);
  }
  uint64_t v14 = (re *)(*((void *(**)(unsigned char *__return_ptr, id *, id *, uint64_t))*this + 2))(&v33[1], this, v41, 12);
  if (!v33[1])
  {
    unsigned int v24 = *re::pipelineLogObjects(v14);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      if (v35) {
        long long v32 = *(unsigned char **)&v36[7];
      }
      else {
        long long v32 = v36;
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v32;
      uint64_t v30 = "%s";
      uint64_t v31 = buf;
      goto LABEL_43;
    }
LABEL_24:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
    *(void *)(a3 + 16) = 0;
    long long v25 = (void *)MEMORY[0x237DBDCF0]();
    uint64_t v38 = *MEMORY[0x263F0F600];
    uint64_t v39 = MEMORY[0x263EFFA80];
    id v26 = [NSDictionary dictionaryWithObjects:&v39 forKeys:&v38 count:1];
    uint64_t v27 = (*((uint64_t (**)(id *, void *))*this + 3))(this, v26);
    if (v27)
    {
      long long v28 = (CGImageSource *)v27;
      re::internal::applySemanticToOptions((re::internal *)(this + 6), (uint64_t)buf);
      re::createTextureDescriptorForCGImageSource(v28, this + 18, v5, buf, 0, 0, 1, (id *)v40);
      NS::SharedPtr<MTL::Texture>::operator=((void **)(a3 + 8), (void **)v40);
      if (*(void *)v40)
      {

        *(void *)uint64_t v40 = 0;
      }

      *(void *)a3 = CGImageSourceCopyPropertiesAtIndex(v28, 0, 0);
      *(void *)(a3 + 16) = CGImageSourceGetType(v28);
      CFRelease(v28);
    }

    goto LABEL_29;
  }
  v33[0] = 0;
  if (v34 < 0xC || LOBYTE(v41[0]) != 171) {
    goto LABEL_24;
  }
  uint64_t v15 = 1u;
  while (v15 != 12)
  {
    int v16 = *((unsigned __int8 *)v41 + v15);
    if (v16 != v17)
    {
      if ((unint64_t)(v15 - 2) < 0xB) {
        goto LABEL_24;
      }
      break;
    }
  }
  uint64_t v18 = (*((uint64_t (**)(id *))*this + 5))(this);
  if (!v18)
  {
    unsigned int v24 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      if ((unint64_t)this[2]) {
        uint64_t v29 = (char *)this[3];
      }
      else {
        uint64_t v29 = (char *)this + 17;
      }
      *(_DWORD *)uint64_t v40 = 136315138;
      *(void *)&uint64_t v40[4] = v29;
      uint64_t v30 = "Failed to get texture ktx data for data labeled '%s'";
      uint64_t v31 = v40;
LABEL_43:
      _os_log_error_impl(&dword_233120000, v24, OS_LOG_TYPE_ERROR, v30, v31, 0xCu);
      goto LABEL_24;
    }
    goto LABEL_24;
  }
  CFDataRef v19 = (const __CFData *)v18;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  *(void *)(a3 + 16) = 0;
  BytePtr = (__n128 *)CFDataGetBytePtr(v19);
  CFIndex Length = CFDataGetLength(v19);
  int v22 = objc_msgSend(this[5], sel_swizzle);
  if ((unint64_t)this[2]) {
    unsigned int v23 = (char *)this[3];
  }
  else {
    unsigned int v23 = (char *)this + 17;
  }
  re::createTextureDescriptorForKTXData(this + 18, BytePtr, Length, v22, (uint64_t)v23, (uint64_t)(this + 6), (uint64_t)buf, v33, (id *)v40, 0);
  NS::SharedPtr<MTL::Texture>::operator=((void **)(a3 + 8), (void **)v40);
  if (*(void *)v40) {

  }
  *(void *)(a3 + 16) = @"org.khronos.ktx";
  CFRelease(v19);
LABEL_29:
  if (!v33[1] && v34 && (v35 & 1) != 0) {
    (*(void (**)(void))(*(void *)v34 + 40))();
  }
}

void *re::anonymous namespace'::createImageProperties(re::_anonymous_namespace_ *this, uint64_t a2)
{
  void v9[3] = *MEMORY[0x263EF8340];
  v8[0] = *MEMORY[0x263F0F458];
  int v3 = [NSNumber numberWithBool:a2];
  v9[0] = v3;
  v8[1] = *MEMORY[0x263F0F4F8];
  uint64_t v4 = [NSNumber numberWithUnsignedLong:this];
  v9[1] = v4;
  v8[2] = *MEMORY[0x263F0F4F0];
  uint64_t v5 = [NSNumber numberWithUnsignedLong:this];
  uint64_t v9[2] = v5;
  uint64_t v6 = [NSDictionary dictionaryWithObjects:v9 forKeys:v8 count:3];

  CFRetain(v6);
  return v6;
}

void re::createTextureDescriptorFromCompileOptions(id *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = 5;
  if (!*(unsigned char *)(a2 + 2)) {
    uint64_t v5 = 0;
  }
  uint64_t v6 = v5 | *(unsigned __int8 *)(a2 + 3);
  id v9 = *a1;
  id v7 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  *a3 = v7;
  objc_msgSend(v7, sel_setStorageMode_, 2);
  int v8 = (re *)objc_msgSend(v7, sel_setUsage_, v6);
  if (*(unsigned char *)(a2 + 2)) {
    objc_msgSend(v7, sel_setProtectionOptions_, re::protectionOptions(v8));
  }
}

void re::loadTextureFromFile(id *a1@<X0>, uint64_t a2@<X1>, id *a3@<X2>, re::internal *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  id v10 = NSURL;
  uint64_t v11 = [NSString stringWithUTF8String:a2];
  CFURLRef v12 = [v10 fileURLWithPath:v11];

  int v13 = CGImageSourceCreateWithURL(v12, 0);
  if (v13)
  {
    uint64_t v14 = v13;
    isValid = (re *)re::TextureData::isValid((re::TextureData *)a5);
    if ((isValid & 1) == 0)
    {
      int v16 = *re::pipelineLogObjects(isValid);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        int v18 = 136315138;
        uint64_t v19 = a2;
        _os_log_error_impl(&dword_233120000, v16, OS_LOG_TYPE_ERROR, "Failed to create texture from file '%s' using descriptor", (uint8_t *)&v18, 0xCu);
      }
    }
  }
  else
  {
    int v17 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      int v18 = 136315138;
      uint64_t v19 = a2;
      _os_log_error_impl(&dword_233120000, v17, OS_LOG_TYPE_ERROR, "Failed to create image source from file '%s' using descriptor", (uint8_t *)&v18, 0xCu);
    }
    *(unsigned char *)a5 &= 0x80u;
    *(void *)(a5 + 8) = 0;
    *(_DWORD *)(a5 + 88) = 0;
    *(void *)(a5 + 96) = 0;
  }
}

void re::createTextureCompileOptionsFromTextureImageOptions(re *this@<X0>, uint64_t a2@<X8>)
{
  re::internal::applySemanticToOptions(this, (uint64_t)v9);
  *(_WORD *)(a2 + 2) = 256;
  *(unsigned char *)(a2 + 4) = 1;
  *(_DWORD *)(a2 + 8) = 1;
  if (v10 == 1) {
    *(_DWORD *)(a2 + 8) = v11;
  }
  int v4 = v12;
  int v5 = v13;
  *(unsigned char *)a2 = v12 != 2;
  if (v4) {
    BOOL v6 = v4 == 3;
  }
  else {
    BOOL v6 = 1;
  }
  char v7 = v6;
  *(unsigned char *)(a2 + 1) = v7;
  *(_DWORD *)(a2 + 12) = v5;
  *(_OWORD *)(a2 + 16) = v14;
  id v8 = v15;
}

void re::loadTextureFileAndConvertToCubeMap(id *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  id v38 = 0;
  int v36 = 0x1000000;
  *(_OWORD *)id v37 = *(_OWORD *)(a3 + 4);
  *(_OWORD *)&v37[12] = *(_OWORD *)(a3 + 16);
  id v8 = NSURL;
  id v9 = [NSString stringWithUTF8String:a2];
  CFURLRef v10 = [v8 fileURLWithPath:v9];

  CGImageSourceRef v11 = CGImageSourceCreateWithURL(v10, 0);
  if (v11)
  {
    int v12 = v11;
    re::createTextureDescriptorFromCompileOptions(a1, (uint64_t)&v36, &v39);
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    int v21 = 1;
    int v26 = 0;
    char v27 = 0;
    int v28 = 0;
    char v29 = 0;
    uint64_t v24 = 0;
    char v25 = 0;
    int v30 = 6;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    id v31 = 0;
    if (*(_DWORD *)&v37[4] >= 2u)
    {
      LODWORD(v20) = 1;
      int v21 = *(_DWORD *)&v37[4];
    }
    int v22 = 2;
    int v23 = *(_DWORD *)&v37[8];
    if (v43)
    {
      if (v43 != 1) {
        goto LABEL_34;
      }
      if (!v42) {
        goto LABEL_8;
      }
    }
    if (!*(void *)&v41[4])
    {
LABEL_8:
      id v15 = *re::pipelineLogObjects(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v45 = 136315138;
        uint64_t v46 = a2;
        _os_log_error_impl(&dword_233120000, v15, OS_LOG_TYPE_ERROR, "Failed to create texture from file '%s'", v45, 0xCu);
      }
    }

    if (v39) {
  }
    }
  else
  {
    int v16 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)int v41 = a2;
      _os_log_error_impl(&dword_233120000, v16, OS_LOG_TYPE_ERROR, "Failed to create image source from file '%s'", buf, 0xCu);
    }
    buf[0] = 0;
    *(void *)&v41[4] = 0;
    unsigned int v43 = 0;
    id v44 = 0;
  }

  if (v43)
  {
    if (v43 != 1) {
      goto LABEL_34;
    }
    if (!v42) {
      goto LABEL_23;
    }
  }
  if (!*(void *)&v41[4])
  {
LABEL_23:
    int v17 = 0;
    *(unsigned char *)a4 &= 0x80u;
    *(void *)(a4 + 8) = 0;
    *(_DWORD *)(a4 + 88) = 0;
    *(void *)(a4 + 96) = 0;
    goto LABEL_24;
  }
  re::createCubeMapFromLatLongTexture(a1, (const re::ImportGraphicsContext *)buf, (const re::TextureData *)*(unsigned __int8 *)(a3 + 1), 0, 0, 0, (uint64_t)&v19);
  if (v34) {
LABEL_34:
  }
    std::__throw_bad_variant_access[abi:nn180100]();
  NS::SharedPtr<MTL::Texture>::operator=(&v38, &v20);

  if (v34 != -1) {
    ((void (*)(uint8_t *, void **))*(&off_26E715550 + v34))(v45, &v20);
  }
  int v17 = 1;
LABEL_24:

  if (v43 != -1) {
    ((void (*)(uint64_t *, unsigned char *))*(&off_26E715550 + v43))(&v19, &v41[4]);
  }
  if (v17)
  {
    if (v38)
    {
      objc_msgSend(v38, sel_setLabel_, objc_msgSend(NSString, sel_stringWithCString_encoding_, a2, 4));
      id v18 = v38;
    }
    else
    {
      id v18 = 0;
    }
    *(unsigned char *)a4 &= 0x80u;
    *(void *)(a4 + 8) = v18;
    *(_DWORD *)(a4 + 88) = 0;
    *(void *)(a4 + 96) = 0;
  }
  if (v38) {
}
  }

void re::createCubeMapFromLatLongTexture(id *this@<X0>, const re::ImportGraphicsContext *a2@<X1>, const re::TextureData *a3@<X2>, unint64_t a4@<X3>, unsigned int a5@<W4>, int a6@<W5>, uint64_t a7@<X8>)
{
  v88[4] = *MEMORY[0x263EF8340];
  id v82 = 0;
  if (*((_DWORD *)a2 + 22)) {
    std::__throw_bad_variant_access[abi:nn180100]();
  }
  int v11 = (int)a3;
  id v14 = *((id *)a2 + 1);
  id v81 = v14;
  if (objc_msgSend(v14, sel_textureType) != (id)2)
  {
    *(unsigned char *)a7 &= 0x80u;
    *(void *)(a7 + 8) = 0;
    *(_DWORD *)(a7 + 88) = 0;
    *(void *)(a7 + 96) = 0;
    goto LABEL_82;
  }
  int v69 = v11;
  int v15 = objc_msgSend(v14, sel_width);
  int v16 = objc_msgSend(v14, sel_height);
  int v17 = v16;
  if (!a4)
  {
    unint64_t v29 = (unint64_t)((double)v15 * 0.318309886);
    if (v29 <= 1) {
      unint64_t v29 = 1;
    }
    unint64_t v30 = (v29 - 1) | ((v29 - 1) >> 1) | (((v29 - 1) | ((v29 - 1) >> 1)) >> 2);
    unint64_t v31 = v30 | (v30 >> 4) | ((v30 | (v30 >> 4)) >> 8);
    unint64_t v32 = v31 | (v31 >> 16) | ((v31 | (v31 >> 16)) >> 32);
    if (v29 - ((v32 + 1) >> 1) >= v32 + 1 - v29) {
      unint64_t v18 = v32 + 1;
    }
    else {
      unint64_t v18 = (v32 + 1) >> 1;
    }
    if (a5) {
      goto LABEL_16;
    }
    goto LABEL_8;
  }
  if (a4 >= 0x2000) {
    unint64_t v18 = 0x2000;
  }
  else {
    unint64_t v18 = a4;
  }
  if (!a5)
  {
LABEL_8:
    if (v16 >= 0) {
      int v19 = v16;
    }
    else {
      int v19 = v16 + 1;
    }
    unsigned int v20 = v19 >> 1;
    if (v20 <= v15 / 4) {
      unsigned int v20 = v15 / 4;
    }
    unsigned int v21 = v20 / v18;
    if (v21 <= 1) {
      unsigned int v21 = 1;
    }
    a5 = v21 + 1;
  }
LABEL_16:
  id v70 = a2;
  if (a5 >= 0x40) {
    int v22 = 64;
  }
  else {
    int v22 = a5;
  }
  int v80 = v22;
  double v23 = floor(log2((double)v18)) + 1.0;
  unsigned __int8 v79 = 0;
  long long v71 = (re *)this;
  uint64_t v24 = (re *)re::internal::chooseWritableTextureFormat((uint64_t)this, &v81, 0, 0, &v79);
  char v25 = *re::pipelineLogObjects(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67110144;
    *(_DWORD *)&uint8_t buf[4] = v15;
    LOWORD(v88[0]) = 1024;
    *(_DWORD *)((char *)v88 + 2) = v17;
    HIWORD(v88[0]) = 2048;
    v88[1] = v18;
    LOWORD(v88[2]) = 2048;
    *(void *)((char *)&v88[2] + 2) = v18;
    WORD1(v88[3]) = 1024;
    HIDWORD(v88[3]) = v24;
    _os_log_impl(&dword_233120000, v25, OS_LOG_TYPE_DEFAULT, "Converting %dx%d texture to %zux%zux6 cubemap with format %d\n", buf, 0x28u);
  }
  int v26 = v79;
  if (v79)
  {
    int v27 = re::translateSRGBPixelFormatToLinear((uint64_t)v24);
    uint64_t v28 = 19;
  }
  else
  {
    uint64_t v28 = 3;
    int v27 = (int)v24;
  }
  id v33 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  objc_msgSend(v33, sel_setTextureType_, 5);
  objc_msgSend(v33, sel_setWidth_, v18);
  objc_msgSend(v33, sel_setHeight_, v18);
  objc_msgSend(v33, sel_setPixelFormat_, (int)v24);
  objc_msgSend(v33, sel_setMipmapLevelCount_, (int)v23);
  objc_msgSend(v33, sel_setSampleCount_, 1);
  objc_msgSend(v33, sel_setUsage_, v28);
  if (objc_msgSend(v14, sel_isShareable)) {
    uint64_t v34 = 2;
  }
  else {
    uint64_t v34 = 0;
  }
  objc_msgSend(v33, sel_setStorageMode_, v34);
  if (objc_msgSend(v14, sel_isShareable)) {
    re::mtl::Device::makeSharedTexture(v33, this, buf);
  }
  else {
    re::mtl::Device::makeTexture(v33, this, buf);
  }
  NS::SharedPtr<MTL::Texture>::operator=(&v82, (void **)buf);
  if (*(void *)buf) {

  }
  id v72 = objc_msgSend(v82, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, v27, 3, 0, 1, 0, 6);
  int v78 = a6;
  id v35 = objc_msgSend(objc_msgSend(MEMORY[0x263F128B8], sel_alloc), sel_init);
  if (v26) {
    int v36 = "generateCubeMapWithLinearToSRGB";
  }
  else {
    int v36 = "generateCubeMap";
  }
  objc_msgSend(v35, sel_setName_, objc_msgSend(NSString, sel_stringWithCString_encoding_, v36, 4));
  id v68 = v35;
  re::mtl::Library::makeFunctionWithDescriptor(this + 1, v35, &v84);
  id v37 = objc_msgSend(objc_msgSend(MEMORY[0x263F12850], sel_alloc), sel_init);
  id v83 = v37;
  id v67 = v84;
  objc_msgSend(v37, sel_setComputeFunction_);
  re::mtl::Device::makeComputePipelineState(this, &v83, &v77);
  *(void *)long long buf = 0x51B2FD90430C103CLL;
  v88[0] = "createCubeMapFromLatLongTextureQueue";
  re::ImportGraphicsContext::getOrCreateCommandQueue((uint64_t)this, (uint64_t)buf, (const char *)1, &v76);
  re::mtl::CommandQueue::makeCommandBuffer(&v76, &v75);
  re::mtl::CommandBuffer::makeComputeCommandEncoder(&v75, &v74);
  id v38 = v77;
  unsigned int v39 = objc_msgSend(v77, sel_threadExecutionWidth);
  uint64_t v40 = (re *)objc_msgSend(v38, sel_maxTotalThreadsPerThreadgroup);
  uint64_t v41 = v40 / v39;
  uint64_t v42 = (v39 + v18 - 1) / v39;
  uint64_t v43 = ((int)v18 + (int)v41 - 1) / v41;
  id v44 = *re::pipelineLogObjects(v40);
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67110400;
    *(_DWORD *)&uint8_t buf[4] = v42;
    LOWORD(v88[0]) = 1024;
    *(_DWORD *)((char *)v88 + 2) = v43;
    HIWORD(v88[0]) = 1024;
    LODWORD(v88[1]) = 6;
    WORD2(v88[1]) = 1024;
    *(_DWORD *)((char *)&v88[1] + 6) = v39;
    WORD1(v88[2]) = 1024;
    HIDWORD(v88[2]) = v41;
    LOWORD(v88[3]) = 1024;
    *(_DWORD *)((char *)&v88[3] + 2) = 1;
    _os_log_impl(&dword_233120000, v44, OS_LOG_TYPE_DEFAULT, "Dispatching %dx%dx%d thread groups of size %dx%dx%d\n", buf, 0x26u);
  }
  [v74 setComputePipelineState:v38];
  [v74 setTexture:v14 atIndex:0];
  [v74 setTexture:v72 atIndex:1];
  [v74 setBytes:&v80 length:4 atIndex:0];
  [v74 setBytes:&v78 length:4 atIndex:1];
  *(void *)long long buf = v42;
  v88[0] = v43;
  v88[1] = 6;
  *(void *)long long v86 = v39;
  *(void *)&char v86[8] = v41;
  *(void *)&v86[16] = 1;
  [v74 dispatchThreadgroups:buf threadsPerThreadgroup:v86];
  [v74 endEncoding];
  re::mtl::CommandBuffer::makeBlitCommandEncoder(&v75, &v73);
  [v73 endEncoding];
  [v75 commit];
  [v75 waitUntilCompleted];
  re::internal::getCommandBufferError(&v75, (uint64_t)buf);
  if (!buf[0])
  {
    id v58 = objc_msgSend(objc_msgSend(v14, sel_label), sel_UTF8String);
    if (v88[1]) {
      int v59 = (char *)v88[2];
    }
    else {
      int v59 = (char *)&v88[1] + 1;
    }
    int v61 = *re::pipelineLogObjects(v60);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
    {
      if (v86[8]) {
        long long v62 = *(unsigned char **)&v86[16];
      }
      else {
        long long v62 = &v86[9];
      }
      *(_DWORD *)id v85 = 136315138;
      *(void *)&v85[4] = v62;
      _os_log_error_impl(&dword_233120000, v61, OS_LOG_TYPE_ERROR, "%s", v85, 0xCu);
    }
    if (*(void *)v86 && (v86[8] & 1) != 0) {
      (*(void (**)(void))(**(void **)v86 + 40))();
    }
  }
  id v45 = objc_msgSend(v14, sel_label);
  if (v45) {
    objc_msgSend(v82, sel_setLabel_, objc_msgSend(v45, sel_stringByAppendingString_, objc_msgSend(NSString, sel_stringWithCString_encoding_, "_cubeMap", 4)));
  }
  if (!buf[0] && v88[0] && (v88[1] & 1) != 0) {
    (*(void (**)(void))(*(void *)v88[0] + 40))();
  }

  if (v38) {
  if (v37)
  }

  if (v67) {
  if (v68)
  }

  if (v72) {
  if (v33)
  }

  if (v69)
  {
    uint64_t v46 = (re *)objc_msgSend(v82, sel_mipmapLevelCount);
    if ((unint64_t)v46 >= 2)
    {
      uint64_t v47 = *re::pipelineLogObjects(v46);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_233120000, v47, OS_LOG_TYPE_DEFAULT, "Generate MIPs for cubemap\n", buf, 2u);
      }
      unint64_t v48 = (void *)MEMORY[0x237DBDCF0]();
      *(void *)long long buf = 0x5C8C10EB3EC8C2FBLL;
      v88[0] = "generateMipmapsQueue";
      re::ImportGraphicsContext::getOrCreateCommandQueue((uint64_t)v71, (uint64_t)buf, (const char *)1, (id *)v85);
      re::mtl::CommandQueue::makeCommandBuffer((id *)v85, &v84);
      re::mtl::CommandBuffer::makeBlitCommandEncoder(&v84, &v83);
      [v83 generateMipmapsForTexture:v82];
      [v83 endEncoding];
      [v84 commit];
      [v84 waitUntilCompleted];
      re::internal::getCommandBufferError(&v84, (uint64_t)buf);
      if (!buf[0])
      {
        unint64_t v50 = *re::pipelineLogObjects(v49);
        if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
          goto LABEL_67;
        }
        id v63 = v82;
        uint64_t v64 = v50;
        id v65 = objc_msgSend(objc_msgSend(v63, sel_label), sel_UTF8String);
        id v66 = (v88[1] & 1) != 0 ? (void *)v88[2] : (void *)((char *)&v88[1] + 1);
        *(_DWORD *)long long v86 = 136315394;
        *(void *)&v86[4] = v65;
        *(_WORD *)&v86[12] = 2080;
        *(void *)&v86[14] = v66;

        if (!buf[0])
        {
LABEL_67:
          if (v88[0])
          {
            if (v88[1]) {
              (*(void (**)(void))(*(void *)v88[0] + 40))();
            }
            memset(v88, 0, 32);
          }
        }
      }
    }
  }
  id v51 = *((id *)v70 + 12);
  if (*((unsigned char *)v71 + 19)) {
    char v52 = *((unsigned char *)v71 + 20);
  }
  else {
    char v52 = 0;
  }
  v86[0] = v52;
  if (v51)
  {
    re::ColorHelpers::getColorGamutFromCGColorSpaceName(v51, v86);
    char v52 = v86[0];
  }
  unsigned __int8 v53 = v52 - 1;
  if (v53 > 2u) {
    uint64_t v54 = (__CFString **)MEMORY[0x263F00230];
  }
  else {
    uint64_t v54 = (__CFString **)qword_264BE7F90[(char)v53];
  }
  long long v55 = *v54;
  *(unsigned char *)a7 &= 0x80u;
  *(void *)(a7 + 8) = v82;
  *(_DWORD *)(a7 + 88) = 0;
  *(void *)(a7 + 96) = 0;
  re::TextureData::setColorSpace((id *)a7, v55);
  uint64_t v57 = *re::pipelineLogObjects(v56);
  if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_233120000, v57, OS_LOG_TYPE_DEFAULT, "Done\n", buf, 2u);
  }
LABEL_82:
  if (v14) {

  }
  if (v82) {
}
  }

void re::loadTextureFileAndConvertToCubeMap(id *a1@<X0>, const char *a2@<X1>, id *a3@<X2>, long long *a4@<X3>, unsigned int a5@<W4>, int a6@<W5>, uint64_t a7@<X8>)
{
  v48[0] = 0;
  v49[0] = 0;
  unsigned int v50 = 0;
  id v51 = 0;
  long long v14 = a4[1];
  long long v42 = *a4;
  long long v43 = v14;
  v44[0] = a4[2];
  *(_OWORD *)((char *)v44 + 12) = *(long long *)((char *)a4 + 44);
  id v15 = *((id *)a4 + 8);
  DWORD1(v43) = 2;
  DWORD2(v42) = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  id v45 = v15;
  id v37 = *a3;
  re::loadTextureFromFile(a1, (uint64_t)a2, &v37, (re::internal *)&v42, (uint64_t)v38);
  if (v37)
  {

    id v37 = 0;
  }
  if (v40)
  {
    if (v40 != 1) {
      goto LABEL_36;
    }
    if (!v39[3]) {
      goto LABEL_9;
    }
  }
  if (v39[0])
  {
    if (*((_DWORD *)a4 + 2) == 2) {
      unint64_t v16 = *((unsigned int *)a4 + 18);
    }
    else {
      unint64_t v16 = 0;
    }
    int v18 = *((_DWORD *)a4 + 5);
    if (v18) {
      BOOL v19 = v18 == 3;
    }
    else {
      BOOL v19 = 1;
    }
    uint64_t v20 = v19;
    re::createCubeMapFromLatLongTexture(a1, (const re::ImportGraphicsContext *)v38, (const re::TextureData *)v20, v16, a5, a6, (uint64_t)&v29);
    if (v31) {
      goto LABEL_36;
    }
    id v21 = v41;
    v33[0] = 0;
    v34[0] = v30[0];
    unsigned int v35 = 0;
    id v36 = v21;
    v48[0] = 0;
    std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)v49, (uint64_t)v34);
    id v22 = v36;
    id v36 = 0;
    double v23 = v51;
    id v51 = v22;

    if (v35 != -1) {
      ((void (*)(char *, void *))*(&off_26E715550 + v35))(&v52, v34);
    }
    unsigned int v35 = -1;

    if (v31 != -1) {
      ((void (*)(char *, id *))*(&off_26E715550 + v31))(&v52, v30);
    }
    v48[0] = v38[0];
    char v17 = 1;
  }
  else
  {
LABEL_9:
    char v17 = 0;
    *(unsigned char *)a7 &= 0x80u;
    *(void *)(a7 + 8) = 0;
    *(_DWORD *)(a7 + 88) = 0;
    *(void *)(a7 + 96) = 0;
  }

  if (v40 != -1) {
    ((void (*)(char *, void *))*(&off_26E715550 + v40))(v33, v39);
  }

  if (v17)
  {
    if (!v50) {
      goto LABEL_29;
    }
    if (v50 == 1)
    {
      if (!v49[3])
      {
LABEL_31:
        *(unsigned char *)a7 = v48[0];
        *(unsigned char *)(a7 + 8) = 0;
        *(_DWORD *)(a7 + 88) = -1;
        std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(a7 + 8, (uint64_t)v49);
        uint64_t v24 = 0;
        id v25 = v51;
        id v51 = 0;
        *(void *)(a7 + 96) = v25;
        goto LABEL_33;
      }
LABEL_29:
      if (v49[0]) {
        re::TextureData::setLabel((re::TextureData *)v48, a2);
      }
      goto LABEL_31;
    }
LABEL_36:
    int v26 = (id *)std::__throw_bad_variant_access[abi:nn180100]();
    re::loadTextureFileAndConvertTo3DTexture(v26, v27, v28);
    return;
  }
  uint64_t v24 = v51;
LABEL_33:

  if (v50 != -1) {
    ((void (*)(char *, void *))*(&off_26E715550 + v50))(v38, v49);
  }
}

void re::loadTextureFileAndConvertTo3DTexture(id *this@<X0>, const re::mtl::Device *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  id v41 = 0;
  char v7 = NSURL;
  id v8 = [NSString stringWithUTF8String:a2];
  CFURLRef v9 = [v7 fileURLWithPath:v8];

  CFURLRef v10 = CGImageSourceCreateWithURL(v9, 0);
  if (!v10)
  {
    uint64_t v28 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = a2;
      _os_log_error_impl(&dword_233120000, v28, OS_LOG_TYPE_ERROR, "Failed to create CGImageSource from file: %s\n", (uint8_t *)&buf, 0xCu);
    }
    goto LABEL_17;
  }
  int v11 = v10;
  ImageAtIndex = CGImageSourceCreateImageAtIndex(v10, 0, 0);
  if (!ImageAtIndex)
  {
    uint64_t v29 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = a2;
      _os_log_error_impl(&dword_233120000, v29, OS_LOG_TYPE_ERROR, "Failed to load CGImage from file: %s\n", (uint8_t *)&buf, 0xCu);
    }
    unint64_t v30 = v11;
    goto LABEL_16;
  }
  int v13 = ImageAtIndex;
  unsigned int v40 = this;
  int Width = CGImageGetWidth(ImageAtIndex);
  size_t Height = (re *)CGImageGetHeight(v13);
  int v16 = (int)Height;
  size_t v17 = (int)Height;
  unint64_t v18 = (int)Height * (uint64_t)Width;
  if (((unsigned __int128)((int)Height * (__int128)Width) >> 64) & 1 | (v18 >> 61))
  {
    unsigned int v31 = *re::pipelineLogObjects(Height);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_233120000, v31, OS_LOG_TYPE_ERROR, "Failure reading LUT texture file: image size - Invalid or Out of range ", (uint8_t *)&buf, 2u);
    }
    CFRelease(v11);
    unint64_t v30 = v13;
LABEL_16:
    CFRelease(v30);
LABEL_17:
    *(unsigned char *)a3 &= 0x80u;
    *(void *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 88) = 0;
    *(void *)(a3 + 96) = 0;
    goto LABEL_18;
  }
  CFURLRef v39 = v9;
  BOOL v19 = re::globalAllocators(Height);
  uint64_t v20 = (void *)(*(uint64_t (**)(uint64_t, unint64_t, void))(*(void *)v19[2] + 32))(v19[2], 8 * v18, 0);
  ColorSpace = CGImageGetColorSpace(v13);
  id v38 = v20;
  id v22 = CGBitmapContextCreate(v20, Width, v17, 0x10uLL, 8 * Width, ColorSpace, 0x1105u);
  if (!v22)
  {
    id v32 = *re::pipelineLogObjects(0);
    CFURLRef v9 = v39;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = a2;
      _os_log_error_impl(&dword_233120000, v32, OS_LOG_TYPE_ERROR, "Failed to create a bitmap context for file: %s\n", (uint8_t *)&buf, 0xCu);
    }
    CFRelease(v11);
    CFRelease(v13);
    goto LABEL_24;
  }
  double v23 = v22;
  CGContextSetBlendMode(v22, kCGBlendModeCopy);
  v48.size.width = (double)Width;
  v48.size.height = (double)v16;
  v48.origin.x = 0.0;
  v48.origin.y = 0.0;
  CGContextDrawImage(v23, v48, v13);
  CFRelease(v13);
  CFRelease(v11);
  CGContextRelease(v23);
  float v25 = cbrt((double)v18);
  if (v25 != (float)(int)v25)
  {
    int v26 = *re::pipelineLogObjects(v24);
    BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    CFURLRef v9 = v39;
    if (v27)
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = a2;
      _os_log_error_impl(&dword_233120000, v26, OS_LOG_TYPE_ERROR, "Incorrect number of color entries for the 3D LUT file: %s\n", (uint8_t *)&buf, 0xCu);
    }
LABEL_24:
    if (v38)
    {
      id v33 = re::globalAllocators((re *)v27);
      (*(void (**)(uint64_t, void *))(*(void *)v33[2] + 40))(v33[2], v38);
    }
    goto LABEL_17;
  }
  int v34 = (int)v25;
  id v35 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  objc_msgSend(v35, sel_setTextureType_, 7);
  objc_msgSend(v35, sel_setPixelFormat_, 115);
  objc_msgSend(v35, sel_setWidth_, v34);
  objc_msgSend(v35, sel_setHeight_, v34);
  objc_msgSend(v35, sel_setDepth_, v34);
  objc_msgSend(v35, sel_setUsage_, 1);
  objc_msgSend(v35, sel_setSampleCount_, 1);
  objc_msgSend(v35, sel_setMipmapLevelCount_, 1);
  objc_msgSend(v35, sel_setStorageMode_, 0);
  re::mtl::Device::makeTexture(v35, v40, &buf);
  NS::SharedPtr<MTL::Texture>::operator=(&v41, (void **)&buf);
  CFURLRef v9 = v39;
  if ((void)buf) {

  }
  objc_msgSend(v41, sel_setLabel_, @"3D LUT");
  long long buf = 0uLL;
  uint64_t v43 = 0;
  uint64_t v44 = v34;
  uint64_t v45 = v34;
  uint64_t v46 = v34;
  id v36 = (re *)objc_msgSend(v41, sel_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage_, &buf, 0, 0, v38, 8 * v34, 8 * (v34 * v34));
  if (v38)
  {
    id v37 = re::globalAllocators(v36);
    (*(void (**)(uint64_t, void *))(*(void *)v37[2] + 40))(v37[2], v38);
  }
  *(unsigned char *)a3 &= 0x80u;
  *(void *)(a3 + 8) = v41;
  *(_DWORD *)(a3 + 88) = 0;
  *(void *)(a3 + 96) = 0;
  if (v35) {

  }
LABEL_18:
  if (v41) {
}
  }

void re::load3DTextureFromLutDataFile(id *this@<X0>, const re::mtl::Device *a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  v62[0] = 0;
  re::FileStreamReader::open(a2, (uint64_t)v57);
  if (v57[0])
  {
    v70[0] = 0;
    uint64_t v8 = v59;
    fgetpos(__stream, v70);
    fpos_t v9 = v70[0];
    CFURLRef v10 = (re *)(v8 - v70[0]);
    __ptr = 0;
    v53[1] = 0;
    unint64_t v54 = 0;
    v53[0] = 0;
    int v55 = 0;
    unint64_t v11 = v8 - v70[0] + 1;
    re::DynamicArray<BOOL>::resize((uint64_t)v53, v11);
    if (v54 == v11 && (int v12 = (re *)fread(__ptr, 1uLL, v8 - v9, __stream), v12 == v10))
    {
      unint64_t v13 = v54;
      if (v54 <= (unint64_t)v10)
      {
        v62[1] = 0;
        long long v72 = 0u;
        long long v73 = 0u;
        long long v71 = 0u;
        memset(v70, 0, sizeof(v70));
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)id v63 = 136315906;
        *(void *)&v63[4] = "operator[]";
        __int16 v64 = 1024;
        int v65 = 789;
        __int16 v66 = 2048;
        id v67 = v10;
        __int16 v68 = 2048;
        unint64_t v69 = v13;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *((unsigned char *)v10 + (void)__ptr) = 0;
      long long v14 = __ptr;
      *(void *)id v63 = 0;
      id v15 = strstr((char *)__ptr, "LUT_3D_SIZE ");
      *(void *)id v63 = v15;
      if (!v15) {
        goto LABEL_10;
      }
      float v17 = strtof(v15 + 12, (char **)v63);
      int v52 = (int)v17;
      int v18 = (int)v17 * (int)v17 * (int)v17;
      if ((unint64_t)(8 * v18) >= 0x4000001)
      {
        BOOL v19 = *re::pipelineLogObjects(v16);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          LODWORD(v70[0]) = 136315650;
          *(fpos_t *)((char *)v70 + 4) = (fpos_t)"LUT_3D_SIZE ";
          WORD2(v70[1]) = 1024;
          *(_DWORD *)((char *)&v70[1] + 6) = v52;
          WORD1(v70[2]) = 2080;
          *(fpos_t *)((char *)&v70[2] + 4) = (fpos_t)a2;
          uint64_t v20 = "Unexpected %s '%d' (too large) for LUT file '%s'";
          id v21 = v19;
          uint32_t v22 = 28;
LABEL_49:
          _os_log_error_impl(&dword_233120000, v21, OS_LOG_TYPE_ERROR, v20, (uint8_t *)v70, v22);
        }
LABEL_10:
        *(unsigned char *)a4 &= 0x80u;
        *(void *)(a4 + 8) = 0;
        *(_DWORD *)(a4 + 88) = 0;
        *(void *)(a4 + 96) = 0;
LABEL_11:
        if (v53[0] && __ptr) {
          (*(void (**)(void))(*(void *)v53[0] + 40))();
        }
        goto LABEL_16;
      }
      unsigned int v51 = (int)v17 * (int)v17;
      float v25 = re::globalAllocators(v16);
      int v26 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v25[2] + 32))(v25[2], 8 * v18, 0);
      if (v26)
      {
        if (v52)
        {
          BOOL v27 = v26;
          uint64_t v28 = (char *)v10 + (void)v14;
          BOOL v29 = v18 > 0;
          unint64_t v30 = *(char **)v63;
          _CF = v18 < 1 || *(void *)v63 == 0 || *(void *)v63 >= (unint64_t)v28;
          unsigned int v50 = v27;
          if (!_CF)
          {
            int v33 = 0;
            int v34 = &v14[v8 - v9];
            unint64_t v49 = v34;
            while (1)
            {
              if (!*v30)
              {
LABEL_58:
                BOOL v29 = 1;
                goto LABEL_61;
              }
              if (v30 < v28)
              {
                uint64_t v35 = v34 - v30;
                while (*v30 && *v30 != 10)
                {
                  *(void *)id v63 = ++v30;
                  if (!--v35)
                  {
                    unint64_t v30 = &v14[(void)v10];
                    break;
                  }
                }
              }
              if (v30 == v28) {
                break;
              }
              if (!*v30) {
                goto LABEL_58;
              }
              *(void *)id v63 = ++v30;
              if (v30 < v28 && *v30 - 48 <= 9)
              {
                _S0 = strtof(v30, (char **)v63);
                __asm { FCVT            H0, S0 }
                unsigned int v40 = (_WORD *)((char *)v50 + 8 * v33);
                *unsigned int v40 = LOWORD(_S0);
                _S0 = strtof(*(const char **)v63, (char **)v63);
                __asm { FCVT            H0, S0 }
                *((_WORD *)v50 + 4 * v33 + 1) = LOWORD(_S0);
                _S0 = strtof(*(const char **)v63, (char **)v63);
                int v34 = v49;
                __asm { FCVT            H0, S0 }
                void v40[2] = LOWORD(_S0);
                v40[3] = COERCE_UNSIGNED_INT(1.0);
                ++v33;
                unint64_t v30 = *(char **)v63;
              }
              BOOL v29 = v33 < v18;
              if (v33 >= v18 || !v30 || v30 >= v28) {
                goto LABEL_60;
              }
            }
            BOOL v29 = 1;
            unint64_t v30 = (char *)v10 + (void)v14;
          }
LABEL_60:
          if (v30)
          {
LABEL_61:
            if (v30 < v28)
            {
              int64_t v44 = &v14[(void)v10] - v30;
              uint64_t v45 = v30 + 1;
              while (*(v45 - 1) == 10)
              {
                *(void *)id v63 = v45++;
                if (!--v44) {
                  goto LABEL_73;
                }
              }
              if (!*(v45 - 1)) {
                BOOL v29 = 1;
              }
              if (!v29)
              {
                uint64_t v46 = *re::pipelineLogObjects((re *)v30);
                if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(v70[0]) = 136315138;
                  *(fpos_t *)((char *)v70 + 4) = (fpos_t)a2;
                  _os_log_impl(&dword_233120000, v46, OS_LOG_TYPE_DEFAULT, "Size of LUT file is larger than its header indicates. It may be loaded incorrectly: '%s'", (uint8_t *)v70, 0xCu);
                }
              }
            }
LABEL_73:
            id v47 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
            objc_msgSend(v47, sel_setTextureType_, 7);
            objc_msgSend(v47, sel_setPixelFormat_, 115);
            objc_msgSend(v47, sel_setWidth_, v52);
            objc_msgSend(v47, sel_setHeight_, v52);
            objc_msgSend(v47, sel_setDepth_, v52);
            objc_msgSend(v47, sel_setUsage_, 1);
            objc_msgSend(v47, sel_setSampleCount_, 1);
            objc_msgSend(v47, sel_setMipmapLevelCount_, 1);
            objc_msgSend(v47, sel_setStorageMode_, 0);
            re::mtl::Device::makeTexture(v47, this, v70);
            NS::SharedPtr<MTL::Texture>::operator=(v62, (void **)v70);
            if (v70[0]) {

            }
            objc_msgSend(v62[0], sel_setLabel_, @"3D LUT");
            memset(v70, 0, 24);
            v70[3] = v52;
            *(void *)&long long v71 = v52;
            *((void *)&v71 + 1) = v52;
            CGRect v48 = re::globalAllocators((re *)objc_msgSend(v62[0], sel_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage_, v70, 0, 0, v50, 8 * v52, 8 * v51));
            (*(void (**)(uint64_t, re *))(*(void *)v48[2] + 40))(v48[2], v50);
            *(unsigned char *)a4 &= 0x80u;
            *(void *)(a4 + 8) = v62[0];
            *(_DWORD *)(a4 + 88) = 0;
            *(void *)(a4 + 96) = 0;
            if (v47) {

            }
            goto LABEL_11;
          }
          double v23 = *re::pipelineLogObjects(0);
          if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            goto LABEL_10;
          }
          LODWORD(v70[0]) = 136315138;
          *(fpos_t *)((char *)v70 + 4) = (fpos_t)a2;
          uint64_t v20 = "Failed to parse LUT from file '%s'";
        }
        else
        {
          double v23 = *re::pipelineLogObjects(v26);
          if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            goto LABEL_10;
          }
          LODWORD(v70[0]) = 136315138;
          *(fpos_t *)((char *)v70 + 4) = (fpos_t)a2;
          uint64_t v20 = "Failed to find size of LUT from file '%s'";
        }
      }
      else
      {
        double v23 = *re::pipelineLogObjects(0);
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          goto LABEL_10;
        }
        LODWORD(v70[0]) = 136315138;
        *(fpos_t *)((char *)v70 + 4) = (fpos_t)a2;
        uint64_t v20 = "Not enough memory to load LUT file '%s'";
      }
    }
    else
    {
      double v23 = *re::pipelineLogObjects(v12);
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        goto LABEL_10;
      }
      LODWORD(v70[0]) = 136315138;
      *(fpos_t *)((char *)v70 + 4) = (fpos_t)a2;
      uint64_t v20 = "Failed to read content of LUT file '%s'";
    }
    id v21 = v23;
    uint32_t v22 = 12;
    goto LABEL_49;
  }
  uint64_t v24 = *re::pipelineLogObjects(v7);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    if (v60) {
      uint64_t v43 = *(unsigned char **)&v61[7];
    }
    else {
      uint64_t v43 = v61;
    }
    LODWORD(v70[0]) = 136315394;
    *(fpos_t *)((char *)v70 + 4) = (fpos_t)a2;
    WORD2(v70[1]) = 2080;
    *(fpos_t *)((char *)&v70[1] + 6) = (fpos_t)v43;
    _os_log_error_impl(&dword_233120000, v24, OS_LOG_TYPE_ERROR, "Attempt to open LUT file '%s' did not succeed: %s", (uint8_t *)v70, 0x16u);
  }
  *(unsigned char *)a4 &= 0x80u;
  *(void *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 88) = 0;
  *(void *)(a4 + 96) = 0;
LABEL_16:
  re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v57);
  if (v62[0]) {
}
  }

void re::encodeProcessTextureCommands(id *a1, id *a2, id *a3, id *a4, id *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  unint64_t v11 = (char *)objc_msgSend(*a5, sel_mipmapLevelCount);
  int v34 = a4;
  int v12 = (char *)objc_msgSend(*a4, sel_mipmapLevelCount);
  if (v11 >= v12) {
    unint64_t v13 = v12;
  }
  else {
    unint64_t v13 = v11;
  }
  id v14 = *a5;
  uint64_t v15 = (uint64_t)objc_msgSend(*a5, sel_arrayLength);
  if ((char *)objc_msgSend(v14, sel_textureType) - 5 >= (char *)2) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 6 * v15;
  }
  uint64_t v38 = v16;
  unsigned int v17 = objc_msgSend(*a2, sel_maxTotalThreadsPerThreadgroup);
  unsigned int v31 = objc_msgSend(*a2, sel_threadExecutionWidth);
  if (v13)
  {
    CFURLRef v39 = 0;
    *(void *)&long long v18 = 136317186;
    long long v30 = v18;
    do
    {
      if (v38)
      {
        for (uint64_t i = 0; i != v38; ++i)
        {
          id v40 = objc_msgSend(*v34, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, a6, a8, v39, 1, i, 1, v30);
          id v20 = objc_msgSend(*a5, sel_newTextureViewWithPixelFormat_textureType_levels_slices_, a7, a8, v39, 1, i, 1);
          id v21 = *a5;
          id v22 = *a1;
          objc_msgSend(v21, sel_pixelFormat);
          objc_msgSend(*a5, sel_width);
          objc_msgSend(*a5, sel_height);
          objc_msgSend(*a5, sel_depth);
          objc_msgSend(*a5, sel_sampleCount);
          MTLGetTextureLevelInfoForDeviceWithOptions();

          unsigned int v24 = v17 / 0;
          if (v17 / 0 <= 1) {
            unsigned int v25 = 1;
          }
          else {
            unsigned int v25 = v17 / 0;
          }
          if (v25 >= (v31 / ((v17 / v31) >> 1) <= v17)) {
            uint64_t v26 = v31 / ((v17 / v31) >> 1) <= v17;
          }
          else {
            uint64_t v26 = v25;
          }
          if (v26 > v24) {
            uint64_t v27 = 1;
          }
          else {
            uint64_t v27 = v24;
          }
          if (re::pipelineHighFrequencyLoggingEnabled(void)::onceToken != -1) {
            dispatch_once(&re::pipelineHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_39);
          }
          if (re::pipelineHighFrequencyLoggingEnabled(void)::shouldLog)
          {
            uint64_t v28 = *re::pipelineLogObjects(v23);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = v30;
              *(void *)&uint8_t buf[4] = "Converting texture gamut";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 0xFFFFFFFF / 0;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = ((int)v27 - 1) / v27;
              __int16 v43 = 1024;
              int v44 = v26 - 1;
              __int16 v45 = 1024;
              int v46 = 0;
              __int16 v47 = 1024;
              int v48 = v27;
              __int16 v49 = 1024;
              int v50 = v26;
              __int16 v51 = 2048;
              int v52 = v39;
              __int16 v53 = 2048;
              uint64_t v54 = i;
              _os_log_debug_impl(&dword_233120000, v28, OS_LOG_TYPE_DEBUG, "%s: dispatching %dx%dx%d thread groups of size %dx%dx%d for mipmap level %zu, slice %zu", buf, 0x44u);
            }
          }
          [*a3 setTexture:v40 atIndex:0];
          [*a3 setTexture:v20 atIndex:1];
          id v29 = *a3;
          *(void *)long long buf = 0xFFFFFFFF / 0;
          *(void *)&uint8_t buf[8] = ((int)v27 - 1) / v27;
          *(void *)&uint8_t buf[16] = (v26 - 1);
          v41[0] = 0;
          v41[1] = v27;
          id v41[2] = v26;
          [v29 dispatchThreadgroups:buf threadsPerThreadgroup:v41];
          if (v20) {

          }
          if (v40) {
        }
          }
      }
      ++v39;
    }
    while (v39 != v13);
  }
}

void re::convertMetalTextureColorSpace(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 88) >= 2u) {
    std::__throw_bad_variant_access[abi:nn180100]();
  }
  int v3 = objc_msgSend(*(id *)(a1 + 8), sel_pixelFormat);
  uint64_t v7 = 0;
  long long v5 = 0u;
  long long v6 = 0u;
  long long v4 = 0u;
  MTLPixelFormatGetInfoForDevice();
  re::isHDR(v3);
  *(unsigned char *)a2 &= 0x80u;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
}

id re::createDescriptorFromTexture@<X0>(id *a1@<X0>, id *a2@<X1>, void *a3@<X8>)
{
  id v6 = objc_msgSend(objc_msgSend(MEMORY[0x263F12A50], sel_alloc), sel_init);
  *a3 = v6;
  objc_msgSend(v6, sel_setTextureType_, objc_msgSend(*a2, sel_textureType));
  objc_msgSend(v6, sel_setWidth_, objc_msgSend(*a2, sel_width));
  objc_msgSend(v6, sel_setHeight_, objc_msgSend(*a2, sel_height));
  objc_msgSend(v6, sel_setDepth_, objc_msgSend(*a2, sel_depth));
  objc_msgSend(v6, sel_setArrayLength_, objc_msgSend(*a2, sel_arrayLength));
  objc_msgSend(v6, sel_setMipmapLevelCount_, objc_msgSend(*a2, sel_mipmapLevelCount));
  objc_msgSend(v6, sel_setSampleCount_, objc_msgSend(*a2, sel_sampleCount));
  objc_msgSend(v6, sel_setPixelFormat_, objc_msgSend(*a2, sel_pixelFormat));
  objc_msgSend(v6, sel_setUsage_, objc_msgSend(*a2, sel_usage));
  objc_msgSend(v6, sel_setCpuCacheMode_, objc_msgSend(*a2, sel_cpuCacheMode));
  objc_msgSend(v6, sel_setStorageMode_, objc_msgSend(*a2, sel_storageMode));
  id v7 = objc_msgSend(*a2, sel_compressionType);
  if ((objc_msgSend(v6, sel_respondsToSelector_, sel_setCompressionType_) & 1) != 0
    || objc_msgSend(v6, sel_methodSignatureForSelector_, sel_setCompressionType_))
  {
    objc_msgSend(v6, sel_setCompressionType_, v7);
  }
  if (!*a1 || (id result = (id)[*a1 supportsTextureSwizzle], result))
  {
    uint64_t v9 = objc_msgSend(*a2, sel_swizzle);
    return objc_msgSend(v6, sel_setSwizzle_, v9);
  }
  return result;
}

id MTL::TextureDescriptor::setCompressionType(void *a1)
{
  if ((objc_msgSend(a1, sel_respondsToSelector_, sel_setCompressionType_) & 1) != 0
    || (id result = objc_msgSend(a1, sel_methodSignatureForSelector_, sel_setCompressionType_)) != 0)
  {
    return objc_msgSend(a1, sel_setCompressionType_, 0);
  }
  return result;
}

void re::convertTextureColorSpace(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*(_DWORD *)(a2 + 88)) {
    re::convertCPUTextureColorSpace(a1, a2, a3);
  }
  else {
    re::convertMetalTextureColorSpace(a2, a3);
  }
}

uint64_t re::internal::applyCompressionOptionsToTextureDescriptor(id *a1, _DWORD *a2, uint64_t a3, uint64_t a4, id *a5)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (a2[6] == 1) {
    return 0;
  }
  objc_msgSend(*a5, sel_pixelFormat);
  uint64_t v38 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  *(_OWORD *)long long buf = 0u;
  MTLPixelFormatGetInfoForDevice();
  int v8 = a2[6];
  if ((v8 - 3) < 2)
  {
    int ASTCDefaultMode = a2[8];
    if (!ASTCDefaultMode)
    {
      int ASTCDefaultMode = re::getASTCDefaultMode((int)objc_msgSend(*a5, sel_pixelFormat));
      int v8 = a2[6];
    }
    unsigned int v11 = a2[7];
    if (v11 <= 1) {
      unsigned int v11 = 1;
    }
    if (v8 == 3) {
      unsigned int v12 = 1;
    }
    else {
      unsigned int v12 = v11;
    }
    int MTLPixelFormat = re::getMTLPixelFormat(v12, ASTCDefaultMode);
    if (objc_msgSend(*a5, sel_pixelFormat) == (id)MTLPixelFormat) {
      return 0;
    }
    objc_msgSend(*a5, sel_textureType);
    char isSupportedPixelFormat = (re *)re::isSupportedPixelFormat();
    if (isSupportedPixelFormat) {
      BOOL v15 = MTLPixelFormat == 0;
    }
    else {
      BOOL v15 = 1;
    }
    if (v15)
    {
      uint64_t v16 = *re::pipelineLogObjects(isSupportedPixelFormat);
      uint64_t result = os_log_type_enabled(v16, OS_LOG_TYPE_INFO);
      if (!result) {
        return result;
      }
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_233120000, v16, OS_LOG_TYPE_INFO, "PixelFormatASTC_4x4_LDR not supported by device", buf, 2u);
      return 0;
    }
    objc_msgSend(*a5, sel_setPixelFormat_, MTLPixelFormat);
    return 1;
  }
  if (v8)
  {
    if (v8 == 2)
    {
      id v9 = *a5;
      if ((objc_msgSend(*a5, sel_respondsToSelector_, sel_setCompressionType_) & 1) != 0
        || objc_msgSend(v9, sel_methodSignatureForSelector_, sel_setCompressionType_))
      {
        objc_msgSend(v9, sel_setCompressionType_, 1);
      }
    }
  }
  else if (*a1)
  {
    id v18 = *a5;
    *(void *)long long buf = objc_msgSend(*a5, sel_storageMode);
    id v34 = objc_msgSend(*a5, sel_pixelFormat);
    id v33 = objc_msgSend(*a5, sel_usage);
    uint64_t TextureCompressionType = re::mtl::getTextureCompressionType(a1, buf, &v34, &v33);
    if ((objc_msgSend(v18, sel_respondsToSelector_, sel_setCompressionType_) & 1) != 0
      || objc_msgSend(v18, sel_methodSignatureForSelector_, sel_setCompressionType_))
    {
      objc_msgSend(v18, sel_setCompressionType_, TextureCompressionType);
    }
  }
  id v20 = *a5;
  if ((objc_msgSend(*a5, sel_respondsToSelector_, sel_compressionType) & 1) == 0)
  {
    uint64_t result = (uint64_t)objc_msgSend(v20, sel_methodSignatureForSelector_, sel_compressionType);
    if (!result) {
      return result;
    }
  }
  if (objc_msgSend(v20, sel_compressionType) != (id)1) {
    return 0;
  }
  objc_msgSend(*a5, sel_pixelFormat);
  uint64_t v38 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  *(_OWORD *)long long buf = 0u;
  InfoForDevice = (re *)MTLPixelFormatGetInfoForDevice();
  if ((*(_WORD *)&buf[8] & 0x400) == 0)
  {
    objc_msgSend(*a5, sel_pixelFormat);
    uint64_t v38 = 0;
    long long v36 = 0u;
    long long v37 = 0u;
    *(_OWORD *)long long buf = 0u;
    id v22 = (re *)MTLPixelFormatGetInfoForDevice();
    if ((*(_DWORD *)&buf[8] & 0x4000000) == 0)
    {
      double v23 = *re::pipelineLogObjects(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
      {
        id v24 = *a5;
        unsigned int v25 = v23;
        unsigned int v26 = objc_msgSend(v24, sel_pixelFormat);
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v26;
        _os_log_impl(&dword_233120000, v25, OS_LOG_TYPE_INFO, "Lossy compression not supported for pixel format '%u'", buf, 8u);
      }
      goto LABEL_36;
    }
    if (*a1)
    {
      id v29 = (re *)[*a1 supportsFamily:1008];
      if ((v29 & 1) == 0)
      {
        unsigned int v31 = *re::pipelineLogObjects(v29);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)long long buf = 0;
          id v32 = "Ignoring lossy compression request: requires MTLGPUFamilyApple8";
          goto LABEL_47;
        }
LABEL_48:
        MTL::TextureDescriptor::setCompressionType(*a5);
        return 0;
      }
    }
    long long v30 = (re *)objc_msgSend(*a5, sel_usage);
    if ((v30 & 0x10) != 0)
    {
      unsigned int v31 = *re::pipelineLogObjects(v30);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        id v32 = "Ignoring lossy compression request for texture with MTLTextureUsagePixelFormatView";
LABEL_47:
        _os_log_impl(&dword_233120000, v31, OS_LOG_TYPE_INFO, v32, buf, 2u);
        goto LABEL_48;
      }
      goto LABEL_48;
    }
    return 1;
  }
  uint64_t v27 = *re::pipelineLogObjects(InfoForDevice);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_233120000, v27, OS_LOG_TYPE_INFO, "Ignoring lossy compression request for compressed pixel format", buf, 2u);
  }
LABEL_36:
  id v28 = *a5;
  if ((objc_msgSend(v28, sel_respondsToSelector_, sel_setCompressionType_) & 1) != 0
    || (uint64_t result = (uint64_t)objc_msgSend(v28, sel_methodSignatureForSelector_, sel_setCompressionType_)) != 0)
  {
    objc_msgSend(v28, sel_setCompressionType_, 0);
    return 0;
  }
  return result;
}

void re::createCompressedTextureData(uint64_t a1@<X0>, int a2@<W1>, long long *a3@<X2>, id *a4@<X3>, id *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  v118[4] = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 88) >= 2u) {
    goto LABEL_129;
  }
  id v14 = (id *)(a1 + 8);
  objc_msgSend(*(id *)(a1 + 8), sel_pixelFormat);
  uint64_t v103 = 0;
  memset(v102, 0, sizeof(v102));
  MTLPixelFormatGetInfoForDevice();
  long long v111 = *a3;
  int ASTCDefaultMode = DWORD1(v111);
  if (!DWORD1(v111))
  {
    if (*(_DWORD *)(a1 + 88) >= 2u) {
      goto LABEL_129;
    }
    int ASTCDefaultMode = re::getASTCDefaultMode((int)objc_msgSend(*v14, sel_pixelFormat));
    DWORD1(v111) = ASTCDefaultMode;
  }
  uint64_t MTLPixelFormat = re::getMTLPixelFormat(v111, ASTCDefaultMode);
  if (!MTLPixelFormat) {
    goto LABEL_11;
  }
  int v18 = MTLPixelFormat;
  if (*a4)
  {
    if (*(_DWORD *)(a1 + 88) >= 2u) {
      goto LABEL_129;
    }
    objc_msgSend(*v14, sel_textureType);
    uint64_t MTLPixelFormat = re::isSupportedPixelFormat();
    if ((MTLPixelFormat & 1) == 0)
    {
LABEL_11:
      long long v20 = v102[0];
      long long v21 = v102[1];
      *(unsigned char *)a7 = 0;
      *(_OWORD *)(a7 + 8) = v20;
      *(_OWORD *)(a7 + 24) = v21;
      return;
    }
  }
  re::internal::synchronizeTextureMipmaps((id *)a1, v17);
  if (a5)
  {
    id v19 = *a5;
LABEL_17:
    id v23 = v19;
    id v110 = v19;
    goto LABEL_18;
  }
  int v22 = *(_DWORD *)(a1 + 88);
  if (v22 == 1)
  {
    id v19 = objc_msgSend(*v14, sel_copy);
    goto LABEL_17;
  }
  if (v22) {
    goto LABEL_129;
  }
  re::createDescriptorFromTexture(a4, v14, &v110);
  id v23 = v110;
LABEL_18:
  if ((objc_msgSend(v23, sel_respondsToSelector_, sel_setCompressionType_) & 1) != 0
    || objc_msgSend(v23, sel_methodSignatureForSelector_, sel_setCompressionType_))
  {
    objc_msgSend(v23, sel_setCompressionType_, 0);
  }
  id v80 = v110;
  objc_msgSend(v110, sel_setPixelFormat_, v18);
  id v24 = *(id *)(a1 + 96);
  id v25 = v24;
  v106[0] = 0;
  id v83 = v25;
  if (re::TextureData::label((re::TextureData *)a1))
  {
    unsigned int v26 = re::TextureData::label((re::TextureData *)a1);
    LOBYTE(v102[0]) = 1;
    *((void *)&v102[0] + 1) = *(void *)&v115[0];
    *(void *)&v102[2] = *((void *)&v115[1] + 1);
    v102[1] = *(long long *)((char *)v115 + 8);
    memset(v115, 0, 32);
    re::Optional<re::DynamicString>::operator=(v106, v102);
    if (LOBYTE(v102[0]) && *((void *)&v102[0] + 1))
    {
      if (v102[1]) {
        (*(void (**)(void))(**((void **)&v102[0] + 1) + 40))();
      }
      memset((char *)v102 + 8, 0, 32);
    }
    if (*(void *)&v115[0] && (BYTE8(v115[0]) & 1) != 0) {
      (*(void (**)(void, void))(**(void **)&v115[0] + 40))(*(void *)&v115[0], *(void *)&v115[1]);
    }
  }
  char v82 = *(unsigned char *)a1;
  LOBYTE(v102[0]) = 0;
  *((void *)&v102[0] + 1) = 0;
  unsigned int v104 = 0;
  id v105 = 0;
  int v27 = *(_DWORD *)(a1 + 88);
  if (v27 != 1)
  {
    if (!v27)
    {
      uint64_t v74 = a6;
      uint64_t v79 = MEMORY[0x237DBDCF0]();
      id v28 = re::TextureData::mipmapLevelCount((re::TextureData *)a1);
      FaceOrArrayCFIndex Length = re::internal::getFaceOrArrayLength((id *)a1, v29);
      unint64_t v87 = 0;
      *(void *)&long long v86 = 0;
      long long v85 = 0uLL;
      DWORD2(v86) = 0;
      if (*(_DWORD *)(a1 + 88) < 2u)
      {
        obuint64_t j = v24;
        uint64_t v84 = FaceOrArrayLength;
        uint64_t v31 = (void)v28 * FaceOrArrayLength;
        id v32 = objc_msgSend(*v14, sel_depth);
        if ((unint64_t)v32 <= 1) {
          uint64_t v33 = 1;
        }
        else {
          uint64_t v33 = (uint64_t)v32;
        }
        if (*((void *)&v85 + 1) < (unint64_t)(v31 * v33)) {
          re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity(&v85, v31 * v33);
        }
        LOBYTE(v95) = 0;
        *(void *)((char *)&v95 + 4) = 0;
        HIDWORD(v95) = 0;
        uint64_t v94 = 0;
        uint64_t v92 = 0;
        id v93 = (id)8;
        dispatch_get_global_queue(21, 0);
        id v96 = (id)objc_claimAutoreleasedReturnValue();
        if (v28)
        {
          uint64_t v34 = 0;
          id v75 = v28;
          id v77 = v14;
          while (1)
          {
            if (*(_DWORD *)(a1 + 88) >= 2u) {
              goto LABEL_129;
            }
            unint64_t v35 = (unint64_t)objc_msgSend(*v14, sel_depth);
            uint64_t v36 = v35 >> v34 <= 1 ? 1 : v35 >> v34;
            if (v84) {
              break;
            }
LABEL_50:
            ++v34;
            id v28 = v75;
            id v14 = v77;
            id v25 = v83;
            if ((id)v34 == v75) {
              goto LABEL_51;
            }
          }
          uint64_t v37 = 0;
LABEL_46:
          uint64_t v38 = 0;
          while (1)
          {
            v118[0] = &unk_26E7156F0;
            v118[1] = &v85;
            v118[3] = v118;
            re::copyTextureBytesToASTCCompression(a4, a1, &v111, a2, v34, v37, v38, (re::ASTCCompressor *)&v92, (uint64_t)v115, (uint64_t)v118);
            std::__function::__value_func<re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::~__value_func[abi:nn180100](v118);
            if (!LOBYTE(v115[0])) {
              break;
            }
            if (v36 == ++v38)
            {
              if (++v37 == v84) {
                goto LABEL_50;
              }
              goto LABEL_46;
            }
          }
          re::DynamicString::DynamicString((re::DynamicString *)v113, (const re::DynamicString *)((char *)v115 + 8));
          *(unsigned char *)a7 = 0;
          uint64_t v46 = *(void *)&v113[24];
          *(void *)(a7 + 8) = *(void *)v113;
          *(void *)(a7 + 32) = v46;
          *(_OWORD *)(a7 + 16) = *(_OWORD *)&v113[8];
          if (!LOBYTE(v115[0]) && *((void *)&v115[0] + 1) && (v115[1] & 1) != 0) {
            (*(void (**)(void))(**((void **)&v115[0] + 1) + 40))();
          }
          int v47 = 1;
          id v25 = v83;
          int v48 = (void *)v79;
LABEL_99:
          if (*((void *)&v95 + 1))
          {
            astcenc_context_free(*((uint64_t *)&v95 + 1));
            *((void *)&v95 + 1) = 0;
          }

          uint64_t v66 = v85;
          if ((void)v85)
          {
            id v67 = v87;
            if (v87)
            {
              if ((void)v86)
              {
                uint64_t v68 = 56 * v86;
                do
                {
                  if (*v67)
                  {

                    *id v67 = 0;
                  }
                  v67 += 7;
                  v68 -= 56;
                }
                while (v68);
                uint64_t v66 = v85;
                id v67 = v87;
              }
              (*(void (**)(uint64_t, id *))(*(void *)v66 + 40))(v66, v67);
            }
          }
          if (v47) {
            goto LABEL_118;
          }
          goto LABEL_111;
        }
LABEL_51:
        if (v74)
        {
          uint64_t v39 = *(void *)(v74 + 24);
          if (!v39)
          {
            long long v72 = (re::TextureData *)std::__throw_bad_function_call[abi:nn180100]();
            re::TextureData::label(v72);
            return;
          }
          (*(void (**)(uint64_t))(*(void *)v39 + 48))(v39);
        }
        if (!*(_DWORD *)(a1 + 88))
        {
          if (objc_msgSend(*v14, sel_isShareable)) {
            SharedTexture = (_anonymous_namespace_ *)re::mtl::Device::makeSharedTexture(v80, a4, &v101);
          }
          else {
            SharedTexture = (_anonymous_namespace_ *)re::mtl::Device::makeTexture(v80, a4, &v101);
          }
          if (!v101)
          {
            long long v61 = v115[0];
            long long v62 = v115[1];
            *(unsigned char *)a7 = 0;
            *(_OWORD *)(a7 + 8) = v61;
            *(_OWORD *)(a7 + 24) = v62;
            int v47 = 1;
            int v48 = (void *)v79;
LABEL_97:
            if (v101) {

            }
            goto LABEL_99;
          }
          *(void *)&v115[0] = 0x5D676084A50D34ACLL;
          *((void *)&v115[0] + 1) = "copyCompressedTextureQueue";
          re::ImportGraphicsContext::getOrCreateCommandQueue((uint64_t)a4, (uint64_t)v115, (const char *)1, &v100);
          re::mtl::CommandQueue::makeCommandBuffer(&v100, &v99);
          re::mtl::CommandBuffer::makeBlitCommandEncoder(&v99, &v98);
          if (v28)
          {
            uint64_t v52 = 0;
            uint64_t v53 = 0;
            id v76 = v28;
            int v78 = v14;
            while (1)
            {
              if (*(_DWORD *)(a1 + 88) >= 2u) {
                goto LABEL_129;
              }
              unint64_t v54 = (unint64_t)objc_msgSend(*v14, sel_depth);
              uint64_t v55 = v54 >> v52 <= 1 ? 1 : v54 >> v52;
              if (v84) {
                break;
              }
LABEL_86:
              if ((id)++v52 == v28) {
                goto LABEL_87;
              }
            }
            uint64_t v56 = 0;
LABEL_81:
            uint64_t v57 = 0;
            uint64_t v58 = 7 * v53;
            while (1)
            {
              uint64_t v59 = v86;
              if ((unint64_t)v86 <= v53 + v57) {
                break;
              }
              v115[0] = 0uLL;
              *(void *)&v115[1] = v57;
              re::mtl::BlitCommandEncoder::copyFromBufferToTexture(&v98, &v87[v58], (uint64_t *)&v87[v58 + 1], (long long *)&v87[v58 + 4], (uint64_t)v101, v56, v52, v115);
              ++v57;
              v58 += 7;
              if (v55 == v57)
              {
                ++v56;
                v53 += v57;
                if (v56 == v84)
                {
                  id v28 = v76;
                  id v14 = v78;
                  goto LABEL_86;
                }
                goto LABEL_81;
              }
            }
            uint64_t v112 = 0;
            memset(v115, 0, sizeof(v115));
            char v60 = (unsigned char *)&_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unsigned int v113 = 136315906;
            *(void *)&v113[4] = "operator[]";
            *(_WORD *)&v113[12] = 1024;
            *(_DWORD *)&v113[14] = 789;
            *(_WORD *)&v113[18] = 2048;
            *(void *)&v113[20] = v53 + v57;
            *(_WORD *)&v113[28] = 2048;
            *(void *)&v113[30] = v59;
            int v73 = 38;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          else
          {
LABEL_87:
            [v98 endEncoding];
            [v99 commit];
            [v99 waitUntilCompleted];
            char v60 = v113;
            re::internal::getCommandBufferError(&v99, (uint64_t)v113);
            if (v113[0])
            {
              LOBYTE(v115[0]) = 0;
              *((void *)&v115[0] + 1) = v101;
              unsigned int v116 = 0;
              id v117 = 0;
              re::TextureData::operator=((uint64_t)v102, (uint64_t)v115);
              re::TextureData::~TextureData((id *)v115);
              int v47 = 0;
LABEL_95:
              id v25 = v83;
              int v48 = (void *)v79;
              if (!v113[0] && *(void *)&v113[8] && (v113[16] & 1) != 0) {
                (*(void (**)(void))(**(void **)&v113[8] + 40))();
              }

              goto LABEL_97;
            }
          }
          if (v113[16]) {
            id v63 = *(unsigned char **)&v113[24];
          }
          else {
            id v63 = v60 + 17;
          }
          long long v64 = v115[0];
          long long v65 = v115[1];
          *(unsigned char *)a7 = 0;
          *(_OWORD *)(a7 + 8) = v64;
          *(_OWORD *)(a7 + 24) = v65;
          int v47 = 1;
          goto LABEL_95;
        }
      }
    }
LABEL_129:
    std::__throw_bad_variant_access[abi:nn180100]();
  }
  int v41 = objc_msgSend(*(id *)(a1 + 8), sel_pixelFormat);
  if (*(_DWORD *)(a1 + 88) != 1) {
    goto LABEL_129;
  }
  int v42 = re::MTLToASTCPixelFormat(v41);
  __int16 v43 = (_anonymous_namespace_ *)re::internal::createCompressedCPUTextureData((id *)(a1 + 16), v42, a2, &v110, (unsigned int *)&v111, 0, (uint64_t)&v92);
  if ((_BYTE)v92)
  {
    obuint64_t j = v24;
    LODWORD(v87) = 0;
    long long v85 = 0u;
    long long v86 = 0u;
    uint64_t v88 = 0;
    long long v90 = 0u;
    uint64_t v91 = 0;
    re::DynamicString::setCapacity(&v89, 0);
    *(void *)unsigned int v113 = v93;
    re::DynamicArray<re::DynamicArray<unsigned char>>::DynamicArray((uint64_t)&v113[8], &v94);
    re::DynamicString::DynamicString((re::DynamicString *)&v114, (const re::DynamicString *)v97);
    NS::SharedPtr<MTL::Texture>::operator=(&v93, (void **)&v85);
    re::DynamicArray<re::DynamicArray<unsigned char>>::operator=((uint64_t)&v94, (uint64_t *)&v85 + 1);
    re::DynamicString::operator=((re::DynamicString *)v97, (re::DynamicString *)&v89);
    LOBYTE(v115[0]) = 0;
    std::__variant_detail::__alt<1ul,re::CPUTexture>::__alt[abi:nn180100]<re::CPUTexture const&>((void *)v115 + 1, (uint64_t)v113);
    unsigned int v116 = 1;
    id v117 = 0;
    LOBYTE(v102[0]) = v115[0];
    std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)v102 + 8, (uint64_t)v115 + 8);
    id v44 = v117;
    id v117 = 0;
    id v45 = v105;
    id v105 = v44;

    if (v116 != -1) {
      ((void (*)(uint64_t *, char *))*(&off_26E715550 + v116))(&v112, (char *)v115 + 8);
    }
    unsigned int v116 = -1;
    re::CPUTexture::~CPUTexture((id *)v113);
    re::CPUTexture::~CPUTexture((id *)&v85);
    re::Result<re::CPUTexture,re::DynamicString>::~Result((unsigned __int8 *)&v92);
LABEL_111:
    objc_storeStrong(&v105, obj);
    if (v106[0])
    {
      if (v108) {
        unint64_t v69 = *(const char **)&v109[7];
      }
      else {
        unint64_t v69 = v109;
      }
      re::TextureData::setLabel((re::TextureData *)v102, v69);
    }
    LOBYTE(v102[0]) = v82 | 8;
    LOBYTE(v115[0]) = v82 | 8;
    BYTE8(v115[0]) = 0;
    unsigned int v116 = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)v115 + 8, (uint64_t)v102 + 8);
    id v70 = v105;
    id v105 = 0;
    id v117 = v70;
    *(unsigned char *)a7 = 1;
    *(unsigned char *)(a7 + 8) = v115[0];
    *(unsigned char *)(a7 + 16) = 0;
    *(_DWORD *)(a7 + 96) = -1;
    std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(a7 + 16, (uint64_t)v115 + 8);
    id v71 = v117;
    id v117 = 0;
    *(void *)(a7 + 104) = v71;
    if (v116 != -1) {
      ((void (*)(uint64_t *, char *))*(&off_26E715550 + v116))(&v92, (char *)v115 + 8);
    }
    goto LABEL_118;
  }
  if (v94) {
    __int16 v49 = (char *)v95;
  }
  else {
    __int16 v49 = (char *)&v94 + 1;
  }
  re::DynamicString::format((re::DynamicString *)"Failed to create compressed texture: %s.", (re::DynamicString *)v115, v49);
  long long v50 = v115[0];
  long long v51 = v115[1];
  *(unsigned char *)a7 = 0;
  *(_OWORD *)(a7 + 8) = v50;
  *(_OWORD *)(a7 + 24) = v51;
  re::Result<re::CPUTexture,re::DynamicString>::~Result((unsigned __int8 *)&v92);
LABEL_118:

  if (v104 != -1) {
    ((void (*)(long long *, char *))*(&off_26E715550 + v104))(v115, (char *)v102 + 8);
  }
  if (v106[0] && v107 && (v108 & 1) != 0) {
    (*(void (**)(void))(*(void *)v107 + 40))();
  }

  if (v110) {
}
  }

char *re::TextureData::label(re::TextureData *this)
{
  int v1 = *((_DWORD *)this + 22);
  if (v1 == 1)
  {
    if (*((unsigned char *)this + 64)) {
      return (char *)*((void *)this + 9);
    }
    else {
      return (char *)this + 65;
    }
  }
  else if (v1)
  {
    long long v4 = (re *)std::__throw_bad_variant_access[abi:nn180100]();
    return (char *)re::parseTextureFromImageOptions(v4, v5);
  }
  else
  {
    id v2 = objc_msgSend(*((id *)this + 1), sel_label);
    return (char *)objc_msgSend(v2, sel_UTF8String);
  }
}

void re::parseTextureFromImageOptions(re *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)this;
  id v55 = 0;
  long long v5 = [MEMORY[0x263F08900] JSONObjectWithData:v4 options:0 error:&v55];
  id v6 = v55;
  id v7 = v6;
  if (v6) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v5 == 0;
  }
  if (v8)
  {
    id v9 = [v6 localizedDescription];
    uint64_t v10 = [v9 UTF8String];
    re::DynamicString::format((re::DynamicString *)"JSON deocing error: %s\n%s", (re::DynamicString *)&v52, v10, re::kTextureFromImageOptionsJSONFormatHelp);
    long long v11 = v52;
    uint64_t v12 = v53;
    uint64_t v13 = v54;
    *(unsigned char *)a2 = 0;
    *(_OWORD *)(a2 + 8) = v11;
    *(void *)(a2 + 24) = v12;
    *(void *)(a2 + 32) = v13;
  }
  else
  {
    uint64_t v36 = a2;
    id v37 = v6;
    long long v49 = 0uLL;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    uint64_t v38 = v5;
    id v14 = v5;
    uint64_t v15 = [v14 countByEnumeratingWithState:&v45 objects:v56 count:16];
    if (v15)
    {
      uint64_t v16 = v15;
      int v17 = 0;
      int v39 = 0;
      id v18 = 0;
      int v19 = 6;
      uint64_t v40 = 0;
      uint64_t v20 = *(void *)v46;
      while (1)
      {
        uint64_t v21 = 0;
        do
        {
          if (*(void *)v46 != v20) {
            objc_enumerationMutation(v14);
          }
          int v22 = *(void **)(*((void *)&v45 + 1) + 8 * v21);
          id v23 = [v14 valueForKey:v22];
          if ([v22 isEqualToString:@"semantic"])
          {
            if ([v23 isEqualToString:@"color"])
            {
              int v19 = 3;
            }
            else if ([v23 isEqualToString:@"normal"])
            {
              int v19 = 5;
            }
            else
            {
              if (([v23 isEqualToString:@"raw"] & 1) == 0)
              {
                uint64_t v34 = [v23 UTF8String];
                re::DynamicString::format((re::DynamicString *)"Unsupported semantic: %s\n%s", (re::DynamicString *)&v52, v34, re::kTextureFromImageOptionsJSONFormatHelp);
                goto LABEL_46;
              }
              int v19 = 1;
            }
            uint64_t v40 = 0x300000002;
          }
          else if ([v22 isEqualToString:@"compression"])
          {
            if ([v23 isEqualToString:@"none"])
            {
              int v17 = 1;
            }
            else if ([v23 isEqualToString:@"GPULossy"])
            {
              int v17 = 2;
            }
            else if ([v23 isEqualToString:@"ASTC_4x4"])
            {
              int v17 = 3;
            }
            else
            {
              if ([v23 isEqualToString:@"ASTC_6x6"])
              {
                int v27 = 5;
              }
              else if ([v23 isEqualToString:@"ASTC_8x8"])
              {
                int v27 = 8;
              }
              else
              {
                if (([v23 isEqualToString:@"ASTC_10x10"] & 1) == 0)
                {
                  uint64_t v35 = [v23 UTF8String];
                  re::DynamicString::format((re::DynamicString *)"Unsupported compression: %s\n%s", (re::DynamicString *)&v52, v35, re::kTextureFromImageOptionsJSONFormatHelp);
                  goto LABEL_46;
                }
                int v27 = 12;
              }
              int v39 = v27;
              int v17 = 4;
            }
          }
          else
          {
            if (![v22 isEqualToString:@"colorSpace"])
            {
              uint64_t v32 = [v22 UTF8String];
              re::DynamicString::format((re::DynamicString *)"Unsupported key: %s\n%s", (re::DynamicString *)&v52, v32, re::kTextureFromImageOptionsJSONFormatHelp);
LABEL_46:
              long long v29 = v52;
              uint64_t v30 = v53;
              uint64_t v31 = v54;
              *(unsigned char *)uint64_t v36 = 0;
              *(_OWORD *)(v36 + 8) = v29;
              *(void *)(v36 + 24) = v30;
              *(void *)(v36 + 32) = v31;

              goto LABEL_47;
            }
            id v25 = (void *)re::CGColorSpaceNameFromOCIOString((re *)v23, v24);
            if (!v25)
            {
              uint64_t v33 = [v23 UTF8String];
              re::DynamicString::format((re::DynamicString *)"Unsupported colorSpace: %s\n%s", (re::DynamicString *)&v52, v33, re::kTextureFromImageOptionsJSONFormatHelp);
              goto LABEL_46;
            }
            id v26 = v25;

            CFRelease(v26);
            id v18 = v26;
          }

          ++v21;
        }
        while (v16 != v21);
        uint64_t v28 = [v14 countByEnumeratingWithState:&v45 objects:v56 count:16];
        uint64_t v16 = v28;
        if (!v28) {
          goto LABEL_42;
        }
      }
    }
    int v17 = 0;
    int v39 = 0;
    id v18 = 0;
    uint64_t v40 = 0;
    int v19 = 6;
LABEL_42:

    __int16 v43 = v52;
    char v44 = BYTE2(v52);
    __int16 v41 = v50;
    char v42 = v51;
    id v18 = v18;
    *(_OWORD *)(v36 + 80) = v49;
    *(unsigned char *)uint64_t v36 = 1;
    *(_OWORD *)(v36 + 8) = (unint64_t)v40;
    *(void *)(v36 + 24) = 1;
    *(_DWORD *)(v36 + 32) = v17;
    *(_DWORD *)(v36 + 36) = v39;
    *(void *)(v36 + 40) = 0;
    *(_DWORD *)(v36 + 48) = 0;
    *(unsigned char *)(v36 + 52) = 0;
    *(_WORD *)(v36 + 53) = v43;
    *(unsigned char *)(v36 + 55) = v44;
    *(_DWORD *)(v36 + 56) = 0;
    *(unsigned char *)(v36 + 60) = 0;
    *(unsigned char *)(v36 + 63) = v42;
    *(_WORD *)(v36 + 61) = v41;
    *(_DWORD *)(v36 + 64) = v19;
    *(void *)(v36 + 72) = v18;
LABEL_47:
    id v7 = v37;
    long long v5 = v38;
  }
}

void *re::introspect_TextureCompressionType(re *this, const re::IntrospectionBase *a2)
{
  int v2 = (int)this;
  {
    if (v9)
    {
      uint64_t v10 = re::introspectionAllocator(v9);
      long long v11 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v10 + 32))(v10, 24, 8);
      *(_DWORD *)long long v11 = 1;
      *((void *)v11 + 1) = 0;
      *((void *)v11 + 2) = "Unspecified";
      re::introspect_TextureCompressionType(BOOL)::enumAttributes = (uint64_t)v11;
      uint64_t v12 = re::introspectionAllocator(v11);
      uint64_t v13 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v12 + 32))(v12, 24, 8);
      *(_DWORD *)uint64_t v13 = 1;
      *((void *)v13 + 1) = 1;
      *((void *)v13 + 2) = "None";
      qword_2687A0B90 = (uint64_t)v13;
      id v14 = re::introspectionAllocator(v13);
      uint64_t v15 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, 24, 8);
      *(_DWORD *)uint64_t v15 = 1;
      *((void *)v15 + 1) = 2;
      *((void *)v15 + 2) = "MetalLossy";
      qword_2687A0B98 = (uint64_t)v15;
      uint64_t v16 = re::introspectionAllocator(v15);
      int v17 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v16 + 32))(v16, 24, 8);
      *(_DWORD *)int v17 = 1;
      *((void *)v17 + 1) = 3;
      *((void *)v17 + 2) = "ASTC_4x4";
      qword_2687A0BA0 = (uint64_t)v17;
      id v18 = re::introspectionAllocator(v17);
      uint64_t v19 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v18 + 32))(v18, 24, 8);
      *(_DWORD *)uint64_t v19 = 1;
      *(void *)(v19 + 8) = 4;
      *(void *)(v19 + 16) = "ASTC";
      qword_2687A0BA8 = v19;
    }
  }
  {
    uint64_t v20 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_TextureCompressionType(BOOL)::info, "TextureCompressionType", 4, 4, 1, 1);
    *(void *)uint64_t v20 = &unk_26E715E00;
    *((void *)v20 + 8) = &re::introspect_TextureCompressionType(BOOL)::enumTable;
    *((_DWORD *)v20 + 4) = 9;
  }
  if (v2)
  {
    if (re::introspect_TextureCompressionType(BOOL)::isInitialized) {
      return &re::introspect_TextureCompressionType(BOOL)::info;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v22);
    char v3 = re::introspect_TextureCompressionType(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v22);
    if (v3) {
      return &re::introspect_TextureCompressionType(BOOL)::info;
    }
    long long v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
    if (re::introspect_TextureCompressionType(BOOL)::isInitialized)
    {
LABEL_9:
      id v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
      return &re::introspect_TextureCompressionType(BOOL)::info;
    }
  }
  re::introspect_TextureCompressionType(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_TextureCompressionType(BOOL)::info, a2);
  v21[0] = 0x661208C0D60D1E8ALL;
  v21[1] = (uint64_t)"TextureCompressionType";
  xmmword_2687A0BD8 = v22;
  re::StringID::destroyString((re::StringID *)v21);
  if ((v2 & 1) == 0) {
    goto LABEL_9;
  }
  return &re::introspect_TextureCompressionType(BOOL)::info;
}

void re::introspect_ASTCBlockSize(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98178, memory_order_acquire) & 1) == 0)
  {
    CFStringRef v24 = (re *)__cxa_guard_acquire(&qword_26AF98178);
    if (v24)
    {
      id v25 = re::introspectionAllocator(v24);
      id v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)id v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "Invalid";
      qword_26AF982D0 = (uint64_t)v26;
      int v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "4x4";
      qword_26AF982D8 = (uint64_t)v28;
      long long v29 = re::introspectionAllocator(v28);
      uint64_t v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "5x4";
      qword_26AF982E0 = (uint64_t)v30;
      uint64_t v31 = re::introspectionAllocator(v30);
      uint64_t v32 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *((void *)v32 + 1) = 3;
      *((void *)v32 + 2) = "5x5";
      qword_26AF982E8 = (uint64_t)v32;
      uint64_t v33 = re::introspectionAllocator(v32);
      uint64_t v34 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 24, 8);
      *(_DWORD *)uint64_t v34 = 1;
      *((void *)v34 + 1) = 4;
      *((void *)v34 + 2) = "6x5";
      qword_26AF982F0 = (uint64_t)v34;
      uint64_t v35 = re::introspectionAllocator(v34);
      uint64_t v36 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v35 + 32))(v35, 24, 8);
      *(_DWORD *)uint64_t v36 = 1;
      *((void *)v36 + 1) = 5;
      *((void *)v36 + 2) = "6x6";
      qword_26AF982F8 = (uint64_t)v36;
      id v37 = re::introspectionAllocator(v36);
      uint64_t v38 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v37 + 32))(v37, 24, 8);
      *(_DWORD *)uint64_t v38 = 1;
      *((void *)v38 + 1) = 6;
      *((void *)v38 + 2) = "8x5";
      qword_26AF98300 = (uint64_t)v38;
      int v39 = re::introspectionAllocator(v38);
      uint64_t v40 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v39 + 32))(v39, 24, 8);
      *(_DWORD *)uint64_t v40 = 1;
      *((void *)v40 + 1) = 7;
      *((void *)v40 + 2) = "8x6";
      qword_26AF98308 = (uint64_t)v40;
      __int16 v41 = re::introspectionAllocator(v40);
      char v42 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v41 + 32))(v41, 24, 8);
      *(_DWORD *)char v42 = 1;
      *((void *)v42 + 1) = 8;
      *((void *)v42 + 2) = "8x8";
      qword_26AF98310 = (uint64_t)v42;
      __int16 v43 = re::introspectionAllocator(v42);
      char v44 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v43 + 32))(v43, 24, 8);
      *(_DWORD *)char v44 = 1;
      *((void *)v44 + 1) = 9;
      *((void *)v44 + 2) = "10x5";
      qword_26AF98318 = (uint64_t)v44;
      long long v45 = re::introspectionAllocator(v44);
      long long v46 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v45 + 32))(v45, 24, 8);
      *(_DWORD *)long long v46 = 1;
      *((void *)v46 + 1) = 10;
      *((void *)v46 + 2) = "10x6";
      qword_26AF98320 = (uint64_t)v46;
      long long v47 = re::introspectionAllocator(v46);
      long long v48 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v47 + 32))(v47, 24, 8);
      *(_DWORD *)long long v48 = 1;
      *((void *)v48 + 1) = 11;
      *((void *)v48 + 2) = "10x8";
      qword_26AF98328 = (uint64_t)v48;
      long long v49 = re::introspectionAllocator(v48);
      __int16 v50 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v49 + 32))(v49, 24, 8);
      *(_DWORD *)__int16 v50 = 1;
      *((void *)v50 + 1) = 12;
      *((void *)v50 + 2) = "10x10";
      qword_26AF98330 = (uint64_t)v50;
      char v51 = re::introspectionAllocator(v50);
      long long v52 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v51 + 32))(v51, 24, 8);
      *(_DWORD *)long long v52 = 1;
      *((void *)v52 + 1) = 13;
      *((void *)v52 + 2) = "12x10";
      qword_26AF98338 = (uint64_t)v52;
      uint64_t v53 = re::introspectionAllocator(v52);
      uint64_t v54 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v53 + 32))(v53, 24, 8);
      *(_DWORD *)uint64_t v54 = 1;
      *(void *)(v54 + 8) = 14;
      *(void *)(v54 + 16) = "12x12";
      qword_26AF98340 = v54;
      __cxa_guard_release(&qword_26AF98178);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98180, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98180))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF98240, "ASTCBlockSize", 4, 4, 1, 1);
    qword_26AF98240 = (uint64_t)&unk_26E715E00;
    qword_26AF98280 = (uint64_t)&re::introspect_ASTCBlockSize(BOOL)::enumTable;
    dword_26AF98250 = 9;
    __cxa_guard_release(&qword_26AF98180);
  }
  if ((_MergedGlobals_417 & 1) == 0)
  {
    _MergedGlobals_417 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF98240, a2);
    uint64_t v56 = 0xC9871D6D0725621ALL;
    uint64_t v57 = "ASTCBlockSize";
    v60[0] = 208862;
    v60[1] = "int";
    int v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v60);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v60);
      uint64_t v4 = (unsigned int *)qword_26AF98280;
      v59[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v60, &v56, 1, 1, (uint64_t)v59);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            id v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v58.var0 = 2 * v10;
            v58.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v60, v14, &v58);
            re::StringID::destroyString((re::StringID *)&v58);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              int v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    uint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v58.var0 = 2 * v18;
              v58.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v60, v22, &v58);
              re::StringID::destroyString((re::StringID *)&v58);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v60, v23);
      xmmword_26AF98260 = (__int128)v58;
      re::StringID::destroyString((re::StringID *)&v56);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v60);
      re::internal::assertLog((re::internal *)5, v55, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "ASTCBlockSize", v56, v57);
      _os_crash();
      __break(1u);
    }
  }
}

void re::introspect_ASTCMode(re *this, const re::IntrospectionBase *a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98188, memory_order_acquire) & 1) == 0)
  {
    CFStringRef v24 = (re *)__cxa_guard_acquire(&qword_26AF98188);
    if (v24)
    {
      id v25 = re::introspectionAllocator(v24);
      id v26 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 24, 8);
      *(_DWORD *)id v26 = 1;
      *((void *)v26 + 1) = 0;
      *((void *)v26 + 2) = "Unspecified";
      qword_26AF981C0 = (uint64_t)v26;
      int v27 = re::introspectionAllocator(v26);
      uint64_t v28 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v27 + 32))(v27, 24, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *((void *)v28 + 1) = 1;
      *((void *)v28 + 2) = "LinearLDR";
      qword_26AF981C8 = (uint64_t)v28;
      long long v29 = re::introspectionAllocator(v28);
      uint64_t v30 = (re *)(*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 24, 8);
      *(_DWORD *)uint64_t v30 = 1;
      *((void *)v30 + 1) = 2;
      *((void *)v30 + 2) = "SRGB_LDR";
      qword_26AF981D0 = (uint64_t)v30;
      uint64_t v31 = re::introspectionAllocator(v30);
      uint64_t v32 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v31 + 32))(v31, 24, 8);
      *(_DWORD *)uint64_t v32 = 1;
      *(void *)(v32 + 8) = 3;
      *(void *)(v32 + 16) = "LinearHDR";
      qword_26AF981D8 = v32;
      __cxa_guard_release(&qword_26AF98188);
    }
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98190, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98190))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_26AF98288, "ASTCMode", 4, 4, 1, 1);
    qword_26AF98288 = (uint64_t)&unk_26E715E00;
    qword_26AF982C8 = (uint64_t)&re::introspect_ASTCMode(BOOL)::enumTable;
    dword_26AF98298 = 9;
    __cxa_guard_release(&qword_26AF98190);
  }
  if ((byte_26AF98171 & 1) == 0)
  {
    byte_26AF98171 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_26AF98288, a2);
    uint64_t v34 = 0x36433FB06C8;
    uint64_t v35 = "ASTCMode";
    v38[0] = 208862;
    v38[1] = "int";
    int v2 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_2687A0D30, v38);
    if (v2)
    {
      uint64_t v3 = *v2;
      re::StringID::destroyString((re::StringID *)v38);
      uint64_t v4 = (unsigned int *)qword_26AF982C8;
      v37[1] = v3;
      re::TypeBuilder::beginEnumType((uint64_t)v38, &v34, 1, 1, (uint64_t)v37);
      unint64_t v6 = *v4;
      if (v6)
      {
        for (unint64_t i = 0; i < v6; ++i)
        {
          uint64_t v8 = *(void *)(*((void *)v4 + 1) + 8 * i);
          if (*(_DWORD *)v8 == 1)
          {
            id v9 = *(char **)(v8 + 16);
            if (v9)
            {
              uint64_t v10 = *v9;
              if (*v9)
              {
                char v11 = v9[1];
                if (v11)
                {
                  uint64_t v12 = (unsigned __int8 *)(v9 + 2);
                  do
                  {
                    uint64_t v10 = 31 * v10 + v11;
                    int v13 = *v12++;
                    char v11 = v13;
                  }
                  while (v13);
                }
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            uint64_t v14 = *(void *)(v8 + 8);
            *(void *)&v36.var0 = 2 * v10;
            v36.var1 = v9;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v38, v14, &v36);
            re::StringID::destroyString((re::StringID *)&v36);
            unint64_t v6 = *v4;
          }
        }
        if (v6)
        {
          for (unint64_t j = 0; j < v6; ++j)
          {
            uint64_t v16 = *(void *)(*((void *)v4 + 1) + 8 * j);
            if (*(_DWORD *)v16 == 2)
            {
              int v17 = *(char **)(v16 + 16);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (*v17)
                {
                  char v19 = v17[1];
                  if (v19)
                  {
                    uint64_t v20 = (unsigned __int8 *)(v17 + 2);
                    do
                    {
                      uint64_t v18 = 31 * v18 + v19;
                      int v21 = *v20++;
                      char v19 = v21;
                    }
                    while (v21);
                  }
                }
              }
              else
              {
                uint64_t v18 = 0;
              }
              uint64_t v22 = *(void *)(v16 + 8);
              *(void *)&v36.var0 = 2 * v18;
              v36.var1 = v17;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v38, v22, &v36);
              re::StringID::destroyString((re::StringID *)&v36);
              unint64_t v6 = *v4;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v38, v23);
      xmmword_26AF982A8 = (__int128)v36;
      re::StringID::destroyString((re::StringID *)&v34);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v38);
      re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "ASTCMode", v34, v35);
      _os_crash();
      __break(1u);
    }
  }
}

void *re::allocInfo_ASTCCompressionOptions(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF98198, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF98198))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98348, "ASTCCompressionOptions");
    __cxa_guard_release(&qword_26AF98198);
  }
  return &unk_26AF98348;
}

void re::initInfo_ASTCCompressionOptions(re *this, re::IntrospectionBase *a2)
{
  v20[0] = 0x9ADC94622CF054B2;
  v20[1] = "ASTCCompressionOptions";
  re::StringID::destroyString((re::StringID *)v20);
  *((_OWORD *)this + 2) = v21;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF981A0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF981A0);
    if (v4)
    {
      long long v5 = (re *)re::introspectionAllocator(v4);
      re::introspect_ASTCBlockSize(v5, v6);
      uint64_t v7 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v7 = 1;
      *(void *)(v7 + 8) = "blockSize";
      *(void *)(v7 + 16) = &qword_26AF98240;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_26AF981E0 = v7;
      uint64_t v8 = (re *)re::introspectionAllocator((re *)v7);
      re::introspect_ASTCMode(v8, v9);
      uint64_t v10 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, 72, 8);
      *(_DWORD *)uint64_t v10 = 1;
      *(void *)(v10 + 8) = "mode";
      *(void *)(v10 + 16) = &qword_26AF98288;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 32) = 0x400000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_26AF981E8 = v10;
      char v11 = re::introspectionAllocator((re *)v10);
      int v13 = re::introspect_BOOL((re *)1, v12);
      uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v11 + 32))(v11, 72, 8);
      *(_DWORD *)uint64_t v14 = 1;
      *(void *)(v14 + 8) = "premultipliedAlpha";
      *(void *)(v14 + 16) = v13;
      *(void *)(v14 + 24) = 0;
      *(void *)(v14 + 32) = 0x800000003;
      *(_DWORD *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = 0;
      *(void *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 64) = 0;
      qword_26AF981F0 = v14;
      uint64_t v15 = re::introspectionAllocator((re *)v14);
      int v17 = re::introspect_float((re *)1, v16);
      uint64_t v18 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v15 + 32))(v15, 72, 8);
      *(_DWORD *)uint64_t v18 = 1;
      *(void *)(v18 + 8) = "quality";
      *(void *)(v18 + 16) = v17;
      *(void *)(v18 + 24) = 0;
      *(void *)(v18 + 32) = 0xC00000004;
      *(_DWORD *)(v18 + 40) = 0;
      *(void *)(v18 + 48) = 0;
      *(void *)(v18 + 56) = 0;
      *(_DWORD *)(v18 + 64) = 0;
      qword_26AF981F8 = v18;
      __cxa_guard_release(&qword_26AF981A0);
    }
  }
  *((void *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 4;
  *((void *)this + 8) = &qword_26AF981E0;
  *((void *)this + 9) = re::internal::defaultConstruct<re::ASTCCompressionOptions>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::ASTCCompressionOptions>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ASTCCompressionOptions>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ASTCCompressionOptions>;
  re::IntrospectionRegistry::add(this, v3);
  long long v19 = v21;
}

void re::internal::defaultConstruct<re::ASTCCompressionOptions>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 12) = 0;
  *(void *)a3 = 0;
  *(unsigned char *)(a3 + 8) = 0;
}

uint64_t re::internal::defaultConstructV2<re::ASTCCompressionOptions>(uint64_t result)
{
  *(_DWORD *)(result + 12) = 0;
  *(void *)uint64_t result = 0;
  *(unsigned char *)(result + 8) = 0;
  return result;
}

uint64_t re::introspect_ASTCCompressionOptions(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ASTCCompressionOptions", (uint64_t (*)(re::internal *))re::allocInfo_ASTCCompressionOptions, (re::IntrospectionBase *(*)(void))re::initInfo_ASTCCompressionOptions, (void (*)(re::IntrospectionBase *))&qword_26AF981A8, this);
}

void *re::allocInfo_TextureCompileOptions(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF981B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26AF981B0))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF983C0, "TextureCompileOptions");
    __cxa_guard_release(&qword_26AF981B0);
  }
  return &unk_26AF983C0;
}

void re::initInfo_TextureCompileOptions(re *this, re::IntrospectionBase *a2)
{
  v38[0] = 0x8FAC598B1297B58CLL;
  v38[1] = "TextureCompileOptions";
  re::StringID::destroyString((re::StringID *)v38);
  *((_OWORD *)this + 2) = v39;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26AF981B8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v4 = (re *)__cxa_guard_acquire(&qword_26AF981B8);
    if (v4)
    {
      long long v5 = re::introspectionAllocator(v4);
      uint64_t v7 = re::introspect_BOOL((re *)1, v6);
      uint64_t v8 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v5 + 32))(v5, 72, 8);
      *(_DWORD *)uint64_t v8 = 1;
      *(void *)(v8 + 8) = "allocateMips";
      *(void *)(v8 + 16) = v7;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(void *)(v8 + 48) = 0;
      *(void *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_26AF98200 = v8;
      id v9 = re::introspectionAllocator((re *)v8);
      char v11 = re::introspect_BOOL((re *)1, v10);
      uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, 72, 8);
      *(_DWORD *)uint64_t v12 = 1;
      *(void *)(v12 + 8) = "generateMips";
      *(void *)(v12 + 16) = v11;
      *(void *)(v12 + 24) = 0;
      *(void *)(v12 + 32) = 0x100000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(void *)(v12 + 48) = 0;
      *(void *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_26AF98208 = v12;
      int v13 = re::introspectionAllocator((re *)v12);
      uint64_t v15 = re::introspect_BOOL((re *)1, v14);
      uint64_t v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v13 + 32))(v13, 72, 8);
      *(_DWORD *)uint64_t v16 = 1;
      *(void *)(v16 + 8) = "useAsRenderTarget";
      *(void *)(v16 + 16) = v15;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 32) = 0x200000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_26AF98210 = v16;
      int v17 = re::introspectionAllocator((re *)v16);
      long long v19 = re::introspect_BOOL((re *)1, v18);
      uint64_t v20 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v17 + 32))(v17, 72, 8);
      *(_DWORD *)uint64_t v20 = 1;
      *(void *)(v20 + 8) = "shaderRead";
      *(void *)(v20 + 16) = v19;
      *(void *)(v20 + 24) = 0;
      *(void *)(v20 + 32) = 0x300000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(void *)(v20 + 48) = 0;
      *(void *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_26AF98218 = v20;
      long long v21 = re::introspectionAllocator((re *)v20);
      uint64_t v23 = re::introspect_BOOL((re *)1, v22);
      uint64_t v24 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v21 + 32))(v21, 72, 8);
      *(_DWORD *)uint64_t v24 = 1;
      *(void *)(v24 + 8) = "privateStorageMode";
      *(void *)(v24 + 16) = v23;
      *(void *)(v24 + 24) = 0;
      *(void *)(v24 + 32) = 0x400000005;
      *(_DWORD *)(v24 + 40) = 0;
      *(void *)(v24 + 48) = 0;
      *(void *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_26AF98220 = v24;
      id v25 = re::introspectionAllocator((re *)v24);
      int v27 = re::introspect_int((re *)1, v26);
      uint64_t v28 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v25 + 32))(v25, 72, 8);
      *(_DWORD *)uint64_t v28 = 1;
      *(void *)(v28 + 8) = "downsampleFactor";
      *(void *)(v28 + 16) = v27;
      *(void *)(v28 + 24) = 0;
      *(void *)(v28 + 32) = 0x800000006;
      *(_DWORD *)(v28 + 40) = 0;
      *(void *)(v28 + 48) = 0;
      *(void *)(v28 + 56) = 0;
      *(_DWORD *)(v28 + 64) = 0;
      qword_26AF98228 = v28;
      long long v29 = re::introspectionAllocator((re *)v28);
      re::introspect_TextureCompressionType((re *)1, v30);
      uint64_t v31 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*(void *)v29 + 32))(v29, 72, 8);
      *(_DWORD *)uint64_t v31 = 1;
      *(void *)(v31 + 8) = "compressionType";
      *(void *)(v31 + 16) = &re::introspect_TextureCompressionType(BOOL)::info;
      *(void *)(v31 + 24) = 0;
      *(void *)(v31 + 32) = 0xC00000007;
      *(_DWORD *)(v31 + 40) = 0;
      *(void *)(v31 + 48) = 0;
      *(void *)(v31 + 56) = 0;
      *(_DWORD *)(v31 + 64) = 0;
      qword_26AF98230 = v31;
      uint64_t v32 = (re *)re::introspectionAllocator((re *)v31);
      uint64_t v33 = v32;
      uint64_t v34 = (re *)qword_26AF981A8;
      if (!qword_26AF981A8)
      {
        uint64_t v34 = (re *)re::allocInfo_ASTCCompressionOptions(v32);
        qword_26AF981A8 = (uint64_t)v34;
        re::initInfo_ASTCCompressionOptions(v34, v35);
      }
      uint64_t v36 = (*(uint64_t (**)(re *, uint64_t, uint64_t))(*(void *)v33 + 32))(v33, 72, 8);
      *(_DWORD *)uint64_t v36 = 1;
      *(void *)(v36 + 8) = "astcCompressionOptions";
      *(void *)(v36 + 16) = v34;
      *(void *)(v36 + 24) = 0;
      *(void *)(v36 + 32) = 0x1000000008;
      *(_DWORD *)(v36 + 40) = 0;
      *(void *)(v36 + 48) = 0;
      *(void *)(v36 + 56) = 0;
      *(_DWORD *)(v36 + 64) = 0;
      qword_26AF98238 = v36;
      __cxa_guard_release(&qword_26AF981B8);
    }
  }
  *((void *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 8;
  *((void *)this + 8) = &qword_26AF98200;
  *((void *)this + 9) = re::internal::defaultConstruct<re::TextureCompileOptions>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::TextureCompileOptions>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::TextureCompileOptions>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::TextureCompileOptions>;
  re::IntrospectionRegistry::add(this, v3);
  long long v37 = v39;
}

double re::internal::defaultConstruct<re::TextureCompileOptions>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&double result = 16777473;
  *(_DWORD *)a3 = 16777473;
  *(unsigned char *)(a3 + 4) = 1;
  *(_DWORD *)(a3 + 8) = 1;
  *(_DWORD *)(a3 + 28) = 0;
  *(void *)(a3 + 12) = 0;
  *(void *)(a3 + 17) = 0;
  return result;
}

double re::internal::defaultConstructV2<re::TextureCompileOptions>(uint64_t a1)
{
  *(void *)&double result = 16777473;
  *(_DWORD *)a1 = 16777473;
  *(unsigned char *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 28) = 0;
  *(void *)(a1 + 12) = 0;
  *(void *)(a1 + 17) = 0;
  return result;
}

uint64_t re::introspect_TextureCompileOptions(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"TextureCompileOptions", (uint64_t (*)(re::internal *))re::allocInfo_TextureCompileOptions, (re::IntrospectionBase *(*)(void))re::initInfo_TextureCompileOptions, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::TextureCompileOptions>, this);
}

void *re::DynamicArray<CGImagePtr>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    long long v5 = result;
    if (result[2] <= a2)
    {
      double result = (void *)*result;
      if (!*v5)
      {
        double result = (void *)re::DynamicArray<CGImagePtr>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x50uLL))
        {
          uint64_t v2 = 80 * a2;
          double result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
          if (result)
          {
            uint64_t v7 = result;
            if (!v5[1]) {
              goto LABEL_16;
            }
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        double result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      uint64_t v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      uint64_t v8 = v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v8 + 80 * v9;
        uint64_t v11 = (uint64_t)v7;
        do
        {
          CGImagePtr::CGImagePtr(v11, (uint64_t *)v8);
          CGImageRelease(*(CGImageRef *)v8);
          *(void *)uint64_t v8 = 0;
          CGColorSpaceRelease(*(CGColorSpaceRef *)(v8 + 48));
          *(void *)(v8 + 48) = 0;
          v11 += 80;
          v8 += 80;
        }
        while (v8 != v10);
        uint64_t v8 = v5[4];
      }
      double result = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26E715570;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E715570;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  int v1 = *(void **)(a1 + 8);
  if (*v1)
  {
    *int v1 = 0;
    uint64_t v2 = *(void *)(a1 + 16);
    uint64_t v3 = *(void *)(v2 + 136);
    if (v3)
    {
      (*(void (**)(void))(v3 + 16))();
      uint64_t v4 = *(void **)(v2 + 136);
      *(void *)(v2 + 136) = 0;
    }
  }
}

uint64_t std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_0>,void ()(void)>::target_type()
{
}

void std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26E7155F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E7155F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = **(const void ***)(a1 + 8);
  if (v2)
  {
    CFRelease(v2);
    **(void **)(a1 + 8) = 0;
    uint64_t v3 = *(void *)(a1 + 16);
    uint64_t v4 = *(void *)(v3 + 136);
    if (v4)
    {
      (*(void (**)(void))(v4 + 16))();
      long long v5 = *(void **)(v3 + 136);
      *(void *)(v3 + 136) = 0;
    }
  }
}

uint64_t std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_1>,void ()(void)>::target_type()
{
}

void std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2>,void ()(void)>::~__func()
{
}

__n128 std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26E715670;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E715670;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2>,void ()(void)>::operator()(uint64_t a1)
{
  int v1 = *(void **)(a1 + 8);
  if (*v1)
  {
    *int v1 = 0;
    uint64_t v2 = *(void *)(a1 + 16);
    uint64_t v3 = *(void *)(v2 + 136);
    if (v3)
    {
      (*(void (**)(void))(v3 + 16))();
      uint64_t v4 = *(void **)(v2 + 136);
      *(void *)(v2 + 136) = 0;
    }
  }
}

uint64_t std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2,std::allocator<re::loadTextureDataWithProvider(re::TextureProvider &,re::Allocator *)::$_2>,void ()(void)>::target_type()
{
}

void std::__function::__func<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0,std::allocator<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0>,re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::~__func()
{
}

void *std::__function::__func<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0,std::allocator<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0>,re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26E7156F0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0,std::allocator<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0>,re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26E7156F0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0,std::allocator<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0>,re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::operator()(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  memset(v19, 0, 56);
  (*(void (**)(id *__return_ptr, uint64_t, id *, id *))(*(void *)a2 + 24))(&v18, a2, &v19[1], &v19[4]);
  NS::SharedPtr<MTL::Texture>::operator=(v19, &v18);
  long long v5 = (_anonymous_namespace_ *)v18;
  if (v18) {

  }
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = *(void *)(v6 + 8);
  unint64_t v8 = *(void *)(v6 + 16);
  unint64_t v9 = v8 + 1;
  if (v8 >= v7 && v7 < v9)
  {
    if (*(void *)v6)
    {
      uint64_t v14 = 2 * v7;
      BOOL v15 = v7 == 0;
      unint64_t v16 = 8;
      if (!v15) {
        unint64_t v16 = v14;
      }
      if (v16 <= v9) {
        unint64_t v17 = v9;
      }
      else {
        unint64_t v17 = v16;
      }
      re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity((void *)v6, v17);
    }
    else
    {
      re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity((void *)v6, v9);
      ++*(_DWORD *)(v6 + 24);
    }
  }
  uint64_t v11 = *(void *)(v6 + 32) + 56 * *(void *)(v6 + 16);
  *(void *)uint64_t v11 = v19[0];
  long long v13 = *(_OWORD *)&v19[3];
  long long v12 = *(_OWORD *)&v19[5];
  *(_OWORD *)(v11 + 8) = *(_OWORD *)&v19[1];
  *(_OWORD *)(v11 + 40) = v12;
  *(_OWORD *)(v11 + 24) = v13;
  ++*(void *)(v6 + 16);
  ++*(_DWORD *)(v6 + 24);
  if (v19[0]) {

  }
  *a3 = 1;
}

uint64_t std::__function::__func<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0,std::allocator<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0>,re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0,std::allocator<re::createCompressedTextureData(re::TextureData const&,re::TextureSemantic,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,NS::SharedPtr<MTL::TextureDescriptor> const*,std::function<void ()(void)> const*)::$_0>,re::Result<re::Unit,re::DynamicString> ()(re::ASTCResultBuffer const&)>::target_type()
{
}

unsigned __int8 *re::Result<re::CPUTexture,re::DynamicString>::~Result(unsigned __int8 *a1)
{
  int v3 = *a1;
  uint64_t v2 = (id *)(a1 + 8);
  if (v3) {
    re::CPUTexture::~CPUTexture(v2);
  }
  else {
    re::DynamicString::deinit((re::DynamicString *)v2);
  }
  return a1;
}

BOOL re::meshHasSkinningData(re *this, const re::GeomMesh *a2)
{
  uint64_t v2 = (re *)((char *)this + 64);
  uint64_t v3 = re::internal::GeomAttributeManager::attributeByName((re *)((char *)this + 64), "skeletonPath");
  uint64_t v4 = re::internal::GeomAttributeManager::attributeByName(v2, "skinnedAnimationGeometryBindTransform");
  uint64_t v5 = re::internal::GeomAttributeManager::attributeByName(v2, "skinnedAnimationWeights");
  uint64_t v6 = re::internal::GeomAttributeManager::attributeByName(v2, "skinnedAnimationJointIndices");
  uint64_t v7 = re::internal::GeomAttributeManager::attributeByName(v2, "skinnedAnimationInfluenceEndIndices");
  if (v3) {
    BOOL v8 = v4 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  return !v8 && v5 != 0 && v6 != 0 && v7 != 0;
}

uint64_t re::repairTangentsAndBitangentsAllVertexRateInternal(re *this, re::GeomMesh *a2, re::GeomAttribute *a3, re::GeomAttribute *a4, re::GeomAttribute *a5)
{
  if ((*(unsigned int (**)(re::GeomMesh *))(*(void *)a2 + 16))(a2))
  {
    uint64_t v9 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)a2, 0);
    unint64_t v10 = (*(unsigned int (**)(re::GeomMesh *))(*(void *)a2 + 16))(a2);
  }
  else
  {
    unint64_t v10 = 0;
    uint64_t v9 = 0;
  }
  if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)a3 + 16))(a3))
  {
    uint64_t v11 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)a3, 0);
    uint64_t v12 = (*(unsigned int (**)(re::GeomAttribute *))(*(void *)a3 + 16))(a3);
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  uint64_t result = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)a4 + 16))(a4);
  if (result)
  {
    uint64_t v14 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)a4, 0);
    uint64_t result = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)a4 + 16))(a4);
    uint64_t v15 = result;
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v14 = 0;
  }
  uint64_t v16 = *((unsigned int *)this + 4);
  if (v16)
  {
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    uint64_t v19 = 16 * v16;
    do
    {
      if (16 * v12 == v17)
      {
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_34:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_35:
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (16 * v15 == v17) {
        goto LABEL_34;
      }
      float32x4_t v20 = vmulq_f32(*(float32x4_t *)(v11 + v17), *(float32x4_t *)(v11 + v17));
      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0]) < 1.0e-10|| (float32x4_t v21 = vmulq_f32(*(float32x4_t *)(v14 + v17), *(float32x4_t *)(v14 + v17)), fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0]) < 1.0e-10))
      {
        if (v10 <= v18) {
          goto LABEL_35;
        }
        float32x4_t v22 = *(float32x4_t *)(v9 + v17);
        v23.i32[1] = v22.i32[1];
        v23.i32[0] = vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL).u32[0];
        int8x8_t v24 = vmvn_s8(vorr_s8((int8x8_t)vcltz_f32(v23), (int8x8_t)vcgez_f32(v23)));
        if ((v24.i8[4] & 1) == 0 && (v24.i8[0] & 1) == 0)
        {
          float32x4_t v25 = vmulq_f32(v22, v22);
          LODWORD(v26) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).u32[0];
          if (fabsf(v26) >= 1.0e-10)
          {
            float v27 = v26;
            float32x2_t v28 = vrsqrte_f32((float32x2_t)LODWORD(v26));
            float32x2_t v29 = vmul_f32(v28, vrsqrts_f32((float32x2_t)LODWORD(v27), vmul_f32(v28, v28)));
            float32x4_t v30 = vmulq_n_f32(v22, vmul_f32(v29, vrsqrts_f32((float32x2_t)LODWORD(v27), vmul_f32(v29, v29))).f32[0]);
            uint64_t v31 = (void *)(v11 + v17);
            *uint64_t v31 = 0;
            v31[1] = 0;
            float32x4_t v32 = vabsq_f32(v30);
            if (v32.f32[1] <= v32.f32[2]) {
              uint64_t v33 = 1;
            }
            else {
              uint64_t v33 = 2;
            }
            if (v32.f32[0] <= v32.f32[2] && v32.f32[0] <= v32.f32[1]) {
              uint64_t v33 = 0;
            }
            *((_DWORD *)v31 + v33) = 1065353216;
            float32x4_t v35 = vmulq_f32(v30, v30);
            float v36 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1))).f32[0];
            float32x4_t v37 = *(float32x4_t *)v31;
            float32x4_t v38 = *(float32x4_t *)v31;
            if (v36 > 0.0)
            {
              float32x4_t v39 = vmulq_f32(v37, v30);
              float32x4_t v38 = vmulq_n_f32(v30, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0]/ v36);
            }
            float32x4_t v40 = vsubq_f32(v37, v38);
            int32x4_t v41 = (int32x4_t)vmulq_f32(v40, v40);
            v41.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v41, 2), vadd_f32(*(float32x2_t *)v41.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v41.i8, 1))).u32[0];
            float32x2_t v42 = vrsqrte_f32((float32x2_t)v41.u32[0]);
            float32x2_t v43 = vmul_f32(v42, vrsqrts_f32((float32x2_t)v41.u32[0], vmul_f32(v42, v42)));
            float32x4_t v44 = vmulq_n_f32(v40, vmul_f32(v43, vrsqrts_f32((float32x2_t)v41.u32[0], vmul_f32(v43, v43))).f32[0]);
            *(float32x4_t *)(v11 + v17) = v44;
            int8x16_t v45 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL), vnegq_f32(v30)), v44, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL));
            *(int8x16_t *)(v14 + v17) = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v45, (int32x4_t)v45), v45, 0xCuLL);
          }
        }
      }
      ++v18;
      v17 += 16;
    }
    while (v19 != v17);
  }
  return result;
}

uint64_t re::repairTangentsAndBitangentsSlowInternal(re *this, re::GeomMesh *a2, re::GeomAttribute *a3, re::GeomAttribute *a4, re::GeomAttribute *a5)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  if ((*(unsigned int (**)(re::GeomMesh *))(*(void *)a2 + 16))(a2))
  {
    uint64_t v51 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)a2, 0);
    unsigned int v52 = (*(uint64_t (**)(re::GeomMesh *))(*(void *)a2 + 16))(a2);
  }
  else
  {
    unsigned int v52 = 0;
    uint64_t v51 = 0;
  }
  if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)a3 + 16))(a3))
  {
    uint64_t v9 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)a3, 0);
    unsigned int v10 = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)a3 + 16))(a3);
  }
  else
  {
    unsigned int v10 = 0;
    uint64_t v9 = 0;
  }
  uint64_t result = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)a4 + 16))(a4);
  if (result)
  {
    uint64_t v13 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)a4, 0);
    uint64_t result = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)a4 + 16))(a4);
    unsigned int v14 = result;
  }
  else
  {
    unsigned int v14 = 0;
    uint64_t v13 = 0;
  }
  v55[0] = 0;
  if (*((unsigned char *)a2 + 16) == 3)
  {
    uint64_t result = re::internal::accessFaceVaryingAttributeSubmesh(a2, v12);
    v55[1] = result;
  }
  else
  {
    v55[0] = (uint64_t)this;
  }
  v54[0] = 0;
  if (*((unsigned char *)a3 + 16) == 3)
  {
    uint64_t result = re::internal::accessFaceVaryingAttributeSubmesh(a3, v12);
    v54[1] = result;
  }
  else
  {
    v54[0] = (uint64_t)this;
  }
  v53[0] = 0;
  if (*((unsigned char *)a4 + 16) == 3)
  {
    uint64_t result = re::internal::accessFaceVaryingAttributeSubmesh(a4, v12);
    v53[1] = result;
  }
  else
  {
    v53[0] = (uint64_t)this;
  }
  uint64_t v50 = *((unsigned int *)this + 10);
  if (*((_DWORD *)this + 10))
  {
    unint64_t v15 = 0;
    long long v49 = this;
    do
    {
      unint64_t v16 = *((void *)this + 5);
      if (v16 <= v15) {
        goto LABEL_54;
      }
      unsigned __int8 v17 = 0;
      if (*(_DWORD *)(*((void *)this + 7) + 16 * v15 + 12) == -1) {
        unsigned __int8 v18 = 3;
      }
      else {
        unsigned __int8 v18 = 4;
      }
      do
      {
        unsigned int v19 = v17;
        unsigned int v20 = re::repairTangentsAndBitangentsSlowInternal(re::GeomMesh &,re::GeomAttribute *,re::GeomAttribute *,re::GeomAttribute *)::FaceVertexAdaptor::vertexIndexOnFace(v54, v15, v17);
        uint64_t result = re::repairTangentsAndBitangentsSlowInternal(re::GeomMesh &,re::GeomAttribute *,re::GeomAttribute *,re::GeomAttribute *)::FaceVertexAdaptor::vertexIndexOnFace(v53, v15, v17);
        if (v20 != -1 && result != -1)
        {
          if (v10 <= v20)
          {
            uint64_t v56 = 0;
            long long v68 = 0u;
            long long v69 = 0u;
            long long v67 = 0u;
            long long v65 = 0u;
            long long v66 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v57 = 136315906;
            StringID v58 = "operator[]";
            __int16 v59 = 1024;
            int v60 = 609;
            __int16 v61 = 2048;
            unint64_t v62 = v20;
            __int16 v63 = 2048;
            unint64_t v64 = v10;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_52:
            uint64_t v56 = 0;
            long long v68 = 0u;
            long long v69 = 0u;
            long long v67 = 0u;
            long long v65 = 0u;
            long long v66 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v57 = 136315906;
            StringID v58 = "operator[]";
            __int16 v59 = 1024;
            int v60 = 609;
            __int16 v61 = 2048;
            unint64_t v62 = v19;
            __int16 v63 = 2048;
            unint64_t v64 = v14;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_53:
            uint64_t v56 = 0;
            long long v68 = 0u;
            long long v69 = 0u;
            long long v67 = 0u;
            long long v65 = 0u;
            long long v66 = 0u;
            unint64_t v16 = &_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v57 = 136315906;
            StringID v58 = "operator[]";
            __int16 v59 = 1024;
            int v60 = 601;
            __int16 v61 = 2048;
            unint64_t v62 = v20;
            __int16 v63 = 2048;
            unint64_t v64 = v52;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_54:
            uint64_t v56 = 0;
            long long v68 = 0u;
            long long v69 = 0u;
            long long v67 = 0u;
            long long v65 = 0u;
            long long v66 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v57 = 136315906;
            StringID v58 = "operator[]";
            __int16 v59 = 1024;
            int v60 = 797;
            __int16 v61 = 2048;
            unint64_t v62 = v15;
            __int16 v63 = 2048;
            unint64_t v64 = v16;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          unsigned int v19 = result;
          if (v14 <= result) {
            goto LABEL_52;
          }
          float32x4_t v22 = (float32x4_t *)(v9 + 16 * v20);
          float32x2_t v23 = (float32x4_t *)(v13 + 16 * result);
          float32x4_t v24 = vmulq_f32(*v22, *v22);
          if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).f32[0]) < 1.0e-10|| (float32x4_t v25 = vmulq_f32(*v23, *v23), fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0]) < 1.0e-10))
          {
            uint64_t result = re::repairTangentsAndBitangentsSlowInternal(re::GeomMesh &,re::GeomAttribute *,re::GeomAttribute *,re::GeomAttribute *)::FaceVertexAdaptor::vertexIndexOnFace(v55, v15, v17);
            if (result != -1)
            {
              unsigned int v20 = result;
              if (v52 <= result) {
                goto LABEL_53;
              }
              float32x4_t v26 = *(float32x4_t *)(v51 + 16 * result);
              v27.i32[1] = v26.i32[1];
              v27.i32[0] = vextq_s8((int8x16_t)v26, (int8x16_t)v26, 8uLL).u32[0];
              int8x8_t v28 = vmvn_s8(vorr_s8((int8x8_t)vcltz_f32(v27), (int8x8_t)vcgez_f32(v27)));
              if ((v28.i8[4] & 1) == 0 && (v28.i8[0] & 1) == 0)
              {
                float32x4_t v29 = vmulq_f32(v26, v26);
                LODWORD(v30) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).u32[0];
                if (fabsf(v30) >= 1.0e-10)
                {
                  float v31 = v30;
                  float32x2_t v32 = vrsqrte_f32((float32x2_t)LODWORD(v30));
                  float32x2_t v33 = vmul_f32(v32, vrsqrts_f32((float32x2_t)LODWORD(v31), vmul_f32(v32, v32)));
                  float32x4_t v34 = vmulq_n_f32(v26, vmul_f32(v33, vrsqrts_f32((float32x2_t)LODWORD(v31), vmul_f32(v33, v33))).f32[0]);
                  v22->i64[0] = 0;
                  v22->i64[1] = 0;
                  float32x4_t v35 = vabsq_f32(v34);
                  uint64_t v36 = 2;
                  if (v35.f32[1] <= v35.f32[2]) {
                    uint64_t v36 = 1;
                  }
                  if (v35.f32[0] <= v35.f32[2] && v35.f32[0] <= v35.f32[1]) {
                    uint64_t v36 = 0;
                  }
                  v22->i32[v36] = 1065353216;
                  float32x4_t v38 = vmulq_f32(v34, v34);
                  float v39 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0];
                  float32x4_t v40 = *v22;
                  float32x4_t v41 = *v22;
                  if (v39 > 0.0)
                  {
                    float32x4_t v42 = vmulq_f32(v40, v34);
                    float32x4_t v41 = vmulq_n_f32(v34, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0]/ v39);
                  }
                  float32x4_t v43 = vsubq_f32(v40, v41);
                  int32x4_t v44 = (int32x4_t)vmulq_f32(v43, v43);
                  v44.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v44, 2), vadd_f32(*(float32x2_t *)v44.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v44.i8, 1))).u32[0];
                  float32x2_t v45 = vrsqrte_f32((float32x2_t)v44.u32[0]);
                  float32x2_t v46 = vmul_f32(v45, vrsqrts_f32((float32x2_t)v44.u32[0], vmul_f32(v45, v45)));
                  float32x4_t v47 = vmulq_n_f32(v43, vmul_f32(v46, vrsqrts_f32((float32x2_t)v44.u32[0], vmul_f32(v46, v46))).f32[0]);
                  *float32x4_t v22 = v47;
                  int8x16_t v48 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v47, (int32x4_t)v47), (int8x16_t)v47, 0xCuLL), vnegq_f32(v34)), v47, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34), (int8x16_t)v34, 0xCuLL));
                  *(int8x16_t *)float32x2_t v23 = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v48, (int32x4_t)v48), v48, 0xCuLL);
                }
              }
            }
          }
        }
        ++v17;
      }
      while (v17 < v18);
      ++v15;
      this = v49;
    }
    while (v15 != v50);
  }
  return result;
}

uint64_t re::repairTangentsAndBitangentsSlowInternal(re::GeomMesh &,re::GeomAttribute *,re::GeomAttribute *,re::GeomAttribute *)::FaceVertexAdaptor::vertexIndexOnFace(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v4 = *a1;
  if (*a1)
  {
    if (*(void *)(v4 + 40) > (unint64_t)a2)
    {
      long long v12 = *(_OWORD *)(*(void *)(v4 + 56) + 16 * a2);
      uint64_t v5 = &v12;
      return *((unsigned int *)v5 + a3);
    }
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v12 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_21;
  }
  uint64_t v8 = a1[1];
  LODWORD(v12) = a2;
  int v9 = *(unsigned __int8 *)(v8 + 140);
  if (v9 == 2)
  {
    uint64_t v10 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(v8 + 144), (unsigned int *)&v12);
    if (v10 == -1) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v11 = (_DWORD *)(*(void *)(v8 + 152) + 8 * v10 + 4);
    goto LABEL_14;
  }
  if (v9 == 1)
  {
    if (*(void *)(v8 + 160) <= (unint64_t)a2) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v11 = (_DWORD *)(*(void *)(v8 + 176) + 4 * a2);
LABEL_14:
    LODWORD(a2) = *v11;
    if (*v11 == -1) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v8 = a1[1];
LABEL_16:
    if (*(void *)(v8 + 24) > (unint64_t)a2)
    {
      uint64_t v5 = (long long *)(*(void *)(v8 + 40) + 16 * a2);
      return *((unsigned int *)v5 + a3);
    }
LABEL_21:
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v12 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(unsigned char *)(v8 + 140))
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    uint64_t result = _os_crash();
    __break(1u);
    return result;
  }
  if (*(_DWORD *)(v8 + 144) > a2) {
    goto LABEL_16;
  }
  return 0xFFFFFFFFLL;
}

uint64_t re::remapSubdivisionSurfaceAttributes(re *this, re::GeomMesh *a2, uint64_t a3, const re::GeomIndexMap *a4)
{
  int v9 = (unsigned int *)a2;
  uint64_t v70 = *MEMORY[0x263EF8340];
  uint64_t result = re::meshHasSubdivCreases(this, a2);
  if (result)
  {
    uint64_t v55 = 0;
    v52[1] = 0;
    uint64_t v53 = 0;
    v52[0] = 0;
    int v54 = 0;
    re::DynamicArray<unsigned int>::resize(v52, v9[4], &re::kInvalidMeshIndex);
    uint64_t v51 = this;
    int v12 = *((_DWORD *)this + 4);
    if (v12)
    {
      uint64_t v13 = 0;
      while (1)
      {
        unsigned int v14 = re::GeomIndexMap::operator[](a3, v13);
        unint64_t v15 = v14;
        uint64_t v16 = (uint64_t)v53;
        if ((unint64_t)v53 <= v14) {
          break;
        }
        *(_DWORD *)(v55 + 4 * v14) = v13;
        uint64_t v13 = (v13 + 1);
        if (v12 == v13) {
          goto LABEL_6;
        }
      }
      uint64_t v56 = 0;
      long long v68 = 0u;
      long long v69 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v65 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v57 = 136315906;
      StringID v58 = "operator[]";
      __int16 v59 = 1024;
      int v60 = 789;
      __int16 v61 = 2048;
      uint64_t v62 = v15;
      __int16 v63 = 2048;
      uint64_t v64 = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_85;
    }
LABEL_6:
    unint64_t v4 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(v9 + 16), "osdEdgeCreaseWeights");
    uint64_t v50 = (re::internal::GeomAttributeManager *)(v9 + 16);
    uint64_t v17 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(v9 + 16), "osdEdgeCreaseIndices");
    if (v17)
    {
      int v9 = (unsigned int *)v17;
      int v18 = (*(uint64_t (**)(unint64_t))(*(void *)v4 + 16))(v4);
      if ((*(unsigned int (**)(unsigned int *))(*(void *)v9 + 16))(v9))
      {
        uint64_t v13 = re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)v9, 0);
        LODWORD(v9) = (*(uint64_t (**)(unsigned int *))(*(void *)v9 + 16))(v9);
      }
      else
      {
        LODWORD(v9) = 0;
        uint64_t v13 = 0;
      }
      uint64_t v16 = 0;
      if (v18)
      {
        unint64_t v15 = 0;
        a3 = (uint64_t)v53;
        int v19 = v18;
        while (v9 > v15)
        {
          unint64_t v5 = *(unsigned int *)(v13 + 4 * v15);
          if ((unint64_t)v53 <= v5) {
            goto LABEL_86;
          }
          unint64_t v15 = (v15 + 1);
          if (v9 <= v15) {
            goto LABEL_87;
          }
          unint64_t v6 = *(unsigned int *)(v13 + 4 * v15);
          if ((unint64_t)v53 <= v6) {
            goto LABEL_88;
          }
          if (*(_DWORD *)(v55 + 4 * v5) == -1 || *(_DWORD *)(v55 + 4 * v6) == -1) {
            uint64_t v16 = v16;
          }
          else {
            uint64_t v16 = (v16 + 1);
          }
          unint64_t v15 = (v15 + 1);
          if (!--v19) {
            goto LABEL_23;
          }
        }
LABEL_85:
        uint64_t v56 = 0;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v65 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v57 = 136315906;
        StringID v58 = "operator[]";
        __int16 v59 = 1024;
        int v60 = 601;
        __int16 v61 = 2048;
        uint64_t v62 = v15;
        __int16 v63 = 2048;
        uint64_t v64 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_86:
        uint64_t v56 = 0;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v65 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v57 = 136315906;
        StringID v58 = "operator[]";
        __int16 v59 = 1024;
        int v60 = 789;
        __int16 v61 = 2048;
        uint64_t v62 = v5;
        __int16 v63 = 2048;
        uint64_t v64 = a3;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_87:
        uint64_t v56 = 0;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v65 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v57 = 136315906;
        StringID v58 = "operator[]";
        __int16 v59 = 1024;
        int v60 = 601;
        __int16 v61 = 2048;
        uint64_t v62 = v15;
        __int16 v63 = 2048;
        uint64_t v64 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_88:
        uint64_t v56 = 0;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v65 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v57 = 136315906;
        StringID v58 = "operator[]";
        __int16 v59 = 1024;
        int v60 = 789;
        __int16 v61 = 2048;
        uint64_t v62 = v6;
        __int16 v63 = 2048;
        uint64_t v64 = a3;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_89;
      }
LABEL_23:
      uint64_t v21 = re::internal::GeomAttributeManager::attributeByName((re *)((char *)v51 + 64), "osdEdgeCreaseWeights");
      uint64_t v22 = re::internal::GeomAttributeManager::attributeByName((re *)((char *)v51 + 64), "osdEdgeCreaseIndices");
      (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 24))(v21, v16);
      (*(void (**)(uint64_t, void))(*(void *)v22 + 24))(v22, (2 * v16));
      if ((*(unsigned int (**)(unint64_t))(*(void *)v4 + 16))(v4))
      {
        uint64_t v23 = re::internal::GeomTypedAttribute<int>::operator[](v4, 0);
        unint64_t v4 = (*(uint64_t (**)(unint64_t))(*(void *)v4 + 16))(v4);
      }
      else
      {
        unint64_t v4 = 0;
        uint64_t v23 = 0;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v21 + 16))(v21))
      {
        uint64_t v24 = re::internal::GeomTypedAttribute<float>::operator[](v21, 0);
        unsigned int v25 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 16))(v21);
      }
      else
      {
        unsigned int v25 = 0;
        uint64_t v24 = 0;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22))
      {
        unint64_t v7 = re::internal::GeomTypedAttribute<float>::operator[](v22, 0);
        unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
      }
      else
      {
        unint64_t v5 = 0;
        unint64_t v7 = 0;
      }
      uint64_t v26 = v23;
      uint64_t v27 = v24;
      if (v18)
      {
        unsigned int v28 = v25;
        a3 = 0;
        int v29 = v18;
        unint64_t v30 = 0;
        LODWORD(v16) = 0;
        unint64_t v15 = (unint64_t)v53;
        uint64_t v31 = v55;
        unint64_t v32 = v4;
        while (v9 > a3)
        {
          unint64_t v6 = *(unsigned int *)(v13 + 4 * a3);
          if (v15 <= v6) {
            goto LABEL_92;
          }
          unint64_t v4 = (a3 + 1);
          if (v9 <= v4) {
            goto LABEL_93;
          }
          unint64_t v4 = *(unsigned int *)(v13 + 4 * v4);
          if (v15 <= v4) {
            goto LABEL_94;
          }
          int v33 = *(_DWORD *)(v31 + 4 * v6);
          int v34 = *(_DWORD *)(v31 + 4 * v4);
          if (v33 != -1 && v34 != -1)
          {
            if (v30 >= v32) {
              goto LABEL_100;
            }
            if (v28 <= v16) {
              goto LABEL_101;
            }
            *(_DWORD *)(v27 + 4 * v16) = *(_DWORD *)(v26 + 4 * v30);
            unint64_t v6 = (2 * v16);
            if (v5 <= 2 * (int)v16) {
              goto LABEL_102;
            }
            *(_DWORD *)(v7 + 4 * v6) = v33;
            unint64_t v6 = v6 | 1;
            if (v5 <= v6) {
              goto LABEL_103;
            }
            *(_DWORD *)(v7 + 4 * v6) = v34;
            LODWORD(v16) = v16 + 1;
          }
          ++v30;
          a3 = (a3 + 2);
          if (v29 == v30) {
            goto LABEL_48;
          }
        }
        goto LABEL_91;
      }
    }
LABEL_48:
    uint64_t v13 = re::internal::GeomAttributeManager::attributeByName(v50, "osdVertexCreaseWeights");
    uint64_t v36 = re::internal::GeomAttributeManager::attributeByName(v50, "osdVertexCreaseIndices");
    if (v36)
    {
      unint64_t v15 = v36;
      unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
      if ((*(unsigned int (**)(unint64_t))(*(void *)v15 + 16))(v15))
      {
        int v9 = (unsigned int *)re::internal::GeomTypedAttribute<int>::operator[](v15, 0);
        unint64_t v5 = (*(unsigned int (**)(unint64_t))(*(void *)v15 + 16))(v15);
        if (v6) {
          goto LABEL_51;
        }
      }
      else
      {
        unint64_t v5 = 0;
        int v9 = 0;
        if (v6)
        {
LABEL_51:
          float32x4_t v37 = 0;
          LODWORD(v16) = 0;
          a3 = (uint64_t)v53;
          while ((const re::GeomMesh *)v5 != v37)
          {
            unint64_t v15 = v9[(void)v37];
            if ((unint64_t)v53 <= v15) {
              goto LABEL_90;
            }
            if (*(_DWORD *)(v55 + 4 * v15) == -1) {
              uint64_t v16 = v16;
            }
            else {
              uint64_t v16 = (v16 + 1);
            }
            float32x4_t v37 = (const re::GeomMesh *)((char *)v37 + 1);
            if ((const re::GeomMesh *)v6 == v37) {
              goto LABEL_61;
            }
          }
LABEL_89:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 601;
          __int16 v61 = 2048;
          uint64_t v62 = v5;
          __int16 v63 = 2048;
          uint64_t v64 = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_90:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 789;
          __int16 v61 = 2048;
          uint64_t v62 = v15;
          __int16 v63 = 2048;
          uint64_t v64 = a3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_91:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 601;
          __int16 v61 = 2048;
          uint64_t v62 = a3;
          __int16 v63 = 2048;
          uint64_t v64 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_92:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 789;
          __int16 v61 = 2048;
          uint64_t v62 = v6;
          __int16 v63 = 2048;
          uint64_t v64 = v15;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_93:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 601;
          __int16 v61 = 2048;
          uint64_t v62 = v4;
          __int16 v63 = 2048;
          uint64_t v64 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_94:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 789;
          __int16 v61 = 2048;
          uint64_t v62 = v4;
          __int16 v63 = 2048;
          uint64_t v64 = v15;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_95:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 601;
          __int16 v61 = 2048;
          uint64_t v62 = v5;
          __int16 v63 = 2048;
          uint64_t v64 = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_96:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 789;
          __int16 v61 = 2048;
          uint64_t v62 = v6;
          __int16 v63 = 2048;
          uint64_t v64 = v7;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_97:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          unint64_t v47 = v42;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 601;
          __int16 v61 = 2048;
          uint64_t v62 = a3;
          __int16 v63 = 2048;
          uint64_t v64 = v47;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_98:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 609;
          __int16 v61 = 2048;
          uint64_t v62 = v6;
          __int16 v63 = 2048;
          uint64_t v64 = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_99:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          unint64_t v30 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 609;
          __int16 v61 = 2048;
          uint64_t v62 = v6;
          __int16 v63 = 2048;
          uint64_t v64 = v15;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_100:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          uint64_t v48 = v32;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 601;
          __int16 v61 = 2048;
          uint64_t v62 = v30;
          __int16 v63 = 2048;
          uint64_t v64 = v48;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_101:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          unsigned int v49 = v28;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 609;
          __int16 v61 = 2048;
          uint64_t v62 = v16;
          __int16 v63 = 2048;
          uint64_t v64 = v49;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_102:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 609;
          __int16 v61 = 2048;
          uint64_t v62 = v6;
          __int16 v63 = 2048;
          uint64_t v64 = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_103:
          uint64_t v56 = 0;
          long long v68 = 0u;
          long long v69 = 0u;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v65 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v57 = 136315906;
          StringID v58 = "operator[]";
          __int16 v59 = 1024;
          int v60 = 609;
          __int16 v61 = 2048;
          uint64_t v62 = v6;
          __int16 v63 = 2048;
          uint64_t v64 = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
      uint64_t v16 = 0;
LABEL_61:
      uint64_t v38 = re::internal::GeomAttributeManager::attributeByName((re *)((char *)v51 + 64), "osdVertexCreaseWeights");
      unint64_t v15 = re::internal::GeomAttributeManager::attributeByName((re *)((char *)v51 + 64), "osdVertexCreaseIndices");
      (*(void (**)(uint64_t, uint64_t))(*(void *)v38 + 24))(v38, v16);
      (*(void (**)(unint64_t, uint64_t))(*(void *)v15 + 24))(v15, v16);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v13 + 16))(v13))
      {
        uint64_t v39 = re::internal::GeomTypedAttribute<int>::operator[](v13, 0);
        unint64_t v40 = (*(unsigned int (**)(uint64_t))(*(void *)v13 + 16))(v13);
      }
      else
      {
        unint64_t v40 = 0;
        uint64_t v39 = 0;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v38 + 16))(v38))
      {
        uint64_t v16 = re::internal::GeomTypedAttribute<float>::operator[](v38, 0);
        LODWORD(v13) = (*(uint64_t (**)(uint64_t))(*(void *)v38 + 16))(v38);
      }
      else
      {
        LODWORD(v13) = 0;
        uint64_t v16 = 0;
      }
      if ((*(unsigned int (**)(unint64_t))(*(void *)v15 + 16))(v15))
      {
        uint64_t v41 = re::internal::GeomTypedAttribute<float>::operator[](v15, 0);
        LODWORD(v15) = (*(uint64_t (**)(unint64_t))(*(void *)v15 + 16))(v15);
      }
      else
      {
        LODWORD(v15) = 0;
        uint64_t v41 = 0;
      }
      unint64_t v42 = v40;
      if (v6)
      {
        a3 = 0;
        unsigned int v43 = 0;
        unint64_t v7 = (unint64_t)v53;
        uint64_t v44 = v55;
        unint64_t v45 = v6;
        while (v5 != a3)
        {
          unint64_t v6 = v9[a3];
          if (v7 <= v6) {
            goto LABEL_96;
          }
          int v46 = *(_DWORD *)(v44 + 4 * v6);
          if (v46 != -1)
          {
            if (v42 <= a3) {
              goto LABEL_97;
            }
            unint64_t v6 = v43;
            if (v13 <= v43) {
              goto LABEL_98;
            }
            *(_DWORD *)(v16 + 4 * v43) = *(_DWORD *)(v39 + 4 * a3);
            if (v15 <= v43) {
              goto LABEL_99;
            }
            *(_DWORD *)(v41 + 4 * v43++) = v46;
          }
          if (v45 == ++a3) {
            goto LABEL_80;
          }
        }
        goto LABEL_95;
      }
    }
LABEL_80:
    uint64_t result = v52[0];
    if (v52[0])
    {
      if (v55) {
        return (*(uint64_t (**)(void))(*(void *)v52[0] + 40))();
      }
    }
  }
  return result;
}

uint64_t re::GeomIndexMap::operator[](uint64_t a1, uint64_t a2)
{
  unsigned int v6 = a2;
  int v3 = *(unsigned __int8 *)(a1 + 12);
  if (v3 == 2)
  {
    uint64_t v5 = re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::find((void *)(a1 + 16), &v6);
    if (v5 != -1) {
      return *(unsigned int *)(*(void *)(a1 + 24) + 8 * v5 + 4);
    }
    return 0xFFFFFFFFLL;
  }
  if (v3 == 1)
  {
    if (*(void *)(a1 + 32) > (unint64_t)a2) {
      return *(unsigned int *)(*(void *)(a1 + 48) + 4 * a2);
    }
    return 0xFFFFFFFFLL;
  }
  if (*(unsigned char *)(a1 + 12))
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "value", 680);
    uint64_t result = _os_crash();
    __break(1u);
  }
  else if (*(_DWORD *)(a1 + 16) <= a2)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return a2;
  }
  return result;
}

uint64_t re::remapSkinningAttributes(re *this, re::GeomMesh *a2, const re::GeomMesh *a3, const re::GeomIndexMap *a4)
{
  unsigned int v6 = (re::GeomMesh *)((char *)a2 + 64);
  uint64_t v7 = re::internal::GeomAttributeManager::attributeByName((re::GeomMesh *)((char *)a2 + 64), "skinnedAnimationWeights");
  uint64_t v8 = re::internal::GeomAttributeManager::attributeByName(v6, "skinnedAnimationJointIndices");
  uint64_t result = re::internal::GeomAttributeManager::attributeByName(v6, "skinnedAnimationInfluenceEndIndices");
  if (v7)
  {
    if (v8)
    {
      uint64_t v10 = result;
      if (result)
      {
        uint64_t v11 = re::internal::GeomAttributeManager::attributeByName((re *)((char *)this + 64), "skinnedAnimationWeights");
        uint64_t v12 = re::internal::GeomAttributeManager::attributeByName((re *)((char *)this + 64), "skinnedAnimationJointIndices");
        uint64_t v38 = re::internal::GeomAttributeManager::attributeByName((re *)((char *)this + 64), "skinnedAnimationInfluenceEndIndices");
        if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 16))(v7))
        {
          uint64_t v42 = re::internal::GeomTypedAttribute<int>::operator[](v7, 0);
          unsigned int v45 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
        }
        else
        {
          unsigned int v45 = 0;
          uint64_t v42 = 0;
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 16))(v8))
        {
          uint64_t v41 = re::internal::GeomTypedAttribute<int>::operator[](v8, 0);
          unsigned int v46 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
        }
        else
        {
          unsigned int v46 = 0;
          uint64_t v41 = 0;
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 16))(v10))
        {
          uint64_t v13 = re::internal::GeomTypedAttribute<int>::operator[](v10, 0);
          unsigned int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
        }
        else
        {
          unsigned int v14 = 0;
          uint64_t v13 = 0;
        }
        uint64_t v15 = *((unsigned int *)this + 4);
        if (v15)
        {
          uint64_t v16 = 0;
          LODWORD(v17) = 0;
          do
          {
            unsigned int v18 = re::GeomIndexMap::operator[]((uint64_t)a3, v16);
            if (v18)
            {
              if (v14 <= v18 - 1) {
                goto LABEL_67;
              }
              int v19 = *(_DWORD *)(v13 + 4 * (v18 - 1));
            }
            else
            {
              int v19 = 0;
            }
            if (v14 <= v18) {
              goto LABEL_66;
            }
            uint64_t v17 = (*(_DWORD *)(v13 + 4 * v18) + v17 - v19);
            uint64_t v16 = (v16 + 1);
          }
          while (v15 != v16);
        }
        else
        {
          uint64_t v17 = 0;
        }
        (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 24))(v11, v17);
        (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 24))(v12, v17);
        (*(void (**)(uint64_t, uint64_t))(*(void *)v38 + 24))(v38, v15);
        if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 16))(v11))
        {
          uint64_t v40 = re::internal::GeomTypedAttribute<float>::operator[](v11, 0);
          unsigned int v43 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
        }
        else
        {
          unsigned int v43 = 0;
          uint64_t v40 = 0;
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 16))(v12))
        {
          uint64_t v39 = re::internal::GeomTypedAttribute<float>::operator[](v12, 0);
          unsigned int v44 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
        }
        else
        {
          unsigned int v44 = 0;
          uint64_t v39 = 0;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v38 + 16))(v38);
        if (result)
        {
          uint64_t v20 = re::internal::GeomTypedAttribute<float>::operator[](v38, 0);
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v38 + 16))(v38);
          uint64_t v21 = result;
          if (!v15) {
            return result;
          }
        }
        else
        {
          uint64_t v21 = 0;
          uint64_t v20 = 0;
          if (!v15) {
            return result;
          }
        }
        uint64_t v22 = 0;
        LODWORD(v23) = 0;
        do
        {
          uint64_t result = re::GeomIndexMap::operator[]((uint64_t)a3, v22);
          if (result)
          {
            if (v14 <= (int)result - 1) {
              goto LABEL_70;
            }
            unsigned int v24 = *(_DWORD *)(v13 + 4 * (result - 1));
          }
          else
          {
            unsigned int v24 = 0;
          }
          if (v14 <= result) {
            goto LABEL_68;
          }
          unsigned int v25 = *(_DWORD *)(v13 + 4 * result);
          unsigned int v26 = v25 - v24;
          if (v25 <= v24) {
            goto LABEL_59;
          }
          uint64_t v27 = v21;
          uint64_t v28 = 0;
          uint64_t v29 = v23;
          if (v24 <= v46) {
            uint64_t v30 = v46;
          }
          else {
            uint64_t v30 = v24;
          }
          uint64_t v31 = v40 + 4 * v23;
          if (v23 <= v44) {
            uint64_t v32 = v44;
          }
          else {
            uint64_t v32 = v23;
          }
          uint64_t v33 = v39 + 4 * v23;
          if (v24 <= v45) {
            uint64_t v34 = v45;
          }
          else {
            uint64_t v34 = v24;
          }
          uint64_t v35 = v42 + 4 * v24;
          if (v23 <= v43) {
            uint64_t v23 = v43;
          }
          else {
            uint64_t v23 = v23;
          }
          uint64_t v36 = v41 + 4 * v24;
          uint64_t result = v34 - v24;
          uint64_t v37 = v30 - v24;
          do
          {
            if (v37 == v28)
            {
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_63:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_64:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_65:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_66:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_67:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_68:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_69:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_70:
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            if (!(v29 - v32 + v28)) {
              goto LABEL_63;
            }
            *(_DWORD *)(v33 + 4 * v28) = *(_DWORD *)(v36 + 4 * v28);
            if (result == v28) {
              goto LABEL_64;
            }
            if (!(v29 - v23 + v28)) {
              goto LABEL_65;
            }
            *(_DWORD *)(v31 + 4 * v28) = *(_DWORD *)(v35 + 4 * v28);
            ++v28;
          }
          while (v26 != v28);
          LODWORD(v23) = v29 + v28;
          uint64_t v21 = v27;
LABEL_59:
          if (v22 == v21) {
            goto LABEL_69;
          }
          *(_DWORD *)(v20 + 4 * v22++) = v23;
        }
        while (v22 != v15);
      }
    }
  }
  return result;
}

void re::makeConditionedMeshForGPU(unsigned int *a1@<X0>, unint64_t a2@<X1>, unsigned int *a3@<X2>, const re::GeomIndexMap *a4@<X3>, uint64_t a5@<X4>, unsigned char *a6@<X8>)
{
  uint64_t v309 = *MEMORY[0x263EF8340];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v231, 4510, a1[4]);
  re::GeomMesh::copy((re::GeomMesh *)a1, (re::GeomMesh *)a3);
  unsigned int v13 = 0;
  unsigned int v14 = a1[4];
  *(void *)long long buf = 0xFFFFFFFF00000000;
  *(_DWORD *)&uint8_t buf[8] = -1;
  unsigned char buf[12] = 0;
  if (v14 - 1 <= 0xFFFFFFFD)
  {
    *(_DWORD *)&uint8_t buf[8] = v14 - 1;
    unsigned int v13 = v14;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_DWORD *)long long buf = v14;
  }
  LODWORD(v242) = v13;
  re::GeomIndexMap::operator=((uint64_t)a4, (uint64_t)buf);
  if (!buf[12]) {
    goto LABEL_14;
  }
  if (buf[12] == 2)
  {
    uint64_t v16 = v246;
    if (!v246) {
      goto LABEL_14;
    }
    if (*((void *)&v242 + 1)) {
      *((void *)&v242 + 1) = 0;
    }
    if (!(void)v242) {
      goto LABEL_14;
    }
LABEL_13:
    (*(void (**)(uint64_t))(*(void *)v16 + 40))(v16);
    goto LABEL_14;
  }
  if (buf[12] != 1)
  {
    re::internal::assertLog((re::internal *)4, v15, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
    _os_crash();
    __break(1u);
    goto LABEL_545;
  }
  uint64_t v16 = v242;
  if ((void)v242 && v244[0]) {
    goto LABEL_13;
  }
LABEL_14:
  unsigned int v17 = 0;
  unsigned int v18 = a1[10];
  *(void *)long long buf = 0xFFFFFFFF00000000;
  *(_DWORD *)&uint8_t buf[8] = -1;
  unsigned char buf[12] = 0;
  if (v18 - 1 <= 0xFFFFFFFD)
  {
    *(_DWORD *)&uint8_t buf[8] = v18 - 1;
    unsigned int v17 = v18;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_DWORD *)long long buf = v18;
  }
  uint64_t v225 = a1;
  LODWORD(v242) = v17;
  re::GeomIndexMap::operator=(a5, (uint64_t)buf);
  if (buf[12])
  {
    if (buf[12] != 2)
    {
      if (buf[12] == 1)
      {
        uint64_t v20 = v242;
        if (!(void)v242) {
          goto LABEL_27;
        }
        int v19 = (const re::GeomMesh *)v244[0];
        if (!v244[0]) {
          goto LABEL_27;
        }
LABEL_26:
        (*(void (**)(uint64_t))(*(void *)v20 + 40))(v20);
        goto LABEL_27;
      }
LABEL_545:
      re::internal::assertLog((re::internal *)4, (uint64_t)v19, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
      _os_crash();
      __break(1u);
      goto LABEL_546;
    }
    uint64_t v20 = v246;
    if (v246)
    {
      if (*((void *)&v242 + 1)) {
        *((void *)&v242 + 1) = 0;
      }
      int v19 = (const re::GeomMesh *)v242;
      if ((void)v242) {
        goto LABEL_26;
      }
    }
  }
LABEL_27:
  unint64_t v223 = (re::GeomIndexMap *)a5;
  unint64_t v230 = a2;
  if (*(unsigned char *)(a2 + 4))
  {
    unsigned int v21 = a3[106];
    if (v21)
    {
      for (unsigned int i = 0; i != v21; ++i)
      {
        uint64_t v23 = re::internal::GeomAttributeContainer::attributeByIndex((re::internal::GeomAttributeContainer *)(a3 + 100), i);
        unsigned int v26 = *(unsigned __int8 *)(v23 + 17);
        if (v26 > 0xA) {
          goto LABEL_543;
        }
        if (((1 << v26) & 0x60F) != 0) {
          re::mergeDiscreteFaceVaryingAttributeValues((re *)a3, *(re::GeomMesh **)(v23 + 8), v25);
        }
        else {
          re::mergeContinuousFaceVaryingAttributeValues((re *)a3, *(re::GeomMesh **)(v23 + 8), v25, 0.00000999999975);
        }
      }
    }
  }
  unint64_t v27 = (unint64_t)v225;
  unsigned int v28 = v225[4];
  unsigned int v29 = v225[10];
  BOOL HasSkinningData = re::meshHasSkinningData((re *)a3, v19);
  unint64_t v30 = v230;
  if (*(unsigned char *)(v230 + 3) && (float)((float)v28 / (float)v29) > 1.2)
  {
    *(_DWORD *)((char *)v306 + 1) = 257;
    *(_OWORD *)&v306[1] = xmmword_23440A7C0;
    LODWORD(v306[3]) = 981668463;
    v306[4] = 0;
    LOBYTE(v306[0]) = 0;
    if (HasSkinningData)
    {
      uint64_t v31 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "skinnedAnimationWeights");
      if ((*(unsigned int (**)(uint64_t))(*(void *)v31 + 16))(v31))
      {
        uint64_t v32 = re::internal::GeomTypedAttribute<int>::operator[](v31, 0);
        int v33 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 16))(v31);
      }
      else
      {
        int v33 = 0;
        uint64_t v32 = 0;
      }
      uint64_t v34 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "skinnedAnimationJointIndices");
      if ((*(unsigned int (**)(uint64_t))(*(void *)v34 + 16))(v34))
      {
        uint64_t v35 = re::internal::GeomTypedAttribute<int>::operator[](v34, 0);
        int v36 = (*(uint64_t (**)(uint64_t))(*(void *)v34 + 16))(v34);
      }
      else
      {
        int v36 = 0;
        uint64_t v35 = 0;
      }
      uint64_t v37 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "skinnedAnimationInfluenceEndIndices");
      if ((*(unsigned int (**)(uint64_t))(*(void *)v37 + 16))(v37))
      {
        uint64_t v38 = re::internal::GeomTypedAttribute<int>::operator[](v37, 0);
        unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v37 + 16))(v37);
      }
      else
      {
        unint64_t v6 = 0;
        uint64_t v38 = 0;
      }
      uint64_t v39 = operator new(0x38uLL);
      *uint64_t v39 = &unk_26E715770;
      v39[1] = v32;
      *((_DWORD *)v39 + 4) = v33;
      void v39[3] = v35;
      *((_DWORD *)v39 + 8) = v36;
      v39[5] = v38;
      *((_DWORD *)v39 + 12) = v6;
      *(void *)&v288[24] = v39;
      v306[4] = v288;
      re::GeomMesh::GeomMesh((re::GeomMesh *)buf, 0);
      if (re::mergeVertices((unint64_t)a3, (unsigned int *)buf, (uint64_t)a4, (uint64_t)v306)) {
        re::GeomMesh::operator=((re::GeomMesh *)a3, (re::GeomMesh *)buf);
      }
      re::GeomMesh::~GeomMesh((re::GeomMesh *)buf);
      unint64_t v30 = v230;
      if (*(unsigned char **)&v288[24] == v288)
      {
        (*(void (**)(unsigned char *))(*(void *)v288 + 32))(v288);
      }
      else if (*(void *)&v288[24])
      {
        (*(void (**)(void))(**(void **)&v288[24] + 40))();
      }
    }
    else
    {
      re::mergeVertices((unint64_t)a3, a3, (uint64_t)a4, (uint64_t)v306);
    }
  }
  uint64_t v40 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "vertexNormal");
  if (!v40 || *(unsigned char *)(v40 + 17) != 7) {
    goto LABEL_65;
  }
  uint64_t v41 = (unsigned __int8 *)re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "vertexNormal");
  int v42 = v41[16];
  if (v42 == 4) {
    goto LABEL_59;
  }
  if (v42 == 2)
  {
    if (*(unsigned char *)(v30 + 7))
    {
      re::internal::GeomBaseMesh::replaceFaceAttributeWithFaceVaryingAttribute((re::internal::GeomBaseMesh *)(a3 + 4), "vertexNormal");
    }
    else
    {
      re::internal::GeomAttributeManager::deleteAttribute((re::internal::GeomAttributeManager *)(a3 + 16), "vertexNormal");
      re::computeSmoothFaceVaryingNormals((re *)a3, v44, 0.7854);
    }
  }
  else if (!v41[16])
  {
LABEL_59:
    unsigned int v43 = *re::pipelineLogObjects((re *)v41);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_233120000, v43, OS_LOG_TYPE_DEFAULT, "Recalculating normals defined at an unsupported rate.", buf, 2u);
    }
    re::internal::GeomAttributeManager::deleteAttribute((re::internal::GeomAttributeManager *)(a3 + 16), "vertexNormal");
  }
LABEL_65:
  uint64_t v45 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "vertexNormal");
  if (!v45 || *(unsigned char *)(v45 + 17) != 7)
  {
    if (*(unsigned char *)(v30 + 5)) {
      re::computeSmoothFaceVaryingNormals((re *)a3, v46, 0.7854);
    }
    else {
      re::computeSmoothVertexNormals((re *)a3, v46);
    }
  }
  uint64_t v47 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "vertexTangent");
  if (!v47
    || *(unsigned char *)(v47 + 17) != 7
    || (uint64_t v48 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "vertexBitangent")) == 0|| *(unsigned char *)(v48 + 17) != 7)
  {
    if (re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(v225 + 16), "vertexUV"))
    {
      uint64_t v50 = (unsigned __int8 *)re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(v225 + 16), "vertexUV");
      if ((v50[16] | 2) == 3)
      {
        uint8_t buf[4] = 1;
        *(_DWORD *)long long buf = 1;
        re::computeTangentsAndBitangents(a3, "vertexUV", "vertexTangent", "vertexBitangent", "vertexNormal", (unint64_t)buf);
      }
      else
      {
        StringID v58 = *re::pipelineLogObjects((re *)v50);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_233120000, v58, OS_LOG_TYPE_DEFAULT, "Cannot generate tangents+bitangents on mesh without vertex or face-varying rate uvs.", buf, 2u);
        }
      }
    }
  }
  if (*(unsigned char *)(v30 + 2))
  {
    uint64_t v51 = (unsigned __int8 *)re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "vertexNormal");
    unsigned int v52 = (unsigned __int8 *)re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "vertexTangent");
    uint64_t v53 = (unsigned __int8 *)re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a3 + 16), "vertexBitangent");
    if (v51)
    {
      if (v52)
      {
        if (v53)
        {
          if (v51[17] == 7 && v52[17] == 7 && v53[17] == 7)
          {
            int v55 = v51[16];
            if ((v55 & 0xFFFFFFFD) == 1)
            {
              int v56 = v52[16];
              if ((v56 & 0xFFFFFFFD) == 1)
              {
                int v57 = v53[16];
                if ((v57 & 0xFFFFFFFD) == 1)
                {
                  if (v55 == 1 && v56 == 1 && v57 == 1) {
                    re::repairTangentsAndBitangentsAllVertexRateInternal((re *)a3, (re::GeomMesh *)v51, (re::GeomAttribute *)v52, (re::GeomAttribute *)v53, v54);
                  }
                  else {
                    re::repairTangentsAndBitangentsSlowInternal((re *)a3, (re::GeomMesh *)v51, (re::GeomAttribute *)v52, (re::GeomAttribute *)v53, v54);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  long long v221 = (re::internal::GeomAttributeManager *)(a3 + 16);
  if (a3[2] != a3[10]) {
  BOOL v59 = re::meshHasSkinningData((re *)a3, v49);
  }
  unint64_t v61 = 1;
  if (!v59 && !*(unsigned char *)v30) {
    unint64_t v61 = *(unsigned char *)(v30 + 9) != 0;
  }
  unint64_t v62 = (unint64_t)buf;
  char v226 = (re::GeomMesh *)a3;
  unsigned int v220 = v61;
  if (!*(unsigned char *)(v30 + 8)) {
    goto LABEL_259;
  }
  BOOL v215 = v59;
  *(void *)&v294[2] = 0;
  memset(v292, 0, sizeof(v292));
  uint64_t v239 = 0;
  v236[1] = 0;
  unint64_t v237 = 0;
  uint64_t v235 = 0;
  v236[0] = 0;
  int v238 = 0;
  v232[1] = 0;
  uint64_t v233 = 0;
  v232[0] = 0;
  int v234 = 0;
  re::GeomConnectivityManifold::GeomConnectivityManifold((re::GeomConnectivityManifold *)buf);
  uint64_t v272 = 0;
  uint64_t v271 = 0;
  int v274 = 0;
  unint64_t v273 = 0;
  uint64_t v287 = 0;
  long long v275 = 0u;
  long long v276 = 0u;
  int v277 = 0;
  long long v278 = 0u;
  long long v279 = 0u;
  int v280 = 0;
  long long v281 = 0u;
  long long v282 = 0u;
  int v283 = 0;
  long long v284 = 0u;
  long long v285 = 0u;
  int v286 = 0;
  if (!re::GeomConnectivityManifold::buildIfManifold((unint64_t)a3, (unint64_t)buf, v63)) {
    goto LABEL_147;
  }
  uint64_t v64 = re::GeomMesh::accessVertexPositions((re::GeomMesh *)a3);
  unint64_t v66 = v65;
  re::DynamicArray<re::Vector3<float>>::resize((uint64_t)&v284 + 8, v65);
  if (v66)
  {
    unint64_t v27 = 0;
    do
    {
      unint64_t v30 = *((void *)&v285 + 1);
      if (*((void *)&v285 + 1) <= v27) {
        goto LABEL_515;
      }
      *(void *)&long long v67 = *(void *)v64;
      DWORD2(v67) = *(_DWORD *)(v64 + 8);
      *(_OWORD *)(v287 + 16 * v27++) = v67;
      v64 += 16;
    }
    while (v66 != v27);
  }
  long long v68 = (_DWORD *)DWORD2(v242);
  re::DynamicArray<float>::resize((uint64_t)&v271, DWORD2(v242));
  if (v68)
  {
    long long v69 = 0;
    unint64_t v27 = *((void *)&v242 + 1);
    uint64_t v70 = (unsigned char *)*((void *)&v285 + 1);
    uint64_t v71 = v287;
    unint64_t v30 = v273;
    uint64_t v72 = v275;
    int v73 = (unsigned int *)(v243 + 4);
    while ((_DWORD *)v27 != v69)
    {
      unint64_t v61 = *(v73 - 1);
      if ((unint64_t)v70 <= v61) {
        goto LABEL_519;
      }
      unint64_t v62 = *v73;
      if ((unint64_t)v70 <= v62) {
        goto LABEL_520;
      }
      unint64_t v6 = v73[1];
      if ((unint64_t)v70 <= v6) {
        goto LABEL_521;
      }
      if ((_DWORD *)v30 == v69) {
        goto LABEL_522;
      }
      float32x4_t v74 = *(float32x4_t *)(v71 + 16 * v61);
      float32x4_t v75 = vsubq_f32(*(float32x4_t *)(v71 + 16 * v62), v74);
      float32x4_t v76 = vsubq_f32(*(float32x4_t *)(v71 + 16 * v6), v74);
      float32x4_t v77 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v76, (int32x4_t)v76), (int8x16_t)v76, 0xCuLL), vnegq_f32(v75)), v76, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v75, (int32x4_t)v75), (int8x16_t)v75, 0xCuLL));
      float32x4_t v78 = vmulq_f32(v77, v77);
      *(float *)(v72 + 4 * (void)v69) = sqrtf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v78.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v78, 2), v78)).f32[0])* 0.5;
      long long v69 = (_DWORD *)((char *)v69 + 1);
      v73 += 4;
      if (v68 == v69) {
        goto LABEL_113;
      }
    }
LABEL_518:
    *(void *)float32x2_t v303 = 0;
    uint64_t v70 = v288;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int32x2_t v288 = 136315906;
    *(void *)&v288[4] = "operator[]";
    *(_WORD *)&v288[12] = 1024;
    *(_DWORD *)&v288[14] = 797;
    *(_WORD *)&v288[18] = 2048;
    *(void *)&v288[20] = v27;
    *(_WORD *)&v288[28] = 2048;
    *(void *)&v288[30] = v27;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_519:
    *(void *)float32x2_t v303 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int32x2_t v288 = 136315906;
    *(void *)&v288[4] = "operator[]";
    *(_WORD *)&v288[12] = 1024;
    *(_DWORD *)&v288[14] = 789;
    *(_WORD *)&v288[18] = 2048;
    *(void *)&v288[20] = v61;
    *(_WORD *)&v288[28] = 2048;
    *(void *)&v288[30] = v70;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_520:
    *(void *)float32x2_t v303 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int32x2_t v288 = 136315906;
    *(void *)&v288[4] = "operator[]";
    *(_WORD *)&v288[12] = 1024;
    *(_DWORD *)&v288[14] = 789;
    *(_WORD *)&v288[18] = 2048;
    *(void *)&v288[20] = v62;
    *(_WORD *)&v288[28] = 2048;
    *(void *)&v288[30] = v70;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_521:
    *(void *)float32x2_t v303 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int32x2_t v288 = 136315906;
    *(void *)&v288[4] = "operator[]";
    *(_WORD *)&v288[12] = 1024;
    *(_DWORD *)&v288[14] = 789;
    *(_WORD *)&v288[18] = 2048;
    *(void *)&v288[20] = v6;
    *(_WORD *)&v288[28] = 2048;
    *(void *)&v288[30] = v70;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_522:
    *(void *)float32x2_t v303 = 0;
    unint64_t v114 = (unint64_t)v288;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int32x2_t v288 = 136315906;
    *(void *)&v288[4] = "operator[]";
    *(_WORD *)&v288[12] = 1024;
    *(_DWORD *)&v288[14] = 789;
    *(_WORD *)&v288[18] = 2048;
    *(void *)&v288[20] = v30;
    *(_WORD *)&v288[28] = 2048;
    *(void *)&v288[30] = v30;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_523;
  }
LABEL_113:
  uint64_t v79 = *(unsigned int *)buf;
  LODWORD(v306[0]) = 0;
  re::DynamicArray<float>::resize((void *)&v275 + 1, *(unsigned int *)buf, v306);
  *(void *)&v288[32] = 0;
  memset(v288, 0, 28);
  if (!v79) {
    goto LABEL_127;
  }
  for (unint64_t j = 0; j != v79; ++j)
  {
    re::GeomConnectivityManifold::fetchVertexIncidentFaces((re::GeomConnectivityManifold *)buf, j, (_anonymous_namespace_ *)v288);
    uint64_t v81 = *(void *)&v288[32];
    if (*(void *)&v288[16])
    {
      unint64_t v61 = v273;
      uint64_t v82 = v275;
      uint64_t v83 = 4 * *(void *)&v288[16];
      uint64_t v84 = *(unsigned int **)&v288[32];
      unint64_t v30 = *((void *)&v276 + 1);
      uint64_t v85 = v278;
      while (1)
      {
        unint64_t v62 = *v84;
        if (v61 <= v62) {
          break;
        }
        if (v30 <= j) {
          goto LABEL_273;
        }
        *(float *)(v85 + 4 * j) = *(float *)(v82 + 4 * v62) + *(float *)(v85 + 4 * j);
        ++v84;
        v83 -= 4;
        if (!v83) {
          goto LABEL_122;
        }
      }
      *(void *)float v296 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      unint64_t j = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float32x2_t v303 = 136315906;
      *(void *)&v303[4] = "operator[]";
      *(_WORD *)&v303[12] = 1024;
      *(_DWORD *)&v303[14] = 789;
      *(_WORD *)&v303[18] = 2048;
      *(void *)&v303[20] = v62;
      __int16 v304 = 2048;
      *(void *)float32x2_t v305 = v61;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_273:
      *(void *)float v296 = 0;
      unint64_t v106 = (unint64_t)v288;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float32x2_t v303 = 136315906;
      *(void *)&v303[4] = "operator[]";
      *(_WORD *)&v303[12] = 1024;
      *(_DWORD *)&v303[14] = 789;
      *(_WORD *)&v303[18] = 2048;
      *(void *)&v303[20] = j;
      __int16 v304 = 2048;
      *(void *)float32x2_t v305 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_274:
      uint64_t v240 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v296[0] = 136315906;
      *(void *)&v296[1] = "operator[]";
      __int16 v297 = 1024;
      int v298 = 789;
      __int16 v299 = 2048;
      float32x2_t v300 = (unsigned char *)v106;
      __int16 v301 = 2048;
      unint64_t v302 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_275:
      uint64_t v240 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v296[0] = 136315906;
      *(void *)&v296[1] = "operator[]";
      __int16 v297 = 1024;
      int v298 = 789;
      __int16 v299 = 2048;
      float32x2_t v300 = (unsigned char *)v62;
      __int16 v301 = 2048;
      unint64_t v302 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_276:
      uint64_t v240 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v296[0] = 136315906;
      *(void *)&v296[1] = "operator[]";
      __int16 v297 = 1024;
      int v298 = 789;
      __int16 v299 = 2048;
      float32x2_t v300 = (unsigned char *)v106;
      __int16 v301 = 2048;
      unint64_t v302 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_277:
      uint64_t v240 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v296[0] = 136315906;
      *(void *)&v296[1] = "operator[]";
      __int16 v297 = 1024;
      int v298 = 797;
      __int16 v299 = 2048;
      float32x2_t v300 = (unsigned char *)v7;
      __int16 v301 = 2048;
      unint64_t v302 = v61;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_278:
      uint64_t v240 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      v296[0] = 136315906;
      *(void *)&v296[1] = "operator[]";
      __int16 v297 = 1024;
      int v298 = 789;
      __int16 v299 = 2048;
      float32x2_t v300 = (unsigned char *)(v106 + 1);
      __int16 v301 = 2048;
      unint64_t v302 = v61;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_279:
      *(void *)float v296 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float32x2_t v303 = 136315906;
      *(void *)&v303[4] = "operator[]";
      *(_WORD *)&v303[12] = 1024;
      *(_DWORD *)&v303[14] = 789;
      *(_WORD *)&v303[18] = 2048;
      *(void *)&v303[20] = v106;
      __int16 v304 = 2048;
      *(void *)float32x2_t v305 = v61;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_280:
      *(void *)float v296 = 0;
      id v89 = v288;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float32x2_t v303 = 136315906;
      *(void *)&v303[4] = "operator[]";
      *(_WORD *)&v303[12] = 1024;
      *(_DWORD *)&v303[14] = 789;
      *(_WORD *)&v303[18] = 2048;
      *(void *)&v303[20] = v106;
      __int16 v304 = 2048;
      *(void *)float32x2_t v305 = v61;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_281:
      uint64_t v240 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int32x2_t v288 = 136315906;
      *(void *)&v288[4] = "operator[]";
      *(_WORD *)&v288[12] = 1024;
      *(_DWORD *)&v288[14] = 789;
      *(_WORD *)&v288[18] = 2048;
      *(void *)&v288[20] = v7;
      *(_WORD *)&v288[28] = 2048;
      *(void *)&v288[30] = v89;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_282:
      uint64_t v240 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int32x2_t v288 = 136315906;
      *(void *)&v288[4] = "operator[]";
      *(_WORD *)&v288[12] = 1024;
      *(_DWORD *)&v288[14] = 789;
      *(_WORD *)&v288[18] = 2048;
      *(void *)&v288[20] = v62;
      *(_WORD *)&v288[28] = 2048;
      *(void *)&v288[30] = v89;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_283:
      uint64_t v240 = 0;
      unint64_t v27 = (unint64_t)v288;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int32x2_t v288 = 136315906;
      *(void *)&v288[4] = "operator[]";
      *(_WORD *)&v288[12] = 1024;
      *(_DWORD *)&v288[14] = 789;
      *(_WORD *)&v288[18] = 2048;
      *(void *)&v288[20] = v8;
      *(_WORD *)&v288[28] = 2048;
      *(void *)&v288[30] = v89;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_284:
      uint64_t v240 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int32x2_t v288 = 136315906;
      *(void *)&v288[4] = "operator[]";
      *(_WORD *)&v288[12] = 1024;
      *(_DWORD *)&v288[14] = 789;
      *(_WORD *)&v288[18] = 2048;
      *(void *)&v288[20] = v7;
      *(_WORD *)&v288[28] = 2048;
      *(void *)&v288[30] = a3;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_285:
      uint64_t v240 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int32x2_t v288 = 136315906;
      *(void *)&v288[4] = "operator[]";
      *(_WORD *)&v288[12] = 1024;
      *(_DWORD *)&v288[14] = 789;
      *(_WORD *)&v288[18] = 2048;
      *(void *)&v288[20] = v62;
      *(_WORD *)&v288[28] = 2048;
      *(void *)&v288[30] = v27;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_286:
      uint64_t v240 = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      uint64_t v134 = (uint8_t *)&_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int32x2_t v288 = 136315906;
      *(void *)&v288[4] = "operator[]";
      *(_WORD *)&v288[12] = 1024;
      *(_DWORD *)&v288[14] = 789;
      *(_WORD *)&v288[18] = 2048;
      *(void *)&v288[20] = v8;
      *(_WORD *)&v288[28] = 2048;
      *(void *)&v288[30] = v27;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_287;
    }
    unint64_t v30 = *((void *)&v276 + 1);
LABEL_122:
    if (v30 <= j) {
      goto LABEL_528;
    }
    *(float *)(v278 + 4 * j) = *(float *)(v278 + 4 * j) / 3.0;
  }
  if (*(void *)v288 && v81) {
    (*(void (**)(void))(**(void **)v288 + 40))();
  }
LABEL_127:
  *((void *)&v279 + 1) = 0;
  ++v280;
  LODWORD(v306[0]) = 0;
  re::DynamicArray<float>::resize((void *)&v278 + 1, v265, v306);
  *((void *)&v282 + 1) = 0;
  ++v283;
  LODWORD(v306[0]) = 0;
  re::DynamicArray<float>::resize((void *)&v281 + 1, *(unsigned int *)buf, v306);
  long long v86 = (unsigned char *)*((void *)&v242 + 1);
  if (DWORD2(v242))
  {
    unint64_t v87 = 0;
    unint64_t v30 = (unint64_t)v296;
    unint64_t v61 = (unint64_t)v303;
    unint64_t v6 = 2;
    while ((unint64_t)v86 > v87)
    {
      *(_OWORD *)float32x2_t v303 = *(_OWORD *)(v243 + 16 * v87);
      re::GeomConnectivityManifold::faceIncidentEdges((re::GeomConnectivityManifold *)buf, v87, v296);
      uint64_t v88 = 0;
      id v89 = (unsigned char *)*((void *)&v285 + 1);
      uint64_t v90 = v287;
      a3 = (unsigned int *)*((void *)&v279 + 1);
      uint64_t v91 = v281;
      unint64_t v27 = *((void *)&v282 + 1);
      uint64_t v92 = v284;
      do
      {
        unint64_t v7 = *(unsigned int *)&v303[4 * v88];
        if ((unint64_t)v89 <= v7) {
          goto LABEL_281;
        }
        uint64_t v93 = v88 + 1;
        if (v88 == 2) {
          uint64_t v94 = 0;
        }
        else {
          uint64_t v94 = v88 + 1;
        }
        unint64_t v62 = *(unsigned int *)&v303[4 * v94];
        if ((unint64_t)v89 <= v62) {
          goto LABEL_282;
        }
        if (v88) {
          uint64_t v95 = (v88 - 1);
        }
        else {
          uint64_t v95 = 2;
        }
        unint64_t v8 = *(unsigned int *)&v303[4 * v95];
        if ((unint64_t)v89 <= v8) {
          goto LABEL_283;
        }
        float32x4_t v96 = *(float32x4_t *)(v90 + 16 * v7);
        float32x4_t v97 = vsubq_f32(*(float32x4_t *)(v90 + 16 * v62), v96);
        float32x4_t v98 = vsubq_f32(*(float32x4_t *)(v90 + 16 * v8), v96);
        float32x4_t v99 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v98, (int32x4_t)v98), (int8x16_t)v98, 0xCuLL), vnegq_f32(v97)), v98, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v97, (int32x4_t)v97), (int8x16_t)v97, 0xCuLL));
        float32x4_t v100 = vmulq_f32(v99, v99);
        float v101 = sqrtf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v100.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v100, 2), v100)).f32[0]);
        float v102 = 0.0;
        if (v101 > 0.0)
        {
          float32x4_t v103 = vmulq_f32(v97, v98);
          float v102 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v103, 2), vaddq_f32(v103, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v103.f32, 1))).f32[0]/ v101;
        }
        unint64_t v7 = v296[v94];
        if ((unint64_t)a3 <= v7) {
          goto LABEL_284;
        }
        *(float *)(v91 + 4 * v7) = *(float *)(v91 + 4 * v7) - v102;
        if (v27 <= v62) {
          goto LABEL_285;
        }
        *(float *)(v92 + 4 * v62) = v102 + *(float *)(v92 + 4 * v62);
        if (v27 <= v8) {
          goto LABEL_286;
        }
        *(float *)(v92 + 4 * v8) = v102 + *(float *)(v92 + 4 * v8);
        uint64_t v88 = v93;
      }
      while (v93 != 3);
      ++v87;
      long long v86 = (unsigned char *)*((void *)&v242 + 1);
      a3 = (unsigned int *)v226;
      if (v87 >= DWORD2(v242)) {
        goto LABEL_147;
      }
    }
LABEL_542:
    *(void *)float32x2_t v303 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int32x2_t v288 = 136315906;
    *(void *)&v288[4] = "operator[]";
    *(_WORD *)&v288[12] = 1024;
    *(_DWORD *)&v288[14] = 797;
    *(_WORD *)&v288[18] = 2048;
    *(void *)&v288[20] = v87;
    *(_WORD *)&v288[28] = 2048;
    *(void *)&v288[30] = v86;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_543:
    re::internal::assertLog((re::internal *)4, v24, "assertion failure: '%s' (%s:line %i) Unsupported attribute type.", "!\"Unreachable code\"", "makeConditionedMeshForGPU", 717);
    _os_crash();
    __break(1u);
  }
LABEL_147:
  unint64_t v104 = a3[4];
  LODWORD(v306[0]) = 0;
  re::DynamicArray<unsigned int>::resize(v236, v104, v306);
  unint64_t v227 = v104;
  if (v104)
  {
    unint64_t v105 = 0;
    unint64_t v6 = (unint64_t)&v288[32];
    a3 = v295;
    while (1)
    {
      *(void *)&v305[2] = 0;
      memset(v303, 0, sizeof(v303));
      re::GeomConnectivityManifold::fetchVertexIncidentEdges((re::GeomConnectivityManifold *)buf, v105, (_anonymous_namespace_ *)v303);
      unint64_t v27 = *(void *)&v303[16];
      memset(v288, 0, 28);
      uint64_t v291 = 0;
      *(_OWORD *)&v288[32] = 0u;
      long long v289 = 0u;
      int v290 = 0;
      unint64_t v30 = (*(_DWORD *)&v303[16] + 1);
      re::DynamicArray<float>::resize((uint64_t)v288, v30);
      re::DynamicArray<float>::resize((uint64_t)&v288[40], (v27 + 1));
      if (!*(void *)&v288[16]) {
        goto LABEL_529;
      }
      **(_DWORD **)&v288[32] = v105;
      unint64_t v30 = *((void *)&v282 + 1);
      if (*((void *)&v282 + 1) <= v105) {
        goto LABEL_530;
      }
      if (!*((void *)&v289 + 1)) {
        goto LABEL_531;
      }
      float *v291 = *(float *)(v284 + 4 * v105) * 0.5;
      unint64_t v8 = v27;
      if (v27) {
        break;
      }
LABEL_160:
      if (*(void *)v303 && *(void *)&v305[2]) {
        (*(void (**)(void))(**(void **)v303 + 40))();
      }
      if (*((void *)&v289 + 1))
      {
        unint64_t v106 = 0;
        unint64_t v30 = 1;
        do
        {
          unint64_t v61 = *(void *)&v288[16];
          if (*(void *)&v288[16] <= v106) {
            goto LABEL_279;
          }
          re::DynamicArray<int>::add(v292, (_DWORD *)(*(void *)&v288[32] + 4 * v106));
          unint64_t v61 = *((void *)&v289 + 1);
          if (*((void *)&v289 + 1) <= v106) {
            goto LABEL_280;
          }
          re::DynamicArray<float>::add((_anonymous_namespace_ *)v232, &v291[v106]);
          unint64_t v106 = v30;
          BOOL v107 = *((void *)&v289 + 1) > (unint64_t)v30;
          unint64_t v30 = (v30 + 1);
        }
        while (v107);
      }
      unint64_t v27 = v237;
      if (v105)
      {
        unint64_t v30 = v105 - 1;
        if (v237 <= v105 - 1) {
          goto LABEL_537;
        }
        int v108 = v239[v30] + *(_DWORD *)&v288[16];
      }
      else
      {
        int v108 = *(_DWORD *)&v288[16];
      }
      if (v237 <= v105) {
        goto LABEL_532;
      }
      v239[v105] = v108;
      if (*(void *)&v288[40])
      {
        if (v291) {
          (*(void (**)(void))(**(void **)&v288[40] + 40))();
        }
        uint64_t v291 = 0;
        long long v289 = 0uLL;
        *(void *)&v288[40] = 0;
        ++v290;
      }
      if (*(void *)v288 && *(void *)&v288[32]) {
        (*(void (**)(void))(**(void **)v288 + 40))();
      }
      if (++v105 == v227) {
        goto LABEL_181;
      }
    }
    unint64_t v106 = 0;
    unint64_t v30 = *(void *)&v303[16];
    while (v30 > v106)
    {
      re::GeomConnectivityManifold::edgeVertices((re::GeomConnectivityManifold *)buf, *(_DWORD *)(*(void *)&v305[2] + 4 * v106), v295);
      unint64_t v62 = v106 + 1;
      unint64_t v30 = *(void *)&v288[16];
      if (*(void *)&v288[16] <= v106 + 1) {
        goto LABEL_275;
      }
      *(_DWORD *)(*(void *)&v288[32] + 4 * v106 + 4) = v295[v105 == v295[0]];
      unint64_t v30 = *(void *)&v303[16];
      if (*(void *)&v303[16] <= v106) {
        goto LABEL_276;
      }
      unint64_t v7 = *(unsigned int *)(*(void *)&v305[2] + 4 * v106);
      unint64_t v61 = *((void *)&v279 + 1);
      if (*((void *)&v279 + 1) <= v7) {
        goto LABEL_277;
      }
      unint64_t v61 = *((void *)&v289 + 1);
      if (*((void *)&v289 + 1) <= v62) {
        goto LABEL_278;
      }
      v291[++v106] = *(float *)(v281 + 4 * v7) * 0.5;
      if (v8 == v62) {
        goto LABEL_160;
      }
    }
    goto LABEL_274;
  }
LABEL_181:
  a3 = (unsigned int *)v226;
  uint64_t v109 = re::GeomMesh::addAttribute((uint64_t)v226, "cotangentLaplacianIndices", 4, 3);
  (*(void (**)(re::GeomAttribute *, void))(*(void *)v109 + 24))(v109, *(unsigned int *)&v292[16]);
  unsigned int v110 = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)v109 + 16))(v109);
  if (v110)
  {
    long long v111 = (_DWORD *)re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v109, 0);
    unsigned int v110 = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)v109 + 16))(v109);
  }
  else
  {
    long long v111 = 0;
  }
  uint64_t v112 = *(void *)&v292[16];
  unint64_t v27 = (unint64_t)v225;
  unint64_t v30 = v230;
  unint64_t v61 = v220;
  unint64_t v62 = (unint64_t)buf;
  if (*(void *)&v292[16])
  {
    unsigned int v113 = *(int **)&v294[2];
    unint64_t v114 = v110;
    uint64_t v115 = v110;
    while (v115)
    {
      int v116 = *v113++;
      *v111++ = v116;
      --v115;
      if (!--v112) {
        goto LABEL_188;
      }
    }
LABEL_523:
    *(void *)float32x2_t v303 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int32x2_t v288 = 136315906;
    *(void *)&v288[4] = "operator[]";
    *(_WORD *)&v288[12] = 1024;
    *(_DWORD *)&v288[14] = 609;
    *(_WORD *)&v288[18] = 2048;
    *(void *)&v288[20] = v114;
    *(_WORD *)&v288[28] = 2048;
    *(void *)&v288[30] = v114;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_524:
    *(void *)float32x2_t v303 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int32x2_t v288 = 136315906;
    *(void *)&v288[4] = "operator[]";
    *(_WORD *)&v288[12] = 1024;
    *(_DWORD *)&v288[14] = 609;
    *(_WORD *)&v288[18] = 2048;
    *(void *)&v288[20] = v114;
    *(_WORD *)&v288[28] = 2048;
    *(void *)&v288[30] = v114;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_525:
    *(void *)float32x2_t v303 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    unsigned int v182 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int32x2_t v288 = 136315906;
    *(void *)&v288[4] = "operator[]";
    *(_WORD *)&v288[12] = 1024;
    *(_DWORD *)&v288[14] = 609;
    *(_WORD *)&v288[18] = 2048;
    *(void *)&v288[20] = v114;
    *(_WORD *)&v288[28] = 2048;
    *(void *)&v288[30] = v114;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_526:
    v236[0] = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v292 = 136315906;
    *(void *)&v292[4] = "operator[]";
    *(_WORD *)&v292[12] = 1024;
    *(_DWORD *)&v292[14] = 601;
    *(_WORD *)&v292[18] = 2048;
    *(void *)&v292[20] = v182;
    __int16 v293 = 2048;
    *(void *)float v294 = v61;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_527:
    v236[0] = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    unint64_t j = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v292 = 136315906;
    *(void *)&v292[4] = "operator[]";
    *(_WORD *)&v292[12] = 1024;
    *(_DWORD *)&v292[14] = 601;
    *(_WORD *)&v292[18] = 2048;
    *(void *)&v292[20] = v8;
    __int16 v293 = 2048;
    *(void *)float v294 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_528:
    *(void *)float v296 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)float32x2_t v303 = 136315906;
    *(void *)&v303[4] = "operator[]";
    *(_WORD *)&v303[12] = 1024;
    *(_DWORD *)&v303[14] = 789;
    *(_WORD *)&v303[18] = 2048;
    *(void *)&v303[20] = j;
    __int16 v304 = 2048;
    *(void *)float32x2_t v305 = v30;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_529:
    uint64_t v240 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    unint64_t v105 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    v296[0] = 136315906;
    *(void *)&v296[1] = "operator[]";
    __int16 v297 = 1024;
    int v298 = 789;
    __int16 v299 = 2048;
    float32x2_t v300 = 0;
    __int16 v301 = 2048;
    unint64_t v302 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_530:
    uint64_t v240 = 0;
    unint64_t v27 = (unint64_t)v288;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    v296[0] = 136315906;
    *(void *)&v296[1] = "operator[]";
    __int16 v297 = 1024;
    int v298 = 797;
    __int16 v299 = 2048;
    float32x2_t v300 = (unsigned char *)v105;
    __int16 v301 = 2048;
    unint64_t v302 = v30;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_531:
    uint64_t v240 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    unint64_t v105 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    v296[0] = 136315906;
    *(void *)&v296[1] = "operator[]";
    __int16 v297 = 1024;
    int v298 = 789;
    __int16 v299 = 2048;
    float32x2_t v300 = 0;
    __int16 v301 = 2048;
    unint64_t v302 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_532:
    *(void *)float v296 = 0;
    unint64_t v30 = (unint64_t)v288;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    unsigned int v164 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)float32x2_t v303 = 136315906;
    *(void *)&v303[4] = "operator[]";
    *(_WORD *)&v303[12] = 1024;
    *(_DWORD *)&v303[14] = 789;
    *(_WORD *)&v303[18] = 2048;
    *(void *)&v303[20] = v105;
    __int16 v304 = 2048;
    *(void *)float32x2_t v305 = v27;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_533:
    v236[0] = 0;
    unint64_t v27 = (unint64_t)v288;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v292 = 136315906;
    *(void *)&v292[4] = "operator[]";
    *(_WORD *)&v292[12] = 1024;
    *(_DWORD *)&v292[14] = 601;
    *(_WORD *)&v292[18] = 2048;
    *(void *)&v292[20] = v164;
    __int16 v293 = 2048;
    *(void *)float v294 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_534:
    v236[0] = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v292 = 136315906;
    *(void *)&v292[4] = "operator[]";
    *(_WORD *)&v292[12] = 1024;
    *(_DWORD *)&v292[14] = 609;
    *(_WORD *)&v292[18] = 2048;
    *(void *)&v292[20] = v27;
    __int16 v293 = 2048;
    *(void *)float v294 = v27;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_535:
    v236[0] = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v292 = 136315906;
    *(void *)&v292[4] = "operator[]";
    *(_WORD *)&v292[12] = 1024;
    *(_DWORD *)&v292[14] = 601;
    *(_WORD *)&v292[18] = 2048;
    *(void *)&v292[20] = v6;
    __int16 v293 = 2048;
    *(void *)float v294 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_536:
    v236[0] = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v292 = 136315906;
    *(void *)&v292[4] = "operator[]";
    *(_WORD *)&v292[12] = 1024;
    *(_DWORD *)&v292[14] = 609;
    *(_WORD *)&v292[18] = 2048;
    *(void *)&v292[20] = v27;
    __int16 v293 = 2048;
    *(void *)float v294 = v27;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_537:
    *(void *)float v296 = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)float32x2_t v303 = 136315906;
    *(void *)&v303[4] = "operator[]";
    *(_WORD *)&v303[12] = 1024;
    *(_DWORD *)&v303[14] = 789;
    *(_WORD *)&v303[18] = 2048;
    *(void *)&v303[20] = v30;
    __int16 v304 = 2048;
    *(void *)float32x2_t v305 = v27;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_538:
    v236[0] = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v292 = 136315906;
    *(void *)&v292[4] = "operator[]";
    *(_WORD *)&v292[12] = 1024;
    *(_DWORD *)&v292[14] = 789;
    *(_WORD *)&v292[18] = 2048;
    *(void *)&v292[20] = v27;
    __int16 v293 = 2048;
    *(void *)float v294 = v30;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_539:
    v236[0] = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v292 = 136315906;
    *(void *)&v292[4] = "operator[]";
    *(_WORD *)&v292[12] = 1024;
    *(_DWORD *)&v292[14] = 609;
    *(_WORD *)&v292[18] = 2048;
    *(void *)&v292[20] = v27;
    __int16 v293 = 2048;
    *(void *)float v294 = v27;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_540:
    v236[0] = 0;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    unint64_t v87 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v292 = 136315906;
    *(void *)&v292[4] = "operator[]";
    *(_WORD *)&v292[12] = 1024;
    *(_DWORD *)&v292[14] = 789;
    *(_WORD *)&v292[18] = 2048;
    *(void *)&v292[20] = v61;
    __int16 v293 = 2048;
    *(void *)float v294 = v30;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_541:
    v236[0] = 0;
    long long v86 = v288;
    long long v307 = 0u;
    long long v308 = 0u;
    memset(v306, 0, sizeof(v306));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v292 = 136315906;
    *(void *)&v292[4] = "operator[]";
    *(_WORD *)&v292[12] = 1024;
    *(_DWORD *)&v292[14] = 601;
    *(_WORD *)&v292[18] = 2048;
    *(void *)&v292[20] = v87;
    __int16 v293 = 2048;
    *(void *)float v294 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_542;
  }
LABEL_188:
  id v117 = re::GeomMesh::addAttribute((uint64_t)v226, "cotangentLaplacianEndIndices", 4, 3);
  (*(void (**)(re::GeomAttribute *, void))(*(void *)v117 + 24))(v117, v237);
  unsigned int v118 = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)v117 + 16))(v117);
  if (v118)
  {
    unint64_t v119 = (_DWORD *)re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v117, 0);
    unsigned int v118 = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)v117 + 16))(v117);
  }
  else
  {
    unint64_t v119 = 0;
  }
  unint64_t v120 = v237;
  if (v237)
  {
    int v121 = v239;
    unint64_t v114 = v118;
    uint64_t v122 = v118;
    while (v122)
    {
      int v123 = *v121++;
      *v119++ = v123;
      --v122;
      if (!--v120) {
        goto LABEL_195;
      }
    }
    goto LABEL_524;
  }
LABEL_195:
  uint64_t v124 = re::GeomMesh::addAttribute((uint64_t)v226, "cotangentLaplacianWeights", 4, 4);
  (*(void (**)(re::GeomAttribute *, void))(*(void *)v124 + 24))(v124, v233);
  unsigned int v125 = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)v124 + 16))(v124);
  if (v125)
  {
    unint64_t v126 = (_DWORD *)re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v124, 0);
    unsigned int v125 = (*(uint64_t (**)(re::GeomAttribute *))(*(void *)v124 + 16))(v124);
  }
  else
  {
    unint64_t v126 = 0;
  }
  uint64_t v127 = v233;
  if (v233)
  {
    long long v128 = v235;
    unint64_t v114 = v125;
    uint64_t v129 = v125;
    while (v129)
    {
      int v130 = *v128++;
      *v126++ = v130;
      --v129;
      if (!--v127) {
        goto LABEL_202;
      }
    }
    goto LABEL_525;
  }
LABEL_202:
  if (*((void *)&v284 + 1))
  {
    if (v287) {
      (*(void (**)(void))(**((void **)&v284 + 1) + 40))();
    }
    uint64_t v287 = 0;
    long long v285 = 0uLL;
    *((void *)&v284 + 1) = 0;
    ++v286;
  }
  if (*((void *)&v281 + 1))
  {
    if ((void)v284) {
      (*(void (**)(void))(**((void **)&v281 + 1) + 40))();
    }
    *(void *)&long long v284 = 0;
    long long v282 = 0uLL;
    *((void *)&v281 + 1) = 0;
    ++v283;
  }
  if (*((void *)&v278 + 1))
  {
    if ((void)v281) {
      (*(void (**)(void))(**((void **)&v278 + 1) + 40))();
    }
    *(void *)&long long v281 = 0;
    long long v279 = 0uLL;
    *((void *)&v278 + 1) = 0;
    ++v280;
  }
  if (*((void *)&v275 + 1))
  {
    if ((void)v278) {
      (*(void (**)(void))(**((void **)&v275 + 1) + 40))();
    }
    *(void *)&long long v278 = 0;
    long long v276 = 0uLL;
    *((void *)&v275 + 1) = 0;
    ++v277;
  }
  if (v271)
  {
    if ((void)v275) {
      (*(void (**)(void))(*(void *)v271 + 40))();
    }
    *(void *)&long long v275 = 0;
    uint64_t v272 = 0;
    unint64_t v273 = 0;
    uint64_t v271 = 0;
    ++v274;
  }
  if (v268)
  {
    int v131 = v270;
    if ((v270 & 1) == 0)
    {
      (*(void (**)(void))(*(void *)v268 + 40))();
      int v131 = v270;
    }
    uint64_t v268 = 0;
    uint64_t v269 = 0;
    int v270 = (v131 | 1) + 2;
  }
  if (v263)
  {
    if (v267) {
      (*(void (**)(void))(*(void *)v263 + 40))();
    }
    uint64_t v267 = 0;
    uint64_t v264 = 0;
    uint64_t v265 = 0;
    uint64_t v263 = 0;
    ++v266;
  }
  if (v258)
  {
    if (v262) {
      (*(void (**)(void))(*(void *)v258 + 40))();
    }
    uint64_t v262 = 0;
    uint64_t v259 = 0;
    uint64_t v260 = 0;
    uint64_t v258 = 0;
    ++v261;
  }
  if (v253)
  {
    if (v257) {
      (*(void (**)(void))(*(void *)v253 + 40))();
    }
    uint64_t v257 = 0;
    uint64_t v254 = 0;
    uint64_t v255 = 0;
    uint64_t v253 = 0;
    ++v256;
  }
  if (v248)
  {
    if (v252) {
      (*(void (**)(void))(*(void *)v248 + 40))();
    }
    uint64_t v252 = 0;
    uint64_t v249 = 0;
    uint64_t v250 = 0;
    uint64_t v248 = 0;
    ++v251;
  }
  if (v244[0])
  {
    if (v247) {
      (*(void (**)(void))(*(void *)v244[0] + 40))();
    }
    uint64_t v247 = 0;
    v244[1] = 0;
    uint64_t v245 = 0;
    v244[0] = 0;
    LODWORD(v246) = v246 + 1;
  }
  if (*(void *)&buf[8] && v243) {
    (*(void (**)(void))(**(void **)&buf[8] + 40))();
  }
  if (v232[0] && v235) {
    (*(void (**)(void))(*(void *)v232[0] + 40))();
  }
  if (v236[0] && v239) {
    (*(void (**)(void))(*(void *)v236[0] + 40))();
  }
  if (*(void *)v292 && *(void *)&v294[2]) {
    (*(void (**)(void))(**(void **)v292 + 40))();
  }
  BOOL v59 = v215;
LABEL_259:
  if (!v61) {
    goto LABEL_328;
  }
  if (*(unsigned char *)(v30 + 8)) {
    BOOL v132 = 0;
  }
  else {
    BOOL v132 = v59;
  }
  if (!v132
    || (uint64_t v133 = re::internal::GeomAttributeManager::attributeByName(v221, "vertexNormal")) == 0
    || *(unsigned char *)(v133 + 16) != 3)
  {
LABEL_308:
    v306[4] = 0;
    memset(v306, 0, 28);
    *(void *)&v288[32] = 0;
    memset(v288, 0, 28);
    re::computeVertexFaceConnectivity((unint64_t)a3, (uint64_t)v306, (unint64_t)v288);
    uint64_t v139 = re::GeomMesh::addAttribute((uint64_t)a3, "vertexAdjacencies", 4, 3);
    (*(void (**)(re::GeomAttribute *, void))(*(void *)v139 + 24))(v139, LODWORD(v306[2]));
    if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)v139 + 16))(v139))
    {
      uint64_t v140 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v139, 0);
      __int16 v141 = (unsigned char *)(*(unsigned int (**)(re::GeomAttribute *))(*(void *)v139 + 16))(v139);
    }
    else
    {
      __int16 v141 = 0;
      uint64_t v140 = 0;
    }
    uint64_t v142 = (unsigned char *)v306[2];
    if (v306[2])
    {
      uint64_t v143 = 0;
      uint64_t v144 = v306[4];
      while (v141 != v143)
      {
        *(_DWORD *)(v140 + 4 * (void)v143) = *(_DWORD *)(v144 + 4 * (void)v143);
        if (v142 == ++v143) {
          goto LABEL_315;
        }
      }
      goto LABEL_516;
    }
LABEL_315:
    long long v145 = re::GeomMesh::addAttribute((uint64_t)a3, "accumulatedVertexValence", 4, 3);
    (*(void (**)(re::GeomAttribute *, void))(*(void *)v145 + 24))(v145, a3[4]);
    if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)v145 + 16))(v145))
    {
      uint64_t v146 = re::internal::GeomTypedAttribute<float>::operator[]((uint64_t)v145, 0);
      __int16 v141 = (unsigned char *)(*(unsigned int (**)(re::GeomAttribute *))(*(void *)v145 + 16))(v145);
    }
    else
    {
      __int16 v141 = 0;
      uint64_t v146 = 0;
    }
    int v147 = *(unsigned char **)&v288[16];
    if (*(void *)&v288[16])
    {
      __int16 v148 = 0;
      uint64_t v149 = *(void *)&v288[32];
      while (v141 != v148)
      {
        *(_DWORD *)(v146 + 4 * (void)v148) = *(_DWORD *)(v149 + 4 * (void)v148);
        if (v147 == ++v148) {
          goto LABEL_322;
        }
      }
      goto LABEL_517;
    }
LABEL_322:
    if (*(void *)v288 && *(void *)&v288[32]) {
      (*(void (**)(void, void))(**(void **)v288 + 40))(*(void *)v288, *(void *)&v288[32]);
    }
    if (v306[0] && v306[4]) {
      (*(void (**)(void, void))(*(void *)v306[0] + 40))(v306[0], v306[4]);
    }
LABEL_328:
    unsigned int v150 = 0;
    unsigned int v151 = a3[4];
    *(void *)int32x2_t v288 = 0xFFFFFFFF00000000;
    *(_DWORD *)&v288[8] = -1;
    v288[12] = 0;
    if (v151 - 1 <= 0xFFFFFFFD)
    {
      *(_DWORD *)&v288[8] = v151 - 1;
      unsigned int v150 = v151;
      *(void *)int32x2_t v288 = v151;
    }
    *(_DWORD *)&v288[16] = v150;
    unint64_t v152 = a3[106];
    if (!a3[106]) {
      goto LABEL_458;
    }
    unint64_t v30 = (unint64_t)(a3 + 100);
    *(void *)&v305[2] = 0;
    memset(v303, 0, sizeof(v303));
    re::DynamicArray<double>::resize((uint64_t)v303, v152);
    unint64_t v153 = 0;
    do
    {
      uint64_t v154 = re::internal::GeomAttributeContainer::attributeByIndex((re::internal::GeomAttributeContainer *)(a3 + 100), v153);
      unint64_t v27 = *(void *)&v303[16];
      if (*(void *)&v303[16] <= v153) {
        goto LABEL_514;
      }
      *(void *)(*(void *)&v305[2] + 8 * v153++) = *(void *)(v154 + 8);
    }
    while (v152 != v153);
    re::GeomMesh::GeomMesh((re::GeomMesh *)buf, 0);
    re::internal::buildMeshByConvertingFaceVaryingToVertexHelper((unint64_t)a3, (uint64_t)v303, (unint64_t)v288, (unint64_t)buf);
    if (v61)
    {
      uint64_t v155 = re::internal::GeomAttributeManager::attributeByName(v221, "vertexAdjacencies");
      uint64_t v156 = re::internal::GeomAttributeManager::attributeByName(v221, "accumulatedVertexValence");
      unint64_t v30 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)&v245, "vertexAdjacencies");
      unint64_t v6 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)&v245, "accumulatedVertexValence");
      uint64_t v157 = v242;
      if ((*(unsigned int (**)(uint64_t))(*(void *)v156 + 16))(v156))
      {
        unint64_t v61 = re::internal::GeomTypedAttribute<int>::operator[](v156, 0);
        LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(void *)v156 + 16))(v156);
      }
      else
      {
        LODWORD(v7) = 0;
        unint64_t v61 = 0;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v155 + 16))(v155))
      {
        uint64_t v218 = re::internal::GeomTypedAttribute<int>::operator[](v155, 0);
        unsigned int v228 = (*(uint64_t (**)(uint64_t))(*(void *)v155 + 16))(v155);
        if (v157) {
          goto LABEL_340;
        }
      }
      else
      {
        unsigned int v228 = 0;
        uint64_t v218 = 0;
        if (v157)
        {
LABEL_340:
          uint64_t v158 = 0;
          LODWORD(v159) = 0;
          while (1)
          {
            unsigned int v160 = re::GeomIndexMap::operator[]((uint64_t)v288, v158);
            LODWORD(v8) = v160;
            if (v7 <= v160) {
              goto LABEL_527;
            }
            if (v160) {
              int v161 = *(_DWORD *)(v61 + 4 * (v160 - 1));
            }
            else {
              int v161 = 0;
            }
            uint64_t v159 = (*(_DWORD *)(v61 + 4 * v160) + v159 - v161);
            uint64_t v158 = (v158 + 1);
            if (v157 == v158) {
              goto LABEL_349;
            }
          }
        }
      }
      uint64_t v159 = 0;
LABEL_349:
      (*(void (**)(unint64_t, uint64_t))(*(void *)v6 + 24))(v6, v157);
      (*(void (**)(unint64_t, uint64_t))(*(void *)v30 + 24))(v30, v159);
      if ((*(unsigned int (**)(unint64_t))(*(void *)v6 + 16))(v6))
      {
        unint64_t v8 = re::internal::GeomTypedAttribute<float>::operator[](v6, 0);
        unint64_t v27 = (*(unsigned int (**)(unint64_t))(*(void *)v6 + 16))(v6);
      }
      else
      {
        unint64_t v27 = 0;
        unint64_t v8 = 0;
      }
      if ((*(unsigned int (**)(unint64_t))(*(void *)v30 + 16))(v30))
      {
        uint64_t v216 = re::internal::GeomTypedAttribute<float>::operator[](v30, 0);
        unint64_t v30 = (*(uint64_t (**)(unint64_t))(*(void *)v30 + 16))(v30);
        if (!v157) {
          goto LABEL_375;
        }
      }
      else
      {
        unint64_t v30 = 0;
        uint64_t v216 = 0;
        if (!v157) {
          goto LABEL_375;
        }
      }
      uint64_t v162 = 0;
      unint64_t v62 = 0;
      while (1)
      {
        unsigned int v163 = re::GeomIndexMap::operator[]((uint64_t)v288, v162);
        unsigned int v164 = v163;
        if (v7 <= v163) {
          goto LABEL_533;
        }
        unsigned int v165 = v163 ? *(_DWORD *)(v61 + 4 * (v163 - 1)) : 0;
        unsigned int v166 = *(_DWORD *)(v61 + 4 * v163);
        BOOL v167 = v166 >= v165;
        unsigned int v168 = v166 - v165;
        if (v168 != 0 && v167) {
          break;
        }
LABEL_373:
        if (v162 == v27) {
          goto LABEL_534;
        }
        *(_DWORD *)(v8 + 4 * v162++) = v62;
        if (v162 == v157) {
          goto LABEL_375;
        }
      }
      if (v165 <= v228) {
        uint64_t v169 = v228;
      }
      else {
        uint64_t v169 = v165;
      }
      unsigned int v170 = (_DWORD *)(v216 + 4 * v62);
      if (v62 <= v30) {
        unint64_t v6 = v30;
      }
      else {
        unint64_t v6 = v62;
      }
      unint64_t v171 = v6 - v62;
      v172 = (int *)(v218 + 4 * v165);
      uint64_t v173 = v169 - v165;
      while (v173)
      {
        if (!v171) {
          goto LABEL_509;
        }
        int v174 = *v172++;
        *v170++ = v174;
        unint64_t v62 = (v62 + 1);
        --v171;
        --v173;
        if (!--v168) {
          goto LABEL_373;
        }
      }
      v236[0] = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v292 = 136315906;
      *(void *)&v292[4] = "operator[]";
      *(_WORD *)&v292[12] = 1024;
      *(_DWORD *)&v292[14] = 601;
      *(_WORD *)&v292[18] = 2048;
      *(void *)&v292[20] = v169;
      __int16 v293 = 2048;
      *(void *)float v294 = v228;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_509:
      v236[0] = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      unsigned int v187 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v292 = 136315906;
      *(void *)&v292[4] = "operator[]";
      *(_WORD *)&v292[12] = 1024;
      *(_DWORD *)&v292[14] = 609;
      *(_WORD *)&v292[18] = 2048;
      *(void *)&v292[20] = v6;
      __int16 v293 = 2048;
      *(void *)float v294 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_510:
      v236[0] = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v292 = 136315906;
      *(void *)&v292[4] = "operator[]";
      *(_WORD *)&v292[12] = 1024;
      *(_DWORD *)&v292[14] = 601;
      *(_WORD *)&v292[18] = 2048;
      *(void *)&v292[20] = v187 + v6;
      __int16 v293 = 2048;
      *(void *)float v294 = v228;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_511:
      v236[0] = 0;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      unsigned int v187 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v292 = 136315906;
      *(void *)&v292[4] = "operator[]";
      *(_WORD *)&v292[12] = 1024;
      *(_DWORD *)&v292[14] = 609;
      *(_WORD *)&v292[18] = 2048;
      *(void *)&v292[20] = (v61 + v6);
      __int16 v293 = 2048;
      *(void *)float v294 = v221;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_512:
      v236[0] = 0;
      unint64_t v27 = (unint64_t)v288;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v292 = 136315906;
      *(void *)&v292[4] = "operator[]";
      *(_WORD *)&v292[12] = 1024;
      *(_DWORD *)&v292[14] = 601;
      *(_WORD *)&v292[18] = 2048;
      *(void *)&v292[20] = v6 + v187;
      __int16 v293 = 2048;
      *(void *)float v294 = v218;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_513:
      v236[0] = 0;
      unint64_t v153 = (unint64_t)v288;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long v292 = 136315906;
      *(void *)&v292[4] = "operator[]";
      *(_WORD *)&v292[12] = 1024;
      *(_DWORD *)&v292[14] = 609;
      *(_WORD *)&v292[18] = 2048;
      *(void *)&v292[20] = v6 + v61;
      __int16 v293 = 2048;
      *(void *)float v294 = v216;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_514:
      *(void *)long long v292 = 0;
      *(_OWORD *)(v62 + 48) = 0u;
      *(_OWORD *)(v62 + 64) = 0u;
      *(_OWORD *)(v62 + 32) = 0u;
      *(_OWORD *)long long buf = 0u;
      long long v242 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v306[0]) = 136315906;
      *(void *)((char *)v306 + 4) = "operator[]";
      WORD2(v306[1]) = 1024;
      *(_DWORD *)((char *)&v306[1] + 6) = 789;
      WORD1(v306[2]) = 2048;
      *(void *)((char *)&v306[2] + 4) = v153;
      WORD2(v306[3]) = 2048;
      *(void *)((char *)&v306[3] + 6) = v27;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_515:
      *(void *)float32x2_t v303 = 0;
      __int16 v141 = v288;
      long long v307 = 0u;
      long long v308 = 0u;
      memset(v306, 0, sizeof(v306));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)int32x2_t v288 = 136315906;
      *(void *)&v288[4] = "operator[]";
      *(_WORD *)&v288[12] = 1024;
      *(_DWORD *)&v288[14] = 789;
      *(_WORD *)&v288[18] = 2048;
      *(void *)&v288[20] = v27;
      *(_WORD *)&v288[28] = 2048;
      *(void *)&v288[30] = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_516:
      *(void *)long long v292 = 0;
      *(_OWORD *)(v62 + 48) = 0u;
      *(_OWORD *)(v62 + 64) = 0u;
      *(_OWORD *)(v62 + 32) = 0u;
      *(_OWORD *)long long buf = 0u;
      long long v242 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float32x2_t v303 = 136315906;
      *(void *)&v303[4] = "operator[]";
      *(_WORD *)&v303[12] = 1024;
      *(_DWORD *)&v303[14] = 609;
      *(_WORD *)&v303[18] = 2048;
      *(void *)&v303[20] = v141;
      __int16 v304 = 2048;
      *(void *)float32x2_t v305 = v141;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_517:
      *(void *)long long v292 = 0;
      *(_OWORD *)(v62 + 48) = 0u;
      *(_OWORD *)(v62 + 64) = 0u;
      *(_OWORD *)(v62 + 32) = 0u;
      *(_OWORD *)long long buf = 0u;
      long long v242 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)float32x2_t v303 = 136315906;
      *(void *)&v303[4] = "operator[]";
      *(_WORD *)&v303[12] = 1024;
      *(_DWORD *)&v303[14] = 609;
      *(_WORD *)&v303[18] = 2048;
      *(void *)&v303[20] = v141;
      __int16 v304 = 2048;
      *(void *)float32x2_t v305 = v141;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_518;
    }
LABEL_375:
    if (*(unsigned char *)(v230 + 8))
    {
      uint64_t v175 = re::internal::GeomAttributeManager::attributeByName(v221, "cotangentLaplacianIndices");
      unint64_t v7 = re::internal::GeomAttributeManager::attributeByName(v221, "cotangentLaplacianEndIndices");
      uint64_t v222 = (re::internal::GeomAttributeManager *)re::internal::GeomAttributeManager::attributeByName(v221, "cotangentLaplacianWeights");
      unint64_t v6 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)&v245, "cotangentLaplacianIndices");
      uint64_t v176 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)&v245, "cotangentLaplacianEndIndices");
      uint64_t v177 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)&v245, "cotangentLaplacianWeights");
      uint64_t v178 = v242;
      uint64_t v217 = v176;
      if ((*(unsigned int (**)(unint64_t))(*(void *)v7 + 16))(v7))
      {
        unint64_t v8 = re::internal::GeomTypedAttribute<int>::operator[](v7, 0);
        unint64_t v61 = (*(uint64_t (**)(unint64_t))(*(void *)v7 + 16))(v7);
      }
      else
      {
        unint64_t v61 = 0;
        unint64_t v8 = 0;
      }
      uint64_t v179 = v177;
      if (v178)
      {
        uint64_t v180 = 0;
        unint64_t v30 = 0;
        while (1)
        {
          unsigned int v181 = re::GeomIndexMap::operator[]((uint64_t)v288, v180);
          unsigned int v182 = v181;
          if (v61 <= v181) {
            goto LABEL_526;
          }
          if (v181) {
            int v183 = *(_DWORD *)(v8 + 4 * (v181 - 1));
          }
          else {
            int v183 = 0;
          }
          unint64_t v30 = (*(_DWORD *)(v8 + 4 * v181) + v30 - v183);
          uint64_t v180 = (v180 + 1);
          if (v178 == v180) {
            goto LABEL_388;
          }
        }
      }
      unint64_t v30 = 0;
LABEL_388:
      (*(void (**)(unint64_t, unint64_t))(*(void *)v6 + 24))(v6, v30);
      uint64_t v184 = v179;
      (*(void (**)(uint64_t, unint64_t))(*(void *)v179 + 24))(v179, v30);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v217 + 24))(v217, v178);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v175 + 16))(v175))
      {
        uint64_t v214 = re::internal::GeomTypedAttribute<int>::operator[](v175, 0);
        unsigned int v228 = (*(uint64_t (**)(uint64_t))(*(void *)v175 + 16))(v175);
      }
      else
      {
        unsigned int v228 = 0;
        uint64_t v214 = 0;
      }
      if ((*(unsigned int (**)(unint64_t))(*(void *)v7 + 16))(v7))
      {
        uint64_t v185 = re::internal::GeomTypedAttribute<int>::operator[](v7, 0);
        LODWORD(v8) = (*(uint64_t (**)(unint64_t))(*(void *)v7 + 16))(v7);
      }
      else
      {
        LODWORD(v8) = 0;
        uint64_t v185 = 0;
      }
      if ((*(unsigned int (**)(re::internal::GeomAttributeManager *))(*(void *)v222 + 16))(v222))
      {
        uint64_t v213 = re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)v222, 0);
        LODWORD(v218) = (*(uint64_t (**)(re::internal::GeomAttributeManager *))(*(void *)v222 + 16))(v222);
      }
      else
      {
        LODWORD(v218) = 0;
        uint64_t v213 = 0;
      }
      if ((*(unsigned int (**)(unint64_t))(*(void *)v6 + 16))(v6))
      {
        uint64_t v212 = re::internal::GeomTypedAttribute<float>::operator[](v6, 0);
        LODWORD(v221) = (*(uint64_t (**)(unint64_t))(*(void *)v6 + 16))(v6);
      }
      else
      {
        LODWORD(v221) = 0;
        uint64_t v212 = 0;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v217 + 16))(v217))
      {
        unint64_t v30 = re::internal::GeomTypedAttribute<float>::operator[](v217, 0);
        unint64_t v27 = (*(unsigned int (**)(uint64_t))(*(void *)v217 + 16))(v217);
      }
      else
      {
        unint64_t v27 = 0;
        unint64_t v30 = 0;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v184 + 16))(v184))
      {
        unint64_t v62 = re::internal::GeomTypedAttribute<float>::operator[](v184, 0);
        LODWORD(v216) = (*(uint64_t (**)(uint64_t))(*(void *)v184 + 16))(v184);
        if (!v178) {
          goto LABEL_433;
        }
        goto LABEL_407;
      }
      LODWORD(v216) = 0;
      unint64_t v62 = 0;
      if (v178)
      {
LABEL_407:
        unint64_t v7 = 0;
        unint64_t v61 = 0;
        while (1)
        {
          unsigned int v186 = re::GeomIndexMap::operator[]((uint64_t)v288, v7);
          LODWORD(v6) = v186;
          if (v186)
          {
            unint64_t v87 = v186 - 1;
            if (v8 <= v87) {
              goto LABEL_541;
            }
            unsigned int v187 = *(_DWORD *)(v185 + 4 * v87);
          }
          else
          {
            unsigned int v187 = 0;
          }
          if (v8 <= v186) {
            goto LABEL_535;
          }
          uint64_t v188 = *(_DWORD *)(v185 + 4 * v186) - v187;
          if (v188) {
            break;
          }
LABEL_431:
          if (v7 == v27) {
            goto LABEL_536;
          }
          unint64_t v61 = (v188 + v61);
          *(_DWORD *)(v30 + 4 * v7++) = v61;
          if (v7 == v178) {
            goto LABEL_433;
          }
        }
        unint64_t v6 = 0;
        LODWORD(v189) = v228 - v187;
        if (v228 >= v187) {
          uint64_t v189 = v189;
        }
        else {
          uint64_t v189 = 0;
        }
        LODWORD(v190) = v221 - v61;
        if (v221 >= v61) {
          uint64_t v190 = v190;
        }
        else {
          uint64_t v190 = 0;
        }
        LODWORD(v191) = v218 - v187;
        if (v218 >= v187) {
          uint64_t v191 = v191;
        }
        else {
          uint64_t v191 = 0;
        }
        LODWORD(v192) = v216 - v61;
        if (v216 >= v61) {
          uint64_t v192 = v192;
        }
        else {
          uint64_t v192 = 0;
        }
        while (v189 != v6)
        {
          if (v190 == v6) {
            goto LABEL_511;
          }
          *(_DWORD *)(v212 + 4 * v61 + 4 * v6) = *(_DWORD *)(v214 + 4 * v187 + 4 * v6);
          if (v191 == v6) {
            goto LABEL_512;
          }
          if (v192 == v6) {
            goto LABEL_513;
          }
          *(_DWORD *)(v62 + 4 * v61 + 4 * v6) = *(_DWORD *)(v213 + 4 * v187 + 4 * v6);
          if (v188 == ++v6) {
            goto LABEL_431;
          }
        }
        goto LABEL_510;
      }
    }
LABEL_433:
    re::remapIndexMap((unsigned int *)v288, a4, (uint64_t)v306);
    re::GeomIndexMap::operator=((uint64_t)a4, (uint64_t)v306);
    unint64_t v27 = (unint64_t)v225;
    a3 = (unsigned int *)v226;
    if (!BYTE4(v306[1])) {
      goto LABEL_444;
    }
    if (BYTE4(v306[1]) == 2)
    {
      uint64_t v194 = *((void *)&v308 + 1);
      if (!*((void *)&v308 + 1)) {
        goto LABEL_444;
      }
      if (v306[3]) {
        v306[3] = 0;
      }
      if (!v306[2]) {
        goto LABEL_444;
      }
LABEL_443:
      (*(void (**)(uint64_t))(*(void *)v194 + 40))(v194);
LABEL_444:
      re::GeomMesh::operator=(v226, (re::GeomMesh *)buf);
      re::GeomMesh::~GeomMesh((re::GeomMesh *)buf);
      if (*(void *)v303)
      {
        uint64_t v195 = *(void *)&v305[2];
        if (*(void *)&v305[2]) {
          (*(void (**)(void, void))(**(void **)v303 + 40))(*(void *)v303, *(void *)&v305[2]);
        }
      }
      unint64_t v30 = v230;
      LODWORD(v61) = v220;
      switch(v288[12])
      {
        case 0:
          goto LABEL_458;
        case 2:
          float32x4_t v196 = v291;
          if (!v291) {
            goto LABEL_458;
          }
          if (*(void *)&v288[24]) {
            *(void *)&v288[24] = 0;
          }
          if (!*(void *)&v288[16]) {
            goto LABEL_458;
          }
LABEL_457:
          (*(void (**)(float *))(*(void *)v196 + 40))(v196);
LABEL_458:
          unsigned int v197 = a3[4];
          if (!*(unsigned char *)(v30 + 1)) {
            goto LABEL_503;
          }
          unsigned int v198 = a3[10];
          if (a3[2] != v198 || (float)((float)v197 / (float)v198) >= 1.2) {
            goto LABEL_503;
          }
          unsigned int v199 = 0;
          *(void *)int32x2_t v288 = 0xFFFFFFFF00000000;
          *(_DWORD *)&v288[8] = -1;
          v288[12] = 0;
          if (v198 - 1 <= 0xFFFFFFFD)
          {
            *(_DWORD *)&v288[8] = v198 - 1;
            unsigned int v199 = v198;
            *(void *)int32x2_t v288 = v198;
          }
          *(_DWORD *)&v288[16] = v199;
          re::internal::makeVertexCacheCoherentMesh((const char **)a3, (const re::GeomMesh *)v288, (re::GeomMesh *)buf);
          re::remapIndexMap((unsigned int *)v288, v223, (uint64_t)v306);
          re::GeomIndexMap::operator=((uint64_t)v223, (uint64_t)v306);
          if (!BYTE4(v306[1])) {
            goto LABEL_474;
          }
          if (BYTE4(v306[1]) == 2)
          {
            uint64_t v201 = *((void *)&v308 + 1);
            if (!*((void *)&v308 + 1)) {
              goto LABEL_474;
            }
            if (v306[3]) {
              v306[3] = 0;
            }
            if (!v306[2]) {
              goto LABEL_474;
            }
LABEL_473:
            (*(void (**)(uint64_t))(*(void *)v201 + 40))(v201);
LABEL_474:
            if (v61)
            {
              uint64_t v202 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)&v245, "vertexAdjacencies");
              *(void *)&v305[2] = 0;
              memset(v303, 0, sizeof(v303));
              re::DynamicArray<float>::resize((uint64_t)v303, v243);
              unint64_t v61 = v243;
              if (v243)
              {
                uint64_t v203 = 0;
                do
                {
                  unsigned int v204 = re::GeomIndexMap::operator[]((uint64_t)v288, v203);
                  unint64_t v27 = v204;
                  unint64_t v30 = *(void *)&v303[16];
                  if (*(void *)&v303[16] <= (unint64_t)v204) {
                    goto LABEL_538;
                  }
                  *(_DWORD *)(*(void *)&v305[2] + 4 * v204) = v203;
                  uint64_t v203 = (v203 + 1);
                }
                while (v61 != v203);
              }
              if ((*(unsigned int (**)(uint64_t))(*(void *)v202 + 16))(v202))
              {
                uint64_t v205 = re::internal::GeomTypedAttribute<float>::operator[](v202, 0);
                unint64_t v27 = (*(unsigned int (**)(uint64_t))(*(void *)v202 + 16))(v202);
              }
              else
              {
                unint64_t v27 = 0;
                uint64_t v205 = 0;
              }
              unsigned int v206 = (*(uint64_t (**)(uint64_t))(*(void *)v202 + 16))(v202);
              if (v206)
              {
                __int16 v207 = 0;
                unint64_t v30 = *(void *)&v303[16];
                uint64_t v208 = *(void *)&v305[2];
                while ((_DWORD *)v27 != v207)
                {
                  unint64_t v61 = *(unsigned int *)(v205 + 4 * (void)v207);
                  if (v30 <= v61) {
                    goto LABEL_540;
                  }
                  *(_DWORD *)(v205 + 4 * (void)v207) = *(_DWORD *)(v208 + 4 * v61);
                  __int16 v207 = (_DWORD *)((char *)v207 + 1);
                  if ((_DWORD *)v206 == v207) {
                    goto LABEL_487;
                  }
                }
                goto LABEL_539;
              }
LABEL_487:
              if (*(void *)v303 && *(void *)&v305[2]) {
                (*(void (**)(void, void))(**(void **)v303 + 40))(*(void *)v303, *(void *)&v305[2]);
              }
              unint64_t v27 = (unint64_t)v225;
            }
            re::GeomMesh::operator=((re::GeomMesh *)a3, (re::GeomMesh *)buf);
            re::GeomMesh::~GeomMesh((re::GeomMesh *)buf);
            switch(v288[12])
            {
              case 0:
                goto LABEL_502;
              case 2:
                float32x4_t v210 = v291;
                if (!v291) {
                  goto LABEL_502;
                }
                if (*(void *)&v288[24]) {
                  *(void *)&v288[24] = 0;
                }
                if (!*(void *)&v288[16]) {
                  goto LABEL_502;
                }
LABEL_501:
                (*(void (**)(float *))(*(void *)v210 + 40))(v210);
LABEL_502:
                unsigned int v197 = a3[4];
LABEL_503:
                BOOL v211 = HasSkinningData;
                if (v197 == *(_DWORD *)(v27 + 16)) {
                  BOOL v211 = 0;
                }
                if (v211) {
                  re::remapSkinningAttributes((re *)a3, (re::GeomMesh *)v27, a4, v60);
                }
                *a6 = 1;
                re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v231);
                return;
              case 1:
                float32x4_t v210 = *(float **)&v288[16];
                if (!*(void *)&v288[16] || !(void)v289) {
                  goto LABEL_502;
                }
                goto LABEL_501;
            }
LABEL_549:
            re::internal::assertLog((re::internal *)4, v209, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
            _os_crash();
            __break(1u);
            goto LABEL_550;
          }
          if (BYTE4(v306[1]) == 1)
          {
            uint64_t v201 = v306[2];
            if (!v306[2] || !(void)v307) {
              goto LABEL_474;
            }
            goto LABEL_473;
          }
LABEL_548:
          re::internal::assertLog((re::internal *)4, v200, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
          _os_crash();
          __break(1u);
          goto LABEL_549;
        case 1:
          float32x4_t v196 = *(float **)&v288[16];
          if (!*(void *)&v288[16] || !(void)v289) {
            goto LABEL_458;
          }
          goto LABEL_457;
      }
LABEL_547:
      re::internal::assertLog((re::internal *)4, v195, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
      _os_crash();
      __break(1u);
      goto LABEL_548;
    }
    if (BYTE4(v306[1]) == 1)
    {
      uint64_t v194 = v306[2];
      if (!v306[2] || !(void)v307) {
        goto LABEL_444;
      }
      goto LABEL_443;
    }
LABEL_546:
    re::internal::assertLog((re::internal *)4, v193, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
    _os_crash();
    __break(1u);
    goto LABEL_547;
  }
  *(void *)&v288[32] = 0;
  memset(v288, 0, 28);
  *(void *)long long buf = 0xFFFFFFFF00000000;
  *(_DWORD *)&uint8_t buf[8] = -1;
  unsigned char buf[12] = 0;
  uint64_t v134 = buf;
  LODWORD(v242) = 0;
  re::DynamicArray<re::TransitionCondition *>::add(v288, &re::GeomAttributeNames::kDefaultNormal);
  re::internal::buildMeshBySplittingFaceVaryingToVertexHelper(a3, (uint64_t)v288, (unint64_t)buf, (unint64_t)a3);
  re::remapIndexMap((unsigned int *)buf, a4, (uint64_t)v306);
  re::GeomIndexMap::operator=((uint64_t)a4, (uint64_t)v306);
  if (!BYTE4(v306[1])) {
    goto LABEL_292;
  }
  if (BYTE4(v306[1]) == 2)
  {
LABEL_287:
    uint64_t v136 = *((void *)&v308 + 1);
    if (*((void *)&v308 + 1))
    {
      if (v306[3]) {
        v306[3] = 0;
      }
      uint64_t v135 = v306[2];
      if (v306[2]) {
        goto LABEL_291;
      }
    }
LABEL_292:
    switch(buf[12])
    {
      case 0u:
        goto LABEL_305;
      case 2u:
        uint64_t v137 = v246;
        if (!v246) {
          goto LABEL_305;
        }
        if (*((void *)&v242 + 1)) {
          *((void *)&v242 + 1) = 0;
        }
        if (!(void)v242) {
          goto LABEL_305;
        }
        int v138 = v134 + 16;
        break;
      case 1u:
        uint64_t v137 = v242;
        if (!(void)v242) {
          goto LABEL_305;
        }
        int v138 = v244;
        if (!v244[0]) {
          goto LABEL_304;
        }
        break;
      default:
        goto LABEL_551;
    }
    (*(void (**)(uint64_t))(*(void *)v137 + 40))(v137);
LABEL_304:
    void *v138 = 0;
LABEL_305:
    if (*(void *)v288 && *(void *)&v288[32]) {
      (*(void (**)(void, void))(**(void **)v288 + 40))(*(void *)v288, *(void *)&v288[32]);
    }
    goto LABEL_308;
  }
  if (BYTE4(v306[1]) == 1)
  {
    uint64_t v136 = v306[2];
    if (!v306[2]) {
      goto LABEL_292;
    }
    uint64_t v135 = v307;
    if (!(void)v307) {
      goto LABEL_292;
    }
LABEL_291:
    (*(void (**)(uint64_t))(*(void *)v136 + 40))(v136);
    goto LABEL_292;
  }
LABEL_550:
  re::internal::assertLog((re::internal *)4, v135, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  _os_crash();
  __break(1u);
LABEL_551:
  re::internal::assertLog((re::internal *)4, v135, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  _os_crash();
  __break(1u);
}

void std::__function::__func<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0,std::allocator<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0>,BOOL ()(unsigned int,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0,std::allocator<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0>,BOOL ()(unsigned int,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_26E715770;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 std::__function::__func<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0,std::allocator<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0>,BOOL ()(unsigned int,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26E715770;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0,std::allocator<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0>,BOOL ()(unsigned int,unsigned int)>::operator()(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a3;
  if (v3)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 48);
    if (v5 <= (int)v3 - 1)
    {
LABEL_36:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    unsigned int v6 = *(_DWORD *)(*(void *)(a1 + 40) + 4 * (v3 - 1));
  }
  else
  {
    unsigned int v6 = 0;
    unsigned int v5 = *(_DWORD *)(a1 + 48);
  }
  if (v5 <= v3) {
    goto LABEL_34;
  }
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = *(unsigned int *)(v7 + 4 * v3);
  if (v4)
  {
    if (v5 <= (int)v4 - 1) {
      goto LABEL_37;
    }
    unsigned int v9 = *(_DWORD *)(v7 + 4 * (v4 - 1));
  }
  else
  {
    unsigned int v9 = 0;
  }
  if (v5 <= v4) {
    goto LABEL_35;
  }
  if (v8 - v6 != *(_DWORD *)(v7 + 4 * v4) - v9) {
    return 0;
  }
  if (v8 != v6)
  {
    unsigned int v10 = *(_DWORD *)(a1 + 16);
    if (v6 <= v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = v6;
    }
    uint64_t v12 = *(void *)(a1 + 8);
    unint64_t v13 = *(unsigned int *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 24);
    if (v6 <= v13) {
      uint64_t v15 = *(unsigned int *)(a1 + 32);
    }
    else {
      uint64_t v15 = v6;
    }
    uint64_t v16 = (_DWORD *)(v14 + 4 * v6);
    uint64_t v17 = v8 - v6;
    unsigned int v18 = (float *)(v12 + 4 * v6);
    uint64_t v19 = v15 - v6;
    for (uint64_t i = v11 - v6; i; --i)
    {
      if (v10 <= v9) {
        goto LABEL_31;
      }
      if (*v18 != *(float *)(v12 + 4 * v9)) {
        return 0;
      }
      if (!v19) {
        goto LABEL_32;
      }
      if (v13 <= v9) {
        goto LABEL_33;
      }
      if (*v16 != *(_DWORD *)(v14 + 4 * v9)) {
        return 0;
      }
      ++v16;
      ++v18;
      --v19;
      if (!--v17) {
        return 1;
      }
    }
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_31:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_32:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_33:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_34:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_35:
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_36;
  }
  return 1;
}

uint64_t std::__function::__func<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0,std::allocator<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0>,BOOL ()(unsigned int,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0,std::allocator<re::makeConditionedMeshForGPU(re::GeomMesh const&,re::MeshCompileOptions const&,re::GeomMesh&,re::GeomIndexMap &,re::GeomIndexMap &)::$_0>,BOOL ()(unsigned int,unsigned int)>::target_type()
{
}

void re::loadGeomSceneFromFile(const char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v24, 4502, 0);
  memset(v15, 0, sizeof(v15));
  long long v17 = 0u;
  long long v18 = 0u;
  int v16 = 0;
  int v19 = 0;
  memset(v20, 0, sizeof(v20));
  int v21 = 0;
  memset(v22, 0, sizeof(v22));
  uint64_t v23 = 0x7FFFFFFFLL;
  if (re::convertMDLAssetToGeomScene(a1, (uint64_t)v15, (unsigned char *)(a2 + 16)))
  {
    re::types::Ok<re::GeomScene>::Ok((uint64_t)v7, v15);
    re::Result<re::GeomScene,re::Error>::Result(a3, (uint64_t)v7);
    re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v14);
    re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v13);
    if (v8)
    {
      if (v12) {
        (*(void (**)(void))(*(void *)v8 + 40))();
      }
      uint64_t v12 = 0;
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t v8 = 0;
      ++v11;
    }
    re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)v7);
  }
  else
  {
    unsigned int v6 = std::system_category();
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = v6;
  }
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v22[8]);
  re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v20[1]);
  if (*((void *)&v17 + 1))
  {
    if (v20[0]) {
      (*(void (**)(void))(**((void **)&v17 + 1) + 40))();
    }
    v20[0] = 0;
    long long v18 = 0uLL;
    *((void *)&v17 + 1) = 0;
    ++v19;
  }
  re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)v15);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v24);
}

void re::makeMeshAssetDataFromGeomScene(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v323 = *MEMORY[0x263EF8340];
  unsigned int v5 = re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v212, 4506, 0);
  long long v200 = 0uLL;
  uint64_t v199 = 0;
  int v201 = 0;
  uint64_t v211 = 0;
  long long v6 = 0uLL;
  long long v202 = 0u;
  long long v203 = 0u;
  long long v205 = 0u;
  long long v206 = 0u;
  int v204 = 0;
  int v207 = 0;
  long long v208 = 0u;
  long long v209 = 0u;
  int v210 = 0;
  unsigned int v165 = a1;
  unint64_t v7 = a1[12];
  if (v7)
  {
    unsigned int v5 = (_anonymous_namespace_ *)re::DynamicArray<re::MeshAssetSkeleton>::setCapacity((void *)&v205 + 1, v7);
    long long v6 = 0uLL;
  }
  int v197 = 0;
  v196[0] = v6;
  v196[1] = v6;
  uint64_t v198 = 0x7FFFFFFFLL;
  if ((2 * v7) <= 1) {
    signed int v8 = 1;
  }
  else {
    signed int v8 = 2 * v7;
  }
  uint64_t v9 = v165[12];
  if (v9)
  {
    uint64_t v10 = v165[14] + 64;
    uint64_t v3 = 160 * v9;
    do
    {
      re::UniqueNameGenerator::uniqueName((re::UniqueNameGenerator *)v196, *(const char **)(v10 - 56), "MeshSkeleton", (re::StringID *)v221);
      re::FixedArray<re::StringID>::FixedArray((unint64_t *)&v221[1], v10 - 48);
      re::FixedArray<unsigned int>::FixedArray((uint64_t *)&v222 + 1, v10 - 24);
      re::FixedArray<re::GenericSRT<float>>::FixedArray(v224, v10);
      re::FixedArray<re::Matrix4x4<float>>::FixedArray((uint64_t *)&v224[24], v10 + 24);
      re::DynamicArray<re::MeshAssetSkeleton>::add((void *)&v205 + 1, (uint64_t *)v221);
      if (*(void *)&v224[24])
      {
        if (*(void *)&v224[32])
        {
          (*(void (**)(void))(**(void **)&v224[24] + 40))();
          *(void *)&v224[32] = 0;
          *(void *)&v224[40] = 0;
        }
        *(void *)&v224[24] = 0;
      }
      if (*(void *)v224)
      {
        if (*(void *)&v224[8])
        {
          (*(void (**)(void))(**(void **)v224 + 40))();
          *(void *)&v224[8] = 0;
          *(void *)&v224[16] = 0;
        }
        *(void *)int v224 = 0;
      }
      if (*((void *)&v222 + 1))
      {
        if ((void)v223)
        {
          (*(void (**)(void))(**((void **)&v222 + 1) + 40))();
          long long v223 = 0uLL;
        }
        *((void *)&v222 + 1) = 0;
      }
      re::FixedArray<re::StringID>::deinit(&v221[1]);
      re::StringID::destroyString((re::StringID *)v221);
      v10 += 160;
      v3 -= 160;
    }
    while (v3);
  }
  unint64_t v11 = (unint64_t)v282;
  unint64_t v12 = (unint64_t)v221;
  unint64_t v13 = v165[2];
  re::DynamicArray<re::MeshAssetModel>::resize((uint64_t)&v199, v13);
  int v194 = 0;
  memset(v193, 0, sizeof(v193));
  uint64_t v195 = 0x7FFFFFFFLL;
  if ((2 * v13) <= 1) {
    signed int v15 = 1;
  }
  else {
    signed int v15 = 2 * v13;
  }
  int v16 = v165;
  uint64_t v17 = a2;
  unint64_t v161 = v13;
  if (v13)
  {
    unint64_t v18 = 0;
    int32x4_t v176 = vdupq_n_s32(0x7F800000u);
    do
    {
      unint64_t v19 = v16[2];
      if (v19 <= v18) {
        goto LABEL_313;
      }
      unint64_t v19 = *((void *)&v200 + 1);
      if (*((void *)&v200 + 1) <= v18) {
        goto LABEL_314;
      }
      unint64_t v20 = v16[4];
      unint64_t v163 = v18;
      uint64_t v21 = v20 + 152 * v18;
      uint64_t v159 = v202;
      *(_OWORD *)uint64_t v191 = *(_OWORD *)v17;
      *(void *)&v191[13] = *(void *)(v17 + 13);
      re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)v192, a2 + 24);
      unint64_t v22 = *(void *)(v21 + 8);
      if (v22) {
        unint64_t v23 = v22 >> 1;
      }
      else {
        unint64_t v23 = v22 >> 1;
      }
      if (v23)
      {
        unint64_t v24 = re::Hash<re::DynamicString>::operator()((uint64_t)v221, v21);
        if (*(void *)(a2 + 72))
        {
          uint64_t v25 = *(unsigned int *)(*(void *)(a2 + 80) + 4 * (v24 % *(unsigned int *)(a2 + 96)));
          if (v25 != 0x7FFFFFFF)
          {
            unint64_t v12 = *(void *)(a2 + 88);
            while (1)
            {
              unint64_t v13 = 120;
              if (re::DynamicString::operator==(v12 + 120 * v25 + 16, v21)) {
                break;
              }
              uint64_t v25 = *(_DWORD *)(v12 + 120 * v25 + 8) & 0x7FFFFFFF;
              if (v25 == 0x7FFFFFFF) {
                goto LABEL_46;
              }
            }
            unint64_t v26 = re::Hash<re::DynamicString>::operator()((uint64_t)v221, v21);
            if (*(void *)(a2 + 72))
            {
              uint64_t v27 = *(void *)(a2 + 88);
              unint64_t v12 = *(unsigned int *)(*(void *)(a2 + 80) + 4 * (v26 % *(unsigned int *)(a2 + 96)));
              for (BOOL i = v12 == 0x7FFFFFFF; !i; BOOL i = v12 == 0x7FFFFFFF)
              {
                unint64_t v13 = 120;
                if (re::DynamicString::operator==(v27 + 120 * v12 + 16, v21)) {
                  goto LABEL_45;
                }
                unint64_t v12 = *(_DWORD *)(v27 + 120 * v12 + 8) & 0x7FFFFFFF;
              }
              unint64_t v12 = 0x7FFFFFFFLL;
            }
            else
            {
              uint64_t v27 = *(void *)(a2 + 88);
              unint64_t v12 = 0x7FFFFFFFLL;
            }
LABEL_45:
            uint64_t v29 = v27 + 120 * v12;
            long long v30 = *(_OWORD *)(v29 + 48);
            *(void *)&v191[13] = *(void *)(v29 + 61);
            *(_OWORD *)uint64_t v191 = v30;
            re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v192, v29 + 72);
          }
        }
      }
LABEL_46:
      unint64_t v31 = v20 + 152 * v163;
      unint64_t v32 = *(void *)(v31 + 48);
      unsigned int v166 = (unint64_t *)(v31 + 48);
      uint64_t v168 = v32;
      *(void *)long long v282 = 0;
      *(void *)&v282[8] = "";
      *(int32x4_t *)&v282[16] = v176;
      *(void *)&long long v33 = 0x7F0000007FLL;
      *((void *)&v33 + 1) = 0x7F0000007FLL;
      *(_OWORD *)&v282[32] = v33;
      uint64_t v315 = 0;
      long long v283 = 0u;
      long long v284 = 0u;
      long long v285 = 0u;
      long long v286 = 0u;
      memset(v287, 0, 28);
      long long v288 = 0u;
      long long v289 = 0u;
      int v290 = 0;
      long long v291 = 0u;
      long long v292 = 0u;
      int v293 = 0;
      long long v294 = 0u;
      long long v295 = 0u;
      int v296 = 0;
      int v299 = 0;
      long long v297 = 0u;
      long long v298 = 0u;
      int v302 = 0;
      long long v300 = 0u;
      long long v301 = 0u;
      int v305 = 0;
      long long v303 = 0u;
      long long v304 = 0u;
      int v308 = 0;
      long long v306 = 0u;
      long long v307 = 0u;
      int v311 = 0;
      long long v309 = 0u;
      long long v310 = 0u;
      long long v312 = 0u;
      long long v313 = 0u;
      int v314 = 0;
      if (*(void *)(v21 + 8)) {
        uint64_t v34 = *(const char **)(v21 + 16);
      }
      else {
        uint64_t v34 = (const char *)(v21 + 9);
      }
      re::UniqueNameGenerator::uniqueName((re::UniqueNameGenerator *)v193, v34, "MeshModel", (re::StringID *)v279);
      long long v35 = *(_OWORD *)v279;
      *(void *)&v279[8] = "";
      *(void *)long long v279 = 0;
      long long v36 = *(_OWORD *)v282;
      *(_OWORD *)long long v282 = v35;
      *(void *)&v247[8] = *((void *)&v36 + 1);
      *(void *)uint64_t v247 = v35 & 0xFFFFFFFFFFFFFFFELL | v36 & 1;
      re::StringID::destroyString((re::StringID *)v247);
      re::StringID::destroyString((re::StringID *)v279);
      unsigned int v39 = v32 - 1;
      if (v32 == 1)
      {
        if (!*v166) {
          goto LABEL_319;
        }
        unint64_t v182 = v20;
        unint64_t v11 = *(void *)(v20 + 152 * v163 + 64);
        unsigned int v40 = *(_DWORD *)(v11 + 48);
      }
      else
      {
        if (!v32)
        {
          LOBYTE(v221[0]) = 0;
          *(void *)&v221[1] = 100;
          *((void *)&v221[1] + 1) = re::AssetErrorCategory(void)::instance;
          long long v222 = *(_OWORD *)v247;
          long long v223 = *(_OWORD *)&v247[16];
          goto LABEL_237;
        }
        re::DynamicArray<re::MeshLodLevelInfo>::resize((uint64_t)&v297 + 8, v32);
        uint64_t v41 = 0;
        unsigned int v42 = 0;
        unint64_t v43 = v20;
        unint64_t v20 = *v166;
        unint64_t v182 = v43;
        unint64_t v11 = *(void *)(v43 + 152 * v163 + 64);
        unint64_t v19 = *((void *)&v298 + 1);
        uint64_t v44 = v300;
        uint64_t v45 = (unsigned int *)(v300 + 8);
        uint64_t v46 = 48;
        do
        {
          if (v20 == v41) {
            goto LABEL_296;
          }
          if (v19 == v41)
          {
LABEL_297:
            *(void *)int v274 = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v279 = 136315906;
            *(void *)&v279[4] = "operator[]";
            *(_WORD *)&v279[12] = 1024;
            *(_DWORD *)&v279[14] = 789;
            *(_WORD *)&v279[18] = 2048;
            *(void *)&v279[20] = v19;
            *(_WORD *)&v279[28] = 2048;
            *(void *)&v279[30] = v19;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_298;
          }
          v42 += *(_DWORD *)(v11 + v46);
          *uint64_t v45 = v42;
          v45 += 3;
          ++v41;
          v46 += 248;
        }
        while (v32 != v41);
        unsigned int v40 = v42;
        unint64_t v13 = *(void *)(v182 + 152 * v163 + 128);
        if (v39 != v13) {
          goto LABEL_80;
        }
        if (v13 >= 2)
        {
          int v54 = *(float **)(v182 + 152 * v163 + 144);
          float v55 = v54[1];
          if (*v54 < v55) {
            goto LABEL_80;
          }
          uint64_t v137 = 2;
          do
          {
            if (v13 == v137) {
              goto LABEL_60;
            }
            float v138 = v54[v137++];
            BOOL v139 = v55 < v138;
            float v55 = v138;
          }
          while (!v139);
          if (v137 - 1 < v13)
          {
LABEL_80:
            unsigned int v56 = 0;
            unsigned __int16 v57 = 0;
            while (1)
            {
              unint64_t v12 = v57;
              if (v19 <= v57) {
                break;
              }
              *(float *)(v44 + 12 * v57++) = (float)(1.0 / (float)(v56 + 2)) * (float)(1.0 / (float)(v56 + 2));
              unsigned int v56 = (unsigned __int16)(v12 + 1);
              if (v56 >= v32) {
                goto LABEL_87;
              }
            }
LABEL_298:
            *(void *)int v274 = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v279 = 136315906;
            *(void *)&v279[4] = "operator[]";
            *(_WORD *)&v279[12] = 1024;
            *(_DWORD *)&v279[14] = 789;
            *(_WORD *)&v279[18] = 2048;
            *(void *)&v279[20] = v12;
            *(_WORD *)&v279[28] = 2048;
            *(void *)&v279[30] = v19;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_299:
            *(void *)int v274 = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v279 = 136315906;
            *(void *)&v279[4] = "operator[]";
            *(_WORD *)&v279[12] = 1024;
            *(_DWORD *)&v279[14] = 789;
            *(_WORD *)&v279[18] = 2048;
            *(void *)&v279[20] = v12;
            *(_WORD *)&v279[28] = 2048;
            *(void *)&v279[30] = v19;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_300:
            *(void *)&v213[0] = 0;
            memset(v247, 0, 80);
            unsigned int v72 = &_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v274 = 136315906;
            *(void *)&v274[4] = "operator[]";
            __int16 v275 = 1024;
            *(_DWORD *)long long v276 = 601;
            *(_WORD *)&v276[4] = 2048;
            *(void *)&v276[6] = 1;
            *(_WORD *)&v276[14] = 2048;
            *(void *)&v276[16] = 1;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_301:
            *(void *)&v213[0] = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v274 = 136315906;
            *(void *)&v274[4] = "operator[]";
            __int16 v275 = 1024;
            *(_DWORD *)long long v276 = 601;
            *(_WORD *)&v276[4] = 2048;
            *(void *)&v276[6] = 2;
            *(_WORD *)&v276[14] = 2048;
            *(void *)&v276[16] = v72;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_302:
            *(void *)&v213[0] = 0;
            memset(v247, 0, 80);
            unint64_t v104 = &_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v274 = 136315906;
            *(void *)&v274[4] = "operator[]";
            __int16 v275 = 1024;
            *(_DWORD *)long long v276 = 601;
            *(_WORD *)&v276[4] = 2048;
            *(void *)&v276[6] = 3;
            *(_WORD *)&v276[14] = 2048;
            *(void *)&v276[16] = 3;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_303:
            *(void *)int v274 = 0;
            memset(v247, 0, 80);
            unint64_t v19 = &_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v279 = 136315906;
            *(void *)&v279[4] = "operator[]";
            *(_WORD *)&v279[12] = 1024;
            *(_DWORD *)&v279[14] = 797;
            *(_WORD *)&v279[18] = 2048;
            *(void *)&v279[20] = v12;
            *(_WORD *)&v279[28] = 2048;
            *(void *)&v279[30] = v104;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_304;
          }
        }
LABEL_60:
        if (v13)
        {
          uint64_t v47 = *(float **)(v182 + 152 * v163 + 144);
          BOOL v48 = *v47 >= 0.0 && *v47 <= 1.0;
          if (!v48) {
            goto LABEL_80;
          }
          uint64_t v49 = 1;
          do
          {
            if (v13 == v49) {
              goto LABEL_73;
            }
            float v50 = v47[v49++];
          }
          while (v50 >= 0.0 && v50 <= 1.0);
          if (v49 - 1 < v13) {
            goto LABEL_80;
          }
LABEL_73:
          uint64_t v52 = v300;
          if (v13)
          {
            unsigned __int16 v53 = 0;
            unint64_t v12 = *((void *)&v298 + 1);
            while (1)
            {
              uint64_t v3 = v53;
              if (v13 <= v53) {
                goto LABEL_317;
              }
              if (v12 <= v53) {
                goto LABEL_318;
              }
              *(float *)(v52 + 12 * v53) = v47[v53];
              ++v53;
              if (v13 <= (unsigned __int16)(v3 + 1)) {
                goto LABEL_86;
              }
            }
          }
        }
        else
        {
          uint64_t v52 = v300;
        }
        unint64_t v12 = v19;
LABEL_86:
        *(_DWORD *)(v52 + 12 * v12 - 12) = 0;
LABEL_87:
        unint64_t v13 = *(void *)(v182 + 152 * v163 + 88);
        if (v39 != v13) {
          goto LABEL_96;
        }
        if (v13 >= 2)
        {
          unint64_t v61 = *(float **)(v182 + 152 * v163 + 104);
          float v62 = v61[1];
          if (*v61 > v62) {
            goto LABEL_96;
          }
          uint64_t v140 = 2;
          do
          {
            if (v13 == v140) {
              goto LABEL_89;
            }
            float v141 = v61[v140++];
            BOOL v48 = v62 <= v141;
            float v62 = v141;
          }
          while (v48);
          if (v140 - 1 < v13)
          {
LABEL_96:
            unsigned int v63 = 0;
            unsigned __int16 v64 = 0;
            while (1)
            {
              unint64_t v12 = v64;
              if (v19 <= v64) {
                goto LABEL_299;
              }
              if (v63 > 4) {
                float v65 = (float)((unint64_t)(100 * v63) - 300);
              }
              else {
                float v65 = __const__ZN2re29computeDefaultLodMaxViewDepthEjj_kViewDepthTable[v63];
              }
              *(float *)(v44 + 12 * v64++ + 4) = v65;
              unsigned int v63 = (unsigned __int16)(v12 + 1);
              if (v63 >= v32) {
                goto LABEL_102;
              }
            }
          }
        }
LABEL_89:
        uint64_t v58 = v300;
        unint64_t v32 = *((void *)&v298 + 1);
        if (v39)
        {
          unsigned __int16 v59 = 0;
          uint64_t v60 = *(void *)(v182 + 152 * v163 + 104);
          do
          {
            unint64_t v19 = v59;
            if (v13 <= v59) {
              goto LABEL_311;
            }
            if (v32 <= v59) {
              goto LABEL_312;
            }
            *(_DWORD *)(v58 + 12 * v59 + 4) = *(_DWORD *)(v60 + 4 * v59);
            ++v59;
          }
          while (v39 > (unsigned __int16)(v19 + 1));
        }
        *(_DWORD *)(v58 + 12 * v32 - 8) = 2139095040;
LABEL_102:
        if (!v20) {
          goto LABEL_315;
        }
      }
      unsigned int v180 = v40;
      unint64_t v13 = *(void *)(v11 + 48);
      if (v13)
      {
        unint64_t v20 = 0;
        v66.i64[0] = 0x7F0000007FLL;
        v66.i64[1] = 0x7F0000007FLL;
        unint64_t v32 = 1;
        float32x4_t v67 = (float32x4_t)v176;
        while (1)
        {
          unint64_t v19 = *(void *)(v11 + 48);
          if (v19 <= v20) {
            goto LABEL_295;
          }
          float32x4_t v185 = v67;
          float32x4_t v188 = v66;
          unint64_t v12 = *(void *)(v11 + 64);
          uint64_t v3 = 736;
          BOOL HasSkinningData = re::meshHasSkinningData((re *)(v12 + 736 * v20), v38);
          re::computeAABB((re *)(v12 + 736 * v20), &v216);
          if (HasSkinningData)
          {
            uint64_t v69 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(v12 + 736 * v20 + 64), "skinnedAnimationGeometryBindTransform");
            if (!(*(unsigned int (**)(uint64_t))(*(void *)v69 + 16))(v69)) {
              goto LABEL_324;
            }
            uint64_t v70 = (_OWORD *)re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[](v69, 0);
            unsigned int v71 = (*(uint64_t (**)(uint64_t))(*(void *)v69 + 16))(v69);
            if (v71 == 1) {
              goto LABEL_300;
            }
            unsigned int v72 = v71;
            if (!v71) {
              goto LABEL_324;
            }
            if (v71 <= 2) {
              goto LABEL_301;
            }
            if (v71 == 3) {
              goto LABEL_302;
            }
            long long v73 = v70[1];
            long long v74 = v70[2];
            long long v75 = v70[3];
            *(_OWORD *)long long v279 = *v70;
            *(_OWORD *)&v279[16] = v73;
            *(_OWORD *)&v279[32] = v74;
            long long v280 = v75;
            re::AABB::transform(&v216, (float32x4_t *)v279, (uint64_t)v247);
            float32x4_t v76 = v185;
            v76.i32[3] = 0;
            float32x4_t v77 = *(float32x4_t *)v247;
            float32x4_t v78 = *(float32x4_t *)&v247[16];
          }
          else
          {
            float32x4_t v76 = v185;
            v76.i32[3] = 0;
            float32x4_t v77 = v216;
            float32x4_t v78 = v217;
          }
          v77.i32[3] = 0;
          float32x4_t v67 = vminnmq_f32(v76, v77);
          float32x4_t v79 = v188;
          v79.i32[3] = 0;
          v78.i32[3] = 0;
          float32x4_t v66 = vmaxnmq_f32(v79, v78);
          unint64_t v20 = v32;
          BOOL v48 = v13 > v32;
          unint64_t v32 = (v32 + 1);
          if (!v48) {
            goto LABEL_117;
          }
        }
      }
      v66.i64[0] = 0x7F0000007FLL;
      v66.i64[1] = 0x7F0000007FLL;
      float32x4_t v67 = (float32x4_t)v176;
LABEL_117:
      *(float32x4_t *)&v282[16] = v67;
      *(float32x4_t *)&v282[32] = v66;
      if (!*v166) {
        goto LABEL_316;
      }
      uint64_t v164 = v182 + 152 * v163 + 64;
      uint64_t v80 = *(void *)v164;
      uint64_t v81 = *(void *)(*(void *)v164 + 48);
      if (v81)
      {
        LODWORD(v82) = 0;
        uint64_t v83 = 736 * v81;
        uint64_t v84 = (_DWORD *)(*(void *)(v80 + 64) + 16);
        do
        {
          unint64_t v82 = (*v84 + v82);
          v84 += 184;
          v83 -= 736;
        }
        while (v83);
      }
      else
      {
        unint64_t v82 = 0;
      }
      *(void *)&v279[32] = 0;
      memset(v279, 0, 28);
      re::DynamicArray<re::Vector3<float>>::resize((uint64_t)v279, v82);
      uint64_t v86 = *(void *)(v80 + 48);
      if (v86)
      {
        unint64_t v11 = 0;
        unint64_t v87 = *(unsigned int **)(v80 + 64);
        unint64_t v13 = (unint64_t)&v87[184 * v86];
        do
        {
          unint64_t v32 = re::meshHasSkinningData((re *)v87, v85);
          uint64_t v3 = v87[4];
          unint64_t v19 = re::GeomMesh::accessVertexPositions((re::GeomMesh *)v87);
          unint64_t v12 = (unint64_t)v85;
          if (v32)
          {
            unint64_t v32 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(v87 + 16), "skinnedAnimationGeometryBindTransform");
            if (!(*(unsigned int (**)(unint64_t))(*(void *)v32 + 16))(v32)) {
              goto LABEL_325;
            }
            unint64_t v20 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[](v32, 0);
            uint64_t v88 = (*(uint64_t (**)(unint64_t))(*(void *)v32 + 16))(v32);
            if (v88 == 1) {
              goto LABEL_308;
            }
            unint64_t v32 = v88;
            if (!v88) {
              goto LABEL_325;
            }
            if (v88 <= 2) {
              goto LABEL_309;
            }
            if (v88 == 3) {
              goto LABEL_310;
            }
            if (v3)
            {
              float32x4_t v89 = *(float32x4_t *)v20;
              float32x4_t v90 = *(float32x4_t *)(v20 + 16);
              float32x4_t v91 = *(float32x4_t *)(v20 + 32);
              float32x4_t v92 = *(float32x4_t *)(v20 + 48);
              unint64_t v12 = v12;
              uint64_t v93 = v12;
              while (v93)
              {
                unint64_t v32 = v11;
                unint64_t v20 = *(void *)&v279[16];
                if (*(void *)&v279[16] <= (unint64_t)v11) {
                  goto LABEL_290;
                }
                unint64_t v11 = (v11 + 1);
                float32x4_t v94 = *(float32x4_t *)v19;
                v19 += 16;
                float32x4_t v95 = vaddq_f32(v92, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v89, v94.f32[0]), v90, *(float32x2_t *)v94.f32, 1), v91, v94, 2));
                *(float32x4_t *)(*(void *)&v279[32] + 16 * v32) = vdivq_f32(v95, (float32x4_t)vdupq_laneq_s32((int32x4_t)v95, 3));
                --v93;
                if (!--v3) {
                  goto LABEL_142;
                }
              }
              goto LABEL_289;
            }
          }
          else if (v3)
          {
            unint64_t v12 = v85;
            uint64_t v96 = v85;
            while (1)
            {
              if (!v96) {
                goto LABEL_287;
              }
              unint64_t v32 = v11;
              unint64_t v20 = *(void *)&v279[16];
              if (*(void *)&v279[16] <= (unint64_t)v11) {
                break;
              }
              unint64_t v11 = (v11 + 1);
              float32x4_t v97 = *(float32x4_t *)v19;
              v19 += 16;
              *(float32x4_t *)(*(void *)&v279[32] + 16 * v32) = v97;
              --v96;
              if (!--v3) {
                goto LABEL_142;
              }
            }
LABEL_288:
            v216.i64[0] = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v274 = 136315906;
            *(void *)&v274[4] = "operator[]";
            __int16 v275 = 1024;
            *(_DWORD *)long long v276 = 789;
            *(_WORD *)&v276[4] = 2048;
            *(void *)&v276[6] = v32;
            *(_WORD *)&v276[14] = 2048;
            *(void *)&v276[16] = v20;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_289:
            v216.i64[0] = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v274 = 136315906;
            *(void *)&v274[4] = "operator[]";
            __int16 v275 = 1024;
            *(_DWORD *)long long v276 = 601;
            *(_WORD *)&v276[4] = 2048;
            *(void *)&v276[6] = v12;
            *(_WORD *)&v276[14] = 2048;
            *(void *)&v276[16] = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_290:
            v216.i64[0] = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v274 = 136315906;
            *(void *)&v274[4] = "operator[]";
            __int16 v275 = 1024;
            *(_DWORD *)long long v276 = 789;
            *(_WORD *)&v276[4] = 2048;
            *(void *)&v276[6] = v32;
            *(_WORD *)&v276[14] = 2048;
            *(void *)&v276[16] = v20;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_291:
            *(void *)float32x2_t v316 = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v274 = 136315906;
            *(void *)&v274[4] = "operator[]";
            __int16 v275 = 1024;
            *(_DWORD *)long long v276 = 797;
            *(_WORD *)&v276[4] = 2048;
            *(void *)&v276[6] = v20;
            *(_WORD *)&v276[14] = 2048;
            *(void *)&v276[16] = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_292:
            uint64_t v220 = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)float32x2_t v316 = 136315906;
            *(void *)&v316[4] = "operator[]";
            __int16 v317 = 1024;
            int v318 = 797;
            __int16 v319 = 2048;
            unint64_t v320 = v20;
            __int16 v321 = 2048;
            unint64_t v322 = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_293:
            uint64_t v220 = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)float32x2_t v316 = 136315906;
            *(void *)&v316[4] = "operator[]";
            __int16 v317 = 1024;
            int v318 = 797;
            __int16 v319 = 2048;
            unint64_t v320 = v20;
            __int16 v321 = 2048;
            unint64_t v322 = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_294:
            *(void *)int v274 = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v279 = 136315906;
            *(void *)&v279[4] = "operator[]";
            *(_WORD *)&v279[12] = 1024;
            *(_DWORD *)&v279[14] = 797;
            *(_WORD *)&v279[18] = 2048;
            *(void *)&v279[20] = v20;
            *(_WORD *)&v279[28] = 2048;
            *(void *)&v279[30] = v32;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_295:
            *(void *)int v274 = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v279 = 136315906;
            *(void *)&v279[4] = "operator[]";
            *(_WORD *)&v279[12] = 1024;
            *(_DWORD *)&v279[14] = 797;
            *(_WORD *)&v279[18] = 2048;
            *(void *)&v279[20] = v20;
            *(_WORD *)&v279[28] = 2048;
            *(void *)&v279[30] = v19;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_296:
            *(void *)int v274 = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v279 = 136315906;
            *(void *)&v279[4] = "operator[]";
            *(_WORD *)&v279[12] = 1024;
            *(_DWORD *)&v279[14] = 797;
            *(_WORD *)&v279[18] = 2048;
            *(void *)&v279[20] = v20;
            *(_WORD *)&v279[28] = 2048;
            *(void *)&v279[30] = v20;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_297;
          }
LABEL_142:
          v87 += 184;
        }
        while (v87 != (unsigned int *)v13);
      }
      MEMORY[0x237DBD720](*(void *)&v279[16], *(void *)&v279[32]);
      float v102 = *(_anonymous_namespace_ **)v279;
      if (*(void *)v279 && *(void *)&v279[32])
      {
        long long v186 = v99;
        long long v189 = v98;
        long long v183 = v100;
        long long v178 = v101;
        float v102 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)v279 + 40))();
        long long v101 = v178;
        long long v100 = v183;
        long long v99 = v186;
        long long v98 = v189;
      }
      long long v283 = v98;
      long long v284 = v99;
      long long v285 = v100;
      long long v286 = v101;
      unint64_t v175 = v180;
      if ((unint64_t)v292 < v180) {
        float v102 = (_anonymous_namespace_ *)re::DynamicArray<re::MeshAssetPart>::setCapacity((void *)&v291 + 1, v180);
      }
      int v218 = 0;
      float32x4_t v217 = 0u;
      float32x4_t v216 = 0u;
      uint64_t v219 = 0x7FFFFFFFLL;
      int v214 = 0;
      memset(v213, 0, sizeof(v213));
      if (2 * v180 <= 1) {
        signed int v103 = 1;
      }
      else {
        signed int v103 = 2 * v180;
      }
      uint64_t v215 = 0x7FFFFFFFLL;
      if (v168)
      {
        unint64_t v12 = 0;
        while (1)
        {
          unint64_t v104 = *v166;
          if (*v166 <= v12) {
            goto LABEL_303;
          }
          unint64_t v167 = v12;
          uint64_t v105 = *(void *)v164 + 248 * v12;
          uint64_t v184 = *(void *)(v105 + 224);
          unint64_t v171 = (unint64_t *)(v105 + 224);
          uint64_t v3 = *(void *)(v105 + 48);
          uint64_t v190 = (unint64_t *)(v105 + 48);
          if (v3) {
            break;
          }
LABEL_231:
          unint64_t v12 = v167 + 1;
          if (v167 + 1 == v168) {
            goto LABEL_232;
          }
        }
        unint64_t v20 = 0;
        int v181 = *(unsigned __int8 *)(v105 + 112);
        uint64_t v106 = *(void *)v164 + 248 * v12;
        unsigned int v187 = (unint64_t *)(v106 + 64);
        unint64_t v170 = v3 * v12;
        uint64_t v169 = (void *)(v106 + 240);
        int v179 = *(unsigned __int8 *)(v105 + 160);
        uint64_t v174 = v106 + 120;
        uint64_t v173 = v106 + 168;
        uint64_t v177 = (unint64_t *)(v106 + 88);
        v172 = (void *)(v106 + 104);
        while (2)
        {
          unint64_t v19 = *v190;
          if (*v190 <= v20)
          {
            *(void *)int v274 = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v279 = 136315906;
            *(void *)&v279[4] = "operator[]";
            *(_WORD *)&v279[12] = 1024;
            *(_DWORD *)&v279[14] = 797;
            *(_WORD *)&v279[18] = 2048;
            *(void *)&v279[20] = v20;
            *(_WORD *)&v279[28] = 2048;
            *(void *)&v279[30] = v19;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_287:
            v216.i64[0] = 0;
            memset(v247, 0, 80);
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)int v274 = 136315906;
            *(void *)&v274[4] = "operator[]";
            __int16 v275 = 1024;
            *(_DWORD *)long long v276 = 601;
            *(_WORD *)&v276[4] = 2048;
            *(void *)&v276[6] = v12;
            *(_WORD *)&v276[14] = 2048;
            *(void *)&v276[16] = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_288;
          }
          unint64_t v11 = *v187;
          unint64_t v13 = *v187 + 736 * v20;
          unint64_t v12 = v13 + 40;
          if (!*(_DWORD *)(v13 + 40)) {
            goto LABEL_230;
          }
          long long v253 = 0u;
          *(void *)&v247[88] = 0;
          memset(v247, 0, 80);
          v247[44] = 1;
          *(_DWORD *)&v247[52] = 1;
          *(_WORD *)&v247[56] = -1;
          *(void *)&v247[80] = "";
          *(int32x4_t *)&v247[96] = v176;
          *(void *)&long long v107 = 0x7F0000007FLL;
          *((void *)&v107 + 1) = 0x7F0000007FLL;
          *(_OWORD *)&v247[112] = v107;
          *(void *)&v252[16] = 0x7FFFFFFF00000000;
          long long v251 = 0u;
          *(_OWORD *)uint64_t v252 = 0u;
          *(_OWORD *)&v247[128] = 0u;
          long long v248 = 0u;
          long long v249 = 0u;
          memset(v250, 0, sizeof(v250));
          re::DynamicArray<re::MeshAssetPart>::add((_anonymous_namespace_ *)((char *)&v291 + 8), (uint64_t)v247);
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v251);
          re::StringID::destroyString((re::StringID *)&v247[72]);
          re::DynamicArray<re::MeshAssetBuffer>::deinit((uint64_t)v247);
          unint64_t v19 = re::meshHasSkinningData((re *)v13, v108);
          if (v19)
          {
            if ((unint64_t)v289 < v175) {
              re::DynamicArray<re::MeshAssetSkinningData>::setCapacity((void *)&v288 + 1, v175);
            }
            for (unint64_t j = *((void *)&v289 + 1); j <= v20 + v170; ++j)
            {
              *(void *)uint64_t v247 = 0xFFFFFFFFLL;
              memset(&v247[8], 0, 136);
              __n128 v111 = re::DynamicArray<re::MeshAssetSkinningData>::add((_anonymous_namespace_ *)((char *)&v288 + 8), (uint64_t)v247);
              if (*(void *)&v247[56])
              {
                if (*(void *)&v247[64])
                {
                  (*(void (**)(__n128))(**(void **)&v247[56] + 40))(v111);
                  *(_OWORD *)&v247[64] = 0uLL;
                }
                *(void *)&v247[56] = 0;
              }
              if (*(void *)&v247[32])
              {
                if (*(void *)&v247[40])
                {
                  (*(void (**)(__n128))(**(void **)&v247[32] + 40))(v111);
                  *(void *)&v247[40] = 0;
                  *(void *)&v247[48] = 0;
                }
                *(void *)&v247[32] = 0;
              }
              if (*(void *)&v247[8] && *(void *)&v247[16]) {
                (*(void (**)(__n128))(**(void **)&v247[8] + 40))(v111);
              }
            }
          }
          if (v184 == v3)
          {
            unint64_t v32 = *v171;
            if (*v171 <= v20) {
              goto LABEL_294;
            }
            unint64_t v32 = *v169 + 48 * v20;
          }
          else
          {
            unint64_t v32 = (unint64_t)&v216;
          }
          if (v181)
          {
            unint64_t v11 = *(void *)(v174 + 16);
            if (v11 <= v20) {
              goto LABEL_291;
            }
            uint64_t v112 = *(void *)(v174 + 32);
            unint64_t v11 = 80;
            uint64_t v113 = v112 + 80 * v20;
            *(void *)long long v279 = *(void *)v113;
            *(_DWORD *)&v279[8] = *(_DWORD *)(v113 + 8);
            v279[12] = *(unsigned char *)(v113 + 12);
            int v114 = *(unsigned __int8 *)(v113 + 12);
            if (v114 == 2)
            {
              re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown((uint64_t)&v279[16], (uint64_t *)(v112 + 80 * v20 + 16));
            }
            else if (v114 == 1)
            {
              re::DynamicArray<float>::DynamicArray((uint64_t)&v279[16], (uint64_t *)(v112 + 80 * v20 + 16));
            }
            else
            {
              if (v114) {
                goto LABEL_322;
              }
              *(_DWORD *)&v279[16] = *(_DWORD *)(v112 + 80 * v20 + 16);
            }
          }
          else
          {
            unsigned int v115 = 0;
            unsigned int v116 = *(_DWORD *)(v11 + 736 * v20 + 16);
            *(void *)long long v279 = 0xFFFFFFFF00000000;
            *(_DWORD *)&v279[8] = -1;
            v279[12] = 0;
            if (v116 - 1 <= 0xFFFFFFFD)
            {
              *(_DWORD *)&v279[8] = v116 - 1;
              unsigned int v115 = v116;
              *(void *)long long v279 = v116;
            }
            *(_DWORD *)&v279[16] = v115;
            unint64_t v11 = 80;
          }
          if (v179)
          {
            unint64_t v12 = *(void *)(v173 + 16);
            if (v12 <= v20) {
              goto LABEL_292;
            }
            uint64_t v117 = *(void *)(v173 + 32);
            uint64_t v118 = v117 + 80 * v20;
            *(void *)int v274 = *(void *)v118;
            *(_DWORD *)&v274[8] = *(_DWORD *)(v118 + 8);
            LOBYTE(v275) = *(unsigned char *)(v118 + 12);
            int v119 = *(unsigned __int8 *)(v118 + 12);
            if (v119 == 2)
            {
              re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown((uint64_t)&v276[2], (uint64_t *)(v117 + 80 * v20 + 16));
            }
            else if (v119 == 1)
            {
              re::DynamicArray<float>::DynamicArray((uint64_t)&v276[2], (uint64_t *)(v117 + 80 * v20 + 16));
            }
            else
            {
              if (v119) {
                goto LABEL_323;
              }
              *(_DWORD *)&v276[2] = *(_DWORD *)(v117 + 80 * v20 + 16);
            }
          }
          else
          {
            unsigned int v120 = 0;
            unsigned int v121 = *(_DWORD *)v12;
            *(void *)int v274 = 0xFFFFFFFF00000000;
            *(_DWORD *)&v274[8] = -1;
            LOBYTE(v275) = 0;
            if (v121 - 1 <= 0xFFFFFFFD)
            {
              *(_DWORD *)&v274[8] = v121 - 1;
              unsigned int v120 = v121;
              *(void *)int v274 = v121;
            }
            *(_DWORD *)&v276[2] = v120;
          }
          unint64_t v12 = *v177;
          if (*v177)
          {
            if (v12 <= v20) {
              goto LABEL_293;
            }
            int v122 = *(_DWORD *)(*v172 + 4 * v20);
          }
          else
          {
            LOWORD(v122) = 0;
          }
          unint64_t v123 = v291 + 144 * *((void *)&v289 + 1) - 144;
          if (!v19) {
            unint64_t v123 = 0;
          }
          if (!(_BYTE)v275) {
            goto LABEL_218;
          }
          if (v275 == 2)
          {
            uint64_t v125 = v278;
            if (!v278) {
              goto LABEL_218;
            }
            if (*(void *)&v276[10]) {
              *(void *)&v276[10] = 0;
            }
            uint64_t v124 = *(void *)&v276[2];
            if (!*(void *)&v276[2]) {
              goto LABEL_218;
            }
          }
          else
          {
            if (v275 != 1) {
              goto LABEL_320;
            }
            uint64_t v125 = *(void *)&v276[2];
            if (!*(void *)&v276[2] || (uint64_t v124 = v277) == 0)
            {
LABEL_218:
              if (v279[12])
              {
                if (v279[12] == 2)
                {
                  if (v281)
                  {
                    if (*(void *)&v279[24]) {
                      *(void *)&v279[24] = 0;
                    }
                    if (*(void *)&v279[16])
                    {
                      (*(void (**)(void))(*(void *)v281 + 40))();
                      unint64_t v126 = (long long *)&v279[16];
                      goto LABEL_229;
                    }
                  }
                }
                else
                {
                  if (v279[12] != 1) {
                    goto LABEL_321;
                  }
                  if (*(void *)&v279[16])
                  {
                    unint64_t v126 = &v280;
                    if ((void)v280)
                    {
                      (*(void (**)(void))(**(void **)&v279[16] + 40))();
                      unint64_t v126 = &v280;
                    }
LABEL_229:
                    *(void *)unint64_t v126 = 0;
                  }
                }
              }
LABEL_230:
              if (++v20 == v3) {
                goto LABEL_231;
              }
              continue;
            }
          }
          break;
        }
        (*(void (**)(uint64_t))(*(void *)v125 + 40))(v125);
        goto LABEL_218;
      }
LABEL_232:
      *(_OWORD *)uint64_t v247 = *(_OWORD *)v282;
      *(void *)&v282[8] = "";
      *(void *)long long v282 = 0;
      *(_OWORD *)&v247[48] = v283;
      *(_OWORD *)&v247[64] = v284;
      *(_OWORD *)&v247[80] = v285;
      *(_OWORD *)&v247[96] = v286;
      *(_OWORD *)&v247[16] = *(_OWORD *)&v282[16];
      *(_OWORD *)&v247[32] = *(_OWORD *)&v282[32];
      *(void *)&v247[112] = v287[0];
      memset(v287, 0, 24);
      ++LODWORD(v287[3]);
      long long v248 = v288;
      long long v249 = v289;
      long long v288 = 0u;
      long long v289 = 0u;
      *(_OWORD *)&v250[8] = v291;
      long long v291 = 0u;
      long long v251 = v292;
      unint64_t v11 = (unint64_t)v282;
      long long v292 = 0u;
      ++v290;
      ++v293;
      *(_OWORD *)&v252[8] = v294;
      long long v253 = v295;
      long long v294 = 0u;
      long long v295 = 0u;
      ++v296;
      long long v255 = v297;
      long long v256 = v298;
      long long v297 = 0u;
      long long v298 = 0u;
      ++v299;
      long long v258 = v300;
      long long v259 = v301;
      long long v300 = 0u;
      long long v301 = 0u;
      ++v302;
      long long v261 = v303;
      long long v262 = v304;
      long long v303 = 0u;
      long long v304 = 0u;
      ++v305;
      long long v264 = v306;
      long long v265 = v307;
      long long v306 = 0u;
      long long v307 = 0u;
      ++v308;
      long long v267 = v309;
      long long v268 = v310;
      long long v309 = 0u;
      long long v310 = 0u;
      ++v311;
      long long v270 = v312;
      long long v271 = v313;
      long long v312 = 0u;
      long long v313 = 0u;
      uint64_t v273 = v315;
      uint64_t v315 = 0;
      ++v314;
      LOBYTE(v221[0]) = 1;
      v221[1] = *(_OWORD *)v247;
      *(void *)&v247[8] = "";
      *(void *)uint64_t v247 = 0;
      long long v222 = *(_OWORD *)&v282[16];
      long long v223 = *(_OWORD *)&v282[32];
      *(_OWORD *)&v224[32] = v285;
      long long v225 = v286;
      *(_OWORD *)int v224 = v283;
      *(_OWORD *)&v224[16] = v284;
      *(void *)char v226 = *(void *)&v247[112];
      memset(&v247[112], 0, 24);
      *(_OWORD *)&v226[8] = *(_OWORD *)&v247[120];
      *(_DWORD *)&v247[136] = 2;
      LODWORD(v227) = 1;
      v228[0] = v248;
      v228[1] = v249;
      long long v248 = 0u;
      long long v249 = 0u;
      v230[0] = *(_OWORD *)&v250[8];
      *(_OWORD *)&v250[8] = 0u;
      v230[1] = v251;
      long long v251 = 0u;
      *(_DWORD *)uint64_t v250 = 2;
      *(_DWORD *)uint64_t v252 = 2;
      int v229 = 1;
      int v231 = 1;
      v232[0] = *(_OWORD *)&v252[8];
      v232[1] = v253;
      *(_OWORD *)&v252[8] = 0u;
      long long v253 = 0u;
      int v254 = 2;
      int v233 = 1;
      v234[0] = v255;
      v234[1] = v256;
      long long v255 = 0u;
      long long v256 = 0u;
      int v257 = 2;
      int v235 = 1;
      v236[0] = v258;
      v236[1] = v259;
      long long v258 = 0u;
      long long v259 = 0u;
      int v260 = 2;
      int v237 = 1;
      v238[0] = v261;
      v238[1] = v262;
      long long v261 = 0u;
      long long v262 = 0u;
      int v263 = 2;
      int v239 = 1;
      v240[0] = v264;
      v240[1] = v265;
      long long v264 = 0u;
      long long v265 = 0u;
      int v266 = 2;
      int v241 = 1;
      v242[0] = v267;
      v242[1] = v268;
      long long v267 = 0u;
      long long v268 = 0u;
      int v269 = 2;
      int v243 = 1;
      v244[0] = v270;
      v244[1] = v271;
      long long v270 = 0u;
      long long v271 = 0u;
      uint64_t v246 = v273;
      uint64_t v273 = 0;
      int v272 = 2;
      int v245 = 1;
      re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit((uint64_t)&v270 + 8);
      re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v267 + 8);
      re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit((uint64_t)&v264 + 8);
      re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v261 + 8);
      re::DynamicArray<re::MeshAssetContactDeformerData>::deinit((uint64_t)&v258 + 8);
      if (*((void *)&v255 + 1))
      {
        if ((void)v258) {
          (*(void (**)(void))(**((void **)&v255 + 1) + 40))();
        }
        *(void *)&long long v258 = 0;
        long long v256 = 0uLL;
        *((void *)&v255 + 1) = 0;
        ++v257;
      }
      re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v252[16]);
      re::DynamicArray<re::MeshAssetPart>::deinit((uint64_t)&v250[16]);
      re::DynamicArray<re::MeshAssetSkinningData>::deinit((uint64_t)&v248 + 8);
      re::DynamicArray<re::MeshAssetBlendShapeData>::deinit((uint64_t)&v247[112]);
      re::StringID::destroyString((re::StringID *)v247);
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v213);
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v216);
LABEL_237:
      re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit((uint64_t)&v312 + 8);
      re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v309 + 8);
      re::DynamicArray<re::MeshAssetWrapDeformerData>::deinit((uint64_t)&v306 + 8);
      re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v303 + 8);
      re::DynamicArray<re::MeshAssetContactDeformerData>::deinit((uint64_t)&v300 + 8);
      if (*((void *)&v297 + 1))
      {
        if ((void)v300) {
          (*(void (**)(void))(**((void **)&v297 + 1) + 40))();
        }
        *(void *)&long long v300 = 0;
        long long v298 = 0uLL;
        *((void *)&v297 + 1) = 0;
        ++v299;
      }
      re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v294 + 8);
      re::DynamicArray<re::MeshAssetPart>::deinit((uint64_t)&v291 + 8);
      re::DynamicArray<re::MeshAssetSkinningData>::deinit((uint64_t)&v288 + 8);
      re::DynamicArray<re::MeshAssetBlendShapeData>::deinit((uint64_t)v287);
      re::StringID::destroyString((re::StringID *)v282);
      int v127 = LOBYTE(v221[0]);
      if (LOBYTE(v221[0]))
      {
        long long v128 = (void *)(v159 + (v163 << 9));
        long long v129 = v221[1];
        *((void *)&v221[1] + 1) = "";
        *(void *)&v221[1] = 0;
        uint64_t v130 = v128[1];
        unint64_t v131 = v129 & 0xFFFFFFFFFFFFFFFELL | *v128 & 1;
        v128[1] = *((void *)&v129 + 1);
        *(void *)&v282[8] = v130;
        *(void *)long long v282 = v131;
        void *v128 = v129;
        re::StringID::destroyString((re::StringID *)v282);
        unint64_t v12 = v159 + (v163 << 9);
        long long v132 = v223;
        *(_OWORD *)(v12 + 16) = v222;
        *(_OWORD *)(v12 + 32) = v132;
        long long v133 = *(_OWORD *)v224;
        long long v134 = *(_OWORD *)&v224[16];
        long long v135 = v225;
        *(_OWORD *)(v12 + 80) = *(_OWORD *)&v224[32];
        *(_OWORD *)(v12 + 96) = v135;
        *(_OWORD *)(v12 + 48) = v133;
        *(_OWORD *)(v12 + 64) = v134;
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v12 + 112, (uint64_t)v226);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v12 + 152, (uint64_t)v228 + 8);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v12 + 192, (uint64_t)v230 + 8);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v12 + 232, (uint64_t)v232 + 8);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v12 + 272, (uint64_t)v234 + 8);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v12 + 312, (uint64_t)v236 + 8);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v12 + 352, (uint64_t)v238 + 8);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v12 + 392, (uint64_t)v240 + 8);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v12 + 432, (uint64_t)v242 + 8);
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=(v12 + 472, (uint64_t)v244 + 8);
        re::DynamicArray<re::MeshAssetSkeleton>::operator=(v12 + 232, (uint64_t *)&v205 + 1);
      }
      else
      {
        *(_OWORD *)long long v282 = v221[1];
        re::DynamicString::DynamicString((re::DynamicString *)&v282[16], (const re::DynamicString *)&v222);
        *(unsigned char *)a3 = 0;
        *(_OWORD *)(a3 + 8) = *(_OWORD *)v282;
        uint64_t v136 = *(void *)&v282[40];
        *(void *)(a3 + 24) = *(void *)&v282[16];
        *(void *)(a3 + 48) = v136;
        *(_OWORD *)(a3 + 32) = *(_OWORD *)&v282[24];
      }
      re::Result<re::MeshAssetModel,re::DetailedError>::~Result(v221);
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v192);
      if (!v127) {
        goto LABEL_281;
      }
      uint64_t v17 = a2;
      unint64_t v18 = v163 + 1;
      int v16 = v165;
    }
    while (v163 + 1 != v161);
  }
  unint64_t v142 = v16[7];
  re::DynamicArray<re::MeshAssetInstance>::resize((uint64_t)&v202 + 8, v142);
  memset(v279, 0, 24);
  if (v142)
  {
    unint64_t v32 = 0;
    uint64_t v144 = 0;
    unint64_t v13 = 0;
    while (1)
    {
      unint64_t v19 = v165[7];
      if (v19 <= v13) {
        break;
      }
      unint64_t v19 = *((void *)&v203 + 1);
      if (*((void *)&v203 + 1) <= v13) {
        goto LABEL_305;
      }
      unint64_t v19 = v165[9] + v32;
      unint64_t v11 = *(unsigned int *)(v19 + 64);
      uint64_t v3 = *((void *)&v200 + 1);
      if (*((void *)&v200 + 1) <= v11) {
        goto LABEL_306;
      }
      uint64_t v3 = *(void *)&v279[8];
      if (*(void *)&v279[8] <= v11) {
        goto LABEL_307;
      }
      uint64_t v3 = v205;
      uint64_t v145 = *(void *)(v202 + (v11 << 9) + 8);
      uint64_t v146 = *(unsigned int *)(*(void *)&v279[16] + 4 * v11);
      *(_DWORD *)(*(void *)&v279[16] + 4 * v11) = v146 + 1;
      int v147 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s-%u", (re::DynamicString *)v247, v145, v146);
      if (v247[8]) {
        __int16 v148 = *(const char **)&v247[16];
      }
      else {
        __int16 v148 = &v247[9];
      }
      *(void *)long long v282 = 0;
      *(void *)&v282[8] = "";
      long long v149 = *(_OWORD *)v282;
      *(void *)&v282[8] = "";
      *(void *)long long v282 = 0;
      unint64_t v11 = v3 + v144;
      uint64_t v150 = *(void *)(v3 + v144 + 8);
      unint64_t v151 = v149 & 0xFFFFFFFFFFFFFFFELL | *(void *)(v3 + v144) & 1;
      *(void *)(v11 + 8) = *((void *)&v149 + 1);
      *((void *)&v221[0] + 1) = v150;
      *(void *)&v221[0] = v151;
      *(void *)unint64_t v11 = v149;
      re::StringID::destroyString((re::StringID *)v221);
      re::StringID::destroyString((re::StringID *)v282);
      if (*(void *)v247 && (v247[8] & 1) != 0) {
        (*(void (**)(void))(**(void **)v247 + 40))();
      }
      float32x4_t v152 = *(float32x4_t *)v19;
      long long v153 = *(_OWORD *)(v19 + 16);
      long long v154 = *(_OWORD *)(v19 + 48);
      *(_OWORD *)(v11 + 48) = *(_OWORD *)(v19 + 32);
      *(_OWORD *)(v11 + 64) = v154;
      *(float32x4_t *)(v11 + 16) = v152;
      *(_OWORD *)(v11 + 32) = v153;
      *(_DWORD *)(v11 + 80) = *(_DWORD *)(v19 + 64);
      *(unsigned char *)(v11 + 84) = 0;
      *(_DWORD *)(v11 + 88) = 1065353216;
      ++v13;
      v144 += 96;
      v32 += 80;
      if (v142 == v13) {
        goto LABEL_271;
      }
    }
LABEL_304:
    *(void *)uint64_t v247 = 0;
    *(_OWORD *)int v224 = 0u;
    long long v223 = 0u;
    long long v222 = 0u;
    memset(v221, 0, sizeof(v221));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v282 = 136315906;
    *(void *)&v282[4] = "operator[]";
    *(_WORD *)&v282[12] = 1024;
    *(_DWORD *)&v282[14] = 797;
    *(_WORD *)&v282[18] = 2048;
    *(void *)&v282[20] = v13;
    *(_WORD *)&v282[28] = 2048;
    *(void *)&v282[30] = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_305:
    *(void *)uint64_t v247 = 0;
    *(_OWORD *)int v224 = 0u;
    long long v223 = 0u;
    long long v222 = 0u;
    memset(v221, 0, sizeof(v221));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v282 = 136315906;
    *(void *)&v282[4] = "operator[]";
    *(_WORD *)&v282[12] = 1024;
    *(_DWORD *)&v282[14] = 789;
    *(_WORD *)&v282[18] = 2048;
    *(void *)&v282[20] = v13;
    *(_WORD *)&v282[28] = 2048;
    *(void *)&v282[30] = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_306:
    *(void *)int v274 = 0;
    *(_OWORD *)int v224 = 0u;
    long long v223 = 0u;
    long long v222 = 0u;
    memset(v221, 0, sizeof(v221));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v282 = 136315906;
    *(void *)&v282[4] = "operator[]";
    *(_WORD *)&v282[12] = 1024;
    *(_DWORD *)&v282[14] = 789;
    *(_WORD *)&v282[18] = 2048;
    *(void *)&v282[20] = v11;
    *(_WORD *)&v282[28] = 2048;
    *(void *)&v282[30] = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_307:
    *(void *)int v274 = 0;
    *(_OWORD *)int v224 = 0u;
    long long v223 = 0u;
    long long v222 = 0u;
    memset(v221, 0, sizeof(v221));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v282 = 136315906;
    *(void *)&v282[4] = "operator[]";
    *(_WORD *)&v282[12] = 1024;
    *(_DWORD *)&v282[14] = 468;
    *(_WORD *)&v282[18] = 2048;
    *(void *)&v282[20] = v11;
    *(_WORD *)&v282[28] = 2048;
    *(void *)&v282[30] = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_308:
    v216.i64[0] = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v274 = 136315906;
    *(void *)&v274[4] = "operator[]";
    __int16 v275 = 1024;
    *(_DWORD *)long long v276 = 601;
    *(_WORD *)&v276[4] = 2048;
    *(void *)&v276[6] = 1;
    *(_WORD *)&v276[14] = 2048;
    *(void *)&v276[16] = 1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_309:
    v216.i64[0] = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v274 = 136315906;
    *(void *)&v274[4] = "operator[]";
    __int16 v275 = 1024;
    *(_DWORD *)long long v276 = 601;
    *(_WORD *)&v276[4] = 2048;
    *(void *)&v276[6] = 2;
    *(_WORD *)&v276[14] = 2048;
    *(void *)&v276[16] = v32;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_310:
    v216.i64[0] = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v274 = 136315906;
    *(void *)&v274[4] = "operator[]";
    __int16 v275 = 1024;
    *(_DWORD *)long long v276 = 601;
    *(_WORD *)&v276[4] = 2048;
    *(void *)&v276[6] = 3;
    *(_WORD *)&v276[14] = 2048;
    *(void *)&v276[16] = 3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_311:
    *(void *)int v274 = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v279 = 136315906;
    *(void *)&v279[4] = "operator[]";
    *(_WORD *)&v279[12] = 1024;
    *(_DWORD *)&v279[14] = 797;
    *(_WORD *)&v279[18] = 2048;
    *(void *)&v279[20] = v19;
    *(_WORD *)&v279[28] = 2048;
    *(void *)&v279[30] = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_312:
    *(void *)int v274 = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v279 = 136315906;
    *(void *)&v279[4] = "operator[]";
    *(_WORD *)&v279[12] = 1024;
    *(_DWORD *)&v279[14] = 789;
    *(_WORD *)&v279[18] = 2048;
    *(void *)&v279[20] = v19;
    *(_WORD *)&v279[28] = 2048;
    *(void *)&v279[30] = v32;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_313:
    *(void *)uint64_t v247 = 0;
    *(_OWORD *)int v224 = 0u;
    long long v223 = 0u;
    long long v222 = 0u;
    memset(v221, 0, sizeof(v221));
    unint64_t v158 = v18;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v282 = 136315906;
    *(void *)&v282[4] = "operator[]";
    *(_WORD *)&v282[12] = 1024;
    *(_DWORD *)&v282[14] = 797;
    *(_WORD *)&v282[18] = 2048;
    *(void *)&v282[20] = v158;
    *(_WORD *)&v282[28] = 2048;
    *(void *)&v282[30] = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_314:
    *(void *)uint64_t v247 = 0;
    *(_OWORD *)int v224 = 0u;
    long long v223 = 0u;
    long long v222 = 0u;
    memset(v221, 0, sizeof(v221));
    unint64_t v12 = v18;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v282 = 136315906;
    *(void *)&v282[4] = "operator[]";
    *(_WORD *)&v282[12] = 1024;
    *(_DWORD *)&v282[14] = 789;
    *(_WORD *)&v282[18] = 2048;
    *(void *)&v282[20] = v12;
    *(_WORD *)&v282[28] = 2048;
    *(void *)&v282[30] = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_315:
    *(void *)int v274 = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v279 = 136315906;
    *(void *)&v279[4] = "operator[]";
    *(_WORD *)&v279[12] = 1024;
    *(_DWORD *)&v279[14] = 797;
    *(_WORD *)&v279[18] = 2048;
    *(void *)&v279[20] = 0;
    *(_WORD *)&v279[28] = 2048;
    *(void *)&v279[30] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_316:
    *(void *)int v274 = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v279 = 136315906;
    *(void *)&v279[4] = "operator[]";
    *(_WORD *)&v279[12] = 1024;
    *(_DWORD *)&v279[14] = 797;
    *(_WORD *)&v279[18] = 2048;
    *(void *)&v279[20] = 0;
    *(_WORD *)&v279[28] = 2048;
    *(void *)&v279[30] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_317:
    *(void *)int v274 = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v279 = 136315906;
    *(void *)&v279[4] = "operator[]";
    *(_WORD *)&v279[12] = 1024;
    *(_DWORD *)&v279[14] = 797;
    *(_WORD *)&v279[18] = 2048;
    *(void *)&v279[20] = v3;
    *(_WORD *)&v279[28] = 2048;
    *(void *)&v279[30] = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_318:
    *(void *)int v274 = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v279 = 136315906;
    *(void *)&v279[4] = "operator[]";
    *(_WORD *)&v279[12] = 1024;
    *(_DWORD *)&v279[14] = 789;
    *(_WORD *)&v279[18] = 2048;
    *(void *)&v279[20] = v3;
    *(_WORD *)&v279[28] = 2048;
    *(void *)&v279[30] = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_319:
    *(void *)int v274 = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v279 = 136315906;
    *(void *)&v279[4] = "operator[]";
    *(_WORD *)&v279[12] = 1024;
    *(_DWORD *)&v279[14] = 797;
    *(_WORD *)&v279[18] = 2048;
    *(void *)&v279[20] = 0;
    *(_WORD *)&v279[28] = 2048;
    *(void *)&v279[30] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_320:
    re::internal::assertLog((re::internal *)4, v124, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
    _os_crash();
    __break(1u);
LABEL_321:
    re::internal::assertLog((re::internal *)4, v124, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
    _os_crash();
    __break(1u);
LABEL_322:
    re::internal::assertLog((re::internal *)4, v109, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 433);
    _os_crash();
    __break(1u);
LABEL_323:
    re::internal::assertLog((re::internal *)4, v109, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 433);
    _os_crash();
    __break(1u);
LABEL_324:
    *(void *)&v213[0] = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v274 = 136315906;
    *(void *)&v274[4] = "operator[]";
    __int16 v275 = 1024;
    *(_DWORD *)long long v276 = 601;
    *(_WORD *)&v276[4] = 2048;
    *(void *)&v276[6] = 0;
    *(_WORD *)&v276[14] = 2048;
    *(void *)&v276[16] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_325:
    v216.i64[0] = 0;
    memset(v247, 0, 80);
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v274 = 136315906;
    *(void *)&v274[4] = "operator[]";
    __int16 v275 = 1024;
    *(_DWORD *)long long v276 = 601;
    *(_WORD *)&v276[4] = 2048;
    *(void *)&v276[6] = 0;
    *(_WORD *)&v276[14] = 2048;
    *(void *)&v276[16] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_271:
  if (*((void *)&v200 + 1))
  {
    uint64_t v155 = (unsigned __int16 *)v202;
    uint64_t v156 = *((void *)&v200 + 1) << 9;
    do
    {
      re::importModelBlendShapes(v155);
      v155 += 256;
      v156 -= 512;
    }
    while (v156);
  }
  re::MeshAssetData::generateMetaData((re::MeshAssetData *)&v199);
  *(void *)&v221[0] = v199;
  uint64_t v199 = 0;
  *(_OWORD *)((char *)v221 + 8) = v200;
  long long v200 = 0u;
  ++v201;
  DWORD2(v221[1]) = 1;
  long long v222 = v202;
  long long v223 = v203;
  long long v202 = 0u;
  long long v203 = 0u;
  *(_OWORD *)&v224[8] = v205;
  *(_OWORD *)&v224[24] = v206;
  long long v205 = 0u;
  long long v206 = 0u;
  ++v204;
  ++v207;
  *(_DWORD *)int v224 = 1;
  *(_DWORD *)&v224[40] = 1;
  long long v225 = v208;
  *(_OWORD *)char v226 = v209;
  long long v208 = 0u;
  long long v209 = 0u;
  uint64_t v227 = v211;
  uint64_t v211 = 0;
  ++v210;
  *(_DWORD *)&v226[16] = 1;
  re::Result<re::MeshAssetData,re::DetailedError>::Result(a3, (uint64_t)v221);
  if (*((void *)&v225 + 1))
  {
    if (v227) {
      (*(void (**)(void))(**((void **)&v225 + 1) + 40))();
    }
    uint64_t v227 = 0;
    *(_OWORD *)char v226 = 0uLL;
    *((void *)&v225 + 1) = 0;
    ++*(_DWORD *)&v226[16];
  }
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v224[16]);
  re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v222 + 8);
  re::DynamicArray<re::MeshAssetModel>::deinit(v221);
  if (*(void *)v279 && *(void *)&v279[8]) {
    (*(void (**)(void))(**(void **)v279 + 40))();
  }
LABEL_281:
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v193);
  double v157 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v196);
  if (*((void *)&v208 + 1))
  {
    if (v211) {
      (*(void (**)(double))(**((void **)&v208 + 1) + 40))(v157);
    }
    uint64_t v211 = 0;
    long long v209 = 0uLL;
    *((void *)&v208 + 1) = 0;
    ++v210;
  }
  re::DynamicArray<re::MeshAssetSkeleton>::deinit((uint64_t)&v205 + 8);
  re::DynamicArray<re::MeshAssetInstance>::deinit((uint64_t)&v202 + 8);
  re::DynamicArray<re::MeshAssetModel>::deinit(&v199);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v212);
}

double re::makeMeshAssetDataFromGeomScene@<D0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  long long v8 = 0u;
  memset(v7, 0, sizeof(v7));
  DWORD1(v8) = 0x7FFFFFFF;
  memset(v9, 0, sizeof(v9));
  int v10 = 0;
  uint64_t v11 = 0x7FFFFFFFLL;
  *(_OWORD *)long long v6 = *(_OWORD *)a2;
  *(void *)&v6[13] = *(void *)(a2 + 13);
  re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v7, a2 + 24);
  re::makeMeshAssetDataFromGeomScene(a1, (uint64_t)v6, a3);
  re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v9);
  return re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v7);
}

void *re::createMeshCollectionFromMeshAsset@<X0>(re *this@<X0>, const re::mtl::Device *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v5 = a2;
  unint64_t v7 = v100;
  uint64_t v124 = *MEMORY[0x263EF8340];
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  unint64_t v8 = *((void *)a2 + 2);
  float32x4_t v77 = (re::Allocator *)re::globalAllocators(this)[2];
  *(void *)a3 = v77;
  unint64_t v75 = v8;
  re::DynamicArray<re::MeshModel>::setCapacity((void *)a3, v8);
  long long v73 = (_anonymous_namespace_ *)a3;
  ++*(_DWORD *)(a3 + 24);
  uint64_t v89 = 0;
  unint64_t v90 = 0;
  uint64_t v91 = 0;
  unint64_t v9 = *((void *)v5 + 12);
  float32x4_t v78 = v5;
  if (v9)
  {
    re::FixedArray<re::Slice<unsigned int>>::init<>(&v89, (uint64_t)v77, v9);
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    unint64_t v13 = (unint64_t)&selRef_taskToken;
    do
    {
      unint64_t v14 = *((void *)v5 + 12);
      if (v14 <= (unint64_t)v12) {
        goto LABEL_106;
      }
      id v15 = objc_msgSend(*(id *)this, sel_newBufferWithBytes_length_options_, *(void *)(*((void *)v5 + 14) + v10 + 104), *(void *)(*((void *)v5 + 14) + v10 + 96) << 6, 0);
      *(void *)&v121[0] = v15;
      DWORD2(v121[0]) = 0;
      HIDWORD(v121[0]) = objc_msgSend(v15, sel_length);
      uint64_t v4 = v90;
      if (v90 <= (unint64_t)v12)
      {
LABEL_107:
        *(void *)long long v100 = 0;
        long long v96 = 0u;
        long long v97 = 0u;
        int32x4_t v94 = 0u;
        long long v95 = 0u;
        long long v93 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v102[0]) = 136315906;
        *(void *)(v7 + 68) = "operator[]";
        WORD6(v102[0]) = 1024;
        *(_DWORD *)(v7 + 78) = 468;
        WORD1(v102[1]) = 2048;
        *(void *)(v7 + 84) = v12;
        WORD6(v102[1]) = 2048;
        *(void *)(v7 + 94) = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_108:
        *(void *)&v121[0] = 0;
        long long v96 = 0u;
        long long v97 = 0u;
        int32x4_t v94 = 0u;
        long long v95 = 0u;
        long long v93 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v102[0]) = 136315906;
        *(void *)((char *)v102 + 4) = "operator[]";
        WORD6(v102[0]) = 1024;
        *(_DWORD *)((char *)v102 + 14) = 797;
        WORD1(v102[1]) = 2048;
        *(void *)((char *)&v102[1] + 4) = v13;
        WORD6(v102[1]) = 2048;
        *(void *)((char *)&v102[1] + 14) = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_109:
        re::internal::assertLog((re::internal *)4, v70, "assertion failure: '%s' (%s:line %i) Cannot copy from a Slice of a different size", "m_size == other.size()", "copy", 378);
        _os_crash();
        __break(1u);
      }
      uint64_t v16 = v91 + v11;
      NS::SharedPtr<MTL::Texture>::operator=((void **)(v91 + v11), (void **)v121);
      *(void *)(v16 + 8) = *((void *)&v121[0] + 1);
      if (*(void *)&v121[0])
      {

        *(void *)&v121[0] = 0;
      }
      if (v15) {

      }
      ++v12;
      v11 += 16;
      v10 += 112;
      unsigned int v5 = v78;
    }
    while ((const char *)v9 != v12);
  }
  if (v75)
  {
    unint64_t v13 = 0;
    unint64_t v7 = (char *)v102 + 8;
    uint64_t v4 = (uint64_t)v113;
    int32x4_t v74 = vdupq_n_s32(0x7F800000u);
    unint64_t v17 = 144;
    while (1)
    {
      unint64_t v12 = (const char *)*((void *)v5 + 2);
      if ((unint64_t)v12 <= v13) {
        goto LABEL_108;
      }
      uint64_t v18 = 0;
      uint64_t v81 = *((void *)v5 + 4);
      *(void *)&long long v93 = 0;
      *((void *)&v93 + 1) = "";
      *(void *)&long long v19 = 0x7F0000007FLL;
      *((void *)&v19 + 1) = 0x7F0000007FLL;
      int32x4_t v94 = v74;
      long long v95 = v19;
      long long v96 = 0u;
      long long v97 = 0u;
      long long v98 = 0u;
      do
      {
        unint64_t v20 = (char *)&v93 + v18;
        *((void *)v20 + 12) = 0;
        *((void *)v20 + 16) = 0;
        v18 += 40;
      }
      while (v18 != 720);
      uint64_t v21 = (void *)(v81 + (v13 << 9));
      unint64_t v22 = re::StringID::operator=((unint64_t *)&v93, v21);
      unint64_t v23 = v21[26];
      uint64_t v86 = (const char **)(v21 + 26);
      unint64_t v82 = v23;
      uint64_t v25 = (const char **)(v21 + 16);
      unint64_t v26 = v21[16];
      if (v26) {
        break;
      }
LABEL_20:
      uint64_t v29 = v21[21];
      unint64_t v14 = (unint64_t)(v21 + 21);
      unint64_t v76 = v13;
      uint64_t v84 = (unint64_t *)v14;
      if (v29 && v90)
      {
        *(void *)&v102[2] = 0;
        *(void *)&long long v104 = 0;
        long long v103 = 0uLL;
        DWORD2(v104) = 0;
        uint64_t v105 = 0;
        uint64_t v106 = 0;
        DWORD2(v102[2]) = 1;
        int v107 = 1;
        uint64_t v109 = 0;
        uint64_t v110 = 0;
        uint64_t v108 = 0;
        int v111 = 0;
        *(void *)&v102[0] = v77;
        *((void *)&v102[0] + 1) = v91;
        v102[1] = v90;
        re::BucketArray<re::SkinningModelBuilder::RawSkinnedMeshPartData,4ul>::init((uint64_t)&v102[1] + 8, (uint64_t)v77, 1uLL);
        re::BucketArray<re::SkinningModelBuilder::PreparedSkinnedMeshPartData,4ul>::init((uint64_t)&v105, (uint64_t)v77, 1uLL);
        if (v82)
        {
          unint64_t v13 = *(void *)v14;
          if (*(void *)v14)
          {
            unint64_t v26 = 0;
            uint64_t v30 = v81 + (v76 << 9);
            float32x4_t v79 = (void *)(v30 + 184);
            uint64_t v80 = (void *)(v30 + 224);
            while (1)
            {
              unint64_t v12 = *v86;
              if ((unint64_t)*v86 <= v26) {
                break;
              }
              unint64_t v31 = *v80 + (v26 << 8);
              uint64_t v32 = *(void *)(v31 + 16);
              if (v32)
              {
                unint64_t v14 = 0;
                uint64_t v33 = 0;
                unint64_t v87 = 0;
                uint64_t v88 = 0;
                uint64_t v34 = (uint64_t *)(*(void *)(v31 + 32) + 64);
                uint64_t v4 = 80 * v32;
                unint64_t v12 = "simplifiedAnimationInfluenceEndIndices";
                do
                {
                  if (*(v34 - 7)) {
                    long long v35 = (const char *)*(v34 - 6);
                  }
                  else {
                    long long v35 = (char *)v34 - 55;
                  }
                  if (!strcmp(v35, "simplifiedAnimationInfluenceEndIndices"))
                  {
                    uint64_t v33 = *v34;
                    unint64_t v14 = (unint64_t)*(v34 - 2) >> 2;
                  }
                  else if (!strcmp(v35, "simplifiedAnimationSkinningInfluences"))
                  {
                    unint64_t v87 = (unint64_t)*(v34 - 2) >> 3;
                    uint64_t v88 = *v34;
                  }
                  v34 += 10;
                  v4 -= 80;
                }
                while (v4);
              }
              else
              {
                unint64_t v87 = 0;
                uint64_t v88 = 0;
                uint64_t v33 = 0;
                unint64_t v14 = 0;
              }
              if (v13 <= v26) {
                goto LABEL_105;
              }
              uint64_t v36 = *v79 + 144 * v26;
              int v37 = *(_DWORD *)v36;
              uint64_t v39 = *(void *)(v36 + 16);
              uint64_t v38 = *(void *)(v36 + 24);
              unint64_t v40 = v26;
              uint64_t v41 = *(void *)(v36 + 40);
              uint64_t v42 = *(void *)(v36 + 48);
              uint64_t v43 = *(void *)(v36 + 64);
              uint64_t v83 = *(void *)(v36 + 72);
              uint64_t v44 = re::BucketArray<re::SkinningModelBuilder::RawSkinnedMeshPartData,4ul>::addUninitialized((uint64_t)&v102[1] + 8);
              *(_DWORD *)uint64_t v44 = v37;
              *(void *)(v44 + 8) = v38;
              *(void *)(v44 + 16) = v39;
              *(void *)(v44 + 24) = v42;
              *(void *)(v44 + 32) = v41;
              *(void *)(v44 + 40) = v88;
              *(void *)(v44 + 48) = v87;
              *(void *)(v44 + 56) = v33;
              *(void *)(v44 + 64) = v14;
              unint64_t v26 = v40 + 1;
              *(void *)(v44 + 72) = v83;
              *(void *)(v44 + 80) = v43;
              uint64_t v4 = (uint64_t)v113;
              if (v40 + 1 < v82)
              {
                unint64_t v13 = *v84;
                if (v26 < *v84) {
                  continue;
                }
              }
              goto LABEL_41;
            }
LABEL_104:
            *(void *)int v114 = 0;
            long long v122 = 0u;
            long long v123 = 0u;
            memset(v121, 0, sizeof(v121));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v100 = 136315906;
            *(void *)&v100[4] = "operator[]";
            *(_WORD *)&v100[12] = 1024;
            *(_DWORD *)&v100[14] = 797;
            *(_WORD *)&v100[18] = 2048;
            *(void *)&v100[20] = v26;
            *(_WORD *)&v100[28] = 2048;
            *(void *)&v100[30] = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_105:
            *(void *)int v114 = 0;
            long long v122 = 0u;
            long long v123 = 0u;
            memset(v121, 0, sizeof(v121));
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)long long v100 = 136315906;
            *(void *)&v100[4] = "operator[]";
            *(_WORD *)&v100[12] = 1024;
            *(_DWORD *)&v100[14] = 797;
            *(_WORD *)&v100[18] = 2048;
            *(void *)&v100[20] = v26;
            *(_WORD *)&v100[28] = 2048;
            *(void *)&v100[30] = v13;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_106:
            *(void *)&v121[0] = 0;
            long long v96 = 0u;
            long long v97 = 0u;
            int32x4_t v94 = 0u;
            long long v95 = 0u;
            long long v93 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v102[0]) = 136315906;
            *(void *)(v7 + 68) = "operator[]";
            WORD6(v102[0]) = 1024;
            *(_DWORD *)(v7 + 78) = 797;
            WORD1(v102[1]) = 2048;
            *(void *)(v7 + 84) = v12;
            WORD6(v102[1]) = 2048;
            *(void *)(v7 + 94) = v14;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_107;
          }
        }
LABEL_41:
        re::SkinningModelBuilder::buildDeformationModel((re::SkinningModelBuilder *)v102, (id *)this, &v99);
        re::BucketArray<re::SkinningModelBuilder::PreparedSkinnedMeshPartData,4ul>::deinit((uint64_t)&v105);
        unint64_t v13 = v76;
        unint64_t v17 = 144;
        if (v105)
        {
          int v45 = v107;
          if ((v107 & 1) == 0)
          {
            (*(void (**)(void))(*(void *)v105 + 40))();
            int v45 = v107;
          }
          uint64_t v105 = 0;
          uint64_t v106 = 0;
          int v107 = (v45 | 1) + 2;
        }
        re::BucketArray<re::SkinningModelBuilder::RawSkinnedMeshPartData,4ul>::deinit((uint64_t)&v102[1] + 8);
        inited = (_anonymous_namespace_ *)*((void *)&v102[1] + 1);
        if (*((void *)&v102[1] + 1) && (BYTE8(v102[2]) & 1) == 0) {
          inited = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**((void **)&v102[1] + 1) + 40))();
        }
      }
      unint64_t v12 = (const char *)(v81 + (v13 << 9));
      unint64_t v26 = *((void *)v12 + 51);
      if (v26)
      {
        uint64_t v27 = (unint64_t *)(v12 + 408);
        re::WrapDeformerModelBuilder::WrapDeformerModelBuilder((re::WrapDeformerModelBuilder *)v100, v77, this, v82, *((void *)v12 + 51), &v99);
        unint64_t v28 = 0;
        unint64_t v14 = (unint64_t)(v12 + 424);
        unint64_t v17 = 104;
        do
        {
          unint64_t v13 = *v27;
          if (*v27 <= v28) {
            goto LABEL_94;
          }
          uint64_t v4 = *(void *)v14 + v17;
          unint64_t v46 = *(unsigned __int16 *)v4;
          size_t v47 = strlen(*(const char **)(v4 - 96));
          *(void *)&v102[0] = *(void *)(v4 - 96);
          *((void *)&v102[0] + 1) = v47;
          uint64_t v48 = *(void *)(v4 - 64);
          *(void *)&v102[1] = *(void *)(v4 - 56);
          *((void *)&v102[1] + 1) = v48;
          uint64_t v49 = *(void *)(v4 - 40);
          *(void *)&v102[2] = *(void *)(v4 - 32);
          *((void *)&v102[2] + 1) = v49;
          uint64_t v50 = *(void *)(v4 - 16);
          *(void *)&long long v103 = *(void *)(v4 - 8);
          *((void *)&v103 + 1) = v50;
          re::WrapDeformerModelBuilder::addWrapTarget((uint64_t)v100, v46, (void **)v28, (uint64_t)v102);
          inited = (_anonymous_namespace_ *)re::WrapDeformerModelBuilder::setEnvelopeBufferName((re::WrapDeformerModelBuilder *)v100, *(unsigned __int16 *)v4, v28++, (const re::StringID *)(v4 - 88));
          v17 += 112;
        }
        while (v26 != v28);
        unint64_t v13 = v76;
        uint64_t v4 = (uint64_t)v113;
        unint64_t v17 = 144;
      }
      unint64_t v26 = *((void *)v12 + 41);
      if (v26)
      {
        v12 += 328;
        re::ContactDeformerModelBuilder::ContactDeformerModelBuilder((re::ContactDeformerModelBuilder *)v100, v77, this, v82, v26, &v99);
        unint64_t v28 = 0;
        uint64_t v27 = (unint64_t *)(v81 + (v13 << 9) + 344);
        do
        {
          unint64_t v14 = *(void *)v12;
          if (*(void *)v12 <= v28) {
            goto LABEL_95;
          }
          uint64_t v51 = *v27 + 48 * v28;
          inited = (_anonymous_namespace_ *)re::ContactDeformerModelBuilder::initTargetsForMeshPart((re::ContactDeformerModelBuilder *)v100, *(unsigned __int16 *)(v51 + 40), v28, *(void *)(v51 + 24), (const re::StringID *)v51);
          uint64_t v52 = *(void *)(v51 + 24);
          if (v52)
          {
            unsigned __int16 v53 = *(unint64_t **)(v51 + 32);
            int v54 = &v53[4 * v52];
            do
            {
              v102[0] = *v53;
              *(void *)&v102[1] = 0;
              unint64_t v55 = v53[2];
              *((void *)&v102[0] + 1) = v53[3];
              *(void *)&v102[1] = v55;
              re::ContactDeformerModelBuilder::addContactTarget((id **)v100, v28, (uint64_t *)v102);
              v53 += 4;
            }
            while (v53 != v54);
          }
        }
        while (++v28 != v26);
      }
      unint64_t v12 = (const char *)(v81 + (v13 << 9));
      unint64_t v26 = *((void *)v12 + 46);
      if (v26)
      {
        unsigned int v56 = (unint64_t *)(v12 + 368);
        re::SmoothDeformerModelBuilder::SmoothDeformerModelBuilder((re::SmoothDeformerModelBuilder *)v114, v77, v82, *((void *)v12 + 46), &v99);
        unint64_t v14 = 0;
        unint64_t v28 = 0;
        unint64_t v17 = (unint64_t)(v12 + 384);
        do
        {
          uint64_t v27 = (unint64_t *)*v56;
          if (*v56 <= v28) {
            goto LABEL_96;
          }
          inited = (_anonymous_namespace_ *)re::SmoothDeformerModelBuilder::setEnvelopeBufferName((re::SmoothDeformerModelBuilder *)v114, *(unsigned __int16 *)(*(void *)v17 + v14 + 16), v28++, (const re::StringID *)(*(void *)v17 + v14));
          v14 += 24;
        }
        while (v26 != v28);
        unint64_t v17 = 144;
      }
      unsigned __int16 v57 = (const char *)*((void *)v12 + 61);
      if (v57)
      {
        uint64_t v58 = (unint64_t *)(v12 + 488);
        re::JiggleDeformerModelBuilder::JiggleDeformerModelBuilder((re::JiggleDeformerModelBuilder *)v114, v77, (unsigned __int16)v82, (unsigned __int16)*((void *)v12 + 61), &v99);
        unint64_t v14 = 0;
        unint64_t v12 = 0;
        unint64_t v28 = v81 + (v13 << 9) + 504;
        do
        {
          unint64_t v17 = *v58;
          if (*v58 <= (unint64_t)v12) {
            goto LABEL_97;
          }
          inited = (_anonymous_namespace_ *)re::JiggleDeformerModelBuilder::setData((re::JiggleDeformerModelBuilder *)v114, *(unsigned __int16 *)(*(void *)v28 + v14 + 40), (unsigned __int16)v12++, (const re::StringID *)(*(void *)v28 + v14), (const re::StringID *)(*(void *)v28 + v14 + 16), *(float *)(*(void *)v28 + v14 + 32), *(float *)(*(void *)v28 + v14 + 36));
          v14 += 48;
        }
        while (v57 != v12);
        unint64_t v17 = 144;
      }
      uint64_t v59 = v81 + (v13 << 9);
      unint64_t v26 = *(void *)(v59 + 448);
      if (v26)
      {
        uint64_t v60 = (const char **)(v59 + 448);
        re::OffsetsDeformerModelBuilder::OffsetsDeformerModelBuilder((re::OffsetsDeformerModelBuilder *)v114, v77, v82, *(void *)(v59 + 448), &v99);
        uint64_t v61 = 0;
        unint64_t v28 = 0;
        unint64_t v14 = v59 + 464;
        do
        {
          unint64_t v12 = *v60;
          if ((unint64_t)*v60 <= v28) {
            goto LABEL_98;
          }
          inited = (_anonymous_namespace_ *)re::OffsetsDeformerModelBuilder::setEnvelopeBufferName((re::OffsetsDeformerModelBuilder *)v114, *(unsigned __int16 *)(*(void *)v14 + v61 + 16), v28++, (const re::StringID *)(*(void *)v14 + v61));
          v61 += 24;
        }
        while (v26 != v28);
      }
      unint64_t v62 = (unint64_t)*v86;
      if (*v84)
      {
        unint64_t v26 = (unint64_t)&v96;
        if (v62)
        {
          unint64_t v13 = 0;
          uint64_t v63 = v81 + (v76 << 9);
          unint64_t v12 = (const char *)(v63 + 224);
          unsigned __int16 v64 = (void *)(v63 + 184);
          unint64_t v14 = 1;
          while (1)
          {
            unint64_t v28 = (unint64_t)*v86;
            if ((unint64_t)*v86 <= v13) {
              break;
            }
            unint64_t v28 = *v84;
            if (*v84 <= v13) {
              goto LABEL_100;
            }
            unint64_t v28 = *((void *)&v96 + 1);
            if (*((void *)&v96 + 1) <= v13) {
              goto LABEL_101;
            }
            re::MeshPart::operator=((uint64_t *)(v97 + 560 * v13), (uint64_t *)v102);
            re::StringID::destroyString((re::StringID *)v113);
            re::FixedArray<re::StringID>::deinit(v112);
            re::AttributeTable::~AttributeTable((re::AttributeTable *)v102);
            unint64_t v13 = v14;
            BOOL v65 = v62 > v14;
            unint64_t v14 = (v14 + 1);
            if (!v65) {
              goto LABEL_88;
            }
          }
LABEL_99:
          *(void *)long long v100 = 0;
          long long v104 = 0u;
          long long v103 = 0u;
          memset(v102, 0, sizeof(v102));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v121[0]) = 136315906;
          *(void *)((char *)v121 + 4) = "operator[]";
          WORD6(v121[0]) = 1024;
          *(_DWORD *)((char *)v121 + 14) = 797;
          WORD1(v121[1]) = 2048;
          *(void *)((char *)&v121[1] + 4) = v13;
          WORD6(v121[1]) = 2048;
          *(void *)((char *)&v121[1] + 14) = v28;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_100:
          *(void *)int v114 = 0;
          long long v122 = 0u;
          long long v123 = 0u;
          memset(v121, 0, sizeof(v121));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v100 = 136315906;
          *(void *)&v100[4] = "operator[]";
          *(_WORD *)&v100[12] = 1024;
          *(_DWORD *)&v100[14] = 797;
          *(_WORD *)&v100[18] = 2048;
          *(void *)&v100[20] = v13;
          *(_WORD *)&v100[28] = 2048;
          *(void *)&v100[30] = v28;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_101:
          *(void *)int v114 = 0;
          long long v122 = 0u;
          long long v123 = 0u;
          memset(v121, 0, sizeof(v121));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v100 = 136315906;
          *(void *)&v100[4] = "operator[]";
          *(_WORD *)&v100[12] = 1024;
          *(_DWORD *)&v100[14] = 468;
          *(_WORD *)&v100[18] = 2048;
          *(void *)&v100[20] = v13;
          *(_WORD *)&v100[28] = 2048;
          *(void *)&v100[30] = v28;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_102:
          *(void *)int v114 = 0;
          long long v104 = 0u;
          long long v103 = 0u;
          memset(v102, 0, sizeof(v102));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v121[0]) = 136315906;
          *(void *)((char *)v121 + 4) = "operator[]";
          WORD6(v121[0]) = 1024;
          *(_DWORD *)((char *)v121 + 14) = 797;
          WORD1(v121[1]) = 2048;
          *(void *)((char *)&v121[1] + 4) = v17;
          WORD6(v121[1]) = 2048;
          *(void *)((char *)&v121[1] + 14) = v14;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_103:
          uint64_t v92 = 0;
          long long v122 = 0u;
          long long v123 = 0u;
          memset(v121, 0, sizeof(v121));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v114 = 136315906;
          *(void *)&v114[4] = "operator[]";
          __int16 v115 = 1024;
          int v116 = 468;
          __int16 v117 = 2048;
          unint64_t v118 = v17;
          __int16 v119 = 2048;
          unint64_t v120 = v14;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_104;
        }
      }
      else
      {
        *(_OWORD *)long long v100 = xmmword_23435FD50;
        *(_OWORD *)&v100[16] = xmmword_23435FD60;
        *(_OWORD *)&v100[32] = xmmword_23435FD80;
        long long v101 = xmmword_23435FBB0;
        unint64_t v26 = (unint64_t)&v96;
        if (v62)
        {
          unint64_t v17 = 0;
          unint64_t v12 = (const char *)(v81 + (v13 << 9) + 224);
          unsigned int v66 = 1;
          do
          {
            unint64_t v14 = (unint64_t)*v86;
            if ((unint64_t)*v86 <= v17) {
              goto LABEL_102;
            }
            unint64_t v14 = *((void *)&v96 + 1);
            if (*((void *)&v96 + 1) <= v17) {
              goto LABEL_103;
            }
            re::MeshPart::operator=((uint64_t *)(v97 + 560 * v17), (uint64_t *)v102);
            re::StringID::destroyString((re::StringID *)v113);
            re::FixedArray<re::StringID>::deinit(v112);
            re::AttributeTable::~AttributeTable((re::AttributeTable *)v102);
            unint64_t v17 = v66;
            BOOL v65 = v62 > v66++;
          }
          while (v65);
        }
        unint64_t v17 = 144;
      }
LABEL_88:
      uint64_t v67 = v81 + (v76 << 9);
      long long v68 = *(_OWORD *)(v67 + 32);
      int32x4_t v94 = *(int32x4_t *)(v67 + 16);
      long long v95 = v68;
      unint64_t v69 = *(void *)(v67 + 288);
      uint64_t v71 = *(void *)(v67 + 288);
      if ((void)v98 != v71) {
        goto LABEL_109;
      }
      if (v71) {
        memmove(*((void **)&v98 + 1), *(const void **)(v67 + 304), 12 * v71);
      }
      re::DynamicArray<re::MeshModel>::add(v73, (uint64_t *)&v93);
      re::MeshModel::~MeshModel((re::MeshModel *)&v93);
      unint64_t v13 = v76 + 1;
      unsigned int v5 = v78;
      if (v76 + 1 == v75) {
        return re::FixedArray<re::BufferSlice>::deinit(&v89);
      }
    }
    re::BlendShapeModelBuilder::BlendShapeModelBuilder((re::BlendShapeModelBuilder *)v100, v77, (id *)this, v82, v21[16], &v99);
    uint64_t v27 = 0;
    unint64_t v28 = 0;
    unint64_t v14 = (unint64_t)(v21 + 18);
    while (1)
    {
      unint64_t v12 = *v25;
      if ((unint64_t)*v25 <= v28) {
        break;
      }
      re::BlendShapeModelBuilder::addBlendShapeGroup((uint64_t)v100, (unint64_t)v27 + *(void *)v14, *(unsigned __int16 *)((char *)v27 + *(void *)v14 + 48), v28++, 0);
      v27 += 7;
      if (v26 == v28)
      {

        uint64_t v21 = (void *)(v81 + (v13 << 9));
        goto LABEL_20;
      }
    }
    *(void *)int v114 = 0;
    long long v104 = 0u;
    long long v103 = 0u;
    memset(v102, 0, sizeof(v102));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v121[0]) = 136315906;
    *(void *)((char *)v121 + 4) = "operator[]";
    WORD6(v121[0]) = 1024;
    *(_DWORD *)((char *)v121 + 14) = 797;
    WORD1(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 4) = v28;
    WORD6(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 14) = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_94:
    *(void *)int v114 = 0;
    long long v104 = 0u;
    long long v103 = 0u;
    memset(v102, 0, sizeof(v102));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v121[0]) = 136315906;
    *(void *)((char *)v121 + 4) = "operator[]";
    WORD6(v121[0]) = 1024;
    *(_DWORD *)((char *)v121 + 14) = 797;
    WORD1(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 4) = v28;
    WORD6(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 14) = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_95:
    *(void *)int v114 = 0;
    long long v104 = 0u;
    long long v103 = 0u;
    memset(v102, 0, sizeof(v102));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v121[0]) = 136315906;
    *(void *)((char *)v121 + 4) = "operator[]";
    WORD6(v121[0]) = 1024;
    *(_DWORD *)((char *)v121 + 14) = 797;
    WORD1(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 4) = v28;
    WORD6(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 14) = v14;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_96:
    *(void *)long long v100 = 0;
    long long v104 = 0u;
    long long v103 = 0u;
    memset(v102, 0, sizeof(v102));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v121[0]) = 136315906;
    *(void *)((char *)v121 + 4) = "operator[]";
    WORD6(v121[0]) = 1024;
    *(_DWORD *)((char *)v121 + 14) = 797;
    WORD1(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 4) = v28;
    WORD6(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 14) = v27;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_97:
    *(void *)long long v100 = 0;
    long long v104 = 0u;
    long long v103 = 0u;
    memset(v102, 0, sizeof(v102));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v121[0]) = 136315906;
    *(void *)((char *)v121 + 4) = "operator[]";
    WORD6(v121[0]) = 1024;
    *(_DWORD *)((char *)v121 + 14) = 797;
    WORD1(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 4) = v12;
    WORD6(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 14) = v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_98:
    *(void *)long long v100 = 0;
    long long v104 = 0u;
    long long v103 = 0u;
    memset(v102, 0, sizeof(v102));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v121[0]) = 136315906;
    *(void *)((char *)v121 + 4) = "operator[]";
    WORD6(v121[0]) = 1024;
    *(_DWORD *)((char *)v121 + 14) = 797;
    WORD1(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 4) = v28;
    WORD6(v121[1]) = 2048;
    *(void *)((char *)&v121[1] + 14) = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_99;
  }
  return re::FixedArray<re::BufferSlice>::deinit(&v89);
}

uint64_t re::makeMeshAssetDataFromDescriptor@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = a2;
  uint64_t v76 = *MEMORY[0x263EF8340];
  unint64_t v7 = &v46;
  memset(v25, 0, sizeof(v25));
  int v26 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  int v29 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  int v32 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v34 = 0x7FFFFFFFLL;
  unint64_t v8 = a1[2];
  unint64_t v24 = v8;
  if (!v8)
  {
LABEL_37:
    unint64_t v18 = a1[12];
    if (v8 >= v18)
    {
      if (!v18)
      {
LABEL_54:
        re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=((uint64_t)&v33[8], (uint64_t)(a1 + 15));
        unint64_t v20 = a1[7];
        if ((unint64_t)v28 >= v20)
        {
          if (!v20)
          {
LABEL_60:
            re::makeMeshAssetDataFromGeomScene(v25, v4, a3);
            goto LABEL_61;
          }
        }
        else
        {
          re::DynamicArray<re::RigSplineIKJoint>::setCapacity((void *)&v27 + 1, a1[7]);
        }
        unint64_t v9 = 0;
        while (1)
        {
          unint64_t v3 = a1[7];
          if (v3 <= v9) {
            goto LABEL_69;
          }
          re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)((char *)&v27 + 8), *(void *)(a1[9] + 8 * v9++) + 32);
          if (v20 == v9) {
            goto LABEL_60;
          }
        }
      }
    }
    else
    {
      re::DynamicArray<re::GeomSkeleton>::setCapacity((void *)&v30 + 1, a1[12]);
    }
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v3 = a1[12];
      if (v3 <= v9) {
        break;
      }
      re::DynamicArray<re::GeomSkeleton>::add((_anonymous_namespace_ *)((char *)&v30 + 8), (StringID *)(*(void *)(a1[14] + 8 * v9++) + 24));
      if (v18 == v9) {
        goto LABEL_54;
      }
    }
LABEL_68:
    *(void *)&v73[0] = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    memset(v36, 0, sizeof(v36));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v46) = 136315906;
    *(uint64_t *)((char *)v7 + 4) = (uint64_t)"operator[]";
    __int16 v48 = 1024;
    *(_DWORD *)((char *)v7 + 14) = 797;
    WORD1(v49) = 2048;
    *(uint64_t *)((char *)v7 + 20) = v9;
    __int16 v50 = 2048;
    *(uint64_t *)((char *)v7 + 30) = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_69:
    *(void *)&v73[0] = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    memset(v36, 0, sizeof(v36));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v46) = 136315906;
    *(uint64_t *)((char *)v7 + 4) = (uint64_t)"operator[]";
    __int16 v48 = 1024;
    *(_DWORD *)((char *)v7 + 14) = 797;
    WORD1(v49) = 2048;
    *(uint64_t *)((char *)v7 + 20) = v9;
    __int16 v50 = 2048;
    *(uint64_t *)((char *)v7 + 30) = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_70:
    *(void *)unsigned int v66 = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    memset(v36, 0, sizeof(v36));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v73[0]) = 136315906;
    *(void *)((char *)v73 + 4) = "operator[]";
    WORD6(v73[0]) = 1024;
    *(_DWORD *)((char *)v73 + 14) = 797;
    WORD1(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 4) = v9;
    WORD6(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 14) = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_71:
    *(void *)unsigned int v66 = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    memset(v36, 0, sizeof(v36));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v73[0]) = 136315906;
    *(void *)((char *)v73 + 4) = "operator[]";
    WORD6(v73[0]) = 1024;
    *(_DWORD *)((char *)v73 + 14) = 797;
    WORD1(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 4) = v9;
    WORD6(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 14) = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_72:
    *(void *)unsigned int v66 = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    memset(v36, 0, sizeof(v36));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v73[0]) = 136315906;
    *(void *)((char *)v73 + 4) = "operator[]";
    WORD6(v73[0]) = 1024;
    *(_DWORD *)((char *)v73 + 14) = 797;
    WORD1(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 4) = v9;
    WORD6(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 14) = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_73:
    *(void *)unsigned int v66 = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    memset(v36, 0, sizeof(v36));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v73[0]) = 136315906;
    *(void *)((char *)v73 + 4) = "operator[]";
    WORD6(v73[0]) = 1024;
    *(_DWORD *)((char *)v73 + 14) = 797;
    WORD1(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 4) = v9;
    WORD6(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 14) = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_74:
    *(void *)unsigned int v66 = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    memset(v36, 0, sizeof(v36));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v73[0]) = 136315906;
    *(void *)((char *)v73 + 4) = "operator[]";
    WORD6(v73[0]) = 1024;
    *(_DWORD *)((char *)v73 + 14) = 797;
    WORD1(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 4) = v9;
    WORD6(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 14) = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_75:
    *(void *)unsigned int v66 = 0;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    memset(v36, 0, sizeof(v36));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v73[0]) = 136315906;
    *(void *)((char *)v73 + 4) = "operator[]";
    WORD6(v73[0]) = 1024;
    *(_DWORD *)((char *)v73 + 14) = 797;
    WORD1(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 4) = v9;
    WORD6(v73[1]) = 2048;
    *(void *)((char *)&v73[1] + 14) = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  uint64_t v23 = a3;
  unint64_t v9 = 0;
  while (1)
  {
    re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)&v46);
    unint64_t v7 = (uint64_t *)a1[2];
    if ((unint64_t)v7 <= v9) {
      goto LABEL_70;
    }
    unint64_t v3 = *(void *)(a1[4] + 152 * v9 + 48);
    if (v52 < v3) {
      break;
    }
    if (v3) {
      goto LABEL_7;
    }
LABEL_19:
    if ((unint64_t)v7 <= v9) {
      goto LABEL_71;
    }
    re::DynamicString::operator=((re::DynamicString *)&v46, (re::DynamicString *)(a1[4] + 152 * v9));
    unint64_t v3 = a1[2];
    if (v3 <= v9) {
      goto LABEL_72;
    }
    re::DynamicArray<float>::resize((uint64_t)&v61, *(void *)(a1[4] + 152 * v9 + 128));
    unint64_t v3 = a1[2];
    if (v3 <= v9) {
      goto LABEL_73;
    }
    re::DynamicArray<float>::resize((uint64_t)&v56, *(void *)(a1[4] + 152 * v9 + 88));
    unint64_t v3 = a1[2];
    if (v3 <= v9) {
      goto LABEL_74;
    }
    memcpy(__dst, *(const void **)(a1[4] + 152 * v9 + 144), 4 * *(void *)(a1[4] + 152 * v9 + 128));
    unint64_t v3 = a1[2];
    if (v3 <= v9) {
      goto LABEL_75;
    }
    memcpy(v60, *(const void **)(a1[4] + 152 * v9 + 104), 4 * *(void *)(a1[4] + 152 * v9 + 88));
    v17.n128_f64[0] = re::DynamicArray<re::GeomModelWithLods>::add((_anonymous_namespace_ *)v25, (uint64_t)&v46);
    if (v61)
    {
      if (__dst) {
        (*(void (**)(double))(*(void *)v61 + 40))(v17.n128_f64[0]);
      }
      unsigned int __dst = 0;
      uint64_t v62 = 0;
      uint64_t v63 = 0;
      uint64_t v61 = 0;
      ++v64;
    }
    if (v56)
    {
      if (v60) {
        (*(void (**)(__n128))(*(void *)v56 + 40))(v17);
      }
      uint64_t v60 = 0;
      uint64_t v57 = 0;
      uint64_t v58 = 0;
      uint64_t v56 = 0;
      ++v59;
    }
    re::DynamicArray<re::GeomModel>::deinit((uint64_t)&v51);
    if (v46 && (v47 & 1) != 0) {
      (*(void (**)(void))(*(void *)v46 + 40))();
    }
    if (++v9 == v24)
    {
      unint64_t v8 = v31;
      unint64_t v7 = &v46;
      uint64_t v4 = a2;
      a3 = v23;
      goto LABEL_37;
    }
  }
  re::DynamicArray<re::GeomModel>::setCapacity(&v51, *(void *)(a1[4] + 152 * v9 + 48));
LABEL_7:
  unint64_t v10 = 0;
  while (1)
  {
    unint64_t v7 = (uint64_t *)a1[2];
    if ((unint64_t)v7 <= v9)
    {
      uint64_t v35 = 0;
      long long v74 = 0u;
      long long v75 = 0u;
      memset(v73, 0, sizeof(v73));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unsigned int v66 = 136315906;
      *(void *)&v66[4] = "operator[]";
      __int16 v67 = 1024;
      int v68 = 797;
      __int16 v69 = 2048;
      unint64_t v70 = v9;
      __int16 v71 = 2048;
      unsigned int v72 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_67:
      uint64_t v35 = 0;
      long long v74 = 0u;
      long long v75 = 0u;
      memset(v73, 0, sizeof(v73));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      *(_DWORD *)unsigned int v66 = 136315906;
      *(void *)&v66[4] = "operator[]";
      __int16 v67 = 1024;
      int v68 = 797;
      __int16 v69 = 2048;
      unint64_t v70 = v10;
      __int16 v71 = 2048;
      unsigned int v72 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_68;
    }
    uint64_t v11 = a1[4];
    unint64_t v7 = *(uint64_t **)(v11 + 152 * v9 + 48);
    if ((unint64_t)v7 <= v10) {
      goto LABEL_67;
    }
    re::makeGeomModelFromModelDescriptor((re *)(*(void *)(*(void *)(v11 + 152 * v9 + 64) + 8 * v10) + 24), (uint64_t)v36);
    if (!LOBYTE(v36[0])) {
      break;
    }
    unint64_t v12 = v53;
    if (v53 >= v52)
    {
      re::DynamicArray<re::GeomModel>::growCapacity(&v51, v53 + 1);
      unint64_t v12 = v53;
    }
    uint64_t v13 = v55;
    unint64_t v14 = (re::DynamicString *)(v55 + 248 * v12);
    re::DynamicString::DynamicString(v14, (const re::DynamicString *)((char *)v36 + 8));
    re::DynamicArray<re::GeomMesh>::DynamicArray((uint64_t)v14 + 32, (uint64_t *)&v37 + 1);
    re::DynamicArray<float>::DynamicArray((uint64_t)v14 + 72, v40);
    int v15 = v41;
    *((unsigned char *)v14 + 112) = v41;
    if (v15) {
      re::DynamicArray<re::GeomIndexMap>::DynamicArray(v13 + 248 * v12 + 120, v42);
    }
    int v16 = v43;
    *(unsigned char *)(v13 + 248 * v12 + 160) = v43;
    if (v16) {
      re::DynamicArray<re::GeomIndexMap>::DynamicArray(v13 + 248 * v12 + 168, v44);
    }
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::DynamicArray(v13 + 248 * v12 + 208, v45);
    ++v53;
    ++v54;
    re::Result<re::GeomModel,re::DetailedError>::~Result(v36);
    if (v3 == ++v10)
    {
      unint64_t v7 = (uint64_t *)a1[2];
      goto LABEL_19;
    }
  }
  v73[0] = *(_OWORD *)((char *)v36 + 8);
  re::DynamicString::DynamicString((re::DynamicString *)&v73[1], (const re::DynamicString *)((char *)&v36[1] + 8));
  *(unsigned char *)uint64_t v23 = 0;
  *(_OWORD *)(v23 + 8) = v73[0];
  uint64_t v19 = *((void *)&v73[2] + 1);
  *(void *)(v23 + 24) = *(void *)&v73[1];
  *(void *)(v23 + 48) = v19;
  *(_OWORD *)(v23 + 32) = *(_OWORD *)((char *)&v73[1] + 8);
  re::Result<re::GeomModel,re::DetailedError>::~Result(v36);
  if (v61)
  {
    if (__dst) {
      (*(void (**)(void))(*(void *)v61 + 40))();
    }
    unsigned int __dst = 0;
    uint64_t v62 = 0;
    uint64_t v63 = 0;
    uint64_t v61 = 0;
    ++v64;
  }
  if (v56)
  {
    if (v60) {
      (*(void (**)(void))(*(void *)v56 + 40))();
    }
    uint64_t v60 = 0;
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    uint64_t v56 = 0;
    ++v59;
  }
  re::DynamicArray<re::GeomModel>::deinit((uint64_t)&v51);
  if (v46 && (v47 & 1) != 0) {
    (*(void (**)(void))(*(void *)v46 + 40))();
  }
LABEL_61:
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v33[8]);
  re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v30 + 8);
  if (*((void *)&v27 + 1))
  {
    if ((void)v30) {
      (*(void (**)(void))(**((void **)&v27 + 1) + 40))();
    }
    *(void *)&long long v30 = 0;
    long long v28 = 0uLL;
    *((void *)&v27 + 1) = 0;
    ++v29;
  }
  return re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)v25);
}

uint64_t re::DynamicArray<re::GeomSkeleton>::add(_anonymous_namespace_ *this, StringID *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::GeomSkeleton>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  unsigned int v5 = (void *)(*((void *)this + 4) + 160 * v4);
  re::StringID::StringID((re::StringID *)v5, a2);
  re::FixedArray<re::StringID>::FixedArray(v5 + 2, (uint64_t)&a2[1]);
  re::FixedArray<unsigned int>::FixedArray(v5 + 5, (uint64_t)&a2[2].var1);
  re::FixedArray<re::GenericSRT<float>>::FixedArray(v5 + 8, (uint64_t)&a2[4]);
  re::FixedArray<re::Matrix4x4<float>>::FixedArray(v5 + 11, (uint64_t)&a2[5].var1);
  uint64_t result = re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable((uint64_t)(v5 + 14), (uint64_t)&a2[7]);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::makeMeshAssetDataWithGeomModel@<X0>(re::DynamicString *a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, uint64_t a4@<X8>)
{
  re::GeomScene::makeSceneWithSingleInstanceModel(a1, (uint64_t)v21);
  if (a2)
  {
    uint64_t v7 = *(void *)(a2 + 16);
    *(void *)&long long v16 = *(void *)(a2 + 32);
    *((void *)&v16 + 1) = v7;
    re::GeomScene::setSkeletons((uint64_t)v21, (uint64_t)&v16);
  }
  LODWORD(v16) = 16842752;
  BYTE4(v16) = 1;
  *(_DWORD *)((char *)&v16 + 5) = 0;
  *(_WORD *)((char *)&v16 + 9) = 0;
  HIDWORD(v16) = 1036831949;
  int v17 = 16843008;
  char v18 = 0;
  long long v20 = 0u;
  memset(v19, 0, sizeof(v19));
  if (a3) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = &v16;
  }
  DWORD1(v20) = 0x7FFFFFFF;
  re::makeMeshAssetDataFromGeomScene(v21, (uint64_t)v8, a4);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v19);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v28);
  re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v27);
  if (v22)
  {
    if (v26) {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v22 + 40))(v22, v26, v9, v10, v11, v12, v13, v14, v16);
    }
    uint64_t v26 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = 0;
    ++v25;
  }
  return re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)v21);
}

uint64_t re::GeomScene::makeSceneWithSingleInstanceModel@<X0>(re::DynamicString *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)&v6);
  re::DynamicString::operator=((re::DynamicString *)&v6, a1);
  re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)v8, (uint64_t)a1);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 16) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_DWORD *)(a2 + 64) = 0;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_DWORD *)(a2 + 104) = 0;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 140) = 0u;
  *(void *)(a2 + 156) = 0x7FFFFFFFLL;
  re::DynamicArray<re::GeomModelWithLods>::add((_anonymous_namespace_ *)a2, (uint64_t)&v6);
  v19[0] = xmmword_23435FD50;
  v19[1] = xmmword_23435FD60;
  _OWORD v19[2] = xmmword_23435FD80;
  void v19[3] = xmmword_23435FBB0;
  int v20 = 0;
  __n128 v4 = re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)(a2 + 40), (uint64_t)v19);
  if (v14)
  {
    if (v18) {
      (*(void (**)(__n128))(*(void *)v14 + 40))(v4);
    }
    uint64_t v18 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v14 = 0;
    ++v17;
  }
  if (v9)
  {
    if (v13) {
      (*(void (**)(__n128))(*(void *)v9 + 40))(v4);
    }
    uint64_t v13 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v9 = 0;
    ++v12;
  }
  re::DynamicArray<re::GeomModel>::deinit((uint64_t)v8);
  uint64_t result = v6;
  if (v6)
  {
    if (v7) {
      return (*(uint64_t (**)(void))(*(void *)v6 + 40))();
    }
  }
  return result;
}

uint64_t re::makeMeshAssetDataWithGeomMeshArray@<X0>(_anonymous_namespace_ *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, int *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  int v12 = 0;
  re::makeMeshAssetDataWithGeomMeshArray(a1, a2, v15, v14, a3, a4, a5);
  uint64_t result = v13;
  if (v13) {
    BOOL v11 = v14 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11) {
    return (*(uint64_t (**)(void))(*(void *)v13 + 40))();
  }
  return result;
}

uint64_t re::makeMeshAssetDataWithGeomMeshArray@<X0>(re::GeomMesh *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, int *a6@<X5>, uint64_t a7@<X8>)
{
  v68[5] = *MEMORY[0x263EF8340];
  v38[0] = 0;
  v38[1] = 0;
  uint64_t v39 = 0;
  long long v41 = 0u;
  long long v42 = 0u;
  int v40 = 0;
  int v43 = 0;
  long long v44 = 0u;
  long long v45 = 0u;
  int v46 = 0;
  memset(v47, 0, sizeof(v47));
  uint64_t v48 = 0x7FFFFFFFLL;
  re::GeomModelWithLods::GeomModelWithLods((re::GeomModelWithLods *)&v25);
  re::GeomModel::GeomModel((re::GeomModel *)&v56);
  re::DynamicArray<re::GeomModel>::add((_anonymous_namespace_ *)v27, (uint64_t)&v56);
  re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit((uint64_t)v68);
  if (v66[40]) {
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)&v67);
  }
  if (v65) {
    re::DynamicArray<re::GeomIndexMap>::deinit((uint64_t)v66);
  }
  if (*((void *)&v60 + 1))
  {
    if (v64) {
      (*(void (**)(void))(**((void **)&v60 + 1) + 40))();
    }
    uint64_t v64 = 0;
    uint64_t v61 = 0;
    uint64_t v62 = 0;
    *((void *)&v60 + 1) = 0;
    ++v63;
  }
  re::DynamicArray<re::GeomMesh>::deinit((uint64_t)&v58);
  if (void)v56 && (BYTE8(v56)) {
    (*(void (**)(void))(*(void *)v56 + 40))();
  }
  re::DynamicArray<re::GeomModelWithLods>::add((_anonymous_namespace_ *)v38, (uint64_t)&v25);
  if (!v39)
  {
LABEL_51:
    uint64_t v49 = 0;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v56 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v50 = 136315906;
    uint64_t v51 = "operator[]";
    uint64_t v52 = 0x800000003150400;
    *(void *)unint64_t v53 = 0;
    *(_WORD *)&uint8_t v53[8] = 2048;
    *(void *)&v53[10] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_52:
    uint64_t v49 = 0;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v56 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v50 = 136315906;
    uint64_t v51 = "operator[]";
    uint64_t v52 = 0x800000003150400;
    *(void *)unint64_t v53 = 0;
    *(_WORD *)&uint8_t v53[8] = 2048;
    *(void *)&v53[10] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (!*(void *)(v41 + 48)) {
    goto LABEL_52;
  }
  uint64_t v13 = *(void **)(v41 + 64);
  unint64_t v14 = a2;
  if (v13[5] < (unint64_t)a2) {
    re::DynamicArray<re::GeomMesh>::setCapacity(v13 + 4, a2);
  }
  LODWORD(v56) = 0;
  re::DynamicArray<unsigned int>::resize(v13 + 9, a2, &v56);
  if (a2)
  {
    uint64_t v15 = 736 * a2;
    do
    {
      re::DynamicArray<re::GeomMesh>::add((_anonymous_namespace_ *)(v13 + 4), a1);
      a1 = (re::GeomMesh *)((char *)a1 + 736);
      v15 -= 736;
    }
    while (v15);
  }
  if (a4)
  {
    for (unint64_t i = 0; a4 != i; ++i)
    {
      if (i < v14)
      {
        unint64_t v17 = v13[11];
        if (v17 <= i)
        {
          uint64_t v49 = 0;
          long long v59 = 0u;
          long long v60 = 0u;
          long long v57 = 0u;
          long long v58 = 0u;
          long long v56 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v50 = 136315906;
          uint64_t v51 = "operator[]";
          uint64_t v52 = 0x800000003150400;
          *(void *)unint64_t v53 = i;
          *(_WORD *)&uint8_t v53[8] = 2048;
          *(void *)&v53[10] = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_51;
        }
        *(_DWORD *)(v13[13] + 4 * i) = *(_DWORD *)(a3 + 4 * i);
      }
    }
  }
  if (a5)
  {
    uint64_t v18 = *(StringID **)(a5 + 32);
    unint64_t v19 = *(void *)(a5 + 16);
    if ((unint64_t)v45 < v19)
    {
      re::DynamicArray<re::GeomSkeleton>::setCapacity((void *)&v44 + 1, v19);
      goto LABEL_29;
    }
    if (v19)
    {
LABEL_29:
      uint64_t v20 = 160 * v19;
      do
      {
        re::DynamicArray<re::GeomSkeleton>::add((_anonymous_namespace_ *)((char *)&v44 + 8), v18);
        LODWORD(v56) = DWORD2(v45) - 1;
        re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<unsigned int &>((uint64_t)&v47[8], v18, &v56);
        v18 += 10;
        v20 -= 160;
      }
      while (v20);
    }
  }
  long long v56 = xmmword_23435FD50;
  long long v57 = xmmword_23435FD60;
  long long v58 = xmmword_23435FD80;
  long long v59 = xmmword_23435FBB0;
  LODWORD(v60) = 0;
  re::DynamicArray<re::GeomInstance>::add((_anonymous_namespace_ *)((char *)&v41 + 8), (uint64_t)&v56);
  int v50 = 16842752;
  LOBYTE(v51) = 1;
  *(_DWORD *)((char *)&v51 + 1) = 0;
  *(_WORD *)((char *)&v51 + 5) = 0;
  uint64_t v52 = 0x10101003DCCCCCDLL;
  v53[0] = 0;
  long long v55 = 0u;
  *(_OWORD *)&v53[4] = 0u;
  long long v54 = 0u;
  if (a6) {
    uint64_t v21 = a6;
  }
  else {
    uint64_t v21 = &v50;
  }
  DWORD1(v55) = 0x7FFFFFFF;
  re::makeMeshAssetDataFromGeomScene(v38, (uint64_t)v21, a7);
  v22.n128_f64[0] = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v53[4]);
  if (v33)
  {
    if (v37) {
      (*(void (**)(double))(*(void *)v33 + 40))(v22.n128_f64[0]);
    }
    uint64_t v37 = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v33 = 0;
    ++v36;
  }
  if (v28)
  {
    if (v32) {
      (*(void (**)(__n128))(*(void *)v28 + 40))(v22);
    }
    uint64_t v32 = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    uint64_t v28 = 0;
    ++v31;
  }
  re::DynamicArray<re::GeomModel>::deinit((uint64_t)v27);
  if (v25 && (v26 & 1) != 0) {
    (*(void (**)(void))(*(void *)v25 + 40))();
  }
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v47[8]);
  re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)&v44 + 8);
  if (*((void *)&v41 + 1))
  {
    if ((void)v44) {
      (*(void (**)(void))(**((void **)&v41 + 1) + 40))();
    }
    *(void *)&long long v44 = 0;
    long long v42 = 0uLL;
    *((void *)&v41 + 1) = 0;
    ++v43;
  }
  return re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)v38);
}

void re::anonymous namespace'::populateAssetPartFromGeomMesh(unint64_t a1, unint64_t a2, uint64_t *a3, uint64_t *a4, __int16 a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t *a9, unint64_t a10)
{
  uint64_t v299 = *MEMORY[0x263EF8340];
  re::GeomMesh::GeomMesh((re::GeomMesh *)v257, 0);
  if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(a2 + 40))
  {
LABEL_15:
    BOOL v19 = 0;
    goto LABEL_16;
  }
  BOOL v19 = 0;
  if (!*(_DWORD *)(a2 + 424)
    && !*(unsigned char *)a1
    && !*(unsigned char *)(a1 + 8)
    && !*(unsigned char *)(a1 + 1)
    && !*(unsigned char *)(a1 + 2)
    && !*(unsigned char *)(a1 + 3))
  {
    uint64_t v20 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a2 + 64), "vertexNormal");
    if (v20)
    {
      if (*(unsigned char *)(v20 + 16) == 1)
      {
        uint64_t v21 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a2 + 64), "vertexTangent");
        if (v21)
        {
          if (*(unsigned char *)(v21 + 16) == 1)
          {
            uint64_t v22 = re::internal::GeomAttributeManager::attributeByName((re::internal::GeomAttributeManager *)(a2 + 64), "vertexBitangent");
            if (!v22 || *(unsigned char *)(v22 + 16) == 1)
            {
              BOOL v19 = v22 != 0;
              goto LABEL_16;
            }
          }
        }
      }
    }
    goto LABEL_15;
  }
LABEL_16:
  uint64_t v250 = *a3;
  int v251 = *((_DWORD *)a3 + 2);
  char v252 = *((unsigned char *)a3 + 12);
  if (v252 == 2)
  {
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown((uint64_t)&v253, a3 + 2);
  }
  else if (v252 == 1)
  {
    re::DynamicArray<float>::DynamicArray((uint64_t)&v253, a3 + 2);
  }
  else
  {
    if (v252)
    {
      re::internal::assertLog((re::internal *)4, v18, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 433);
      _os_crash();
      __break(1u);
      goto LABEL_607;
    }
    LODWORD(v253) = *((_DWORD *)a3 + 4);
  }
  uint64_t v243 = *a4;
  int v244 = *((_DWORD *)a4 + 2);
  char v245 = *((unsigned char *)a4 + 12);
  switch(v245)
  {
    case 2:
      re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown((uint64_t)&v246, a4 + 2);
      break;
    case 1:
      re::DynamicArray<float>::DynamicArray((uint64_t)&v246, a4 + 2);
      break;
    case 0:
      LODWORD(v246) = *((_DWORD *)a4 + 4);
      break;
    default:
LABEL_607:
      re::internal::assertLog((re::internal *)4, v18, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 433);
      _os_crash();
      __break(1u);
      goto LABEL_608;
  }
  uint64_t v236 = *a3;
  int v237 = *((_DWORD *)a3 + 2);
  char v238 = *((unsigned char *)a3 + 12);
  long long v221 = (re::UniqueNameGenerator *)a8;
  __int16 v222 = a5;
  uint64_t v223 = a7;
  switch(v238)
  {
    case 2:
      re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown((uint64_t)&v239, a3 + 2);
      break;
    case 1:
      re::DynamicArray<float>::DynamicArray((uint64_t)&v239, a3 + 2);
      break;
    case 0:
      LODWORD(v239) = *((_DWORD *)a3 + 4);
      break;
    default:
LABEL_608:
      re::internal::assertLog((re::internal *)4, v18, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 433);
      _os_crash();
      __break(1u);
      goto LABEL_609;
  }
  uint64_t v23 = a2;
  if (v19) {
    goto LABEL_75;
  }
  *(void *)long long buf = 0xFFFFFFFF00000000;
  *(_DWORD *)&uint8_t buf[8] = -1;
  unsigned char buf[12] = 0;
  LODWORD(v260) = 0;
  re::makeConditionedMeshForGPU((unsigned int *)a2, a1, v257, (const re::GeomIndexMap *)&v236, (uint64_t)buf, v279);
  re::remapIndexMap((unsigned int *)&v236, (const re::GeomIndexMap *)a3, (uint64_t)v297);
  re::GeomIndexMap::operator=((uint64_t)&v250, (uint64_t)v297);
  if (BYTE12(v297[0]))
  {
    if (BYTE12(v297[0]) == 2)
    {
      uint64_t v25 = *((void *)&v298 + 1);
      if (!*((void *)&v298 + 1)) {
        goto LABEL_46;
      }
      if (*((void *)&v297[1] + 1)) {
        *((void *)&v297[1] + 1) = 0;
      }
      if (!*(void *)&v297[1]) {
        goto LABEL_46;
      }
    }
    else
    {
      if (BYTE12(v297[0]) != 1) {
        goto LABEL_613;
      }
      uint64_t v25 = *(void *)&v297[1];
      if (!*(void *)&v297[1] || !*(void *)&v297[3]) {
        goto LABEL_46;
      }
    }
    (*(void (**)(uint64_t))(*(void *)v25 + 40))(v25);
  }
LABEL_46:
  re::remapIndexMap((unsigned int *)buf, (const re::GeomIndexMap *)a4, (uint64_t)v297);
  re::GeomIndexMap::operator=((uint64_t)&v243, (uint64_t)v297);
  if (!BYTE12(v297[0])) {
    goto LABEL_57;
  }
  if (BYTE12(v297[0]) == 2)
  {
    uint64_t v27 = *((void *)&v298 + 1);
    if (!*((void *)&v298 + 1)) {
      goto LABEL_57;
    }
    if (*((void *)&v297[1] + 1)) {
      *((void *)&v297[1] + 1) = 0;
    }
    uint64_t v26 = *(void *)&v297[1];
    if (!*(void *)&v297[1]) {
      goto LABEL_57;
    }
LABEL_56:
    (*(void (**)(uint64_t))(*(void *)v27 + 40))(v27);
    goto LABEL_57;
  }
  if (BYTE12(v297[0]) != 1) {
    goto LABEL_614;
  }
  uint64_t v27 = *(void *)&v297[1];
  if (*(void *)&v297[1])
  {
    uint64_t v26 = *(void *)&v297[3];
    if (*(void *)&v297[3]) {
      goto LABEL_56;
    }
  }
LABEL_57:
  if (!v279[0] && *(void *)&v279[24] && (v279[32] & 1) != 0) {
    (*(void (**)(void))(**(void **)&v279[24] + 40))();
  }
  switch(buf[12])
  {
    case 0u:
      goto LABEL_74;
    case 2u:
      uint64_t v28 = *((void *)&v263 + 1);
      if (!*((void *)&v263 + 1)) {
        goto LABEL_74;
      }
      if (*((void *)&v260 + 1)) {
        *((void *)&v260 + 1) = 0;
      }
      if (!(void)v260) {
        goto LABEL_74;
      }
      uint64_t v29 = &v260;
      break;
    case 1u:
      uint64_t v28 = v260;
      if (!(void)v260) {
        goto LABEL_74;
      }
      uint64_t v29 = &v262;
      if (!(void)v262) {
        goto LABEL_73;
      }
      break;
    default:
      goto LABEL_615;
  }
  (*(void (**)(uint64_t))(*(void *)v28 + 40))(v28);
LABEL_73:
  *(void *)uint64_t v29 = 0;
LABEL_74:
  uint64_t v23 = (uint64_t)v257;
LABEL_75:
  uint64_t v220 = a6;
  uint64_t v30 = (re::internal::GeomAttributeManager *)(v23 + 64);
  int v224 = (void *)*(unsigned int *)(v23 + 16);
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v285, 4508, *(unsigned int *)(v23 + 640));
  *(void *)&v273[32] = 0;
  memset(v273, 0, 28);
  uint64_t v31 = *(void *)(v23 + 640);
  int v229 = (unsigned int *)a2;
  unint64_t v230 = a1;
  uint64_t v228 = v23;
  int v231 = (re::internal::GeomAttributeManager *)(v23 + 64);
  if (v31)
  {
    re::DynamicArray<re::MeshAssetBuffer>::setCapacity(v273, *(void *)(v23 + 640));
    unsigned int v32 = 0;
    a8 = (unint64_t)"skinnedAnimationGeometryBindTransform";
    do
    {
      uint64_t v33 = (unsigned char *)re::internal::GeomAttributeManager::attributeByIndex(v30, v32);
      uint64_t v34 = (const char *)*((void *)v33 + 1);
      if (strcmp("skinnedAnimationGeometryBindTransform", v34))
      {
        if (strcmp("skinnedAnimationWeights", v34))
        {
          if (strcmp("skinnedAnimationJointIndices", v34))
          {
            if (strcmp("skinnedAnimationRemappedJointIndices", v34))
            {
              if (strcmp("skinnedAnimationInfluenceEndIndices", v34))
              {
                uint64_t v35 = (_anonymous_namespace_ *)strcmp("skeletonPath", v34);
                if (v35)
                {
                  unint64_t v36 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)v288);
                  if (!*(void *)(a1 + 24)
                    || (unint64_t v37 = a1,
                        uint64_t v38 = *(unsigned int *)(*(void *)(a1 + 32) + 4 * (v36 % *(unsigned int *)(a1 + 48))),
                        a8 = 0x7FFFFFFFLL,
                        v38 == 0x7FFFFFFF))
                  {
LABEL_88:
                    uint64_t v23 = 0;
                  }
                  else
                  {
                    uint64_t v39 = *(void *)(v37 + 40);
                    while (!re::DynamicString::operator==(v39 + 56 * v38 + 16, (uint64_t)v288))
                    {
                      uint64_t v38 = *(_DWORD *)(v39 + 56 * v38 + 8) & 0x7FFFFFFF;
                      if (v38 == 0x7FFFFFFF) {
                        goto LABEL_88;
                      }
                    }
                    uint64_t v23 = v39 + 56 * v38 + 48;
                  }
                  int v40 = v33[16];
                  long long v41 = (re *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                  a1 = (unint64_t)v41;
                  switch(v33[17])
                  {
                    case 0:
                      if (v23)
                      {
                        int v43 = *re::pipelineLogObjects(v41);
                        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_233120000, v43, OS_LOG_TYPE_DEFAULT, "Mesh attribute type kInt16 is not supported for compression.", buf, 2u);
                        }
                      }
                      unsigned int v44 = 50;
                      break;
                    case 1:
                      if (v23)
                      {
                        long long v45 = *re::pipelineLogObjects(v41);
                        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_233120000, v45, OS_LOG_TYPE_DEFAULT, "Mesh attribute type kUInt16 is not supported for compression.", buf, 2u);
                        }
                      }
                      unsigned int v44 = 49;
                      break;
                    case 2:
                      if (v23)
                      {
                        int v46 = *re::pipelineLogObjects(v41);
                        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_233120000, v46, OS_LOG_TYPE_DEFAULT, "Mesh attribute type kInt32 is not supported for compression.", buf, 2u);
                        }
                      }
                      unsigned int v44 = 32;
                      break;
                    case 3:
                      if (v23)
                      {
                        char v47 = *re::pipelineLogObjects(v41);
                        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_233120000, v47, OS_LOG_TYPE_DEFAULT, "Mesh attribute type kUInt32 is not supported for compression.", buf, 2u);
                        }
                      }
                      unsigned int v44 = 36;
                      break;
                    case 4:
                      if (!v23) {
                        goto LABEL_114;
                      }
                      if (*(unsigned char *)v23) {
                        unsigned int v44 = 28;
                      }
                      else {
                        unsigned int v44 = 53;
                      }
                      break;
                    case 5:
                      if (v23)
                      {
                        uint64_t v48 = *re::pipelineLogObjects(v41);
                        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_233120000, v48, OS_LOG_TYPE_DEFAULT, "Mesh attribute type kDouble is not supported for compression.", buf, 2u);
                        }
                      }
LABEL_114:
                      unsigned int v44 = 28;
                      break;
                    case 6:
                      if (v23)
                      {
                        BOOL v49 = *(unsigned __int8 *)v23 >= 3u;
                        unsigned int v44 = 0xA0719u >> (8 * *(unsigned char *)v23);
                        int v50 = 29;
                        goto LABEL_122;
                      }
                      unsigned int v44 = 29;
                      break;
                    case 7:
                      if (!v23) {
                        goto LABEL_119;
                      }
                      BOOL v49 = *(unsigned __int8 *)v23 >= 3u;
                      unsigned int v44 = 0xB081Au >> (8 * *(unsigned char *)v23);
                      int v50 = 30;
                      goto LABEL_122;
                    case 8:
                      if (v23)
                      {
                        BOOL v49 = *(unsigned __int8 *)v23 >= 3u;
                        unsigned int v44 = 0xC091Bu >> (8 * *(unsigned char *)v23);
                        int v50 = 31;
LABEL_122:
                        if (v49) {
                          unsigned int v44 = v50;
                        }
                      }
                      else
                      {
                        unsigned int v44 = 31;
                      }
                      break;
                    case 9:
                      if (v23)
                      {
                        uint64_t v51 = *re::pipelineLogObjects(v41);
                        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_233120000, v51, OS_LOG_TYPE_DEFAULT, "Mesh attribute type kUInt8 is not supported for compression.", buf, 2u);
                        }
                      }
                      unsigned int v44 = 45;
                      break;
                    case 0xA:
                      if (v23)
                      {
                        uint64_t v52 = *re::pipelineLogObjects(v41);
                        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_233120000, v52, OS_LOG_TYPE_DEFAULT, "Mesh attribute type kInt8 is not supported for compression.", buf, 2u);
                        }
                      }
                      unsigned int v44 = 46;
                      break;
                    default:
LABEL_119:
                      unsigned int v44 = 30;
                      break;
                  }
                  *(void *)&v279[32] = 0;
                  memset(v279, 0, 28);
                  LODWORD(v225) = v44;
                  unsigned int v53 = re::sizeFromVertexFormat(v44, v42);
                  unsigned int v54 = v53;
                  LODWORD(v227) = v40;
                  if (v40 == 1) {
                    unsigned __int8 v55 = (v53 + 3) & 0xFC;
                  }
                  else {
                    unsigned __int8 v55 = v53;
                  }
                  re::DynamicArray<BOOL>::resize((uint64_t)v279, a1 * v55);
                  if (v23)
                  {
                    switch(v33[17])
                    {
                      case 0:
                        goto LABEL_145;
                      case 1:
                        goto LABEL_147;
                      case 2:
                        goto LABEL_149;
                      case 3:
                        goto LABEL_151;
                      case 4:
                      case 6:
                      case 7:
                      case 8:
                        float v57 = *(float *)(v23 + 4);
                        int v58 = *(unsigned __int8 *)v23;
                        if (v58 == 2)
                        {
                          long long v56 = (_anonymous_namespace_ *)re::fillStreamSN8((re *)v33, *(const re::GeomAttribute **)&v279[32], (char *)v55, 0, v57);
                        }
                        else if (v58 == 1)
                        {
                          long long v56 = (_anonymous_namespace_ *)re::fillStreamUN8((re *)v33, *(const re::GeomAttribute **)&v279[32], (char *)v55, 0, v57);
                        }
                        else if (!*(unsigned char *)v23)
                        {
                          long long v56 = (_anonymous_namespace_ *)re::fillStreamFP16((re *)v33, *(const re::GeomAttribute **)&v279[32], (char *)v55, 0, v57);
                        }
                        goto LABEL_234;
                      case 5:
                        goto LABEL_153;
                      case 9:
                        goto LABEL_156;
                      case 0xA:
                        goto LABEL_158;
                      default:
                        goto LABEL_234;
                    }
                  }
                  switch(v33[17])
                  {
                    case 0:
LABEL_145:
                      a1 = *(void *)&v279[32];
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33))
                      {
                        uint64_t v23 = re::internal::GeomTypedAttribute<short>::operator[]((uint64_t)v33, 0);
                        uint64_t v59 = (*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        uint64_t v23 = 0;
                      }
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (!v56) {
                        goto LABEL_234;
                      }
                      a8 = 0;
                      size_t v68 = v54;
                      a2 = v55;
                      uint64_t v69 = v56;
                      do
                      {
                        if (v59 == a8) {
                          goto LABEL_582;
                        }
                        long long v56 = (_anonymous_namespace_ *)memcpy((void *)a1, (const void *)v23, v68);
                        ++a8;
                        a1 += a2;
                        v23 += 2;
                      }
                      while (v69 != a8);
                      goto LABEL_234;
                    case 1:
LABEL_147:
                      a1 = *(void *)&v279[32];
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33))
                      {
                        uint64_t v23 = re::internal::GeomTypedAttribute<short>::operator[]((uint64_t)v33, 0);
                        uint64_t v59 = (*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        uint64_t v23 = 0;
                      }
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (!v56) {
                        goto LABEL_234;
                      }
                      a8 = 0;
                      size_t v70 = v54;
                      a2 = v55;
                      uint64_t v71 = v56;
                      do
                      {
                        if (v59 == a8) {
                          goto LABEL_583;
                        }
                        long long v56 = (_anonymous_namespace_ *)memcpy((void *)a1, (const void *)v23, v70);
                        ++a8;
                        a1 += a2;
                        v23 += 2;
                      }
                      while (v71 != a8);
                      goto LABEL_234;
                    case 2:
LABEL_149:
                      a1 = *(void *)&v279[32];
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33))
                      {
                        uint64_t v23 = re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)v33, 0);
                        uint64_t v59 = (*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        uint64_t v23 = 0;
                      }
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (!v56) {
                        goto LABEL_234;
                      }
                      a8 = 0;
                      size_t v72 = v54;
                      a2 = v55;
                      uint64_t v73 = v56;
                      do
                      {
                        if (v59 == a8) {
                          goto LABEL_584;
                        }
                        long long v56 = (_anonymous_namespace_ *)memcpy((void *)a1, (const void *)v23, v72);
                        ++a8;
                        a1 += a2;
                        v23 += 4;
                      }
                      while (v73 != a8);
                      goto LABEL_234;
                    case 3:
LABEL_151:
                      a1 = *(void *)&v279[32];
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33))
                      {
                        uint64_t v23 = re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)v33, 0);
                        uint64_t v59 = (*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        uint64_t v23 = 0;
                      }
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (!v56) {
                        goto LABEL_234;
                      }
                      a8 = 0;
                      size_t v74 = v54;
                      a2 = v55;
                      uint64_t v75 = v56;
                      do
                      {
                        if (v59 == a8) {
                          goto LABEL_585;
                        }
                        long long v56 = (_anonymous_namespace_ *)memcpy((void *)a1, (const void *)v23, v74);
                        ++a8;
                        a1 += a2;
                        v23 += 4;
                      }
                      while (v75 != a8);
                      goto LABEL_234;
                    case 4:
                      long long v60 = *(char **)&v279[32];
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33))
                      {
                        uint64_t v61 = (char *)re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)v33, 0);
                        uint64_t v59 = (*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        uint64_t v61 = 0;
                      }
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (!v56) {
                        goto LABEL_234;
                      }
                      a8 = 0;
                      size_t v83 = v54;
                      uint64_t v84 = v55;
                      uint64_t v85 = v56;
                      do
                      {
                        if (v59 == a8) {
                          goto LABEL_596;
                        }
                        long long v56 = (_anonymous_namespace_ *)memcpy(v60, v61, v83);
                        ++a8;
                        v60 += v84;
                        v61 += 4;
                      }
                      while (v85 != a8);
                      goto LABEL_234;
                    case 5:
LABEL_153:
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (v56)
                      {
                        a2 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)v33, 0);
                        long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                        uint64_t v59 = v56;
                        if (!a1) {
                          goto LABEL_234;
                        }
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        a2 = 0;
                        if (!a1) {
                          goto LABEL_234;
                        }
                      }
                      uint64_t v76 = 0;
                      float32x4_t v77 = *(float **)&v279[32];
                      do
                      {
                        if (v59 == v76) {
                          goto LABEL_586;
                        }
                        float v78 = *(double *)(a2 + 8 * v76);
                        *float32x4_t v77 = v78;
                        ++v76;
                        float32x4_t v77 = (float *)((char *)v77 + v55);
                      }
                      while (a1 != v76);
                      goto LABEL_234;
                    case 6:
                      uint64_t v62 = *(char **)&v279[32];
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33))
                      {
                        uint64_t v63 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)v33, 0);
                        uint64_t v59 = (*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        uint64_t v63 = 0;
                      }
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (!v56) {
                        goto LABEL_234;
                      }
                      a8 = 0;
                      size_t v86 = v54;
                      uint64_t v87 = v55;
                      uint64_t v88 = v56;
                      do
                      {
                        if (v59 == a8) {
                          goto LABEL_597;
                        }
                        long long v56 = (_anonymous_namespace_ *)memcpy(v62, (const void *)(v63 + 8 * a8++), v86);
                        v62 += v87;
                      }
                      while (v88 != a8);
                      goto LABEL_234;
                    case 7:
                      uint64_t v64 = *(char **)&v279[32];
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33))
                      {
                        char v65 = (char *)re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)v33, 0);
                        uint64_t v59 = (*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        char v65 = 0;
                      }
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (!v56) {
                        goto LABEL_234;
                      }
                      a8 = 0;
                      size_t v89 = v54;
                      uint64_t v90 = v55;
                      uint64_t v91 = v56;
                      do
                      {
                        if (v59 == a8) {
                          goto LABEL_598;
                        }
                        long long v56 = (_anonymous_namespace_ *)memcpy(v64, v65, v89);
                        ++a8;
                        v64 += v90;
                        v65 += 16;
                      }
                      while (v91 != a8);
                      goto LABEL_234;
                    case 8:
                      unsigned int v66 = *(char **)&v279[32];
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33))
                      {
                        uint64_t v67 = (char *)re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)v33, 0);
                        uint64_t v59 = (*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        uint64_t v67 = 0;
                      }
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (!v56) {
                        goto LABEL_234;
                      }
                      a8 = 0;
                      size_t v92 = v54;
                      uint64_t v93 = v55;
                      uint64_t v94 = v56;
                      break;
                    case 9:
LABEL_156:
                      a1 = *(void *)&v279[32];
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33))
                      {
                        uint64_t v23 = re::internal::GeomTypedAttribute<signed char>::operator[]((uint64_t)v33, 0);
                        uint64_t v59 = (*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        uint64_t v23 = 0;
                      }
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (!v56) {
                        goto LABEL_234;
                      }
                      a8 = 0;
                      size_t v79 = v54;
                      a2 = v55;
                      uint64_t v80 = v56;
                      do
                      {
                        if (v59 == a8) {
                          goto LABEL_587;
                        }
                        long long v56 = (_anonymous_namespace_ *)memcpy((void *)a1, (const void *)(v23 + a8++), v79);
                        a1 += a2;
                      }
                      while (v80 != a8);
                      goto LABEL_234;
                    case 0xA:
LABEL_158:
                      a1 = *(void *)&v279[32];
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33))
                      {
                        uint64_t v23 = re::internal::GeomTypedAttribute<signed char>::operator[]((uint64_t)v33, 0);
                        uint64_t v59 = (*(unsigned int (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      }
                      else
                      {
                        uint64_t v59 = 0;
                        uint64_t v23 = 0;
                      }
                      long long v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(unsigned char *))(*(void *)v33 + 16))(v33);
                      if (!v56) {
                        goto LABEL_234;
                      }
                      a8 = 0;
                      size_t v81 = v54;
                      a2 = v55;
                      uint64_t v82 = v56;
                      do
                      {
                        if (v59 == a8) {
                          goto LABEL_588;
                        }
                        long long v56 = (_anonymous_namespace_ *)memcpy((void *)a1, (const void *)(v23 + a8++), v81);
                        a1 += a2;
                      }
                      while (v82 != a8);
                      goto LABEL_234;
                    default:
                      goto LABEL_234;
                  }
                  do
                  {
                    if (v59 == a8) {
                      goto LABEL_599;
                    }
                    long long v56 = (_anonymous_namespace_ *)memcpy(v66, v67, v92);
                    ++a8;
                    v66 += v93;
                    v67 += 16;
                  }
                  while (v94 != a8);
LABEL_234:
                  *(void *)&v297[2] = *(void *)v279;
                  *(_OWORD *)((char *)&v297[2] + 8) = *(_OWORD *)&v279[8];
                  *(void *)&long long v298 = *(void *)&v279[32];
                  DWORD2(v297[3]) = 1;
                  BYTE8(v298) = (_BYTE)v225;
                  BYTE9(v298) = v227 == 1;
                  v95.n128_f64[0] = re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)v273, (uint64_t)v297);
                  a2 = (unint64_t)v229;
                  a1 = v230;
                  uint64_t v23 = v228;
                  uint64_t v30 = v231;
                  a8 = (unint64_t)"skinnedAnimationGeometryBindTransform";
                  if (*(void *)&v297[2])
                  {
                    if ((void)v298) {
                      (*(void (**)(double))(**(void **)&v297[2] + 40))(v95.n128_f64[0]);
                    }
                    *(void *)&long long v298 = 0;
                    memset(&v297[2], 0, 24);
                    ++DWORD2(v297[3]);
                  }
                  if (*(void *)&v297[0])
                  {
                    if (BYTE8(v297[0])) {
                      (*(void (**)(__n128))(**(void **)&v297[0] + 40))(v95);
                    }
                    __n128 v95 = 0uLL;
                    memset(v297, 0, 32);
                  }
                  if (*(void *)&v288[0] && (BYTE8(v288[0]) & 1) != 0) {
                    (*(void (**)(__n128))(**(void **)&v288[0] + 40))(v95);
                  }
                }
              }
            }
          }
        }
      }
      ++v32;
    }
    while (v32 != v31);
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v285);
  uint64_t v31 = (uint64_t)v224;
  if (v273 != (unsigned char *)a9)
  {
    uint64_t v97 = *a9;
    if (*a9 && *(void *)v273 && v97 != *(void *)v273) {
      goto LABEL_604;
    }
    *a9 = *(void *)v273;
    *(void *)uint64_t v273 = v97;
    long long v98 = *(_OWORD *)(a9 + 1);
    *(_OWORD *)(a9 + 1) = *(_OWORD *)&v273[8];
    *(_OWORD *)&v273[8] = v98;
    uint64_t v99 = a9[4];
    a9[4] = *(void *)&v273[32];
    *(void *)&v273[32] = v99;
    ++*(_DWORD *)&v273[24];
    ++*((_DWORD *)a9 + 6);
  }
  re::DynamicArray<re::MeshAssetBuffer>::deinit((uint64_t)v273);
  long long v100 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)(a9 + 25), v223);
  if (v252 && v250)
  {
    if ((void)v262) {
      v101.n128_f64[0] = re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)a9, (uint64_t)buf);
    }
    if ((void)v261)
    {
      if ((void)v263) {
        (*(void (**)(__n128))(*(void *)v261 + 40))(v101);
      }
      *(void *)&long long v263 = 0;
      *(void *)&long long v262 = 0;
      long long v261 = 0uLL;
      ++DWORD2(v262);
    }
    long long v100 = *(_anonymous_namespace_ **)buf;
    if (*(void *)buf && (buf[8] & 1) != 0) {
      long long v100 = (_anonymous_namespace_ *)(*(uint64_t (**)(__n128))(**(void **)buf + 40))(v101);
    }
  }
  if (v245 && v243)
  {
    if ((void)v262) {
      v102.n128_f64[0] = re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)a9, (uint64_t)buf);
    }
    if ((void)v261)
    {
      if ((void)v263) {
        (*(void (**)(__n128))(*(void *)v261 + 40))(v102);
      }
      *(void *)&long long v263 = 0;
      *(void *)&long long v262 = 0;
      long long v261 = 0uLL;
      ++DWORD2(v262);
    }
    long long v100 = *(_anonymous_namespace_ **)buf;
    if (*(void *)buf && (buf[8] & 1) != 0) {
      long long v100 = (_anonymous_namespace_ *)(*(uint64_t (**)(__n128))(**(void **)buf + 40))(v102);
    }
  }
  if (v238 && v236)
  {
    if ((void)v262) {
      v103.n128_f64[0] = re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)a9, (uint64_t)buf);
    }
    if ((void)v261)
    {
      if ((void)v263) {
        (*(void (**)(__n128))(*(void *)v261 + 40))(v103);
      }
      *(void *)&long long v263 = 0;
      *(void *)&long long v262 = 0;
      long long v261 = 0uLL;
      ++DWORD2(v262);
    }
    long long v100 = *(_anonymous_namespace_ **)buf;
    if (*(void *)buf && (buf[8] & 1) != 0) {
      long long v100 = (_anonymous_namespace_ *)(*(uint64_t (**)(__n128))(**(void **)buf + 40))(v103);
    }
  }
  uint64_t v104 = *(void *)(v23 + 40);
  unint64_t v105 = (3 * *(_DWORD *)(v23 + 8));
  uint64_t v233 = 0;
  unint64_t v234 = 0;
  unint64_t v235 = 0;
  if ((int)v104 <= 0)
  {
    unint64_t v109 = v234;
    a1 = v235;
    goto LABEL_293;
  }
  unsigned int v106 = 0;
  uint64_t v107 = 0;
  uint64_t v108 = v104;
  unint64_t v109 = v234;
  uint64_t v59 = *(void *)(v23 + 40);
  while (2)
  {
    if (v107 == v59) {
      goto LABEL_565;
    }
    uint64_t v110 = 0;
    uint64_t v111 = v106;
    *(_OWORD *)long long v279 = *(_OWORD *)(*(void *)(v23 + 56) + 16 * v107);
    a1 = v235;
    unint64_t v112 = v235 + 4 * v106;
    do
    {
      a8 = v111 + v110;
      if (v109 <= v111 + v110)
      {
        *(void *)uint64_t v273 = 0;
        long long v263 = 0u;
        long long v262 = 0u;
        long long v261 = 0u;
        long long v260 = 0u;
        *(_OWORD *)long long buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v297[0]) = 136315906;
        *(void *)((char *)v297 + 4) = "operator[]";
        WORD6(v297[0]) = 1024;
        *(_DWORD *)((char *)v297 + 14) = 468;
        WORD1(v297[1]) = 2048;
        *(void *)((char *)&v297[1] + 4) = a8;
        WORD6(v297[1]) = 2048;
        *(void *)((char *)&v297[1] + 14) = v109;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_322;
      }
      *(_DWORD *)(v112 + 4 * v110) = *(_DWORD *)&v279[4 * v110];
      ++v110;
    }
    while (v110 != 3);
    ++v107;
    unsigned int v106 = v111 + 3;
    if (v107 != v108) {
      continue;
    }
    break;
  }
LABEL_293:
  uint64_t v59 = v224 >> 16;
  char v113 = 1;
  if (v59) {
    char v113 = 2;
  }
  *(void *)&long long v261 = 0;
  *(void *)&long long v260 = 0;
  memset(buf, 0, sizeof(buf));
  DWORD2(v260) = 0;
  re::DynamicArray<BOOL>::resize((uint64_t)buf, ((v109 << v113) + 3) & 0xFFFFFFFFFFFFFFFCLL);
  __int16 v115 = (_DWORD *)v261;
  if (v59)
  {
    for (; v109; --v109)
    {
      int v116 = *(_DWORD *)a1;
      a1 += 4;
      *v115++ = v116;
    }
    unint64_t v109 = 36;
  }
  else
  {
    for (; v109; --v109)
    {
      int v117 = *(_DWORD *)a1;
      a1 += 4;
      *(_WORD *)__int16 v115 = v117;
      __int16 v115 = (_DWORD *)((char *)v115 + 2);
    }
    unint64_t v109 = 49;
  }
  uint64_t v227 = &v268[2];
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v268[2], (uint64_t *)buf);
  char v271 = v109;
  char v272 = 0;
  if (*(void *)buf && (void)v261) {
    (*(void (**)(void))(**(void **)buf + 40))();
  }
  unint64_t v118 = (_anonymous_namespace_ *)re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)a9, (re::DynamicString *)v264);
  *((_DWORD *)a9 + 10) = v105;
  *((unsigned char *)a9 + 44) = v59 != 0;
  *((_DWORD *)a9 + 12) = v224;
  *((_DWORD *)a9 + 15) = *(_DWORD *)(a2 + 16);
  *((_WORD *)a9 + 28) = v222;
  a1 = v230;
  if (*(unsigned char *)(v230 + 9))
  {
    a1 = *(unsigned int *)(v23 + 16);
    a2 = v234;
    memset(v297, 0, 32);
    re::DynamicString::setCapacity(v297, 0);
    __int16 v119 = &v297[2];
    *(void *)&long long v298 = 0;
    memset(&v297[2], 0, 28);
    WORD4(v298) = 256;
    *(void *)long long buf = "tension";
    *(void *)&uint8_t buf[8] = 7;
    re::DynamicString::operator=((re::DynamicString *)v297, (uint64_t)buf);
    WORD4(v298) = 284;
    re::DynamicArray<BOOL>::resize((uint64_t)&v297[2], 4 * a1);
    re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)a9, (re::DynamicString *)v297);
    if (re::internal::GeomAttributeManager::attributeByName(v231, "vertexAdjacencies"))
    {
      unint64_t v120 = (_anonymous_namespace_ *)re::internal::GeomAttributeManager::attributeByName(v231, "accumulatedVertexValence");
      if (v120)
      {
        long long v225 = &v297[2];
        memset(v279, 0, 32);
        re::DynamicString::setCapacity(v279, 0);
        unsigned int __dst = 0;
        __uint64_t n = 0;
        *(void *)&v279[32] = 0;
        uint64_t v280 = 0;
        int v282 = 0;
        __int16 v284 = 256;
        *(void *)long long buf = "adjacentFaceArea";
        *(void *)&uint8_t buf[8] = 16;
        re::DynamicString::operator=((re::DynamicString *)v279, (uint64_t)buf);
        __int16 v284 = 284;
        int v224 = &v279[32];
        re::DynamicArray<BOOL>::resize((uint64_t)&v279[32], 4 * a1);
        *(void *)&v273[32] = 0;
        memset(v273, 0, 28);
        unint64_t v121 = *(unsigned int *)(v23 + 8);
        if (v121) {
          re::DynamicArray<int>::setCapacity(v273, v121);
        }
        uint64_t v122 = re::GeomMesh::accessVertexPositions((re::GeomMesh *)v23);
        if (a2)
        {
          uint64_t v124 = v122;
          uint64_t v31 = v123;
          unint64_t v109 = 0;
          while (1)
          {
            uint64_t v23 = v234;
            if (v234 <= v109) {
              break;
            }
            uint64_t v59 = *(unsigned int *)(v235 + 4 * v109);
            if (v59 >= v31) {
              goto LABEL_574;
            }
            a8 = v109 + 1;
            if (v234 <= v109 + 1) {
              goto LABEL_575;
            }
            uint64_t v125 = *(unsigned int *)(v235 + 4 * v109 + 4);
            if (v125 >= v31) {
              goto LABEL_576;
            }
            a8 = v109 + 2;
            if (v234 <= v109 + 2) {
              goto LABEL_577;
            }
            uint64_t v23 = *(unsigned int *)(v235 + 4 * v109 + 8);
            if (v23 >= v31) {
              goto LABEL_578;
            }
            float32x4_t v126 = *(float32x4_t *)(v124 + 16 * v59);
            float32x4_t v127 = vsubq_f32(*(float32x4_t *)(v124 + 16 * v125), v126);
            float32x4_t v128 = vsubq_f32(*(float32x4_t *)(v124 + 16 * v23), v126);
            float32x4_t v129 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v128, (int32x4_t)v128), (int8x16_t)v128, 0xCuLL), vnegq_f32(v127)), v128, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v127, (int32x4_t)v127), (int8x16_t)v127, 0xCuLL));
            float32x4_t v130 = vmulq_f32(v129, v129);
            *(float *)long long buf = sqrtf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v130.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v130, 2), v130)).f32[0])* 0.5;
            re::DynamicArray<float>::add((_anonymous_namespace_ *)v273, (float *)buf);
            v109 += 3;
            if (v109 >= a2) {
              goto LABEL_319;
            }
          }
LABEL_573:
          *(void *)long long v285 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v288[0]) = 136315906;
          *(void *)((char *)v288 + 4) = "operator[]";
          WORD6(v288[0]) = 1024;
          *(_DWORD *)((char *)v288 + 14) = 476;
          WORD1(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 4) = v109;
          WORD6(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 14) = v23;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_574:
          *(void *)long long v285 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v288[0]) = 136315906;
          *(void *)((char *)v288 + 4) = "operator[]";
          WORD6(v288[0]) = 1024;
          *(_DWORD *)((char *)v288 + 14) = 601;
          WORD1(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 4) = v59;
          WORD6(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 14) = v31;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_575:
          *(void *)long long v285 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          uint64_t v125 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v288[0]) = 136315906;
          *(void *)((char *)v288 + 4) = "operator[]";
          WORD6(v288[0]) = 1024;
          *(_DWORD *)((char *)v288 + 14) = 476;
          WORD1(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 4) = a8;
          WORD6(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 14) = v23;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_576:
          *(void *)long long v285 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          uint64_t v124 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v288[0]) = 136315906;
          *(void *)((char *)v288 + 4) = "operator[]";
          WORD6(v288[0]) = 1024;
          *(_DWORD *)((char *)v288 + 14) = 601;
          WORD1(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 4) = v125;
          WORD6(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 14) = v31;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_577:
          *(void *)long long v285 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v288[0]) = 136315906;
          *(void *)((char *)v288 + 4) = "operator[]";
          WORD6(v288[0]) = 1024;
          *(_DWORD *)((char *)v288 + 14) = 476;
          WORD1(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 4) = a8;
          WORD6(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 14) = v23;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_578:
          *(void *)long long v285 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v288[0]) = 136315906;
          *(void *)((char *)v288 + 4) = "operator[]";
          WORD6(v288[0]) = 1024;
          *(_DWORD *)((char *)v288 + 14) = 601;
          WORD1(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 4) = v23;
          WORD6(v288[1]) = 2048;
          *(void *)((char *)&v288[1] + 14) = v31;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_579:
          *(void *)long long v279 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v297[0]) = 136315906;
          *(void *)((char *)v297 + 4) = "operator[]";
          WORD6(v297[0]) = 1024;
          *(_DWORD *)((char *)v297 + 14) = 601;
          WORD1(v297[1]) = 2048;
          *(void *)((char *)&v297[1] + 4) = v59;
          WORD6(v297[1]) = 2048;
          *(void *)((char *)&v297[1] + 14) = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_580:
          *(void *)long long v279 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v297[0]) = 136315906;
          *(void *)((char *)v297 + 4) = "operator[]";
          WORD6(v297[0]) = 1024;
          *(_DWORD *)((char *)v297 + 14) = 468;
          WORD1(v297[1]) = 2048;
          *(void *)((char *)&v297[1] + 4) = v124;
          WORD6(v297[1]) = 2048;
          *(void *)((char *)&v297[1] + 14) = v124;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_581:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v285 = 136315906;
          *(void *)&v285[4] = "operator[]";
          *(_WORD *)&v285[12] = 1024;
          *(_DWORD *)&v285[14] = 601;
          *(_WORD *)&v285[18] = 2048;
          *(void *)&v285[20] = a2;
          __int16 v286 = 2048;
          *(void *)uint64_t v287 = a2;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_582:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_583:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_584:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_585:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_586:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_587:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_588:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_589:
          *(void *)uint64_t v273 = 0;
          long long v298 = 0u;
          memset(v297, 0, sizeof(v297));
          unsigned int v196 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v279 = 136315906;
          *(void *)&v279[4] = "operator[]";
          *(_WORD *)&v279[12] = 1024;
          *(_DWORD *)&v279[14] = 601;
          *(_WORD *)&v279[18] = 2048;
          *(void *)&v279[20] = a8;
          *(_WORD *)&v279[28] = 2048;
          *(void *)&v279[30] = a8;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_590:
          *(void *)uint64_t v273 = 0;
          long long v298 = 0u;
          memset(v297, 0, sizeof(v297));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v279 = 136315906;
          *(void *)&v279[4] = "operator[]";
          *(_WORD *)&v279[12] = 1024;
          *(_DWORD *)&v279[14] = 601;
          *(_WORD *)&v279[18] = 2048;
          *(void *)&v279[20] = v23;
          *(_WORD *)&v279[28] = 2048;
          *(void *)&v279[30] = v196;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_591:
          *(void *)uint64_t v273 = 0;
          long long v298 = 0u;
          memset(v297, 0, sizeof(v297));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v279 = 136315906;
          *(void *)&v279[4] = "operator[]";
          *(_WORD *)&v279[12] = 1024;
          *(_DWORD *)&v279[14] = 789;
          *(_WORD *)&v279[18] = 2048;
          *(void *)&v279[20] = a1;
          *(_WORD *)&v279[28] = 2048;
          *(void *)&v279[30] = v31;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_592:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          unsigned int v196 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v285 = 136315906;
          *(void *)&v285[4] = "operator[]";
          *(_WORD *)&v285[12] = 1024;
          *(_DWORD *)&v285[14] = 601;
          *(_WORD *)&v285[18] = 2048;
          *(void *)&v285[20] = v59;
          __int16 v286 = 2048;
          *(void *)uint64_t v287 = a2;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_593:
          *(void *)uint64_t v273 = 0;
          long long v298 = 0u;
          memset(v297, 0, sizeof(v297));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v279 = 136315906;
          *(void *)&v279[4] = "operator[]";
          *(_WORD *)&v279[12] = 1024;
          *(_DWORD *)&v279[14] = 601;
          *(_WORD *)&v279[18] = 2048;
          *(void *)&v279[20] = v31;
          *(_WORD *)&v279[28] = 2048;
          *(void *)&v279[30] = v196;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_594:
          uint64_t v258 = 0;
          long long v298 = 0u;
          memset(v297, 0, sizeof(v297));
          unsigned int v196 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v290 = 136315906;
          *(void *)&v290[4] = "operator[]";
          __int16 v291 = 1024;
          int v292 = 789;
          __int16 v293 = 2048;
          unint64_t v294 = a2;
          __int16 v295 = 2048;
          uint64_t v296 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_595:
          uint64_t v258 = 0;
          long long v298 = 0u;
          memset(v297, 0, sizeof(v297));
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v290 = 136315906;
          *(void *)&v290[4] = "operator[]";
          __int16 v291 = 1024;
          int v292 = 601;
          __int16 v293 = 2048;
          unint64_t v294 = v59;
          __int16 v295 = 2048;
          uint64_t v296 = v196;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_596:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_597:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_598:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_599:
          *(void *)int v290 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          unsigned int v196 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)long long v264 = 136315906;
          *(void *)&v264[4] = "operator[]";
          __int16 v265 = 1024;
          *(_DWORD *)int v266 = 601;
          *(_WORD *)&v266[4] = 2048;
          *(void *)&v266[6] = v59;
          __int16 v267 = 2048;
          *(void *)long long v268 = v59;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_600:
          uint64_t v258 = 0;
          long long v298 = 0u;
          memset(v297, 0, sizeof(v297));
          LODWORD(v147) = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)int v290 = 136315906;
          *(void *)&v290[4] = "operator[]";
          __int16 v291 = 1024;
          int v292 = 601;
          __int16 v293 = 2048;
          unint64_t v294 = a8;
          __int16 v295 = 2048;
          uint64_t v296 = v196;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_601:
          *(void *)long long v279 = 0;
          long long v263 = 0u;
          long long v262 = 0u;
          long long v261 = 0u;
          long long v260 = 0u;
          *(_OWORD *)long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v297[0]) = 136315906;
          *(void *)((char *)v297 + 4) = "operator[]";
          WORD6(v297[0]) = 1024;
          *(_DWORD *)((char *)v297 + 14) = 601;
          WORD1(v297[1]) = 2048;
          *(void *)((char *)&v297[1] + 4) = 1;
          WORD6(v297[1]) = 2048;
          *(void *)((char *)&v297[1] + 14) = 1;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_602;
        }
LABEL_319:
        uint64_t v131 = re::internal::GeomAttributeManager::attributeByName(v231, "vertexAdjacencies");
        if ((*(unsigned int (**)(uint64_t))(*(void *)v131 + 16))(v131))
        {
          uint64_t v23 = re::internal::GeomTypedAttribute<int>::operator[](v131, 0);
          uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v131 + 16))(v131);
          goto LABEL_323;
        }
LABEL_322:
        uint64_t v31 = 0;
        uint64_t v23 = 0;
LABEL_323:
        uint64_t v132 = re::internal::GeomAttributeManager::attributeByName(v231, "accumulatedVertexValence");
        if ((*(unsigned int (**)(uint64_t))(*(void *)v132 + 16))(v132))
        {
          unint64_t v105 = re::internal::GeomTypedAttribute<int>::operator[](v132, 0);
          a2 = (*(unsigned int (**)(uint64_t))(*(void *)v132 + 16))(v132);
        }
        else
        {
          a2 = 0;
          unint64_t v105 = 0;
        }
        *(void *)&v288[2] = 0;
        memset(v288, 0, 28);
        if (a1)
        {
          re::DynamicArray<int>::setCapacity(v288, a1);
          unint64_t v109 = 0;
          do
          {
            if (v109)
            {
              uint64_t v59 = v109 - 1;
              if (a2 <= v109 - 1) {
                goto LABEL_592;
              }
              unsigned int v133 = *(_DWORD *)(v105 + 4 * v59);
            }
            else
            {
              unsigned int v133 = 0;
            }
            if (v109 == a2) {
              goto LABEL_581;
            }
            signed int v134 = *(_DWORD *)(v105 + 4 * v109);
            float v135 = 0.0;
            int v136 = v134 - v133;
            if (v134 > (int)v133)
            {
              uint64_t v59 = *(void *)&v273[16];
              if (v133 <= v31) {
                uint64_t v137 = v31;
              }
              else {
                uint64_t v137 = v133;
              }
              float v138 = (int *)(v23 + 4 * v133);
              uint64_t v139 = v137 - v133;
              do
              {
                if (!v139)
                {
                  *(void *)int v290 = 0;
                  long long v263 = 0u;
                  long long v262 = 0u;
                  long long v261 = 0u;
                  long long v260 = 0u;
                  *(_OWORD *)long long buf = 0u;
                  unint64_t v105 = &_os_log_internal;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)long long v285 = 136315906;
                  *(void *)&v285[4] = "operator[]";
                  *(_WORD *)&v285[12] = 1024;
                  *(_DWORD *)&v285[14] = 601;
                  *(_WORD *)&v285[18] = 2048;
                  *(void *)&v285[20] = v137;
                  __int16 v286 = 2048;
                  *(void *)uint64_t v287 = v31;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_562:
                  *(void *)int v290 = 0;
                  long long v263 = 0u;
                  long long v262 = 0u;
                  long long v261 = 0u;
                  long long v260 = 0u;
                  *(_OWORD *)long long buf = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)long long v285 = 136315906;
                  *(void *)&v285[4] = "operator[]";
                  *(_WORD *)&v285[12] = 1024;
                  *(_DWORD *)&v285[14] = 789;
                  *(_WORD *)&v285[18] = 2048;
                  *(void *)&v285[20] = a8;
                  __int16 v286 = 2048;
                  *(void *)uint64_t v287 = v59;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_563;
                }
                a8 = *v138;
                if (*(void *)&v273[16] <= a8) {
                  goto LABEL_562;
                }
                float v135 = v135 + *(float *)(*(void *)&v273[32] + 4 * a8);
                ++v138;
                ++v133;
                --v139;
              }
              while (v134 > (int)v133);
            }
            *(float *)long long buf = v135 / (float)v136;
            re::DynamicArray<float>::add((_anonymous_namespace_ *)v288, (float *)buf);
            ++v109;
          }
          while (v109 != a1);
          uint64_t v140 = *(const void **)&v288[2];
        }
        else
        {
          uint64_t v140 = 0;
        }
        memcpy(__dst, v140, __n);
        re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)a9, (re::DynamicString *)v279);
        uint64_t v23 = v228;
        __int16 v119 = v225;
        if (*(void *)&v288[0] && *(void *)&v288[2]) {
          (*(void (**)(void, void))(**(void **)&v288[0] + 40))(*(void *)&v288[0], *(void *)&v288[2]);
        }
        if (*(void *)v273 && *(void *)&v273[32]) {
          (*(void (**)(void, void))(**(void **)v273 + 40))(*(void *)v273, *(void *)&v273[32]);
        }
        if (*(void *)&v279[32])
        {
          if (__dst) {
            (*(void (**)(void, void *))(**(void **)&v279[32] + 40))(*(void *)&v279[32], __dst);
          }
          unsigned int __dst = 0;
          v224[1] = 0;
          v224[2] = 0;
          void *v224 = 0;
          ++v282;
        }
        if (*(void *)v279 && (v279[8] & 1) != 0) {
          (*(void (**)(void, void))(**(void **)v279 + 40))(*(void *)v279, *(void *)&v279[16]);
        }
      }
    }
    a2 = (unint64_t)v229;
    a1 = v230;
    if (*(void *)&v297[2])
    {
      if ((void)v298) {
        (*(void (**)(void, void))(**(void **)&v297[2] + 40))(*(void *)&v297[2], v298);
      }
      *(void *)&long long v298 = 0;
      v119[1] = 0;
      v119[2] = 0;
      void *v119 = 0;
      ++DWORD2(v297[3]);
    }
    if (*(void *)&v297[0] && (BYTE8(v297[0]) & 1) != 0) {
      (*(void (**)(void, void))(**(void **)&v297[0] + 40))(*(void *)&v297[0], *(void *)&v297[1]);
    }
  }
  a8 = a10;
  re::UniqueNameGenerator::uniqueName(v221, *(const char **)a2, "MeshPart", (re::StringID *)v297);
  long long v141 = v297[0];
  uint64_t v59 = (uint64_t)"";
  *(void *)&v297[0] = 0;
  *((void *)&v297[0] + 1) = "";
  uint64_t v142 = a9[9];
  uint64_t v143 = a9[10];
  *(_OWORD *)(a9 + 9) = v141;
  *(void *)&uint8_t buf[8] = v143;
  *(void *)long long buf = v141 & 0xFFFFFFFFFFFFFFFELL | v142 & 1;
  re::StringID::destroyString((re::StringID *)buf);
  re::StringID::destroyString((re::StringID *)v297);
  if (!a10 || !re::meshHasSkinningData((re *)v23, v144)) {
    goto LABEL_404;
  }
  uint64_t v146 = re::internal::GeomAttributeManager::attributeByName(v231, "skeletonPath");
  uint64_t v147 = re::internal::GeomAttributeManager::attributeByName(v231, "skinnedAnimationGeometryBindTransform");
  uint64_t v148 = re::internal::GeomAttributeManager::attributeByName(v231, "skinnedAnimationWeights");
  uint64_t v149 = re::internal::GeomAttributeManager::attributeByName(v231, "skinnedAnimationJointIndices");
  uint64_t v150 = re::internal::GeomAttributeManager::attributeByName(v231, "skinnedAnimationInfluenceEndIndices");
  unint64_t v151 = (_anonymous_namespace_ *)re::internal::GeomTypedAttribute<short>::operator[](v146, 0);
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = "";
  float32x4_t v152 = (int *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v220, buf);
  re::StringID::destroyString((re::StringID *)buf);
  if (v152) {
    int v153 = *v152;
  }
  else {
    int v153 = 0;
  }
  *(_DWORD *)a10 = v153;
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v147 + 16))(v147)) {
    goto LABEL_612;
  }
  long long v154 = (_OWORD *)re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[](v147, 0);
  unsigned int v155 = (*(uint64_t (**)(uint64_t))(*(void *)v147 + 16))(v147);
  if (v155 == 1) {
    goto LABEL_601;
  }
  LODWORD(v147) = v155;
  if (!v155) {
    goto LABEL_612;
  }
  if (v155 <= 2)
  {
LABEL_602:
    *(void *)long long v279 = 0;
    long long v263 = 0u;
    long long v262 = 0u;
    long long v261 = 0u;
    long long v260 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v297[0]) = 136315906;
    *(void *)((char *)v297 + 4) = "operator[]";
    WORD6(v297[0]) = 1024;
    *(_DWORD *)((char *)v297 + 14) = 601;
    WORD1(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 4) = 2;
    WORD6(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 14) = v147;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_603;
  }
  if (v155 == 3)
  {
LABEL_603:
    *(void *)long long v279 = 0;
    long long v263 = 0u;
    long long v262 = 0u;
    long long v261 = 0u;
    long long v260 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v297[0]) = 136315906;
    *(void *)((char *)v297 + 4) = "operator[]";
    WORD6(v297[0]) = 1024;
    *(_DWORD *)((char *)v297 + 14) = 601;
    WORD1(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 4) = 3;
    WORD6(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 14) = 3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_604:
    re::internal::assertLog((re::internal *)4, v96, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
    _os_crash();
    __break(1u);
    goto LABEL_605;
  }
  long long v156 = v154[1];
  long long v157 = v154[2];
  long long v158 = v154[3];
  *(_OWORD *)(a10 + 80) = *v154;
  *(_OWORD *)(a10 + 96) = v156;
  *(_OWORD *)(a10 + 112) = v157;
  *(_OWORD *)(a10 + 128) = v158;
  unsigned int v159 = (*(uint64_t (**)(uint64_t))(*(void *)v148 + 16))(v148);
  (*(void (**)(uint64_t))(*(void *)v149 + 16))(v149);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v148 + 16))(v148))
  {
    uint64_t v160 = re::internal::GeomTypedAttribute<int>::operator[](v148, 0);
    uint64_t v23 = (*(unsigned int (**)(uint64_t))(*(void *)v148 + 16))(v148);
  }
  else
  {
    uint64_t v23 = 0;
    uint64_t v160 = 0;
  }
  unint64_t v161 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)v149 + 16))(v149);
  if (v161)
  {
    a1 = re::internal::GeomTypedAttribute<int>::operator[](v149, 0);
    unint64_t v161 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)v149 + 16))(v149);
    uint64_t v31 = v161;
  }
  else
  {
    uint64_t v31 = 0;
    a1 = 0;
  }
  a2 = a10 + 8;
  unint64_t v109 = v159;
  if (v159)
  {
    uint64_t v162 = 0;
    uint64_t v59 = *(void *)(a10 + 16);
    unint64_t v163 = (_DWORD *)(*(void *)(a10 + 24) + 4);
    while (1)
    {
      if (v23 == v162) {
        goto LABEL_568;
      }
      if (v31 == v162) {
        break;
      }
      if (v59 == v162) {
        goto LABEL_570;
      }
      int v164 = *(_DWORD *)(v160 + 4 * v162);
      *(v163 - 1) = *(_DWORD *)(a1 + 4 * v162);
      _DWORD *v163 = v164;
      v163 += 2;
      if (v109 == ++v162) {
        goto LABEL_386;
      }
    }
LABEL_569:
    *(void *)long long v279 = 0;
    long long v263 = 0u;
    long long v262 = 0u;
    long long v261 = 0u;
    long long v260 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v297[0]) = 136315906;
    *(void *)((char *)v297 + 4) = "operator[]";
    WORD6(v297[0]) = 1024;
    *(_DWORD *)((char *)v297 + 14) = 601;
    WORD1(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 4) = v31;
    WORD6(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 14) = v31;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_570:
    *(void *)long long v279 = 0;
    long long v263 = 0u;
    long long v262 = 0u;
    long long v261 = 0u;
    long long v260 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v297[0]) = 136315906;
    *(void *)((char *)v297 + 4) = "operator[]";
    WORD6(v297[0]) = 1024;
    *(_DWORD *)((char *)v297 + 14) = 468;
    WORD1(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 4) = v59;
    WORD6(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 14) = v59;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_571;
  }
LABEL_386:
  unint64_t v109 = (*(uint64_t (**)(uint64_t))(*(void *)v150 + 16))(v150);
  unsigned int v165 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)v150 + 16))(v150);
  if (v165)
  {
    uint64_t v166 = re::internal::GeomTypedAttribute<int>::operator[](v150, 0);
    unsigned int v165 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)v150 + 16))(v150);
    uint64_t v59 = v165;
  }
  else
  {
    uint64_t v59 = 0;
    uint64_t v166 = 0;
  }
  uint64_t v23 = v228;
  a1 = v109;
  a2 = (unint64_t)v229;
  if (v109)
  {
    uint64_t v167 = 0;
    unint64_t v109 = *(void *)(a10 + 40);
    uint64_t v168 = *(void *)(a10 + 48);
    while (v59 != v167)
    {
      if (v109 == v167) {
        goto LABEL_572;
      }
      *(_DWORD *)(v168 + 4 * v167) = *(_DWORD *)(v166 + 4 * v167);
      if (a1 == ++v167) {
        goto LABEL_394;
      }
    }
LABEL_571:
    *(void *)long long v279 = 0;
    long long v263 = 0u;
    long long v262 = 0u;
    long long v261 = 0u;
    long long v260 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v297[0]) = 136315906;
    *(void *)((char *)v297 + 4) = "operator[]";
    WORD6(v297[0]) = 1024;
    *(_DWORD *)((char *)v297 + 14) = 601;
    WORD1(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 4) = v59;
    WORD6(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 14) = v59;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_572:
    *(void *)long long v279 = 0;
    long long v263 = 0u;
    long long v262 = 0u;
    long long v261 = 0u;
    long long v260 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v297[0]) = 136315906;
    *(void *)((char *)v297 + 4) = "operator[]";
    WORD6(v297[0]) = 1024;
    *(_DWORD *)((char *)v297 + 14) = 468;
    WORD1(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 4) = v109;
    WORD6(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 14) = v109;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_573;
  }
LABEL_394:
  uint64_t v169 = re::internal::GeomAttributeManager::attributeByName(v231, "skinnedAnimationRemappedJointIndices");
  if (v169)
  {
    uint64_t v170 = v169;
    unsigned int v171 = (*(uint64_t (**)(uint64_t))(*(void *)v169 + 16))(v169);
    v172 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)v170 + 16))(v170);
    if (v172)
    {
      uint64_t v173 = re::internal::GeomTypedAttribute<int>::operator[](v170, 0);
      v172 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)v170 + 16))(v170);
      uint64_t v59 = v172;
    }
    else
    {
      uint64_t v59 = 0;
      uint64_t v173 = 0;
    }
    unint64_t v109 = v171;
    a1 = v230;
    if (v171)
    {
      uint64_t v174 = 0;
      uint64_t v124 = *(void *)(a10 + 64);
      uint64_t v175 = *(void *)(a10 + 72);
      while (v59 != v174)
      {
        if (v124 == v174) {
          goto LABEL_580;
        }
        *(_DWORD *)(v175 + 4 * v174) = *(_DWORD *)(v173 + 4 * v174);
        if (v109 == ++v174) {
          goto LABEL_404;
        }
      }
      goto LABEL_579;
    }
  }
  else
  {
    *(void *)(a10 + 64) = 0;
    a1 = v230;
  }
LABEL_404:
  if (!*(unsigned char *)(a1 + 10)) {
    goto LABEL_513;
  }
  re::GeomMesh::GeomMesh((re::GeomMesh *)buf, 0);
  if (*(_DWORD *)(v23 + 40) < 0x65u
    || (float v176 = *(float *)(a1 + 12), v176 >= 1.0)
    || v176 <= 0.0
    || (LODWORD(v297[0]) = *(_DWORD *)(a1 + 12),
        *(_OWORD *)((char *)v297 + 4) = xmmword_23440A910,
        re::internal::simplifyMeshHelper((unsigned int *)v23, (re::GeomMesh *)buf, (uint64_t)v297),
        v260 >= *(_DWORD *)(v23 + 16))
    || DWORD2(v261) >= *(_DWORD *)(v23 + 40))
  {
    uint64_t v177 = re::GeomMesh::copy((re::GeomMesh *)v23, (re::GeomMesh *)buf);
  }
  if (!DWORD2(v261)) {
    goto LABEL_512;
  }
  memset(v279, 0, 32);
  long long v178 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v279, 0);
  unsigned int __dst = 0;
  __uint64_t n = 0;
  *(void *)&v279[32] = 0;
  uint64_t v280 = 0;
  int v282 = 0;
  __int16 v284 = 256;
  re::DynamicString::operator=((re::DynamicString *)v279, (re::DynamicString *)v297);
  if (*(void *)&v297[0] && (BYTE8(v297[0]) & 1) != 0) {
    (*(void (**)(void, void))(**(void **)&v297[0] + 40))(*(void *)&v297[0], *(void *)&v297[1]);
  }
  LOBYTE(v284) = 30;
  re::DynamicArray<BOOL>::resize((uint64_t)&v279[32], 12 * v260);
  HIBYTE(v284) = 0;
  uint64_t v179 = re::GeomMesh::accessVertexPositions((re::GeomMesh *)buf);
  if (v260)
  {
    unint64_t v181 = 0;
    unint64_t v105 = v180;
    do
    {
      if (v181 == v180) {
        goto LABEL_566;
      }
      unint64_t v182 = (char *)__dst + 12 * v181;
      unint64_t v183 = v179 + 16 * v181;
      uint64_t v184 = *(void *)v183;
      *((_DWORD *)v182 + 2) = *(_DWORD *)(v183 + 8);
      *(void *)unint64_t v182 = v184;
      ++v181;
    }
    while (v181 < v260);
  }
  re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)a9, (re::DynamicString *)v279);
  if (*(void *)&v279[32])
  {
    if (__dst) {
      (*(void (**)(void, void *))(**(void **)&v279[32] + 40))(*(void *)&v279[32], __dst);
    }
    unsigned int __dst = 0;
    uint64_t v280 = 0;
    __uint64_t n = 0;
    *(void *)&v279[32] = 0;
    ++v282;
  }
  float32x4_t v185 = *(_anonymous_namespace_ **)v279;
  if (*(void *)v279 && (v279[8] & 1) != 0) {
    float32x4_t v185 = (_anonymous_namespace_ *)(*(uint64_t (**)(void, void))(**(void **)v279 + 40))(*(void *)v279, *(void *)&v279[16]);
  }
  memset(v279, 0, 32);
  long long v186 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v279, 0);
  unsigned int __dst = 0;
  __uint64_t n = 0;
  *(void *)&v279[32] = 0;
  uint64_t v280 = 0;
  int v282 = 0;
  __int16 v284 = 256;
  re::DynamicString::operator=((re::DynamicString *)v279, (re::DynamicString *)v297);
  if (*(void *)&v297[0] && (BYTE8(v297[0]) & 1) != 0) {
    (*(void (**)(void, void))(**(void **)&v297[0] + 40))(*(void *)&v297[0], *(void *)&v297[1]);
  }
  LOBYTE(v284) = 36;
  re::DynamicArray<BOOL>::resize((uint64_t)&v279[32], 12 * DWORD2(v261));
  HIBYTE(v284) = 0;
  unint64_t v105 = *((void *)&v261 + 1);
  if (DWORD2(v261))
  {
    uint64_t v187 = 0;
    uint64_t v188 = 0;
    unint64_t v109 = 0;
    do
    {
      if (v105 <= v109) {
        goto LABEL_567;
      }
      long long v189 = (char *)__dst + v187;
      uint64_t v190 = *(void *)(*((void *)&v262 + 1) + v188);
      *((_DWORD *)v189 + 2) = *(_DWORD *)(*((void *)&v262 + 1) + v188 + 8);
      *(void *)long long v189 = v190;
      ++v109;
      unint64_t v105 = *((void *)&v261 + 1);
      v188 += 16;
      v187 += 12;
    }
    while (v109 < DWORD2(v261));
  }
  re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)a9, (re::DynamicString *)v279);
  if (*(void *)&v279[32])
  {
    uint64_t v191 = (const re::GeomMesh *)__dst;
    if (__dst) {
      (*(void (**)(void, void *))(**(void **)&v279[32] + 40))(*(void *)&v279[32], __dst);
    }
    unsigned int __dst = 0;
    uint64_t v280 = 0;
    __uint64_t n = 0;
    *(void *)&v279[32] = 0;
    ++v282;
  }
  if (*(void *)v279 && (v279[8] & 1) != 0) {
    (*(void (**)(void, void))(**(void **)v279 + 40))(*(void *)v279, *(void *)&v279[16]);
  }
  if (!a10 || !re::meshHasSkinningData((re *)v23, v191)) {
    goto LABEL_512;
  }
  long long v289 = 0;
  memset(v288, 0, 44);
  uint64_t v192 = re::GeomMesh::accessVertexPositions((re::GeomMesh *)v23);
  if (!v193)
  {
LABEL_605:
    *(void *)uint64_t v273 = 0;
    long long v298 = 0u;
    memset(v297, 0, sizeof(v297));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long v279 = 136315906;
    *(void *)&v279[4] = "operator[]";
    *(_WORD *)&v279[12] = 1024;
    *(_DWORD *)&v279[14] = 601;
    *(_WORD *)&v279[18] = 2048;
    *(void *)&v279[20] = 0;
    *(_WORD *)&v279[28] = 2048;
    *(void *)&v279[30] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::internal::GeomKDTree<re::Vector3<float>>::build((uint64_t)v288, *(unsigned int *)(v23 + 16), v192);
  uint64_t v226 = re::internal::GeomAttributeManager::attributeByName(v231, "skinnedAnimationWeights");
  uint64_t v194 = re::internal::GeomAttributeManager::attributeByName(v231, "skinnedAnimationJointIndices");
  uint64_t v195 = re::internal::GeomAttributeManager::attributeByName(v231, "skinnedAnimationInfluenceEndIndices");
  if ((*(unsigned int (**)(uint64_t))(*(void *)v195 + 16))(v195))
  {
    unint64_t v109 = re::internal::GeomTypedAttribute<int>::operator[](v195, 0);
    unsigned int v196 = (*(uint64_t (**)(uint64_t))(*(void *)v195 + 16))(v195);
  }
  else
  {
    unsigned int v196 = 0;
    unint64_t v109 = 0;
  }
  float32x4_t v232 = (re::internal::GeomAttributeManager *)v194;
  *(void *)&v287[2] = 0;
  memset(v285, 0, sizeof(v285));
  re::DynamicArray<float>::resize((uint64_t)v285, v260);
  ClosestHelper = (_anonymous_namespace_ *)re::GeomMesh::accessVertexPositions((re::GeomMesh *)buf);
  if (!v260)
  {
    unint64_t v201 = 0;
    goto LABEL_460;
  }
  uint64_t v199 = (float32x4_t *)ClosestHelper;
  a1 = 0;
  a2 = 0;
  a8 = v198;
  uint64_t v59 = 0xFFFFFFFFLL;
  do
  {
    if (a8 == a1) {
      goto LABEL_589;
    }
    *(_DWORD *)long long v279 = -1;
    if (*(void *)&v288[2])
    {
      *(void *)&v297[0] = 0x7FF0000000000000;
      ClosestHelper = (_anonymous_namespace_ *)re::internal::GeomKDTree<re::Vector3<float>>::findClosestHelper((uint64_t)v288, v289, v199, (double *)v297, v279);
      LODWORD(v23) = *(_DWORD *)v279;
      if (!*(_DWORD *)v279)
      {
        int v200 = 0;
        goto LABEL_455;
      }
    }
    else
    {
      LODWORD(v23) = -1;
    }
    uint64_t v31 = (v23 - 1);
    if (v196 <= v31) {
      goto LABEL_593;
    }
    int v200 = *(_DWORD *)(v109 + 4 * v31);
LABEL_455:
    if (v196 <= v23) {
      goto LABEL_590;
    }
    uint64_t v31 = *(void *)&v285[16];
    if (*(void *)&v285[16] <= a1) {
      goto LABEL_591;
    }
    a2 = (*(_DWORD *)(v109 + 4 * v23) + a2 - v200);
    *(_DWORD *)(*(void *)&v287[2] + 4 * a1++) = v23;
    ++v199;
  }
  while (a1 < v260);
  unint64_t v201 = 8 * a2;
LABEL_460:
  memset(v279, 0, 32);
  long long v202 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v279, 0);
  unsigned int __dst = 0;
  __uint64_t n = 0;
  *(void *)&v279[32] = 0;
  uint64_t v280 = 0;
  int v282 = 0;
  __int16 v284 = 256;
  re::DynamicString::operator=((re::DynamicString *)v279, (re::DynamicString *)v297);
  if (*(void *)&v297[0] && (BYTE8(v297[0]) & 1) != 0) {
    (*(void (**)(void, void))(**(void **)&v297[0] + 40))(*(void *)&v297[0], *(void *)&v297[1]);
  }
  LOBYTE(v284) = 36;
  re::DynamicArray<BOOL>::resize((uint64_t)&v279[32], 4 * v260);
  HIBYTE(v284) = 0;
  memset(v273, 0, 32);
  int v204 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v273, 0);
  uint64_t v277 = 0;
  uint64_t v275 = 0;
  *(void *)&v273[32] = 0;
  uint64_t v274 = 0;
  int v276 = 0;
  __int16 v278 = 256;
  re::DynamicString::operator=((re::DynamicString *)v273, (re::DynamicString *)v297);
  if (*(void *)&v297[0] && (BYTE8(v297[0]) & 1) != 0) {
    (*(void (**)(void, void))(**(void **)&v297[0] + 40))(*(void *)&v297[0], *(void *)&v297[1]);
  }
  LOBYTE(v278) = 45;
  re::DynamicArray<BOOL>::resize((uint64_t)&v273[32], v201);
  HIBYTE(v278) = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)v226 + 16))(v226))
  {
    a1 = re::internal::GeomTypedAttribute<int>::operator[](v226, 0);
    unint64_t v105 = (*(uint64_t (**)(uint64_t))(*(void *)v226 + 16))(v226);
  }
  else
  {
    unint64_t v105 = 0;
    a1 = 0;
  }
  if ((*(unsigned int (**)(re::internal::GeomAttributeManager *))(*(void *)v232 + 16))(v232))
  {
    uint64_t v23 = re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)v232, 0);
    uint64_t v31 = (*(uint64_t (**)(re::internal::GeomAttributeManager *))(*(void *)v232 + 16))(v232);
  }
  else
  {
    uint64_t v31 = 0;
    uint64_t v23 = 0;
  }
  if (v260)
  {
    a2 = 0;
    unsigned int v205 = 0;
    uint64_t v206 = v277;
    while (1)
    {
      uint64_t v59 = *(void *)&v285[16];
      if (*(void *)&v285[16] <= a2) {
        goto LABEL_594;
      }
      uint64_t v59 = *(unsigned int *)(*(void *)&v287[2] + 4 * a2);
      if (v59)
      {
        a8 = (v59 - 1);
        if (v196 <= a8) {
          goto LABEL_600;
        }
        unsigned int v207 = *(_DWORD *)(v109 + 4 * a8);
      }
      else
      {
        unsigned int v207 = 0;
      }
      if (v196 <= v59) {
        goto LABEL_595;
      }
      uint64_t v208 = *(_DWORD *)(v109 + 4 * v59) - v207;
      if (v208) {
        break;
      }
LABEL_491:
      v205 += v208;
      *((_DWORD *)__dst + a2++) = v205;
      if (a2 >= v260) {
        goto LABEL_492;
      }
    }
    a8 = v207;
    LODWORD(v209) = v105 - v207;
    if (v105 >= v207) {
      uint64_t v209 = v209;
    }
    else {
      uint64_t v209 = 0;
    }
    BOOL v49 = v31 >= v207;
    LODWORD(v210) = v31 - v207;
    if (v49) {
      uint64_t v210 = v210;
    }
    else {
      uint64_t v210 = 0;
    }
    unsigned int v211 = v205;
    uint64_t v212 = v208;
    while (v209)
    {
      *(_DWORD *)(v206 + 8 * v211 + 4) = *(_DWORD *)(a1 + 4 * a8);
      if (!v210) {
        goto LABEL_564;
      }
      *(_DWORD *)(v206 + 8 * v211++) = *(_DWORD *)(v23 + 4 * a8);
      --v210;
      --v209;
      ++a8;
      if (!--v212) {
        goto LABEL_491;
      }
    }
LABEL_563:
    uint64_t v258 = 0;
    long long v298 = 0u;
    memset(v297, 0, sizeof(v297));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v290 = 136315906;
    *(void *)&v290[4] = "operator[]";
    __int16 v291 = 1024;
    int v292 = 601;
    __int16 v293 = 2048;
    unint64_t v294 = a8;
    __int16 v295 = 2048;
    uint64_t v296 = v105;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_564:
    uint64_t v258 = 0;
    long long v298 = 0u;
    memset(v297, 0, sizeof(v297));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)int v290 = 136315906;
    *(void *)&v290[4] = "operator[]";
    __int16 v291 = 1024;
    int v292 = 601;
    __int16 v293 = 2048;
    unint64_t v294 = a8;
    __int16 v295 = 2048;
    uint64_t v296 = v31;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_565:
    *(void *)long long v279 = 0;
    long long v263 = 0u;
    long long v262 = 0u;
    long long v261 = 0u;
    long long v260 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v297[0]) = 136315906;
    *(void *)((char *)v297 + 4) = "operator[]";
    WORD6(v297[0]) = 1024;
    *(_DWORD *)((char *)v297 + 14) = 797;
    WORD1(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 4) = v59;
    WORD6(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 14) = v59;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_566:
    *(void *)&v288[0] = 0;
    long long v298 = 0u;
    memset(v297, 0, sizeof(v297));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v273 = 136315906;
    *(void *)&v273[4] = "operator[]";
    *(_WORD *)&v273[12] = 1024;
    *(_DWORD *)&v273[14] = 601;
    *(_WORD *)&v273[18] = 2048;
    *(void *)&v273[20] = v105;
    *(_WORD *)&v273[28] = 2048;
    *(void *)&v273[30] = v105;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_567:
    *(void *)&v288[0] = 0;
    long long v298 = 0u;
    memset(v297, 0, sizeof(v297));
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    *(_DWORD *)uint64_t v273 = 136315906;
    *(void *)&v273[4] = "operator[]";
    *(_WORD *)&v273[12] = 1024;
    *(_DWORD *)&v273[14] = 797;
    *(_WORD *)&v273[18] = 2048;
    *(void *)&v273[20] = v109;
    *(_WORD *)&v273[28] = 2048;
    *(void *)&v273[30] = v105;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_568:
    *(void *)long long v279 = 0;
    long long v263 = 0u;
    long long v262 = 0u;
    long long v261 = 0u;
    long long v260 = 0u;
    *(_OWORD *)long long buf = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    LODWORD(v297[0]) = 136315906;
    *(void *)((char *)v297 + 4) = "operator[]";
    WORD6(v297[0]) = 1024;
    *(_DWORD *)((char *)v297 + 14) = 601;
    WORD1(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 4) = v23;
    WORD6(v297[1]) = 2048;
    *(void *)((char *)&v297[1] + 14) = v23;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_569;
  }
LABEL_492:
  re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)a9, (re::DynamicString *)v273);
  re::DynamicArray<re::MeshAssetBuffer>::add((_anonymous_namespace_ *)a9, (re::DynamicString *)v279);
  a2 = (unint64_t)v229;
  a1 = v230;
  uint64_t v23 = v228;
  if (*(void *)&v273[32])
  {
    if (v277) {
      (*(void (**)(void, uint64_t))(**(void **)&v273[32] + 40))(*(void *)&v273[32], v277);
    }
    uint64_t v277 = 0;
    uint64_t v274 = 0;
    uint64_t v275 = 0;
    *(void *)&v273[32] = 0;
    ++v276;
  }
  if (*(void *)v273 && (v273[8] & 1) != 0) {
    (*(void (**)(void, void))(**(void **)v273 + 40))(*(void *)v273, *(void *)&v273[16]);
  }
  if (*(void *)&v279[32])
  {
    if (__dst) {
      (*(void (**)(void, void *))(**(void **)&v279[32] + 40))(*(void *)&v279[32], __dst);
    }
    unsigned int __dst = 0;
    uint64_t v280 = 0;
    __uint64_t n = 0;
    *(void *)&v279[32] = 0;
    ++v282;
  }
  if (*(void *)v279 && (v279[8] & 1) != 0) {
    (*(void (**)(void, void))(**(void **)v279 + 40))(*(void *)v279, *(void *)&v279[16]);
  }
  if (*(void *)v285 && *(void *)&v287[2]) {
    (*(void (**)(void, void))(**(void **)v285 + 40))(*(void *)v285, *(void *)&v287[2]);
  }
  if (*(void *)&v288[1] && v289) {
    (*(void (**)(void, uint64_t *))(**(void **)&v288[1] + 40))(*(void *)&v288[1], v289);
  }
LABEL_512:
  re::GeomMesh::~GeomMesh((re::GeomMesh *)buf);
LABEL_513:
  if (*(unsigned char *)(a1 + 6)) {
    re::internal::makeOpenSubdivAssetBuffersAndAppendToAssetPart((re::internal *)a2, (const re::GeomMesh *)a9, v145);
  }
  re::computeAABB((re *)v23, buf);
  long long v213 = v260;
  *((_OWORD *)a9 + 6) = *(_OWORD *)buf;
  *((_OWORD *)a9 + 7) = v213;
  re::computeOrientedBoundingBox((re *)v23, buf);
  long long v215 = v260;
  *((_OWORD *)a9 + 8) = *(_OWORD *)buf;
  *((_OWORD *)a9 + 9) = v215;
  long long v216 = v262;
  *((_OWORD *)a9 + 10) = v261;
  *((_OWORD *)a9 + 11) = v216;
  if (*(void *)&v268[2])
  {
    uint64_t v214 = v270;
    if (v270) {
      (*(void (**)(void, uint64_t))(**(void **)&v268[2] + 40))(*(void *)&v268[2], v270);
    }
    uint64_t v270 = 0;
    v227[1] = 0;
    v227[2] = 0;
    void *v227 = 0;
    ++v269;
  }
  if (*(void *)v264 && (v264[8] & 1) != 0) {
    (*(void (**)(void, void))(**(void **)v264 + 40))(*(void *)v264, *(void *)&v266[2]);
  }
  if (v233 && v234) {
    (*(void (**)(uint64_t, unint64_t))(*(void *)v233 + 40))(v233, v235);
  }
  if (v238)
  {
    if (v238 != 2)
    {
      if (v238 == 1)
      {
        uint64_t v217 = v239;
        if (!v239) {
          goto LABEL_536;
        }
        uint64_t v214 = v241;
        if (!v241) {
          goto LABEL_536;
        }
LABEL_535:
        (*(void (**)(uint64_t))(*(void *)v217 + 40))(v217);
        goto LABEL_536;
      }
LABEL_609:
      re::internal::assertLog((re::internal *)4, v214, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
      _os_crash();
      __break(1u);
LABEL_610:
      re::internal::assertLog((re::internal *)4, v214, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
      _os_crash();
      __break(1u);
LABEL_611:
      re::internal::assertLog((re::internal *)4, v214, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
      _os_crash();
      __break(1u);
LABEL_612:
      *(void *)long long v279 = 0;
      long long v263 = 0u;
      long long v262 = 0u;
      long long v261 = 0u;
      long long v260 = 0u;
      *(_OWORD *)long long buf = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      LODWORD(v297[0]) = 136315906;
      *(void *)((char *)v297 + 4) = "operator[]";
      WORD6(v297[0]) = 1024;
      *(_DWORD *)((char *)v297 + 14) = 601;
      WORD1(v297[1]) = 2048;
      *(void *)((char *)&v297[1] + 4) = 0;
      WORD6(v297[1]) = 2048;
      *(void *)((char *)&v297[1] + 14) = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_613:
      re::internal::assertLog((re::internal *)4, v24, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
      _os_crash();
      __break(1u);
LABEL_614:
      re::internal::assertLog((re::internal *)4, v26, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
      _os_crash();
      __break(1u);
LABEL_615:
      re::internal::assertLog((re::internal *)4, v26, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D28C0CLL);
    }
    uint64_t v217 = v242;
    if (v242)
    {
      if (v240) {
        uint64_t v240 = 0;
      }
      uint64_t v214 = v239;
      if (v239) {
        goto LABEL_535;
      }
    }
  }
LABEL_536:
  if (v245)
  {
    if (v245 == 2)
    {
      if (v249)
      {
        if (v247) {
          uint64_t v247 = 0;
        }
        uint64_t v214 = v246;
        if (v246)
        {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v249 + 40))(v249, v246);
          int v218 = &v246;
          goto LABEL_547;
        }
      }
    }
    else
    {
      if (v245 != 1) {
        goto LABEL_610;
      }
      if (v246)
      {
        int v218 = v248;
        uint64_t v214 = v248[0];
        if (v248[0])
        {
          (*(void (**)(uint64_t, void))(*(void *)v246 + 40))(v246, v248[0]);
          int v218 = v248;
        }
LABEL_547:
        uint64_t *v218 = 0;
      }
    }
  }
  if (v252)
  {
    if (v252 == 2)
    {
      if (v256)
      {
        if (v254) {
          uint64_t v254 = 0;
        }
        if (v253)
        {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v256 + 40))(v256, v253);
          uint64_t v219 = &v253;
          goto LABEL_559;
        }
      }
    }
    else
    {
      if (v252 != 1) {
        goto LABEL_611;
      }
      if (v253)
      {
        uint64_t v219 = v255;
        if (v255[0])
        {
          (*(void (**)(uint64_t, void))(*(void *)v253 + 40))(v253, v255[0]);
          uint64_t v219 = v255;
        }
LABEL_559:
        uint64_t *v219 = 0;
      }
    }
  }
  re::GeomMesh::~GeomMesh((re::GeomMesh *)v257);
}

uint64_t re::DynamicArray<re::MeshAssetBuffer>::add(_anonymous_namespace_ *this, re::DynamicString *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::MeshAssetBuffer>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  unsigned int v5 = (re::DynamicString *)(*((void *)this + 4) + 80 * v4);
  re::DynamicString::DynamicString(v5, a2);
  uint64_t result = re::DynamicArray<BOOL>::DynamicArray((uint64_t)v5 + 32, (uint64_t *)a2 + 4);
  *((_WORD *)v5 + 36) = *((_WORD *)a2 + 36);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::anonymous namespace'::anonymous namespace'::makePartToModelIndexMappingHelper(uint64_t a1, uint64_t a2, char a3, unsigned int *a4)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  re::DynamicString::setCapacity((void *)a1, 0);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 72) = 256;
  v11[0] = *(const char **)(a2 + 8);
  v11[1] = (const char *)strlen(v11[0]);
  re::DynamicString::operator=((re::DynamicString *)a1, (uint64_t)v11);
  re::DynamicArray<BOOL>::resize(a1 + 32, 4 * *a4);
  *(unsigned char *)(a1 + 73) = a3;
  *(unsigned char *)(a1 + 72) = 36;
  uint64_t v8 = *a4;
  if (v8)
  {
    uint64_t v9 = 0;
    uint64_t v10 = *(void *)(a1 + 64);
    do
    {
      *(_DWORD *)(v10 + 4 * v9) = re::GeomIndexMap::operator[]((uint64_t)a4, v9);
      ++v9;
    }
    while (v8 != v9);
  }
}

uint64_t re::internal::GeomKDTree<re::Vector3<float>>::findClosestHelper(uint64_t result, uint64_t *a2, float32x4_t *a3, double *a4, _DWORD *a5)
{
  if (a2)
  {
    uint64_t v8 = a2;
    uint64_t v9 = (uint64_t *)result;
    do
    {
      uint64_t v10 = *v9;
      uint64_t v11 = *((unsigned int *)v8 + 4);
      float32x4_t v12 = *(float32x4_t *)(*v9 + 16 * v11);
      uint32x4_t v13 = (uint32x4_t)vceqq_f32(v12, *a3);
      v13.i32[3] = v13.i32[2];
      unsigned int v14 = vminvq_u32(v13);
      double v15 = 0.0;
      if ((v14 & 0x80000000) == 0)
      {
        float32x4_t v16 = vsubq_f32(v12, *a3);
        float32x4_t v17 = vmulq_f32(v16, v16);
        double v15 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0];
      }
      if (v15 < *a4)
      {
        *a4 = v15;
        *a5 = v11;
        uint64_t v11 = *((unsigned int *)v8 + 4);
      }
      uint64_t v18 = v10 + 16 * v11;
      uint64_t v19 = *((unsigned __int8 *)v8 + 20);
      float v20 = a3->f32[v19];
      float v21 = *(float *)(v18 + 4 * v19);
      if (v20 == v21) {
        double v22 = 0.0;
      }
      else {
        double v22 = (float)(v20 - v21);
      }
      if (v22 >= 0.0)
      {
        uint64_t result = re::internal::GeomKDTree<re::Vector3<float>>::findClosestHelper(v9, v8[1], a3, a4, a5);
        if (*a4 <= v22 * v22) {
          return result;
        }
      }
      else
      {
        uint64_t result = re::internal::GeomKDTree<re::Vector3<float>>::findClosestHelper(v9, *v8, a3, a4, a5);
        if (*a4 <= v22 * v22) {
          return result;
        }
        ++v8;
      }
      uint64_t v8 = (uint64_t *)*v8;
    }
    while (v8);
  }
  return result;
}

uint64_t re::anonymous namespace'::loadMeshPartFromAssetPart(_anonymous_namespace_ *a1, id *a2, uint64_t a3, long long *a4, uint64_t a5)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  unint64_t v8 = *(void *)(a3 + 16);
  uint64_t v38 = 0;
  v35[1] = 0;
  unint64_t v36 = 0;
  v35[0] = 0;
  int v37 = 0;
  memset(v34, 0, sizeof(v34));
  unint64_t v9 = v8 + *(unsigned int *)(a3 + 228);
  if (v9) {
    re::DynamicArray<re::NamedVertexBuffer>::setCapacity(v35, v9);
  }
  if (v8)
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    unint64_t v12 = (unint64_t)&selRef_taskToken;
    while (1)
    {
      uint32x4_t v13 = *(void **)(a3 + 16);
      if ((unint64_t)v13 <= v11)
      {
        uint64_t v39 = 0;
        long long v51 = 0u;
        long long v52 = 0u;
        long long v49 = 0u;
        long long v50 = 0u;
        long long v48 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v40 = 136315906;
        long long v41 = "operator[]";
        __int16 v42 = 1024;
        int v43 = 797;
        __int16 v44 = 2048;
        unint64_t v45 = v11;
        __int16 v46 = 2048;
        id v47 = v13;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_45:
        uint64_t v39 = 0;
        long long v51 = 0u;
        long long v52 = 0u;
        long long v49 = 0u;
        long long v50 = 0u;
        long long v48 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v40 = 136315906;
        long long v41 = "operator[]";
        __int16 v42 = 1024;
        int v43 = 797;
        __int16 v44 = 2048;
        unint64_t v45 = 0;
        __int16 v46 = 2048;
        id v47 = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_46:
        uint64_t v39 = 0;
        long long v51 = 0u;
        long long v52 = 0u;
        long long v49 = 0u;
        long long v50 = 0u;
        long long v48 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        int v40 = 136315906;
        long long v41 = "operator[]";
        __int16 v42 = 1024;
        int v43 = 789;
        __int16 v44 = 2048;
        unint64_t v45 = v12;
        __int16 v46 = 2048;
        id v47 = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      uint64_t v14 = *(void *)(a3 + 32) + v10;
      size_t v15 = *(void *)(v14 + 48);
      id v5 = objc_msgSend(*a2, sel_newBufferWithLength_options_, v15, 0);
      id v16 = objc_msgSend(v5, sel_contents);
      if (!*(void *)(v14 + 48)) {
        goto LABEL_45;
      }
      memcpy(v16, *(const void **)(v14 + 64), v15);
      re::DynamicString::DynamicString((re::DynamicString *)&v48, (const re::DynamicString *)v14);
      LOWORD(v50) = *(_WORD *)(v14 + 72);
      *((void *)&v50 + 1) = v5;
      LODWORD(v51) = 0;
      DWORD1(v51) = objc_msgSend(v5, sel_length);
      *((void *)&v51 + 1) = 0xFFFFFFFF00000000;
      re::DynamicArray<re::NamedVertexBuffer>::add((_anonymous_namespace_ *)v35, (uint64_t)&v48);
      if (*((void *)&v50 + 1))
      {

        *((void *)&v50 + 1) = 0;
      }
      if (void)v48 && (BYTE8(v48)) {
        (*(void (**)(void))(*(void *)v48 + 40))();
      }
      *(void *)&long long v48 = v11;
      if (re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::find((uint64_t *)v34, v14) == -1)break; {
      if (v5)
      }
        goto LABEL_14;
LABEL_15:
      ++v11;
      v10 += 80;
      if (v8 == v11) {
        goto LABEL_19;
      }
    }
    re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::internalAdd((_anonymous_namespace_ *)v34, (const re::DynamicString *)v14, (uint64_t *)&v48);
    if (!v5) {
      goto LABEL_15;
    }
LABEL_14:

    goto LABEL_15;
  }
LABEL_19:
  uint64_t v17 = *(unsigned int *)(a3 + 232);
  if (v17)
  {
    uint64_t v18 = 0;
    uint64_t v19 = (int *)(*(void *)(a3 + 216) + 8);
    while (1)
    {
      int v20 = *v19;
      v19 += 20;
      if (v20 < 0) {
        break;
      }
      if (v17 == ++v18)
      {
        LODWORD(v18) = *(_DWORD *)(a3 + 232);
        break;
      }
    }
  }
  else
  {
    LODWORD(v18) = 0;
  }
  if (v17 != v18)
  {
    uint64_t v21 = v18;
    uint64_t v22 = *(void *)(a3 + 216);
    do
    {
      uint64_t v23 = v22 + 80 * v21;
      uint64_t v24 = re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::find((uint64_t *)v34, v23 + 48);
      if (v24 != -1)
      {
        unint64_t v12 = *(void *)(*((void *)&v34[0] + 1) + 40 * v24 + 32);
        if (v12 < v8)
        {
          id v5 = v36;
          if ((unint64_t)v36 <= v12) {
            goto LABEL_46;
          }
          uint64_t v25 = v38;
          re::DynamicString::DynamicString((re::DynamicString *)&v48, (const re::DynamicString *)(v23 + 16));
          uint64_t v26 = v25 + (v12 << 6);
          LOWORD(v50) = *(_WORD *)(v26 + 32);
          *((void *)&v50 + 1) = *(id *)(v26 + 40);
          *(void *)&long long v51 = *(void *)(v26 + 48);
          *((void *)&v51 + 1) = 0xFFFFFFFF00000000;
          re::DynamicArray<re::NamedVertexBuffer>::add((_anonymous_namespace_ *)v35, (uint64_t)&v48);
          if (*((void *)&v50 + 1))
          {

            *((void *)&v50 + 1) = 0;
          }
          if (void)v48 && (BYTE8(v48)) {
            (*(void (**)(void))(*(void *)v48 + 40))();
          }
        }
      }
      uint64_t v22 = *(void *)(a3 + 216);
      if (*(_DWORD *)(a3 + 232) <= (v18 + 1)) {
        int v27 = v18 + 1;
      }
      else {
        int v27 = *(_DWORD *)(a3 + 232);
      }
      while (1)
      {
        uint64_t v21 = (v18 + 1);
        if (v27 - 1 == v18) {
          break;
        }
        LODWORD(v18) = v18 + 1;
        int v28 = v21;
        if ((*(_DWORD *)(v22 + 80 * v21 + 8) & 0x80000000) != 0) {
          goto LABEL_42;
        }
      }
      int v28 = v27;
LABEL_42:
      LODWORD(v18) = v28;
    }
    while (v17 != v28);
  }
  re::StringID::StringID((re::StringID *)v33, (const StringID *)(a3 + 72));
  re::MeshPart::MeshPart((uint64_t)a1, v33, *(_WORD *)(a3 + 56), v38, (unint64_t)v36, *(_DWORD *)(a3 + 40), *(_DWORD *)(a3 + 48), *(_DWORD *)(a3 + 52), (_OWORD *)(a3 + 96), a5, a4, (re::MeshPartFlags *)(a3 + 192), *(_DWORD *)(a3 + 60), *(_DWORD *)(a3 + 64));
  re::StringID::destroyString((re::StringID *)v33);
  re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::deinit((uint64_t)v34);
  return re::DynamicArray<re::NamedVertexBuffer>::deinit((uint64_t)v35);
}

void *re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::init(void *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = result;
  result[7] = a2;
  unint64_t v4 = 151 * a3;
  unint64_t v5 = ((unint64_t)(151 * a3) >> 7) + 15;
  unint64_t v6 = v5 & 0x3FFFFFFFFFFFFF0;
  result[2] = v5 & 0x3FFFFFFFFFFFFF0;
  if ((v5 & 0x3FFFFFFFFFFFFF0) != 0)
  {
    unint64_t v7 = v5 >> 4;
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 32))(a2, 41 * v6, 16);
    *unint64_t v3 = result;
    if (v4 >= 0x80)
    {
      uint64_t v8 = 0;
      *(void *)&long long v9 = -1;
      *((void *)&v9 + 1) = -1;
      do
        *(_OWORD *)(*v3 + 16 * v8++) = v9;
      while (v7 != v8);
      uint64_t result = (void *)*v3;
    }
    v3[1] = &result[2 * v7];
    unint64_t v6 = v3[2];
    if (v6)
    {
      uint64_t v10 = 0;
      for (unint64_t i = 0; i < v6; ++i)
      {
        uint64_t v12 = v3[1] + v10;
        *(_OWORD *)uint64_t v12 = 0u;
        *(_OWORD *)(v12 + 16) = 0u;
        uint64_t result = re::DynamicString::setCapacity((void *)v12, 0);
        *(void *)(v12 + 32) = 0;
        unint64_t v6 = v3[2];
        v10 += 40;
      }
    }
  }
  else
  {
    *uint64_t result = 0;
    result[1] = 0;
  }
  v3[5] = 0;
  v3[6] = 0;
  v3[3] = 0;
  v3[4] = v6;
  return result;
}

uint64_t re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::find(uint64_t *a1, uint64_t a2)
{
  if (!a1[7] || (unint64_t)a1[2] < 0x10 || !a1[3]) {
    return -1;
  }
  unint64_t v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v15, a2) % ((unint64_t)a1[2] >> 4);
  while (1)
  {
    uint64_t v5 = *a1;
    char v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v16, a2);
    int8x16_t v14 = *(int8x16_t *)(v5 + 16 * v4);
    unint64_t v7 = (unint64_t)vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(vdupq_n_s8(v6 & 0x7F), v14), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
    unint64_t v8 = __clz(__rbit64(v7));
    if (v8 <= 0x3F) {
      break;
    }
LABEL_10:
    v12.i64[0] = -1;
    v12.i64[1] = -1;
    if (vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(v14, v12), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800))
    {
      return -1;
    }
    if (++v4 == (unint64_t)a1[2] >> 4) {
      unint64_t v4 = 0;
    }
    uint64_t v11 = -1;
    if (v4 == re::Hash<re::DynamicString>::operator()((uint64_t)&v17, a2) % ((unint64_t)a1[2] >> 4)) {
      return v11;
    }
  }
  uint64_t v9 = 16 * v4;
  uint64_t v10 = a1[1];
  while (1)
  {
    uint64_t v11 = v8 + v9;
    if (re::DynamicString::operator==(a2, v10 + 40 * (v8 + v9))) {
      return v11;
    }
    if (v8 <= 0x3E)
    {
      unint64_t v8 = __clz(__rbit64((-2 << v8) & v7));
      if (v8 < 0x40) {
        continue;
      }
    }
    goto LABEL_10;
  }
}

unint64_t re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::internalAdd(_anonymous_namespace_ *a1, const re::DynamicString *a2, uint64_t *a3)
{
  if (!*((void *)a1 + 7))
  {
  }
  uint64_t v6 = *((void *)a1 + 4);
  if (!v6 || *((void *)a1 + 2) > (unint64_t)(8 * v6)) {
    re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::resize((long long *)a1);
  }
  unint64_t v7 = re::Hash<re::DynamicString>::operator()((uint64_t)&v17, (uint64_t)a2) % (*((void *)a1 + 2) >> 4);
  while (1)
  {
    uint64_t v8 = *(void *)a1;
    char v9 = re::Hash<re::DynamicString>::operator()((uint64_t)&v17, (uint64_t)a2);
    unint64_t v10 = __clz(__rbit64(*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v8 + 16 * v7)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800)));
    if (v10 < 0x40) {
      break;
    }
    if (v7 + 1 == *((void *)a1 + 2) >> 4) {
      unint64_t v7 = 0;
    }
    else {
      ++v7;
    }
  }
  uint64_t v11 = v8 + 16 * v7;
  int v12 = *(unsigned __int8 *)(v11 + v10);
  *(unsigned char *)(v11 + v10) = v9 & 0x7F;
  unint64_t v13 = v10 + 16 * v7;
  re::DynamicString::DynamicString((re::DynamicString *)&v17, a2);
  uint64_t v19 = *a3;
  int8x16_t v14 = re::DynamicString::operator=((re::DynamicString *)(*((void *)a1 + 1) + 40 * v13), (re::DynamicString *)&v17);
  *((void *)v14 + 4) = v19;
  if (v17 && (v18 & 1) != 0) {
    (*(void (**)(void))(*(void *)v17 + 40))();
  }
  uint64_t v15 = *((void *)a1 + 4);
  ++*((void *)a1 + 3);
  *((void *)a1 + 4) = v15 - (v12 == 255);
  unint64_t result = re::Hash<re::DynamicString>::operator()((uint64_t)&v17, *((void *)a1 + 1) + 40 * v13);
  *((void *)a1 + 5) ^= result;
  return result;
}

void re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::resize(long long *a1)
{
  unint64_t v3 = *((void *)a1 + 2);
  uint64_t v2 = *((void *)a1 + 3);
  unint64_t v4 = (((unint64_t)(151 * (v2 + 1)) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  unint64_t v5 = ((3 * v3) >> 1) & 0x1FFFFFFFFFFFFFFLL;
  if (v4 > (192 * v3) >> 7) {
    unint64_t v5 = (((unint64_t)(151 * (v2 + 1)) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  }
  unint64_t v6 = (v5 << 7) / 0x97;
  uint64_t v7 = *((void *)a1 + 7);
  long long v26 = 0u;
  *(_OWORD *)int v27 = 0u;
  if (v4 <= v3) {
    uint64_t v8 = v2 + 1;
  }
  else {
    uint64_t v8 = v6;
  }
  memset(&v27[16], 0, 32);
  re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::init(&v26, v7, v8);
  unint64_t v9 = *((void *)a1 + 2);
  if (v9 >= 0x10)
  {
    uint64_t v10 = 0;
    unint64_t v11 = v9 >> 4;
    while (1)
    {
      unsigned __int16 v12 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(*(void *)a1 + v10)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800).u16[0];
      unint64_t v13 = (unsigned __int16)~v12;
      if (v12 != 0xFFFF) {
        break;
      }
      v10 += 16;
      if (!--v11) {
        goto LABEL_12;
      }
    }
    unint64_t v14 = __clz(__rbit64(v13)) + v10;
    while (v14 != -1)
    {
      re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::internalAdd(&v26, *((void *)a1 + 1) + 40 * v14, *((void *)a1 + 1) + 40 * v14 + 32);
      unint64_t v21 = v14 >> 4;
      unint64_t v9 = *((void *)a1 + 2);
      if (v14 >> 4 >= v9 >> 4) {
        break;
      }
      unint64_t v22 = __clz(__rbit64((-2 << (v14 & 0xF)) & v13));
      if (v22 >= 0x40)
      {
        uint64_t v23 = 16 * v21;
        unint64_t v24 = ~v21 + (v9 >> 4);
        while (v24)
        {
          unint64_t v13 = (unsigned __int16)~*(void *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(*(void *)a1 + v23 + 16)), (int8x16_t)xmmword_2343680E0)))), (int8x8_t)0x3830282018100800);
          unint64_t v25 = __clz(__rbit64(v13));
          v23 += 16;
          --v24;
          if (v25 <= 0x3F)
          {
            unint64_t v14 = v25 + v23;
            goto LABEL_20;
          }
        }
        break;
      }
      unint64_t v14 = v22 + (v14 & 0xFFFFFFFFFFFFFFF0);
LABEL_20:
      ;
    }
  }
LABEL_12:
  uint64_t v15 = *(void *)&v27[40];
  *(void *)&unsigned char v27[40] = *((void *)a1 + 7);
  long long v16 = v26;
  long long v17 = *(_OWORD *)v27;
  long long v26 = *a1;
  *(void *)int v27 = v9;
  long long v18 = *(_OWORD *)&v27[16];
  long long v19 = *(long long *)((char *)a1 + 40);
  *((void *)a1 + 6) = *(void *)&v27[32];
  *((void *)a1 + 7) = v15;
  *(_OWORD *)&v27[24] = v19;
  long long v20 = *(long long *)((char *)a1 + 24);
  *a1 = v16;
  a1[1] = v17;
  a1[2] = v18;
  *(_OWORD *)&unsigned char v27[8] = v20;
  re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::deinit((uint64_t)&v26);
}

double re::HashBrown<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,void,false>::deinit(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v2 = *(re::DynamicString **)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 16);
      if (v3)
      {
        uint64_t v4 = 40 * v3;
        do
        {
          re::DynamicString::deinit(v2);
          uint64_t v2 = (re::DynamicString *)((char *)v2 + 40);
          v4 -= 40;
        }
        while (v4);
      }
      *(void *)(a1 + 8) = 0;
    }
    if (*(void *)a1)
    {
      (*(void (**)(void))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56));
      *(void *)a1 = 0;
    }
    double result = 0.0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

uint64_t re::types::Ok<re::GeomScene>::Ok(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = re::DynamicArray<re::GeomModelWithLods>::DynamicArray(a1, a2);
  re::DynamicArray<re::GeomInstance>::DynamicArray(v4 + 40, a2 + 5);
  re::DynamicArray<re::GeomSkeleton>::DynamicArray(a1 + 80, a2 + 10);
  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable(a1 + 120, (uint64_t)(a2 + 15));
  return a1;
}

uint64_t re::Result<re::GeomScene,re::Error>::Result(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 1;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)(a1 + 8) = *(void *)a2;
  *(void *)(a1 + 16) = v3;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v4 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v4;
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v5;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(a1 + 32);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  uint64_t v6 = *(void *)(a2 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 40);
  *(void *)(a1 + 56) = v6;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  uint64_t v7 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v7;
  uint64_t v8 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v8;
  ++*(_DWORD *)(a2 + 64);
  ++*(_DWORD *)(a1 + 72);
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  uint64_t v9 = *(void *)(a2 + 88);
  *(void *)(a1 + 88) = *(void *)(a2 + 80);
  *(void *)(a1 + 96) = v9;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  uint64_t v10 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = v10;
  uint64_t v11 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = *(void *)(a2 + 112);
  *(void *)(a2 + 112) = v11;
  ++*(_DWORD *)(a2 + 104);
  ++*(_DWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 144) = 0u;
  *(_DWORD *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 164) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 128), (uint64_t *)(a2 + 120));
  return a1;
}

void re::gatherMaterialConstants(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v9 = a2;
  id v10 = a3;
  uint64_t v11 = [MEMORY[0x263F83F10] USDPreviewSurfaceDefaults];
  unsigned __int16 v12 = [v11 objectForKeyedSubscript:@"opacityThreshold"];
  [v12 floatValue];
  HIDWORD(v140) = v13;

  unint64_t v14 = [v11 objectForKeyedSubscript:@"emissiveColor"];
  [v14 float3Value];
  *(_OWORD *)uint64_t v143 = v15;

  long long v16 = [v11 objectForKeyedSubscript:@"metallic"];
  [v16 floatValue];
  HIDWORD(v142) = v17;

  long long v18 = [v11 objectForKeyedSubscript:@"roughness"];
  [v18 floatValue];
  LODWORD(v142) = v19;

  long long v20 = [v11 objectForKeyedSubscript:@"clearcoat"];
  [v20 floatValue];
  HIDWORD(v141) = v21;

  unint64_t v22 = [v11 objectForKeyedSubscript:@"clearcoatRoughness"];
  [v22 floatValue];
  LODWORD(v141) = v23;

  unint64_t v24 = [v11 objectForKeyedSubscript:@"textureFallback"];
  [v24 float4Value];
  __n128 v118 = v25;

  long long v26 = [v11 objectForKeyedSubscript:@"ior"];
  [v26 floatValue];
  LODWORD(v140) = v27;

  uint64_t v30 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v138, "[%f, %f, %f, %f, srgb]", BaseColorTintAndOpacity.n128_f32[0], BaseColorTintAndOpacity.n128_f32[1], BaseColorTintAndOpacity.n128_f32[2], BaseColorTintAndOpacity.n128_f32[3]);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v137, (const re::DynamicString *)&v138);
  if (*(void *)v137.__x_ && (v137.__x_[2] & 1) != 0) {
    (*(void (**)(void))(**(void **)v137.__x_ + 40))();
  }
  __int16 v115 = v9;
  uint64_t v31 = [v9 path];
  unsigned int v32 = [v31 stringValue];
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v33 = [v32 hash];
  v137.__x_[0] = v33;
  for (uint64_t i = 1; i != 624; ++i)
  {
    std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v33 = i + 1812433253 * (v33 ^ (v33 >> 30));
    v137.__x_[i] = v33;
  }
  v137.__i_ = 0;

  double v36 = (float)((float)((float)std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v137)
                      * 2.3283e-10)
              + 0.0);
  double v37 = (float)((float)((float)std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v137)
                      * 2.3283e-10)
              + 0.0);
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v38 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v137);
  uint64_t v39 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v135, "[%f, %f, %f, srgb]", v36, v37, (float)((float)((float)v38 * 2.3283e-10) + 0.0));
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v133, (const re::DynamicString *)&v135);
  int v40 = v133;
  if (v133 && (v134 & 1) != 0) {
    int v40 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v133 + 40))();
  }
  BOOL v42 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a4, (uint64_t)&v131);
  int v43 = v131;
  if (v131 && (v132 & 1) != 0) {
    int v43 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v131 + 40))();
  }
  if (v42)
  {
    unint64_t v44 = re::Hash<re::DynamicString>::operator()((uint64_t)&v129, (uint64_t)&v131);
    uint64_t v45 = 0x7FFFFFFFLL;
    if (*(void *)a4)
    {
      uint64_t v46 = *(unsigned int *)(*(void *)(a4 + 8) + 4 * (v44 % *(unsigned int *)(a4 + 24)));
      if (v46 != 0x7FFFFFFF)
      {
        uint64_t v47 = *(void *)(a4 + 16);
        uint64_t v45 = 0x7FFFFFFFLL;
        while (1)
        {
          unint64_t v44 = re::DynamicString::operator==(v47 + 56 * v46 + 16, (uint64_t)&v131);
          if (v44) {
            break;
          }
          uint64_t v46 = *(_DWORD *)(v47 + 56 * v46 + 8) & 0x7FFFFFFF;
          if (v46 == 0x7FFFFFFF) {
            goto LABEL_26;
          }
        }
        uint64_t v45 = v46;
      }
    }
LABEL_26:
    long long v51 = *(void **)(*(void *)(a4 + 16) + 56 * v45 + 48);
    BOOL v52 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a5, (uint64_t)&v129);
    __n128 TextureScaleFloat3 = re::getTextureScaleFloat3(v51, v52, v118);
    if (v129 && (v130 & 1) != 0)
    {
      __n128 v116 = TextureScaleFloat3;
      (*(void (**)(void))(*(void *)v129 + 40))();
      __n128 TextureScaleFloat3 = v116;
    }
    if (v131 && (v132 & 1) != 0)
    {
      __n128 v117 = TextureScaleFloat3;
      (*(void (**)(void))(*(void *)v131 + 40))();
      __n128 TextureScaleFloat3 = v117;
    }
    long long v50 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v133, "[%f, %f, %f, 1.0]", TextureScaleFloat3.n128_f32[0], TextureScaleFloat3.n128_f32[1], TextureScaleFloat3.n128_f32[2]);
  }
  else
  {
    re::getConstantFloat3(v10, @"inputs:emissiveColor", v143);
    long long v49 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v131, "[%f, %f, %f, srgb]", v143[0], v143[1], v143[2]);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v129, (const re::DynamicString *)&v131);
    if (v129 && (v130 & 1) != 0) {
      (*(void (**)(void))(*(void *)v129 + 40))();
    }
    re::DynamicString::appendf((re::DynamicString *)&v133, "[1,1,1,1]");
    long long v50 = v131;
    if (v131 && (v132 & 1) != 0) {
      long long v50 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v131 + 40))();
    }
  }
  unint64_t v54 = re::Hash<re::DynamicString>::operator()((uint64_t)&v129, (uint64_t)&v131);
  unint64_t v55 = v54;
  if (!*(void *)a1)
  {
    LODWORD(v56) = 0;
    goto LABEL_40;
  }
  unint64_t v56 = v54 % *(unsigned int *)(a1 + 24);
  uint64_t v57 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v56);
  if (v57 == 0x7FFFFFFF)
  {
LABEL_40:
    uint64_t v59 = *(unsigned int *)(a1 + 36);
    if (v59 == 0x7FFFFFFF)
    {
      uint64_t v59 = *(unsigned int *)(a1 + 32);
      int v60 = v59;
      if (v59 == *(_DWORD *)(a1 + 24))
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
        LODWORD(v56) = v55 % *(unsigned int *)(a1 + 24);
        int v60 = *(_DWORD *)(a1 + 32);
      }
      *(_DWORD *)(a1 + 32) = v60 + 1;
      uint64_t v61 = *(void *)(a1 + 16);
      int v62 = *(_DWORD *)(v61 + 80 * v59 + 8);
    }
    else
    {
      uint64_t v61 = *(void *)(a1 + 16);
      int v62 = *(_DWORD *)(v61 + 80 * v59 + 8);
      *(_DWORD *)(a1 + 36) = v62 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v61 + 80 * v59 + 8) = v62 | 0x80000000;
    *(_DWORD *)(*(void *)(a1 + 16) + 80 * v59 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 80 * v59 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * v56);
    *(void *)(*(void *)(a1 + 16) + 80 * v59) = v55;
    uint64_t v63 = re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 80 * v59 + 16), (const re::DynamicString *)&v131);
    uint64_t v64 = (re::DynamicString *)(*(void *)(a1 + 16) + 80 * v59 + 48);
    *(_DWORD *)(*(void *)(a1 + 8) + 4 * v56) = v59;
    ++*(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 40);
    goto LABEL_46;
  }
  uint64_t v58 = *(void *)(a1 + 16);
  while (!re::DynamicString::operator==(v58 + 80 * v57 + 16, (uint64_t)&v131))
  {
    uint64_t v57 = *(_DWORD *)(v58 + 80 * v57 + 8) & 0x7FFFFFFF;
    if (v57 == 0x7FFFFFFF) {
      goto LABEL_40;
    }
  }
LABEL_46:
  char v65 = v131;
  if (v131 && (v132 & 1) != 0) {
    char v65 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v131 + 40))();
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v131, (const re::DynamicString *)&v133);
  unsigned int v66 = v131;
  if (v131 && (v132 & 1) != 0) {
    unsigned int v66 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v131 + 40))();
  }
  char v69 = v68;
  size_t v70 = v131;
  if (v131 && (v132 & 1) != 0) {
    size_t v70 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v131 + 40))();
  }
  if (v67)
  {
    LODWORD(v72) = re::getTextureScaleFloat(v67, v69 != 0, v118).n128_u32[0];
  }
  else
  {
    re::getConstantFloat((re *)v10, (NSDictionary *)@"inputs:metallic", (NSString *)((char *)&v142 + 4), v71);
    float v72 = *((float *)&v142 + 1);
  }
  uint64_t v73 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v131, "%f", v72);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v129, (const re::DynamicString *)&v131);
  size_t v74 = v129;
  if (v129 && (v130 & 1) != 0) {
    size_t v74 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v129 + 40))();
  }
  char v77 = v76;
  float v78 = v129;
  if (v129 && (v130 & 1) != 0) {
    float v78 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v129 + 40))();
  }
  if (v75)
  {
    LODWORD(v80) = re::getTextureScaleFloat(v75, v77 != 0, v118).n128_u32[0];
  }
  else
  {
    re::getConstantFloat((re *)v10, (NSDictionary *)@"inputs:roughness", &v142, v79);
    float v80 = *(float *)&v142;
  }
  size_t v81 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v129, "%f", v80);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v127, (const re::DynamicString *)&v129);
  uint64_t v82 = v127;
  if (v127 && (v128 & 1) != 0) {
    uint64_t v82 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v127 + 40))();
  }
  BOOL v85 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a4, (uint64_t)&v125);
  size_t v86 = v125;
  if (v125 && (v126 & 1) != 0) {
    size_t v86 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v125 + 40))();
  }
  if (v85)
  {
    unint64_t v87 = re::Hash<re::DynamicString>::operator()((uint64_t)&v123, (uint64_t)&v125);
    uint64_t v88 = 0x7FFFFFFFLL;
    if (*(void *)a4)
    {
      uint64_t v89 = *(unsigned int *)(*(void *)(a4 + 8) + 4 * (v87 % *(unsigned int *)(a4 + 24)));
      if (v89 != 0x7FFFFFFF)
      {
        uint64_t v90 = *(void *)(a4 + 16);
        uint64_t v88 = 0x7FFFFFFFLL;
        while (1)
        {
          unint64_t v87 = re::DynamicString::operator==(v90 + 56 * v89 + 16, (uint64_t)&v125);
          if (v87) {
            break;
          }
          uint64_t v89 = *(_DWORD *)(v90 + 56 * v89 + 8) & 0x7FFFFFFF;
          if (v89 == 0x7FFFFFFF) {
            goto LABEL_82;
          }
        }
        uint64_t v88 = v89;
      }
    }
LABEL_82:
    size_t v92 = *(void **)(*(void *)(a4 + 16) + 56 * v88 + 48);
    BOOL v93 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a5, (uint64_t)&v123);
    LODWORD(v91) = re::getTextureScaleFloat(v92, v93, v118).n128_u32[0];
    if (v123 && (v124 & 1) != 0) {
      (*(void (**)(void))(*(void *)v123 + 40))();
    }
    if (v125 && (v126 & 1) != 0) {
      (*(void (**)(void))(*(void *)v125 + 40))();
    }
  }
  else
  {
    re::getConstantFloat((re *)v10, (NSDictionary *)@"inputs:clearcoat", (NSString *)((char *)&v141 + 4), v84);
    float v91 = *((float *)&v141 + 1);
  }
  uint64_t v94 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v127, "%f", v91);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v125, (const re::DynamicString *)&v127);
  __n128 v95 = v125;
  if (v125 && (v126 & 1) != 0) {
    __n128 v95 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v125 + 40))();
  }
  BOOL v98 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a4, (uint64_t)&v123);
  uint64_t v99 = v123;
  if (v123 && (v124 & 1) != 0) {
    uint64_t v99 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v123 + 40))();
  }
  if (v98)
  {
    unint64_t v100 = re::Hash<re::DynamicString>::operator()((uint64_t)&v121, (uint64_t)&v123);
    uint64_t v101 = 0x7FFFFFFFLL;
    if (*(void *)a4)
    {
      uint64_t v102 = *(unsigned int *)(*(void *)(a4 + 8) + 4 * (v100 % *(unsigned int *)(a4 + 24)));
      if (v102 != 0x7FFFFFFF)
      {
        uint64_t v103 = *(void *)(a4 + 16);
        uint64_t v101 = 0x7FFFFFFFLL;
        while (1)
        {
          unint64_t v100 = re::DynamicString::operator==(v103 + 56 * v102 + 16, (uint64_t)&v123);
          if (v100) {
            break;
          }
          uint64_t v102 = *(_DWORD *)(v103 + 56 * v102 + 8) & 0x7FFFFFFF;
          if (v102 == 0x7FFFFFFF) {
            goto LABEL_103;
          }
        }
        uint64_t v101 = v102;
      }
    }
LABEL_103:
    unint64_t v105 = *(void **)(*(void *)(a4 + 16) + 56 * v101 + 48);
    BOOL v106 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a5, (uint64_t)&v121);
    LODWORD(v104) = re::getTextureScaleFloat(v105, v106, v118).n128_u32[0];
    if (v121 && (v122 & 1) != 0) {
      (*(void (**)(void))(*(void *)v121 + 40))();
    }
    if (v123 && (v124 & 1) != 0) {
      (*(void (**)(void))(*(void *)v123 + 40))();
    }
  }
  else
  {
    re::getConstantFloat((re *)v10, (NSDictionary *)@"inputs:clearcoatRoughness", &v141, v97);
    float v104 = *(float *)&v141;
  }
  uint64_t v107 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v125, "%f", v104);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v123, (const re::DynamicString *)&v125);
  if (v123 && (v124 & 1) != 0) {
    (*(void (**)(void))(*(void *)v123 + 40))();
  }
  ConstantFloat = (_anonymous_namespace_ *)re::getConstantFloat((re *)v10, (NSDictionary *)@"inputs:opacityThreshold", (NSString *)((char *)&v140 + 4), v108);
  uint64_t v110 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v123, "%f", *((float *)&v140 + 1));
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v121, (const re::DynamicString *)&v123);
  if (v121 && (v122 & 1) != 0) {
    (*(void (**)(void))(*(void *)v121 + 40))();
  }
  unint64_t v112 = (_anonymous_namespace_ *)re::getConstantFloat((re *)v10, (NSDictionary *)@"inputs:ior", &v140, v111);
  if ((float)((float)((float)((float)(1.0 - *(float *)&v140) / (float)(*(float *)&v140 + 1.0))
                     * (float)((float)(1.0 - *(float *)&v140) / (float)(*(float *)&v140 + 1.0)))
             / 0.08) <= 1.0)
    float v113 = (float)((float)((float)(1.0 - *(float *)&v140) / (float)(*(float *)&v140 + 1.0))
                 * (float)((float)(1.0 - *(float *)&v140) / (float)(*(float *)&v140 + 1.0)))
         / 0.08;
  else {
    float v113 = 1.0;
  }
  int v114 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)&v121, "%f", v113);
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1, (re::DynamicString *)&v119, (const re::DynamicString *)&v121);
  if (v119 && (v120 & 1) != 0) {
    (*(void (**)(void))(*(void *)v119 + 40))();
  }
  if (v121 && (v122 & 1) != 0) {
    (*(void (**)(void))(*(void *)v121 + 40))();
  }
  if (v123 && (v124 & 1) != 0) {
    (*(void (**)(void))(*(void *)v123 + 40))();
  }
  if (v125 && (v126 & 1) != 0) {
    (*(void (**)(void))(*(void *)v125 + 40))();
  }
  if (v127 && (v128 & 1) != 0) {
    (*(void (**)(void))(*(void *)v127 + 40))();
  }
  if (v129 && (v130 & 1) != 0) {
    (*(void (**)(void))(*(void *)v129 + 40))();
  }

  if (v131 && (v132 & 1) != 0) {
    (*(void (**)(void))(*(void *)v131 + 40))();
  }

  if (v133 && (v134 & 1) != 0) {
    (*(void (**)(void))(*(void *)v133 + 40))();
  }
  if (v135 && (v136 & 1) != 0) {
    (*(void (**)(void))(*(void *)v135 + 40))();
  }
  if (v138 && (v139 & 1) != 0) {
    (*(void (**)(void))(*(void *)v138 + 40))();
  }
}

__n128 re::anonymous namespace'::getBaseColorTintAndOpacity(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)&v92[4] = _Q0;
  uint64_t v11 = [MEMORY[0x263F83F10] USDPreviewSurfaceDefaults];
  unsigned __int16 v12 = [v11 objectForKeyedSubscript:@"diffuseColor"];
  [v12 float3Value];
  float32x4_t v93 = v13;

  unint64_t v14 = [v11 objectForKeyedSubscript:@"opacity"];
  [v14 floatValue];
  *(_DWORD *)size_t v92 = v15;

  long long v16 = [v11 objectForKeyedSubscript:@"textureFallback"];
  [v16 float4Value];
  __n128 v75 = v17;

  re::getConstantFloat3(v5, @"inputs:diffuseColor", &v93);
  re::getConstantFloat((re *)v5, (NSDictionary *)@"inputs:opacity", (NSString *)v92, v18);
  re::getConstantFloat3(v5, @"inputs:realitykit:tint", &v92[4]);
  float32x4_t v74 = *(float32x4_t *)&v92[4];
  float32x4_t v80 = vmulq_f32(*(float32x4_t *)&v92[4], v93);
  float32x4_t v93 = v80;
  BOOL v20 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a2, (uint64_t)&v89);
  if (v20)
  {
    int v23 = v89;
    if (v89 && (v90 & 1) != 0) {
      int v23 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, uint64_t, uint64_t, uint64_t))(*(void *)v89 + 40))(v89, v91, v21, v22);
    }
  }
  else
  {
    BOOL v26 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a2, (uint64_t)&v86);
    if (v86 && (v87 & 1) != 0) {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v86 + 40))(v86, v88, v24, v25);
    }
    int v23 = v89;
    if (v89 && (v90 & 1) != 0) {
      int v23 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, uint64_t, uint64_t, uint64_t))(*(void *)v89 + 40))(v89, v91, v24, v25);
    }
    if (!v26)
    {
      float32x4_t v53 = v80;
LABEL_90:
      v53.i32[3] = *(_DWORD *)v92;
LABEL_91:
      float32x4_t v83 = v53;
      goto LABEL_92;
    }
  }
  BOOL v27 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a2, (uint64_t)&v89);
  if (v27)
  {
    uint64_t v30 = v89;
    if (v89 && (v90 & 1) != 0) {
      uint64_t v30 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, uint64_t, uint64_t, uint64_t))(*(void *)v89 + 40))(v89, v91, v28, v29);
    }
    goto LABEL_29;
  }
  BOOL v33 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a2, (uint64_t)&v86);
  if (v86 && (v87 & 1) != 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v86 + 40))(v86, v88, v31, v32);
  }
  uint64_t v30 = v89;
  if (v89 && (v90 & 1) != 0) {
    uint64_t v30 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, uint64_t, uint64_t, uint64_t))(*(void *)v89 + 40))(v89, v91, v31, v32);
  }
  if (!v33)
  {
LABEL_29:
    BOOL v38 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a2, (uint64_t)&v89);
    if (v38)
    {
      BOOL v43 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a2, (uint64_t)&v86);
      if (v86 && (v87 & 1) != 0) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v86 + 40))(v86, v88, v41, v42);
      }
      unint64_t v44 = v89;
      if (v89 && (v90 & 1) != 0) {
        unint64_t v44 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, uint64_t, uint64_t, uint64_t))(*(void *)v89 + 40))(v89, v91, v41, v42);
      }
      if (!v43)
      {
        unint64_t v45 = re::Hash<re::DynamicString>::operator()((uint64_t)&v86, (uint64_t)&v89);
        uint64_t v46 = 0x7FFFFFFFLL;
        if (*(void *)a2)
        {
          uint64_t v47 = *(unsigned int *)(*(void *)(a2 + 8) + 4 * (v45 % *(unsigned int *)(a2 + 24)));
          if (v47 != 0x7FFFFFFF)
          {
            uint64_t v48 = *(void *)(a2 + 16);
            uint64_t v46 = 0x7FFFFFFFLL;
            while (1)
            {
              unint64_t v45 = re::DynamicString::operator==(v48 + 56 * v47 + 16, (uint64_t)&v89);
              if (v45) {
                break;
              }
              uint64_t v47 = *(_DWORD *)(v48 + 56 * v47 + 8) & 0x7FFFFFFF;
              if (v47 == 0x7FFFFFFF) {
                goto LABEL_83;
              }
            }
            uint64_t v46 = v47;
          }
        }
LABEL_83:
        char v69 = *(void **)(*(void *)(a2 + 16) + 56 * v46 + 48);
        BOOL v70 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a3, (uint64_t)&v86);
        float32x4_t TextureScaleFloat3 = (float32x4_t)re::getTextureScaleFloat3(v69, v70, v75);
        float32x4_t v72 = TextureScaleFloat3;
        if (v86 && (v87 & 1) != 0)
        {
          __n128 v84 = (__n128)TextureScaleFloat3;
          (*(void (**)(uint64_t, uint64_t))(*(void *)v86 + 40))(v86, v88);
          float32x4_t v72 = (float32x4_t)v84;
        }
        if (v89 && (v90 & 1) != 0)
        {
          float32x4_t v85 = v72;
          (*(void (**)(_anonymous_namespace_ *, uint64_t))(*(void *)v89 + 40))(v89, v91);
          float32x4_t v72 = v85;
        }
        float32x4_t v53 = vmulq_f32(v72, v74);
        goto LABEL_90;
      }
    }
    else
    {
      unint64_t v44 = v89;
      if (v89 && (v90 & 1) != 0) {
        unint64_t v44 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, uint64_t, uint64_t, uint64_t))(*(void *)v89 + 40))(v89, v91, v39, v40);
      }
    }
    unint64_t v49 = re::Hash<re::DynamicString>::operator()((uint64_t)&v86, (uint64_t)&v89);
    uint64_t v50 = 0x7FFFFFFFLL;
    if (*(void *)a2)
    {
      uint64_t v51 = *(unsigned int *)(*(void *)(a2 + 8) + 4 * (v49 % *(unsigned int *)(a2 + 24)));
      if (v51 != 0x7FFFFFFF)
      {
        uint64_t v52 = *(void *)(a2 + 16);
        uint64_t v50 = 0x7FFFFFFFLL;
        while (1)
        {
          unint64_t v49 = re::DynamicString::operator==(v52 + 56 * v51 + 16, (uint64_t)&v89);
          if (v49) {
            break;
          }
          uint64_t v51 = *(_DWORD *)(v52 + 56 * v51 + 8) & 0x7FFFFFFF;
          if (v51 == 0x7FFFFFFF) {
            goto LABEL_54;
          }
        }
        uint64_t v50 = v51;
      }
    }
LABEL_54:
    unint64_t v54 = *(void **)(*(void *)(a2 + 16) + 56 * v50 + 48);
    BOOL v55 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a3, (uint64_t)&v86);
    __n128 v81 = re::getTextureScaleFloat3(v54, v55, v75);
    if (v86 && (v87 & 1) != 0) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v86 + 40))(v86, v88);
    }
    unint64_t v56 = v89;
    if (v89 && (v90 & 1) != 0) {
      unint64_t v56 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, uint64_t))(*(void *)v89 + 40))(v89, v91);
    }
    unint64_t v57 = re::Hash<re::DynamicString>::operator()((uint64_t)&v86, (uint64_t)&v89);
    if (*(void *)a2)
    {
      unint64_t v58 = v57 % *(unsigned int *)(a2 + 24);
      uint64_t v59 = *(void *)(a2 + 8);
      uint64_t v60 = *(void *)(a2 + 16);
      uint64_t v61 = *(unsigned int *)(v59 + 4 * v58);
      if (v61 != 0x7FFFFFFF)
      {
        do
        {
          unint64_t v57 = re::DynamicString::operator==(v60 + 56 * v61 + 16, (uint64_t)&v89);
          if (v57) {
            goto LABEL_67;
          }
          uint64_t v61 = *(_DWORD *)(v60 + 56 * v61 + 8) & 0x7FFFFFFF;
        }
        while (v61 != 0x7FFFFFFF);
      }
    }
    else
    {
      uint64_t v60 = *(void *)(a2 + 16);
    }
    uint64_t v61 = 0x7FFFFFFFLL;
LABEL_67:
    int v62 = *(void **)(v60 + 56 * v61 + 48);
    BOOL v63 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a3, (uint64_t)&v86);
    unsigned __int32 v64 = re::getTextureScaleFloat(v62, v63, v75).n128_u32[0];
    if (v86 && (v87 & 1) != 0)
    {
      unsigned __int32 v76 = v64;
      (*(void (**)(uint64_t, uint64_t))(*(void *)v86 + 40))(v86, v88);
      unsigned __int32 v64 = v76;
    }
    float32x4_t v53 = vmulq_f32((float32x4_t)v81, v74);
    if (v89 && (v90 & 1) != 0)
    {
      unsigned __int32 v77 = v64;
      float32x4_t v82 = v53;
      (*(void (**)(void))(*(void *)v89 + 40))();
      unsigned __int32 v64 = v77;
      float32x4_t v53 = v82;
    }
    v53.i32[3] = v64;
    goto LABEL_91;
  }
  unint64_t v34 = re::Hash<re::DynamicString>::operator()((uint64_t)&v86, (uint64_t)&v89);
  uint64_t v35 = 0x7FFFFFFFLL;
  if (*(void *)a2)
  {
    uint64_t v36 = *(unsigned int *)(*(void *)(a2 + 8) + 4 * (v34 % *(unsigned int *)(a2 + 24)));
    if (v36 != 0x7FFFFFFF)
    {
      uint64_t v37 = *(void *)(a2 + 16);
      uint64_t v35 = 0x7FFFFFFFLL;
      while (1)
      {
        unint64_t v34 = re::DynamicString::operator==(v37 + 56 * v36 + 16, (uint64_t)&v89);
        if (v34) {
          break;
        }
        uint64_t v36 = *(_DWORD *)(v37 + 56 * v36 + 8) & 0x7FFFFFFF;
        if (v36 == 0x7FFFFFFF) {
          goto LABEL_75;
        }
      }
      uint64_t v35 = v36;
    }
  }
LABEL_75:
  char v65 = *(void **)(*(void *)(a2 + 16) + 56 * v35 + 48);
  BOOL v66 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a3, (uint64_t)&v86);
  unsigned __int32 v67 = re::getTextureScaleFloat(v65, v66, v75).n128_u32[0];
  if (v86 && (v87 & 1) != 0)
  {
    unsigned __int32 v78 = v67;
    (*(void (**)(uint64_t, uint64_t))(*(void *)v86 + 40))(v86, v88);
    unsigned __int32 v67 = v78;
  }
  if (v89 && (v90 & 1) != 0)
  {
    unsigned __int32 v79 = v67;
    (*(void (**)(_anonymous_namespace_ *, uint64_t))(*(void *)v89 + 40))(v89, v91);
    unsigned __int32 v67 = v79;
  }
  float32x4_t v68 = v80;
  v68.i32[3] = v67;
  float32x4_t v83 = v68;
LABEL_92:

  return (__n128)v83;
}

void re::getConstantFloat3(void *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v4 = [a1 objectForKey:a2];
  if (v4)
  {
    id v8 = v4;
    id v5 = [v4 type];
    uint64_t v6 = (void *)*MEMORY[0x263F83F50];

    uint64_t v4 = v8;
    if (v5 == v6)
    {
      [v8 float3Value];
      uint64_t v4 = v8;
      *a3 = v7;
    }
  }
}

__n128 re::getTextureScaleFloat3(void *a1, int a2, __n128 a3)
{
  id v4 = a1;
  __asm { FMOV            V0.4S, #1.0 }
  __n128 PropertyValueWithOutputProperty = re::getPropertyValueWithOutputProperty(v4, @"inputs:scale", _Q0);
  uint64_t v11 = re::getDataComponentWithPropertyOutput((uint64_t)&v24, PropertyValueWithOutputProperty);
  if ((void)v24)
  {
    if (BYTE8(v24)) {
      (*(void (**)(void, void))(*(void *)v24 + 40))(v24, v25);
    }
    long long v24 = 0u;
    long long v25 = 0u;
  }
  if (a2)
  {
    objc_msgSend(v11, "float3Value", *(_OWORD *)&a3);
    float32x4_t v20 = v12;
  }
  else
  {
    __n128 v21 = re::getPropertyValueWithOutputProperty(v4, @"inputs:fallback", a3);
    unint64_t v14 = re::getDataComponentWithPropertyOutput((uint64_t)v23, v21);
    if (*(void *)&v23[0])
    {
      if (BYTE8(v23[0])) {
        (*(void (**)(void))(**(void **)&v23[0] + 40))();
      }
      memset(v23, 0, sizeof(v23));
    }
    objc_msgSend(v11, "float3Value", *(_OWORD *)&a3);
    float32x4_t v22 = v15;
    [v14 float3Value];
    float32x4_t v20 = vmulq_f32(v22, v16);
  }
  return (__n128)v20;
}

_anonymous_namespace_ *re::anonymous namespace'::resolveTextureConnection(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  BOOL v8 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a1, a3);
  if (v8)
  {
    unint64_t v9 = re::Hash<re::DynamicString>::operator()((uint64_t)&v16, a3);
    uint64_t v10 = 0x7FFFFFFFLL;
    if (*(void *)a1)
    {
      uint64_t v11 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * (v9 % *(unsigned int *)(a1 + 24)));
      if (v11 != 0x7FFFFFFF)
      {
        uint64_t v12 = *(void *)(a1 + 16);
        uint64_t v10 = 0x7FFFFFFFLL;
        while (!re::DynamicString::operator==(v12 + 56 * v11 + 16, a3))
        {
          uint64_t v11 = *(_DWORD *)(v12 + 56 * v11 + 8) & 0x7FFFFFFF;
          if (v11 == 0x7FFFFFFF) {
            goto LABEL_18;
          }
        }
        uint64_t v10 = v11;
      }
    }
LABEL_18:
    unint64_t v14 = (_anonymous_namespace_ *)*(id *)(*(void *)(a1 + 16) + 56 * v10 + 48);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a2, a3);
  }
  else
  {
    if (!v7) {
      goto LABEL_16;
    }
    BOOL v13 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a1, (uint64_t)&v16);
    if (v16 && (v17 & 1) != 0) {
      (*(void (**)(void))(*(void *)v16 + 40))();
    }
    if (v13)
    {
      unint64_t v14 = (_anonymous_namespace_ *)v7;
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a2, (uint64_t)&v16);
      if (v16 && (v17 & 1) != 0) {
        (*(void (**)(void))(*(void *)v16 + 40))();
      }
    }
    else
    {
LABEL_16:
      unint64_t v14 = 0;
    }
  }

  return v14;
}

uint64_t re::getConstantFloat(re *this, NSDictionary *a2, NSString *a3, float *a4)
{
  id v5 = -[re objectForKey:](this, "objectForKey:", a2, a4);
  uint64_t v6 = v5;
  if (v5
    && ([v5 type],
        id v7 = objc_claimAutoreleasedReturnValue(),
        BOOL v8 = (void *)*MEMORY[0x263F83F40],
        v7,
        v7 == v8))
  {
    [v6 floatValue];
    *(_DWORD *)a3 = v10;
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
  }

  return v9;
}

__n128 re::getTextureScaleFloat(void *a1, int a2, __n128 a3)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  id v4 = a1;
  __asm { FMOV            V0.4S, #1.0 }
  __n128 PropertyValueWithOutputProperty = re::getPropertyValueWithOutputProperty(v4, @"inputs:scale", _Q0);
  int v10 = [v4 name];
  uint64_t v11 = [v10 stringValue];
  uint64_t v12 = [v11 componentsSeparatedByString:@":"];

  id v13 = [v12 lastObject];
  unint64_t v14 = (_anonymous_namespace_ *)[v13 UTF8String];

  if (v34) {
    float32x4_t v15 = v36;
  }
  else {
    float32x4_t v15 = v35;
  }
  if (!strcmp(v15, "r") || !strcmp(v15, "g") || !strcmp(v15, "b") || (uint64_t v16 = (re *)strcmp(v15, "a"), !v16))
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v31, (const re::DynamicString *)&v33);
    int v19 = re::getDataComponentWithPropertyOutput((uint64_t)&v31, PropertyValueWithOutputProperty);
    if ((void)v31)
    {
      if (BYTE8(v31)) {
        (*(void (**)(void, void))(*(void *)v31 + 40))(v31, v32);
      }
      long long v31 = 0u;
      long long v32 = 0u;
    }
    if (a2)
    {
      objc_msgSend(v19, "floatValue", *(_OWORD *)&a3);
      PropertyValueWithOutputProperty.n128_u64[0] = v20;
    }
    else
    {
      __n128 v29 = re::getPropertyValueWithOutputProperty(v4, @"inputs:fallback", a3);
      re::DynamicString::DynamicString((re::DynamicString *)v30, (const re::DynamicString *)&v33);
      __n128 v21 = re::getDataComponentWithPropertyOutput((uint64_t)v30, v29);
      if (*(void *)&v30[0])
      {
        if (BYTE8(v30[0])) {
          (*(void (**)(void))(**(void **)&v30[0] + 40))();
        }
        memset(v30, 0, sizeof(v30));
      }
      objc_msgSend(v19, "floatValue", *(_OWORD *)&a3);
      float v23 = v22;
      [v21 floatValue];
      v25.n128_f32[0] = v23 * v24;
      __n128 PropertyValueWithOutputProperty = v25;
    }
  }
  else
  {
    char v17 = *re::pipelineLogObjects(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      if (v34) {
        long long v18 = v36;
      }
      else {
        long long v18 = v35;
      }
      *(_DWORD *)long long buf = 136315138;
      BOOL v38 = v18;
      _os_log_error_impl(&dword_233120000, v17, OS_LOG_TYPE_ERROR, "Invalid USD texture shader node output %s for single texture component.", buf, 0xCu);
    }
  }
  if (v33 && (v34 & 1) != 0) {
    (*(void (**)(void))(*(void *)v33 + 40))();
  }

  return PropertyValueWithOutputProperty;
}

void re::gatherMaterialTextureProperties(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  uint64_t v3 = [MEMORY[0x263F83F10] textureMaterialPropertiesWithMaterial:a1];
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_DWORD *)(a2 + 36) = 0x7FFFFFFF;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_WORD *)(a2 + 80) = 0;
  id v4 = [v3 objectForKey:@"inputs:diffuseColor"];
  id v72 = v4;
  if (v4)
  {
    re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v72);
    if (*(void *)buf)
    {
      if (buf[8]) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
    }
  }
  id v5 = [v3 objectForKey:@"inputs:normal"];
  id v71 = v5;
  if (v5)
  {
    re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v71);
    if (*(void *)buf)
    {
      if (buf[8]) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
    }
  }
  uint64_t v6 = [v3 objectForKey:@"inputs:metallic"];
  id v70 = v6;
  id v7 = [v3 objectForKey:@"inputs:roughness"];
  id v69 = v7;
  BOOL v8 = [v3 objectForKey:@"inputs:specularColor"];
  id v68 = v8;
  uint64_t v9 = [v3 objectForKey:@"inputs:occlusion"];
  id v67 = v9;
  if (v6)
  {
    int v10 = [v6 parentNode];
    uint64_t v11 = [v10 property:@"inputs:file"];
    uint64_t v6 = [v11 stringValue];
  }
  if (v7)
  {
    uint64_t v12 = [v7 parentNode];
    id v13 = [v12 property:@"inputs:file"];
    id v7 = [v13 stringValue];
  }
  if (v8)
  {
    unint64_t v14 = [v8 parentNode];
    float32x4_t v15 = [v14 property:@"inputs:file"];
    BOOL v8 = [v15 stringValue];
  }
  if (v9)
  {
    uint64_t v16 = [v9 parentNode];
    char v17 = [v16 property:@"inputs:file"];
    uint64_t v9 = [v17 stringValue];
  }
  id v18 = v6;
  id v19 = v18;
  if (!v18)
  {
    id v19 = v7;
    if (!v19)
    {
      id v19 = v8;
      if (!v19) {
        id v19 = v9;
      }
    }
  }
  if (v9)
  {
    unint64_t v20 = (_anonymous_namespace_ *)[v9 isEqualToString:v19];
    if ((v20 & 1) == 0)
    {
      re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v67);
      if (*(void *)buf && (buf[8] & 1) != 0) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
      id v21 = v67;
      id v67 = 0;

      uint64_t v9 = 0;
    }
  }
  float v22 = [MEMORY[0x263EFF9C0] set];
  if (v18 && [v18 isEqualToString:v19])
  {
    float v23 = [v70 name];
    float v24 = [v23 stringValue];
    [v22 addObject:v24];
  }
  if (v7 && [v7 isEqualToString:v19])
  {
    __n128 v25 = [v69 name];
    BOOL v26 = [v25 stringValue];
    [v22 addObject:v26];
  }
  if (v8 && [v8 isEqualToString:v19])
  {
    BOOL v27 = [v68 name];
    uint64_t v28 = [v27 stringValue];
    [v22 addObject:v28];
  }
  if (v9 && [v9 isEqualToString:v19])
  {
    __n128 v29 = [v67 name];
    uint64_t v30 = [v29 stringValue];
    [v22 addObject:v30];
  }
  unint64_t v31 = [v22 count];
  if (v31 < 2) {
    goto LABEL_53;
  }
  if (v18)
  {
    unint64_t v31 = [v18 isEqualToString:v19];
    if (!v31) {
      goto LABEL_53;
    }
  }
  if (v7)
  {
    unint64_t v31 = [v7 isEqualToString:v19];
    if (!v31) {
      goto LABEL_53;
    }
  }
  if (!v8)
  {
    if (!v9) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  unint64_t v31 = [v8 isEqualToString:v19];
  if (v9 && (v31 & 1) != 0)
  {
LABEL_50:
    unint64_t v31 = [v9 isEqualToString:v19];
    if ((v31 & 1) == 0) {
      goto LABEL_53;
    }
    goto LABEL_51;
  }
  if (!v31)
  {
LABEL_53:
    if (v70)
    {
      re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v70);
      unint64_t v31 = *(void *)buf;
      if (*(void *)buf)
      {
        if (buf[8]) {
          unint64_t v31 = (*(uint64_t (**)(void))(**(void **)buf + 40))();
        }
      }
    }
    if (v69)
    {
      re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v69);
      unint64_t v31 = *(void *)buf;
      if (*(void *)buf)
      {
        if (buf[8]) {
          unint64_t v31 = (*(uint64_t (**)(void))(**(void **)buf + 40))();
        }
      }
    }
    if (v68)
    {
      re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v68);
      unint64_t v31 = *(void *)buf;
      if (*(void *)buf)
      {
        if (buf[8]) {
          unint64_t v31 = (*(uint64_t (**)(void))(**(void **)buf + 40))();
        }
      }
    }
    if (v67)
    {
      re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v67);
      if (*(void *)buf)
      {
        if (buf[8]) {
          (*(void (**)(void))(**(void **)buf + 40))();
        }
      }
    }
    goto LABEL_76;
  }
LABEL_51:
  uint64_t v61 = v8;
  int v62 = v7;
  id v32 = v70;
  uint64_t v33 = v32;
  id v66 = v32;
  id v34 = v69;
  if (v32)
  {
    id v35 = v68;
  }
  else
  {
    id v32 = v69;
    id v66 = v32;
    id v35 = v68;
    if (!v32)
    {
      id v32 = v68;
      id v66 = v32;
      id v35 = v32;
      if (!v32)
      {
        id v32 = v67;
        id v66 = v32;
      }
    }
  }
  uint64_t v60 = v32;
  re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v66);
  if (*(void *)buf && (buf[8] & 1) != 0) {
    (*(void (**)(void))(**(void **)buf + 40))();
  }
  id v36 = v34;
  id v37 = v33;
  id v38 = v67;
  id v39 = v35;
  uint64_t v40 = *(void **)(a2 + 48);
  *(void *)(a2 + 48) = v36;

  uint64_t v41 = *(void **)(a2 + 56);
  *(void *)(a2 + 56) = v37;

  uint64_t v42 = *(void **)(a2 + 64);
  *(void *)(a2 + 64) = v38;

  BOOL v43 = *(void **)(a2 + 72);
  *(void *)(a2 + 72) = v39;

  BOOL v8 = v61;
  id v7 = v62;
LABEL_76:

  unint64_t v44 = [v3 objectForKey:@"inputs:emissiveColor"];
  unint64_t v45 = v44;
  id v66 = v44;
  if (v44)
  {
    re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v66);
    if (*(void *)buf)
    {
      if (buf[8]) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
    }
  }
  id v46 = v72;
  uint64_t v47 = [v3 objectForKey:@"inputs:opacity"];
  id v65 = v47;
  if (v47)
  {
    uint64_t v48 = re::gatherMaterialTextureProperties(USKNode *)::$_0::operator()(v46, v47);
    *(unsigned char *)(a2 + 80) = v48;
    if ((v48 & 1) == 0)
    {
      re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v65);
      if (*(void *)buf)
      {
        if (buf[8]) {
          (*(void (**)(void))(**(void **)buf + 40))();
        }
      }
    }
  }
  unint64_t v49 = [v3 objectForKey:@"inputs:realitykit:tintMask"];
  if (v49)
  {
    uint64_t v50 = (re *)re::gatherMaterialTextureProperties(USKNode *)::$_0::operator()(v46, v49);
    if (v50)
    {
      *(unsigned char *)(a2 + 81) = 1;
    }
    else
    {
      uint64_t v51 = *re::pipelineLogObjects(v50);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        unint64_t v56 = v51;
        unint64_t v57 = [v49 objectPath];
        id v58 = [v57 stringValue];
        uint64_t v59 = [v58 UTF8String];
        *(_DWORD *)long long buf = 136315138;
        *(void *)&uint8_t buf[4] = v59;
        _os_log_error_impl(&dword_233120000, v56, OS_LOG_TYPE_ERROR, "Unsupported connection to the \"tintMask\" at %s: only connections to the alpha channel of the \"diffuseColor\" texture are supported.", buf, 0xCu);
      }
    }
  }
  uint64_t v52 = [v3 objectForKey:@"inputs:clearcoatRoughness"];
  float32x4_t v53 = v52;
  id v64 = v52;
  if (v52)
  {
    re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v64);
    if (*(void *)buf)
    {
      if (buf[8]) {
        (*(void (**)(void))(**(void **)buf + 40))();
      }
    }
  }
  unint64_t v54 = [v3 objectForKey:@"inputs:clearcoat"];
  id v63 = v54;
  if (v54)
  {
    BOOL v55 = v54;
    re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(a2, (const re::DynamicString *)buf, &v63);
    if (*(void *)buf && (buf[8] & 1) != 0) {
      (*(void (**)(void))(**(void **)buf + 40))();
    }
  }
}

id re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<USKProperty * {__strong}&>(uint64_t a1, const re::DynamicString *a2, id *a3)
{
  unint64_t v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v17, (uint64_t)a2);
  unint64_t v7 = v6;
  if (!*(void *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 24);
  uint64_t v9 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v8);
  if (v9 == 0x7FFFFFFF)
  {
LABEL_8:
    uint64_t v12 = *(unsigned int *)(a1 + 36);
    if (v12 == 0x7FFFFFFF)
    {
      uint64_t v12 = *(unsigned int *)(a1 + 32);
      int v13 = v12;
      if (v12 == *(_DWORD *)(a1 + 24))
      {
        re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
        LODWORD(v8) = v7 % *(unsigned int *)(a1 + 24);
        int v13 = *(_DWORD *)(a1 + 32);
      }
      *(_DWORD *)(a1 + 32) = v13 + 1;
      uint64_t v14 = *(void *)(a1 + 16);
      int v15 = *(_DWORD *)(v14 + 56 * v12 + 8);
    }
    else
    {
      uint64_t v14 = *(void *)(a1 + 16);
      int v15 = *(_DWORD *)(v14 + 56 * v12 + 8);
      *(_DWORD *)(a1 + 36) = v15 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v14 + 56 * v12 + 8) = v15 | 0x80000000;
    *(_DWORD *)(*(void *)(a1 + 16) + 56 * v12 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v12 + 8) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * v8);
    *(void *)(*(void *)(a1 + 16) + 56 * v12) = v7;
    re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v12 + 16), a2);
    uint64_t v16 = *(void *)(a1 + 16) + 56 * v12;
    id result = *a3;
    *(void *)(v16 + 48) = result;
    *(_DWORD *)(*(void *)(a1 + 8) + 4 * v8) = v12;
    ++*(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 40);
    return result;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  while (1)
  {
    id result = (id)re::DynamicString::operator==(v10 + 56 * v9 + 16, (uint64_t)a2);
    if (result) {
      return result;
    }
    uint64_t v9 = *(_DWORD *)(v10 + 56 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
}

uint64_t re::gatherMaterialTextureProperties(USKNode *)::$_0::operator()(void *a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  id v3 = a2;
  id v4 = [a1 parentNode];
  id v5 = [v4 property:@"inputs:file"];
  unint64_t v6 = [v5 stringValue];

  unint64_t v7 = [v3 parentNode];
  unint64_t v8 = [v7 property:@"inputs:file"];
  uint64_t v9 = [v8 stringValue];

  LODWORD(v7) = [v6 isEqualToString:v9];
  uint64_t v10 = [v3 name];

  uint64_t v11 = [v10 stringValue];
  int v12 = [v11 isEqualToString:@"outputs:a"];

  uint64_t v13 = v7 & v12;
  return v13;
}

uint64_t re::isMaterialTransparent(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  unint64_t v6 = v5;
  if (!*(unsigned char *)(a2 + 80)) {
    goto LABEL_12;
  }
  BOOL v7 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a2, (uint64_t)&v15);
  id v5 = v15;
  if (v15 && (v16 & 1) != 0) {
    id v5 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v15 + 40))();
  }
  if (!v7)
  {
LABEL_12:
    BOOL v11 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a2, (uint64_t)&v15);
    int v12 = v15;
    if (v15 && (v16 & 1) != 0) {
      int v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(void *)v15 + 40))();
    }
    if (v11)
    {
      BOOL v13 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a3, (uint64_t)&v15);
      if (v15 && (v16 & 1) != 0) {
        (*(void (**)(void))(*(void *)v15 + 40))();
      }
      if (v13) {
        goto LABEL_20;
      }
    }
LABEL_21:
    goto LABEL_22;
  }
  uint64_t v9 = (re::TextureProvider **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(a3, (uint64_t)&v15);
  if (v15 && (v16 & 1) != 0) {
    (*(void (**)(void))(*(void *)v15 + 40))();
  }
  if (!v9) {
    goto LABEL_21;
  }
  if (!*v9)
  {
LABEL_20:
    uint64_t HaveAlpha = 1;
    goto LABEL_22;
  }
  uint64_t HaveAlpha = re::TextureProvider::canHaveAlpha(*v9, v8);
LABEL_22:

  return HaveAlpha;
}

uint64_t re::isMaterialAlphaCutout(re *this, NSDictionary *a2, uint64_t a3, float *a4)
{
  LODWORD(var4) = 0;
  LODWORD(result) = re::getConstantFloat(this, (NSDictionary *)@"inputs:opacityThreshold", &var4, a4);
  if (*(float *)&var4 > 0.0) {
    return result;
  }
  else {
    return 0;
  }
}

__n128 re::getPropertyValueWithOutputProperty(void *a1, void *a2, __n128 a3)
{
  id v4 = a2;
  if (a1)
  {
    id v5 = [a1 parentNode];
    unint64_t v6 = v5;
    if (v5)
    {
      BOOL v7 = [v5 property:v4];
      unint64_t v8 = v7;
      if (v7)
      {
        uint64_t v9 = [v7 data];

        if (v9)
        {
          [v8 float4Value];
          a3 = v10;
        }
      }
    }
  }

  return a3;
}

id re::getDataComponentWithPropertyOutput(uint64_t a1, __n128 a2)
{
  if (*(void *)(a1 + 8)) {
    uint64_t v2 = *(const char **)(a1 + 16);
  }
  else {
    uint64_t v2 = (const char *)(a1 + 9);
  }
  if (!strcmp(v2, "r"))
  {
    id v6 = objc_alloc(MEMORY[0x263F83ED8]);
    unint64_t v7 = a2.n128_u64[0];
LABEL_14:
    id v5 = objc_msgSend(v6, "initWithFloat:", *(double *)&v7, *(_OWORD *)&a2);
    goto LABEL_15;
  }
  if (!strcmp(v2, "g"))
  {
    id v6 = objc_alloc(MEMORY[0x263F83ED8]);
    HIDWORD(v7) = a2.n128_u32[1];
    LODWORD(v7) = a2.n128_u32[1];
    goto LABEL_14;
  }
  if (!strcmp(v2, "b"))
  {
    id v6 = objc_alloc(MEMORY[0x263F83ED8]);
    unint64_t v7 = __PAIR64__(a2.n128_u32[1], a2.n128_u32[2]);
    goto LABEL_14;
  }
  if (!strcmp(v2, "a"))
  {
    id v6 = objc_alloc(MEMORY[0x263F83ED8]);
    unint64_t v7 = __PAIR64__(a2.n128_u32[1], a2.n128_u32[3]);
    goto LABEL_14;
  }
  int v3 = strcmp(v2, "rgb");
  id v4 = objc_alloc(MEMORY[0x263F83ED8]);
  if (v3) {
    id v5 = (void *)[v4 initWithFloat4:a2.n128_f64[0]];
  }
  else {
    id v5 = (void *)[v4 initWithFloat3:a2.n128_f64[0]];
  }
LABEL_15:
  return v5;
}

void re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(void *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v23, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v23;
      id v6 = *(unint64_t **)(a1 + 16);
      long long v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)float v23 = v5;
      *(void *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        do
        {
          if ((v6[1] & 0x80000000) != 0)
          {
            unint64_t v14 = *v6;
            unint64_t v15 = *(unsigned int *)(a1 + 24);
            unint64_t v16 = *v6 % v15;
            uint64_t v17 = *(unsigned int *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              uint64_t v17 = *(unsigned int *)(a1 + 32);
              int v18 = v17;
              if (v17 == v15)
              {
                re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v12));
                unint64_t v16 = v14 % *(unsigned int *)(a1 + 24);
                int v18 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 56 * v17 + 8);
            }
            else
            {
              uint64_t v19 = *(void *)(a1 + 16);
              int v20 = *(_DWORD *)(v19 + 56 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 56 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + 56 * v17 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 56 * v17 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v16);
            *(void *)(*(void *)(a1 + 16) + 56 * v17) = v14;
            re::DynamicString::DynamicString((re::DynamicString *)(*(void *)(a1 + 16) + 56 * v17 + 16), (const re::DynamicString *)(v6 + 2));
            uint64_t v21 = *(void *)(a1 + 16) + 56 * v17;
            *(void *)(v21 + 48) = (id)v6[6];
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v16) = v17;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v6 += 7;
        }
        while (v11 < v10);
      }
      re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2) {
      signed int v22 = a2;
    }
    else {
      signed int v22 = 3;
    }
  }
}

uint64_t re::internal::makeOpenSubdivAssetBuffersAndAppendToAssetPartInternal(re::internal *this, const re::GeomMesh *a2, MeshAssetPart *a3)
{
  long long v5 = this;
  uint64_t v117 = *MEMORY[0x263EF8340];
  __n128 v84 = (re::internal *)((char *)this + 64);
  uint64_t result = re::internal::GeomAttributeManager::attributeByName((re::internal *)((char *)this + 64), "osdSubdivisionScheme");
  if (result)
  {
    uint64_t result = re::internal::GeomTypedAttribute<short>::operator[](result, 0);
    if (*(_WORD *)result == 1)
    {
      uint64_t v96 = 0;
      uint64_t v94 = 0;
      v93[0] = 0;
      v93[1] = 0;
      int v95 = 0;
      int v7 = *((_DWORD *)v5 + 50);
      if (v7)
      {
        for (unsigned int i = 0; i != v7; ++i)
        {
          uint64_t result = re::internal::GeomAttributeContainer::attributeByIndex((re::internal *)((char *)v5 + 176), i);
          if (*(unsigned char *)(result + 17) == 6)
          {
            v102[0] = *(void **)(result + 8);
            uint64_t result = (uint64_t)re::DynamicArray<re::TransitionCondition *>::add(v93, v102);
          }
        }
      }
      long long v9 = v102;
      int v10 = *((_DWORD *)v5 + 106);
      if (v10)
      {
        for (unsigned int j = 0; j != v10; ++j)
        {
          uint64_t v12 = re::internal::GeomAttributeContainer::attributeByIndex((re::internal *)((char *)v5 + 400), j);
          uint64_t result = re::internal::accessFaceVaryingAttributeSubmesh((re::internal *)v12, v13);
          if (*(_DWORD *)(result + 24) == *((_DWORD *)v5 + 10) && *(unsigned char *)(v12 + 17) == 6)
          {
            v102[0] = *(void **)(v12 + 8);
            uint64_t result = (uint64_t)re::DynamicArray<re::TransitionCondition *>::add(v93, v102);
          }
        }
      }
      uint64_t v82 = v96;
      float32x4_t v83 = v94;
      long long v104 = 0u;
      memset(&__src[8], 0, 64);
      float32x4_t v80 = (re::internal *)((char *)v5 + 16);
      unint64_t v14 = *((void *)v5 + 5);
      uint64_t v15 = v14;
      LODWORD(v102[0]) = *((_DWORD *)v5 + 4);
      HIDWORD(v102[0]) = v14;
      uint64_t v98 = 0;
      uint64_t v97 = 0;
      uint64_t v99 = 0;
      unint64_t v16 = (int)v14;
      if ((int)v14 >= 1)
      {
        int v18 = 0;
        unsigned int v19 = 0;
        int v20 = (uint64_t *)*((void *)v5 + 5);
        uint64_t v3 = v98;
        uint64_t v21 = v99;
        signed int v22 = (int *)(*((void *)v5 + 7) + 12);
        while (1)
        {
          if (v20 == v18) {
            goto LABEL_107;
          }
          if ((void *)v3 == v18) {
            break;
          }
          int v23 = *v22;
          v22 += 4;
          if (v23 == -1) {
            int v24 = 3;
          }
          else {
            int v24 = 4;
          }
          v21[(void)v18] = v24;
          v19 += v24;
          int v18 = (char *)v18 + 1;
          if ((void *)(int)v14 == v18) {
            goto LABEL_24;
          }
        }
LABEL_108:
        *(void *)&long long v91 = 0;
        long long v115 = 0u;
        long long v116 = 0u;
        long long v113 = 0u;
        long long v114 = 0u;
        long long v112 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v105 = 136315906;
        *(void **)((char *)v9 + 196) = "operator[]";
        __int16 v106 = 1024;
        *(_DWORD *)((char *)v9 + 206) = 468;
        __int16 v108 = 2048;
        *(void **)((char *)v9 + 212) = (void *)v3;
        __int16 v110 = 2048;
        *(void **)((char *)v9 + 222) = (void *)v3;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_109:
        *(void *)&long long v100 = 0;
        long long v115 = 0u;
        long long v116 = 0u;
        long long v113 = 0u;
        long long v114 = 0u;
        long long v112 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v105 = 136315906;
        *(void **)((char *)v9 + 196) = "operator[]";
        __int16 v106 = 1024;
        *(_DWORD *)((char *)v9 + 206) = 797;
        __int16 v108 = 2048;
        *(void **)((char *)v9 + 212) = (void *)v16;
        __int16 v110 = 2048;
        *(void **)((char *)v9 + 222) = (void *)v16;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        *(void *)unint64_t v105 = 0;
        memset(__src, 0, 64);
        *(_OWORD *)uint64_t v102 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        LODWORD(v112) = 136315906;
        *(void *)(v16 + 4) = "operator[]";
        WORD6(v112) = 1024;
        *(_DWORD *)(v16 + 14) = 468;
        WORD1(v113) = 2048;
        *(void *)(v16 + 20) = v5;
        WORD6(v113) = 2048;
        *(void *)(v16 + 30) = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        uint64_t v97 = 0;
        long long v115 = 0u;
        long long v116 = 0u;
        long long v113 = 0u;
        long long v114 = 0u;
        long long v112 = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        *(_DWORD *)unint64_t v105 = 136315906;
        *(void *)&v105[4] = "operator[]";
        __int16 v106 = 1024;
        int v107 = 789;
        __int16 v108 = 2048;
        unint64_t v109 = v14;
        __int16 v110 = 2048;
        unint64_t v111 = (unint64_t)v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_110;
      }
      unsigned int v19 = 0;
LABEL_24:
      long long v91 = 0uLL;
      unint64_t v25 = v19;
      *(void *)&long long v92 = 0;
      if (!v14)
      {
        uint64_t v31 = v92;
        goto LABEL_35;
      }
      uint64_t v27 = 0;
      int v28 = 0;
      unint64_t v16 = *((void *)v5 + 5);
      uint64_t v29 = *((void *)v5 + 7);
      long long v5 = (re::internal *)*((void *)&v91 + 1);
      do
      {
        if (v27 == v16) {
          goto LABEL_109;
        }
        uint64_t v30 = 0;
        long long v100 = *(_OWORD *)(v29 + 16 * v27);
        uint64_t v31 = v92;
        if (HIDWORD(v100) == -1) {
          uint64_t v32 = 3;
        }
        else {
          uint64_t v32 = 4;
        }
        do
        {
          unint64_t v14 = (v28 + v30);
          if ((unint64_t)v5 <= v14)
          {
            *(void *)&long long v89 = 0;
            long long v115 = 0u;
            long long v116 = 0u;
            long long v113 = 0u;
            long long v114 = 0u;
            long long v112 = 0u;
            unint64_t v33 = &_os_log_internal;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unint64_t v105 = 136315906;
            *(void *)&v105[4] = "operator[]";
            __int16 v106 = 1024;
            int v107 = 468;
            __int16 v108 = 2048;
            unint64_t v109 = v14;
            __int16 v110 = 2048;
            unint64_t v111 = (unint64_t)v5;
            _os_log_send_and_compose_impl();
            BOOL v43 = (_anonymous_namespace_ *)_os_crash_msg();
            __break(1u);
            id v36 = 0;
            int v20 = 0;
LABEL_51:
            uint64_t v47 = 0;
            DWORD1(v104) = v16;
            __n128 v81 = v36;
            *((void *)&v104 + 1) = v36;
            unint64_t v14 = 24;
            uint64_t v3 = 3;
            long long v9 = (void **)&v100;
            while (1)
            {
              if (v47 == v16) {
                goto LABEL_120;
              }
              uint64_t v48 = (re::internal *)re::internal::GeomAttributeManager::attributeByName(v84, *(const char **)(v82 + 8 * v47));
              long long v5 = v80;
              if (*((unsigned char *)v48 + 16) == 3)
              {
                uint64_t v48 = (re::internal *)re::internal::accessFaceVaryingAttributeSubmesh(v48, v49);
                long long v5 = v48;
              }
              if (v47 == v33) {
                goto LABEL_121;
              }
              unint64_t v50 = (4 * *((_DWORD *)v5 + 6));
              uint64_t v51 = HIDWORD(v102[0]);
              if (!HIDWORD(v102[0]))
              {
                uint64_t v60 = v20[3 * v47 + 2];
                goto LABEL_67;
              }
              uint64_t v52 = 0;
              int v53 = 0;
              unint64_t v54 = &v20[3 * v47];
              BOOL v55 = (unint64_t *)(v54 + 1);
              unint64_t v56 = v54 + 2;
              unint64_t v16 = *((void *)v5 + 3);
              do
              {
                if (v52 == v16)
                {
                  *(void *)&long long v100 = 0;
                  long long v115 = 0u;
                  long long v116 = 0u;
                  long long v113 = 0u;
                  long long v114 = 0u;
                  long long v112 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)unint64_t v105 = 136315906;
                  *(void *)&v105[4] = "operator[]";
                  __int16 v106 = 1024;
                  int v107 = 797;
                  __int16 v108 = 2048;
                  unint64_t v109 = v16;
                  __int16 v110 = 2048;
                  unint64_t v111 = v16;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_107:
                  *(void *)&long long v91 = 0;
                  long long v115 = 0u;
                  long long v116 = 0u;
                  long long v113 = 0u;
                  long long v114 = 0u;
                  long long v112 = 0u;
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  *(_DWORD *)unint64_t v105 = 136315906;
                  *(void **)((char *)v9 + 196) = "operator[]";
                  __int16 v106 = 1024;
                  *(_DWORD *)((char *)v9 + 206) = 797;
                  __int16 v108 = 2048;
                  *(void **)((char *)v9 + 212) = v20;
                  __int16 v110 = 2048;
                  *(void **)((char *)v9 + 222) = v20;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_108;
                }
                uint64_t v57 = 0;
                long long v100 = *(_OWORD *)(*((void *)v5 + 5) + 16 * v52);
                unint64_t v58 = *v55;
                if (HIDWORD(v100) == -1) {
                  uint64_t v59 = 3;
                }
                else {
                  uint64_t v59 = 4;
                }
                do
                {
                  unint64_t v4 = (v53 + v57);
                  if (v58 <= v4)
                  {
                    *(void *)&long long v89 = 0;
                    long long v115 = 0u;
                    long long v116 = 0u;
                    long long v113 = 0u;
                    long long v114 = 0u;
                    long long v112 = 0u;
                    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)unint64_t v105 = 136315906;
                    *(void *)&v105[4] = "operator[]";
                    __int16 v106 = 1024;
                    int v107 = 468;
                    __int16 v108 = 2048;
                    unint64_t v109 = v4;
                    __int16 v110 = 2048;
                    unint64_t v111 = v58;
                    _os_log_send_and_compose_impl();
                    _os_crash_msg();
                    __break(1u);
LABEL_70:
                    long long v5 = 0;
                    uint64_t v42 = 0;
                    goto LABEL_71;
                  }
                  uint64_t v60 = *v56;
                  *(_DWORD *)(*v56 + 4 * v4) = *((_DWORD *)&v100 + v57++);
                }
                while (v59 != v57);
                ++v52;
                v53 += v57;
              }
              while (v52 != v51);
LABEL_67:
              uint64_t v61 = (uint64_t)v81 + 16 * v47;
              *(_DWORD *)uint64_t v61 = *(_DWORD *)v5;
              *(void *)(v61 + 8) = v60;
              ++v47;
              unint64_t v16 = (unint64_t)v83;
              if (v47 == v33)
              {
                long long v9 = v102;
                goto LABEL_41;
              }
            }
          }
          *(_DWORD *)(v31 + 4 * v14) = *((_DWORD *)&v100 + v30++);
        }
        while (v32 != v30);
        ++v27;
        v28 += v30;
      }
      while (v27 != v15);
LABEL_35:
      v102[1] = v99;
      *(void *)float32x4_t __src = v31;
      unint64_t v16 = (unint64_t)v83;
      if (v83)
      {
        unint64_t v33 = v83;
                                                            + 32))();
        if (v34)
        {
          id v36 = v34;
          uint64_t v37 = v83 - 1;
          if (v83 == 1)
          {
            *(_DWORD *)id v34 = 0;
            id v38 = (void *)((char *)v34 + 8);
          }
          else
          {
            id v38 = (void *)((char *)v34 + 8);
            do
            {
              *((_DWORD *)v38 - 2) = 0;
              *id v38 = 0;
              v38 += 2;
              --v37;
            }
            while (v37);
            *((_DWORD *)v38 - 2) = 0;
          }
          *id v38 = 0;
          if (v45)
          {
            int v20 = v45;
            id v46 = v45;
            if (v83 != 1)
            {
              bzero(v45, 24 * v83 - 24);
              id v46 = &v20[3 * v83 - 3];
            }
            *id v46 = 0;
            v46[1] = 0;
            void v46[2] = 0;
            goto LABEL_51;
          }
LABEL_123:
          re::internal::assertLog((re::internal *)4, v44, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
          _os_crash();
          __break(1u);
        }
LABEL_122:
        re::internal::assertLog((re::internal *)4, v35, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
        _os_crash();
        __break(1u);
        goto LABEL_123;
      }
LABEL_41:
      uint64_t v39 = re::internal::GeomAttributeManager::attributeByName(v84, "osdEdgeCreaseIndices");
      uint64_t v40 = re::internal::GeomAttributeManager::attributeByName(v84, "osdEdgeCreaseWeights");
      long long v100 = 0uLL;
      *(void *)&long long v101 = 0;
      long long v89 = 0uLL;
      *(void *)&long long v90 = 0;
      if (v40 && v39)
      {
        unint64_t v16 = v40;
        unint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v40 + 16))(v40);
        *(_DWORD *)&__src[8] = v4;
        if (!(*(unsigned int (**)(uint64_t))(*(void *)v39 + 16))(v39)) {
          goto LABEL_70;
        }
        uint64_t v42 = re::internal::GeomTypedAttribute<int>::operator[](v39, 0);
        long long v5 = (re::internal *)(*(uint64_t (**)(uint64_t))(*(void *)v39 + 16))(v39);
LABEL_71:
        unsigned int v62 = (*(uint64_t (**)(unint64_t))(*(void *)v16 + 16))(v16);
        if (v62)
        {
          uint64_t v63 = re::internal::GeomTypedAttribute<int>::operator[](v16, 0);
          unsigned int v62 = (*(uint64_t (**)(unint64_t))(*(void *)v16 + 16))(v16);
        }
        else
        {
          uint64_t v63 = 0;
        }
        uint64_t v64 = v90;
        if (v4)
        {
          id v65 = 0;
          unint64_t v14 = 0;
          unint64_t v16 = *((void *)&v89 + 1);
          uint64_t v3 = v62;
          long long v9 = (void **)*((void *)&v100 + 1);
          uint64_t v66 = v101;
          id v67 = (void **)v4;
          while (v5 > v14)
          {
            unint64_t v4 = v14;
            if (v16 <= v14) {
              goto LABEL_114;
            }
            *(_DWORD *)(v64 + 4 * v14) = *(_DWORD *)(v42 + 4 * v14);
            unint64_t v14 = (v14 + 1);
            if (v5 <= v14) {
              goto LABEL_116;
            }
            if (v16 <= v14) {
              goto LABEL_117;
            }
            *(_DWORD *)(v64 + 4 * v14) = *(_DWORD *)(v42 + 4 * v14);
            if ((void **)v62 == v65) {
              goto LABEL_118;
            }
            if (v9 == v65) {
              goto LABEL_119;
            }
            *(_DWORD *)(v66 + 4 * (void)v65) = *(_DWORD *)(v63 + 4 * (void)v65);
            id v65 = (void **)((char *)v65 + 1);
            unint64_t v14 = (v14 + 1);
            if (v67 == v65) {
              goto LABEL_85;
            }
          }
LABEL_112:
          *(void *)&long long v87 = 0;
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void *)&v105[4] = "operator[]";
          __int16 v106 = 1024;
          int v107 = 601;
          __int16 v108 = 2048;
          unint64_t v109 = v14;
          __int16 v110 = 2048;
          unint64_t v111 = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_113:
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void **)((char *)v9 + 196) = "operator[]";
          __int16 v106 = 1024;
          *(_DWORD *)((char *)v9 + 206) = 601;
          __int16 v108 = 2048;
          *(void **)((char *)v9 + 212) = (void *)v16;
          __int16 v110 = 2048;
          *(void **)((char *)v9 + 222) = (void *)v16;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_114:
          *(void *)&long long v87 = 0;
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void *)&v105[4] = "operator[]";
          __int16 v106 = 1024;
          int v107 = 468;
          __int16 v108 = 2048;
          unint64_t v109 = v4;
          __int16 v110 = 2048;
          unint64_t v111 = v16;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_115:
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void **)((char *)v9 + 196) = "operator[]";
          __int16 v106 = 1024;
          *(_DWORD *)((char *)v9 + 206) = 468;
          __int16 v108 = 2048;
          *(void **)((char *)v9 + 212) = v5;
          __int16 v110 = 2048;
          *(void **)((char *)v9 + 222) = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_116:
          *(void *)&long long v87 = 0;
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void *)&v105[4] = "operator[]";
          __int16 v106 = 1024;
          int v107 = 601;
          __int16 v108 = 2048;
          unint64_t v109 = v14;
          __int16 v110 = 2048;
          unint64_t v111 = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_117:
          *(void *)&long long v87 = 0;
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void *)&v105[4] = "operator[]";
          __int16 v106 = 1024;
          int v107 = 468;
          __int16 v108 = 2048;
          unint64_t v109 = v14;
          __int16 v110 = 2048;
          unint64_t v111 = v16;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_118:
          *(void *)&long long v87 = 0;
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void *)&v105[4] = "operator[]";
          __int16 v106 = 1024;
          int v107 = 601;
          __int16 v108 = 2048;
          unint64_t v109 = v3;
          __int16 v110 = 2048;
          unint64_t v111 = v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_119:
          *(void *)&long long v87 = 0;
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          unint64_t v33 = &_os_log_internal;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void *)&v105[4] = "operator[]";
          __int16 v106 = 1024;
          int v107 = 468;
          __int16 v108 = 2048;
          unint64_t v109 = (unint64_t)v9;
          __int16 v110 = 2048;
          unint64_t v111 = (unint64_t)v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_120:
          re::internal::assertLog((re::internal *)6, v44, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v16, v16);
          _os_crash();
          __break(1u);
LABEL_121:
          *(void *)&long long v100 = 0;
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void *)&v105[4] = "operator[]";
          __int16 v106 = 1024;
          int v107 = 468;
          __int16 v108 = 2048;
          unint64_t v109 = v33;
          __int16 v110 = 2048;
          unint64_t v111 = v33;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          uint64_t v97 = 0;
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void **)((char *)v9 + 196) = "operator[]";
          __int16 v106 = 1024;
          *(_DWORD *)((char *)v9 + 206) = 789;
          __int16 v108 = 2048;
          *(void **)((char *)v9 + 212) = 0;
          __int16 v110 = 2048;
          *(void **)((char *)v9 + 222) = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_122;
        }
        uint64_t v66 = v101;
LABEL_85:
        *(void *)&__src[24] = v66;
        *(void *)&__src[16] = v64;
        long long v9 = v102;
      }
      uint64_t v68 = re::internal::GeomAttributeManager::attributeByName(v84, "osdVertexCreaseIndices");
      uint64_t v69 = re::internal::GeomAttributeManager::attributeByName(v84, "osdVertexCreaseWeights");
      long long v87 = 0uLL;
      *(void *)&long long v88 = 0;
      long long v85 = 0uLL;
      *(void *)&long long v86 = 0;
      if (v69 && v68)
      {
        uint64_t v70 = v69;
        id v71 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(void *)v69 + 16))(v69);
        unsigned int v72 = v71;
        *(_DWORD *)&__src[32] = v71;
        unint64_t v73 = (int)v71;
        if ((*(unsigned int (**)(uint64_t))(*(void *)v68 + 16))(v68))
        {
          uint64_t v75 = re::internal::GeomTypedAttribute<int>::operator[](v68, 0);
          unint64_t v14 = (*(unsigned int (**)(uint64_t))(*(void *)v68 + 16))(v68);
        }
        else
        {
          unint64_t v14 = 0;
          uint64_t v75 = 0;
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v70 + 16))(v70))
        {
          unint64_t v4 = re::internal::GeomTypedAttribute<int>::operator[](v70, 0);
          unint64_t v16 = (*(unsigned int (**)(uint64_t))(*(void *)v70 + 16))(v70);
        }
        else
        {
          unint64_t v16 = 0;
          unint64_t v4 = 0;
        }
        uint64_t v76 = v86;
        if (v72)
        {
          unsigned __int32 v77 = 0;
          uint64_t v3 = *((void *)&v85 + 1);
          unsigned __int32 v78 = (re::internal *)v72;
          long long v5 = (re::internal *)*((void *)&v87 + 1);
          uint64_t v79 = v88;
          while ((re::internal *)v14 != v77)
          {
            if ((re::internal *)v3 == v77) {
              goto LABEL_111;
            }
            *(_DWORD *)(v76 + 4 * (void)v77) = *(_DWORD *)(v75 + 4 * (void)v77);
            if ((re::internal *)v16 == v77) {
              goto LABEL_113;
            }
            if (v5 == v77) {
              goto LABEL_115;
            }
            *(_DWORD *)(v79 + 4 * (void)v77) = *(_DWORD *)(v4 + 4 * (void)v77);
            unsigned __int32 v77 = (re::internal *)((char *)v77 + 1);
            if (v78 == v77) {
              goto LABEL_103;
            }
          }
LABEL_110:
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void **)((char *)v9 + 196) = "operator[]";
          __int16 v106 = 1024;
          *(_DWORD *)((char *)v9 + 206) = 601;
          __int16 v108 = 2048;
          *(void **)((char *)v9 + 212) = (void *)v14;
          __int16 v110 = 2048;
          *(void **)((char *)v9 + 222) = (void *)v14;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_111:
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v112 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unint64_t v105 = 136315906;
          *(void **)((char *)v9 + 196) = "operator[]";
          __int16 v106 = 1024;
          *(_DWORD *)((char *)v9 + 206) = 468;
          __int16 v108 = 2048;
          *(void **)((char *)v9 + 212) = (void *)v3;
          __int16 v110 = 2048;
          *(void **)((char *)v9 + 222) = (void *)v3;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_112;
        }
        uint64_t v79 = v88;
LABEL_103:
        *(void *)&__src[48] = v79;
        *(void *)&__src[40] = v76;
      }
      operator new();
    }
  }
  return result;
}

void re::internal::makeOpenSubdivAssetBuffersAndAppendToAssetPart(re::internal *this, const re::GeomMesh *a2, MeshAssetPart *a3)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (re::internal::GeomAttributeManager::attributeByName((re::internal *)((char *)this + 64), "vertexUV"))
  {
    re::internal::makeOpenSubdivAssetBuffersAndAppendToAssetPartInternal(this, a2, v5);
  }
  else
  {
    uint64_t v17 = 0;
    int v18 = 0;
    bzero(v19, 0x2C8uLL);
    re::internal::GeomBaseMesh::GeomBaseMesh((re::internal::GeomBaseMesh *)v19);
    v19[89] = 0;
    re::GeomMesh::copy(this, (re::GeomMesh *)&v17);
    int v7 = re::addVertexUVs((re *)&v17, v6);
    unsigned int v8 = (uint64_t *)re::GeomMesh::accessVertexPositions(this);
    unsigned int v10 = v9;
    if ((*(unsigned int (**)(re::GeomAttribute *))(*(void *)v7 + 16))(v7))
    {
      uint64_t v12 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)v7, 0);
      uint64_t v13 = (*(unsigned int (**)(re::GeomAttribute *))(*(void *)v7 + 16))(v7);
    }
    else
    {
      uint64_t v13 = 0;
      uint64_t v12 = 0;
    }
    uint64_t v14 = *((unsigned int *)this + 4);
    if (v14)
    {
      for (uint64_t i = 0; i != v14; ++i)
      {
        if (v10 == i)
        {
          uint64_t v20 = 0;
          long long v32 = 0u;
          long long v33 = 0u;
          long long v30 = 0u;
          long long v31 = 0u;
          long long v29 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v21 = 136315906;
          signed int v22 = "operator[]";
          __int16 v23 = 1024;
          int v24 = 601;
          __int16 v25 = 2048;
          uint64_t v26 = v10;
          __int16 v27 = 2048;
          uint64_t v28 = v10;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_15:
          uint64_t v20 = 0;
          long long v32 = 0u;
          long long v33 = 0u;
          long long v30 = 0u;
          long long v31 = 0u;
          long long v29 = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          int v21 = 136315906;
          signed int v22 = "operator[]";
          __int16 v23 = 1024;
          int v24 = 609;
          __int16 v25 = 2048;
          uint64_t v26 = v13;
          __int16 v27 = 2048;
          uint64_t v28 = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        if (v13 == i) {
          goto LABEL_15;
        }
        uint64_t v16 = *v8;
        v8 += 2;
        *(void *)(v12 + 8 * i) = v16;
      }
    }
    re::internal::makeOpenSubdivAssetBuffersAndAppendToAssetPartInternal((re::internal *)&v17, a2, v11);
    re::GeomMesh::~GeomMesh((re::GeomMesh *)&v17);
  }
}

BOOL re::meshHasSubdivCreases(re *this, const re::GeomMesh *a2)
{
  uint64_t v2 = (re *)((char *)this + 64);
  return re::internal::GeomAttributeManager::attributeByName((re *)((char *)this + 64), "osdEdgeCreaseIndices")
      || re::internal::GeomAttributeManager::attributeByName(v2, "osdVertexCreaseIndices") != 0;
}

uint64_t re::ASTCCompressor::initializeContext@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v7 = result;
  unsigned int v9 = (void *)(result + 32);
  if (!*(void *)(result + 32))
  {
    if (!a3)
    {
      unsigned int v10 = "Invalid input ASTC pixel format";
      goto LABEL_9;
    }
    if (!*(_DWORD *)(a2 + 4))
    {
      unsigned int v10 = "Invalid ASTC mode";
      goto LABEL_9;
    }
    if (!*(_DWORD *)a2)
    {
      unsigned int v10 = "Invalid ASTC block size";
      goto LABEL_9;
    }
    *(_DWORD *)uint64_t result = a3;
    *(_DWORD *)(result + 4) = a4;
    *(_OWORD *)(result + 16) = *(_OWORD *)a2;
    unsigned int v14 = *(_DWORD *)(a2 + 4);
    if (v14 != 1)
    {
      if (v14 == 3)
      {
        unsigned int v14 = 2;
        switch(a3)
        {
          case 6u:
          case 7u:
          case 8u:
          case 9u:
          case 0xAu:
LABEL_24:
            char v15 = 1;
            break;
          default:
            unsigned int v14 = 3;
            goto LABEL_19;
        }
LABEL_25:
        if ((v15 & (*(unsigned char *)(a2 + 8) == 0)) != 0) {
          int v16 = 4;
        }
        else {
          int v16 = 0;
        }
        if ((a4 - 3) >= 2) {
          int v17 = v16;
        }
        else {
          int v17 = v16 | 8;
        }
        uint64_t v33 = 0;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v26 = 0u;
        LODWORD(result) = astcenc_config_init(v14, v18, v19, 1u, v17, (uint64_t)&v26, *(float *)(a2 + 12));
        float v20 = 0.0;
        int v21 = 0;
        if (a3 <= 0xA) {
          int v21 = dword_23440A930[a3];
        }
        DWORD1(v27) = 1065353216;
        DWORD2(v27) = v21;
        HIDWORD(v27) = v21;
        if (a3 - 6 < 5) {
          float v20 = 1.0;
        }
        *(float *)&long long v28 = v20;
        if (!result)
        {
          uint64_t result = astcenc_context_alloc((uint64_t)&v26, *(_DWORD *)(v7 + 8));
          if (!result)
          {
LABEL_39:
            *(unsigned char *)a5 = 1;
            return result;
          }
          *unsigned int v9 = 0;
        }
        error_string = astcenc_get_error_string(result);
        long long v11 = v23;
        uint64_t v12 = v24;
        uint64_t v13 = v25;
        goto LABEL_10;
      }
      if (v14 != 2)
      {
        re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "initializeContext", 232);
        _os_crash();
        __break(1u);
        JUMPOUT(0x233D3157CLL);
      }
      unsigned int v14 = 0;
    }
LABEL_19:
    switch(a3)
    {
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xAu:
        goto LABEL_24;
      default:
        char v15 = 0;
        break;
    }
    goto LABEL_25;
  }
  if (*(_DWORD *)a2 == *(_DWORD *)(result + 16)
    && *(_DWORD *)(a2 + 4) == *(_DWORD *)(result + 20)
    && *(unsigned __int8 *)(a2 + 8) == *(unsigned __int8 *)(result + 24)
    && *(float *)(a2 + 12) == *(float *)(result + 28)
    && *(_DWORD *)result == a3
    && *(_DWORD *)(result + 4) == a4)
  {
    goto LABEL_39;
  }
  unsigned int v10 = "ASTCCompressor::initializeContext cannot be called with different options";
LABEL_9:
  long long v11 = v26;
  uint64_t v13 = *((void *)&v27 + 1);
  uint64_t v12 = v27;
LABEL_10:
  *(unsigned char *)a5 = 0;
  *(_OWORD *)(a5 + 8) = v11;
  *(void *)(a5 + 24) = v12;
  *(void *)(a5 + 32) = v13;
  return result;
}

uint64_t re::anonymous namespace'::blockToSize(unsigned int a1)
{
  if (a1 > 0xE) {
    return 4;
  }
  else {
    return qword_23440A960[a1];
  }
}

uint64_t re::ASTCCompressor::compress@<X0>(re::ASTCCompressor *this@<X0>, const vImage_Buffer *a2@<X1>, unsigned __int8 *a3@<X2>, uint64_t a4@<X8>)
{
  int v7 = *(_DWORD *)this;
  uint64_t v8 = *(int *)this;
  if (*(_DWORD *)this > 0xAu) {
    goto LABEL_7;
  }
  int v9 = 1;
  if (((1 << v7) & 0x1D9) == 0)
  {
    if (((1 << v7) & 0x620) != 0)
    {
      int v10 = 2;
      int v37 = 1;
      goto LABEL_9;
    }
    if (v7 == 2)
    {
LABEL_8:
      int v10 = 0;
      int v37 = v9;
      int v9 = 0;
      goto LABEL_9;
    }
LABEL_7:
    int v9 = 0;
    goto LABEL_8;
  }
  int v37 = 0;
  int v10 = 2;
LABEL_9:
  if (v8 > 0xA) {
    goto LABEL_13;
  }
  int v11 = 3;
  if (((1 << v8) & 0x6C0) != 0)
  {
LABEL_11:
    int v12 = v10;
    int v10 = 0;
    goto LABEL_15;
  }
  if (v8 != 8)
  {
LABEL_13:
    int v11 = 5;
    if (((v8 - 4) & 0xFFFFFFFB) != 0) {
      goto LABEL_11;
    }
  }
  int v12 = 0;
LABEL_15:
  BOOL v13 = v8 == 10 || v8 == 7;
  if (v13) {
    int v14 = v10;
  }
  else {
    int v14 = v11;
  }
  int v38 = v14;
  if (v13) {
    int v15 = v11;
  }
  else {
    int v15 = v12;
  }
  if (v13) {
    int v16 = v12;
  }
  else {
    int v16 = v9;
  }
  if (v13) {
    int v17 = v9;
  }
  else {
    int v17 = v10;
  }
  vImagePixelCount width = a2->width;
  if (v8 > 0xA) {
    uint64_t v19 = 1;
  }
  else {
    uint64_t v19 = qword_23440AA50[v8];
  }
  size_t v20 = v19 * width;
  uint64_t v60 = 0;
  int v59 = 0;
  data = (char *)a2->data;
  vImagePixelCount height = a2->height;
  uint64_t v57 = a2->data;
  memset(v58, 0, sizeof(v58));
  if (a2->rowBytes != v19 * width)
  {
    re::DynamicArray<BOOL>::resize((uint64_t)v58, height * v20);
    long long v23 = v60;
    if (a2->height)
    {
      uint64_t v36 = a4;
      vImagePixelCount v24 = 0;
      do
      {
        memcpy(v23, data, v20);
        v23 += v20;
        data += a2->rowBytes;
        ++v24;
        vImagePixelCount height = a2->height;
      }
      while (v24 < height);
      long long v23 = v60;
      a4 = v36;
    }
    else
    {
      vImagePixelCount height = 0;
    }
    uint64_t v57 = v23;
    vImagePixelCount width = a2->width;
  }
  unsigned int v56 = 0;
  v55[0] = 0;
  v55[1] = v55;
  uint64_t v55[2] = 0x2020000000;
  void v55[3] = &v56;
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN2re14ASTCCompressor8compressERK13vImage_BufferPh_block_invoke;
  aBlock[3] = &unk_264BE7FE0;
  int v44 = width;
  int v45 = height;
  int v46 = 1;
  int v47 = v37;
  int v51 = v17;
  int v52 = v16;
  int v53 = v15;
  int v54 = v38;
  uint64_t v48 = &v57;
  unint64_t v49 = a3;
  unint64_t v50 = 16 * (width + v25 - 1) / v25 * ((height + v26 - 1) / v26);
  aBlock[4] = v55;
  aBlock[5] = this;
  long long v27 = (void (**)(void *, void))_Block_copy(aBlock);
  size_t v28 = *((void *)this + 1);
  if (v28 < 2) {
    v27[2](v27, 0);
  }
  else {
    dispatch_apply(v28, *((dispatch_queue_t *)this + 5), v27);
  }
  astcenc_compress_reset(*((astcenc_context **)this + 4));
  if (atomic_load(&v56))
  {
    unsigned int v30 = atomic_load(&v56);
    error_string = astcenc_get_error_string(v30);
    long long v32 = v40;
    uint64_t v33 = v41;
    uint64_t v34 = v42;
    *(unsigned char *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v32;
    *(void *)(a4 + 24) = v33;
    *(void *)(a4 + 32) = v34;
  }
  else
  {
    *(unsigned char *)a4 = 1;
  }

  _Block_object_dispose(v55, 8);
  uint64_t result = v58[0];
  if (v58[0])
  {
    if (v60) {
      return (*(uint64_t (**)(void))(*(void *)v58[0] + 40))(v58[0]);
    }
  }
  return result;
}

uint64_t ___ZN2re14ASTCCompressor8compressERK13vImage_BufferPh_block_invoke(uint64_t a1)
{
  uint64_t result = astcenc_compress_image(*(void *)(*(void *)(a1 + 40) + 32));
  if (result) {
    atomic_store(result, *(unsigned int **)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  }
  return result;
}

uint64_t re::getASTCBlockSize(int a1)
{
  if ((a1 - 186) > 0x32) {
    return 0;
  }
  else {
    return dword_23440AAA8[a1 - 186];
  }
}

uint64_t re::getASTCDefaultMode(int a1)
{
  if (re::isHDR(a1)) {
    return 3;
  }
  MTLPixelFormatGetInfoForDevice();
  return 1;
}

uint64_t re::getMTLPixelFormat(unsigned int a1, int a2)
{
  if (a2 == 3)
  {
    if (a1 <= 0xE)
    {
      uint64_t v2 = (unsigned int *)&unk_23440ABEC;
      return v2[a1];
    }
  }
  else if (a2 == 2)
  {
    if (a1 < 0xF)
    {
      uint64_t v2 = (unsigned int *)&unk_23440ABB0;
      return v2[a1];
    }
  }
  else if (a2 == 1 && a1 < 0xF)
  {
    uint64_t v2 = (unsigned int *)&unk_23440AB74;
    return v2[a1];
  }
  return 0;
}

uint64_t re::MTLToASTCPixelFormat(int a1)
{
  if (a1 > 69)
  {
    if ((a1 - 70) < 2) {
      return 6;
    }
    if (a1 == 115) {
      return 9;
    }
  }
  else
  {
    if ((a1 - 10) < 2) {
      return 1;
    }
    if (a1 == 25) {
      return 2;
    }
  }
  return 0;
}

void re::internalLogTextureCompressionInfo(re *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int *a9)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  if (a7 != 7) {
    a5 = a4;
  }
  if (a7 == 5) {
    int v15 = 6;
  }
  else {
    int v15 = a5;
  }
  int v16 = *re::pipelineLogObjects(a1);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    int v17 = off_264BE8000[re::MTLToASTCPixelFormat(a8)];
    int v18 = *((unsigned __int8 *)a9 + 8);
    uint64_t v19 = *a9;
    if (v19 > 0xE) {
      size_t v20 = "4x4";
    }
    else {
      size_t v20 = off_264BE8050[v19];
    }
    int v21 = 136316930;
    signed int v22 = a1;
    __int16 v23 = 1024;
    int v24 = a2;
    __int16 v25 = 1024;
    int v26 = a3;
    __int16 v27 = 1024;
    int v28 = v15;
    __int16 v29 = 1024;
    int v30 = a6;
    __int16 v31 = 2080;
    long long v32 = v17;
    __int16 v33 = 1024;
    int v34 = v18;
    __int16 v35 = 2080;
    uint64_t v36 = v20;
    _os_log_debug_impl(&dword_233120000, v16, OS_LOG_TYPE_DEBUG, "%s - Texture compression requested on texture import:\nInput: %ux%ux%u. mips: %u, texel format: %s, premult if alpha: %d, block format: %s", (uint8_t *)&v21, 0x3Eu);
  }
}

void re::logTextureCompressionInfo(re *a1, uint64_t a2, int *a3)
{
  if (*(_DWORD *)(a2 + 88) >= 2u) {
    goto LABEL_8;
  }
  unsigned int v6 = objc_msgSend(*(id *)(a2 + 8), sel_width);
  if (*(_DWORD *)(a2 + 88) >= 2u) {
    goto LABEL_8;
  }
  int v7 = v6;
  unsigned int v8 = objc_msgSend(*(id *)(a2 + 8), sel_height);
  if (*(_DWORD *)(a2 + 88) >= 2u
    || (int v9 = v8, v10 = objc_msgSend(*(id *)(a2 + 8), sel_arrayLength), *(_DWORD *)(a2 + 88) >= 2u)
    || (int v11 = v10,
        int v12 = objc_msgSend(*(id *)(a2 + 8), sel_depth),
        unsigned int v13 = re::TextureData::mipmapLevelCount((re::TextureData *)a2),
        *(_DWORD *)(a2 + 88) >= 2u)
    || (int v14 = v13, v15 = objc_msgSend(*(id *)(a2 + 8), sel_textureType), *(_DWORD *)(a2 + 88) >= 2u))
  {
LABEL_8:
    int v16 = std::__throw_bad_variant_access[abi:nn180100]();
    re::logTextureCompressionInfo(v16, v17);
  }
  else
  {
    re::internalLogTextureCompressionInfo(a1, v7, v9, v11, v12, v14, v15, (int)objc_msgSend(*(id *)(a2 + 8), sel_pixelFormat), a3);
  }
}

void re::logTextureCompressionInfo(re *a1, id a2, int *a3)
{
}

void *re::parseAnimationBVH@<X0>(re *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v127 = *MEMORY[0x263EF8340];
  float v103 = 0.0;
  long long v104 = 0u;
  long long v105 = 0u;
  unint64_t v4 = &v104;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  uint64_t v117 = this;
  v118[64] = v118;
  v118[65] = v118;
  uint64_t v102 = 0;
  v99[1] = 0;
  unint64_t v100 = 0;
  v99[0] = 0;
  int v101 = 0;
  unint64_t v7 = v6 - NextToken;
  if (v6 == NextToken)
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v8 = 0;
    if (v7 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v6 - NextToken;
    }
    while (v8 != 9)
    {
      if (aHierarchy[v8] != *((unsigned char *)NextToken + v8)) {
        goto LABEL_47;
      }
      if (v9 == ++v8) {
        goto LABEL_11;
      }
    }
    uint64_t v9 = 9;
  }
LABEL_11:
  if (v9 != v7) {
    goto LABEL_47;
  }
  if (!NextToken) {
    goto LABEL_47;
  }
  __endptr[0].n128_u64[0] = 0;
  memset(&__endptr[1], 0, 32);
  __endptr[0].n128_u64[1] = (unint64_t)"";
  *(void *)&long long v113 = 0;
  *((void *)&v113 + 1) = 0xFFFFFFFFLL;
  if (__endptr[2].n128_u64[0])
  {
    if (__endptr[2].n128_u64[1])
    {
      (*(void (**)(__n128))(*(void *)__endptr[2].n128_u64[0] + 40))(v10);
      __endptr[2].n128_u64[1] = 0;
      *(void *)&long long v113 = 0;
    }
    __endptr[2].n128_u64[0] = 0;
  }
  re::StringID::destroyString((re::StringID *)__endptr);
  int v11 = v102;
  unint64_t v12 = v100;
  unint64_t v14 = v13 - NextToken;
  if (v13 == NextToken)
  {
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = v14 <= 1 ? 1 : v13 - NextToken;
    while (v15 != 4)
    {
      if (aRoot_1[v15] != *((unsigned char *)NextToken + v15)) {
        goto LABEL_47;
      }
      if (v16 == ++v15) {
        goto LABEL_27;
      }
    }
    uint64_t v16 = 4;
  }
LABEL_27:
  if (v16 != v14
  {
LABEL_47:
    uint64_t v36 = "Unable to parse hierarchy.";
LABEL_48:
    __n128 v37 = __endptr[0];
    __n128 v38 = __endptr[1];
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 100;
    *(void *)(a2 + 16) = re::AssetErrorCategory(void)::instance;
    *(__n128 *)(a2 + 24) = v37;
    *(__n128 *)(a2 + 40) = v38;
    goto LABEL_49;
  }
  size_t v20 = &v119;
  uint64_t v22 = 0;
  unint64_t v23 = 0;
  int v24 = v102;
  __int16 v25 = v102;
  do
  {
    unint64_t v26 = *((void *)&v104 + 1);
    if (*((void *)&v104 + 1) <= v23)
    {
      v110.i64[0] = 0;
      long long v113 = 0u;
      *(_OWORD *)long long v114 = 0u;
      memset(__endptr, 0, sizeof(__endptr));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v119 = 136315906;
      char v120 = "operator[]";
      __int16 v121 = 1024;
      int v122 = 468;
      __int16 v123 = 2048;
      unint64_t v124 = v23;
      __int16 v125 = 2048;
      unint64_t v126 = v26;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_95:
      v110.i64[0] = 0;
      long long v113 = 0u;
      *(_OWORD *)long long v114 = 0u;
      memset(__endptr, 0, sizeof(__endptr));
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v119 = 136315906;
      char v120 = "operator[]";
      __int16 v121 = 1024;
      int v122 = 468;
      __int16 v123 = 2048;
      unint64_t v124 = v23;
      __int16 v125 = 2048;
      unint64_t v126 = v26;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_96;
    }
    __int16 v27 = re::StringID::operator=((unint64_t *)(v105 + v22), (uint64_t *)v25);
    unint64_t v26 = v106;
    if ((unint64_t)v106 <= v23) {
      goto LABEL_95;
    }
    *(_DWORD *)(*((void *)&v106 + 1) + 4 * v23++) = *((_DWORD *)v25 + 14);
    __int16 v25 = (re::StringID *)((char *)v25 + 64);
    v22 += 16;
  }
  while (v19 != v23);
  __int16 v25 = 0;
  int v28 = (long long *)((char *)v24 + 16);
  uint64_t v29 = 32;
  while (1)
  {
    unint64_t v23 = *((void *)&v107 + 1);
    if (*((void *)&v107 + 1) <= (unint64_t)v25) {
      break;
    }
    long long v30 = *v28;
    v28 += 4;
    *(_OWORD *)(v108 + v29) = v30;
    __int16 v25 = (re::StringID *)((char *)v25 + 1);
    v29 += 48;
    if ((re::StringID *)v19 == v25)
    {
      unint64_t v33 = v32 - v31;
      if (v32 == v31)
      {
        uint64_t v35 = 0;
      }
      else
      {
        uint64_t v34 = 0;
        if (v33 <= 1) {
          uint64_t v35 = 1;
        }
        else {
          uint64_t v35 = v32 - v31;
        }
        while (v34 != 6)
        {
          if (aMotion[v34] != *(unsigned char *)(v31 + v34)) {
            goto LABEL_163;
          }
          if (v35 == ++v34) {
            goto LABEL_70;
          }
        }
        uint64_t v35 = 6;
      }
LABEL_70:
      if (v35 != v33) {
        goto LABEL_163;
      }
      if (!v31) {
        goto LABEL_163;
      }
      unint64_t v46 = v45 - v31;
      if (v45 == v31)
      {
        uint64_t v48 = 0;
      }
      else
      {
        uint64_t v47 = 0;
        uint64_t v48 = v46 <= 1 ? 1 : v45 - v31;
        while (v47 != 7)
        {
          if (aFrames[v47] != *(unsigned char *)(v31 + v47)) {
            goto LABEL_163;
          }
          if (v48 == ++v47) {
            goto LABEL_82;
          }
        }
        uint64_t v48 = 7;
      }
LABEL_82:
      if (v48 != v46) {
        goto LABEL_163;
      }
      if (v49 == v31) {
        goto LABEL_163;
      }
      uint64_t v50 = v49;
      __endptr[0].n128_u64[0] = 0;
      uint64_t v31 = strtol((const char *)v31, (char **)__endptr, 10);
      if (__endptr[0].n128_u64[0] != v50) {
        goto LABEL_163;
      }
      LODWORD(v23) = v31;
      if (!v31) {
        goto LABEL_163;
      }
      size_t v20 = (int *)v24;
      unint64_t v52 = v51 - v31;
      if (v51 == v31) {
        goto LABEL_97;
      }
      uint64_t v53 = 0;
      if (v52 <= 1) {
        uint64_t v54 = 1;
      }
      else {
        uint64_t v54 = v51 - v31;
      }
      while (v53 != 5)
      {
        if (aFrame[v53] != *(unsigned char *)(v31 + v53)) {
          goto LABEL_163;
        }
        if (v54 == ++v53) {
          goto LABEL_99;
        }
      }
      uint64_t v54 = 5;
      goto LABEL_99;
    }
  }
LABEL_96:
  v110.i64[0] = 0;
  long long v113 = 0u;
  *(_OWORD *)long long v114 = 0u;
  memset(__endptr, 0, sizeof(__endptr));
  unint64_t v4 = (long long *)&_os_log_internal;
  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  int v119 = 136315906;
  char v120 = "operator[]";
  __int16 v121 = 1024;
  int v122 = 468;
  __int16 v123 = 2048;
  unint64_t v124 = (unint64_t)v25;
  __int16 v125 = 2048;
  unint64_t v126 = v23;
  _os_log_send_and_compose_impl();
  uint64_t v31 = _os_crash_msg();
  __break(1u);
LABEL_97:
  uint64_t v54 = 0;
LABEL_99:
  if (v54 != v52) {
    goto LABEL_163;
  }
  unint64_t v56 = v55 - v31;
  if (v55 == v31)
  {
    uint64_t v58 = 0;
  }
  else
  {
    uint64_t v57 = 0;
    uint64_t v58 = v56 <= 1 ? 1 : v55 - v31;
    while (v57 != 5)
    {
      if (aTime_0[v57] != *(unsigned char *)(v31 + v57)) {
        goto LABEL_163;
      }
      if (v58 == ++v57) {
        goto LABEL_110;
      }
    }
    uint64_t v58 = 5;
  }
LABEL_110:
  unint64_t v59 = (unint64_t)&v103;
  if (v58 != v56) {
    goto LABEL_163;
  }
  if (v60 == v31) {
    goto LABEL_163;
  }
  uint64_t v61 = v60;
  __endptr[0].n128_u64[0] = 0;
  float v103 = strtof((const char *)v31, (char **)__endptr);
  if (__endptr[0].n128_u64[0] != v61) {
    goto LABEL_163;
  }
  if (!v31) {
    goto LABEL_163;
  }
  uint64_t v93 = (int)v23;
  if ((int)v23 >= 1)
  {
    unint64_t v96 = 0;
    BOOL v94 = 0;
    uint64_t v62 = v19 <= 1 ? 1 : v19;
    uint64_t v91 = v23;
    uint64_t v92 = v62;
    float32x4_t v95 = (float32x4_t)vdupq_n_s32(0x3C8EFA35u);
    unint64_t v63 = v19;
    while (1)
    {
      uint64_t v64 = (unint64_t *)v109;
      if ((unint64_t)v109 <= v96) {
        goto LABEL_167;
      }
      uint64_t v65 = *((void *)&v109 + 1);
      unint64_t v59 = *((void *)&v109 + 1) + 24 * v96;
      if (v63) {
        break;
      }
LABEL_151:
      if (v31)
      {
        BOOL v94 = (uint64_t)++v96 >= v93;
        if (v96 != v91) {
          continue;
        }
      }
      goto LABEL_153;
    }
    unint64_t v59 = 0;
    uint64_t v66 = v65 + 24 * v96;
    uint64_t v64 = (unint64_t *)(v66 + 8);
    id v67 = (void *)(v66 + 16);
    while (1)
    {
      unint64_t v63 = *v64;
      if (*v64 <= v59) {
        goto LABEL_165;
      }
      uint64_t v68 = &v20[16 * v59];
      *(_OWORD *)(*v67 + 48 * v59 + 32) = *((_OWORD *)v68 + 1);
      if (v59 == v19) {
        goto LABEL_166;
      }
      uint64_t v70 = *((void *)v68 + 5);
      uint64_t v69 = (unint64_t *)(v68 + 10);
      if (v70) {
        break;
      }
LABEL_149:
      if (++v59 == v92)
      {
        unint64_t v63 = v19;
        goto LABEL_151;
      }
    }
    unint64_t v71 = 0;
    while (2)
    {
      if (v72 != v31)
      {
        uint64_t v73 = v72;
        __endptr[0].n128_u64[0] = 0;
        *(float *)&uint64_t v74 = strtof((const char *)v31, (char **)__endptr);
        v98.i64[0] = v74;
        if (__endptr[0].n128_u64[0] == v73)
        {
          if (v75 != v31)
          {
            uint64_t v76 = v75;
            __endptr[0].n128_u64[0] = 0;
            *(float *)&uint64_t v77 = strtof((const char *)v31, (char **)__endptr);
            v97.i64[0] = v77;
            if (__endptr[0].n128_u64[0] == v76)
            {
              if (v78 != v31)
              {
                uint64_t v79 = v78;
                __endptr[0].n128_u64[0] = 0;
                v81.f32[0] = strtof((const char *)v31, (char **)__endptr);
                if (__endptr[0].n128_u64[0] == v79)
                {
                  unint64_t v63 = *v69;
                  if (*v69 > v71)
                  {
                    switch(*(_DWORD *)(*(void *)&v20[16 * v59 + 12] + 4 * v71))
                    {
                      case 0:
                        unint64_t v63 = *v64;
                        if (*v64 <= v59) {
                          goto LABEL_168;
                        }
                        float32x4_t v82 = v98;
                        v82.i32[1] = v97.i32[0];
                        v82.i32[2] = v81.i32[0];
                        *(float32x4_t *)(*v67 + 48 * v59 + 32) = v82;
                        goto LABEL_148;
                      case 1:
                        float32x4_t v83 = v98;
                        v83.i32[1] = v97.i32[0];
                        v83.i32[2] = v81.i32[0];
                        float32x4_t v110 = vmulq_f32(v83, v95);
                        __endptr[0] = (__n128)xmmword_23435FBB0;
                        re::convertIntrinsicEulersToQuaternions<float>((uint64_t)&v110, 1, 0, (uint64_t)__endptr, 1);
                        unint64_t v63 = *v64;
                        if (*v64 <= v59) {
                          goto LABEL_169;
                        }
                        goto LABEL_147;
                      case 2:
                        v81.i32[1] = v98.i32[0];
                        v81.i32[2] = v97.i32[0];
                        float32x4_t v110 = vmulq_f32(v81, v95);
                        __endptr[0] = (__n128)xmmword_23435FBB0;
                        re::convertIntrinsicEulersToQuaternions<float>((uint64_t)&v110, 1, 1, (uint64_t)__endptr, 1);
                        unint64_t v63 = *v64;
                        if (*v64 <= v59) {
                          goto LABEL_170;
                        }
                        goto LABEL_147;
                      case 3:
                        float32x4_t v84 = v97;
                        v84.i32[1] = v81.i32[0];
                        v84.i32[2] = v98.i32[0];
                        float32x4_t v110 = vmulq_f32(v84, v95);
                        __endptr[0] = (__n128)xmmword_23435FBB0;
                        re::convertIntrinsicEulersToQuaternions<float>((uint64_t)&v110, 1, 2, (uint64_t)__endptr, 1);
                        unint64_t v63 = *v64;
                        if (*v64 <= v59) {
                          goto LABEL_171;
                        }
                        goto LABEL_147;
                      case 4:
                        float32x4_t v85 = v98;
                        v85.i32[1] = v97.i32[0];
                        v85.i32[2] = v81.i32[0];
                        float32x4_t v110 = vmulq_f32(v85, v95);
                        __endptr[0] = (__n128)xmmword_23435FBB0;
                        re::convertIntrinsicEulersToQuaternions<float>((uint64_t)&v110, 1, 3, (uint64_t)__endptr, 1);
                        unint64_t v63 = *v64;
                        if (*v64 <= v59) {
                          goto LABEL_172;
                        }
                        goto LABEL_147;
                      case 5:
                        float32x4_t v86 = v97;
                        v86.i32[1] = v98.i32[0];
                        v86.i32[2] = v81.i32[0];
                        float32x4_t v110 = vmulq_f32(v86, v95);
                        __endptr[0] = (__n128)xmmword_23435FBB0;
                        re::convertIntrinsicEulersToQuaternions<float>((uint64_t)&v110, 1, 4, (uint64_t)__endptr, 1);
                        unint64_t v63 = *v64;
                        if (*v64 <= v59) {
                          goto LABEL_173;
                        }
                        goto LABEL_147;
                      case 6:
                        v81.i32[1] = v97.i32[0];
                        v81.i32[2] = v98.i32[0];
                        float32x4_t v110 = vmulq_f32(v81, v95);
                        __endptr[0] = (__n128)xmmword_23435FBB0;
                        re::convertIntrinsicEulersToQuaternions<float>((uint64_t)&v110, 1, 5, (uint64_t)__endptr, 1);
                        unint64_t v63 = *v64;
                        if (*v64 <= v59) {
                          goto LABEL_174;
                        }
LABEL_147:
                        unint64_t v87 = __endptr[0].n128_u64[1];
                        uint64_t v88 = *v67 + 48 * v59;
                        *(void *)(v88 + 16) = __endptr[0].n128_u64[0];
                        *(void *)(v88 + 24) = v87;
LABEL_148:
                        if (++v71 >= *v69) {
                          goto LABEL_149;
                        }
                        continue;
                      default:
                        goto LABEL_175;
                    }
                  }
                  v110.i64[0] = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 476;
                  __int16 v123 = 2048;
                  unint64_t v124 = v71;
                  __int16 v125 = 2048;
                  unint64_t v126 = v63;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_165:
                  v110.i64[0] = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 468;
                  __int16 v123 = 2048;
                  unint64_t v124 = v59;
                  __int16 v125 = 2048;
                  unint64_t v126 = v63;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_166:
                  v110.i64[0] = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 797;
                  __int16 v123 = 2048;
                  unint64_t v124 = v19;
                  __int16 v125 = 2048;
                  unint64_t v126 = v19;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_167:
                  v110.i64[0] = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 468;
                  __int16 v123 = 2048;
                  unint64_t v124 = v96;
                  __int16 v125 = 2048;
                  unint64_t v126 = (unint64_t)v64;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_168:
                  v110.i64[0] = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 468;
                  __int16 v123 = 2048;
                  unint64_t v124 = v59;
                  __int16 v125 = 2048;
                  unint64_t v126 = v63;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_169:
                  uint64_t v111 = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 468;
                  __int16 v123 = 2048;
                  unint64_t v124 = v59;
                  __int16 v125 = 2048;
                  unint64_t v126 = v63;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_170:
                  uint64_t v111 = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 468;
                  __int16 v123 = 2048;
                  unint64_t v124 = v59;
                  __int16 v125 = 2048;
                  unint64_t v126 = v63;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_171:
                  uint64_t v111 = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 468;
                  __int16 v123 = 2048;
                  unint64_t v124 = v59;
                  __int16 v125 = 2048;
                  unint64_t v126 = v63;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_172:
                  uint64_t v111 = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 468;
                  __int16 v123 = 2048;
                  unint64_t v124 = v59;
                  __int16 v125 = 2048;
                  unint64_t v126 = v63;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_173:
                  uint64_t v111 = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 468;
                  __int16 v123 = 2048;
                  unint64_t v124 = v59;
                  __int16 v125 = 2048;
                  unint64_t v126 = v63;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_174:
                  uint64_t v111 = 0;
                  long long v113 = 0u;
                  *(_OWORD *)long long v114 = 0u;
                  memset(__endptr, 0, sizeof(__endptr));
                  os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  int v119 = 136315906;
                  char v120 = "operator[]";
                  __int16 v121 = 1024;
                  int v122 = 468;
                  __int16 v123 = 2048;
                  unint64_t v124 = v59;
                  __int16 v125 = 2048;
                  unint64_t v126 = v63;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_175:
                  re::internal::assertLog((re::internal *)4, v80, *(double *)v81.i64, "assertion failure: '%s' (%s:line %i) Invalid Joint Channel value.", "!\"Unreachable code\"", "parseFrameNumbersLine", 507);
                  _os_crash();
                  __break(1u);
                  JUMPOUT(0x233D33534);
                }
              }
            }
          }
        }
      }
      break;
    }
LABEL_153:
    if (!v94)
    {
LABEL_163:
      uint64_t v36 = "Unable to parse motion frames.";
      goto LABEL_48;
    }
  }
  re::types::Ok<re::AnimationBVH>::Ok((uint64_t)__endptr, &v103);
  *(unsigned char *)a2 = 1;
  *(_DWORD *)(a2 + 8) = __endptr[0].n128_u32[0];
  unint64_t v89 = __endptr[1].n128_u64[0];
  *(void *)(a2 + 16) = __endptr[0].n128_u64[1];
  *(void *)(a2 + 24) = v89;
  *(__n128 *)(a2 + 32) = *(__n128 *)((char *)&__endptr[1] + 8);
  memset(&__endptr[0].n128_i8[8], 0, 32);
  *(void *)(a2 + 48) = __endptr[2].n128_u64[1];
  __endptr[2].n128_u64[1] = 0;
  *(_OWORD *)(a2 + 56) = v113;
  long long v113 = 0u;
  *(void *)(a2 + 72) = *(void *)v114;
  *(_OWORD *)(a2 + 80) = *(_OWORD *)&v114[8];
  memset(v114, 0, sizeof(v114));
  uint64_t v90 = v116;
  *(void *)(a2 + 96) = v115;
  *(void *)(a2 + 104) = v90;
  uint64_t v115 = 0;
  uint64_t v116 = 0;
  re::FixedArray<re::FixedArray<float>>::deinit(&v114[16]);
  if (*((void *)&v113 + 1))
  {
    if (*(void *)v114)
    {
      (*(void (**)(void, void))(**((void **)&v113 + 1) + 40))(*((void *)&v113 + 1), *(void *)&v114[8]);
      *(_OWORD *)long long v114 = 0uLL;
    }
    *((void *)&v113 + 1) = 0;
  }
  if (__endptr[2].n128_u64[0])
  {
    if (__endptr[2].n128_u64[1])
    {
      (*(void (**)(unint64_t, void))(*(void *)__endptr[2].n128_u64[0] + 40))(__endptr[2].n128_u64[0], v113);
      __endptr[2].n128_u64[1] = 0;
      *(void *)&long long v113 = 0;
    }
    __endptr[2].n128_u64[0] = 0;
  }
  re::FixedArray<re::StringID>::deinit(&__endptr[0].n128_u64[1]);
LABEL_49:
  uint64_t v39 = v99[0];
  if (v99[0])
  {
    long long v40 = v102;
    if (v102)
    {
      if (v100)
      {
        unint64_t v41 = v100 << 6;
        uint64_t v42 = v102;
        do
        {
          uint64_t v43 = *((void *)v42 + 4);
          if (v43)
          {
            if (*((void *)v42 + 5))
            {
              (*(void (**)(uint64_t, void))(*(void *)v43 + 40))(v43, *((void *)v42 + 6));
              *((void *)v42 + 5) = 0;
              *((void *)v42 + 6) = 0;
            }
            *((void *)v42 + 4) = 0;
          }
          re::StringID::destroyString(v42);
          uint64_t v42 = (re::StringID *)((char *)v42 + 64);
          v41 -= 64;
        }
        while (v41);
      }
      (*(void (**)(uint64_t, re::StringID *))(*(void *)v39 + 40))(v39, v40);
    }
  }
  re::FixedArray<re::FixedArray<float>>::deinit((void *)&v108 + 1);
  if ((void)v107)
  {
    if (*((void *)&v107 + 1))
    {
      (*(void (**)(void, void))(*(void *)v107 + 40))(v107, v108);
      *((void *)&v107 + 1) = 0;
      *(void *)&long long v108 = 0;
    }
    *(void *)&long long v107 = 0;
  }
  if (*((void *)&v105 + 1))
  {
    if ((void)v106)
    {
      (*(void (**)(void, void))(**((void **)&v105 + 1) + 40))(*((void *)&v105 + 1), *((void *)&v106 + 1));
      long long v106 = 0uLL;
    }
    *((void *)&v105 + 1) = 0;
  }
  return re::FixedArray<re::StringID>::deinit(v4);
}

__n128 re::DynamicArray<re::anonymous namespace'::BVHJointData>::add(uint64_t a1, __n128 *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(void *)a1)
    {
      uint64_t v13 = 2 * v4;
      BOOL v14 = v4 == 0;
      unint64_t v15 = 8;
      if (!v14) {
        unint64_t v15 = v13;
      }
      if (v15 <= v6) {
        unint64_t v16 = v6;
      }
      else {
        unint64_t v16 = v15;
      }
    }
    else
    {
      ++*(_DWORD *)(a1 + 24);
    }
  }
  uint64_t v8 = (__n128 *)(*(void *)(a1 + 32) + (*(void *)(a1 + 16) << 6));
  unint64_t v9 = a2->n128_u64[0];
  v8->n128_u64[0] = v8->n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | a2->n128_u64[0] & 1;
  v8->n128_u64[0] = a2->n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | v9 & 1;
  v8->n128_u64[1] = a2->n128_u64[1];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = (unint64_t)"";
  __n128 result = a2[1];
  v8[1] = result;
  v8[2].n128_u64[1] = 0;
  v8[3].n128_u64[0] = 0;
  v8[2].n128_u64[0] = 0;
  unint64_t v11 = a2[2].n128_u64[1];
  v8[2].n128_u64[0] = a2[2].n128_u64[0];
  v8[2].n128_u64[1] = v11;
  a2[2].n128_u64[0] = 0;
  a2[2].n128_u64[1] = 0;
  unint64_t v12 = v8[3].n128_u64[0];
  v8[3].n128_u64[0] = a2[3].n128_u64[0];
  a2[3].n128_u64[0] = v12;
  v8[3].n128_u32[2] = a2[3].n128_u32[2];
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::anonymous namespace'::parseJointDescription(re::_anonymous_namespace_::TokenStream *a1, int a2, uint64_t a3)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  {
    return 0;
  }
  uint64_t v6 = *(void *)(a3 + 32);
  uint64_t v7 = *(void *)(a3 + 16);
  unint64_t v10 = v9 - NextToken;
  if (v9 == NextToken)
  {
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = v10 <= 1 ? 1 : v9 - NextToken;
    while (v11 != 8)
    {
      if (aChannels[v11] != NextToken[v11]) {
        return 0;
      }
      if (v12 == ++v11) {
        goto LABEL_13;
      }
    }
    uint64_t v12 = 8;
  }
LABEL_13:
  if (v12 != v10) {
    return 0;
  }
  if (v14 == v13) {
    return 0;
  }
  unint64_t v15 = v14;
  __endptr[0].n128_u64[0] = 0;
  unint64_t v16 = (_anonymous_namespace_ *)strtol(v13, (char **)__endptr, 10);
  if ((char *)__endptr[0].n128_u64[0] != v15) {
    return 0;
  }
  unsigned int v17 = v16;
  if ((int)v16 < 1) {
    return 0;
  }
  unint64_t v18 = v16 / 3uLL;
  if (v16 % 3) {
    return 0;
  }
  uint64_t v19 = v7 - 1;
  unint64_t v20 = v6 + (v19 << 6) + 32;
  uint64_t v21 = v6 + (v19 << 6);
  *(void *)(v21 + 40) = v18;
  uint64_t v22 = (unint64_t *)(v21 + 40);
  if (v17 > 2)
  {
    uint64_t v38 = 4 * v18;
    *(void *)(v21 + 48) = v39;
    unint64_t v41 = (void *)(v21 + 48);
    if (v39)
    {
      uint64_t v42 = v39;
      if (v17 - 3 >= 3)
      {
        bzero(v39, v38 - 4);
        uint64_t v42 = (_DWORD *)((char *)v42 + v38 - 4);
      }
      unint64_t v20 = 0;
      *uint64_t v42 = 0;
      if (v18 <= 1) {
        uint64_t v43 = 1;
      }
      else {
        uint64_t v43 = v18;
      }
      uint64_t v71 = v43;
      while (1)
      {
        size_t v46 = v45 - (void)v44;
        if ((unint64_t)(v45 - (void)v44 + 1) > 0x20) {
          return 0;
        }
        memcpy(__endptr, v44, v46);
        __endptr[0].n128_u8[v46] = 0;
        size_t v49 = v48 - (void)v47;
        if ((unint64_t)(v48 - (void)v47 + 1) > 0x20) {
          return 0;
        }
        memcpy(&v73, v47, v49);
        *((unsigned char *)&v73 + v49) = 0;
        size_t v52 = v51 - (void)v50;
        if ((unint64_t)(v51 - (void)v50 + 1) > 0x20) {
          return 0;
        }
        memcpy(v76, v50, v52);
        v76[v52] = 0;
        unint64_t v53 = *v22;
        if (*v22 <= v20) {
          break;
        }
        uint64_t v54 = 0;
        *(_DWORD *)(*v41 + 4 * v20) = -1;
        unint64_t v18 = (unint64_t)off_264BE80D8;
        while (strcmp((const char *)__endptr, *(const char **)(v18 - 16))
             || strcmp((const char *)&v73, *(const char **)(v18 - 8))
             || strcmp(v76, *(const char **)v18))
        {
          ++v54;
          v18 += 24;
          if (v54 == 7) {
            goto LABEL_66;
          }
        }
        unint64_t v18 = *v22;
        if (*v22 <= v20) {
          goto LABEL_116;
        }
        *(_DWORD *)(*v41 + 4 * v20) = v54;
LABEL_66:
        unint64_t v53 = *v22;
        if (*v22 <= v20) {
          goto LABEL_114;
        }
        if (*(_DWORD *)(*v41 + 4 * v20) == -1) {
          return 0;
        }
        if (++v20 == v71) {
          goto LABEL_19;
        }
      }
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v85 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v77 = 136315906;
      uint64_t v78 = "operator[]";
      __int16 v79 = 1024;
      int v80 = 468;
      __int16 v81 = 2048;
      unint64_t v82 = v20;
      __int16 v83 = 2048;
      unint64_t v84 = v53;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_114:
      long long v88 = 0u;
      long long v89 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v85 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v77 = 136315906;
      uint64_t v78 = "operator[]";
      __int16 v79 = 1024;
      int v80 = 468;
      __int16 v81 = 2048;
      unint64_t v82 = v20;
      __int16 v83 = 2048;
      unint64_t v84 = v53;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, v40, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
LABEL_116:
    long long v88 = 0u;
    long long v89 = 0u;
    long long v86 = 0u;
    long long v87 = 0u;
    long long v85 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v77 = 136315906;
    uint64_t v78 = "operator[]";
    __int16 v79 = 1024;
    int v80 = 468;
    __int16 v81 = 2048;
    unint64_t v82 = v20;
    __int16 v83 = 2048;
    unint64_t v84 = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_19:
    return 0;
  while (1)
  {
    unint64_t v25 = v24 - v23;
    if (v24 == v23)
    {
      uint64_t v27 = 0;
    }
    else
    {
      uint64_t v26 = 0;
      uint64_t v27 = v25 <= 1 ? 1 : v24 - v23;
      while (v26 != 5)
      {
        if (aJoint_0[v26] != v23[v26]) {
          goto LABEL_72;
        }
        if (v27 == ++v26) {
          goto LABEL_30;
        }
      }
      uint64_t v27 = 5;
    }
LABEL_30:
    if (v27 != v25) {
      break;
    }
    __endptr[0].n128_u64[0] = 0;
    __endptr[0].n128_u64[1] = (unint64_t)"";
    __endptr[1] = 0u;
    long long v73 = 0u;
    uint64_t v74 = 0;
    int v75 = a2;
    if ((void)v73)
    {
      if (*((void *)&v73 + 1))
      {
        (*(void (**)(__n128))(*(void *)v73 + 40))(v28);
        *((void *)&v73 + 1) = 0;
        uint64_t v74 = 0;
      }
      *(void *)&long long v73 = 0;
    }
    re::StringID::destroyString((re::StringID *)__endptr);
    uint64_t v29 = *(void *)(a3 + 32);
    uint64_t v30 = *(void *)(a3 + 16);
    unint64_t v33 = v32 - v31;
    if (v32 == v31)
    {
      uint64_t v35 = 0;
    }
    else
    {
      uint64_t v34 = 0;
      if (v33 <= 1) {
        uint64_t v35 = 1;
      }
      else {
        uint64_t v35 = v32 - v31;
      }
      while (v34 != 5)
      {
        if (aJoint_0[v34] != v31[v34]) {
          return 0;
        }
        if (v35 == ++v34) {
          goto LABEL_45;
        }
      }
      uint64_t v35 = 5;
    }
LABEL_45:
    if (v35 == v33)
    {
      {
        {
          continue;
        }
      }
    }
    return 0;
  }
LABEL_72:
  unint64_t v57 = v56 - v55;
  if (v56 == v55)
  {
    uint64_t v59 = 0;
  }
  else
  {
    uint64_t v58 = 0;
    uint64_t v59 = v57 <= 1 ? 1 : v56 - v55;
    while (v58 != 3)
    {
      if (aEnd_0[v58] != v55[v58]) {
        goto LABEL_109;
      }
      if (v59 == ++v58) {
        goto LABEL_82;
      }
    }
    uint64_t v59 = 3;
  }
LABEL_82:
  if (v59 == v57)
  {
    unint64_t v62 = v61 - v60;
    if (v61 == v60)
    {
      uint64_t v64 = 0;
    }
    else
    {
      uint64_t v63 = 0;
      uint64_t v64 = v62 <= 1 ? 1 : v61 - v60;
      while (v63 != 3)
      {
        if (aEnd_0[v63] != v60[v63]) {
          return 0;
        }
        if (v64 == ++v63) {
          goto LABEL_93;
        }
      }
      uint64_t v64 = 3;
    }
LABEL_93:
    if (v64 != v62) {
      return 0;
    }
    unint64_t v67 = v66 - v65;
    if (v66 == v65)
    {
      uint64_t v69 = 0;
    }
    else
    {
      uint64_t v68 = 0;
      uint64_t v69 = v67 <= 1 ? 1 : v66 - v65;
      while (v68 != 4)
      {
        if (aSite[v68] != v65[v68]) {
          return 0;
        }
        if (v69 == ++v68) {
          goto LABEL_104;
        }
      }
      uint64_t v69 = 4;
    }
LABEL_104:
    if (v69 != v67
    {
      return 0;
    }
  }
LABEL_109:
}

char *re::anonymous namespace'::TokenStream::getNextToken(re::_anonymous_namespace_::TokenStream *this, char a2)
{
  unint64_t v4 = (char *)*((void *)this + 65);
  unint64_t v5 = (char *)*((void *)this + 66);
  if (v4 < v5)
  {
    uint64_t v6 = MEMORY[0x263EF8318];
    do
    {
      unsigned int v7 = *v4;
      if ((v7 & 0x80000000) != 0)
      {
        int v8 = __maskrune(v7, 0x4000uLL);
        unint64_t v5 = (char *)*((void *)this + 66);
        if (!v8) {
          break;
        }
      }
      else if ((*(_DWORD *)(v6 + 4 * v7 + 60) & 0x4000) == 0)
      {
        break;
      }
      ++v4;
    }
    while (v4 < v5);
  }
  if (v4 >= v5)
  {
    unint64_t v10 = v4;
  }
  else
  {
    uint64_t v9 = MEMORY[0x263EF8318];
    unint64_t v10 = v4;
    do
    {
      unsigned int v11 = *v10;
      if ((v11 & 0x80000000) != 0)
      {
        int v12 = __maskrune(v11, 0x4000uLL);
        unint64_t v5 = (char *)*((void *)this + 66);
        if (v12) {
          break;
        }
      }
      else if ((*(_DWORD *)(v9 + 4 * v11 + 60) & 0x4000) != 0)
      {
        break;
      }
      ++v10;
    }
    while (v10 < v5);
  }
  if (v10 == v5)
  {
    unint64_t v4 = (char *)*((void *)this + 65);
    unint64_t v13 = *((void *)this + 66);
    uint64_t v14 = MEMORY[0x263EF8318];
    while ((unint64_t)v4 < v13)
    {
      unsigned int v15 = *v4;
      if ((v15 & 0x80000000) != 0)
      {
        int v16 = __maskrune(v15, 0x4000uLL);
        unint64_t v13 = *((void *)this + 66);
        if (!v16) {
          break;
        }
      }
      else if ((*(_DWORD *)(v14 + 4 * v15 + 60) & 0x4000) == 0)
      {
        break;
      }
      ++v4;
    }
    unint64_t v10 = v4;
    if ((unint64_t)v4 < v13)
    {
      do
      {
        unsigned int v17 = *v10;
        if ((v17 & 0x80000000) != 0)
        {
          if (__maskrune(v17, 0x4000uLL)) {
            break;
          }
        }
        else if ((*(_DWORD *)(v14 + 4 * v17 + 60) & 0x4000) != 0)
        {
          break;
        }
        ++v10;
      }
      while ((unint64_t)v10 < *((void *)this + 66));
    }
  }
  if ((a2 & 1) == 0) {
    *((void *)this + 65) = v10;
  }
  return v4;
}

uint64_t re::anonymous namespace'::TokenStream::endLine(re::_anonymous_namespace_::TokenStream *this)
{
  uint64_t v2 = (unsigned __int8 *)*((void *)this + 65);
  uint64_t v3 = MEMORY[0x263EF8318];
  do
  {
    while (1)
    {
      unint64_t v4 = (char *)*((void *)this + 66);
      if (v2 >= (unsigned __int8 *)v4) {
        break;
      }
      unsigned int v5 = (char)*v2;
      if ((v5 & 0x80000000) != 0)
      {
        int v7 = __maskrune(v5, 0x4000uLL);
        uint64_t v2 = (unsigned __int8 *)*((void *)this + 65);
        if (v7) {
          goto LABEL_5;
        }
LABEL_8:
        unint64_t v4 = (char *)*((void *)this + 66);
        break;
      }
      if ((*(_DWORD *)(v3 + 4 * v5 + 60) & 0x4000) == 0) {
        goto LABEL_8;
      }
LABEL_5:
      int v6 = *v2++;
      *((void *)this + 65) = v2;
      if (v6 == 10) {
        return 1;
      }
    }
    if (v2 != (unsigned __int8 *)v4) {
      break;
    }
    uint64_t v2 = (unsigned __int8 *)*((void *)this + 65);
  }
  while ((unint64_t)v2 < *((void *)this + 66));
  return 0;
}

uint64_t re::anonymous namespace'::TokenStream::readFromStream(re::_anonymous_namespace_::TokenStream *this)
{
  uint64_t v2 = *((void *)this + 66);
  uint64_t v3 = (char *)*((void *)this + 65);
  uint64_t v4 = v2 - (void)v3;
  unsigned int v5 = (char *)this + 8;
  if (v3 != (char *)this + 8)
  {
    memmove((char *)this + 8, v3, v2 - (void)v3);
    *((void *)this + 65) = v5;
    *((void *)this + 66) = &v5[v4];
  }
  uint64_t result = (*(uint64_t (**)(void, char *, uint64_t))(**(void **)this + 16))(*(void *)this, &v5[v4], 512 - v4);
  *((void *)this + 66) += result;
  return result;
}

void *re::DynamicArray<re::anonymous namespace'::BVHJointData>::setCapacity(void *result, unint64_t a2)
{
  uint64_t v3 = result[1];
  if (v3 != a2)
  {
    unsigned int v5 = result;
    if (result[2] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 58)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 64, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          unint64_t v2 = a2 << 6;
          uint64_t result = (void *)(*(uint64_t (**)(void *, unint64_t, uint64_t))(*result + 32))(result, a2 << 6, 16);
          if (result)
          {
            int v7 = result;
            if (!v5[1]) {
              goto LABEL_18;
            }
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(void *)(*v5 + 8));
        uint64_t result = (void *)_os_crash();
        __break(1u);
        return result;
      }
      int v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      int v8 = (uint64_t *)v5[4];
      uint64_t v9 = v5[2];
      if (v9)
      {
        uint64_t v10 = v9 << 6;
        unsigned int v11 = v7;
        do
        {
          uint64_t v12 = *v8;
          *unsigned int v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *unsigned int v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *int v8 = 0;
          v8[1] = (uint64_t)"";
          *((_OWORD *)v11 + 1) = *((_OWORD *)v8 + 1);
          v11[5] = 0;
          v11[6] = 0;
          v11[4] = 0;
          uint64_t v13 = v8[5];
          v11[4] = v8[4];
          v11[5] = v13;
          void v8[4] = 0;
          void v8[5] = 0;
          uint64_t v14 = v11[6];
          v11[6] = v8[6];
          v8[6] = v14;
          *((_DWORD *)v11 + 14) = *((_DWORD *)v8 + 14);
          if (v8[4]) {
            void v8[4] = 0;
          }
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 8;
          v11 += 8;
          v10 -= 64;
        }
        while (v10);
        int v8 = (uint64_t *)v5[4];
      }
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(*(void *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t re::anonymous namespace'::Token::getSID(re::_anonymous_namespace_::Token *this, re::StringID *a2, uint64_t *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  size_t v5 = a2 - this;
  if (a2 == this) {
    return a2 != this;
  }
  if (v5 + 1 < 0x81)
  {
    int v7 = (_anonymous_namespace_ *)memcpy(__dst, this, v5);
    __dst[v5] = 0;
    uint64_t v14 = 0;
    unsigned int v15 = "";
    size_t v8 = strlen(__dst);
    uint64_t v9 = v14;
    uint64_t v10 = v15;
    uint64_t v14 = 0;
    unsigned int v15 = "";
    uint64_t v11 = *a3;
    uint64_t v12 = a3[1];
    *a3 = v9;
    a3[1] = (uint64_t)v10;
    v16[0] = v9 & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
    v16[1] = v12;
    re::StringID::destroyString((re::StringID *)v16);
    re::StringID::destroyString((re::StringID *)&v14);
    return a2 != this;
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "getString(buffer, sizeof(buffer))", "getSID", 156);
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::anonymous namespace'::parseLeftBraceLine(re::_anonymous_namespace_::TokenStream *a1)
{
  if (v3 == NextToken)
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (*NextToken != 123) {
      return 0;
    }
    uint64_t v4 = 1;
  }
  if (v4 != v3 - NextToken) {
    return 0;
  }
}

uint64_t re::anonymous namespace'::parseOffsetLine(re::_anonymous_namespace_::TokenStream *a1, float *a2)
{
  unint64_t v6 = v5 - NextToken;
  if (v5 == NextToken)
  {
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v7 = 0;
    if (v6 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v5 - NextToken;
    }
    while (v7 != 6)
    {
      if (aOffset_0[v7] != NextToken[v7]) {
        return 0;
      }
      if (v8 == ++v7) {
        goto LABEL_11;
      }
    }
    uint64_t v8 = 6;
  }
  if (v8 != v6) {
    return 0;
  }
  if (v10 == v9) {
    return 0;
  }
  uint64_t v11 = v10;
  uint64_t v19 = 0;
  *a2 = strtof(v9, &v19);
  if (v19 != v11) {
    return 0;
  }
  if (v14 == v13) {
    return 0;
  }
LABEL_11:
  unsigned int v15 = v14;
  uint64_t v19 = 0;
  a2[1] = strtof(v13, &v19);
  if (v19 == v15
    && (uint64_t v18 = v17, v19 = 0, a2[2] = strtof(v16, &v19), v19 == v18))
  {
  }
  else
  {
    return 0;
  }
}

uint64_t re::anonymous namespace'::parseRightBraceLine(re::_anonymous_namespace_::TokenStream *a1)
{
  if (v3 == NextToken)
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (*NextToken != 125) {
      return 0;
    }
    uint64_t v4 = 1;
  }
  if (v4 != v3 - NextToken) {
    return 0;
  }
}

uint64_t re::types::Ok<re::AnimationBVH>::Ok(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = (uint64_t)(a2 + 20);
  *(_DWORD *)a1 = *a2;
  size_t v5 = (uint64_t *)(a1 + 80);
  re::FixedArray<re::StringID>::FixedArray((unint64_t *)(a1 + 8), (uint64_t)(a2 + 2));
  re::FixedArray<unsigned int>::FixedArray((uint64_t *)(a1 + 32), (uint64_t)(a2 + 8));
  re::FixedArray<re::GenericSRT<float>>::FixedArray((void *)(a1 + 56), (uint64_t)(a2 + 14));
  re::FixedArray<re::FixedArray<re::GenericSRT<float>>>::FixedArray(v5, v4);
  return a1;
}

BOOL re::fillStreamFP16(re *this, const re::GeomAttribute *a2, char *a3, uint64_t a4, float a5)
{
  unsigned int v7 = a3;
  uint64_t v10 = (_WORD *)((char *)a2 + a4);
  switch(*((unsigned char *)this + 17))
  {
    case 4:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        return 1;
      }
      uint64_t v11 = (float *)re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)this, 0);
      unsigned int v12 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v12) {
        return 1;
      }
      _S1 = *v11;
      __asm
      {
        FCVT            H0, S1
        FCVT            S2, H0
      }
      float v20 = vabds_f32(*v11, _S2);
      if (*v11 != _S2 && v20 > a5) {
        return 0;
      }
      unint64_t v22 = 0;
      unint64_t v23 = v12;
      break;
    case 5:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        return 1;
      }
      __n128 v28 = (double *)re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)this, 0);
      unsigned int v29 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v29) {
        return 1;
      }
      _D1 = *v28;
      __asm { FCVT            H0, D1 }
      *(float *)&_D1 = *v28;
      __asm { FCVT            S2, H0 }
      float v33 = vabds_f32(*(float *)&_D1, _S2);
      if (*(float *)&_D1 != _S2 && v33 > a5) {
        return 0;
      }
      unint64_t v22 = 0;
      unint64_t v23 = v29;
      do
      {
        *uint64_t v10 = _H0;
        if (v29 - 1 == v22) {
          goto LABEL_55;
        }
        uint64_t v10 = (_WORD *)((char *)v10 + v7);
        _D1 = v28[v22 + 1];
        __asm { FCVT            H0, D1 }
        *(float *)&_D1 = _D1;
        __asm { FCVT            S2, H0 }
        float v37 = vabds_f32(*(float *)&_D1, _S2);
        ++v22;
      }
      while (*(float *)&_D1 == _S2 || v37 <= a5);
      return v22 >= v23;
    case 6:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        return 1;
      }
      uint64_t v39 = (float32x2_t *)re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)this, 0);
      unsigned int v40 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v40) {
        return 1;
      }
      uint64_t v42 = 0;
      BOOL v43 = 0;
      int v44 = (_WORD *)((char *)a2 + a4 + 2);
      do
      {
        _D1.i32[0] = v39->i32[0];
        __asm { FCVT            H1, S1 }
        *(v44 - 1) = _D1.i16[0];
        _S2 = v39->i32[1];
        __asm { FCVT            H2, S2 }
        *int v44 = _S2;
        _D1.i16[1] = _S2;
        float32x2_t v46 = vsub_f32(*v39, (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(_D1));
        _D1 = (float16x4_t)vmul_f32(v46, v46);
        if (vaddv_f32((float32x2_t)_D1) > (float)(a5 * a5)) {
          break;
        }
        BOOL v43 = ++v42 >= (unint64_t)v40;
        ++v39;
        int v44 = (_WORD *)((char *)v44 + v7);
      }
      while (v40 != v42);
      return v43;
    case 7:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        return 1;
      }
      uint64_t v47 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)this, 0);
      unsigned int v48 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v48) {
        return 1;
      }
      unint64_t v49 = 0;
      BOOL v43 = 0;
      uint64_t v50 = v47;
      do
      {
        uint64_t v51 = 0;
        float32x4_t v66 = 0uLL;
        do
        {
          _S2 = *(_DWORD *)(v50 + 4 * v51);
          __asm
          {
            FCVT            H2, S2
            FCVT            S3, H2
          }
          v66.i32[v51] = _S3;
          v10[v51++] = _S2;
        }
        while (v51 != 3);
        float32x4_t v54 = vsubq_f32(*(float32x4_t *)(v47 + 16 * v49), v66);
        float32x4_t v55 = vmulq_f32(v54, v54);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 2), vaddq_f32(v55, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 1))).f32[0] > (float)(a5 * a5))break; {
        ++v49;
        }
        uint64_t v10 = (_WORD *)((char *)v10 + v7);
        v50 += 16;
        BOOL v43 = v49 >= v48;
      }
      while (v49 != v48);
      return v43;
    case 8:
      if ((*(unsigned int (**)(re *))(*(void *)this + 16))(this)
        && (uint64_t v56 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)this, 0),
            (unsigned int v57 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this)) != 0))
      {
        unint64_t v58 = 0;
        BOOL v43 = 0;
        uint64_t v59 = v56;
        do
        {
          uint64_t v60 = 0;
          float32x4_t v66 = 0uLL;
          do
          {
            _S1 = *(_DWORD *)(v59 + 4 * v60);
            __asm
            {
              FCVT            H1, S1
              FCVT            S2, H1
            }
            v66.i32[v60] = _S2;
            v10[v60++] = _S1;
          }
          while (v60 != 4);
          float32x4_t v63 = vsubq_f32(*(float32x4_t *)(v56 + 16 * v58), v66);
          int8x16_t v64 = (int8x16_t)vmulq_f32(v63, v63);
          if (vaddv_f32(vadd_f32(*(float32x2_t *)v64.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v64, v64, 8uLL))) > (float)(a5 * a5)) {
            break;
          }
          ++v58;
          uint64_t v10 = (_WORD *)((char *)v10 + v7);
          v59 += 16;
          BOOL v43 = v58 >= v57;
        }
        while (v58 != v57);
      }
      else
      {
        return 1;
      }
      return v43;
    default:
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Attempt to convert a non-numeric type into a half-float stream.", "!\"Unreachable code\"", "fillStreamFP16", 215);
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D34DA0);
  }
  while (1)
  {
    *uint64_t v10 = _H0;
    if (v12 - 1 == v22) {
      break;
    }
    uint64_t v10 = (_WORD *)((char *)v10 + v7);
    _S1 = v11[v22 + 1];
    __asm
    {
      FCVT            H0, S1
      FCVT            S2, H0
    }
    float v26 = vabds_f32(_S1, _S2);
    ++v22;
    if (_S1 != _S2 && v26 > a5) {
      return v22 >= v23;
    }
  }
LABEL_55:
  unint64_t v22 = v23;
  return v22 >= v23;
}

BOOL re::fillStreamUN8(re *this, const re::GeomAttribute *a2, char *a3, uint64_t a4, float a5)
{
  unsigned int v6 = a3;
  uint64_t v8 = (char *)a2 + a4;
  switch(*((unsigned char *)this + 17))
  {
    case 4:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        goto LABEL_69;
      }
      uint64_t v9 = re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)this, 0);
      unsigned int v10 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v10) {
        goto LABEL_69;
      }
      unint64_t v11 = 0;
      BOOL v12 = 0;
      do
      {
        float v13 = *(float *)(v9 + 4 * v11);
        if (v13 > 1.0) {
          float v13 = 1.0;
        }
        if (v13 >= 0.0) {
          float v14 = v13 * 255.0;
        }
        else {
          float v14 = 0.0;
        }
        unsigned int v15 = llroundf(v14);
        *uint64_t v8 = v15;
        float v16 = (float)v15 / 255.0;
        float v17 = *(float *)(v9 + 4 * v11);
        float v18 = vabds_f32(v17, v16);
        if (v17 != v16 && v18 > a5) {
          break;
        }
        ++v11;
        v8 += v6;
        BOOL v12 = v11 >= v10;
      }
      while (v10 != v11);
      break;
    case 5:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        goto LABEL_69;
      }
      uint64_t v20 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)this, 0);
      unsigned int v21 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v21) {
        goto LABEL_69;
      }
      unint64_t v22 = 0;
      BOOL v12 = 0;
      do
      {
        double v23 = *(double *)(v20 + 8 * v22);
        if (v23 > 1.0) {
          double v23 = 1.0;
        }
        if (v23 >= 0.0) {
          double v24 = v23 * 255.0;
        }
        else {
          double v24 = 0.0;
        }
        unsigned int v25 = llround(v24);
        *uint64_t v8 = v25;
        float v26 = *(double *)(v20 + 8 * v22);
        float v27 = (double)v25 / 255.0;
        float v28 = vabds_f32(v26, v27);
        if (v26 != v27 && v28 > a5) {
          break;
        }
        ++v22;
        v8 += v6;
        BOOL v12 = v22 >= v21;
      }
      while (v21 != v22);
      break;
    case 6:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        goto LABEL_69;
      }
      uint64_t v30 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)this, 0);
      unsigned int v31 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v31) {
        goto LABEL_69;
      }
      unint64_t v32 = 0;
      BOOL v12 = 0;
      do
      {
        uint64_t v33 = 0;
        uint64_t v34 = (float32x2_t *)(v30 + 8 * v32);
        v62.i64[0] = 0;
        char v35 = 1;
        do
        {
          float v36 = v34->f32[v33];
          if (v36 > 1.0) {
            float v36 = 1.0;
          }
          if (v36 >= 0.0) {
            float v37 = v36 * 255.0;
          }
          else {
            float v37 = 0.0;
          }
          unsigned int v38 = llroundf(v37);
          v8[v33] = v38;
          float v39 = (float)v38;
          LOBYTE(v38) = v35;
          v62.f32[v33] = v39 / 255.0;
          uint64_t v33 = 1;
          char v35 = 0;
        }
        while ((v38 & 1) != 0);
        float32x2_t v40 = vsub_f32(*v34, *(float32x2_t *)v62.f32);
        if (vaddv_f32(vmul_f32(v40, v40)) > (float)(a5 * a5)) {
          break;
        }
        ++v32;
        v8 += v6;
        BOOL v12 = v32 >= v31;
      }
      while (v32 != v31);
      break;
    case 7:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        goto LABEL_69;
      }
      uint64_t v41 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)this, 0);
      unsigned int v42 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v42) {
        goto LABEL_69;
      }
      unint64_t v43 = 0;
      BOOL v12 = 0;
      uint64_t v44 = v41;
      do
      {
        uint64_t v45 = 0;
        float32x4_t v62 = 0uLL;
        do
        {
          float v46 = *(float *)(v44 + 4 * v45);
          if (v46 > 1.0) {
            float v46 = 1.0;
          }
          if (v46 >= 0.0) {
            float v47 = v46 * 255.0;
          }
          else {
            float v47 = 0.0;
          }
          unsigned int v48 = llroundf(v47);
          v8[v45] = v48;
          v62.f32[v45++] = (float)v48 / 255.0;
        }
        while (v45 != 3);
        float32x4_t v49 = vsubq_f32(*(float32x4_t *)(v41 + 16 * v43), v62);
        float32x4_t v50 = vmulq_f32(v49, v49);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).f32[0] > (float)(a5 * a5))break; {
        ++v43;
        }
        v8 += v6;
        v44 += 16;
        BOOL v12 = v43 >= v42;
      }
      while (v43 != v42);
      break;
    case 8:
      if ((*(unsigned int (**)(re *))(*(void *)this + 16))(this)
        && (uint64_t v51 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)this, 0),
            (unsigned int v52 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this)) != 0))
      {
        unint64_t v53 = 0;
        BOOL v12 = 0;
        uint64_t v54 = v51;
        do
        {
          uint64_t v55 = 0;
          float32x4_t v62 = 0uLL;
          do
          {
            float v56 = *(float *)(v54 + 4 * v55);
            if (v56 > 1.0) {
              float v56 = 1.0;
            }
            if (v56 >= 0.0) {
              float v57 = v56 * 255.0;
            }
            else {
              float v57 = 0.0;
            }
            unsigned int v58 = llroundf(v57);
            v8[v55] = v58;
            v62.f32[v55++] = (float)v58 / 255.0;
          }
          while (v55 != 4);
          float32x4_t v59 = vsubq_f32(*(float32x4_t *)(v51 + 16 * v53), v62);
          int8x16_t v60 = (int8x16_t)vmulq_f32(v59, v59);
          if (vaddv_f32(vadd_f32(*(float32x2_t *)v60.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL))) > (float)(a5 * a5)) {
            break;
          }
          ++v53;
          v8 += v6;
          v54 += 16;
          BOOL v12 = v53 >= v52;
        }
        while (v53 != v52);
      }
      else
      {
LABEL_69:
        BOOL v12 = 1;
      }
      break;
    default:
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Attempt to convert a non-numeric type into a uint8 stream.", "!\"Unreachable code\"", "fillStreamUN8", 247);
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D35374);
  }
  return v12;
}

BOOL re::fillStreamSN8(re *this, const re::GeomAttribute *a2, char *a3, uint64_t a4, float a5)
{
  unsigned int v6 = a3;
  uint64_t v8 = (char *)a2 + a4;
  switch(*((unsigned char *)this + 17))
  {
    case 4:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        goto LABEL_75;
      }
      uint64_t v9 = re::internal::GeomTypedAttribute<int>::operator[]((uint64_t)this, 0);
      unsigned int v10 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v10) {
        goto LABEL_75;
      }
      unint64_t v11 = 0;
      BOOL v12 = 0;
      do
      {
        float v13 = *(float *)(v9 + 4 * v11);
        if (v13 > 1.0) {
          float v13 = 1.0;
        }
        float v14 = v13 * 127.0;
        BOOL v15 = v13 < -1.0;
        float v16 = -127.0;
        if (!v15) {
          float v16 = v14;
        }
        int v17 = llroundf(v16);
        *uint64_t v8 = v17;
        float v18 = *(float *)(v9 + 4 * v11);
        float v19 = (float)v17 / 127.0;
        if (v19 < -1.0) {
          float v19 = -1.0;
        }
        float v20 = vabds_f32(v18, v19);
        if (v18 != v19 && v20 > a5) {
          break;
        }
        ++v11;
        v8 += v6;
        BOOL v12 = v11 >= v10;
      }
      while (v10 != v11);
      break;
    case 5:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        goto LABEL_75;
      }
      uint64_t v22 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)this, 0);
      unsigned int v23 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v23) {
        goto LABEL_75;
      }
      unint64_t v24 = 0;
      BOOL v12 = 0;
      do
      {
        double v25 = *(double *)(v22 + 8 * v24);
        if (v25 > 1.0) {
          double v25 = 1.0;
        }
        if (v25 >= -1.0) {
          double v26 = v25 * 127.0;
        }
        else {
          double v26 = -127.0;
        }
        int v27 = llround(v26);
        *uint64_t v8 = v27;
        float v28 = *(double *)(v22 + 8 * v24);
        double v29 = (double)v27 / 127.0;
        if (v29 < -1.0) {
          double v29 = -1.0;
        }
        float v30 = v29;
        float v31 = vabds_f32(v28, v30);
        if (v28 != v30 && v31 > a5) {
          break;
        }
        ++v24;
        v8 += v6;
        BOOL v12 = v24 >= v23;
      }
      while (v23 != v24);
      break;
    case 6:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        goto LABEL_75;
      }
      uint64_t v33 = re::internal::GeomTypedAttribute<double>::operator[]((uint64_t)this, 0);
      unsigned int v34 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v34) {
        goto LABEL_75;
      }
      unint64_t v35 = 0;
      BOOL v12 = 0;
      for (i = v34; i != v35; BOOL v12 = v35 >= i)
      {
        uint64_t v37 = 0;
        unsigned int v38 = (float32x2_t *)(v33 + 8 * v35);
        v72.i64[0] = 0;
        char v39 = 1;
        do
        {
          float v40 = v38->f32[v37];
          if (v40 > 1.0) {
            float v40 = 1.0;
          }
          float v41 = v40 * 127.0;
          BOOL v15 = v40 < -1.0;
          float v42 = -127.0;
          if (!v15) {
            float v42 = v41;
          }
          int v43 = llroundf(v42);
          char v44 = v39;
          v8[v37] = v43;
          float v45 = (float)v43 / 127.0;
          if (v45 < -1.0) {
            float v45 = -1.0;
          }
          v72.f32[v37] = v45;
          uint64_t v37 = 1;
          char v39 = 0;
        }
        while ((v44 & 1) != 0);
        float32x2_t v46 = vsub_f32(*v38, *(float32x2_t *)v72.f32);
        if (vaddv_f32(vmul_f32(v46, v46)) > (float)(a5 * a5)) {
          break;
        }
        ++v35;
        v8 += v6;
      }
      break;
    case 7:
      if (!(*(unsigned int (**)(re *))(*(void *)this + 16))(this)) {
        goto LABEL_75;
      }
      uint64_t v47 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)this, 0);
      unsigned int v48 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this);
      if (!v48) {
        goto LABEL_75;
      }
      unint64_t v49 = 0;
      BOOL v12 = 0;
      uint64_t v50 = v47;
      do
      {
        uint64_t v51 = 0;
        float32x4_t v72 = 0uLL;
        do
        {
          float v52 = *(float *)(v50 + 4 * v51);
          if (v52 > 1.0) {
            float v52 = 1.0;
          }
          float v53 = v52 * 127.0;
          BOOL v15 = v52 < -1.0;
          float v54 = -127.0;
          if (!v15) {
            float v54 = v53;
          }
          int v55 = llroundf(v54);
          v8[v51] = v55;
          float v56 = (float)v55 / 127.0;
          if (v56 < -1.0) {
            float v56 = -1.0;
          }
          v72.f32[v51++] = v56;
        }
        while (v51 != 3);
        float32x4_t v57 = vsubq_f32(*(float32x4_t *)(v47 + 16 * v49), v72);
        float32x4_t v58 = vmulq_f32(v57, v57);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 2), vaddq_f32(v58, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 1))).f32[0] > (float)(a5 * a5))break; {
        ++v49;
        }
        v8 += v6;
        v50 += 16;
        BOOL v12 = v49 >= v48;
      }
      while (v49 != v48);
      break;
    case 8:
      if ((*(unsigned int (**)(re *))(*(void *)this + 16))(this)
        && (uint64_t v59 = re::internal::GeomTypedAttribute<re::Vector3<float>>::operator[]((uint64_t)this, 0),
            (unsigned int v60 = (*(uint64_t (**)(re *))(*(void *)this + 16))(this)) != 0))
      {
        unint64_t v61 = 0;
        BOOL v12 = 0;
        uint64_t v62 = v59;
        do
        {
          uint64_t v63 = 0;
          float32x4_t v72 = 0uLL;
          do
          {
            float v64 = *(float *)(v62 + 4 * v63);
            if (v64 > 1.0) {
              float v64 = 1.0;
            }
            float v65 = v64 * 127.0;
            BOOL v15 = v64 < -1.0;
            float v66 = -127.0;
            if (!v15) {
              float v66 = v65;
            }
            int v67 = llroundf(v66);
            v8[v63] = v67;
            float v68 = (float)v67 / 127.0;
            if (v68 < -1.0) {
              float v68 = -1.0;
            }
            v72.f32[v63++] = v68;
          }
          while (v63 != 4);
          float32x4_t v69 = vsubq_f32(*(float32x4_t *)(v59 + 16 * v61), v72);
          int8x16_t v70 = (int8x16_t)vmulq_f32(v69, v69);
          if (vaddv_f32(vadd_f32(*(float32x2_t *)v70.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v70, v70, 8uLL))) > (float)(a5 * a5)) {
            break;
          }
          ++v61;
          v8 += v6;
          v62 += 16;
          BOOL v12 = v61 >= v60;
        }
        while (v61 != v60);
      }
      else
      {
LABEL_75:
        BOOL v12 = 1;
      }
      break;
    default:
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Attempt to convert a non-numeric type into an int8 stream.", "!\"Unreachable code\"", "fillStreamSN8", 279);
      _os_crash();
      __break(1u);
      JUMPOUT(0x233D35998);
  }
  return v12;
}

id *re::ImportGraphicsResources::init(id *this, const re::ColorManager *a2, id *a3)
{
  this[3] = a2;
  if (a3)
  {
    uint64_t v4 = this;
    size_t v5 = re::ObjCObject::operator=(this, a3 + 23);
    this = re::ObjCObject::operator=(v5 + 1, (id *)a3[7] + 31);
    __int16 v6 = *((_WORD *)a3 + 140);
    *((unsigned char *)v4 + 18) = *((unsigned char *)a3 + 282);
    *((_WORD *)v4 + 8) = v6;
  }
  return this;
}

void **re::ImportGraphicsResources::deinit(re::ImportGraphicsResources *this)
{
  re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::clear((uint64_t)this + 72);
  *((void *)this + 3) = 0;
  re::ObjCObject::operator=((void **)this, 0);
  return re::ObjCObject::operator=((void **)this + 1, 0);
}

void re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::clear(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 24);
    if (v2) {
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_18, 4 * v2);
    }
    unint64_t v3 = *(unsigned int *)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = *(void *)(a1 + 16);
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          uint64_t v8 = v6 + v4;
          *(_DWORD *)uint64_t v8 = v7 & 0x7FFFFFFF;
          *(void *)(v8 + 8) = 0;

          unint64_t v3 = *(unsigned int *)(a1 + 32);
        }
        v4 += 24;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    int v9 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v9;
  }
}

void re::ImportGraphicsResources::~ImportGraphicsResources(re::ImportGraphicsResources *this)
{
}

void re::ImportGraphicsResources::getOrCreateCommandQueue(uint64_t a1@<X0>, uint64_t a2@<X1>, const char *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  uint64_t v12 = *(void *)a2 & 0x7FFFFFFFFFFFFFFFLL;
  int v9 = (id *)re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::tryGet(a1 + 72, &v12);
  if (v9)
  {
    id v10 = *v9;
  }
  else
  {
    re::ImportGraphicsResources::createCommandQueue((id *)a1, *(const re::mtl::Device **)(a2 + 8), a3, (id *)&v12);
    uint64_t v11 = *(void *)a2 & 0x7FFFFFFFFFFFFFFFLL;
    re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::addNew<re::mtl::CommandQueue&>(a1 + 72, &v11, (id *)&v12);
    id v10 = (id)v12;
    uint64_t v12 = 0;
  }
  *a4 = v10;
  os_unfair_lock_unlock(v8);
}

void re::ImportGraphicsResources::createCommandQueue(id *this@<X0>, const re::mtl::Device *a2@<X1>, const char *a3@<X2>, id *a4@<X8>)
{
  if (*this)
  {
    int v5 = (int)a3;
    id v8 = objc_msgSend(objc_msgSend(MEMORY[0x263F12818], sel_alloc), sel_init);
    int v9 = v8;
    if (v5) {
      objc_msgSend(v8, sel_setCommitSynchronously_, 1);
    }
    re::mtl::Device::makeCommandQueue(this, (uint64_t)v9, a4);
    if (a2)
    {
      id v10 = [NSString stringWithUTF8String:a2];
      [*a4 setLabel:v10];
    }
    if (v9)
    {
    }
  }
  else
  {
    *a4 = 0;
  }
}

void *re::allocInfo_ImportGraphicsResources(re *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_418, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_418))
  {
    re::IntrospectionStructure::IntrospectionStructure((re::IntrospectionStructure *)&unk_26AF98440, "ImportGraphicsResources");
    __cxa_guard_release(&_MergedGlobals_418);
  }
  return &unk_26AF98440;
}

void re::initInfo_ImportGraphicsResources(re *this, re::IntrospectionBase *a2)
{
  v5[0] = 0x136231223051452ALL;
  v5[1] = "ImportGraphicsResources";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((void *)this + 2) = 0xC000000008;
  *((_DWORD *)this + 6) = 64;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = &re::initInfo_ImportGraphicsResources(re::IntrospectionBase *)::structureAttributes;
  *((void *)this + re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = re::internal::defaultConstruct<re::ImportGraphicsResources>;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = re::internal::defaultDestruct<re::ImportGraphicsResources>;
  *((void *)this + 13) = re::internal::defaultConstructV2<re::ImportGraphicsResources>;
  *((void *)this + 14) = re::internal::defaultDestructV2<re::ImportGraphicsResources>;
  re::IntrospectionRegistry::add(this, v3);
  long long v4 = v6;
}

double re::internal::defaultConstruct<re::ImportGraphicsResources>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_WORD *)(a3 + 16) = 257;
  *(unsigned char *)(a3 + 18) = 1;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(void *)&double result = 0x7FFFFFFFLL;
  *(void *)(a3 + 108) = 0x7FFFFFFFLL;
  *(_DWORD *)(a3 + 128) = 0;
  return result;
}

void re::internal::defaultDestruct<re::ImportGraphicsResources>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)(a3 + 72));

  long long v4 = *(void **)a3;
}

double re::internal::defaultConstructV2<re::ImportGraphicsResources>(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 16) = 257;
  *(unsigned char *)(a1 + 18) = 1;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(void *)&double result = 0x7FFFFFFFLL;
  *(void *)(a1 + 108) = 0x7FFFFFFFLL;
  *(_DWORD *)(a1 + 128) = 0;
  return result;
}

void re::internal::defaultDestructV2<re::ImportGraphicsResources>(uint64_t a1)
{
  re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)(a1 + 72));

  uint64_t v2 = *(void **)a1;
}

uint64_t re::introspect_ImportGraphicsResources(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ImportGraphicsResources", (uint64_t (*)(re::internal *))re::allocInfo_ImportGraphicsResources, (re::IntrospectionBase *(*)(void))re::initInfo_ImportGraphicsResources, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ImportGraphicsResources>, this);
}

uint64_t re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v2 = *a2;
  unint64_t v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if (v4 == 0x7FFFFFFF) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(void *)(v6 + 24 * v4 + 8) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 24 * v4) & 0x7FFFFFFF;
      if (v4 == 0x7FFFFFFF) {
        break;
      }
      if (*(void *)(v6 + 24 * v4 + 8) == v2) {
        return v6 + 24 * v4 + 16;
      }
    }
    return 0;
  }
  return v6 + 24 * v4 + 16;
}

uint64_t re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::addNew<re::mtl::CommandQueue&>(uint64_t a1, uint64_t *a2, id *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(void *)a1)
  {
    LODWORD(vre::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = 0;
    goto LABEL_8;
  }
  unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
  if (v10 == 0x7FFFFFFF)
  {
LABEL_8:
    unsigned int v13 = re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::addEmplace<re::mtl::CommandQueue&>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 16) + 24 * v13;
    return v12 + 16;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  while (*(void *)(v11 + 24 * v10 + 8) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 24 * v10) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = v11 + 24 * v10;
  return v12 + 16;
}

uint64_t re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::addEmplace<re::mtl::CommandQueue&>(uint64_t a1, unsigned int a2, unint64_t a3, void *a4, id *a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  if (v9 == 0x7FFFFFFF)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 32);
    int v10 = v9;
    if (v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      int v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 24 * v9);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 24 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  uint64_t v14 = 24 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(void *)(a1 + 16) + v14) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v9) & 0x80000000 | *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2);
  *(void *)(*(void *)(a1 + 16) + 24 * v9 + 8) = *a4;
  uint64_t v15 = *(void *)(a1 + 16) + 24 * v9;
  *(void *)(v15 + 16) = *a5;
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v28, 0, 36);
      *(void *)&v28[36] = 0x7FFFFFFFLL;
      re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::init((uint64_t)v28, v4, a2);
      long long v5 = *(_OWORD *)a1;
      *(void *)a1 = *(void *)v28;
      uint64_t v6 = *(void *)(a1 + 16);
      long long v7 = *(_OWORD *)&v28[8];
      *(_OWORD *)float v28 = v5;
      *(void *)&unsigned char v28[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      long long v9 = *(_OWORD *)&v28[24];
      *(_OWORD *)&v28[24] = *(_OWORD *)(a1 + 24);
      unsigned int v8 = *(_DWORD *)&v28[32];
      *(_OWORD *)(a1 + 24) = v9;
      unint64_t v10 = v8;
      if (v8)
      {
        unint64_t v11 = 0;
        int v12 = DWORD1(v9);
        uint64_t v13 = v7;
        uint64_t v14 = (uint64_t *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v14 - 2) & 0x80000000) != 0)
          {
            unint64_t v15 = *(v14 - 1);
            unint64_t v16 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) >> 27));
            unint64_t v17 = v16 ^ (v16 >> 31);
            unint64_t v18 = *(unsigned int *)(a1 + 24);
            unint64_t v19 = v17 % v18;
            uint64_t v20 = *(unsigned int *)(a1 + 36);
            if (v20 == 0x7FFFFFFF)
            {
              uint64_t v20 = *(unsigned int *)(a1 + 32);
              int v21 = v20;
              if (v20 == v18)
              {
                re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::setCapacity(a1, (2 * v12));
                unint64_t v19 = v17 % *(unsigned int *)(a1 + 24);
                int v21 = *(_DWORD *)(a1 + 32);
                uint64_t v13 = *(void *)(a1 + 8);
                unint64_t v15 = *(v14 - 1);
              }
              *(_DWORD *)(a1 + 32) = v21 + 1;
              uint64_t v22 = *(void *)(a1 + 16);
              int v23 = *(_DWORD *)(v22 + 24 * v20);
            }
            else
            {
              uint64_t v22 = *(void *)(a1 + 16);
              int v23 = *(_DWORD *)(v22 + 24 * v20);
              *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
            }
            uint64_t v24 = 24 * v20;
            *(_DWORD *)(v22 + v24) = v23 | 0x80000000;
            *(_DWORD *)(*(void *)(a1 + 16) + v24) = *(_DWORD *)(*(void *)(a1 + 16) + 24 * v20) & 0x80000000 | *(_DWORD *)(v13 + 4 * v19);
            *(void *)(*(void *)(a1 + 16) + 24 * v20 + 8) = v15;
            uint64_t v25 = *(void *)(a1 + 16) + 24 * v20;
            uint64_t v26 = *v14;
            *uint64_t v14 = 0;
            *(void *)(v25 + 16) = v26;
            uint64_t v13 = *(void *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v1re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = v20;
            int v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 3;
        }
        while (v11 < v10);
      }
      re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)v28);
    }
  }
  else
  {
    if (a2) {
      signed int v27 = a2;
    }
    else {
      signed int v27 = 3;
    }
  }
}

void re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4 = 245;
  long long v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    unint64_t v6 = v4 >> 1;
    long long v7 = &v5[v4 >> 1];
    signed int v9 = *v7;
    unsigned int v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3) {
      long long v5 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
  }
  while (v4);
  uint64_t v10 = *v5;
  *(void *)a1 = a2;
  uint64_t v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  int v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    uint64_t v14 = v12;
    *(void *)(a1 + 8) = v12;
    if (v10) {
      memset_pattern16(v12, &memset_pattern_18, 4 * v10);
    }
    *(void *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

double re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v6 = a1[2];
        int v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          uint64_t v8 = v6 + v4;
          *(_DWORD *)uint64_t v8 = v7 & 0x7FFFFFFF;
          *(void *)(v8 + 8) = 0;

          unint64_t v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 24;
      }
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(void *)&double result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomDeformer>::add(_anonymous_namespace_ *this, uint64_t *a2)
{
  unint64_t v4 = *((void *)this + 2);
  if (v4 >= *((void *)this + 1))
  {
    re::DynamicArray<re::GeomDeformer>::growCapacity(this, v4 + 1);
    unint64_t v4 = *((void *)this + 2);
  }
  uint64_t result = re::GeomDeformer::GeomDeformer(*((void *)this + 4) + 448 * v4, a2);
  ++*((void *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::DynamicArray<re::GeomDeformer>::deinit(uint64_t a1)
{
  uint64_t result = *(void *)a1;
  if (result)
  {
    unint64_t v3 = *(re::GeomDeformer **)(a1 + 32);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        uint64_t v5 = 448 * v4;
        do
        {
          re::GeomDeformer::~GeomDeformer(v3);
          unint64_t v3 = (re::GeomDeformer *)((char *)v3 + 448);
          v5 -= 448;
        }
        while (v5);
        uint64_t result = *(void *)a1;
        unint64_t v3 = *(re::GeomDeformer **)(a1 + 32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, re::GeomDeformer *))(*(void *)result + 40))(result, v3);
    }
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void *re::DynamicArray<re::GeomDeformer>::growCapacity(void *this, unint64_t a2)
{
  unint64_t v2 = this[1];
  if (v2 < a2)
  {
    unint64_t v3 = a2;
    uint64_t v4 = this;
    if (*this)
    {
      uint64_t v5 = 2 * v2;
      BOOL v6 = v2 == 0;
      unint64_t v7 = 8;
      if (!v6) {
        unint64_t v7 = v5;
      }
      if (v7 > a2) {
        a2 = v7;
      }
      return re::DynamicArray<re::GeomDeformer>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::GeomDeformer>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::AnimationMetaData::deinit(re::AnimationMetaData *this)
{
  re::DynamicArray<unsigned long>::deinit((uint64_t)this + 40);
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)this);
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)this + 80);
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)this + 120);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 20);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 26);
  return re::DynamicArray<unsigned long>::deinit((uint64_t)this + 304);
}

void generateInfluenceData(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, _anonymous_namespace_ *a6, void *a7, _anonymous_namespace_ *a8)
{
  uint64_t v99 = *MEMORY[0x263EF8340];
  id v15 = a3;
  id v16 = a4;
  if (*((void *)a6 + 2))
  {
    re::DynamicString::format((re::DynamicString *)"Size of Weights = %ld", (re::DynamicString *)&v94, *((void *)a6 + 2));
    long long v17 = v94;
    uint64_t v19 = *((void *)&v95 + 1);
    uint64_t v18 = v95;
    *(unsigned char *)a1 = 0;
    uint64_t v20 = 1015;
LABEL_7:
    *(void *)(a1 + 8) = v20;
    *(void *)(a1 + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a1 + 24) = v17;
    *(void *)(a1 + 40) = v18;
    *(void *)(a1 + 48) = v19;
    goto LABEL_8;
  }
  if (a7[2])
  {
    re::DynamicString::format((re::DynamicString *)"Size of JointIndices = %ld", (re::DynamicString *)&v94, a7[2]);
    long long v17 = v94;
    uint64_t v19 = *((void *)&v95 + 1);
    uint64_t v18 = v95;
    *(unsigned char *)a1 = 0;
    uint64_t v20 = 1016;
    goto LABEL_7;
  }
  if (*((void *)a8 + 2))
  {
    re::DynamicString::format((re::DynamicString *)"Size of InfluenceEndIndices = %ld", (re::DynamicString *)&v94, *((void *)a8 + 2));
    long long v17 = v94;
    uint64_t v19 = *((void *)&v95 + 1);
    uint64_t v18 = v95;
    *(unsigned char *)a1 = 0;
    uint64_t v20 = 1017;
    goto LABEL_7;
  }
  uint64_t v74 = a5;
  uint64_t v21 = [v15 dataStart];
  if (!v21)
  {
    re::DynamicString::format((re::DynamicString *)"Weight Attribute stride = %ld, format = %ld", (re::DynamicString *)&v94, [v15 stride], objc_msgSend(v15, "format"));
    long long v17 = v94;
    uint64_t v19 = *((void *)&v95 + 1);
    uint64_t v18 = v95;
    *(unsigned char *)a1 = 0;
    uint64_t v20 = 1021;
    goto LABEL_7;
  }
  uint64_t v22 = v21;
  if (![v16 dataStart])
  {
    re::DynamicString::format((re::DynamicString *)"Joint Indexes Attribute stride = %ld, format = %ld", (re::DynamicString *)&v94, [v16 stride], objc_msgSend(v16, "format"));
    long long v17 = v94;
    uint64_t v19 = *((void *)&v95 + 1);
    uint64_t v18 = v95;
    *(unsigned char *)a1 = 0;
    uint64_t v20 = 1009;
    goto LABEL_7;
  }
  long long v73 = a8;
  unsigned __int8 v23 = [v15 format];
  uint64_t v82 = 0;
  unint64_t v83 = 0;
  uint64_t v84 = 0;
  id v24 = v16;
  uint64_t v25 = (_anonymous_namespace_ *)[v24 format];
  unint64_t v26 = v25 * a2;
  unsigned __int8 v75 = v23;
  if ((~[v24 format] & 0xA0000) != 0)
  {
    if ((~[v24 format] & 0x90000) != 0)
    {
      if ((~[v24 format] & 0x60000) != 0)
      {
        if ((~[v24 format] & 0x50000) != 0)
        {
          if (([v24 format] & 0x20000) != 0)
          {
            uint64_t v41 = [v24 dataStart];
            if (v26)
            {
              uint64_t v42 = 0;
              unint64_t v30 = v83;
              uint64_t v43 = v84;
              while (v30 != v42)
              {
                *(_DWORD *)(v43 + 4 * v42) = *(char *)(v41 + v42);
                if (v26 == ++v42) {
                  goto LABEL_49;
                }
              }
              goto LABEL_92;
            }
          }
          else
          {
            if (([v24 format] & 0x10000) == 0)
            {
              re::DynamicString::format((re::DynamicString *)"Format = %ld", (re::DynamicString *)&v94, [v24 format]);
              long long v76 = v94;
              long long v40 = v95;

              *(unsigned char *)a1 = 0;
              *(void *)(a1 + 8) = 1011;
              *(void *)(a1 + 16) = &re::AnimationErrorCategory(void)::instance;
              *(_OWORD *)(a1 + 24) = v76;
              *(_OWORD *)(a1 + 40) = v40;
              goto LABEL_82;
            }
            uint64_t v44 = [v24 dataStart];
            if (v26)
            {
              uint64_t v45 = 0;
              unint64_t v30 = v83;
              uint64_t v46 = v84;
              while (v30 != v45)
              {
                *(_DWORD *)(v46 + 4 * v45) = *(unsigned __int8 *)(v44 + v45);
                if (v26 == ++v45) {
                  goto LABEL_49;
                }
              }
LABEL_93:
              uint64_t v79 = 0;
              long long v97 = 0u;
              long long v98 = 0u;
              long long v96 = 0u;
              long long v94 = 0u;
              long long v95 = 0u;
              os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              int v86 = 136315906;
              long long v87 = "operator[]";
              __int16 v88 = 1024;
              int v89 = 468;
              __int16 v90 = 2048;
              unint64_t v91 = v30;
              __int16 v92 = 2048;
              unint64_t v93 = v30;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
          }
        }
        else
        {
          uint64_t v37 = [v24 dataStart];
          if (v26)
          {
            uint64_t v38 = 0;
            unint64_t v30 = v83;
            uint64_t v39 = v84;
            while (v30 != v38)
            {
              *(_DWORD *)(v39 + 4 * v38) = *(unsigned __int16 *)(v37 + 2 * v38);
              if (v26 == ++v38) {
                goto LABEL_49;
              }
            }
            goto LABEL_91;
          }
        }
      }
      else
      {
        uint64_t v34 = [v24 dataStart];
        if (v26)
        {
          uint64_t v35 = 0;
          unint64_t v30 = v83;
          uint64_t v36 = v84;
          while (v30 != v35)
          {
            *(_DWORD *)(v36 + 4 * v35) = *(__int16 *)(v34 + 2 * v35);
            if (v26 == ++v35) {
              goto LABEL_49;
            }
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      uint64_t v31 = [v24 dataStart];
      if (v26)
      {
        uint64_t v32 = 0;
        unint64_t v30 = v83;
        uint64_t v33 = v84;
        while (v30 != v32)
        {
          *(_DWORD *)(v33 + 4 * v32) = *(_DWORD *)(v31 + 4 * v32);
          if (v26 == ++v32) {
            goto LABEL_49;
          }
        }
        goto LABEL_88;
      }
    }
  }
  else
  {
    uint64_t v27 = [v24 dataStart];
    if (v26)
    {
      uint64_t v28 = 0;
      unint64_t v30 = v83;
      uint64_t v29 = v84;
      while (v30 != v28)
      {
        *(_DWORD *)(v29 + 4 * v28) = *(_DWORD *)(v27 + 4 * v28);
        if (v26 == ++v28) {
          goto LABEL_49;
        }
      }
      goto LABEL_87;
    }
  }
LABEL_49:
  id v68 = v16;
  id v69 = v15;
  uint64_t v47 = v75;
  uint64_t v67 = a2;

  uint64_t v79 = 0;
  unint64_t v80 = 0;
  uint64_t v81 = 0;
  unint64_t v72 = v75 * a2;
  if (!v72)
  {
LABEL_71:
    if (*((void *)v73 + 2) != v67)
    {
      re::DynamicString::format((re::DynamicString *)"InfluenceEndIndices size = %ld, vertexCount = %ld", (re::DynamicString *)&v94, *((void *)v73 + 2), v67);
      long long v63 = v94;
      uint64_t v65 = *((void *)&v95 + 1);
      uint64_t v64 = v95;
      *(unsigned char *)a1 = 0;
      uint64_t v66 = 1020;
      goto LABEL_78;
    }
    *(unsigned char *)a1 = 1;
    goto LABEL_79;
  }
  uint64_t v49 = 0;
  unint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v70 = v75 - 1;
  uint64_t v71 = 4 * v75;
LABEL_51:
  if (!v47)
  {
    uint64_t v51 = 0;
    goto LABEL_75;
  }
  uint64_t v52 = 0;
  float v53 = 0.0;
  unint64_t v30 = v80;
  uint64_t v54 = v81;
  do
  {
    if (v30 == v52)
    {
      uint64_t v85 = 0;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v96 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      unint64_t v58 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v86 = 136315906;
      long long v87 = "operator[]";
      __int16 v88 = 1024;
      int v89 = 468;
      __int16 v90 = 2048;
      unint64_t v91 = v30;
      __int16 v92 = 2048;
      unint64_t v93 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_86:
      uint64_t v85 = 0;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v96 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v86 = 136315906;
      long long v87 = "operator[]";
      __int16 v88 = 1024;
      int v89 = 468;
      __int16 v90 = 2048;
      unint64_t v91 = v58;
      __int16 v92 = 2048;
      unint64_t v93 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_87:
      uint64_t v79 = 0;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v96 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v86 = 136315906;
      long long v87 = "operator[]";
      __int16 v88 = 1024;
      int v89 = 468;
      __int16 v90 = 2048;
      unint64_t v91 = v30;
      __int16 v92 = 2048;
      unint64_t v93 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_88:
      uint64_t v79 = 0;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v96 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      unint64_t v59 = &_os_log_internal;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v86 = 136315906;
      long long v87 = "operator[]";
      __int16 v88 = 1024;
      int v89 = 468;
      __int16 v90 = 2048;
      unint64_t v91 = v30;
      __int16 v92 = 2048;
      unint64_t v93 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_89:
      uint64_t v85 = 0;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v96 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v86 = 136315906;
      long long v87 = "operator[]";
      __int16 v88 = 1024;
      int v89 = 468;
      __int16 v90 = 2048;
      unint64_t v91 = v59;
      __int16 v92 = 2048;
      unint64_t v93 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_90:
      uint64_t v79 = 0;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v96 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v86 = 136315906;
      long long v87 = "operator[]";
      __int16 v88 = 1024;
      int v89 = 468;
      __int16 v90 = 2048;
      unint64_t v91 = v30;
      __int16 v92 = 2048;
      unint64_t v93 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_91:
      uint64_t v79 = 0;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v96 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v86 = 136315906;
      long long v87 = "operator[]";
      __int16 v88 = 1024;
      int v89 = 468;
      __int16 v90 = 2048;
      unint64_t v91 = v30;
      __int16 v92 = 2048;
      unint64_t v93 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_92:
      uint64_t v79 = 0;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v96 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      int v86 = 136315906;
      long long v87 = "operator[]";
      __int16 v88 = 1024;
      int v89 = 468;
      __int16 v90 = 2048;
      unint64_t v91 = v30;
      __int16 v92 = 2048;
      unint64_t v93 = v30;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_93;
    }
    float v55 = *(float *)(v22 + 4 * v52);
    *(float *)(v54 + 4 * v52) = v55;
    float v53 = v53 + v55;
    ++v52;
  }
  while (v47 != v52);
  if (fabsf(v53) < 0.00001)
  {
LABEL_75:
    re::DynamicString::format((re::DynamicString *)"Vertex Index = %ld", (re::DynamicString *)&v94, v51);
    long long v63 = v94;
    uint64_t v65 = *((void *)&v95 + 1);
    uint64_t v64 = v95;
    *(unsigned char *)a1 = 0;
    uint64_t v66 = 1010;
    goto LABEL_78;
  }
  uint64_t v77 = v51;
  unint64_t v56 = 0;
  char v57 = 1;
LABEL_57:
  unint64_t v30 = v80;
  if (v56 <= v80) {
    unint64_t v58 = v80;
  }
  else {
    unint64_t v58 = v56;
  }
  do
  {
    float v78 = 0.0;
    if (v58 == v56) {
      goto LABEL_86;
    }
    float v78 = *(float *)(v81 + 4 * v56) / v53;
    if (v78 > 0.0)
    {
      re::DynamicArray<float>::add(a6, &v78);
      unint64_t v59 = v50 + v56;
      unint64_t v30 = v83;
      if (v83 <= v50 + v56) {
        goto LABEL_89;
      }
      unint64_t v60 = *(int *)(v84 + v49 + 4 * v56);
      unint64_t v61 = *(void *)(v74 + 16);
      if (v61 <= v60)
      {
        re::DynamicString::format((re::DynamicString *)"Invalid Joint Index (%d), number of joints: %zu", (re::DynamicString *)&v94, *(int *)(v84 + v49 + 4 * v56), v61);
        long long v63 = v94;
        uint64_t v65 = *((void *)&v95 + 1);
        uint64_t v64 = v95;
        *(unsigned char *)a1 = 0;
        uint64_t v66 = 1018;
        goto LABEL_78;
      }
      LODWORD(v94) = *(void *)(*(void *)(v74 + 32) + 8 * v60);
      re::DynamicArray<int>::add(a7, &v94);
      char v57 = 0;
      if (v70 == v56++)
      {
LABEL_70:
        LODWORD(v94) = *((void *)a6 + 2);
        re::DynamicArray<int>::add(v73, &v94);
        v50 += v47;
        uint64_t v51 = v77 + 1;
        v22 += v71;
        v49 += v71;
        if (v50 >= v72) {
          goto LABEL_71;
        }
        goto LABEL_51;
      }
      goto LABEL_57;
    }
    ++v56;
  }
  while (v47 != v56);
  if ((v57 & 1) == 0) {
    goto LABEL_70;
  }
  re::DynamicString::format((re::DynamicString *)"Vertex Index = %ld", (re::DynamicString *)&v94, v77);
  long long v63 = v94;
  uint64_t v65 = *((void *)&v95 + 1);
  uint64_t v64 = v95;
  *(unsigned char *)a1 = 0;
  uint64_t v66 = 1019;
LABEL_78:
  *(void *)(a1 + 8) = v66;
  *(void *)(a1 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(a1 + 24) = v63;
  *(void *)(a1 + 40) = v64;
  *(void *)(a1 + 48) = v65;
LABEL_79:
  id v16 = v68;
  id v15 = v69;
  if (v79 && v80) {
    (*(void (**)(void))(*(void *)v79 + 40))();
  }
LABEL_82:
  if (v82 && v83) {
    (*(void (**)(void))(*(void *)v82 + 40))();
  }
LABEL_8:
}

void processForMeshData(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v278 = *MEMORY[0x263EF8340];
  id v8 = a2;
  uint64_t v228 = [v8 vertexCount];
  long long v251 = 0u;
  long long v252 = 0u;
  long long v253 = 0u;
  long long v254 = 0u;
  signed int v9 = [v8 components];
  uint64_t v10 = [v9 countByEnumeratingWithState:&v251 objects:v270 count:16];
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)v252;
LABEL_3:
    uint64_t v13 = 0;
    while (1)
    {
      if (*(void *)v252 != v12) {
        objc_enumerationMutation(v9);
      }
      uint64_t v14 = *(void **)(*((void *)&v251 + 1) + 8 * v13);
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        break;
      }
      if (v11 == ++v13)
      {
        uint64_t v11 = [v9 countByEnumeratingWithState:&v251 objects:v270 count:16];
        if (!v11) {
          goto LABEL_9;
        }
        goto LABEL_3;
      }
    }
    id v15 = v14;

    if (v15)
    {
      id v16 = [v15 skeleton];
      long long v17 = v16;
      if (v16)
      {
        uint64_t v18 = [(uint8_t *)v16 jointPaths];
        uint64_t v19 = [v18 count];

        if (v19)
        {
          int v250 = -1;
          unint64_t v20 = a5[40];
          uint64_t v21 = a3;
          if (v20)
          {
            uint64_t v22 = 0;
            unsigned int v23 = 1;
            while (*(uint8_t **)(a5[42] + 8 * v22) != v17)
            {
              uint64_t v22 = v23;
              BOOL v24 = v20 > v23++;
              if (!v24) {
                goto LABEL_17;
              }
            }
            unsigned int v42 = v23 - 1;
            int v250 = v23 - 1;
            uint64_t v249 = 0;
            uint64_t v246 = 0;
            uint64_t v247 = 0;
            uint64_t v245 = 0;
            int v248 = 0;
            if (v23) {
              goto LABEL_133;
            }
          }
          else
          {
LABEL_17:
            uint64_t v249 = 0;
            uint64_t v246 = 0;
            uint64_t v247 = 0;
            uint64_t v245 = 0;
            int v248 = 0;
          }
          *(void *)long long buf = v17;
          uint64_t v25 = (_anonymous_namespace_ *)re::DynamicArray<unsigned long>::add(a5 + 38, buf);
          long long v26 = 0uLL;
          *(void *)long long buf = 0;
          memset(v258, 0, sizeof(v258));
          *(void *)&uint8_t buf[8] = "";
          long long v259 = 0u;
          memset(v260, 0, sizeof(v260));
          long long v261 = 0u;
          long long v262 = 0x7FFFFFFF00000000uLL;
          unint64_t v28 = *(void *)(a3 + 8);
          unint64_t v27 = *(void *)(a3 + 16);
          if (v27 >= v28)
          {
            unint64_t v35 = v27 + 1;
            if (v28 < v27 + 1)
            {
              if (*(void *)a3)
              {
                unint64_t v36 = 2 * v28;
                if (!v28) {
                  unint64_t v36 = 8;
                }
                if (v36 <= v35) {
                  unint64_t v37 = v35;
                }
                else {
                  unint64_t v37 = v36;
                }
                re::DynamicArray<re::ModelIOSkeleton>::setCapacity((void *)a3, v37);
              }
              else
              {
                re::DynamicArray<re::ModelIOSkeleton>::setCapacity((void *)a3, v35);
                ++*(_DWORD *)(a3 + 24);
              }
              long long v26 = 0uLL;
            }
            unint64_t v27 = *(void *)(a3 + 16);
            uint8_t v29 = buf[0];
          }
          else
          {
            uint8_t v29 = 0;
          }
          uint64_t v43 = *(void *)(a3 + 32) + 168 * v27;
          *(void *)uint64_t v43 = *(void *)v43 & 0xFFFFFFFFFFFFFFFELL | v29 & 1;
          *(void *)uint64_t v43 = *(void *)buf & 0xFFFFFFFFFFFFFFFELL | v29 & 1;
          *(void *)(v43 + 8) = *(void *)&buf[8];
          *(void *)&uint8_t buf[8] = "";
          *(void *)long long buf = 0;
          *(_DWORD *)(v43 + 16) = *(_DWORD *)v258;
          *(void *)(v43 + 32) = 0;
          *(void *)(v43 + 40) = 0;
          *(void *)(v43 + 24) = 0;
          *(void *)(v43 + 24) = *(void *)&v258[8];
          *(void *)&v258[8] = 0;
          *(void *)(v43 + 32) = *(void *)&v258[16];
          *(void *)&v258[16] = 0;
          uint64_t v44 = *(void *)(v43 + 40);
          *(void *)(v43 + 40) = *(void *)&v258[24];
          *(void *)&v258[24] = v44;
          *(void *)(v43 + 56) = 0;
          *(void *)(v43 + 64) = 0;
          *(void *)(v43 + 48) = 0;
          *(void *)(v43 + 48) = *(void *)&v258[32];
          *(void *)&v258[32] = 0;
          *(void *)(v43 + 56) = *(void *)&v258[40];
          *(void *)&v258[40] = 0;
          uint64_t v45 = *(void *)(v43 + 64);
          *(void *)(v43 + 64) = *(void *)&v258[48];
          *(void *)&v258[48] = v45;
          *(void *)(v43 + 72) = 0;
          *(void *)(v43 + 80) = 0;
          *(void *)(v43 + 88) = 0;
          *(void *)(v43 + 72) = *(void *)&v258[56];
          *(void *)&v258[56] = 0;
          *(void *)(v43 + 80) = *(void *)&v258[64];
          *(void *)&v258[64] = 0;
          uint64_t v46 = *(void *)(v43 + 88);
          *(void *)(v43 + 88) = v259;
          *(void *)&long long v259 = v46;
          *(void *)(v43 + 96) = 0;
          *(void *)(v43 + 104) = 0;
          *(void *)(v43 + 112) = 0;
          *(void *)(v43 + 96) = *((void *)&v259 + 1);
          *((void *)&v259 + 1) = 0;
          *(void *)(v43 + 104) = v260[0];
          v260[0] = 0;
          uint64_t v47 = *(void *)(v43 + 112);
          *(void *)(v43 + 112) = v260[1];
          v260[1] = v47;
          *(_DWORD *)(v43 + 152) = 0;
          *(_OWORD *)(v43 + 136) = v26;
          *(_OWORD *)(v43 + 120) = v26;
          *(void *)(v43 + 156) = 0x7FFFFFFFLL;
          *(void *)(v43 + 120) = v260[2];
          v260[2] = 0;
          uint64_t v48 = *(void *)(v43 + 128);
          *(void *)(v43 + 128) = v260[3];
          v260[3] = v48;
          uint64_t v49 = *(void *)(v43 + 136);
          *(void *)(v43 + 136) = v261;
          *(void *)&long long v261 = v49;
          LODWORD(v4re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = *(_DWORD *)(v43 + 144);
          *(_DWORD *)(v43 + 144) = DWORD2(v261);
          DWORD2(v261) = v49;
          LODWORD(v4re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = *(_DWORD *)(v43 + 148);
          *(_DWORD *)(v43 + 148) = HIDWORD(v261);
          HIDWORD(v261) = v49;
          LODWORD(v4re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = *(_DWORD *)(v43 + 152);
          *(_DWORD *)(v43 + 152) = v262;
          LODWORD(v262) = v49;
          LODWORD(v4re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = *(_DWORD *)(v43 + 156);
          *(_DWORD *)(v43 + 156) = DWORD1(v262);
          DWORD1(v262) = v49;
          ++*(void *)(a3 + 16);
          ++*(_DWORD *)(a3 + 24);
          double v50 = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(&v260[2]);
          if (*((void *)&v259 + 1))
          {
            if (v260[0])
            {
              (*(void (**)(double))(**((void **)&v259 + 1) + 40))(v50);
              v260[0] = 0;
              v260[1] = 0;
            }
            *((void *)&v259 + 1) = 0;
          }
          re::FixedArray<re::StringID>::deinit(&v258[56]);
          if (*(void *)&v258[32])
          {
            if (*(void *)&v258[40])
            {
              (*(void (**)(void))(**(void **)&v258[32] + 40))();
              *(void *)&v258[40] = 0;
              *(void *)&v258[48] = 0;
            }
            *(void *)&v258[32] = 0;
          }
          if (*(void *)&v258[8])
          {
            if (*(void *)&v258[16])
            {
              (*(void (**)(void))(**(void **)&v258[8] + 40))();
              *(_OWORD *)&v258[16] = 0uLL;
            }
            *(void *)&v258[8] = 0;
          }
          re::StringID::destroyString((re::StringID *)buf);
          unint64_t v224 = *(void *)(a3 + 32);
          uint64_t v225 = *(void *)(a3 + 16) - 1;
          uint64_t v51 = (void *)(v224 + 168 * v225);
          uint64_t v52 = [(uint8_t *)v17 name];
          float v53 = v52;
          if (v52)
          {
            uint64_t v52 = (void *)[v52 UTF8String];
            uint64_t v54 = (const char *)v52;
          }
          else
          {
            uint64_t v54 = "(unnamed)";
          }
          v256.columns[0].f64[0] = 0.0;
          *(void *)&v256.columns[0].f64[1] = "";
          long long v55 = *(_OWORD *)v256.columns[0].f64;
          v256.columns[0].f64[0] = 0.0;
          *(void *)&v256.columns[0].f64[1] = "";
          uint64_t v56 = v51[1];
          unint64_t v57 = v55 & 0xFFFFFFFFFFFFFFFELL | *v51 & 1;
          v51[1] = *((void *)&v55 + 1);
          *(void *)&uint8_t buf[8] = v56;
          *(void *)long long buf = v57;
          *uint64_t v51 = v55;
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)&v256);

          unint64_t v58 = [(uint8_t *)v17 jointPaths];
          if (!v58)
          {
            uint64_t v117 = [v8 name];
            __n128 v118 = v117;
            if (v117) {
              int v119 = (const char *)[v117 UTF8String];
            }
            else {
              int v119 = "(unnamed)";
            }
            re::DynamicString::format((re::DynamicString *)"Processing mesh \"%s\"", (re::DynamicString *)buf, v119);
            long long v123 = *(_OWORD *)buf;
            long long v124 = *(_OWORD *)v258;
            *(unsigned char *)a1 = 0;
            *(void *)(a1 + 8) = 1003;
            *(void *)(a1 + 16) = &re::AnimationErrorCategory(void)::instance;
            *(_OWORD *)(a1 + 24) = v123;
            *(_OWORD *)(a1 + 40) = v124;

LABEL_209:
            if (v245)
            {
              if (v249) {
                (*(void (**)(void))(*(void *)v245 + 40))();
              }
              uint64_t v249 = 0;
            }
            goto LABEL_213;
          }
          uint64_t v213 = a4;
          id v215 = v15;
          long long v216 = a5;
          int v218 = v17;
          uint64_t v220 = v8;
          uint64_t v222 = a1;
          unint64_t v230 = v58;
          unint64_t v59 = (_anonymous_namespace_ *)[v58 count];
          if (v59)
          {
            uint64_t v61 = 0;
            uint64_t v62 = 0;
            unint64_t v63 = v224 + 168 * v225;
            uint64_t v64 = v63 + 120;
            uint64_t v65 = (uint8_t **)(v63 + 80);
            uint64_t v66 = (uint64_t *)(v63 + 88);
            uint64_t v227 = 136315138;
            unint64_t v67 = (unint64_t)"Duplicate joint name found in skeleton: '%s'\n";
            while (1)
            {
              id v68 = [v230 objectAtIndexedSubscript:v62];
              id v69 = (_anonymous_namespace_ *)[v68 UTF8String];
              *(void *)float32x4_t v232 = 0;
              *(void *)&v232[8] = "";

              uint64_t v70 = (re *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v64, v232);
              if (v70)
              {
                uint64_t v71 = *re::pipelineLogObjects(v70);
                if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
                {
                  unint64_t v72 = v71;
                  *(_DWORD *)long long buf = 136315138;
                  *(void *)&uint8_t buf[4] = *(void *)&v232[8];
                  _os_log_impl(&dword_233120000, v72, OS_LOG_TYPE_DEFAULT, "Duplicate joint name found in skeleton: '%s'\n", buf, 0xCu);
                }
              }
              else
              {
                *(_DWORD *)long long buf = v62;
                re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<unsigned int &>(v64, (StringID *)v232, buf);
              }
              long long v17 = *v65;
              if (*v65 <= (uint8_t *)v62) {
                break;
              }
              re::StringID::operator=((unint64_t *)(*v66 + v61), (uint64_t *)v232);
              re::StringID::destroyString((re::StringID *)v232);
              uint64_t v62 = (_anonymous_namespace_ *)((char *)v62 + 1);
              v61 += 16;
              if (v59 == v62) {
                goto LABEL_67;
              }
            }
            *(void *)__int16 v267 = 0;
            memset(v258, 0, 64);
            *(_OWORD *)long long buf = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v256.columns[0].f64[0]) = 136315906;
            *(void *)((char *)v256.columns[0].f64 + 4) = "operator[]";
            WORD2(v256.columns[0].f64[1]) = 1024;
            *(_DWORD *)((char *)&v256.columns[0].f64[1] + 6) = 468;
            WORD1(v256.columns[0].f64[2]) = 2048;
            *(void *)((char *)&v256.columns[0].f64[2] + 4) = v62;
            WORD2(v256.columns[0].f64[3]) = 2048;
            *(void *)((char *)&v256.columns[0].f64[3] + 6) = v17;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_216;
          }
LABEL_67:
          unint64_t v73 = v224 + 168 * v225;
          unsigned __int8 v75 = *(uint64_t **)(v73 + 80);
          long long v17 = (uint8_t *)(v73 + 80);
          uint64_t v66 = v75;
          if (v75)
          {
            unint64_t v67 = 0;
            unint64_t v76 = v224 + 168 * v225;
            uint64_t v77 = (void *)(v76 + 88);
            uint64_t v227 = (uint64_t)&v267[9];
            uint64_t v78 = v76 + 120;
            uint64_t v79 = (uint64_t **)(v76 + 104);
            unint64_t v80 = (void *)(v76 + 112);
            uint64_t v81 = 8;
            while ((unint64_t)v66 > v67)
            {
              uint64_t v82 = *(const char **)(*v77 + v81);
              re::DynamicString::rfind((uint64_t)v232, 47, &v240);
              if ((_BYTE)v240 && v241)
              {
                unint64_t v83 = (_anonymous_namespace_ *)re::DynamicString::substr((re::DynamicString *)v232, 0, v241, (re::DynamicString *)v267);
                if (v267[8]) {
                  uint64_t v84 = *(const char **)&v267[16];
                }
                else {
                  uint64_t v84 = &v267[9];
                }
                uint64_t v235 = 0;
                uint64_t v236 = "";
                uint64_t v85 = (int *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v78, &v235);
                uint64_t v66 = *v79;
                if (v85)
                {
                  if ((unint64_t)*v79 <= v67) {
                    goto LABEL_218;
                  }
                  int v86 = *v85;
                }
                else
                {
                  if ((unint64_t)*v79 <= v67) {
                    goto LABEL_219;
                  }
                  int v86 = -1;
                }
                *(_DWORD *)(*v80 + 4 * v67) = v86;
                re::StringID::destroyString((re::StringID *)&v235);
                if (*(void *)v267 && (v267[8] & 1) != 0) {
                  (*(void (**)(void))(**(void **)v267 + 40))();
                }
              }
              else
              {
                uint64_t v66 = *v79;
                if ((unint64_t)*v79 <= v67) {
                  goto LABEL_217;
                }
                *(_DWORD *)(*v80 + 4 * v67) = -1;
              }
              uint64_t v74 = *(_anonymous_namespace_ **)v232;
              if (*(void *)v232 && (v232[8] & 1) != 0) {
                uint64_t v74 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(void **)v232 + 40))();
              }
              ++v67;
              uint64_t v66 = *(uint64_t **)v17;
              v81 += 16;
              if (v67 >= *(void *)v17) {
                goto LABEL_90;
              }
            }
LABEL_216:
            *(void *)float32x4_t v232 = 0;
            memset(v258, 0, 64);
            *(_OWORD *)long long buf = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v256.columns[0].f64[0]) = 136315906;
            *(void *)((char *)v256.columns[0].f64 + 4) = "operator[]";
            WORD2(v256.columns[0].f64[1]) = 1024;
            *(_DWORD *)((char *)&v256.columns[0].f64[1] + 6) = 468;
            WORD1(v256.columns[0].f64[2]) = 2048;
            *(void *)((char *)&v256.columns[0].f64[2] + 4) = v67;
            WORD2(v256.columns[0].f64[3]) = 2048;
            *(void *)((char *)&v256.columns[0].f64[3] + 6) = v66;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_217:
            *(void *)__int16 v267 = 0;
            memset(v258, 0, 64);
            *(_OWORD *)long long buf = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v256.columns[0].f64[0]) = 136315906;
            *(void *)((char *)v256.columns[0].f64 + 4) = "operator[]";
            WORD2(v256.columns[0].f64[1]) = 1024;
            *(_DWORD *)((char *)&v256.columns[0].f64[1] + 6) = 468;
            WORD1(v256.columns[0].f64[2]) = 2048;
            *(void *)((char *)&v256.columns[0].f64[2] + 4) = v67;
            WORD2(v256.columns[0].f64[3]) = 2048;
            *(void *)((char *)&v256.columns[0].f64[3] + 6) = v66;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_218:
            *(void *)char v271 = 0;
            memset(v258, 0, 64);
            *(_OWORD *)long long buf = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v256.columns[0].f64[0]) = 136315906;
            *(void *)((char *)v256.columns[0].f64 + 4) = "operator[]";
            WORD2(v256.columns[0].f64[1]) = 1024;
            *(_DWORD *)((char *)&v256.columns[0].f64[1] + 6) = 468;
            WORD1(v256.columns[0].f64[2]) = 2048;
            *(void *)((char *)&v256.columns[0].f64[2] + 4) = v67;
            WORD2(v256.columns[0].f64[3]) = 2048;
            *(void *)((char *)&v256.columns[0].f64[3] + 6) = v66;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_219:
            *(void *)char v271 = 0;
            memset(v258, 0, 64);
            *(_OWORD *)long long buf = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            LODWORD(v256.columns[0].f64[0]) = 136315906;
            *(void *)((char *)v256.columns[0].f64 + 4) = "operator[]";
            WORD2(v256.columns[0].f64[1]) = 1024;
            *(_DWORD *)((char *)&v256.columns[0].f64[1] + 6) = 468;
            WORD1(v256.columns[0].f64[2]) = 2048;
            *(void *)((char *)&v256.columns[0].f64[2] + 4) = v67;
            WORD2(v256.columns[0].f64[3]) = 2048;
            *(void *)((char *)&v256.columns[0].f64[3] + 6) = v66;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_220;
          }
LABEL_90:
          *(_DWORD *)(v224 + 168 * v225 + 16) = v59;
          long long v17 = v218;
          long long v87 = [(uint8_t *)v218 jointBindTransforms];
          __int16 v88 = v87;
          if (v87)
          {
            uint64_t v89 = [v87 elementCount];
            id v8 = v220;
            a1 = v222;
            id v15 = v215;
            if (v89)
            {
              unint64_t v90 = v89;
              unint64_t v91 = [(uint8_t *)v218 jointRestTransforms];
              uint64_t v212 = v91;
              if (v91)
              {
                uint64_t v240 = 0;
                unint64_t v241 = 0;
                unint64_t v242 = 0;
                unsigned int v211 = (const simd_double4x4 *)v242;
                __int16 v92 = (_anonymous_namespace_ *)objc_msgSend(v88, "getDouble4x4Array:maxCount:");
                a5 = v216;
                a4 = v213;
                uint64_t v21 = a3;
                if (v92 == (_anonymous_namespace_ *)v90)
                {
                  uint64_t v235 = 0;
                  uint64_t v236 = 0;
                  unint64_t v237 = 0;
                  uint64_t v210 = (float64x2_t *)v237;
                  unint64_t v93 = (_anonymous_namespace_ *)-[_anonymous_namespace_ getDouble4x4Array:maxCount:](v212, "getDouble4x4Array:maxCount:");
                  if (v93 == (_anonymous_namespace_ *)v90)
                  {
                    uint64_t v209 = v88;
                    long long v94 = (uint64_t *)(v224 + 168 * v225);
                    unint64_t v67 = (unint64_t)(v94 + 3);
                    uint64_t v97 = v94[13];
                    long long v96 = v94 + 13;
                    if (v97)
                    {
                      uint64_t v98 = 0;
                      uint64_t v99 = 0;
                      uint64_t v66 = 0;
                      unint64_t v100 = v224 + 168 * v225;
                      long long v17 = (uint8_t *)(v100 + 64);
                      int v101 = (unint64_t *)(v100 + 32);
                      uint64_t v102 = (void *)(v100 + 40);
                      uint64_t v226 = (unint64_t *)(v100 + 56);
                      uint64_t v227 = (uint64_t)v236;
                      unint64_t v224 = v241;
                      float v103 = v211;
                      long long v104 = v210 + 4;
                      while ((uint64_t *)v227 != v66)
                      {
                        float64x2_t v106 = v104[-4];
                        float64x2_t v105 = v104[-3];
                        float64x2_t v108 = v104[-2];
                        float64x2_t v107 = v104[-1];
                        float64x2_t v110 = *v104;
                        float64x2_t v109 = v104[1];
                        float64x2_t v112 = v104[2];
                        float64x2_t v111 = v104[3];
                        *(void *)&v232[8] = 1065353216;
                        *(void *)&v232[16] = 0;
                        *(void *)float32x4_t v232 = 0x3F8000003F800000;
                        *(void *)&v232[24] = 0x3F80000000000000;
                        long long v233 = 0uLL;
                        *(float32x4_t *)long long buf = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v106), v105);
                        *(float32x4_t *)uint64_t v258 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v108), v107);
                        *(float32x4_t *)&v258[16] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v110), v109);
                        *(float32x4_t *)&v258[32] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v112), v111);
                        re::decomposeScaleRotationTranslation<float>((uint64_t)buf, (int32x4_t *)v232, &v232[16], &v233);
                        unint64_t v67 = *v226;
                        if (*v226 <= (unint64_t)v66) {
                          goto LABEL_221;
                        }
                        long long v113 = (_OWORD *)(*(void *)v17 + v98);
                        long long v114 = *(_OWORD *)v232;
                        long long v115 = v233;
                        v113[1] = *(_OWORD *)&v232[16];
                        v113[2] = v115;
                        _OWORD *v113 = v114;
                        if ((uint64_t *)v224 == v66) {
                          goto LABEL_222;
                        }
                        v279.columns[2] = *(simd_float4 *)v256.columns[1].f64;
                        v279.columns[3] = *(simd_float4 *)&v256.columns[1].f64[2];
                        v279.columns[0] = *(simd_float4 *)v256.columns[0].f64;
                        v279.columns[1] = *(simd_float4 *)&v256.columns[0].f64[2];
                        simd_float4x4 v280 = __invert_f4(v279);
                        unint64_t v67 = *v101;
                        if (*v101 <= (unint64_t)v66) {
                          goto LABEL_223;
                        }
                        *(simd_float4x4 *)(*v102 + v9re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = v280;
                        uint64_t v66 = (uint64_t *)((char *)v66 + 1);
                        v99 += 64;
                        ++v103;
                        v98 += 48;
                        v104 += 8;
                        if ((unint64_t)v66 >= *v96) {
                          goto LABEL_102;
                        }
                      }
LABEL_220:
                      *(void *)float32x4_t v232 = 0;
                      memset(v258, 0, 64);
                      *(_OWORD *)long long buf = 0u;
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      LODWORD(v256.columns[0].f64[0]) = 136315906;
                      *(void *)((char *)v256.columns[0].f64 + 4) = "operator[]";
                      WORD2(v256.columns[0].f64[1]) = 1024;
                      *(_DWORD *)((char *)&v256.columns[0].f64[1] + 6) = 468;
                      WORD1(v256.columns[0].f64[2]) = 2048;
                      *(void *)((char *)&v256.columns[0].f64[2] + 4) = v227;
                      WORD2(v256.columns[0].f64[3]) = 2048;
                      *(void *)((char *)&v256.columns[0].f64[3] + 6) = v227;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_221:
                      *(void *)__int16 v267 = 0;
                      memset(v258, 0, 64);
                      *(_OWORD *)long long buf = 0u;
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      LODWORD(v256.columns[0].f64[0]) = 136315906;
                      *(void *)((char *)v256.columns[0].f64 + 4) = "operator[]";
                      WORD2(v256.columns[0].f64[1]) = 1024;
                      *(_DWORD *)((char *)&v256.columns[0].f64[1] + 6) = 468;
                      WORD1(v256.columns[0].f64[2]) = 2048;
                      *(void *)((char *)&v256.columns[0].f64[2] + 4) = v66;
                      WORD2(v256.columns[0].f64[3]) = 2048;
                      *(void *)((char *)&v256.columns[0].f64[3] + 6) = v67;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_222:
                      *(void *)__int16 v267 = 0;
                      memset(v258, 0, 64);
                      *(_OWORD *)long long buf = 0u;
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      LODWORD(v256.columns[0].f64[0]) = 136315906;
                      *(void *)((char *)v256.columns[0].f64 + 4) = "operator[]";
                      WORD2(v256.columns[0].f64[1]) = 1024;
                      *(_DWORD *)((char *)&v256.columns[0].f64[1] + 6) = 468;
                      WORD1(v256.columns[0].f64[2]) = 2048;
                      *(void *)((char *)&v256.columns[0].f64[2] + 4) = v224;
                      WORD2(v256.columns[0].f64[3]) = 2048;
                      *(void *)((char *)&v256.columns[0].f64[3] + 6) = v224;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_223:
                      *(void *)char v271 = 0;
                      memset(v258, 0, 64);
                      *(_OWORD *)long long buf = 0u;
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      *(_DWORD *)__int16 v267 = 136315906;
                      *(void *)&v267[4] = "operator[]";
                      *(_WORD *)&v267[12] = 1024;
                      *(_DWORD *)&v267[14] = 468;
                      *(_WORD *)&v267[18] = 2048;
                      *(void *)&v267[20] = v66;
                      __int16 v268 = 2048;
                      *(void *)int v269 = v67;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
                      goto LABEL_224;
                    }
LABEL_102:
                    int v116 = 0;
                    uint64_t v21 = a3;
                    unsigned int v42 = *(_DWORD *)(a3 + 16) - 1;
                    int v250 = v42;
                    long long v17 = v218;
                    id v8 = v220;
                    id v15 = v215;
                    a5 = v216;
                    a1 = v222;
                    a4 = v213;
                    __int16 v88 = v209;
                  }
                  else
                  {
                    unsigned int v133 = [v220 name];
                    char v134 = v133;
                    if (v133) {
                      uint64_t v135 = (const char *)[v133 UTF8String];
                    }
                    else {
                      uint64_t v135 = "(unnamed)";
                    }
                    re::DynamicString::format((re::DynamicString *)"Incorrect number of rest transforms for \"%s\".", (re::DynamicString *)buf, v135);
                    long long v140 = *(_OWORD *)buf;
                    long long v141 = *(_OWORD *)v258;
                    *(unsigned char *)uint64_t v222 = 0;
                    *(void *)(v222 + 8) = 1029;
                    *(void *)(v222 + 16) = &re::AnimationErrorCategory(void)::instance;
                    *(_OWORD *)(v222 + 24) = v140;
                    *(_OWORD *)(v222 + 40) = v141;

                    int v116 = 1;
                    unsigned int v42 = -1;
                  }
                  if (v235 && v236) {
                    (*(void (**)(void))(*(void *)v235 + 40))();
                  }
                }
                else
                {
                  char v128 = [v220 name];
                  float32x4_t v129 = v128;
                  if (v128) {
                    char v130 = (const char *)[v128 UTF8String];
                  }
                  else {
                    char v130 = "(unnamed)";
                  }
                  re::DynamicString::format((re::DynamicString *)"Incorrect number of bind transforms for \"%s\".", (re::DynamicString *)buf, v130);
                  long long v138 = *(_OWORD *)buf;
                  long long v139 = *(_OWORD *)v258;
                  *(unsigned char *)uint64_t v222 = 0;
                  *(void *)(v222 + 8) = 1005;
                  *(void *)(v222 + 16) = &re::AnimationErrorCategory(void)::instance;
                  *(_OWORD *)(v222 + 24) = v138;
                  *(_OWORD *)(v222 + 40) = v139;

                  int v116 = 1;
                  unsigned int v42 = -1;
                }
                if (v240 && v241) {
                  (*(void (**)(void))(*(void *)v240 + 40))();
                }
              }
              else
              {
                __int16 v125 = [v220 name];
                unint64_t v126 = v125;
                a5 = v216;
                a4 = v213;
                uint64_t v21 = a3;
                if (v125) {
                  uint64_t v127 = (const char *)[v125 UTF8String];
                }
                else {
                  uint64_t v127 = "(unnamed)";
                }
                re::DynamicString::format((re::DynamicString *)"Processing mesh \"%s\"", (re::DynamicString *)buf, v127);
                long long v136 = *(_OWORD *)buf;
                long long v137 = *(_OWORD *)v258;
                *(unsigned char *)uint64_t v222 = 0;
                *(void *)(v222 + 8) = 1028;
                *(void *)(v222 + 16) = &re::AnimationErrorCategory(void)::instance;
                *(_OWORD *)(v222 + 24) = v136;
                *(_OWORD *)(v222 + 40) = v137;

                int v116 = 1;
                unsigned int v42 = -1;
              }

              if (v116) {
                goto LABEL_209;
              }
LABEL_133:
              uint64_t v223 = a1;
              uint64_t v219 = v17;
              long long v17 = (uint8_t *)v42;
              uint64_t v66 = *(uint64_t **)(v21 + 16);
              unsigned int v231 = v42;
              if ((unint64_t)v66 <= v42) {
                goto LABEL_227;
              }
              uint64_t v214 = a4;
              uint64_t v217 = a5;
              long long v221 = v8;
              uint64_t v142 = *(void *)(v21 + 32);
              id v143 = v15;
              id v144 = v15;
              uint64_t v145 = [v144 jointPaths];
              unsigned int v146 = [v145 count];

              uint64_t v147 = v146;
              if (v146)
              {
                uint64_t v148 = 0;
                uint64_t v149 = v142 + 168 * v17 + 120;
                while (1)
                {
                  uint64_t v150 = [v144 jointPaths];
                  id v151 = [v150 objectAtIndexedSubscript:v148];
                  float32x4_t v152 = (_anonymous_namespace_ *)[v151 UTF8String];
                  v256.columns[0].f64[0] = 0.0;
                  *(void *)&v256.columns[0].f64[1] = "";

                  int v153 = (unsigned int *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v149, &v256);
                  if (!v153) {
                    break;
                  }
                  *(void *)long long buf = *v153;
                  re::DynamicArray<unsigned long>::add(&v245, buf);
                  re::StringID::destroyString((re::StringID *)&v256);
                  if (v147 == ++v148) {
                    goto LABEL_142;
                  }
                }
                re::DynamicString::format((re::DynamicString *)"Joint \"%s\" missing from skeleton while remapping joints.", (re::DynamicString *)buf, *(void *)&v256.columns[0].f64[1]);
                long long v160 = *(_OWORD *)buf;
                long long v161 = *(_OWORD *)v258;
                unsigned int v159 = (unsigned char *)v223;
                *(unsigned char *)uint64_t v223 = 0;
                *(void *)(v223 + 8) = 1000;
                *(void *)(v223 + 16) = &re::AnimationErrorCategory(void)::instance;
                *(_OWORD *)(v223 + 24) = v160;
                *(_OWORD *)(v223 + 40) = v161;
                re::StringID::destroyString((re::StringID *)&v256);
              }
              else
              {
                uint64_t v154 = v142 + 168 * v17;
                uint64_t v156 = *(void *)(v154 + 80);
                unsigned int v155 = (void *)(v154 + 80);
                if (v156)
                {
                  uint64_t v157 = 0;
                  unsigned int v158 = 1;
                  do
                  {
                    *(void *)long long buf = v157;
                    re::DynamicArray<unsigned long>::add(&v245, buf);
                    uint64_t v157 = v158;
                    BOOL v24 = *v155 > (unint64_t)v158++;
                  }
                  while (v24);
                }
LABEL_142:
                unsigned int v159 = (unsigned char *)v223;
                *(unsigned char *)uint64_t v223 = 1;
              }

              long long v17 = v219;
              id v8 = v221;
              id v15 = v143;
              if (!*v159) {
                goto LABEL_209;
              }
              uint64_t v162 = [v221 vertexAttributeDataForAttributeNamed:*MEMORY[0x263F135A8]];
              unint64_t v163 = v162;
              if (v162)
              {
                if (([v162 format] & 0xC0000) != 0)
                {
                  int v164 = [v221 vertexAttributeDataForAttributeNamed:*MEMORY[0x263F135A0]];
                  if (!v164)
                  {
                    uint64_t v191 = [v221 name];
                    uint64_t v192 = v191;
                    if (v191) {
                      int v193 = (const char *)[v191 UTF8String];
                    }
                    else {
                      int v193 = "(unnamed)";
                    }
                    re::DynamicString::format((re::DynamicString *)"Processing mesh \"%s\"", (re::DynamicString *)buf, v193);
                    long long v207 = *(_OWORD *)buf;
                    long long v208 = *(_OWORD *)v258;
                    *(unsigned char *)uint64_t v223 = 0;
                    *(void *)(v223 + 8) = 1008;
                    *(void *)(v223 + 16) = &re::AnimationErrorCategory(void)::instance;
                    *(_OWORD *)(v223 + 24) = v207;
                    *(_OWORD *)(v223 + 40) = v208;

LABEL_207:
                    goto LABEL_208;
                  }
                  *(void *)&v269[2] = 0;
                  memset(v267, 0, sizeof(v267));
                  uint64_t v244 = 0;
                  unint64_t v241 = 0;
                  unint64_t v242 = 0;
                  uint64_t v239 = 0;
                  uint64_t v240 = 0;
                  int v243 = 0;
                  uint64_t v236 = 0;
                  unint64_t v237 = 0;
                  uint64_t v235 = 0;
                  int v238 = 0;
                  generateInfluenceData((uint64_t)v232, v228, v163, v164, (uint64_t)&v245, (_anonymous_namespace_ *)v267, &v240, (_anonymous_namespace_ *)&v235);
                  if (v232[0])
                  {
                    *(_OWORD *)long long buf = 0u;
                    memset(v258, 0, 48);
                    long long v17 = buf;
                    unsigned int v165 = re::DynamicString::DynamicString((re::DynamicString *)&v258[56]);
                    uint64_t v266 = 0;
                    long long v265 = 0u;
                    long long v264 = 0u;
                    long long v263 = 0u;
                    long long v262 = 0u;
                    long long v261 = 0u;
                    memset(v260, 0, sizeof(v260));
                    unint64_t v67 = v237;
                    uint64_t v167 = (uint64_t *)v237;
                    if (v237)
                    {
                      uint64_t v168 = 0;
                      uint64_t v169 = v239;
                      uint64_t v66 = (uint64_t *)*((void *)&v262 + 1);
                      uint64_t v170 = v263;
                      while (v66 != v168)
                      {
                        *(_DWORD *)(v170 + 4 * (void)v168) = *(_DWORD *)(v169 + 4 * (void)v168);
                        uint64_t v168 = (uint64_t *)((char *)v168 + 1);
                        if (v167 == v168) {
                          goto LABEL_153;
                        }
                      }
LABEL_224:
                      uint64_t v255 = 0;
                      memset(&v256, 0, 80);
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      *(_DWORD *)char v271 = 136315906;
                      *(void *)&v271[4] = "operator[]";
                      __int16 v272 = 1024;
                      int v273 = 468;
                      __int16 v274 = 2048;
                      unint64_t v275 = (unint64_t)v66;
                      __int16 v276 = 2048;
                      unint64_t v277 = (unint64_t)v66;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_225:
                      uint64_t v255 = 0;
                      memset(&v256, 0, 80);
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      *(_DWORD *)char v271 = 136315906;
                      *(void *)&v271[4] = "operator[]";
                      __int16 v272 = 1024;
                      int v273 = 468;
                      __int16 v274 = 2048;
                      unint64_t v275 = (unint64_t)v66;
                      __int16 v276 = 2048;
                      unint64_t v277 = (unint64_t)v66;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_226:
                      uint64_t v255 = 0;
                      memset(&v256, 0, 80);
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      *(_DWORD *)char v271 = 136315906;
                      *(void *)&v271[4] = "operator[]";
                      __int16 v272 = 1024;
                      int v273 = 468;
                      __int16 v274 = 2048;
                      unint64_t v275 = v67;
                      __int16 v276 = 2048;
                      unint64_t v277 = v67;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_227:
                      *(void *)float32x4_t v232 = 0;
                      memset(v258, 0, 64);
                      *(_OWORD *)long long buf = 0u;
                      os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                      LODWORD(v256.columns[0].f64[0]) = 136315906;
                      *(void *)((char *)v256.columns[0].f64 + 4) = "operator[]";
                      WORD2(v256.columns[0].f64[1]) = 1024;
                      *(_DWORD *)((char *)&v256.columns[0].f64[1] + 6) = 789;
                      WORD1(v256.columns[0].f64[2]) = 2048;
                      *(void *)((char *)&v256.columns[0].f64[2] + 4) = v17;
                      WORD2(v256.columns[0].f64[3]) = 2048;
                      *(void *)((char *)&v256.columns[0].f64[3] + 6) = v66;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
                    }
LABEL_153:
                    unint64_t v67 = *(void *)&v267[16];
                    v172 = *(uint64_t **)&v267[16];
                    if (*(void *)&v267[16])
                    {
                      uint64_t v173 = 0;
                      uint64_t v174 = *(void *)&v269[2];
                      uint64_t v175 = v260[2];
                      uint64_t v66 = (uint64_t *)v260[1];
                      while (v66 != v173)
                      {
                        *(_DWORD *)(v175 + 4 * (void)v173) = *(_DWORD *)(v174 + 4 * (void)v173);
                        uint64_t v173 = (uint64_t *)((char *)v173 + 1);
                        if (v172 == v173) {
                          goto LABEL_157;
                        }
                      }
                      goto LABEL_225;
                    }
LABEL_157:
                    unint64_t v176 = v242;
                    unint64_t v178 = v242;
                    long long v17 = v219;
                    if (v242)
                    {
                      uint64_t v179 = 0;
                      uint64_t v180 = v244;
                      uint64_t v181 = *((void *)&v261 + 1);
                      unint64_t v67 = v261;
                      while (v67 != v179)
                      {
                        *(_DWORD *)(v181 + 4 * v17re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = *(_DWORD *)(v180 + 4 * v179);
                        if (v178 == ++v179) {
                          goto LABEL_161;
                        }
                      }
                      goto LABEL_226;
                    }
LABEL_161:
                    *((void *)&v265 + 1) = 0;
                    [v144 geometryBindTransform];
                    *(_DWORD *)&v258[48] = v231;
                    unint64_t v183 = objc_msgSend(v221, "name", v182);
                    uint64_t v184 = v183;
                    if (v183) {
                      float32x4_t v185 = (char *)[v183 UTF8String];
                    }
                    else {
                      float32x4_t v185 = "(unnamed)";
                    }
                    re::DynamicString::operator=((re::DynamicString *)&v258[56], v185);

                    id v8 = v221;
                    uint64_t v199 = objc_msgSend(v221, "name", re::DynamicArray<re::ModelIOSkinningData>::add(v214, (uint64_t)buf));
                    int v200 = v199;
                    if (v199)
                    {
                      uint64_t v199 = (void *)[v199 UTF8String];
                      unint64_t v201 = (const char *)v199;
                    }
                    else
                    {
                      unint64_t v201 = "(unnamed)";
                    }
                    re::HashTable<re::DynamicString,unsigned int,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned int &>((uint64_t)(v217 + 20), (re::DynamicString *)&v256, &v250);
                    if (*(void *)&v256.columns[0].f64[0])
                    {
                      if (LOBYTE(v256.columns[0].f64[1])) {
                        (*(void (**)(void))(**(void **)&v256.columns[0].f64[0] + 40))();
                      }
                      memset(&v256, 0, 32);
                    }

                    long long v202 = [(uint8_t *)v219 name];
                    long long v203 = v202;
                    if (v202)
                    {
                      long long v202 = (void *)[v202 UTF8String];
                      int v204 = (const char *)v202;
                    }
                    else
                    {
                      int v204 = "(unnamed)";
                    }
                    double v205 = re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)(v217 + 10), &v256);
                    if (*(void *)&v256.columns[0].f64[0])
                    {
                      if (LOBYTE(v256.columns[0].f64[1])) {
                        (*(void (**)(double))(**(void **)&v256.columns[0].f64[0] + 40))(v205);
                      }
                      memset(&v256, 0, 32);
                    }

                    uint64_t v206 = [v144 jointAnimation];
                    if (v206)
                    {
                      *(void *)&v256.columns[0].f64[0] = v206;
                      re::HashTable<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::add<unsigned int &>((uint64_t)(v217 + 26), (uint64_t *)&v256, &v250);
                    }
                    *(unsigned char *)uint64_t v223 = 1;

                    re::ModelIOSkinningData::~ModelIOSkinningData((re::ModelIOSkinningData *)buf);
                    if (v232[0]) {
                      goto LABEL_196;
                    }
                  }
                  else
                  {
                    *(unsigned char *)uint64_t v223 = 0;
                    *(_OWORD *)(v223 + 8) = *(_OWORD *)&v232[8];
                    *(void *)(v223 + 24) = *(void *)&v232[24];
                    *(void *)(v223 + 48) = v234;
                    *(_OWORD *)(v223 + 32) = v233;
                    uint64_t v234 = 0;
                    *(void *)&v232[24] = 0;
                    long long v233 = 0uLL;
                  }
                  if (*(void *)&v232[24] && (v233 & 1) != 0) {
                    (*(void (**)(void))(**(void **)&v232[24] + 40))();
                  }
LABEL_196:
                  if (v235 && v239) {
                    (*(void (**)(void))(*(void *)v235 + 40))();
                  }
                  if (v240 && v244) {
                    (*(void (**)(void))(*(void *)v240 + 40))();
                  }
                  if (*(void *)v267 && *(void *)&v269[2]) {
                    (*(void (**)(void))(**(void **)v267 + 40))();
                  }
                  goto LABEL_207;
                }
                long long v189 = [v221 name];
                uint64_t v187 = v189;
                if (v189) {
                  uint64_t v190 = (const char *)[v189 UTF8String];
                }
                else {
                  uint64_t v190 = "(unnamed)";
                }
                re::DynamicString::format((re::DynamicString *)"Processing mesh \"%s\"", (re::DynamicString *)buf, v190);
                long long v194 = *(_OWORD *)buf;
                uint64_t v196 = *(void *)&v258[8];
                uint64_t v195 = *(void *)v258;
                uint64_t v197 = v223;
                *(unsigned char *)uint64_t v223 = 0;
                uint64_t v198 = 1007;
              }
              else
              {
                long long v186 = [v221 name];
                uint64_t v187 = v186;
                if (v186) {
                  uint64_t v188 = (const char *)[v186 UTF8String];
                }
                else {
                  uint64_t v188 = "(unnamed)";
                }
                re::DynamicString::format((re::DynamicString *)"Processing mesh \"%s\"", (re::DynamicString *)buf, v188);
                long long v194 = *(_OWORD *)buf;
                uint64_t v196 = *(void *)&v258[8];
                uint64_t v195 = *(void *)v258;
                uint64_t v197 = v223;
                *(unsigned char *)uint64_t v223 = 0;
                uint64_t v198 = 1006;
              }
              *(void *)(v197 + 8) = v198;
              *(void *)(v197 + 16) = &re::AnimationErrorCategory(void)::instance;
              *(_OWORD *)(v197 + 24) = v194;
              *(void *)(v197 + 40) = v195;
              *(void *)(v197 + 48) = v196;

LABEL_208:
              goto LABEL_209;
            }
            char v120 = [v220 name];
            __int16 v121 = v120;
            if (!v120)
            {
              int v122 = "(unnamed)";
              goto LABEL_117;
            }
          }
          else
          {
            id v8 = v220;
            char v120 = [v220 name];
            __int16 v121 = v120;
            id v15 = v215;
            if (!v120)
            {
              int v122 = "(unnamed)";
              goto LABEL_117;
            }
          }
          int v122 = (const char *)[v120 UTF8String];
LABEL_117:
          re::DynamicString::format((re::DynamicString *)"Processing mesh \"%s\"", (re::DynamicString *)buf, v122);
          long long v131 = *(_OWORD *)buf;
          long long v132 = *(_OWORD *)v258;
          *(unsigned char *)uint64_t v222 = 0;
          *(void *)(v222 + 8) = 1004;
          *(void *)(v222 + 16) = &re::AnimationErrorCategory(void)::instance;
          *(_OWORD *)(v222 + 24) = v131;
          *(_OWORD *)(v222 + 40) = v132;

          goto LABEL_209;
        }
        uint64_t v33 = [v8 name];
        uint64_t v31 = v33;
        if (v33) {
          uint64_t v34 = (const char *)[v33 UTF8String];
        }
        else {
          uint64_t v34 = "(unnamed)";
        }
        re::DynamicString::format((re::DynamicString *)"Processing mesh \"%s\"", (re::DynamicString *)buf, v34);
        long long v38 = *(_OWORD *)buf;
        uint64_t v40 = *(void *)&v258[8];
        uint64_t v39 = *(void *)v258;
        *(unsigned char *)a1 = 0;
        uint64_t v41 = 1003;
      }
      else
      {
        unint64_t v30 = [v8 name];
        uint64_t v31 = v30;
        if (v30) {
          uint64_t v32 = (const char *)[v30 UTF8String];
        }
        else {
          uint64_t v32 = "(unnamed)";
        }
        re::DynamicString::format((re::DynamicString *)"Processing mesh \"%s\"", (re::DynamicString *)buf, v32);
        long long v38 = *(_OWORD *)buf;
        uint64_t v40 = *(void *)&v258[8];
        uint64_t v39 = *(void *)v258;
        *(unsigned char *)a1 = 0;
        uint64_t v41 = 1002;
      }
      *(void *)(a1 + 8) = v41;
      *(void *)(a1 + 16) = &re::AnimationErrorCategory(void)::instance;
      *(_OWORD *)(a1 + 24) = v38;
      *(void *)(a1 + 40) = v39;
      *(void *)(a1 + 48) = v40;

LABEL_213:
      goto LABEL_214;
    }
  }
  else
  {
LABEL_9:
  }
  *(unsigned char *)a1 = 1;
LABEL_214:
}

float64x2_t anonymous namespace'::convertToRE(float32x4_t *this, const simd_double4x4 *a2)
{
  float32x4_t v2 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)a2->columns[1].f64), *(float64x2_t *)&a2->columns[1].f64[2]);
  float32x4_t v3 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)a2->columns[2].f64), *(float64x2_t *)&a2->columns[2].f64[2]);
  float64x2_t result = *(float64x2_t *)&a2->columns[3].f64[2];
  float32x4_t v5 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)a2->columns[3].f64), result);
  *this = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)a2->columns[0].f64), *(float64x2_t *)&a2->columns[0].f64[2]);
  this[1] = v2;
  this[2] = v3;
  this[3] = v5;
  return result;
}

double re::DynamicArray<re::ModelIOSkinningData>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(void *)a1)
      {
        uint64_t v7 = 2 * v4;
        BOOL v8 = v4 == 0;
        unint64_t v9 = 8;
        if (!v8) {
          unint64_t v9 = v7;
        }
        if (v9 <= v6) {
          unint64_t v10 = v6;
        }
        else {
          unint64_t v10 = v9;
        }
        re::DynamicArray<re::ModelIOSkinningData>::setCapacity((void *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::ModelIOSkinningData>::setCapacity((void *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    unint64_t v5 = *(void *)(a1 + 16);
  }
  uint64_t v11 = *(void *)(a1 + 32) + 224 * v5;
  long long v12 = *(_OWORD *)(a2 + 16);
  long long v13 = *(_OWORD *)(a2 + 32);
  long long v14 = *(_OWORD *)(a2 + 48);
  *(_DWORD *)(v11 + 64) = *(_DWORD *)(a2 + 64);
  *(_OWORD *)(v11 + 32) = v13;
  *(_OWORD *)(v11 + 48) = v14;
  *(_OWORD *)(v11 + 16) = v12;
  *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
  double result = 0.0;
  *(_OWORD *)(v11 + 88) = 0u;
  *(_OWORD *)(v11 + 72) = 0u;
  *(void *)(v11 + 96) = *(void *)(a2 + 96);
  uint64_t v16 = *(void *)(a2 + 80);
  *(void *)(v11 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = 0;
  uint64_t v17 = *(void *)(a2 + 88);
  *(void *)(a2 + 96) = 0;
  uint64_t v19 = *(void *)(v11 + 80);
  uint64_t v18 = *(void *)(v11 + 88);
  *(void *)(v11 + 80) = v16;
  *(void *)(v11 + 88) = v17;
  *(void *)(a2 + 80) = v19;
  *(void *)(a2 + 88) = v18;
  *(void *)(v11 + 104) = 0;
  *(void *)(v11 + 112) = 0;
  *(void *)(v11 + 120) = 0;
  uint64_t v20 = *(void *)(a2 + 112);
  *(void *)(v11 + 104) = *(void *)(a2 + 104);
  *(void *)(v11 + 112) = v20;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  uint64_t v21 = *(void *)(v11 + 120);
  *(void *)(v11 + 120) = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = v21;
  *(void *)(v11 + 128) = 0;
  *(void *)(v11 + 136) = 0;
  *(void *)(v11 + 144) = 0;
  uint64_t v22 = *(void *)(a2 + 136);
  *(void *)(v11 + 128) = *(void *)(a2 + 128);
  *(void *)(v11 + 136) = v22;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  uint64_t v23 = *(void *)(v11 + 144);
  *(void *)(v11 + 144) = *(void *)(a2 + 144);
  *(void *)(a2 + 144) = v23;
  *(void *)(v11 + 152) = 0;
  *(void *)(v11 + 160) = 0;
  *(void *)(v11 + 168) = 0;
  uint64_t v24 = *(void *)(a2 + 160);
  *(void *)(v11 + 152) = *(void *)(a2 + 152);
  *(void *)(v11 + 160) = v24;
  *(void *)(a2 + 152) = 0;
  *(void *)(a2 + 160) = 0;
  uint64_t v25 = *(void *)(v11 + 168);
  *(void *)(v11 + 168) = *(void *)(a2 + 168);
  *(void *)(a2 + 168) = v25;
  *(void *)(v11 + 176) = 0;
  *(void *)(v11 + 184) = 0;
  *(void *)(v11 + 192) = 0;
  uint64_t v26 = *(void *)(a2 + 184);
  *(void *)(v11 + 176) = *(void *)(a2 + 176);
  *(void *)(v11 + 184) = v26;
  *(void *)(a2 + 176) = 0;
  *(void *)(a2 + 184) = 0;
  uint64_t v27 = *(void *)(v11 + 192);
  *(void *)(v11 + 192) = *(void *)(a2 + 192);
  *(void *)(a2 + 192) = v27;
  *(void *)(v11 + 200) = 0;
  *(void *)(v11 + 208) = 0;
  *(void *)(v11 + 216) = 0;
  uint64_t v28 = *(void *)(a2 + 208);
  *(void *)(v11 + 200) = *(void *)(a2 + 200);
  *(void *)(v11 + 208) = v28;
  *(void *)(a2 + 200) = 0;
  *(void *)(a2 + 208) = 0;
  uint64_t v29 = *(void *)(v11 + 216);
  *(void *)(v11 + 216) = *(void *)(a2 + 216);
  *(void *)(a2 + 216) = v29;
  ++*(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::HashTable<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::add<unsigned int &>(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  unint64_t v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  unint64_t v9 = *(void *)a1;
  if (*(void *)a1)
  {
    unint64_t v9 = v8 % *(unsigned int *)(a1 + 24);
    uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 4 * v9);
    if (v10 != 0x7FFFFFFF)
    {
      uint64_t v16 = *(void *)(a1 + 16);
      if (*(void *)(v16 + 32 * v10 + 16) == v6) {
        return;
      }
      while (1)
      {
        uint64_t v10 = *(_DWORD *)(v16 + 32 * v10 + 8) & 0x7FFFFFFF;
        if (v10 == 0x7FFFFFFF) {
          break;
        }
        if (*(void *)(v16 + 32 * v10 + 16) == v6) {
          return;
        }
      }
    }
  }
  uint64_t v11 = *(unsigned int *)(a1 + 36);
  if (v11 == 0x7FFFFFFF)
  {
    uint64_t v11 = *(unsigned int *)(a1 + 32);
    int v12 = v11;
    if (v11 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long,unsigned int,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(vre::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = v8 % *(unsigned int *)(a1 + 24);
      int v12 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v12 + 1;
    uint64_t v13 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v13 + 32 * v11 + 8);
  }
  else
  {
    uint64_t v13 = *(void *)(a1 + 16);
    int v14 = *(_DWORD *)(v13 + 32 * v11 + 8);
    *(_DWORD *)(a1 + 36) = v14 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v13 + 32 * v11 + 8) = v14 | 0x80000000;
  uint64_t v15 = *(void *)(a1 + 8);
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v11 + 8) = *(_DWORD *)(*(void *)(a1 + 16) + 32 * v11 + 8) & 0x80000000 | *(_DWORD *)(v15 + 4 * v9);
  *(void *)(*(void *)(a1 + 16) + 32 * v11) = v8;
  *(void *)(*(void *)(a1 + 16) + 32 * v11 + 16) = *a2;
  *(_DWORD *)(*(void *)(a1 + 16) + 32 * v11 + 24) = *a3;
  *(_DWORD *)(v15 + 4 * vre::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = v11;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
}

void re::ModelIOSkinningData::~ModelIOSkinningData(re::ModelIOSkinningData *this)
{
}

void re::importSkeleton(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v107 = *MEMORY[0x263EF8340];
  id v3 = a1;
  unint64_t v4 = (simd_float4x4 *)"";
  v81.i64[0] = 0;
  v81.i64[1] = (uint64_t)"";
  unint64_t v5 = (unint64_t)&v82;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  memset(v88, 0, sizeof(v88));
  int v89 = 0;
  uint64_t v90 = 0x7FFFFFFFLL;
  uint64_t v6 = [v3 property:@"joints"];
  unint64_t v7 = v6;
  if (v6
    && ([(_anonymous_namespace_ *)v6 data], unint64_t v8 = objc_claimAutoreleasedReturnValue(),
                                                   v8,
                                                   v8))
  {
    unint64_t v9 = [(_anonymous_namespace_ *)v7 stringArray];
    uint64_t v10 = v9;
    if (v9)
    {
      uint64_t v72 = a2;
      unint64_t v73 = v7;
      uint64_t v74 = v9;
      unsigned int v11 = [v9 count];
      int v12 = [v3 path];
      id v13 = [v12 stringValue];
      int v14 = (_anonymous_namespace_ *)[v13 UTF8String];
      v102.columns[0].i64[0] = 0;
      v102.columns[0].i64[1] = (uint64_t)"";
      simd_float4 v15 = v102.columns[0];
      v102.columns[0].i64[0] = 0;
      v102.columns[0].i64[1] = (uint64_t)"";
      __int8 v16 = v81.i8[0];
      uint64_t v17 = v81.i64[1];
      simd_float4 v81 = v15;
      *(void *)&long long buf = v15.i64[0] & 0xFFFFFFFFFFFFFFFELL | v16 & 1;
      *((void *)&buf + 1) = v17;
      re::StringID::destroyString((re::StringID *)&buf);
      re::StringID::destroyString((re::StringID *)&v102);

      unint64_t v18 = v11;
      LODWORD(v75) = 0;
      if (v11)
      {
        unsigned int v22 = 0;
        while (1)
        {
          id v23 = [v74 objectAtIndexedSubscript:v22];
          uint64_t v24 = (_anonymous_namespace_ *)[v23 UTF8String];
          uint64_t v103 = 0;
          long long v104 = "";
          unint64_t v25 = v75;
          uint64_t v26 = *((void *)&v82 + 1);
          if (*((void *)&v82 + 1) <= (unint64_t)v75) {
            break;
          }
          uint64_t v27 = (void *)(v83 + 16 * v75);
          uint64_t v28 = v103;
          uint64_t v29 = v104;
          uint64_t v103 = 0;
          long long v104 = "";
          uint64_t v30 = v27[1];
          unint64_t v31 = v28 & 0xFFFFFFFFFFFFFFFELL | *v27 & 1;
          v27[1] = v29;
          *(void *)&long long buf = v31;
          *((void *)&buf + 1) = v30;
          *uint64_t v27 = v28;
          re::StringID::destroyString((re::StringID *)&buf);
          re::StringID::destroyString((re::StringID *)&v103);

          unint64_t v25 = v75;
          uint64_t v26 = *((void *)&v82 + 1);
          if (*((void *)&v82 + 1) <= (unint64_t)v75) {
            goto LABEL_84;
          }
          uint64_t v32 = re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<unsigned int &>((uint64_t)v88, (StringID *)(v83 + 16 * v75), &v75);
          int v33 = *(_DWORD *)v32;
          if (*(_DWORD *)v32 != v75)
          {
            uint64_t v34 = *re::pipelineLogObjects((re *)v32);
            uint64_t v32 = os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT);
            if (v32)
            {
              uint64_t v35 = v75;
              unint64_t v36 = v34;
              id v37 = [v74 objectAtIndexedSubscript:v35];
              uint64_t v38 = [v37 UTF8String];
              LODWORD(buf) = 136315138;
              *(void *)((char *)&buf + 4) = v38;
              _os_log_impl(&dword_233120000, v36, OS_LOG_TYPE_DEFAULT, "Duplicate joint name found in skeleton: '%s'\n", (uint8_t *)&buf, 0xCu);
            }
            int v33 = v75;
          }
          unsigned int v22 = v33 + 1;
          LODWORD(v75) = v22;
          if (v22 >= v11)
          {
            unint64_t v5 = 0;
            while (1)
            {
              unint64_t v25 = v84;
              if ((unint64_t)v84 <= v5) {
                goto LABEL_85;
              }
              *(_DWORD *)(*((void *)&v84 + 1) + 4 * v5) = -1;
              unint64_t v25 = *((void *)&v82 + 1);
              if (*((void *)&v82 + 1) <= v5) {
                goto LABEL_86;
              }
              uint64_t v39 = *(char **)(v83 + 16 * v5 + 8);
              uint64_t v40 = strrchr(v39, 47);
              if (v40)
              {
                uint64_t v41 = v40;
                unsigned int v42 = v39;
                while (1)
                {
                  uint64_t v103 = 0;
                  long long v104 = "";
                  uint64_t v43 = (_DWORD *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)v88, &v103);
                  if (v43) {
                    break;
                  }
                  unsigned int v42 = v104;
                  uint64_t v41 = strrchr(v104, 47);
                  uint64_t v26 = *re::pipelineLogObjects((re *)v41);
                  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v26 = v26;
                    LODWORD(buf) = 136315138;
                    *(void *)((char *)&buf + 4) = v104;
                    _os_log_impl(&dword_233120000, v26, OS_LOG_TYPE_DEFAULT, "Expected joint parent do not exist: %s, looking for its ancester", (uint8_t *)&buf, 0xCu);
                  }
                  re::StringID::destroyString((re::StringID *)&v103);
                  if (!v41) {
                    goto LABEL_25;
                  }
                }
                unint64_t v25 = v84;
                if ((unint64_t)v84 <= v5) {
                  goto LABEL_87;
                }
                *(_DWORD *)(*((void *)&v84 + 1) + 4 * v5) = *v43;
                re::StringID::destroyString((re::StringID *)&v103);
              }
LABEL_25:
              ++v5;
              unint64_t v18 = v11;
              if (v5 == v11) {
                goto LABEL_30;
              }
            }
          }
        }
        uint64_t v78 = 0;
        long long v96 = 0u;
        long long v95 = 0u;
        long long v94 = 0u;
        long long v93 = 0u;
        long long buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v102.columns[0].i32[0] = 136315906;
        *(uint64_t *)((char *)v102.columns[0].i64 + 4) = (uint64_t)"operator[]";
        v102.columns[0].i16[6] = 1024;
        *(__int32 *)((char *)&v102.columns[0].i32[3] + 2) = 468;
        v102.columns[1].i16[1] = 2048;
        *(uint64_t *)((char *)v102.columns[1].i64 + 4) = v25;
        v102.columns[1].i16[6] = 2048;
        *(uint64_t *)((char *)&v102.columns[1].i64[1] + 6) = (uint64_t)v26;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_84:
        uint64_t v103 = 0;
        long long v96 = 0u;
        long long v95 = 0u;
        long long v94 = 0u;
        long long v93 = 0u;
        long long buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v102.columns[0].i32[0] = 136315906;
        *(uint64_t *)((char *)v102.columns[0].i64 + 4) = (uint64_t)"operator[]";
        v102.columns[0].i16[6] = 1024;
        *(__int32 *)((char *)&v102.columns[0].i32[3] + 2) = 468;
        v102.columns[1].i16[1] = 2048;
        *(uint64_t *)((char *)v102.columns[1].i64 + 4) = v25;
        v102.columns[1].i16[6] = 2048;
        *(uint64_t *)((char *)&v102.columns[1].i64[1] + 6) = (uint64_t)v26;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_85:
        uint64_t v103 = 0;
        long long v96 = 0u;
        long long v95 = 0u;
        long long v94 = 0u;
        long long v93 = 0u;
        long long buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v102.columns[0].i32[0] = 136315906;
        *(uint64_t *)((char *)v102.columns[0].i64 + 4) = (uint64_t)"operator[]";
        v102.columns[0].i16[6] = 1024;
        *(__int32 *)((char *)&v102.columns[0].i32[3] + 2) = 468;
        v102.columns[1].i16[1] = 2048;
        *(uint64_t *)((char *)v102.columns[1].i64 + 4) = v5;
        v102.columns[1].i16[6] = 2048;
        *(uint64_t *)((char *)&v102.columns[1].i64[1] + 6) = v25;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_86:
        uint64_t v103 = 0;
        long long v96 = 0u;
        long long v95 = 0u;
        long long v94 = 0u;
        long long v93 = 0u;
        long long buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v102.columns[0].i32[0] = 136315906;
        *(uint64_t *)((char *)v102.columns[0].i64 + 4) = (uint64_t)"operator[]";
        v102.columns[0].i16[6] = 1024;
        *(__int32 *)((char *)&v102.columns[0].i32[3] + 2) = 468;
        v102.columns[1].i16[1] = 2048;
        *(uint64_t *)((char *)v102.columns[1].i64 + 4) = v5;
        v102.columns[1].i16[6] = 2048;
        *(uint64_t *)((char *)&v102.columns[1].i64[1] + 6) = v25;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_87:
        uint64_t v78 = 0;
        long long v96 = 0u;
        long long v95 = 0u;
        long long v94 = 0u;
        long long v93 = 0u;
        long long buf = 0u;
        os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        v102.columns[0].i32[0] = 136315906;
        *(uint64_t *)((char *)v102.columns[0].i64 + 4) = (uint64_t)"operator[]";
        v102.columns[0].i16[6] = 1024;
        *(__int32 *)((char *)&v102.columns[0].i32[3] + 2) = 468;
        v102.columns[1].i16[1] = 2048;
        *(uint64_t *)((char *)v102.columns[1].i64 + 4) = v5;
        v102.columns[1].i16[6] = 2048;
        *(uint64_t *)((char *)&v102.columns[1].i64[1] + 6) = v25;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_88;
      }
LABEL_30:
      uint64_t v48 = [v3 property:@"restTransforms"];
      uint64_t v78 = 0;
      uint64_t v79 = 0;
      unint64_t v80 = 0;
      if (v48
        && ([(_anonymous_namespace_ *)v48 data], (uint64_t v49 = objc_claimAutoreleasedReturnValue()) != 0)
        && (double v50 = (void *)v49,
            uint64_t v51 = v80,
            uint64_t v52 = [(_anonymous_namespace_ *)v48 double4x4Array:v80 maxCount:v18],
            v50,
            v52 == v18))
      {
        unint64_t v4 = &v102;
        if (v18)
        {
          unint64_t v25 = 0;
          uint64_t v26 = v79;
          uint64_t v54 = 32;
          while (v26 != v25)
          {
            unint64_t v5 = *((void *)&v85 + 1);
            if (*((void *)&v85 + 1) <= v25) {
              goto LABEL_89;
            }
            re::decomposeScaleRotationTranslation<float>((uint64_t)&v102, (int32x4_t *)(v86 + v54 - 32), (void *)(v86 + v54 - 16), (_OWORD *)(v86 + v54));
            ++v25;
            v54 += 48;
            ++v51;
            if (v18 == v25) {
              goto LABEL_38;
            }
          }
LABEL_88:
          uint64_t v103 = 0;
          long long v96 = 0u;
          long long v95 = 0u;
          long long v94 = 0u;
          long long v93 = 0u;
          long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          v102.columns[0].i32[0] = 136315906;
          *(uint64_t *)((char *)v4->columns[0].i64 + 4) = (uint64_t)"operator[]";
          v102.columns[0].i16[6] = 1024;
          *(__int32 *)((char *)&v4->columns[0].i32[3] + 2) = 468;
          v102.columns[1].i16[1] = 2048;
          *(uint64_t *)((char *)v4->columns[1].i64 + 4) = (uint64_t)v26;
          v102.columns[1].i16[6] = 2048;
          *(uint64_t *)((char *)&v4->columns[1].i64[1] + 6) = (uint64_t)v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_89:
          uint64_t v75 = 0;
          long long v96 = 0u;
          long long v95 = 0u;
          long long v94 = 0u;
          long long v93 = 0u;
          long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v103) = 136315906;
          *(uint64_t *)((char *)v4[1].columns[0].i64 + 4) = (uint64_t)"operator[]";
          WORD2(v104) = 1024;
          *(__int32 *)((char *)&v4[1].columns[0].i32[3] + 2) = 468;
          __int16 v105 = 2048;
          *(uint64_t *)((char *)v4[1].columns[1].i64 + 4) = v25;
          __int16 v106 = 2048;
          *(uint64_t *)((char *)&v4[1].columns[1].i64[1] + 6) = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_90:
          uint64_t v103 = 0;
          long long v96 = 0u;
          long long v95 = 0u;
          long long v94 = 0u;
          long long v93 = 0u;
          long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          v102.columns[0].i32[0] = 136315906;
          *(uint64_t *)((char *)v4->columns[0].i64 + 4) = (uint64_t)"operator[]";
          v102.columns[0].i16[6] = 1024;
          *(__int32 *)((char *)&v4->columns[0].i32[3] + 2) = 468;
          v102.columns[1].i16[1] = 2048;
          *(uint64_t *)((char *)v4->columns[1].i64 + 4) = (uint64_t)v26;
          v102.columns[1].i16[6] = 2048;
          *(uint64_t *)((char *)&v4->columns[1].i64[1] + 6) = (uint64_t)v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_91:
          uint64_t v91 = 0;
          long long v96 = 0u;
          long long v95 = 0u;
          long long v94 = 0u;
          long long v93 = 0u;
          long long buf = 0u;
          os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          LODWORD(v103) = 136315906;
          *(uint64_t *)((char *)v4[1].columns[0].i64 + 4) = (uint64_t)"operator[]";
          WORD2(v104) = 1024;
          *(__int32 *)((char *)&v4[1].columns[0].i32[3] + 2) = 468;
          __int16 v105 = 2048;
          *(uint64_t *)((char *)v4[1].columns[1].i64 + 4) = v25;
          __int16 v106 = 2048;
          *(uint64_t *)((char *)&v4[1].columns[1].i64[1] + 6) = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_38:
        long long v55 = [v3 property:@"bindTransforms"];
        uint64_t v75 = 0;
        unint64_t v76 = 0;
        uint64_t v77 = 0;
        if (v55
          && ([(_anonymous_namespace_ *)v55 data], (uint64_t v56 = objc_claimAutoreleasedReturnValue()) != 0)
          && (unint64_t v57 = (void *)v56,
              unint64_t v58 = v77,
              uint64_t v59 = [(_anonymous_namespace_ *)v55 double4x4Array:v77 maxCount:v18],
              v57,
              v59 == v18))
        {
          if (v18)
          {
            unint64_t v25 = 0;
            uint64_t v26 = v76;
            uint64_t v61 = 32;
            while (v26 != v25)
            {
              simd_float4x4 v108 = __invert_f4(v102);
              unint64_t v5 = v87;
              if ((unint64_t)v87 <= v25) {
                goto LABEL_91;
              }
              *(simd_float4x4 *)(*((void *)&v87 + 1) + v61 - 32) = v108;
              ++v25;
              v61 += 64;
              ++v58;
              if (v18 == v25) {
                goto LABEL_46;
              }
            }
            goto LABEL_90;
          }
LABEL_46:
          re::types::Ok<re::GeomSkeleton>::Ok((uint64_t)&buf, (uint64_t *)&v81);
          re::Result<re::GeomSkeleton,re::DetailedError>::Result(v72, (uint64_t *)&buf);
          v62.n128_f64[0] = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v101);
          unint64_t v7 = v73;
          if (v98)
          {
            if (v99)
            {
              (*(void (**)(double))(*(void *)v98 + 40))(v62.n128_f64[0]);
              uint64_t v99 = 0;
              uint64_t v100 = 0;
            }
            uint64_t v98 = 0;
          }
          if ((void)v96)
          {
            if (*((void *)&v96 + 1))
            {
              (*(void (**)(__n128))(*(void *)v96 + 40))(v62);
              *((void *)&v96 + 1) = 0;
              uint64_t v97 = 0;
            }
            *(void *)&long long v96 = 0;
          }
          if (*((void *)&v94 + 1))
          {
            if ((void)v95)
            {
              (*(void (**)(__n128))(**((void **)&v94 + 1) + 40))(v62);
              long long v95 = 0uLL;
            }
            *((void *)&v94 + 1) = 0;
          }
          re::FixedArray<re::StringID>::deinit(&v93);
          re::StringID::destroyString((re::StringID *)&buf);
        }
        else
        {
          id v68 = [v3 path];
          id v69 = [v68 stringValue];
          re::DynamicString::format((re::DynamicString *)"Skeleton \"%s\" does not have bind transforms.", (re::DynamicString *)&buf, [v69 UTF8String]);
          long long v70 = buf;
          long long v71 = v93;
          *(unsigned char *)uint64_t v72 = 0;
          *(void *)(v72 + 8) = 1004;
          *(void *)(v72 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
          *(_OWORD *)(v72 + 24) = v70;
          *(_OWORD *)(v72 + 40) = v71;

          unint64_t v7 = v73;
        }
        if (v75 && v76) {
          (*(void (**)(void))(*(void *)v75 + 40))();
        }
      }
      else
      {
        unint64_t v63 = [v3 path];
        id v64 = [v63 stringValue];
        re::DynamicString::format((re::DynamicString *)"Skeleton \"%s\" does not have rest transforms.", (re::DynamicString *)&buf, [v64 UTF8String]);
        long long v65 = buf;
        long long v66 = v93;
        *(unsigned char *)uint64_t v72 = 0;
        *(void *)(v72 + 8) = 1028;
        *(void *)(v72 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
        *(_OWORD *)(v72 + 24) = v65;
        *(_OWORD *)(v72 + 40) = v66;

        unint64_t v7 = v73;
      }
      if (v78 && v79) {
        (*(void (**)(void))(*(void *)v78 + 40))();
      }

      uint64_t v10 = v74;
    }
    else
    {
      long long v46 = buf;
      long long v47 = v93;
      *(unsigned char *)a2 = 0;
      *(void *)(a2 + 8) = 1003;
      *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
      *(_OWORD *)(a2 + 24) = v46;
      *(_OWORD *)(a2 + 40) = v47;
    }
  }
  else
  {
    long long v44 = buf;
    long long v45 = v93;
    *(unsigned char *)a2 = 0;
    *(void *)(a2 + 8) = 1003;
    *(void *)(a2 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a2 + 24) = v44;
    *(_OWORD *)(a2 + 40) = v45;
  }

  v67.n128_f64[0] = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v88);
  if (*((void *)&v86 + 1))
  {
    if ((void)v87)
    {
      (*(void (**)(double))(**((void **)&v86 + 1) + 40))(v67.n128_f64[0]);
      long long v87 = 0uLL;
    }
    *((void *)&v86 + 1) = 0;
  }
  if ((void)v85)
  {
    if (*((void *)&v85 + 1))
    {
      (*(void (**)(__n128))(*(void *)v85 + 40))(v67);
      *((void *)&v85 + 1) = 0;
      *(void *)&long long v86 = 0;
    }
    *(void *)&long long v85 = 0;
  }
  if (*((void *)&v83 + 1))
  {
    if ((void)v84)
    {
      (*(void (**)(__n128))(**((void **)&v83 + 1) + 40))(v67);
      long long v84 = 0uLL;
    }
    *((void *)&v83 + 1) = 0;
  }
  re::FixedArray<re::StringID>::deinit(&v82);
  re::StringID::destroyString((re::StringID *)&v81);
}

void re::importSkeletalAnimation(void *a1@<X0>, char a2@<W1>, uint64_t a3@<X8>, double a4@<D0>)
{
  uint64_t v146 = *MEMORY[0x263EF8340];
  id v7 = a1;
  unint64_t v8 = [v7 type];
  unint64_t v9 = (void *)*MEMORY[0x263F84008];

  if (v8 != v9)
  {
    uint64_t v10 = [v7 path];
    id v11 = [v10 stringValue];
    uint64_t v12 = [v11 UTF8String];
    id v13 = [v7 type];
    re::DynamicString::format((re::DynamicString *)"Node \"%s\" has unknown animation type: %s.", (re::DynamicString *)&v115, v12, [v13 UTF8String]);
    long long v14 = v115;
    uint64_t v15 = v116;
    uint64_t v16 = v117;
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 1018;
    *(void *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a3 + 24) = v14;
    *(void *)(a3 + 40) = v15;
    *(void *)(a3 + 48) = v16;

    goto LABEL_45;
  }
  re::TimelineAssetData::TimelineAssetData((uint64_t)&v115, 34);
  __int16 v120 = 256;
  uint64_t v125 = 0;
  long long v122 = 0u;
  long long v123 = 0u;
  int v121 = 1023969417;
  int v124 = 0;
  *(void *)&long long v115 = &unk_26E6D0D68;
  uint64_t v128 = 0;
  memset(v126, 0, sizeof(v126));
  int v127 = 0;
  __int16 v129 = 257;
  BOOL v130 = 1;
  uint64_t v17 = [v7 property:@"rotations"];
  unint64_t v18 = [v7 property:@"translations"];
  uint64_t v19 = [v7 property:@"scales"];
  uint64_t v20 = (void *)v19;
  if (v17 && v18 && v19)
  {
    if ([v17 isAnimated])
    {
      uint64_t v103 = [v17 timeSamples];
      uint64_t v21 = [v103 arraySize];
    }
    else
    {
      uint64_t v21 = 0;
      uint64_t v103 = 0;
    }
    if ([v18 isAnimated])
    {
      simd_float4x4 v102 = [v18 timeSamples];
      uint64_t v27 = [v102 arraySize];
    }
    else
    {
      uint64_t v27 = 0;
      simd_float4x4 v102 = 0;
    }
    long long v104 = v20;
    if ([v20 isAnimated])
    {
      uint64_t v28 = [v20 timeSamples];
      uint64_t v100 = [v28 arraySize];
    }
    else
    {
      uint64_t v100 = 0;
      uint64_t v28 = 0;
    }
    __int16 v105 = [v7 property:@"joints"];
    if (!v105
      || ([v105 data], uint64_t v29 = objc_claimAutoreleasedReturnValue(), v29, !v29))
    {
      id v37 = [v7 path];
      id v38 = [v37 stringValue];
      re::DynamicString::format((re::DynamicString *)"Animation node \"%s\" do not specify valid joint names.", (re::DynamicString *)&v132, [v38 UTF8String]);
      long long v39 = v132;
      long long v40 = v133;
      *(unsigned char *)a3 = 0;
      *(void *)(a3 + 8) = 1018;
      *(void *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
      *(_OWORD *)(a3 + 24) = v39;
      *(_OWORD *)(a3 + 40) = v40;

      unsigned int v22 = v104;
LABEL_39:

      goto LABEL_40;
    }
    uint64_t v98 = [v105 stringArray];
    uint64_t v30 = (_anonymous_namespace_ *)[v98 count];
    unint64_t v31 = (unint64_t)v30;
    uint64_t v99 = v17;
    if (v21)
    {
      if (v30 != (_anonymous_namespace_ *)[v17 arraySizeAtTime:1.79769313e308]) {
        goto LABEL_37;
      }
      [v103 dataNoCopy];
      long long v95 = v28;
      uint64_t v32 = v18;
      id v33 = objc_claimAutoreleasedReturnValue();
      uint64_t v34 = (double *)[v33 bytes];
      double v35 = fmin(*v34, 1.79769313e308);
      double v36 = fmax(v34[v21 - 1], -1.79769313e308);

      unint64_t v18 = v32;
      uint64_t v28 = v95;
    }
    else
    {
      double v35 = 1.79769313e308;
      double v36 = -1.79769313e308;
    }
    if (v27)
    {
      if (v31 != [v18 arraySizeAtTime:v35]) {
        goto LABEL_37;
      }
      [v102 dataNoCopy];
      long long v96 = v28;
      uint64_t v41 = v18;
      id v42 = objc_claimAutoreleasedReturnValue();
      uint64_t v43 = (double *)[v42 bytes];
      if (v35 > *v43) {
        double v35 = *v43;
      }
      long long v44 = &v43[v27];
      if (v36 < *(v44 - 1)) {
        double v36 = *(v44 - 1);
      }

      unint64_t v18 = v41;
      uint64_t v28 = v96;
    }
    if (!v100)
    {
      if (!(v27 | v21))
      {
        double v36 = 0.0;
        double v35 = 0.0;
      }
      goto LABEL_48;
    }
    if (v31 == [v104 arraySizeAtTime:v35])
    {
      id v45 = [v28 dataNoCopy];
      long long v46 = (double *)[v45 bytes];
      if (v35 > *v46) {
        double v35 = *v46;
      }
      long long v47 = &v46[v100];
      if (v36 < *(v47 - 1)) {
        double v36 = *(v47 - 1);
      }

LABEL_48:
      uint64_t v97 = v28;
      int v101 = v18;
      if (v35 >= v36) {
        double v36 = v35;
      }
      float v53 = a4;
      int v121 = LODWORD(v53);
      if (v53 <= 0.0016667
        || fabsf(v53 + -0.0016667) < (float)((float)((float)(fabsf(v53) + 0.0016667) + 1.0) * 0.00001)
        || (a2 & 1) == 0)
      {
        HIBYTE(v120) = 0;
      }
      uint64_t v54 = (char *)&v126[1] + 8;
      long long v55 = (_anonymous_namespace_ *)re::DynamicArray<re::StringID>::setCapacity((void *)&v126[1] + 1, v31);
      ++v127;
      if (v31)
      {
        for (uint64_t i = 0; i != v31; ++i)
        {
          id v57 = [v98 objectAtIndexedSubscript:i];
          unint64_t v58 = (_anonymous_namespace_ *)[v57 UTF8String];
          *(void *)&long long v132 = 0;
          *((void *)&v132 + 1) = "";
          re::DynamicArray<re::StringID>::add((void *)&v126[1] + 1, (uint64_t *)&v132);
          re::StringID::destroyString((re::StringID *)&v132);
        }
      }
      *(float *)&unsigned int v59 = v35 * a4;
      *(float *)&unsigned int v60 = v36 * a4;
      *(void *)&long long v122 = __PAIR64__(v60, v59);
      LODWORD(v54) = vcvtpd_u64_f64(v36 - v35 + 1.0);
      uint64_t v112 = 0;
      unint64_t v113 = 0;
      uint64_t v114 = 0;
      uint64_t v109 = 0;
      unint64_t v110 = 0;
      uint64_t v111 = 0;
      uint64_t v106 = 0;
      unint64_t v107 = 0;
      uint64_t v108 = 0;
      re::DynamicArray<re::SkeletalPoseAssetData>::resize((void *)&v122 + 1, (unint64_t)v54);
      unint64_t v18 = v101;
      if (*((void *)&v123 + 1))
      {
        unint64_t v63 = 0;
        while (1)
        {
          unsigned int v22 = v104;
          unint64_t v64 = [v104 arraySizeAtTime:v35 + (double)v63];
          unint64_t v65 = [v17 arraySizeAtTime:v35 + (double)v63];
          long long v66 = (_anonymous_namespace_ *)[v18 arraySizeAtTime:v35 + (double)v63];
          BOOL v67 = v64 > v31 || v65 > v31;
          if (v67 || (unint64_t)v66 > v31) {
            break;
          }
          unint64_t v69 = [v104 float3Array:v111 maxCount:v31 atTime:v35 + (double)v63];
          unint64_t v70 = [v17 quatfArray:v114 maxCount:v31 atTime:v35 + (double)v63];
          long long v71 = (_anonymous_namespace_ *)[v18 float3Array:v108 maxCount:v31 atTime:v35 + (double)v63];
          uint64_t v72 = v71;
          if (v69 <= v70) {
            unint64_t v73 = v70;
          }
          else {
            unint64_t v73 = v69;
          }
          if (v73 <= (unint64_t)v71) {
            uint64_t v74 = v71;
          }
          else {
            uint64_t v74 = (_anonymous_namespace_ *)v73;
          }
          if (v69) {
            BOOL v75 = v69 == (void)v74;
          }
          else {
            BOOL v75 = 1;
          }
          if (!v75
            || (v70 ? (BOOL v76 = v70 == (void)v74) : (BOOL v76 = 1),
                !v76 || (v71 ? (BOOL v77 = (unint64_t)v71 >= v73) : (BOOL v77 = 1), !v77)))
          {
            int v89 = [v7 path];
            id v90 = [v89 stringValue];
            re::DynamicString::format((re::DynamicString *)"Sample %ld in node \"%s\" has: Total Scales = %ld, Total Rotations = %ld, Total Translations = %ld", (re::DynamicString *)&v132, v63, [v90 UTF8String], v69, v70, v72);
            long long v91 = v132;
            long long v92 = v133;
            *(unsigned char *)a3 = 0;
            *(void *)(a3 + 8) = 1027;
            *(void *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
            *(_OWORD *)(a3 + 24) = v91;
            *(_OWORD *)(a3 + 40) = v92;

            unint64_t v18 = v101;
            unsigned int v22 = v104;
            goto LABEL_104;
          }
          LOBYTE(v12re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = v69 != 0;
          HIBYTE(v12re::HashTable<re::WeakStringID,re::mtl::CommandQueue,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,false,false>::deinit((uint64_t *)this + 9) = v70 != 0;
          BOOL v130 = v71 != 0;
          unint64_t v78 = *((void *)&v123 + 1);
          if (*((void *)&v123 + 1) <= v63) {
            goto LABEL_119;
          }
          uint64_t v79 = (void *)(v125 + 24 * v63);
          unint64_t v18 = v101;
          if (v31)
          {
            uint64_t v80 = 0;
            unint64_t v78 = 0;
            while (1)
            {
              unint64_t v81 = v110;
              if (v110 <= v78) {
                break;
              }
              unint64_t v81 = v113;
              if (v113 <= v78) {
                goto LABEL_115;
              }
              unint64_t v81 = v107;
              if (v107 <= v78) {
                goto LABEL_116;
              }
              unint64_t v81 = *((void *)&v123 + 1);
              if (*((void *)&v123 + 1) <= v63) {
                goto LABEL_117;
              }
              uint64_t v82 = v125 + 24 * v63;
              unint64_t v81 = *(void *)(v82 + 8);
              if (v81 <= v78) {
                goto LABEL_118;
              }
              uint64_t v83 = *(void *)(v111 + 16 * v78 + 8);
              uint64_t v84 = *(void *)(v114 + 16 * v78);
              uint64_t v85 = *(void *)(v114 + 16 * v78 + 8);
              uint64_t v86 = *(void *)(v108 + 16 * v78);
              uint64_t v87 = *(void *)(v108 + 16 * v78 + 8);
              __int16 v88 = (void *)(*(void *)(v82 + 16) + v80);
              *__int16 v88 = *(void *)(v111 + 16 * v78);
              v88[1] = v83;
              v88[2] = v84;
              v88[3] = v85;
              uint64_t v88[4] = v86;
              v88[5] = v87;
              ++v78;
              v80 += 48;
              if (v31 == v78) {
                goto LABEL_96;
              }
            }
            uint64_t v131 = 0;
            long long v133 = 0u;
            memset(v134, 0, sizeof(v134));
            long long v132 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v138 = 136315906;
            long long v139 = "operator[]";
            __int16 v140 = 1024;
            int v141 = 468;
            __int16 v142 = 2048;
            unint64_t v143 = v78;
            __int16 v144 = 2048;
            unint64_t v145 = v81;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_115:
            uint64_t v131 = 0;
            long long v133 = 0u;
            memset(v134, 0, sizeof(v134));
            long long v132 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v138 = 136315906;
            long long v139 = "operator[]";
            __int16 v140 = 1024;
            int v141 = 468;
            __int16 v142 = 2048;
            unint64_t v143 = v78;
            __int16 v144 = 2048;
            unint64_t v145 = v81;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_116:
            uint64_t v131 = 0;
            long long v133 = 0u;
            memset(v134, 0, sizeof(v134));
            long long v132 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v138 = 136315906;
            long long v139 = "operator[]";
            __int16 v140 = 1024;
            int v141 = 468;
            __int16 v142 = 2048;
            unint64_t v143 = v78;
            __int16 v144 = 2048;
            unint64_t v145 = v81;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_117:
            uint64_t v131 = 0;
            long long v133 = 0u;
            memset(v134, 0, sizeof(v134));
            long long v132 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v138 = 136315906;
            long long v139 = "operator[]";
            __int16 v140 = 1024;
            int v141 = 789;
            __int16 v142 = 2048;
            unint64_t v143 = v63;
            __int16 v144 = 2048;
            unint64_t v145 = v81;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_118:
            uint64_t v131 = 0;
            long long v133 = 0u;
            memset(v134, 0, sizeof(v134));
            long long v132 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v138 = 136315906;
            long long v139 = "operator[]";
            __int16 v140 = 1024;
            int v141 = 468;
            __int16 v142 = 2048;
            unint64_t v143 = v78;
            __int16 v144 = 2048;
            unint64_t v145 = v81;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_119:
            uint64_t v131 = 0;
            long long v133 = 0u;
            memset(v134, 0, sizeof(v134));
            long long v132 = 0u;
            os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            int v138 = 136315906;
            long long v139 = "operator[]";
            __int16 v140 = 1024;
            int v141 = 789;
            __int16 v142 = 2048;
            unint64_t v143 = v63;
            __int16 v144 = 2048;
            unint64_t v145 = v78;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
LABEL_96:
          if (++v63 >= *((void *)&v123 + 1)) {
            goto LABEL_97;
          }
        }
        long long v93 = v132;
        long long v94 = v133;
        *(unsigned char *)a3 = 0;
        *(void *)(a3 + 8) = 1027;
        *(void *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
        *(_OWORD *)(a3 + 24) = v93;
        *(_OWORD *)(a3 + 40) = v94;
LABEL_104:
        uint64_t v28 = v97;
        uint64_t v52 = v98;
      }
      else
      {
LABEL_97:
        re::types::Ok<re::SkeletalPoseSampledAnimationAssetData>::Ok((uint64_t)&v132, (uint64_t)&v115);
        re::Result<re::SkeletalPoseSampledAnimationAssetData,re::DetailedError>::Result(a3, (uint64_t)&v132);
        re::DynamicArray<re::StringID>::deinit((uint64_t)&v137);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v136);
        *(void *)&long long v132 = &unk_26E6D0DD8;
        re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)&v135);
        *(void *)&long long v132 = &unk_26E6D3730;
        unsigned int v22 = v104;
        uint64_t v52 = v98;
        if (v134[1])
        {
          if (v134[2]) {
            (*(void (**)(void))(*(void *)v134[1] + 40))();
          }
          memset(&v134[1], 0, 32);
        }
        re::StringID::destroyString((re::StringID *)((char *)&v133 + 8));
        uint64_t v28 = v97;
      }
      if (v106 && v107) {
        (*(void (**)(void))(*(void *)v106 + 40))();
      }
      if (v109 && v110) {
        (*(void (**)(void))(*(void *)v109 + 40))();
      }
      if (v112 && v113) {
        (*(void (**)(void))(*(void *)v112 + 40))();
      }
      goto LABEL_38;
    }
LABEL_37:
    uint64_t v48 = [v7 path];
    id v49 = [v48 stringValue];
    re::DynamicString::format((re::DynamicString *)"Processing animation \"%s\"", (re::DynamicString *)&v132, [v49 UTF8String]);
    long long v50 = v132;
    long long v51 = v133;
    *(unsigned char *)a3 = 0;
    *(void *)(a3 + 8) = 1018;
    *(void *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a3 + 24) = v50;
    *(_OWORD *)(a3 + 40) = v51;

    unsigned int v22 = v104;
    uint64_t v52 = v98;
LABEL_38:

    uint64_t v17 = v99;
    goto LABEL_39;
  }
  [v7 path];
  v23 = unsigned int v22 = v20;
  id v24 = [v23 stringValue];
  re::DynamicString::format((re::DynamicString *)"Processing animation \"%s\"", (re::DynamicString *)&v132, [v24 UTF8String]);
  long long v25 = v132;
  long long v26 = v133;
  *(unsigned char *)a3 = 0;
  *(void *)(a3 + 8) = 1018;
  *(void *)(a3 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(a3 + 24) = v25;
  *(_OWORD *)(a3 + 40) = v26;

LABEL_40:
  re::DynamicArray<re::StringID>::deinit((uint64_t)&v126[1] + 8);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v126);
  *(void *)&long long v115 = &unk_26E6D0DD8;
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)&v122 + 8);
  *(void *)&long long v115 = &unk_26E6D3730;
  if ((void)v118)
  {
    if (BYTE8(v118)) {
      (*(void (**)(void))(*(void *)v118 + 40))();
    }
    long long v118 = 0u;
    long long v119 = 0u;
  }
  re::StringID::destroyString((re::StringID *)&v117);
LABEL_45:
}

void processAnimationObject(void *a1@<X0>, void *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v196 = *MEMORY[0x263EF8340];
  id v7 = a1;
  if (!v7)
  {
    StringID v123 = (StringID)v178;
    long long v124 = v179;
    *(unsigned char *)a4 = 0;
    *(void *)(a4 + 8) = 1012;
    *(void *)(a4 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
    *(StringID *)(a4 + 24) = v123;
    *(_OWORD *)(a4 + 40) = v124;
    goto LABEL_113;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
LABEL_112:
    *(unsigned char *)a4 = 1;
    goto LABEL_113;
  }
  float32x4_t v152 = a2;
  unint64_t v8 = (unint64_t)v7;
  unint64_t v9 = [(id)v8 rotations];
  uint64_t v10 = [v9 keyTimes];
  uint64_t v11 = [v10 count];

  uint64_t v12 = [(id)v8 translations];
  id v13 = [v12 keyTimes];
  uint64_t v14 = [v13 count];

  uint64_t v15 = [(id)v8 scales];
  uint64_t v16 = [v15 keyTimes];
  uint64_t v17 = [v16 count];

  if (v11 != v14 || v14 != v17)
  {
    uint64_t v125 = [(id)v8 name];
    unint64_t v126 = v125;
    if (v125) {
      int v127 = (const char *)[v125 UTF8String];
    }
    else {
      int v127 = "(unnamed)";
    }
    re::DynamicString::format((re::DynamicString *)"Processing node \"%s\"", (re::DynamicString *)&v178, v127);
    StringID v130 = (StringID)v178;
    uint64_t v132 = *((void *)&v179 + 1);
    uint64_t v131 = v179;
    *(unsigned char *)a4 = 0;
    uint64_t v133 = 1025;
    goto LABEL_76;
  }
  if (!*(void *)(a3 + 208)) {
    goto LABEL_70;
  }
  unint64_t v18 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) >> 27));
  uint64_t v19 = *(unsigned int *)(*(void *)(a3 + 216) + 4 * ((v18 ^ (v18 >> 31)) % *(unsigned int *)(a3 + 232)));
  if (v19 == 0x7FFFFFFF) {
    goto LABEL_70;
  }
  uint64_t v20 = *(void *)(a3 + 224);
  while (*(void *)(v20 + 32 * v19 + 16) != v8)
  {
    uint64_t v19 = *(_DWORD *)(v20 + 32 * v19 + 8) & 0x7FFFFFFF;
    if (v19 == 0x7FFFFFFF) {
      goto LABEL_70;
    }
  }
  uint64_t v21 = *(unsigned int *)(v20 + 32 * v19 + 24);
  if (v21 == -1)
  {
LABEL_70:
    uint64_t v128 = [(id)v8 name];
    unint64_t v126 = v128;
    if (v128) {
      __int16 v129 = (const char *)[v128 UTF8String];
    }
    else {
      __int16 v129 = "(unnamed)";
    }
    re::DynamicString::format((re::DynamicString *)"Skeleton not found for node \"%s\"", (re::DynamicString *)&v178, v129);
    StringID v130 = (StringID)v178;
    uint64_t v132 = *((void *)&v179 + 1);
    uint64_t v131 = v179;
    *(unsigned char *)a4 = 0;
    uint64_t v133 = 1026;
LABEL_76:
    *(void *)(a4 + 8) = v133;
    *(void *)(a4 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
    *(StringID *)(a4 + 24) = v130;
    *(void *)(a4 + 40) = v131;
    *(void *)(a4 + 48) = v132;

    goto LABEL_113;
  }
  uint64_t v146 = v21;
  id v147 = v7;
  unsigned int v22 = [(id)v8 jointPaths];
  unint64_t v23 = [v22 count];

  id v24 = [(id)v8 rotations];
  [v24 minimumTime];
  float v26 = v25;

  uint64_t v27 = [(id)v8 rotations];
  [v27 maximumTime];
  float v29 = v28;

  uint64_t v30 = [(id)v8 translations];
  [v30 minimumTime];
  float v32 = v31;
  if (v26 > v32) {
    float v26 = v32;
  }

  id v33 = [(id)v8 scales];
  [v33 minimumTime];
  float v35 = v34;
  if (v26 > v35) {
    float v26 = v35;
  }

  double v36 = [(id)v8 translations];
  [v36 maximumTime];
  float v38 = v37;
  if (v29 < v38) {
    float v29 = v38;
  }

  int v153 = (void *)v8;
  long long v39 = [(id)v8 scales];
  [v39 maximumTime];
  float v41 = v40;
  if (v29 < v41) {
    float v29 = v41;
  }

  id v42 = (_anonymous_namespace_ *)re::Timeline::Timeline((uint64_t)v167, 34);
  __int16 v171 = 256;
  long long v173 = 0u;
  long long v174 = 0u;
  v167[0] = &unk_26E6C1190;
  __int16 v175 = 257;
  char v176 = 1;
  unint64_t v148 = a3;
  float v43 = *(double *)(a3 + 344);
  float v172 = v43;
  uint64_t v164 = 0;
  unint64_t v165 = 0;
  uint64_t v166 = 0;
  if (v23)
  {
    long long v44 = 0;
    unint64_t v45 = 0;
    while (1)
    {
      long long v46 = [v153 jointPaths];
      id v47 = [v46 objectAtIndexedSubscript:v45];
      uint64_t v48 = (_anonymous_namespace_ *)[v47 UTF8String];
      uint64_t v160 = 0;
      long long v161 = "";
      unint64_t i = v165;
      if (v165 <= v45) {
        break;
      }
      long long v50 = (uint64_t *)&v44[v166];
      uint64_t v51 = v160;
      uint64_t v52 = v161;
      uint64_t v160 = 0;
      long long v161 = "";
      float v53 = *(char **)&v44[v166 + 8];
      unint64_t v54 = v51 & 0xFFFFFFFFFFFFFFFELL | *(void *)&v44[v166] & 1;
      v50[1] = (uint64_t)v52;
      *(void *)&unsigned long long v178 = v54;
      *((void *)&v178 + 1) = v53;
      *long long v50 = v51;
      re::StringID::destroyString((re::StringID *)&v178);
      re::StringID::destroyString((re::StringID *)&v160);

      ++v45;
      v44 += 16;
      if (v23 == v45) {
        goto LABEL_23;
      }
    }
    uint64_t v157 = 0;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    unsigned long long v178 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v188 = 136315906;
    long long v189 = "operator[]";
    __int16 v190 = 1024;
    int v191 = 468;
    __int16 v192 = 2048;
    unint64_t v193 = v45;
    __int16 v194 = 2048;
    unint64_t v195 = i;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_115:
    uint64_t v177 = 0;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    unsigned long long v178 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v188 = 136315906;
    long long v189 = "operator[]";
    __int16 v190 = 1024;
    int v191 = 468;
    __int16 v192 = 2048;
    unint64_t v193 = i;
    __int16 v194 = 2048;
    unint64_t v195 = (unint64_t)v44;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_116:
    uint64_t v177 = 0;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    unsigned long long v178 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v188 = 136315906;
    long long v189 = "operator[]";
    __int16 v190 = 1024;
    int v191 = 468;
    __int16 v192 = 2048;
    unint64_t v193 = i;
    __int16 v194 = 2048;
    unint64_t v195 = (unint64_t)v44;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_117:
    uint64_t v177 = 0;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    unsigned long long v178 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v188 = 136315906;
    long long v189 = "operator[]";
    __int16 v190 = 1024;
    int v191 = 468;
    __int16 v192 = 2048;
    unint64_t v193 = i;
    __int16 v194 = 2048;
    unint64_t v195 = (unint64_t)v44;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_118:
    re::internal::assertLog((re::internal *)4, v108, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 454);
    _os_crash();
    __break(1u);
LABEL_119:
    uint64_t v177 = 0;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    unsigned long long v178 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v188 = 136315906;
    long long v189 = "operator[]";
    __int16 v190 = 1024;
    int v191 = 468;
    __int16 v192 = 2048;
    unint64_t v193 = i;
    __int16 v194 = 2048;
    unint64_t v195 = (unint64_t)v44;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_23:
  long long v186 = 0u;
  long long v187 = 0u;
  long long v184 = 0u;
  long long v185 = 0u;
  long long v182 = 0u;
  long long v183 = 0u;
  long long v180 = 0u;
  long long v181 = 0u;
  *(void *)&unsigned long long v178 = 0;
  long long v179 = 0u;
  *((void *)&v178 + 1) = "";
  *(void *)&long long v187 = 0x7FFFFFFF00000000;
  re::make::shared::object<re::SkeletalPoseJointDefinition,re::FixedArray<re::StringID>,re::Skeleton>((re *)&v164, (const StringID *)&v178, &v163);
  re::Skeleton::~Skeleton((re::Skeleton *)&v178);
  float v55 = fmaxf(0.0 - v26, 0.0);
  *(float *)&long long v173 = v26 + v55;
  *((float *)&v173 + 1) = v55 + v29;
  double v56 = *(double *)(v148 + 344);
  double v57 = (float)((float)(v55 + v29) - (float)(v26 + v55)) / v56;
  unint64_t v58 = vcvtmd_u64_f64(v57);
  unint64_t v151 = v58 + 1;
  double v59 = v57 - floor(v57);
  unsigned int v60 = (_anonymous_namespace_ *)re::FixedArray<re::SkeletalPose>::deinit((void *)&v173 + 1);
  unint64_t v150 = v58;
  if (v59 <= v56 * 0.01) {
    unint64_t v61 = v58 + 1;
  }
  else {
    unint64_t v61 = v58 + 2;
  }
  if ((void)v174)
  {
    unint64_t v63 = (uint64_t *)*((void *)&v174 + 1);
    uint64_t v64 = 88 * v174;
    do
    {
      re::SkeletalPose::init(v63, &v163);
      v63 += 11;
      v64 -= 88;
    }
    while (v64);
  }
  unint64_t v65 = [v153 rotations];
  unint64_t v66 = [v65 elementCount];
  long long v161 = 0;
  uint64_t v162 = 0;
  uint64_t v160 = 0;

  id v68 = [v153 scales];
  unsigned int v158 = 0;
  uint64_t v159 = 0;
  uint64_t v157 = 0;

  unint64_t v70 = [v153 translations];
  unsigned int v155 = 0;
  uint64_t v156 = 0;
  uint64_t v154 = 0;

  if (v58 != -1)
  {
    unint64_t v72 = 0;
    double v73 = v26;
    BOOL v74 = 1;
    uint64_t v75 = 88;
    while (1)
    {
      BOOL v149 = v74;
      BOOL v76 = [v153 scales];
      uint64_t v77 = v159;
      unint64_t v78 = [v153 scales];
      uint64_t v79 = objc_msgSend(v76, "getFloat3Array:maxCount:atTime:", v77, objc_msgSend(v78, "elementCount"), v73 + (double)v72 * v56);

      uint64_t v80 = [v153 rotations];
      uint64_t v81 = v162;
      uint64_t v82 = [v153 rotations];
      uint64_t v83 = objc_msgSend(v80, "getFloatQuaternionArray:maxCount:atTime:", v81, objc_msgSend(v82, "elementCount"), v73 + (double)v72 * v56);

      uint64_t v84 = [v153 translations];
      uint64_t v85 = v156;
      uint64_t v86 = [v153 translations];
      uint64_t v87 = objc_msgSend(v84, "getFloat3Array:maxCount:atTime:", v85, objc_msgSend(v86, "elementCount"), v73 + (double)v72 * v56);

      if (v79) {
        BOOL v88 = v79 == v83;
      }
      else {
        BOOL v88 = 0;
      }
      if (!v88 || v83 != v87)
      {
        uint64_t v75 = (uint64_t)v153;
        char v134 = [v153 name];
        uint64_t v135 = v134;
        if (v134) {
          uint64_t v136 = (const char *)[v134 UTF8String];
        }
        else {
          uint64_t v136 = "(unnamed)";
        }
        re::DynamicString::format((re::DynamicString *)"Sample %ld in node \"%s\" has: Total Scales = %ld, Total Rotations = %ld, Total Translations = %ld", (re::DynamicString *)&v178, v72, v136, v79, v83, v87);
        StringID v137 = (StringID)v178;
        long long v138 = v179;
        *(unsigned char *)a4 = 0;
        *(void *)(a4 + 8) = 1027;
        *(void *)(a4 + re::FixedArray<CoreIKTransform>::deinit((uint64_t *)this + 16) = &re::AnimationErrorCategory(void)::instance;
        *(StringID *)(a4 + 24) = v137;
        *(_OWORD *)(a4 + 40) = v138;

        BOOL v139 = v149;
        goto LABEL_96;
      }
      if (v23) {
        break;
      }
LABEL_47:
      BOOL v74 = v72 + 1 < v151;
      BOOL v88 = v72++ == v150;
      if (v88) {
        goto LABEL_49;
      }
    }
    uint64_t v90 = 0;
    unint64_t v91 = 0;
    while (1)
    {
      long long v92 = v158;
      if ((unint64_t)v158 <= v91) {
        break;
      }
      long long v92 = (char *)v161;
      if ((unint64_t)v161 <= v91) {
        goto LABEL_82;
      }
      long long v92 = v155;
      if ((unint64_t)v155 <= v91) {
        goto LABEL_83;
      }
      long long v92 = (char *)v174;
      if ((unint64_t)v174 <= v72) {
        goto LABEL_84;
      }
      long long v92 = *(char **)(*((void *)&v174 + 1) + 88 * v72 + 24);
      if ((unint64_t)v92 <= v91) {
        goto LABEL_85;
      }
      uint64_t v93 = *(void *)(v159 + 16 * v91 + 8);
      uint64_t v94 = *(void *)(v162 + 16 * v91);
      uint64_t v95 = *(void *)(v162 + 16 * v91 + 8);
      uint64_t v96 = *(void *)(v156 + 16 * v91);
      uint64_t v97 = *(void *)(v156 + 16 * v91 + 8);
      uint64_t v98 = (void *)(*(void *)(*((void *)&v174 + 1) + 88 * v72 + 32) + v90);
      *uint64_t v98 = *(void *)(v159 + 16 * v91);
      v98[1] = v93;
      v98[2] = v94;
      v98[3] = v95;
      v98[4] = v96;
      v98[5] = v97;
      ++v91;
      v90 += 48;
      if (v23 == v91) {
        goto LABEL_47;
      }
    }
    uint64_t v177 = 0;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    unsigned long long v178 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v188 = 136315906;
    long long v189 = "operator[]";
    __int16 v190 = 1024;
    int v191 = 468;
    __int16 v192 = 2048;
    unint64_t v193 = v91;
    __int16 v194 = 2048;
    unint64_t v195 = (unint64_t)v92;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_82:
    uint64_t v177 = 0;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    unsigned long long v178 = 0u;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v188 = 136315906;
    long long v189 = "operator[]";
    __int16 v190 = 1024;
    int v191 = 468;
    __int16 v192 = 2048;
    unint64_t v193 = v91;
    __int16 v194 = 2048;
    unint64_t v195 = (unint64_t)v92;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_83:
    uint64_t v177 = 0;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    unsigned long long v178 = 0u;
    unint64_t v72 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v188 = 136315906;
    long long v189 = "operator[]";
    __int16 v190 = 1024;
    int v191 = 468;
    __int16 v192 = 2048;
    unint64_t v193 = v91;
    __int16 v194 = 2048;
    unint64_t v195 = (unint64_t)v92;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_84:
    uint64_t v177 = 0;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    unsigned long long v178 = 0u;
    a4 = &_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v188 = 136315906;
    long long v189 = "operator[]";
    __int16 v190 = 1024;
    int v191 = 468;
    __int16 v192 = 2048;
    unint64_t v193 = v72;
    __int16 v194 = 2048;
    unint64_t v195 = (unint64_t)v92;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_85:
    uint64_t v177 = 0;
    long long v181 = 0u;
    long long v182 = 0u;
    long long v179 = 0u;
    long long v180 = 0u;
    unsigned long long v178 = 0u;
    uint64_t v116 = (__int16 *)&_os_log_internal;
    os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    int v188 = 136315906;
    long long v189 = "operator[]";
    __int16 v190 = 1024;
    int v191 = 468;
    __int16 v192 = 2048;
    unint64_t v193 = v91;
    __int16 v194 = 2048;
    unint64_t v195 = (unint64_t)v92;
    _os_log_send_and_compose_impl();
    long long v71 = (_anonymous_namespace_ *)_os_crash_msg();
    __break(1u);
    goto LABEL_86;
  }
LABEL_49:
  if (v59 > v56 * 0.01)
  {
    uint64_t v99 = [v153 scales];
    uint64_t v100 = v159;
    int v101 = [v153 scales];
    objc_msgSend(v99, "getFloat3Array:maxCount:atTime:", v100, objc_msgSend(v101, "elementCount"), v29);

    simd_float4x4 v102 = [v153 rotations];
    uint64_t v103 = v162;
    long long v104 = [v153 rotations];
    objc_msgSend(v102, "getFloatQuaternionArray:maxCount:atTime:", v103, objc_msgSend(v104, "elementCount"), v29);

    __int16 v105 = [v153 translations];
    uint64_t v106 = v156;
    unint64_t v107 = [v153 translations];
    objc_msgSend(v105, "getFloat3Array:maxCount:atTime:", v106, objc_msgSend(v107, "elementCount"), v29);

    if (v23)
    {
      uint64_t v109 = 0;
      for (unint64_t i = 0; i != v23; ++i)
      {
        long long v44 = v158;
        if ((unint64_t)v158 <= i) {
          goto LABEL_115;
        }
        long long v44 = v161;
        if ((unint64_t)v161 <= i) {
          goto LABEL_116;
        }
        long long v44 = v155;
        if ((unint64_t)v155 <= i) {
          goto LABEL_117;
        }
        if (!(void)v174) {
          goto LABEL_118;
        }
        long long v44 = *(const char **)(*((void *)&v174 + 1) + 88 * (v174 - 1) + 24);
        if ((unint64_t)v44 <= i) {
          goto LABEL_119;
        }
        uint64_t v110 = *(void *)(v159 + 16 * i + 8);
        uint64_t v111 = *(void *)(v162 + 16 * i);
        uint64_t v112 = *(void *)(v162 + 16 * i + 8);
        uint64_t v113 = *(void *)(v156 + 16 * i);
        uint64_t v114 = *(void *)(v156 + 16 * i + 8);
        long long v115 = (void *)(*(void *)(*((void *)&v174 + 1) + 88 * (v174 - 1) + 32) + v109);
        void *v115 = *(void *)(v159 + 16 * i);
        v115[1] = v110;
        v115[2] = v111;
        v115[3] = v112;
        v115[4] = v113;
        long long v115[5] = v114;
        v109 += 48;
      }
    }
  }
  uint64_t v116 = &v175;
  uint64_t v117 = v152;
  uint64_t v75 = (uint64_t)v153;
  unint64_t v118 = v152[1];
  unint64_t v119 = v152[2];
  unint64_t v91 = v148;
  if (v119 >= v118)
  {
    unint64_t v23 = v119 + 1;
    if (v118 >= v119 + 1)
    {
LABEL_87:
      uint64_t v117 = v152;
      unint64_t v119 = v152[2];
      goto LABEL_88;
    }
    long long v92 = (char *)v152;
    if (*v152)
    {
      uint64_t v120 = 2 * v118;
      BOOL v88 = v118 == 0;
      unint64_t v121 = 8;
      if (!v88) {
        unint64_t v121 = v120;
      }
      if (v121 <= v23) {
        unint64_t v122 = v23;
      }
      else {
        unint64_t v122 = v121;
      }
      re::DynamicArray<re::SkeletalPoseSampledAnimation>::setCapacity(v152, v122);
      goto LABEL_87;
    }
LABEL_86:
    re::DynamicArray<re::SkeletalPoseSampledAnimation>::setCapacity(v92, v23);
    ++*((_DWORD *)v92 + 6);
    goto LABEL_87;
  }
LABEL_88:
  re::SampledAnimation<re::SkeletalPose>::SampledAnimation(v117[4] + 120 * v119, v167);
  *(void *)uint64_t v140 = &unk_26E6C1190;
  __int16 v141 = *v116;
  *(unsigned char *)(v140 + 114) = *((unsigned char *)v116 + 2);
  *(_WORD *)(v140 + 112) = v141;
  ++v117[2];
  ++*((_DWORD *)v117 + 6);
  __int16 v142 = [(id)v75 name];
  unint64_t v143 = v142;
  if (v142)
  {
    __int16 v142 = (void *)[v142 UTF8String];
    __int16 v144 = (const char *)v142;
  }
  else
  {
    __int16 v144 = "(unnamed)";
  }
  double v145 = re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)(v91 + 120), &v178);
  if ((void)v178)
  {
    if (BYTE8(v178)) {
      (*(void (**)(double))(*(void *)v178 + 40))(v145);
    }
    unsigned long long v178 = 0u;
    long long v179 = 0u;
  }

  *(void *)&unsigned long long v178 = v146;
  re::DynamicArray<unsigned long>::add((void *)(v91 + 40), &v178);
  BOOL v139 = 0;
LABEL_96:
  if (v154 && v155) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v154 + 40))(v154, v156);
  }
  if (v157 && v158) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v157 + 40))(v157, v159);
  }
  if (v160 && v161) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v160 + 40))(v160, v162);
  }
  if (v163) {

  }
  re::FixedArray<re::StringID>::deinit(&v164);
  v167[0] = &unk_26E6C0FD0;
  re::FixedArray<re::SkeletalPose>::deinit((void *)&v173 + 1);
  v167[0] = &unk_26E6BF1F0;
  if ((void)v169)
  {
    if (BYTE8(v169)) {
      (*(void (**)(void, void))(*(void *)v169 + 40))(v169, v170);
    }
    long long v169 = 0u;
    long long v170 = 0u;
    uint64_t v75 = (uint64_t)v153;
  }
  re::StringID::destroyString((re::StringID *)&v168);

  id v7 = v147;
  if (!v139) {
    goto LABEL_112;
  }
LABEL_113:
}